

##file cppcheck-2.8/externals/simplecpp/simplecpp.h

1:
|
47:
48: namespace simplecpp {
49:
50:
51: class Macro ;
52:
|
55:
56: class Location {
57: public:
58: explicit Location ( const std :: vector < std :: string > & f@var1 ) : files@var19 ( f@var1 ) , fileIndex@var20 ( 0 ) , line@var21 ( 1U ) , col@var22 ( 0U ) { }
59:
60: Location ( const Location & loc@var2 ) : files@var19 ( loc@var2 . files@var3 ) , fileIndex@var20 ( loc@var2 . fileIndex@var4 ) , line@var21 ( loc@var2 . line@var5 ) , col@var22 ( loc@var2 . col@var6 ) { }
61:
62: Location & operator= ( const Location & other@var7 ) {
63: if (@expr1073742942 this@expr1119 !=@expr1073742944 &@expr1073742945 other@var7 ) {
64: fileIndex@var20 =@expr1073742946 other@var7 .@expr1073742947 fileIndex@var8 ;
65: line@var21 =@expr1073742948 other@var7 .@expr1073742949 line@var9 ;
66: col@var22 =@expr1073742950 other@var7 .@expr1073742951 col@var10 ;
67: }
68: return *@expr1073742952 this@expr1119 ;
69: }
70:
71:
72: void adjust ( const std :: string & str@var11 ) ;
73:
74: bool operator< ( const Location & rhs@var12 ) const {
75: if (@expr1073742953 fileIndex@var20 !=@expr1073742954 rhs@var12 .@expr1131 fileIndex@var13 ) {
76: return fileIndex@var20 <@expr1073742956 rhs@var12 .@expr1131 fileIndex@var13 ; }
77: if (@expr1073742958 line@var21 !=@expr1073742959 rhs@var12 .@expr1136 line@var14 ) {
78: return line@var21 <@expr1073742961 rhs@var12 .@expr1136 line@var14 ; }
79: return col@var22 <@expr1073742963 rhs@var12 .@expr1073742964 col@var15 ;
80: }
81:
82: bool sameline ( const Location & other@var16 ) const {
83: return fileIndex@var20 ==@expr1073742965 other@var16 .@expr1073742966 fileIndex@var17 &&@expr1073742967 line@var21 ==@expr1073742968 other@var16 .@expr1073742969 line@var18 ;
84: }
85:
86: const std :: string & file ( ) const {
87: return fileIndex@var20 <@expr1073742970 files@var19 .@expr1073742971 size (@expr1073742972 ) ?@expr1073742973 files@var19 [@expr1073742974 fileIndex@var20 ] :@expr1073742975 emptyFileName@var23 ;
88: }
89:
90: const std :: vector < std :: string > & files@var19 ;
91: unsigned int fileIndex@var20 ;
92: unsigned int line@var21 ;
93: unsigned int col@var22 ;
94: private:
95: static const std :: string emptyFileName@var23 ;
96: } ;
97:
|
101:
102: class Token {
103: public:
104: Token ( const std :: string & s@var24 , const Location & loc@var25 ) :
105: location@var44 ( loc@var25 ) , previous@var45 ( nullptr ) , next@var46 ( nullptr ) , string@var57 ( s@var24 ) {
106: flags (@expr1073742976 ) ;
107: }
108:
109: Token ( const Token & tok@var26 ) :
110: macro@var39 ( tok@var26 . macro@var27 ) , op@var40 ( tok@var26 . op@var28 ) , comment@var41 ( tok@var26 . comment@var29 ) , name@var42 ( tok@var26 . name@var30 ) , number@var43 ( tok@var26 . number@var31 ) , location@var44 ( tok@var26 . location@var32 ) , previous@var45 ( nullptr ) , next@var46 ( nullptr ) , string@var57 ( tok@var26 . string@var33 ) , mExpandedFrom@var58 ( tok@var26 . mExpandedFrom@var34 ) {
111: }
112:
113: void flags ( ) {
114: name@var42 =@expr1073742977 (@expr1073742978 std ::@expr1073742979 isalpha (@expr1073742980 static_cast < unsigned char > (@expr1157 string@var57 [@expr1158 0 ] ) ) ||@expr1073742983 string@var57 [@expr1158 0 ] ==@expr1073742985 '_' ||@expr1073742986 string@var57 [@expr1158 0 ] ==@expr1073742988 '$' )
115: &&@expr1073742989 (@expr1073742990 std ::@expr1073742991 memchr (@expr1073742992 string@var57 .@expr1073742993 c_str (@expr1073742994 ) , '\'' , string@var57 .@expr1171 size (@expr1172 ) ) ==@expr1073742997 nullptr ) ;
116: comment@var41 =@expr1073742998 string@var57 .@expr1171 size (@expr1172 ) >@expr1177 1U &&@expr1073743002 string@var57 [@expr1158 0 ] ==@expr1073743004 '/' &&@expr1073743005 (@expr1073743006 string@var57 [@expr1183 1 ] ==@expr1073743008 '/' ||@expr1073743009 string@var57 [@expr1183 1 ] ==@expr1073743011 '*' ) ;
117: number@var43 =@expr1073743012 std ::@expr1189 isdigit (@expr1073743014 static_cast < unsigned char > (@expr1157 string@var57 [@expr1158 0 ] ) ) ||@expr1073743017 (@expr1073743018 string@var57 .@expr1171 size (@expr1172 ) >@expr1177 1U &&@expr1073743022 string@var57 [@expr1158 0 ] ==@expr1073743024 '-' &&@expr1073743025 std ::@expr1189 isdigit (@expr1073743027 static_cast < unsigned char > (@expr1073743028 string@var57 [@expr1183 1 ] ) ) ) ;
118: op@var40 =@expr1073743030 (@expr1073743031 string@var57 .@expr1171 size (@expr1172 ) ==@expr1073743034 1U ) ?@expr1073743035 string@var57 [@expr1158 0 ] :@expr1073743037 '\0' ;
119: }
120:
121: const std :: string & str ( ) const {
122: return string@var57 ;
123: }
124: void setstr ( const std :: string & s@var35 ) {
125: string@var57 =@expr1073743038 s@var35 ;
126: flags (@expr1073743039 ) ;
127: }
128:
129: bool isOneOf ( const char ops@var36 [ ] ) const ;
130: bool startsWithOneOf ( const char c@var37 [ ] ) const ;
131: bool endsWithOneOf ( const char c@var38 [ ] ) const ;
132:
133: std :: string macro@var39 ;
134: char op@var40 ;
135: bool comment@var41 ;
136: bool name@var42 ;
137: bool number@var43 ;
138: Location location@var44 ;
139: Token * previous@var45 ;
140: Token * next@var46 ;
141:
142: const Token * previousSkipComments ( ) const {
143: const Token * tok@var47 ; tok@var47 =@expr1073743040 this@expr1073743041 .@expr1073743042 previous@var45 ;
144: while (@expr1073743043 tok@var47 &&@expr1073743044 tok@var47 .@expr1073743045 comment@var48 ) {
145: tok@var47 =@expr1073743046 tok@var47 .@expr1073743047 previous@var49 ; }
146: return tok@var47 ;
147: }
148:
149: const Token * nextSkipComments ( ) const {
150: const Token * tok@var50 ; tok@var50 =@expr1073743048 this@expr1073743049 .@expr1073743050 next@var46 ;
151: while (@expr1073743051 tok@var50 &&@expr1073743052 tok@var50 .@expr1073743053 comment@var51 ) {
152: tok@var50 =@expr1073743054 tok@var50 .@expr1073743055 next@var52 ; }
153: return tok@var50 ;
154: }
155:
156: void setExpandedFrom ( const Token * tok@var53 , const Macro * m@var54 ) {
157: mExpandedFrom@var58 =@expr1073743056 tok@var53 .@expr1073743057 mExpandedFrom@var55 ;
158: mExpandedFrom@var58 .@expr1073743058 insert (@expr1073743059 m@var54 ) ;
159: }
160: bool isExpandedFrom ( const Macro * m@var56 ) const {
161: return mExpandedFrom@var58 .@expr1073743060 find (@expr1073743061 m@var56 ) !=@expr1073743062 mExpandedFrom@var58 .@expr1073743063 end (@expr1073743064 ) ;
162: }
163:
164: void printAll ( ) const ;
165: void printOut ( ) const ;
166: private:
167: std :: string string@var57 ;
168:
169: std :: set < const Macro * > mExpandedFrom@var58 ;
170:
171:
172: Token & operator= ( const Token & tok@var59 ) ;
173: } ;
174:
175:
176: struct Output {
177: explicit Output ( const std :: vector < std :: string > & files@var60 ) : type@var61 ( ERROR ) , location@var62 ( files@var60 ) { }
178: enum Type {
179: ERROR ,
180: WARNING ,
181: MISSING_HEADER ,
182: INCLUDE_NESTED_TOO_DEEPLY ,
183: SYNTAX_ERROR ,
184: PORTABILITY_BACKSLASH ,
185: UNHANDLED_CHAR_ERROR ,
186: EXPLICIT_INCLUDE_NOT_FOUND
187: } ; enum Type type@var61 ;
188: Location location@var62 ;
189: std :: string msg@var63 ;
190: } ;
191:
|
194:
195: class TokenList {
196: public:
197: explicit TokenList ( std :: vector < std :: string > & filenames@var64 ) ;
198: TokenList ( std :: istream & istr@var65 , std :: vector < std :: string > & filenames@var66 , const std :: string & filename@var67 = std :: string ( ) , std :: list < Output > * outputList@var68 = nullptr ) ;
199: TokenList ( const TokenList & other@var69 ) ;
200:
201: TokenList ( TokenList && other@var70 ) ;
202:
203: ~ TokenList ( ) ;
204: TokenList & operator= ( const TokenList & other@var71 ) ;
205:
206: TokenList & operator= ( TokenList && other@var72 ) ;
207:
208:
209: void clear ( ) ;
210: bool empty ( ) const {
211: return !@expr1073743065 frontToken@var109 ;
212: }
213: void push_back ( Token * tok@var73 ) ;
214:
215: void dump ( ) const ;
216: std :: string stringify ( ) const ;
217:
218: void readfile ( std :: istream & istr@var74 , const std :: string & filename@var75 = std :: string ( ) , std :: list < Output > * outputList@var76 = nullptr ) ;
219: void constFold ( ) ;
220:
221: void removeComments ( ) ;
222:
223: Token * front ( ) {
224: return frontToken@var109 ;
225: }
226:
227: const Token * cfront ( ) const {
228: return frontToken@var109 ;
229: }
230:
231: Token * back ( ) {
232: return backToken@var110 ;
233: }
234:
235: const Token * cback ( ) const {
236: return backToken@var110 ;
237: }
238:
239: void deleteToken ( Token * tok@var77 ) {
240: if (@expr1073743066 !@expr1073743067 tok@var77 ) {
241: return ; }
242: Token * prev@var78 ; prev@var78 =@expr1073743068 tok@var77 .@expr1073743069 previous@var79 ;
243: Token * next@var80 ; next@var80 =@expr1073743070 tok@var77 .@expr1073743071 next@var81 ;
244: if (@expr1073743072 prev@var78 ) {
245: prev@var78 .@expr1073743073 next@var82 =@expr1073743074 next@var80 ; }
246: if (@expr1073743075 next@var80 ) {
247: next@var80 .@expr1073743076 previous@var83 =@expr1073743077 prev@var78 ; }
248: if (@expr1073743078 frontToken@var109 ==@expr1073743079 tok@var77 ) {
249: frontToken@var109 =@expr1073743080 next@var80 ; }
250: if (@expr1073743081 backToken@var110 ==@expr1073743082 tok@var77 ) {
251: backToken@var110 =@expr1073743083 prev@var78 ; }
252: delete tok@var77 ;
253: }
254:
255: void takeTokens ( TokenList & other@var84 ) {
256: if (@expr1073743084 !@expr1073743085 other@var84 .@expr1262 frontToken@var85 ) {
257: return ; }
258: if (@expr1073743087 !@expr1073743088 frontToken@var109 ) {
259: frontToken@var109 =@expr1073743089 other@var84 .@expr1262 frontToken@var85 ;
260: } else {
261: backToken@var110 .@expr1073743091 next@var112 =@expr1073743092 other@var84 .@expr1262 frontToken@var85 ;
262: other@var84 .@expr1262 frontToken@var85 .@expr1073743095 previous@var86 =@expr1073743096 backToken@var110 ;
263: }
264: backToken@var110 =@expr1073743097 other@var84 .@expr1274 backToken@var87 ;
265: other@var84 .@expr1262 frontToken@var85 =@expr1073743100 other@var84 .@expr1274 backToken@var87 =@expr1073743102 nullptr ;
266: }
267:
268:
269: std :: map < std :: string , unsigned long > sizeOfType@var88 ;
270:
271: private:
272: void combineOperators ( ) ;
273:
274: void constFoldUnaryNotPosNeg ( Token * tok@var89 ) ;
275: void constFoldMulDivRem ( Token * tok@var90 ) ;
276: void constFoldAddSub ( Token * tok@var91 ) ;
277: void constFoldShift ( Token * tok@var92 ) ;
278: void constFoldComparison ( Token * tok@var93 ) ;
279: void constFoldBitwise ( Token * tok@var94 ) ;
280: void constFoldLogicalOp ( Token * tok@var95 ) ;
281: void constFoldQuestionOp ( Token * * tok1@var96 ) ;
282:
283: std :: string readUntil ( std :: istream & istr@var97 , const Location & location@var98 , char start@var99 , char end@var100 , std :: list < Output > * outputList@var101 , unsigned int bom@var102 ) ;
284: void lineDirective ( unsigned int fileIndex@var103 , unsigned int line@var104 , Location * location@var105 ) ;
285:
286: std :: string lastLine ( int maxsize@var106 = 100000 ) const ;
287: bool isLastLinePreprocessor ( int maxsize@var107 = 100000 ) const ;
288:
289: unsigned int fileIndex ( const std :: string & filename@var108 ) ;
290:
291: Token * frontToken@var109 ;
292: Token * backToken@var110 ;
293: std :: vector < std :: string > & files@var111 ;
294: } ;
295:
296:
297: struct MacroUsage {
298: explicit MacroUsage ( const std :: vector < std :: string > & f@var113 , bool macroValueKnown_@var114 ) : macroLocation@var116 ( f@var113 ) , useLocation@var117 ( f@var113 ) , macroValueKnown@var118 ( macroValueKnown_@var114 ) { }
299: std :: string macroName@var115 ;
300: Location macroLocation@var116 ;
301: Location useLocation@var117 ;
302: bool macroValueKnown@var118 ;
303: } ;
304:
305:
306: struct IfCond {
307: explicit IfCond ( const Location & location@var119 , const std :: string & E@var120 , long long result@var121 ) : location@var122 ( location@var119 ) , E@var123 ( E@var120 ) , result@var124 ( result@var121 ) { }
308: Location location@var122 ;
309: std :: string E@var123 ;
310: long long result@var124 ;
311: } ;
312:
|
316:
317: struct DUI {
318: DUI ( ) { }
319: std :: list < std :: string > defines@var125 ;
320: std :: set < std :: string > undefined@var126 ;
321: std :: list < std :: string > includePaths@var127 ;
322: std :: list < std :: string > includes@var128 ;
323: std :: string std@var129 ;
324: } ;
325:
326: long long characterLiteralToLL ( const std :: string & str@var130 ) ;
327:
328: std :: map < std :: string , TokenList * > load ( const TokenList & rawtokens@var131 , std :: vector < std :: string > & filenames@var132 , const DUI & dui@var133 , std :: list < Output > * outputList@var134 = nullptr ) ;
329:
|
341:
342: void preprocess ( TokenList & output@var135 , const TokenList & rawtokens@var136 , std :: vector < std :: string > & files@var137 , std :: map < std :: string , TokenList * > & filedata@var138 , const DUI & dui@var139 , std :: list < Output > * outputList@var140 = nullptr , std :: list < MacroUsage > * macroUsage@var141 = nullptr , std :: list < IfCond > * ifCond@var142 = nullptr ) ;
343:
|
346:
347: void cleanup ( std :: map < std :: string , TokenList * > & filedata@var143 ) ;
348:
349:
350: std :: string simplifyPath ( std :: string path@var144 ) ;
351:
352:
353: std :: string convertCygwinToWindowsPath ( const std :: string & cygwinPath@var145 ) ;
354:
355:
356: std :: string getCStdString ( const std :: string & std@var146 ) ;
357:
358:
359: std :: string getCppStdString ( const std :: string & std@var147 ) ;
360: }

##file cppcheck-2.8/externals/simplecpp/simplecpp.cpp

1:
|
50:
51: static bool isHex ( const std :: string & s@var148 )
52: {
53: return s@var148 .@expr1073743103 size (@expr1073743104 ) >@expr1073743105 2 &&@expr1073743106 (@expr1073743107 s@var148 .@expr1284 compare (@expr1073743109 0 , 2 , "0x" ) ==@expr1073743110 0 ||@expr1073743111 s@var148 .@expr1284 compare (@expr1073743113 0 , 2 , "0X" ) ==@expr1073743114 0 ) ;
54: }
55:
56: static bool isOct ( const std :: string & s@var149 )
57: {
58: return s@var149 .@expr1073743115 size (@expr1073743116 ) >@expr1073743117 1 &&@expr1073743118 (@expr1073743119 s@var149 [@expr1073743120 0 ] ==@expr1073743121 '0' ) &&@expr1073743122 (@expr1073743123 s@var149 [@expr1300 1 ] >=@expr1073743125 '0' ) &&@expr1073743126 (@expr1073743127 s@var149 [@expr1300 1 ] <@expr1073743129 '8' ) ;
59: }
60:
61:
62: static bool isStringLiteral_ ( const std :: string & s@var150 )
63: {
64: return s@var150 .@expr1073743130 size (@expr1073743131 ) >@expr1073743132 1 &&@expr1073743133 (@expr1073743134 s@var150 [@expr1073743135 0 ] ==@expr1073743136 '\"' ) &&@expr1073743137 (@expr1073743138 *@expr1073743139 s@var150 .@expr1073743140 rbegin (@expr1073743141 ) ==@expr1073743142 '\"' ) ;
65: }
66:
67:
68: static bool isCharLiteral_ ( const std :: string & s@var151 )
69: {
70:
71:
72: return s@var151 .@expr1073743143 size (@expr1073743144 ) >@expr1073743145 1 &&@expr1073743146 (@expr1073743147 s@var151 [@expr1073743148 0 ] ==@expr1073743149 '\'' ) &&@expr1073743150 (@expr1073743151 *@expr1073743152 s@var151 .@expr1073743153 rbegin (@expr1073743154 ) ==@expr1073743155 '\'' ) ;
73: }
74:
75: static const std :: string DEFINE@var152 ( "define" ) ;
76: static const std :: string UNDEF@var153 ( "undef" ) ;
77:
78: static const std :: string INCLUDE@var154 ( "include" ) ;
79:
80: static const std :: string ERROR@var155 ( "error" ) ;
81: static const std :: string WARNING@var156 ( "warning" ) ;
82:
83: static const std :: string IF@var157 ( "if" ) ;
84: static const std :: string IFDEF@var158 ( "ifdef" ) ;
85: static const std :: string IFNDEF@var159 ( "ifndef" ) ;
86: static const std :: string DEFINED@var160 ( "defined" ) ;
87: static const std :: string ELSE@var161 ( "else" ) ;
88: static const std :: string ELIF@var162 ( "elif" ) ;
89: static const std :: string ENDIF@var163 ( "endif" ) ;
90:
91: static const std :: string PRAGMA@var164 ( "pragma" ) ;
92: static const std :: string ONCE@var165 ( "once" ) ;
93:
94: static const std :: string HAS_INCLUDE@var166 ( "__has_include" ) ;
95:
96: template < class T > static std :: string toString ( T t@var167 )
97: {
98: std ::@expr1073743156 ostringstream ostr@var168 ;
99: ostr@var168 <<@expr1073743157 t@var167 ;
100: return ostr@var168 .@expr1073743158 str (@expr1073743159 ) ;
101: }
102:
103: static long long stringToLL ( const std :: string & s@var169 )
104: {
105: long long ret@var170 ;
106: const bool hex@var171 =@expr1073743162 isHex (@expr1073743163 s@var169 ) ;
107: const bool oct@var172 =@expr1073743164 isOct (@expr1073743165 s@var169 ) ;
108: std ::@expr1073743166 istringstream istr@var173 (@expr1073743167 hex@var171 ?@expr1073743168 s@var169 .@expr1345 substr (@expr1073743170 2 ) :@expr1073743171 oct@var172 ?@expr1073743172 s@var169 .@expr1345 substr (@expr1073743174 1 ) :@expr1073743175 s@var169 ) ;
109: if (@expr1073743176 hex@var171 ) {
110: istr@var173 >>@expr1073743177 std ::@expr1073743178 hex@expr1073743160 ; }
111: else { if (@expr1073743179 oct@var172 ) {
112: istr@var173 >>@expr1073743180 std ::@expr1073743181 oct@expr1073743161 ; } }
113: istr@var173 >>@expr1073743182 ret@var170 ;
114: return ret@var170 ;
115: }
116:
117: static unsigned long long stringToULL ( const std :: string & s@var174 )
118: {
119: unsigned long long ret@var175 ;
120: const bool hex@var176 =@expr1073743185 isHex (@expr1073743186 s@var174 ) ;
121: const bool oct@var177 =@expr1073743187 isOct (@expr1073743188 s@var174 ) ;
122: std ::@expr1073743189 istringstream istr@var178 (@expr1073743190 hex@var176 ?@expr1073743191 s@var174 .@expr1368 substr (@expr1073743193 2 ) :@expr1073743194 oct@var177 ?@expr1073743195 s@var174 .@expr1368 substr (@expr1073743197 1 ) :@expr1073743198 s@var174 ) ;
123: if (@expr1073743199 hex@var176 ) {
124: istr@var178 >>@expr1073743200 std ::@expr1073743201 hex@expr1073743183 ; }
125: else { if (@expr1073743202 oct@var177 ) {
126: istr@var178 >>@expr1073743203 std ::@expr1073743204 oct@expr1073743184 ; } }
127: istr@var178 >>@expr1073743205 ret@var175 ;
128: return ret@var175 ;
129: }
130:
131: static bool startsWith ( const std :: string & str@var179 , const std :: string & s@var180 )
132: {
133: return (@expr1073743206 str@var179 .@expr1073743207 size (@expr1073743208 ) >=@expr1073743209 s@var180 .@expr1386 size (@expr1387 ) &&@expr1073743212 str@var179 .@expr1073743213 compare (@expr1073743214 0 , s@var180 .@expr1386 size (@expr1387 ) , s@var180 ) ==@expr1073743217 0 ) ;
134: }
135:
136: static bool endsWith ( const std :: string & s@var181 , const std :: string & e@var182 )
137: {
138: return (@expr1073743218 s@var181 .@expr1395 size (@expr1396 ) >=@expr1073743221 e@var182 .@expr1398 size (@expr1399 ) &&@expr1073743224 s@var181 .@expr1073743225 compare (@expr1073743226 s@var181 .@expr1395 size (@expr1396 ) -@expr1073743229 e@var182 .@expr1398 size (@expr1399 ) , e@var182 .@expr1398 size (@expr1399 ) , e@var182 ) ==@expr1073743234 0 ) ;
139: }
140:
141: static bool sameline ( const simplecpp :: Token * tok1@var183 , const simplecpp :: Token * tok2@var184 )
142: {
143: return tok1@var183 &&@expr1073743235 tok2@var184 &&@expr1073743236 tok1@var183 .@expr1073743237 location@var185 .@expr1073743238 sameline (@expr1073743239 tok2@var184 .@expr1073743240 location@var186 ) ;
144: }
145:
146: static bool isAlternativeBinaryOp ( const simplecpp :: Token * tok@var187 , const std :: string & alt@var188 )
147: {
148: return (@expr1417 tok@var187 .@expr1073743242 name@var189 &&@expr1073743243
149: tok@var187 .@expr1073743244 str (@expr1073743245 ) ==@expr1073743246 alt@var188 &&@expr1073743247
150: tok@var187 .@expr1424 previous@var190 &&@expr1073743249
151: tok@var187 .@expr1426 next@var191 &&@expr1073743251
152: (@expr1417 tok@var187 .@expr1424 previous@var190 .@expr1073743254 number@var192 ||@expr1073743255 tok@var187 .@expr1424 previous@var190 .@expr1073743257 name@var193 ||@expr1073743258 tok@var187 .@expr1424 previous@var190 .@expr1073743260 op@var194 ==@expr1073743261 ')' ) &&@expr1073743262
153: (@expr1417 tok@var187 .@expr1426 next@var191 .@expr1073743265 number@var195 ||@expr1073743266 tok@var187 .@expr1426 next@var191 .@expr1073743268 name@var196 ||@expr1073743269 tok@var187 .@expr1426 next@var191 .@expr1073743271 op@var197 ==@expr1073743272 '(' ) ) ;
154: }
155:
156: static bool isAlternativeUnaryOp ( const simplecpp :: Token * tok@var198 , const std :: string & alt@var199 )
157: {
158: return (@expr1449 (@expr1449 tok@var198 .@expr1073743275 name@var200 &&@expr1073743276 tok@var198 .@expr1073743277 str (@expr1073743278 ) ==@expr1073743279 alt@var199 ) &&@expr1073743280
159: (@expr1449 !@expr1073743282 tok@var198 .@expr1459 previous@var201 ||@expr1073743284 tok@var198 .@expr1459 previous@var201 .@expr1073743286 op@var202 ==@expr1073743287 '(' ) &&@expr1073743288
160: (@expr1449 tok@var198 .@expr1466 next@var203 &&@expr1073743291 (@expr1449 tok@var198 .@expr1466 next@var203 .@expr1073743294 name@var204 ||@expr1073743295 tok@var198 .@expr1466 next@var203 .@expr1073743297 number@var205 ) ) ) ;
161: }
162:
163: static std :: string replaceAll ( std :: string s@var206 , const std :: string & from@var207 , const std :: string & to@var208 )
164: {
165: for (@expr1073743299 unsigned long pos@var209 =@expr1073743300 s@var206 .@expr1477 find (@expr1073743302 from@var207 ) ; pos@var209 !=@expr1073743303 std ::@expr1073743304 string ::@expr1073743305 npos@expr1073743298 ; pos@var209 =@expr1073743306 s@var206 .@expr1477 find (@expr1073743308 from@var207 , pos@var209 +@expr1073743309 to@var208 .@expr1073743310 size (@expr1073743311 ) ) ) {
166: s@var206 .@expr1073743312 replace (@expr1073743313 pos@var209 , from@var207 .@expr1073743314 size (@expr1073743315 ) , to@var208 ) ; }
167: return s@var206 ;
168: }
169:
170: const std :: string simplecpp :: Location :: emptyFileName@var23 ;
171:
172: void simplecpp :: Location :: adjust ( const std :: string & str@var210 )
173: {
174: if (@expr1073743316 strpbrk (@expr1073743317 str@var210 .@expr1073743318 c_str (@expr1073743319 ) , "\r\n" ) ==@expr1073743320 nullptr ) {
175: col@var22 +=@expr1073743321 str@var210 .@expr1498 size (@expr1499 ) ;
176: return ;
177: }
178:
179: for (@expr1073743324 unsigned long i@var211 =@expr1073743325 0U ; i@var211 <@expr1073743326 str@var210 .@expr1498 size (@expr1499 ) ; ++@expr1073743329 i@var211 ) {
180: col@var22 ++@expr1073743330 ;
181: if (@expr1073743331 str@var210 [@expr1508 i@var211 ] ==@expr1073743333 '\n' ||@expr1073743334 str@var210 [@expr1508 i@var211 ] ==@expr1512 '\r' ) {
182: col@var22 =@expr1073743337 1 ;
183: line@var21 ++@expr1073743338 ;
184: if (@expr1073743339 str@var210 [@expr1508 i@var211 ] ==@expr1512 '\r' &&@expr1073743342 (@expr1073743343 i@var211 +@expr1520 1 ) <@expr1073743345 str@var210 .@expr1498 size (@expr1499 ) &&@expr1073743348 str@var210 [@expr1073743349 i@var211 +@expr1520 1 ] ==@expr1073743351 '\n' ) {
185: ++@expr1073743352 i@var211 ; }
186: }
187: }
188: }
189:
190: bool simplecpp :: Token :: isOneOf ( const char ops@var212 [ ] ) const
191: {
192: return (@expr1529 op@var40 !=@expr1073743354 '\0' ) &&@expr1073743355 (@expr1529 std ::@expr1073743357 strchr (@expr1073743358 ops@var212 , op@var40 ) !=@expr1073743359 nullptr ) ;
193: }
194:
195: bool simplecpp :: Token :: startsWithOneOf ( const char c@var213 [ ] ) const
196: {
197: return std ::@expr1073743360 strchr (@expr1073743361 c@var213 , string@var57 [@expr1073743362 0 ] ) !=@expr1073743363 nullptr ;
198: }
199:
200: bool simplecpp :: Token :: endsWithOneOf ( const char c@var214 [ ] ) const
201: {
202: return std ::@expr1073743364 strchr (@expr1073743365 c@var214 , string@var57 [@expr1073743366 string@var57 .@expr1073743367 size (@expr1073743368 ) -@expr1073743369 1U ] ) !=@expr1073743370 nullptr ;
203: }
204:
205: void simplecpp :: Token :: printAll ( ) const
206: {
207: const Token * tok@var215 ; tok@var215 =@expr1073743373 this@expr1073743374 ;
208: while (@expr1073743375 tok@var215 .@expr1552 previous@var216 ) {
209: tok@var215 =@expr1073743377 tok@var215 .@expr1552 previous@var216 ; }
210: for (@expr1073743379 ; tok@var215 ; tok@var215 =@expr1073743380 tok@var215 .@expr1073743381 next@var217 ) {
211: if (@expr1073743382 tok@var215 .@expr1552 previous@var216 ) {
212: std ::@expr1560 cout@expr1547 <<@expr1073743385 (@expr1073743386 sameline (@expr1073743387 tok@var215 , tok@var215 .@expr1552 previous@var216 ) ?@expr1073743389 ' ' :@expr1073743390 '\n' ) ;
213: }
214: std ::@expr1560 cout@expr1547 <<@expr1073743392 tok@var215 .@expr1073743393 str (@expr1073743394 ) ;
215: }
216: std ::@expr1560 cout@expr1547 <<@expr1073743396 std ::@expr1073743397 endl@expr1073743372 ;
217: }
218:
219: void simplecpp :: Token :: printOut ( ) const
220: {
221: for (@expr1073743400 const Token *@expr1073743401 tok@var218 =@expr1073743402 this@expr1579 ; tok@var218 ; tok@var218 =@expr1073743404 tok@var218 .@expr1073743405 next@var219 ) {
222: if (@expr1073743406 tok@var218 !=@expr1073743407 this@expr1579 ) {
223: std ::@expr1584 cout@expr1574 <<@expr1073743409 (@expr1073743410 sameline (@expr1073743411 tok@var218 , tok@var218 .@expr1073743412 previous@var220 ) ?@expr1073743413 ' ' :@expr1073743414 '\n' ) ;
224: }
225: std ::@expr1584 cout@expr1574 <<@expr1073743416 tok@var218 .@expr1073743417 str (@expr1073743418 ) ;
226: }
227: std ::@expr1584 cout@expr1574 <<@expr1073743420 std ::@expr1073743421 endl@expr1073743399 ;
228: }
229:
230: simplecpp :: TokenList :: TokenList ( std :: vector < std :: string > & filenames@var221 ) : frontToken@var109 ( nullptr ) , backToken@var110 ( nullptr ) , files@var111 ( filenames@var221 ) { }
231:
232: simplecpp :: TokenList :: TokenList ( std :: istream & istr@var222 , std :: vector < std :: string > & filenames@var223 , const std :: string & filename@var224 , OutputList * outputList@var225 )
233: : frontToken@var109 ( nullptr ) , backToken@var110 ( nullptr ) , files@var111 ( filenames@var223 )
234: {
235: readfile (@expr1073743422 istr@var222 , filename@var224 , outputList@var225 ) ;
236: }
237:
238: simplecpp :: TokenList :: TokenList ( const TokenList & other@var226 ) : frontToken@var109 ( nullptr ) , backToken@var110 ( nullptr ) , files@var111 ( other@var226 . files@var227 )
239: {
240: *@expr1073743423 this@expr1073743424 =@expr1073743425 other@var226 ;
241: }
242:
243:
244: simplecpp :: TokenList :: TokenList ( TokenList && other@var228 ) : TokenList ( other@var228 )
245: {
246: *@expr1073743426 this@expr1073743427 =@expr1073743428 std ::@expr1073743429 move (@expr1073743430 other@var228 ) ;
247: }
248:
249:
250: simplecpp :: TokenList :: ~ TokenList ( )
251: {
252: clear (@expr1073743431 ) ;
253: }
254:
255: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( const TokenList & other@var229 )
256: {
257: if (@expr1073743432 this@expr1609 !=@expr1073743434 &@expr1073743435 other@var229 ) {
258: clear (@expr1073743436 ) ;
259: files@var111 =@expr1073743437 other@var229 .@expr1073743438 files@var230 ;
260: for (@expr1073743439 const Token *@expr1073743440 tok@var231 =@expr1073743441 other@var229 .@expr1073743442 cfront (@expr1073743443 ) ; tok@var231 ; tok@var231 =@expr1073743444 tok@var231 .@expr1073743445 next@var232 ) {
261: push_back (@expr1073743446 new Token (@expr1073743447 *@expr1073743448 tok@var231 ) ) ; }
262: sizeOfType@var88 =@expr1073743449 other@var229 .@expr1073743450 sizeOfType@var233 ;
263: }
264: return *@expr1073743451 this@expr1609 ;
265: }
266:
267:
268: simplecpp :: TokenList & simplecpp :: TokenList :: operator= ( TokenList && other@var234 )
269: {
270: if (@expr1073743452 this@expr1629 !=@expr1073743454 &@expr1073743455 other@var234 ) {
271: clear (@expr1073743456 ) ;
272: frontToken@var109 =@expr1073743457 other@var234 .@expr1634 frontToken@var235 ;
273: other@var234 .@expr1634 frontToken@var235 =@expr1073743460 nullptr ;
274: backToken@var110 =@expr1073743461 other@var234 .@expr1638 backToken@var236 ;
275: other@var234 .@expr1638 backToken@var236 =@expr1073743464 nullptr ;
276: files@var111 =@expr1073743465 other@var234 .@expr1073743466 files@var237 ;
277: sizeOfType@var88 =@expr1073743467 std ::@expr1073743468 move (@expr1073743469 other@var234 .@expr1073743470 sizeOfType@var238 ) ;
278: }
279: return *@expr1073743471 this@expr1629 ;
280: }
281:
282:
283: void simplecpp :: TokenList :: clear ( )
284: {
285: backToken@var110 =@expr1073743472 nullptr ;
286: while (@expr1073743473 frontToken@var109 ) {
287: Token * next@var239 ; next@var239 =@expr1073743474 frontToken@var109 .@expr1073743475 next@var1118 ;
288: delete frontToken@var109 ;
289: frontToken@var109 =@expr1073743476 next@var239 ;
290: }
291: sizeOfType@var88 .@expr1073743477 clear (@expr1073743478 ) ;
292: }
293:
294: void simplecpp :: TokenList :: push_back ( Token * tok@var240 )
295: {
296: if (@expr1073743479 !@expr1073743480 frontToken@var109 ) {
297: frontToken@var109 =@expr1073743481 tok@var240 ; }
298: else {
299: backToken@var110 .@expr1073743482 next@var1119 =@expr1073743483 tok@var240 ; }
300: tok@var240 .@expr1073743484 previous@var241 =@expr1073743485 backToken@var110 ;
301: backToken@var110 =@expr1073743486 tok@var240 ;
302: }
303:
304: void simplecpp :: TokenList :: dump ( ) const
305: {
306: std ::@expr1073743489 cout@expr1073743487 <<@expr1073743490 stringify (@expr1073743491 ) <<@expr1073743492 std ::@expr1073743493 endl@expr1073743488 ;
307: }
308:
309: std :: string simplecpp :: TokenList :: stringify ( ) const
310: {
311: std ::@expr1073743494 ostringstream ret@var242 ;
312: Location loc@var243 (@expr1073743495 files@var111 ) ;
313: for (@expr1073743496 const Token *@expr1073743497 tok@var244 =@expr1073743498 cfront (@expr1073743499 ) ; tok@var244 ; tok@var244 =@expr1073743500 tok@var244 .@expr1073743501 next@var245 ) {
314: if (@expr1073743502 tok@var244 .@expr1679 location@var246 .@expr1680 line@var247 <@expr1073743505 loc@var243 .@expr1682 line@var248 ||@expr1073743507 tok@var244 .@expr1679 location@var246 .@expr1073743509 fileIndex@var249 !=@expr1073743510 loc@var243 .@expr1073743511 fileIndex@var250 ) {
315: ret@var242 <<@expr1073743512 "\n#line " <<@expr1073743513 tok@var244 .@expr1679 location@var246 .@expr1680 line@var247 <<@expr1073743516 " \"" <<@expr1073743517 tok@var244 .@expr1679 location@var246 .@expr1073743519 file (@expr1073743520 ) <<@expr1073743521 "\"\n" ;
316: loc@var243 =@expr1073743522 tok@var244 .@expr1679 location@var246 ;
317: }
318:
319: while (@expr1073743524 tok@var244 .@expr1679 location@var246 .@expr1680 line@var247 >@expr1073743527 loc@var243 .@expr1682 line@var248 ) {
320: ret@var242 <<@expr1073743529 '\n' ;
321: loc@var243 .@expr1682 line@var248 ++@expr1073743531 ;
322: }
323:
324: if (@expr1073743532 sameline (@expr1073743533 tok@var244 .@expr1073743534 previous@var251 , tok@var244 ) ) {
325: ret@var242 <<@expr1073743535 ' ' ; }
326:
327: ret@var242 <<@expr1073743536 tok@var244 .@expr1713 str (@expr1714 ) ;
328:
329: loc@var243 .@expr1073743539 adjust (@expr1073743540 tok@var244 .@expr1713 str (@expr1714 ) ) ;
330: }
331:
332: return ret@var242 .@expr1073743543 str (@expr1073743544 ) ;
333: }
334:
335: static unsigned char readChar ( std :: istream & istr@var252 , unsigned int bom@var253 )
336: {
337: unsigned char ch@var254 ; ch@var254 =@expr1073743545 static_cast < unsigned char > (@expr1722 istr@var252 .@expr1723 get (@expr1724 ) ) ;
338:
339:
340:
341: if (@expr1725 bom@var253 ==@expr1726 0xfeff ||@expr1727 bom@var253 ==@expr1728 0xfffe ) {
342: const unsigned char ch2@var255 =@expr1073743553 static_cast < unsigned char > (@expr1722 istr@var252 .@expr1723 get (@expr1724 ) ) ;
343: const int ch16@var256 =@expr1073743557 (@expr1073743558 bom@var253 ==@expr1726 0xfeff ) ?@expr1073743560 (@expr1073743561 ch@var254 <<@expr1073743562 8 |@expr1073743563 ch2@var255 ) :@expr1073743564 (@expr1073743565 ch2@var255 <<@expr1073743566 8 |@expr1073743567 ch@var254 ) ;
344: ch@var254 =@expr1073743568 static_cast < unsigned char > (@expr1073743569 (@expr1073743570 ch16@var256 >=@expr1073743571 0x80 ) ?@expr1073743572 0xff :@expr1073743573 ch16@var256 ) ;
345: }
346:
347:
348: if (@expr1073743574 ch@var254 ==@expr1073743575 '\r' ) {
349: ch@var254 =@expr1073743576 '\n' ;
350: if (@expr1073743577 bom@var253 ==@expr1073743578 0 &&@expr1073743579 static_cast < char > (@expr1073743580 istr@var252 .@expr1073743581 peek (@expr1073743582 ) ) ==@expr1073743583 '\n' ) {
351: (@expr1073743584 void ) istr@var252 .@expr1723 get (@expr1724 ) ; }
352: else { if (@expr1725 bom@var253 ==@expr1726 0xfeff ||@expr1727 bom@var253 ==@expr1728 0xfffe ) {
353: int c1@var257 ; c1@var257 =@expr1073743591 istr@var252 .@expr1723 get (@expr1724 ) ;
354: int c2@var258 ; c2@var258 =@expr1073743594 istr@var252 .@expr1723 get (@expr1724 ) ;
355: int ch16@var259 ; ch16@var259 =@expr1073743597 (@expr1073743598 bom@var253 ==@expr1726 0xfeff ) ?@expr1073743600 (@expr1073743601 c1@var257 <<@expr1073743602 8 |@expr1073743603 c2@var258 ) :@expr1073743604 (@expr1073743605 c2@var258 <<@expr1073743606 8 |@expr1073743607 c1@var257 ) ;
356: if (@expr1073743608 ch16@var259 !=@expr1073743609 '\n' ) {
357: istr@var252 .@expr1786 unget (@expr1787 ) ;
358: istr@var252 .@expr1786 unget (@expr1787 ) ;
359: }
360: } }
361: }
362:
363: return ch@var254 ;
364: }
365:
366: static unsigned char peekChar ( std :: istream & istr@var260 , unsigned int bom@var261 )
367: {
368: unsigned char ch@var262 ; ch@var262 =@expr1073743614 static_cast < unsigned char > (@expr1791 istr@var260 .@expr1792 peek (@expr1793 ) ) ;
369:
370:
371:
372: if (@expr1073743618 bom@var261 ==@expr1795 0xfeff ||@expr1073743620 bom@var261 ==@expr1073743621 0xfffe ) {
373: (@expr1073743622 void ) istr@var260 .@expr1073743623 get (@expr1073743624 ) ;
374: const unsigned char ch2@var263 =@expr1073743625 static_cast < unsigned char > (@expr1791 istr@var260 .@expr1792 peek (@expr1793 ) ) ;
375: istr@var260 .@expr1073743629 unget (@expr1073743630 ) ;
376: const int ch16@var264 =@expr1073743631 (@expr1073743632 bom@var261 ==@expr1795 0xfeff ) ?@expr1073743634 (@expr1073743635 ch@var262 <<@expr1073743636 8 |@expr1073743637 ch2@var263 ) :@expr1073743638 (@expr1073743639 ch2@var263 <<@expr1073743640 8 |@expr1073743641 ch@var262 ) ;
377: ch@var262 =@expr1073743642 static_cast < unsigned char > (@expr1073743643 (@expr1073743644 ch16@var264 >=@expr1073743645 0x80 ) ?@expr1073743646 0xff :@expr1073743647 ch16@var264 ) ;
378: }
379:
380:
381: if (@expr1073743648 ch@var262 ==@expr1073743649 '\r' ) {
382: ch@var262 =@expr1073743650 '\n' ; }
383:
384: return ch@var262 ;
385: }
386:
387: static void ungetChar ( std :: istream & istr@var265 , unsigned int bom@var266 )
388: {
389: istr@var265 .@expr1827 unget (@expr1828 ) ;
390: if (@expr1073743653 bom@var266 ==@expr1073743654 0xfeff ||@expr1073743655 bom@var266 ==@expr1073743656 0xfffe ) {
391: istr@var265 .@expr1827 unget (@expr1828 ) ; }
392: }
393:
394: static unsigned short getAndSkipBOM ( std :: istream & istr@var267 )
395: {
396: const int ch1@var268 =@expr1073743659 istr@var267 .@expr1836 peek (@expr1837 ) ;
397:
398:
399: if (@expr1073743662 ch1@var268 >=@expr1073743663 0xfe ) {
400: unsigned short bom@var269 ; bom@var269 =@expr1073743664 static_cast < unsigned char > (@expr1841 istr@var267 .@expr1842 get (@expr1843 ) ) <<@expr1073743668 8 ;
401: if (@expr1073743669 istr@var267 .@expr1836 peek (@expr1837 ) >=@expr1073743672 0xfe ) {
402: return bom@var269 |@expr1073743673 static_cast < unsigned char > (@expr1841 istr@var267 .@expr1842 get (@expr1843 ) ) ; }
403: istr@var267 .@expr1853 unget (@expr1854 ) ;
404: return 0 ;
405: }
406:
407:
408: if (@expr1073743679 ch1@var268 ==@expr1073743680 0xef ) {
409: (@expr1857 void ) istr@var267 .@expr1842 get (@expr1843 ) ;
410: if (@expr1073743684 istr@var267 .@expr1842 get (@expr1843 ) ==@expr1073743687 0xbb &&@expr1073743688 istr@var267 .@expr1836 peek (@expr1837 ) ==@expr1073743691 0xbf ) {
411: (@expr1857 void ) istr@var267 .@expr1842 get (@expr1843 ) ;
412: } else {
413: istr@var267 .@expr1853 unget (@expr1854 ) ;
414: istr@var267 .@expr1853 unget (@expr1854 ) ;
415: }
416: }
417:
418: return 0 ;
419: }
420:
421: static bool isNameChar ( unsigned char ch@var270 )
422: {
423: return std ::@expr1073743699 isalnum (@expr1073743700 ch@var270 ) ||@expr1073743701 ch@var270 ==@expr1073743702 '_' ||@expr1073743703 ch@var270 ==@expr1073743704 '$' ;
424: }
425:
426: static std :: string escapeString ( const std :: string & str@var271 )
427: {
428: std ::@expr1073743705 ostringstream ostr@var272 ;
429: ostr@var272 <<@expr1882 '\"' ;
430: for (@expr1073743707 unsigned long i@var273 =@expr1073743708 1U ; i@var273 <@expr1073743709 str@var271 .@expr1073743710 size (@expr1073743711 ) -@expr1073743712 1 ; ++@expr1073743713 i@var273 ) {
431: char c@var274 ; c@var274 =@expr1073743714 str@var271 [@expr1073743715 i@var273 ] ;
432: if (@expr1073743716 c@var274 ==@expr1073743717 '\\' ||@expr1073743718 c@var274 ==@expr1073743719 '\"' ||@expr1073743720 c@var274 ==@expr1073743721 '\'' ) {
433: ostr@var272 <<@expr1073743722 '\\' ; }
434: ostr@var272 <<@expr1073743723 c@var274 ;
435: }
436: ostr@var272 <<@expr1882 '\"' ;
437: return ostr@var272 .@expr1073743725 str (@expr1073743726 ) ;
438: }
439:
440: static void portabilityBackslash ( simplecpp :: OutputList * outputList@var275 , const std :: vector < std :: string > & files@var276 , const simplecpp :: Location & location@var277 )
441: {
442: if (@expr1073743727 !@expr1073743728 outputList@var275 ) {
443: return ; }
444: simplecpp ::@expr1073743729 Output err@var278 (@expr1073743730 files@var276 ) ;
445: err@var278 .@expr1073743731 type@var279 =@expr1073743732 simplecpp ::@expr1073743733 Output ::@expr1073743734 PORTABILITY_BACKSLASH ;
446: err@var278 .@expr1073743735 location@var280 =@expr1073743736 location@var277 ;
447: err@var278 .@expr1073743737 msg@var281 =@expr1073743738 "Combination 'backslash space newline' is not portable." ;
448: outputList@var275 .@expr1073743739 push_back (@expr1073743740 err@var278 ) ;
449: }
450:
451: static bool isStringLiteralPrefix ( const std :: string & str@var282 )
452: {
453: return str@var282 ==@expr1073743741 "u" ||@expr1073743742 str@var282 ==@expr1073743743 "U" ||@expr1073743744 str@var282 ==@expr1073743745 "L" ||@expr1073743746 str@var282 ==@expr1073743747 "u8" ||@expr1073743748
454: str@var282 ==@expr1073743749 "R" ||@expr1073743750 str@var282 ==@expr1073743751 "uR" ||@expr1073743752 str@var282 ==@expr1073743753 "UR" ||@expr1073743754 str@var282 ==@expr1073743755 "LR" ||@expr1073743756 str@var282 ==@expr1073743757 "u8R" ;
455: }
456:
457: void simplecpp :: TokenList :: lineDirective ( unsigned int fileIndex@var283 , unsigned int line@var284 , Location * location@var285 )
458: {
459: if (@expr1073743758 fileIndex@var283 !=@expr1073743759 location@var285 .@expr1936 fileIndex@var286 ||@expr1073743761 line@var284 >=@expr1073743762 location@var285 .@expr1939 line@var287 ) {
460: location@var285 .@expr1936 fileIndex@var286 =@expr1073743765 fileIndex@var283 ;
461: location@var285 .@expr1939 line@var287 =@expr1073743767 line@var284 ;
462: return ;
463: }
464:
465: if (@expr1073743768 line@var284 +@expr1073743769 2 >=@expr1073743770 location@var285 .@expr1939 line@var287 ) {
466: location@var285 .@expr1939 line@var287 =@expr1073743773 line@var284 ;
467: while (@expr1073743774 cback (@expr1073743775 ) .@expr1073743776 op@var1120 !=@expr1073743777 '#' ) {
468: deleteToken (@expr1954 back (@expr1955 ) ) ; }
469: deleteToken (@expr1954 back (@expr1955 ) ) ;
470: return ;
471: }
472: }
473:
474: static const std :: string COMMENT_END@var288 ( "*/" ) ;
475:
476: void simplecpp :: TokenList :: readfile ( std :: istream & istr@var289 , const std :: string & filename@var290 , OutputList * outputList@var291 )
477: {
478: std ::@expr1073743791 stack < simplecpp ::@expr1968 Location > loc@var292 ;
479:
480: unsigned int multiline@var293 ; multiline@var293 =@expr1073743793 0U ;
481:
482: const Token * oldLastToken@var294 ; oldLastToken@var294 =@expr1073743794 nullptr ;
483:
484: const unsigned short bom@var295 =@expr1073743795 getAndSkipBOM (@expr1073743796 istr@var289 ) ;
485:
486: Location location@var296 (@expr1073743797 files@var111 ) ;
487: location@var296 .@expr1974 fileIndex@var297 =@expr1073743799 fileIndex (@expr1073743800 filename@var290 ) ;
488: location@var296 .@expr1977 line@var298 =@expr1073743802 1U ;
489: location@var296 .@expr1979 col@var299 =@expr1073743804 1U ;
490: while (@expr1981 istr@var289 .@expr1982 good (@expr1983 ) ) {
491: unsigned char ch@var300 ; ch@var300 =@expr1073743808 readChar (@expr1985 istr@var289 , bom@var295 ) ;
492: if (@expr1073743810 !@expr1987 istr@var289 .@expr1982 good (@expr1983 ) ) {
493: break ; }
494: if (@expr1073743814 ch@var300 <@expr1073743815 ' ' &&@expr1073743816 ch@var300 !=@expr1073743817 '\t' &&@expr1073743818 ch@var300 !=@expr1995 '\n' &&@expr1073743820 ch@var300 !=@expr1997 '\r' ) {
495: ch@var300 =@expr1073743822 ' ' ; }
496:
497: if (@expr1073743823 ch@var300 >=@expr1073743824 0x80 ) {
498: if (@expr2001 outputList@var291 ) {
499: simplecpp ::@expr1073743826 Output err@var301 (@expr1073743827 files@var111 ) ;
500: err@var301 .@expr1073743828 type@var302 =@expr1073743829 simplecpp ::@expr1073743830 Output ::@expr1073743831 UNHANDLED_CHAR_ERROR ;
501: err@var301 .@expr1073743832 location@var303 =@expr1073743833 location@var296 ;
502: std ::@expr1073743834 ostringstream s@var304 ;
503: s@var304 <<@expr1073743835 static_cast < int > (@expr1073743836 ch@var300 ) ;
504: err@var301 .@expr1073743837 msg@var305 =@expr1073743838 "The code contains unhandled character(s) (character code=" +@expr1073743839 s@var304 .@expr1073743840 str (@expr1073743841 ) +@expr1073743842 "). Neither unicode nor extended ascii is supported." ;
505: outputList@var291 .@expr2019 push_back (@expr1073743844 err@var301 ) ;
506: }
507: clear (@expr1073743845 ) ;
508: return ;
509: }
510:
511: if (@expr1073743846 ch@var300 ==@expr2023 '\n' ) {
512: if (@expr1073743848 cback (@expr2025 ) &&@expr1073743850 cback (@expr2025 ) .@expr1073743852 op@expr1073743782 ==@expr1073743853 '\\' ) {
513: if (@expr1073743854 location@var296 .@expr1979 col@var299 >@expr1073743856 cback (@expr2025 ) .@expr2034 location .@expr2035 col@expr1959 +@expr1073743860 1U ) {
514: portabilityBackslash (@expr1073743861 outputList@var291 , files@var111 , cback (@expr2025 ) .@expr2034 location@expr1073743784 ) ; }
515: ++@expr1073743864 multiline@var293 ;
516: deleteToken (@expr1073743865 back (@expr2042 ) ) ;
517: } else {
518: location@var296 .@expr1977 line@var298 +=@expr1073743868 multiline@var293 +@expr1073743869 1 ;
519: multiline@var293 =@expr1073743870 0U ;
520: }
521: if (@expr1073743871 !@expr1073743872 multiline@var293 ) {
522: location@var296 .@expr1979 col@var299 =@expr1073743874 1 ; }
523:
524: if (@expr1073743875 oldLastToken@var294 !=@expr1073743876 cback (@expr2025 ) ) {
525: oldLastToken@var294 =@expr1073743878 cback (@expr2025 ) ;
526: if (@expr1073743880 !@expr1073743881 isLastLinePreprocessor (@expr1073743882 ) ) {
527: continue ; }
528: const std ::@expr1073743883 string lastline@var306 (@expr1073743884 lastLine (@expr2061 ) ) ;
529: if (@expr1073743886 lastline@var306 ==@expr1073743887 "# file %str%" ) {
530: const Token * strtok@var307 ; strtok@var307 =@expr1073743888 cback (@expr2025 ) ;
531: while (@expr1073743890 strtok@var307 .@expr1073743891 comment@var308 ) {
532: strtok@var307 =@expr1073743892 strtok@var307 .@expr1073743893 previous@var309 ; }
533: loc@var292 .@expr1073743894 push (@expr1073743895 location@var296 ) ;
534: location@var296 .@expr1974 fileIndex@var297 =@expr1073743897 fileIndex (@expr1073743898 strtok@var307 .@expr2075 str (@expr2076 ) .@expr1073743901 substr (@expr1073743902 1U , strtok@var307 .@expr2075 str (@expr2076 ) .@expr1073743905 size (@expr1073743906 ) -@expr1073743907 2U ) ) ;
535: location@var296 .@expr1977 line@var298 =@expr1073743909 1U ;
536: } else { if (@expr1073743910 lastline@var306 ==@expr1073743911 "# line %num%" ) {
537: const Token * numtok@var310 ; numtok@var310 =@expr1073743912 cback (@expr2025 ) ;
538: while (@expr1073743914 numtok@var310 .@expr1073743915 comment@var311 ) {
539: numtok@var310 =@expr1073743916 numtok@var310 .@expr1073743917 previous@var312 ; }
540: lineDirective (@expr1073743918 location@var296 .@expr1974 fileIndex@var297 , std ::@expr2096 atol (@expr1073743921 numtok@var310 .@expr1073743922 str (@expr1073743923 ) .@expr1073743924 c_str (@expr1073743925 ) ) , &@expr2102 location@var296 ) ;
541: } else { if (@expr1073743927 lastline@var306 ==@expr1073743928 "# %num% %str%" ||@expr1073743929 lastline@var306 ==@expr1073743930 "# line %num% %str%" ) {
542: const Token * strtok@var313 ; strtok@var313 =@expr1073743931 cback (@expr2025 ) ;
543: while (@expr1073743933 strtok@var313 .@expr1073743934 comment@var314 ) {
544: strtok@var313 =@expr1073743935 strtok@var313 .@expr2112 previous@var315 ; }
545: const Token * numtok@var316 ; numtok@var316 =@expr1073743937 strtok@var313 .@expr2112 previous@var315 ;
546: while (@expr1073743939 numtok@var316 .@expr1073743940 comment@var317 ) {
547: numtok@var316 =@expr1073743941 numtok@var316 .@expr1073743942 previous@var318 ; }
548: lineDirective (@expr1073743943 fileIndex (@expr1073743944 replaceAll (@expr1073743945 strtok@var313 .@expr2122 str (@expr2123 ) .@expr1073743948 substr (@expr1073743949 1U , strtok@var313 .@expr2122 str (@expr2123 ) .@expr1073743952 size (@expr1073743953 ) -@expr1073743954 2U ) , "\\\\" , "\\" ) ) ,
549: std ::@expr2096 atol (@expr1073743956 numtok@var316 .@expr1073743957 str (@expr1073743958 ) .@expr1073743959 c_str (@expr1073743960 ) ) , &@expr2102 location@var296 ) ;
550: }
551:
552: else { if (@expr1073743962 lastline@var306 ==@expr1073743963 "# endfile" &&@expr1073743964 !@expr1073743965 loc@var292 .@expr1073743966 empty (@expr1073743967 ) ) {
553: location@var296 =@expr1073743968 loc@var292 .@expr1073743969 top (@expr1073743970 ) ;
554: loc@var292 .@expr1073743971 pop (@expr1073743972 ) ;
555: } } } }
556: }
557:
558: continue ;
559: }
560:
561: if (@expr1073743973 std ::@expr1073743974 isspace (@expr1073743975 ch@var300 ) ) {
562: location@var296 .@expr1979 col@var299 ++@expr1073743977 ;
563: continue ;
564: }
565:
566: std ::@expr1073743978 string currentToken@var319 ;
567:
568: if (@expr1073743979 cback (@expr2025 ) &&@expr1073743981 cback (@expr2025 ) .@expr2034 location .@expr2160 line@expr1961 ==@expr2161 location@var296 .@expr1977 line@var298 &&@expr1073743987 cback (@expr2025 ) .@expr2165 previous@expr1073743786 &&@expr1073743990 cback (@expr2025 ) .@expr2165 previous .@expr1073743993 op@expr1073743787 ==@expr1073743994 '#' &&@expr1073743995 (@expr1073743996 lastLine (@expr2061 ) ==@expr1073743998 "# error" ||@expr1073743999 lastLine (@expr2061 ) ==@expr1073744001 "# warning" ) ) {
569: char prev@var320 ; prev@var320 =@expr1073744002 ' ' ;
570: while (@expr1073744003 istr@var289 .@expr1982 good (@expr1983 ) &&@expr1073744006 (@expr1073744007 prev@var320 ==@expr1073744008 '\\' ||@expr1073744009 (@expr1073744010 ch@var300 !=@expr1997 '\r' &&@expr1073744012 ch@var300 !=@expr1995 '\n' ) ) ) {
571: currentToken@var319 +=@expr1073744014 ch@var300 ;
572: prev@var320 =@expr1073744015 ch@var300 ;
573: ch@var300 =@expr1073744016 readChar (@expr1985 istr@var289 , bom@var295 ) ;
574: }
575: ungetChar (@expr2194 istr@var289 , bom@var295 ) ;
576: push_back (@expr2195 new Token (@expr2196 currentToken@var319 , location@var296 ) ) ;
577: location@var296 .@expr2197 adjust (@expr2198 currentToken@var319 ) ;
578: continue ;
579: }
580:
581:
582: if (@expr1073744023 isNameChar (@expr2200 ch@var300 ) ) {
583: const bool num@var321 =@expr1073744025 std ::@expr1073744026 isdigit (@expr1073744027 ch@var300 ) ;
584: while (@expr1073744028 istr@var289 .@expr1982 good (@expr1983 ) &&@expr1073744031 isNameChar (@expr2200 ch@var300 ) ) {
585: currentToken@var319 +=@expr1073744033 ch@var300 ;
586: ch@var300 =@expr1073744034 readChar (@expr1985 istr@var289 , bom@var295 ) ;
587: if (@expr1073744036 num@var321 &&@expr1073744037 ch@var300 ==@expr2214 '\'' &&@expr1073744039 isNameChar (@expr1073744040 peekChar (@expr2217 istr@var289 , bom@var295 ) ) ) {
588: ch@var300 =@expr1073744042 readChar (@expr1985 istr@var289 , bom@var295 ) ; }
589: }
590:
591: ungetChar (@expr2194 istr@var289 , bom@var295 ) ;
592: }
593:
594:
595: else { if (@expr1073744045 ch@var300 ==@expr2222 '/' &&@expr1073744047 peekChar (@expr2217 istr@var289 , bom@var295 ) ==@expr1073744049 '/' ) {
596: while (@expr1073744050 istr@var289 .@expr1982 good (@expr1983 ) &&@expr1073744053 ch@var300 !=@expr1997 '\r' &&@expr1073744055 ch@var300 !=@expr1995 '\n' ) {
597: currentToken@var319 +=@expr1073744057 ch@var300 ;
598: ch@var300 =@expr1073744058 readChar (@expr1985 istr@var289 , bom@var295 ) ;
599: }
600: const std ::@expr1968 string ::@expr1968 size_type pos@var322 =@expr1073744062 currentToken@var319 .@expr1073744063 find_last_not_of (@expr1073744064 " \t" ) ;
601: if (@expr1073744065 pos@var322 <@expr1073744066 currentToken@var319 .@expr2243 size (@expr2244 ) -@expr2245 1U &&@expr1073744070 currentToken@var319 [@expr1073744071 pos@var322 ] ==@expr1073744072 '\\' ) {
602: portabilityBackslash (@expr1073744073 outputList@var291 , files@var111 , location@var296 ) ; }
603: if (@expr1073744074 currentToken@var319 [@expr1073744075 currentToken@var319 .@expr2243 size (@expr2244 ) -@expr2245 1U ] ==@expr1073744079 '\\' ) {
604: ++@expr1073744080 multiline@var293 ;
605: currentToken@var319 .@expr2257 erase (@expr1073744082 currentToken@var319 .@expr2243 size (@expr2244 ) -@expr2245 1U ) ;
606: } else {
607: ungetChar (@expr2194 istr@var289 , bom@var295 ) ;
608: }
609: }
610:
611:
612: else { if (@expr1073744087 ch@var300 ==@expr2222 '/' &&@expr1073744089 peekChar (@expr2217 istr@var289 , bom@var295 ) ==@expr1073744091 '*' ) {
613: currentToken@var319 =@expr1073744092 "/*" ;
614: (@expr1073744093 void ) readChar (@expr1985 istr@var289 , bom@var295 ) ;
615: ch@var300 =@expr1073744095 readChar (@expr1985 istr@var289 , bom@var295 ) ;
616: while (@expr1981 istr@var289 .@expr1982 good (@expr1983 ) ) {
617: currentToken@var319 +=@expr1073744100 ch@var300 ;
618: if (@expr1073744101 currentToken@var319 .@expr2243 size (@expr2244 ) >=@expr1073744104 4U &&@expr1073744105 endsWith (@expr1073744106 currentToken@var319 , COMMENT_END@var288 ) ) {
619: break ; }
620: ch@var300 =@expr1073744107 readChar (@expr1985 istr@var289 , bom@var295 ) ;
621: }
622:
623:
624: std ::@expr2285 string ::@expr1073744110 size_type pos@var323 ; pos@var323 =@expr1073744111 0 ;
625: while (@expr1073744112 (@expr1073744113 pos@var323 =@expr1073744114 currentToken@var319 .@expr2291 find (@expr1073744116 "\\\n" , pos@var323 ) ) !=@expr1073744117 std ::@expr2285 string ::@expr2295 npos@expr1964 ) {
626: currentToken@var319 .@expr2257 erase (@expr1073744121 pos@var323 , 2 ) ;
627: ++@expr1073744122 multiline@var293 ;
628: }
629: if (@expr1073744123 multiline@var293 ||@expr1073744124 startsWith (@expr1073744125 lastLine (@expr1073744126 10 ) , "# " ) ) {
630: pos@var323 =@expr1073744127 0 ;
631: while (@expr1073744128 (@expr1073744129 pos@var323 =@expr1073744130 currentToken@var319 .@expr2291 find (@expr1073744132 '\n' , pos@var323 ) ) !=@expr1073744133 std ::@expr2285 string ::@expr2295 npos@expr1964 ) {
632: currentToken@var319 .@expr2257 erase (@expr1073744137 pos@var323 , 1 ) ;
633: ++@expr1073744138 multiline@var293 ;
634: }
635: }
636: }
637:
638:
639: else { if (@expr1073744139 ch@var300 ==@expr2316 '\"' ||@expr1073744141 ch@var300 ==@expr2214 '\'' ) {
640: std ::@expr1073744143 string prefix@var324 ;
641: if (@expr1073744144 cback (@expr2025 ) &&@expr1073744146 cback (@expr2025 ) .@expr1073744148 name@expr1073743789 &&@expr1073744149 isStringLiteralPrefix (@expr1073744150 cback (@expr2025 ) .@expr2328 str (@expr2329 ) ) &&@expr1073744154
642: (@expr1073744155 (@expr1073744156 cback (@expr2025 ) .@expr2034 location .@expr2035 col@expr1959 +@expr1073744160 cback (@expr2025 ) .@expr2328 str (@expr2329 ) .@expr1073744164 size (@expr1073744165 ) ) ==@expr1073744166 location@var296 .@expr1979 col@var299 ) &&@expr1073744168
643: (@expr1073744169 cback (@expr2025 ) .@expr2034 location .@expr2160 line@expr1961 ==@expr2161 location@var296 .@expr1977 line@var298 ) ) {
644: prefix@var324 =@expr1073744175 cback (@expr2025 ) .@expr2328 str (@expr2329 ) ;
645: }
646:
647: if (@expr1073744179 ch@var300 ==@expr2316 '\"' &&@expr1073744181 !@expr1073744182 prefix@var324 .@expr2359 empty (@expr2360 ) &&@expr1073744185 *@expr1073744186 cback (@expr2025 ) .@expr2328 str (@expr2329 ) .@expr1073744190 rbegin (@expr1073744191 ) ==@expr1073744192 'R' ) {
648: std ::@expr1073744193 string delim@var325 ;
649: currentToken@var319 =@expr1073744194 ch@var300 ;
650: prefix@var324 .@expr1073744195 resize (@expr1073744196 prefix@var324 .@expr1073744197 size (@expr1073744198 ) -@expr1073744199 1 ) ;
651: ch@var300 =@expr1073744200 readChar (@expr1985 istr@var289 , bom@var295 ) ;
652: while (@expr1073744202 istr@var289 .@expr1982 good (@expr1983 ) &&@expr1073744205 ch@var300 !=@expr1073744206 '(' &&@expr1073744207 ch@var300 !=@expr1995 '\n' ) {
653: delim@var325 +=@expr1073744209 ch@var300 ;
654: ch@var300 =@expr1073744210 readChar (@expr1985 istr@var289 , bom@var295 ) ;
655: }
656: if (@expr1073744212 !@expr1987 istr@var289 .@expr1982 good (@expr1983 ) ||@expr1073744216 ch@var300 ==@expr2023 '\n' ) {
657: if (@expr2001 outputList@var291 ) {
658: Output err@var326 (@expr1073744219 files@var111 ) ;
659: err@var326 .@expr1073744220 type@var327 =@expr1073744221 Output ::@expr2398 SYNTAX_ERROR@expr1966 ;
660: err@var326 .@expr1073744223 location@var328 =@expr1073744224 location@var296 ;
661: err@var326 .@expr1073744225 msg@var329 =@expr1073744226 "Invalid newline in raw string delimiter." ;
662: outputList@var291 .@expr2019 push_back (@expr1073744228 err@var326 ) ;
663: }
664: return ;
665: }
666: const std ::@expr1073744229 string endOfRawString@var330 (@expr1073744230 ')' +@expr1073744231 delim@var325 +@expr1073744232 currentToken@var319 ) ;
667: while (@expr1073744233 istr@var289 .@expr1982 good (@expr1983 ) &&@expr1073744236 !@expr1073744237 (@expr1073744238 endsWith (@expr2415 currentToken@var319 , endOfRawString@var330 ) &&@expr1073744240 currentToken@var319 .@expr2243 size (@expr2244 ) >@expr1073744243 1 ) ) {
668: currentToken@var319 +=@expr1073744244 readChar (@expr1985 istr@var289 , bom@var295 ) ; }
669: if (@expr1073744246 !@expr1073744247 endsWith (@expr2415 currentToken@var319 , endOfRawString@var330 ) ) {
670: if (@expr2001 outputList@var291 ) {
671: Output err@var331 (@expr1073744250 files@var111 ) ;
672: err@var331 .@expr1073744251 type@var332 =@expr1073744252 Output ::@expr2398 SYNTAX_ERROR@expr1966 ;
673: err@var331 .@expr1073744254 location@var333 =@expr1073744255 location@var296 ;
674: err@var331 .@expr1073744256 msg@var334 =@expr1073744257 "Raw string missing terminating delimiter." ;
675: outputList@var291 .@expr2019 push_back (@expr1073744259 err@var331 ) ;
676: }
677: return ;
678: }
679: currentToken@var319 .@expr2257 erase (@expr1073744261 currentToken@var319 .@expr2243 size (@expr2244 ) -@expr1073744264 endOfRawString@var330 .@expr2441 size (@expr2442 ) , endOfRawString@var330 .@expr2441 size (@expr2442 ) -@expr1073744269 1U ) ;
680: currentToken@var319 =@expr1073744270 escapeString (@expr1073744271 currentToken@var319 ) ;
681: currentToken@var319 .@expr1073744272 insert (@expr1073744273 0 , prefix@var324 ) ;
682: back (@expr2042 ) .@expr2451 setstr (@expr1073744276 currentToken@var319 ) ;
683: location@var296 .@expr2197 adjust (@expr2198 currentToken@var319 ) ;
684: if (@expr1073744279 currentToken@var319 .@expr1073744280 find_first_of (@expr1073744281 "\r\n" ) ==@expr1073744282 std ::@expr2285 string ::@expr2295 npos@expr1964 ) {
685: location@var296 .@expr1979 col@var299 +=@expr1073744286 2 +@expr1073744287 2 *@expr1073744288 delim@var325 .@expr2465 size (@expr2466 ) ; }
686: else {
687: location@var296 .@expr1979 col@var299 +=@expr1073744292 1 +@expr1073744293 delim@var325 .@expr2465 size (@expr2466 ) ; }
688:
689: continue ;
690: }
691:
692: currentToken@var319 =@expr1073744296 readUntil (@expr1073744297 istr@var289 , location@var296 , ch@var300 , ch@var300 , outputList@var291 , bom@var295 ) ;
693: if (@expr2474 currentToken@var319 .@expr2243 size (@expr2244 ) <@expr2477 2U ) {
694:
695: return ; }
696:
697: std ::@expr1073744302 string s@var335 ; s@var335 =@expr1073744303 currentToken@var319 ;
698: std ::@expr2285 string ::@expr1073744305 size_type pos@var336 ;
699: int newlines@var337 ; newlines@var337 =@expr1073744306 0 ;
700: while (@expr1073744307 (@expr1073744308 pos@var336 =@expr1073744309 s@var335 .@expr1073744310 find_first_of (@expr1073744311 "\r\n" ) ) !=@expr1073744312 std ::@expr2285 string ::@expr2295 npos@expr1964 ) {
701: s@var335 .@expr1073744315 erase (@expr1073744316 pos@var336 , 1 ) ;
702: newlines@var337 ++@expr1073744317 ;
703: }
704:
705: if (@expr1073744318 prefix@var324 .@expr2359 empty (@expr2360 ) ) {
706: push_back (@expr1073744321 new Token (@expr1073744322 s@var335 , location@var296 ) ) ; }
707: else {
708: back (@expr2042 ) .@expr2451 setstr (@expr1073744325 prefix@var324 +@expr1073744326 s@var335 ) ; }
709:
710: if (@expr1073744327 newlines@var337 >@expr1073744328 0 &&@expr1073744329 lastLine (@expr2061 ) .@expr1073744331 compare (@expr1073744332 0 , 9 , "# define " ) ==@expr1073744333 0 ) {
711: multiline@var293 +=@expr1073744334 newlines@var337 ;
712: location@var296 .@expr2197 adjust (@expr1073744336 s@var335 ) ;
713: } else {
714: location@var296 .@expr2197 adjust (@expr2198 currentToken@var319 ) ;
715: }
716: continue ;
717: }
718:
719: else {
720: currentToken@var319 +=@expr1073744339 ch@var300 ;
721: } } } }
722:
723: if (@expr1073744340 currentToken@var319 ==@expr1073744341 "<" &&@expr1073744342 lastLine (@expr2061 ) ==@expr1073744344 "# include" ) {
724: currentToken@var319 =@expr1073744345 readUntil (@expr1073744346 istr@var289 , location@var296 , '<' , '>' , outputList@var291 , bom@var295 ) ;
725: if (@expr2474 currentToken@var319 .@expr2243 size (@expr2244 ) <@expr2477 2U ) {
726: return ; }
727: }
728:
729: push_back (@expr2195 new Token (@expr2196 currentToken@var319 , location@var296 ) ) ;
730:
731: if (@expr1073744353 multiline@var293 ) {
732: location@var296 .@expr1979 col@var299 +=@expr1073744355 currentToken@var319 .@expr2243 size (@expr2244 ) ; }
733: else {
734: location@var296 .@expr2197 adjust (@expr2198 currentToken@var319 ) ; }
735: }
736:
737: combineOperators (@expr1073744360 ) ;
738: }
739:
740: void simplecpp :: TokenList :: constFold ( )
741: {
742: while (@expr1073744361 cfront (@expr1073744362 ) ) {
743:
744: Token * tok@var338 ; tok@var338 =@expr1073744363 back (@expr1073744364 ) ;
745: while (@expr1073744365 tok@var338 &&@expr1073744366 tok@var338 .@expr2543 op@var339 !=@expr2544 '(' ) {
746: tok@var338 =@expr1073744369 tok@var338 .@expr2546 previous@var340 ; }
747:
748:
749: if (@expr1073744371 !@expr1073744372 tok@var338 ) {
750: tok@var338 =@expr1073744373 front (@expr1073744374 ) ; }
751:
752:
753: constFoldUnaryNotPosNeg (@expr1073744375 tok@var338 ) ;
754: constFoldMulDivRem (@expr1073744376 tok@var338 ) ;
755: constFoldAddSub (@expr1073744377 tok@var338 ) ;
756: constFoldShift (@expr1073744378 tok@var338 ) ;
757: constFoldComparison (@expr1073744379 tok@var338 ) ;
758: constFoldBitwise (@expr1073744380 tok@var338 ) ;
759: constFoldLogicalOp (@expr1073744381 tok@var338 ) ;
760: constFoldQuestionOp (@expr1073744382 &@expr1073744383 tok@var338 ) ;
761:
762:
763: if (@expr1073744384 tok@var338 .@expr2543 op@var339 !=@expr2544 '(' ) {
764: break ; }
765:
766: if (@expr1073744387 !@expr1073744388 tok@var338 .@expr2565 next@var341 ||@expr1073744390 !@expr1073744391 tok@var338 .@expr2565 next@var341 .@expr2569 next@var342 ||@expr1073744394 tok@var338 .@expr2565 next@var341 .@expr2569 next@var342 .@expr1073744397 op@var343 !=@expr1073744398 ')' ) {
767: break ; }
768:
769: tok@var338 =@expr1073744399 tok@var338 .@expr2565 next@var341 ;
770: deleteToken (@expr1073744401 tok@var338 .@expr2546 previous@var340 ) ;
771: deleteToken (@expr1073744403 tok@var338 .@expr2565 next@var341 ) ;
772: }
773: }
774:
775: static bool isFloatSuffix ( const simplecpp :: Token * tok@var344 )
776: {
777: if (@expr1073744405 !@expr1073744406 tok@var344 ||@expr1073744407 tok@var344 .@expr2584 str (@expr2585 ) .@expr1073744410 size (@expr1073744411 ) !=@expr1073744412 1U ) {
778: return false ; }
779: const char c@var345 =@expr1073744413 std ::@expr1073744414 tolower (@expr1073744415 tok@var344 .@expr2584 str (@expr2585 ) [@expr1073744418 0 ] ) ;
780: return c@var345 ==@expr1073744419 'f' ||@expr1073744420 c@var345 ==@expr1073744421 'l' ;
781: }
782:
783: void simplecpp :: TokenList :: combineOperators ( )
784: {
785: std ::@expr1073744422 stack < bool > executableScope@var346 ;
786: executableScope@var346 .@expr2599 push (@expr1073744424 false ) ;
787: for (@expr1073744425 Token *@expr1073744426 tok@var347 =@expr1073744427 front (@expr1073744428 ) ; tok@var347 ; tok@var347 =@expr1073744429 tok@var347 .@expr2606 next@var348 ) {
788: if (@expr1073744431 tok@var347 .@expr2608 op@var349 ==@expr1073744433 '{' ) {
789: if (@expr1073744434 executableScope@var346 .@expr2611 top (@expr2612 ) ) {
790: executableScope@var346 .@expr2599 push (@expr1073744438 true ) ;
791: continue ;
792: }
793: const Token * prev@var350 ; prev@var350 =@expr1073744439 tok@var347 .@expr2616 previous@var351 ;
794: while (@expr1073744441 prev@var350 &&@expr1073744442 prev@var350 .@expr1073744443 isOneOf (@expr1073744444 ";{}()" ) ) {
795: prev@var350 =@expr1073744445 prev@var350 .@expr1073744446 previous@var352 ; }
796: executableScope@var346 .@expr2599 push (@expr1073744448 prev@var350 &&@expr1073744449 prev@var350 .@expr1073744450 op@var353 ==@expr1073744451 ')' ) ;
797: continue ;
798: }
799: if (@expr1073744452 tok@var347 .@expr2608 op@var349 ==@expr1073744454 '}' ) {
800: if (@expr1073744455 executableScope@var346 .@expr1073744456 size (@expr1073744457 ) >@expr1073744458 1 ) {
801: executableScope@var346 .@expr1073744459 pop (@expr1073744460 ) ; }
802: continue ;
803: }
804:
805: if (@expr1073744461 tok@var347 .@expr2608 op@var349 ==@expr1073744463 '.' ) {
806:
807: if (@expr1073744464 tok@var347 .@expr2606 next@var348 &&@expr1073744466 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr1073744469 '.' &&@expr1073744470 tok@var347 .@expr2606 next@var348 .@expr2648 location@var355 .@expr2649 col@var356 ==@expr1073744474 (@expr1073744475 tok@var347 .@expr2652 location@var357 .@expr2653 col@var358 +@expr1073744478 1 ) &&@expr1073744479
808: tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 &&@expr1073744482 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr2661 op@var360 ==@expr1073744486 '.' &&@expr1073744487 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr1073744490 location@var361 .@expr1073744491 col@var362 ==@expr1073744492 (@expr1073744493 tok@var347 .@expr2652 location@var357 .@expr2653 col@var358 +@expr1073744496 2 ) ) {
809: tok@var347 .@expr2673 setstr (@expr1073744498 "..." ) ;
810: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
811: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
812: continue ;
813: }
814:
815: if (@expr2679 tok@var347 .@expr2616 previous@var351 &&@expr2681 tok@var347 .@expr2616 previous@var351 .@expr2683 number@var363 ) {
816: tok@var347 .@expr2673 setstr (@expr1073744509 tok@var347 .@expr2616 previous@var351 .@expr1073744511 str (@expr1073744512 ) +@expr1073744513 '.' ) ;
817: deleteToken (@expr1073744514 tok@var347 .@expr2616 previous@var351 ) ;
818: if (@expr1073744516 isFloatSuffix (@expr1073744517 tok@var347 .@expr2606 next@var348 ) ||@expr1073744519 (@expr1073744520 tok@var347 .@expr2606 next@var348 &&@expr1073744522 tok@var347 .@expr2606 next@var348 .@expr1073744524 startsWithOneOf (@expr1073744525 "AaBbCcDdEeFfPp" ) ) ) {
819: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
820: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
821: }
822: }
823: if (@expr1073744536 tok@var347 .@expr2606 next@var348 &&@expr1073744538 tok@var347 .@expr2606 next@var348 .@expr1073744540 number@var364 ) {
824: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
825: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
826: }
827: }
828:
829: const char lastChar@var365 =@expr1073744551 tok@var347 .@expr2704 str (@expr2705 ) [@expr1073744554 tok@var347 .@expr2704 str (@expr2705 ) .@expr1073744557 size (@expr1073744558 ) -@expr1073744559 1 ] ;
830: if (@expr1073744560 tok@var347 .@expr1073744561 number@var366 &&@expr1073744562 !@expr1073744563 isOct (@expr1073744564 tok@var347 .@expr2704 str (@expr2705 ) ) &&@expr1073744567
831: (@expr1073744568 (@expr1073744569 !@expr1073744570 isHex (@expr2747 tok@var347 .@expr2704 str (@expr2705 ) ) &&@expr1073744574 (@expr1073744575 lastChar@var365 ==@expr1073744576 'E' ||@expr1073744577 lastChar@var365 ==@expr1073744578 'e' ) ) ||@expr1073744579
832: (@expr1073744580 isHex (@expr2747 tok@var347 .@expr2704 str (@expr2705 ) ) &&@expr1073744584 (@expr1073744585 lastChar@var365 ==@expr1073744586 'P' ||@expr1073744587 lastChar@var365 ==@expr1073744588 'p' ) ) ) &&@expr1073744589
833: tok@var347 .@expr2606 next@var348 &&@expr1073744591 tok@var347 .@expr2606 next@var348 .@expr1073744593 isOneOf (@expr1073744594 "+-" ) &&@expr1073744595 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 &&@expr1073744598 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr2777 number@var367 ) {
834: tok@var347 .@expr2673 setstr (@expr1073744603 tok@var347 .@expr2704 str (@expr2705 ) +@expr1073744606 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 +@expr1073744609 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr1073744612 str (@expr1073744613 ) ) ;
835: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
836: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
837: }
838:
839: if (@expr1073744618 tok@var347 .@expr2608 op@var349 ==@expr1073744620 '\0' ||@expr1073744621 !@expr1073744622 tok@var347 .@expr2606 next@var348 ||@expr1073744624 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr1073744627 '\0' ) {
840: continue ; }
841: if (@expr1073744628 !@expr1073744629 sameline (@expr1073744630 tok@var347 , tok@var347 .@expr2606 next@var348 ) ) {
842: continue ; }
843: if (@expr2808 tok@var347 .@expr2652 location@var357 .@expr2653 col@var358 +@expr2811 1U !=@expr2812 tok@var347 .@expr2606 next@var348 .@expr2648 location@var355 .@expr2649 col@var356 ) {
844: continue ; }
845:
846: if (@expr1073744640 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr2819 '=' &&@expr1073744644 tok@var347 .@expr1073744645 isOneOf (@expr1073744646 "=!<>+-*/%&|^" ) ) {
847: if (@expr1073744647 tok@var347 .@expr2608 op@var349 ==@expr2825 '&' &&@expr1073744650 !@expr1073744651 executableScope@var346 .@expr2611 top (@expr2612 ) ) {
848:
849:
850: int indentlevel@var368 ; indentlevel@var368 =@expr1073744654 0 ;
851: const Token * start@var369 ; start@var369 =@expr1073744655 tok@var347 ;
852: while (@expr1073744656 indentlevel@var368 >=@expr1073744657 0 &&@expr1073744658 start@var369 ) {
853: if (@expr1073744659 start@var369 .@expr2836 op@var370 ==@expr1073744661 ')' ) {
854: ++@expr1073744662 indentlevel@var368 ; }
855: else { if (@expr1073744663 start@var369 .@expr2836 op@var370 ==@expr1073744665 '(' ) {
856: --@expr1073744666 indentlevel@var368 ; }
857: else { if (@expr1073744667 start@var369 .@expr1073744668 isOneOf (@expr1073744669 ";{}" ) ) {
858: break ; } } }
859: start@var369 =@expr1073744670 start@var369 .@expr2847 previous@var371 ;
860: }
861: if (@expr1073744672 indentlevel@var368 ==@expr1073744673 -1 &&@expr1073744674 start@var369 ) {
862: const Token * ftok@var372 ; ftok@var372 =@expr1073744675 start@var369 ;
863: bool isFuncDecl@var373 ; isFuncDecl@var373 =@expr1073744676 ftok@var372 .@expr1073744677 name@var374 ;
864: while (@expr1073744678 isFuncDecl@var373 ) {
865: if (@expr1073744679 !@expr1073744680 start@var369 .@expr2857 name@var375 &&@expr1073744682 start@var369 .@expr1073744683 str (@expr1073744684 ) !=@expr1073744685 "::" &&@expr1073744686 start@var369 .@expr2836 op@var370 !=@expr1073744688 '*' &&@expr1073744689 start@var369 .@expr2836 op@var370 !=@expr1073744691 '&' ) {
866: isFuncDecl@var373 =@expr1073744692 false ; }
867: if (@expr1073744693 !@expr1073744694 start@var369 .@expr2847 previous@var371 ) {
868: break ; }
869: if (@expr1073744696 start@var369 .@expr2847 previous@var371 .@expr1073744698 isOneOf (@expr1073744699 ";{}:" ) ) {
870: break ; }
871: start@var369 =@expr1073744700 start@var369 .@expr2847 previous@var371 ;
872: }
873: isFuncDecl@var373 &=@expr1073744702 start@var369 !=@expr1073744703 ftok@var372 &&@expr1073744704 start@var369 .@expr2857 name@var375 ;
874: if (@expr1073744706 isFuncDecl@var373 ) {
875:
876: continue ;
877: }
878: }
879: }
880: tok@var347 .@expr2673 setstr (@expr1073744708 tok@var347 .@expr2704 str (@expr2705 ) +@expr1073744711 "=" ) ;
881: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
882: } else { if (@expr1073744714 (@expr1073744715 tok@var347 .@expr2608 op@var349 ==@expr1073744717 '|' ||@expr1073744718 tok@var347 .@expr2608 op@var349 ==@expr2825 '&' ) &&@expr1073744721 tok@var347 .@expr2608 op@var349 ==@expr2899 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ) {
883: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
884: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
885: } else { if (@expr1073744736 tok@var347 .@expr2608 op@var349 ==@expr1073744738 ':' &&@expr1073744739 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr1073744742 ':' ) {
886: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
887: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
888: } else { if (@expr1073744753 tok@var347 .@expr2608 op@var349 ==@expr2931 '-' &&@expr1073744756 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr1073744759 '>' ) {
889: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
890: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
891: } else { if (@expr1073744770 (@expr1073744771 tok@var347 .@expr2608 op@var349 ==@expr1073744773 '<' ||@expr1073744774 tok@var347 .@expr2608 op@var349 ==@expr1073744776 '>' ) &&@expr1073744777 tok@var347 .@expr2608 op@var349 ==@expr2899 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ) {
892: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
893: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
894: if (@expr1073744792 tok@var347 .@expr2606 next@var348 &&@expr1073744794 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ==@expr2819 '=' &&@expr1073744798 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 &&@expr1073744801 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr2661 op@var360 !=@expr1073744805 '=' ) {
895: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
896: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
897: }
898: } else { if (@expr1073744816 (@expr1073744817 tok@var347 .@expr2608 op@var349 ==@expr1073744819 '+' ||@expr1073744820 tok@var347 .@expr2608 op@var349 ==@expr2931 '-' ) &&@expr1073744823 tok@var347 .@expr2608 op@var349 ==@expr2899 tok@var347 .@expr2606 next@var348 .@expr2644 op@var354 ) {
899: if (@expr2808 tok@var347 .@expr2652 location@var357 .@expr2653 col@var358 +@expr2811 1U !=@expr2812 tok@var347 .@expr2606 next@var348 .@expr2648 location@var355 .@expr2649 col@var356 ) {
900: continue ; }
901: if (@expr2679 tok@var347 .@expr2616 previous@var351 &&@expr2681 tok@var347 .@expr2616 previous@var351 .@expr2683 number@var363 ) {
902: continue ; }
903: if (@expr1073744841 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 &&@expr1073744844 tok@var347 .@expr2606 next@var348 .@expr2657 next@var359 .@expr2777 number@var367 ) {
904: continue ; }
905: tok@var347 .@expr2673 setstr (@expr2703 tok@var347 .@expr2704 str (@expr2705 ) +@expr2706 tok@var347 .@expr2606 next@var348 .@expr2708 str (@expr2709 ) ) ;
906: deleteToken (@expr2675 tok@var347 .@expr2606 next@var348 ) ;
907: } } } } } }
908: }
909: }
910:
911: static const std :: string COMPL@var376 ( "compl" ) ;
912: static const std :: string NOT@var377 ( "not" ) ;
913: void simplecpp :: TokenList :: constFoldUnaryNotPosNeg ( simplecpp :: Token * tok@var378 )
914: {
915: for (@expr1073744858 ; tok@var378 &&@expr1073744859 tok@var378 .@expr3036 op@var379 !=@expr1073744861 ')' ; tok@var378 =@expr1073744862 tok@var378 .@expr3039 next@var380 ) {
916:
917: if (@expr1073744864 isAlternativeUnaryOp (@expr1073744865 tok@var378 , NOT@var377 ) ) {
918: tok@var378 .@expr3036 op@var379 =@expr1073744867 '!' ; }
919:
920: else { if (@expr1073744868 isAlternativeUnaryOp (@expr1073744869 tok@var378 , COMPL@var376 ) ) {
921: tok@var378 .@expr3036 op@var379 =@expr1073744871 '~' ; } }
922:
923: if (@expr1073744872 tok@var378 .@expr3036 op@var379 ==@expr1073744874 '!' &&@expr1073744875 tok@var378 .@expr3039 next@var380 &&@expr1073744877 tok@var378 .@expr3039 next@var380 .@expr3055 number@var381 ) {
924: tok@var378 .@expr3056 setstr (@expr1073744881 tok@var378 .@expr3039 next@var380 .@expr3059 str (@expr3060 ) ==@expr1073744885 "0" ?@expr1073744886 "1" :@expr1073744887 "0" ) ;
925: deleteToken (@expr3064 tok@var378 .@expr3039 next@var380 ) ;
926: } else { if (@expr1073744890 tok@var378 .@expr3036 op@var379 ==@expr1073744892 '~' &&@expr1073744893 tok@var378 .@expr3039 next@var380 &&@expr1073744895 tok@var378 .@expr3039 next@var380 .@expr3055 number@var381 ) {
927: tok@var378 .@expr3056 setstr (@expr1073744899 toString (@expr1073744900 ~@expr1073744901 stringToLL (@expr1073744902 tok@var378 .@expr3039 next@var380 .@expr3059 str (@expr3060 ) ) ) ) ;
928: deleteToken (@expr3064 tok@var378 .@expr3039 next@var380 ) ;
929: } else {
930: if (@expr1073744908 tok@var378 .@expr3085 previous@var382 &&@expr1073744910 (@expr1073744911 tok@var378 .@expr3085 previous@var382 .@expr1073744913 number@var383 ||@expr1073744914 tok@var378 .@expr3085 previous@var382 .@expr1073744916 name@var384 ) ) {
931: continue ; }
932: if (@expr1073744917 !@expr1073744918 tok@var378 .@expr3039 next@var380 ||@expr1073744920 !@expr1073744921 tok@var378 .@expr3039 next@var380 .@expr3055 number@var381 ) {
933: continue ; }
934: switch (@expr1073744924 tok@var378 .@expr3036 op@var379 ) {
935: case '+' :@expr3102 ;
936: tok@var378 .@expr3056 setstr (@expr1073744928 tok@var378 .@expr3039 next@var380 .@expr3059 str (@expr3060 ) ) ;
937: deleteToken (@expr3064 tok@var378 .@expr3039 next@var380 ) ;
938: break ;
939: case '-' :@expr3102 ;
940: tok@var378 .@expr3056 setstr (@expr1073744936 tok@var378 .@expr3036 op@var379 +@expr1073744938 tok@var378 .@expr3039 next@var380 .@expr3059 str (@expr3060 ) ) ;
941: deleteToken (@expr3064 tok@var378 .@expr3039 next@var380 ) ;
942: break ;
943: }
944: } }
945: }
946: }
947:
948: void simplecpp :: TokenList :: constFoldMulDivRem ( Token * tok@var385 )
949: {
950: for (@expr1073744944 ; tok@var385 &&@expr1073744945 tok@var385 .@expr3122 op@var386 !=@expr1073744947 ')' ; tok@var385 =@expr1073744948 tok@var385 .@expr3125 next@var387 ) {
951: if (@expr1073744950 !@expr1073744951 tok@var385 .@expr3128 previous@var388 ||@expr1073744953 !@expr1073744954 tok@var385 .@expr3128 previous@var388 .@expr1073744956 number@var389 ) {
952: continue ; }
953: if (@expr1073744957 !@expr1073744958 tok@var385 .@expr3125 next@var387 ||@expr1073744960 !@expr1073744961 tok@var385 .@expr3125 next@var387 .@expr1073744963 number@var390 ) {
954: continue ; }
955:
956: long long result@var391 ;
957: if (@expr1073744964 tok@var385 .@expr3122 op@var386 ==@expr1073744966 '*' ) {
958: result@var391 =@expr1073744967 stringToLL (@expr3144 tok@var385 .@expr3128 previous@var388 .@expr3146 str (@expr3147 ) ) *@expr1073744972 stringToLL (@expr3149 tok@var385 .@expr3125 next@var387 .@expr3151 str (@expr3152 ) ) ; }
959: else { if (@expr1073744977 tok@var385 .@expr3122 op@var386 ==@expr3155 '/' ||@expr1073744980 tok@var385 .@expr3122 op@var386 ==@expr1073744982 '%' ) {
960: long long rhs@var392 ; rhs@var392 =@expr1073744983 stringToLL (@expr3149 tok@var385 .@expr3125 next@var387 .@expr3151 str (@expr3152 ) ) ;
961: if (@expr1073744988 rhs@var392 ==@expr1073744989 0 ) {
962: throw std ::@expr3166 overflow_error (@expr1073744991 "division/modulo by zero" ) ; }
963: long long lhs@var393 ; lhs@var393 =@expr1073744992 stringToLL (@expr3144 tok@var385 .@expr3128 previous@var388 .@expr3146 str (@expr3147 ) ) ;
964: if (@expr1073744997 rhs@var392 ==@expr1073744998 -1 &&@expr1073744999 lhs@var393 ==@expr1073745000 std ::@expr1073745001 numeric_limits < long long > ::@expr1073745002 min (@expr1073745003 ) ) {
965: throw std ::@expr3166 overflow_error (@expr1073745005 "division overflow" ) ; }
966: if (@expr1073745006 tok@var385 .@expr3122 op@var386 ==@expr3155 '/' ) {
967: result@var391 =@expr1073745009 lhs@var393 /@expr1073745010 rhs@var392 ; }
968: else {
969: result@var391 =@expr1073745011 lhs@var393 %@expr1073745012 rhs@var392 ; }
970: } else {
971: continue ; } }
972:
973: tok@var385 =@expr1073745013 tok@var385 .@expr3128 previous@var388 ;
974: tok@var385 .@expr1073745015 setstr (@expr1073745016 toString (@expr1073745017 result@var391 ) ) ;
975: deleteToken (@expr3194 tok@var385 .@expr3125 next@var387 ) ;
976: deleteToken (@expr3194 tok@var385 .@expr3125 next@var387 ) ;
977: }
978: }
979:
980: void simplecpp :: TokenList :: constFoldAddSub ( Token * tok@var394 )
981: {
982: for (@expr1073745022 ; tok@var394 &&@expr1073745023 tok@var394 .@expr3200 op@var395 !=@expr1073745025 ')' ; tok@var394 =@expr1073745026 tok@var394 .@expr3203 next@var396 ) {
983: if (@expr1073745028 !@expr1073745029 tok@var394 .@expr3206 previous@var397 ||@expr1073745031 !@expr1073745032 tok@var394 .@expr3206 previous@var397 .@expr1073745034 number@var398 ) {
984: continue ; }
985: if (@expr1073745035 !@expr1073745036 tok@var394 .@expr3203 next@var396 ||@expr1073745038 !@expr1073745039 tok@var394 .@expr3203 next@var396 .@expr1073745041 number@var399 ) {
986: continue ; }
987:
988: long long result@var400 ;
989: if (@expr1073745042 tok@var394 .@expr3200 op@var395 ==@expr1073745044 '+' ) {
990: result@var400 =@expr1073745045 stringToLL (@expr3222 tok@var394 .@expr3206 previous@var397 .@expr3224 str (@expr3225 ) ) +@expr1073745050 stringToLL (@expr3227 tok@var394 .@expr3203 next@var396 .@expr3229 str (@expr3230 ) ) ; }
991: else { if (@expr1073745055 tok@var394 .@expr3200 op@var395 ==@expr1073745057 '-' ) {
992: result@var400 =@expr1073745058 stringToLL (@expr3222 tok@var394 .@expr3206 previous@var397 .@expr3224 str (@expr3225 ) ) -@expr1073745063 stringToLL (@expr3227 tok@var394 .@expr3203 next@var396 .@expr3229 str (@expr3230 ) ) ; }
993: else {
994: continue ; } }
995:
996: tok@var394 =@expr1073745068 tok@var394 .@expr3206 previous@var397 ;
997: tok@var394 .@expr1073745070 setstr (@expr1073745071 toString (@expr1073745072 result@var400 ) ) ;
998: deleteToken (@expr3249 tok@var394 .@expr3203 next@var396 ) ;
999: deleteToken (@expr3249 tok@var394 .@expr3203 next@var396 ) ;
1000: }
1001: }
1002:
1003: void simplecpp :: TokenList :: constFoldShift ( Token * tok@var401 )
1004: {
1005: for (@expr1073745077 ; tok@var401 &&@expr1073745078 tok@var401 .@expr1073745079 op@var402 !=@expr1073745080 ')' ; tok@var401 =@expr1073745081 tok@var401 .@expr3258 next@var403 ) {
1006: if (@expr1073745083 !@expr1073745084 tok@var401 .@expr3261 previous@var404 ||@expr1073745086 !@expr1073745087 tok@var401 .@expr3261 previous@var404 .@expr1073745089 number@var405 ) {
1007: continue ; }
1008: if (@expr1073745090 !@expr1073745091 tok@var401 .@expr3258 next@var403 ||@expr1073745093 !@expr1073745094 tok@var401 .@expr3258 next@var403 .@expr1073745096 number@var406 ) {
1009: continue ; }
1010:
1011: long long result@var407 ;
1012: if (@expr1073745097 tok@var401 .@expr3274 str (@expr3275 ) ==@expr1073745100 "<<" ) {
1013: result@var407 =@expr1073745101 stringToLL (@expr3278 tok@var401 .@expr3261 previous@var404 .@expr3280 str (@expr3281 ) ) <<@expr1073745106 stringToLL (@expr3283 tok@var401 .@expr3258 next@var403 .@expr3285 str (@expr3286 ) ) ; }
1014: else { if (@expr1073745111 tok@var401 .@expr3274 str (@expr3275 ) ==@expr1073745114 ">>" ) {
1015: result@var407 =@expr1073745115 stringToLL (@expr3278 tok@var401 .@expr3261 previous@var404 .@expr3280 str (@expr3281 ) ) >>@expr1073745120 stringToLL (@expr3283 tok@var401 .@expr3258 next@var403 .@expr3285 str (@expr3286 ) ) ; }
1016: else {
1017: continue ; } }
1018:
1019: tok@var401 =@expr1073745125 tok@var401 .@expr3261 previous@var404 ;
1020: tok@var401 .@expr1073745127 setstr (@expr1073745128 toString (@expr1073745129 result@var407 ) ) ;
1021: deleteToken (@expr3306 tok@var401 .@expr3258 next@var403 ) ;
1022: deleteToken (@expr3306 tok@var401 .@expr3258 next@var403 ) ;
1023: }
1024: }
1025:
1026: static const std :: string NOTEQ@var408 ( "not_eq" ) ;
1027: void simplecpp :: TokenList :: constFoldComparison ( Token * tok@var409 )
1028: {
1029: for (@expr1073745134 ; tok@var409 &&@expr1073745135 tok@var409 .@expr1073745136 op@var410 !=@expr1073745137 ')' ; tok@var409 =@expr1073745138 tok@var409 .@expr3315 next@var411 ) {
1030: if (@expr1073745140 isAlternativeBinaryOp (@expr1073745141 tok@var409 , NOTEQ@var408 ) ) {
1031: tok@var409 .@expr3318 setstr (@expr1073745143 "!=" ) ; }
1032:
1033: if (@expr1073745144 !@expr1073745145 tok@var409 .@expr1073745146 startsWithOneOf (@expr1073745147 "<>=!" ) ) {
1034: continue ; }
1035: if (@expr1073745148 !@expr1073745149 tok@var409 .@expr3326 previous@var412 ||@expr1073745151 !@expr1073745152 tok@var409 .@expr3326 previous@var412 .@expr1073745154 number@var413 ) {
1036: continue ; }
1037: if (@expr1073745155 !@expr1073745156 tok@var409 .@expr3315 next@var411 ||@expr1073745158 !@expr1073745159 tok@var409 .@expr3315 next@var411 .@expr1073745161 number@var414 ) {
1038: continue ; }
1039:
1040: int result@var415 ;
1041: if (@expr1073745162 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745165 "==" ) {
1042: result@var415 =@expr1073745166 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) ==@expr1073745171 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1043: else { if (@expr1073745176 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745179 "!=" ) {
1044: result@var415 =@expr1073745180 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) !=@expr1073745185 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1045: else { if (@expr1073745190 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745193 ">" ) {
1046: result@var415 =@expr1073745194 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) >@expr1073745199 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1047: else { if (@expr1073745204 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745207 ">=" ) {
1048: result@var415 =@expr1073745208 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) >=@expr1073745213 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1049: else { if (@expr1073745218 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745221 "<" ) {
1050: result@var415 =@expr1073745222 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) <@expr1073745227 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1051: else { if (@expr1073745232 tok@var409 .@expr3339 str (@expr3340 ) ==@expr1073745235 "<=" ) {
1052: result@var415 =@expr1073745236 stringToLL (@expr3343 tok@var409 .@expr3326 previous@var412 .@expr3345 str (@expr3346 ) ) <=@expr1073745241 stringToLL (@expr3348 tok@var409 .@expr3315 next@var411 .@expr3350 str (@expr3351 ) ) ; }
1053: else {
1054: continue ; } } } } } }
1055:
1056: tok@var409 =@expr1073745246 tok@var409 .@expr3326 previous@var412 ;
1057: tok@var409 .@expr3318 setstr (@expr1073745249 toString (@expr1073745250 result@var415 ) ) ;
1058: deleteToken (@expr3427 tok@var409 .@expr3315 next@var411 ) ;
1059: deleteToken (@expr3427 tok@var409 .@expr3315 next@var411 ) ;
1060: }
1061: }
1062:
1063: static const std :: string BITAND@var416 ( "bitand" ) ;
1064: static const std :: string BITOR@var417 ( "bitor" ) ;
1065: static const std :: string XOR@var418 ( "xor" ) ;
1066: void simplecpp :: TokenList :: constFoldBitwise ( Token * tok@var419 )
1067: {
1068: Token * const tok1@var420 ; tok1@var420 =@expr1073745255 tok@var419 ;
1069: for (@expr1073745256 const char *@expr1073745257 op@var421 =@expr1073745258 "&^|" ; *@expr3435 op@var421 ; op@var421 ++@expr1073745260 ) {
1070: const std ::@expr1073745261 string * alternativeOp@var422 ;
1071: if (@expr3438 *@expr3435 op@var421 ==@expr3440 '&' ) {
1072: alternativeOp@var422 =@expr1073745265 &@expr1073745266 BITAND@var416 ; }
1073: else { if (@expr1073745267 *@expr3435 op@var421 ==@expr1073745269 '|' ) {
1074: alternativeOp@var422 =@expr1073745270 &@expr1073745271 BITOR@var417 ; }
1075: else {
1076: alternativeOp@var422 =@expr1073745272 &@expr1073745273 XOR@var418 ; } }
1077: for (@expr1073745274 tok@var419 =@expr1073745275 tok1@var420 ; tok@var419 &&@expr1073745276 tok@var419 .@expr3453 op@var423 !=@expr1073745278 ')' ; tok@var419 =@expr1073745279 tok@var419 .@expr3456 next@var424 ) {
1078: if (@expr1073745281 tok@var419 .@expr3453 op@var423 !=@expr1073745283 *@expr3435 op@var421 &&@expr1073745285 !@expr1073745286 isAlternativeBinaryOp (@expr1073745287 tok@var419 , *@expr1073745288 alternativeOp@var422 ) ) {
1079: continue ; }
1080: if (@expr1073745289 !@expr1073745290 tok@var419 .@expr3467 previous@var425 ||@expr1073745292 !@expr1073745293 tok@var419 .@expr3467 previous@var425 .@expr1073745295 number@var426 ) {
1081: continue ; }
1082: if (@expr1073745296 !@expr1073745297 tok@var419 .@expr3456 next@var424 ||@expr1073745299 !@expr1073745300 tok@var419 .@expr3456 next@var424 .@expr1073745302 number@var427 ) {
1083: continue ; }
1084: long long result@var428 ;
1085: if (@expr3438 *@expr3435 op@var421 ==@expr3440 '&' ) {
1086: result@var428 =@expr1073745306 stringToLL (@expr3483 tok@var419 .@expr3467 previous@var425 .@expr3485 str (@expr3486 ) ) &@expr1073745311 stringToLL (@expr3488 tok@var419 .@expr3456 next@var424 .@expr3490 str (@expr3491 ) ) ; }
1087: else { if (@expr1073745316 *@expr3435 op@var421 ==@expr1073745318 '^' ) {
1088: result@var428 =@expr1073745319 stringToLL (@expr3483 tok@var419 .@expr3467 previous@var425 .@expr3485 str (@expr3486 ) ) ^@expr1073745324 stringToLL (@expr3488 tok@var419 .@expr3456 next@var424 .@expr3490 str (@expr3491 ) ) ; }
1089: else {
1090: result@var428 =@expr1073745329 stringToLL (@expr3483 tok@var419 .@expr3467 previous@var425 .@expr3485 str (@expr3486 ) ) |@expr1073745334 stringToLL (@expr3488 tok@var419 .@expr3456 next@var424 .@expr3490 str (@expr3491 ) ) ; } }
1091: tok@var419 =@expr1073745339 tok@var419 .@expr3467 previous@var425 ;
1092: tok@var419 .@expr1073745341 setstr (@expr1073745342 toString (@expr1073745343 result@var428 ) ) ;
1093: deleteToken (@expr3520 tok@var419 .@expr3456 next@var424 ) ;
1094: deleteToken (@expr3520 tok@var419 .@expr3456 next@var424 ) ;
1095: }
1096: }
1097: }
1098:
1099: static const std :: string AND@var429 ( "and" ) ;
1100: static const std :: string OR@var430 ( "or" ) ;
1101: void simplecpp :: TokenList :: constFoldLogicalOp ( Token * tok@var431 )
1102: {
1103: for (@expr1073745348 ; tok@var431 &&@expr1073745349 tok@var431 .@expr1073745350 op@var432 !=@expr1073745351 ')' ; tok@var431 =@expr1073745352 tok@var431 .@expr3529 next@var433 ) {
1104: if (@expr1073745354 tok@var431 .@expr1073745355 name@var434 ) {
1105: if (@expr1073745356 isAlternativeBinaryOp (@expr1073745357 tok@var431 , AND@var429 ) ) {
1106: tok@var431 .@expr3534 setstr (@expr1073745359 "&&" ) ; }
1107: else { if (@expr1073745360 isAlternativeBinaryOp (@expr1073745361 tok@var431 , OR@var430 ) ) {
1108: tok@var431 .@expr3534 setstr (@expr1073745363 "||" ) ; } }
1109: }
1110: if (@expr1073745364 tok@var431 .@expr3541 str (@expr3542 ) !=@expr1073745367 "&&" &&@expr1073745368 tok@var431 .@expr3541 str (@expr3542 ) !=@expr1073745371 "||" ) {
1111: continue ; }
1112: if (@expr1073745372 !@expr1073745373 tok@var431 .@expr3550 previous@var435 ||@expr1073745375 !@expr1073745376 tok@var431 .@expr3550 previous@var435 .@expr1073745378 number@var436 ) {
1113: continue ; }
1114: if (@expr1073745379 !@expr1073745380 tok@var431 .@expr3529 next@var433 ||@expr1073745382 !@expr1073745383 tok@var431 .@expr3529 next@var433 .@expr1073745385 number@var437 ) {
1115: continue ; }
1116:
1117: int result@var438 ;
1118: if (@expr1073745386 tok@var431 .@expr3541 str (@expr3542 ) ==@expr1073745389 "||" ) {
1119: result@var438 =@expr1073745390 stringToLL (@expr3567 tok@var431 .@expr3550 previous@var435 .@expr3569 str (@expr3570 ) ) ||@expr1073745395 stringToLL (@expr3572 tok@var431 .@expr3529 next@var433 .@expr3574 str (@expr3575 ) ) ; }
1120: else {
1121: result@var438 =@expr1073745400 stringToLL (@expr3567 tok@var431 .@expr3550 previous@var435 .@expr3569 str (@expr3570 ) ) &&@expr1073745405 stringToLL (@expr3572 tok@var431 .@expr3529 next@var433 .@expr3574 str (@expr3575 ) ) ; }
1122:
1123: tok@var431 =@expr1073745410 tok@var431 .@expr3550 previous@var435 ;
1124: tok@var431 .@expr3534 setstr (@expr1073745413 toString (@expr1073745414 result@var438 ) ) ;
1125: deleteToken (@expr3591 tok@var431 .@expr3529 next@var433 ) ;
1126: deleteToken (@expr3591 tok@var431 .@expr3529 next@var433 ) ;
1127: }
1128: }
1129:
1130: void simplecpp :: TokenList :: constFoldQuestionOp ( Token * * tok1@var439 )
1131: {
1132: bool gotoTok1@var440 ; gotoTok1@var440 =@expr1073745419 false ;
1133: for (@expr1073745420 Token *@expr1073745421 tok@var441 =@expr1073745422 *@expr3599 tok1@var439 ; tok@var441 &&@expr1073745424 tok@var441 .@expr1073745425 op@var442 !=@expr1073745426 ')' ; tok@var441 =@expr1073745427 gotoTok1@var440 ?@expr1073745428 *@expr3599 tok1@var439 :@expr1073745430 tok@var441 .@expr3607 next@var443 ) {
1134: gotoTok1@var440 =@expr1073745432 false ;
1135: if (@expr1073745433 tok@var441 .@expr1073745434 str (@expr1073745435 ) !=@expr1073745436 "?" ) {
1136: continue ; }
1137: if (@expr1073745437 !@expr1073745438 tok@var441 .@expr3615 previous@var444 ||@expr1073745440 !@expr1073745441 tok@var441 .@expr3607 next@var443 ||@expr1073745443 !@expr1073745444 tok@var441 .@expr3607 next@var443 .@expr3622 next@var445 ) {
1138: throw std ::@expr3623 runtime_error (@expr3624 "invalid expression" ) ; }
1139: if (@expr1073745449 !@expr1073745450 tok@var441 .@expr3615 previous@var444 .@expr1073745452 number@var446 ) {
1140: continue ; }
1141: if (@expr1073745453 tok@var441 .@expr3607 next@var443 .@expr3622 next@var445 .@expr1073745456 op@var447 !=@expr1073745457 ':' ) {
1142: continue ; }
1143: Token * const condTok@var448 ; condTok@var448 =@expr1073745458 tok@var441 .@expr3615 previous@var444 ;
1144: Token * const trueTok@var449 ; trueTok@var449 =@expr1073745460 tok@var441 .@expr3607 next@var443 ;
1145: Token * const falseTok@var450 ; falseTok@var450 =@expr1073745462 trueTok@var449 .@expr3639 next@var451 .@expr1073745464 next@var452 ;
1146: if (@expr1073745465 !@expr1073745466 falseTok@var450 ) {
1147: throw std ::@expr3623 runtime_error (@expr3624 "invalid expression" ) ; }
1148: if (@expr1073745469 condTok@var448 ==@expr1073745470 *@expr3599 tok1@var439 ) {
1149: *@expr3599 tok1@var439 =@expr1073745473 condTok@var448 .@expr3650 str (@expr3651 ) !=@expr1073745476 "0" ?@expr1073745477 trueTok@var449 :@expr3654 falseTok@var450 ; }
1150: deleteToken (@expr1073745479 condTok@var448 .@expr1073745480 next@var453 ) ;
1151: deleteToken (@expr1073745481 trueTok@var449 .@expr3639 next@var451 ) ;
1152: deleteToken (@expr1073745483 condTok@var448 .@expr3650 str (@expr3651 ) ==@expr1073745486 "0" ?@expr1073745487 trueTok@var449 :@expr3654 falseTok@var450 ) ;
1153: deleteToken (@expr1073745489 condTok@var448 ) ;
1154: gotoTok1@var440 =@expr1073745490 true ;
1155: }
1156: }
1157:
1158: void simplecpp :: TokenList :: removeComments ( )
1159: {
1160: Token * tok@var454 ; tok@var454 =@expr1073745491 frontToken@var109 ;
1161: while (@expr1073745492 tok@var454 ) {
1162: Token * tok1@var455 ; tok1@var455 =@expr1073745493 tok@var454 ;
1163: tok@var454 =@expr1073745494 tok@var454 .@expr1073745495 next@var456 ;
1164: if (@expr1073745496 tok1@var455 .@expr1073745497 comment@var457 ) {
1165: deleteToken (@expr1073745498 tok1@var455 ) ; }
1166: }
1167: }
1168:
1169: std :: string simplecpp :: TokenList :: readUntil ( std :: istream & istr@var458 , const Location & location@var459 , const char start@var460 , const char end@var461 , OutputList * outputList@var462 , unsigned int bom@var463 )
1170: {
1171: std ::@expr1073745500 string ret@var464 ;
1172: ret@var464 +=@expr1073745501 start@var460 ;
1173:
1174: bool backslash@var465 ; backslash@var465 =@expr1073745502 false ;
1175: char ch@var466 ; ch@var466 =@expr1073745503 0 ;
1176: while (@expr1073745504 ch@var466 !=@expr3681 end@var461 &&@expr1073745506 ch@var466 !=@expr1073745507 '\r' &&@expr1073745508 ch@var466 !=@expr1073745509 '\n' &&@expr1073745510 istr@var458 .@expr3687 good (@expr3688 ) ) {
1177: ch@var466 =@expr1073745513 readChar (@expr3690 istr@var458 , bom@var463 ) ;
1178: if (@expr1073745515 backslash@var465 &&@expr1073745516 ch@var466 ==@expr1073745517 '\n' ) {
1179: ch@var466 =@expr1073745518 0 ;
1180: backslash@var465 =@expr1073745519 false ;
1181: continue ;
1182: }
1183: backslash@var465 =@expr1073745520 false ;
1184: ret@var464 +=@expr1073745521 ch@var466 ;
1185: if (@expr1073745522 ch@var466 ==@expr1073745523 '\\' ) {
1186: bool update_ch@var467 ; update_ch@var467 =@expr1073745524 false ;
1187: char next@var468 ; next@var468 =@expr1073745525 0 ;
1188: do {
1189: next@var468 =@expr1073745526 readChar (@expr3690 istr@var458 , bom@var463 ) ;
1190: if (@expr1073745528 next@var468 ==@expr3705 '\r' ||@expr1073745530 next@var468 ==@expr1073745531 '\n' ) {
1191: ret@var464 .@expr1073745532 erase (@expr1073745533 ret@var464 .@expr1073745534 size (@expr1073745535 ) -@expr1073745536 1U ) ;
1192: backslash@var465 =@expr1073745537 next@var468 ==@expr3705 '\r' ;
1193: update_ch@var467 =@expr1073745539 false ;
1194: } else { if (@expr1073745540 next@var468 ==@expr3717 '\\' ) {
1195: update_ch@var467 =@expr1073745542 !@expr1073745543 update_ch@var467 ; } }
1196: ret@var464 +=@expr1073745544 next@var468 ;
1197: } while (@expr1073745545 next@var468 ==@expr3717 '\\' ) ;
1198: if (@expr1073745547 update_ch@var467 ) {
1199: ch@var466 =@expr1073745548 next@var468 ; }
1200: }
1201: }
1202:
1203: if (@expr1073745549 !@expr1073745550 istr@var458 .@expr3687 good (@expr3688 ) ||@expr1073745553 ch@var466 !=@expr3681 end@var461 ) {
1204: clear (@expr1073745555 ) ;
1205: if (@expr1073745556 outputList@var462 ) {
1206: Output err@var469 (@expr1073745557 files@var111 ) ;
1207: err@var469 .@expr1073745558 type@var470 =@expr1073745559 Output ::@expr1073745560 SYNTAX_ERROR@expr1073745499 ;
1208: err@var469 .@expr1073745561 location@var471 =@expr1073745562 location@var459 ;
1209: err@var469 .@expr1073745563 msg@var472 =@expr1073745564 std ::@expr1073745565 string (@expr1073745566 "No pair for character (" ) +@expr1073745567 start@var460 +@expr1073745568 "). Can't process file. File is either invalid or unicode, which is currently not supported." ;
1210: outputList@var462 .@expr1073745569 push_back (@expr1073745570 err@var469 ) ;
1211: }
1212: return "" ;
1213: }
1214:
1215: return ret@var464 ;
1216: }
1217:
1218: std :: string simplecpp :: TokenList :: lastLine ( int maxsize@var473 ) const
1219: {
1220: std ::@expr1073745571 string ret@var474 ;
1221: int count@var475 ; count@var475 =@expr1073745572 0 ;
1222: for (@expr1073745573 const Token *@expr1073745574 tok@var476 =@expr1073745575 cback (@expr3752 ) ; ; tok@var476 =@expr1073745577 tok@var476 .@expr1073745578 previous@var477 ) {
1223: if (@expr1073745579 !@expr1073745580 sameline (@expr1073745581 tok@var476 , cback (@expr3752 ) ) ) {
1224: break ;
1225: }
1226: if (@expr1073745583 tok@var476 .@expr1073745584 comment@var478 ) {
1227: continue ; }
1228: if (@expr1073745585 ++@expr1073745586 count@var475 >@expr1073745587 maxsize@var473 ) {
1229: return "" ; }
1230: if (@expr1073745588 !@expr1073745589 ret@var474 .@expr1073745590 empty (@expr1073745591 ) ) {
1231: ret@var474 .@expr3768 insert (@expr1073745593 0 , 1 , ' ' ) ; }
1232: if (@expr1073745594 tok@var476 .@expr3771 str (@expr3772 ) [@expr1073745597 0 ] ==@expr1073745598 '\"' ) {
1233: ret@var474 .@expr3768 insert (@expr1073745600 0 , "%str%" ) ; }
1234: else { if (@expr1073745601 tok@var476 .@expr1073745602 number@var479 ) {
1235: ret@var474 .@expr3768 insert (@expr1073745604 0 , "%num%" ) ; }
1236: else {
1237: ret@var474 .@expr3768 insert (@expr1073745606 0 , tok@var476 .@expr3771 str (@expr3772 ) ) ; } }
1238: }
1239: return ret@var474 ;
1240: }
1241:
1242: bool simplecpp :: TokenList :: isLastLinePreprocessor ( int maxsize@var480 ) const
1243: {
1244: const Token * prevTok@var481 ; prevTok@var481 =@expr1073745609 nullptr ;
1245: int count@var482 ; count@var482 =@expr1073745610 0 ;
1246: for (@expr1073745611 const Token *@expr1073745612 tok@var483 =@expr1073745613 cback (@expr3790 ) ; ; tok@var483 =@expr1073745615 tok@var483 .@expr1073745616 previous@var484 ) {
1247: if (@expr1073745617 !@expr1073745618 sameline (@expr1073745619 tok@var483 , cback (@expr3790 ) ) ) {
1248: break ; }
1249: if (@expr1073745621 tok@var483 .@expr1073745622 comment@var485 ) {
1250: continue ; }
1251: if (@expr1073745623 ++@expr1073745624 count@var482 >@expr1073745625 maxsize@var480 ) {
1252: return false ; }
1253: prevTok@var481 =@expr1073745626 tok@var483 ;
1254: }
1255: return prevTok@var481 &&@expr1073745627 prevTok@var481 .@expr1073745628 str (@expr1073745629 ) [@expr1073745630 0 ] ==@expr1073745631 '#' ;
1256: }
1257:
1258: unsigned int simplecpp :: TokenList :: fileIndex ( const std :: string & filename@var486 )
1259: {
1260: for (@expr1073745632 unsigned int i@var487 =@expr1073745633 0 ; i@var487 <@expr1073745634 files@var111 .@expr3811 size (@expr3812 ) ; ++@expr1073745637 i@var487 ) {
1261: if (@expr1073745638 files@var111 [@expr1073745639 i@var487 ] ==@expr1073745640 filename@var486 ) {
1262: return i@var487 ; }
1263: }
1264: files@var111 .@expr1073745641 push_back (@expr1073745642 filename@var486 ) ;
1265: return files@var111 .@expr3811 size (@expr3812 ) -@expr1073745645 1U ;
1266: }
1267:
1268:
1269: namespace simplecpp {
1270: class Macro ;
1271:
|
1276:
1277: class Macro {
1278: public:
1279: explicit Macro ( std :: vector < std :: string > & f@var488 ) : nameTokDef@var794 ( nullptr ) , variadic@var796 ( false ) , valueToken@var797 ( nullptr ) , endToken@var798 ( nullptr ) , files@var799 ( f@var488 ) , tokenListDefine@var800 ( f@var488 ) , valueDefinedInCode_@var802 ( false ) { }
1280:
1281: Macro ( const Token * tok@var489 , std :: vector < std :: string > & f@var490 ) : nameTokDef@var794 ( nullptr ) , files@var799 ( f@var490 ) , tokenListDefine@var800 ( f@var490 ) , valueDefinedInCode_@var802 ( true ) {
1282: if (@expr1073745646 sameline (@expr1073745647 tok@var489 .@expr1073745648 previous@var491 , tok@var489 ) ) {
1283: throw std ::@expr3825 runtime_error (@expr3826 "bad macro syntax" ) ; }
1284: if (@expr1073745651 tok@var489 .@expr1073745652 op@var492 !=@expr1073745653 '#' ) {
1285: throw std ::@expr3825 runtime_error (@expr3826 "bad macro syntax" ) ; }
1286: const Token * const hashtok@var493 ; hashtok@var493 =@expr1073745656 tok@var489 ;
1287: tok@var489 =@expr1073745657 tok@var489 .@expr3834 next@var494 ;
1288: if (@expr1073745659 !@expr3836 tok@var489 ||@expr1073745661 tok@var489 .@expr1073745662 str (@expr1073745663 ) !=@expr1073745664 DEFINE@var152 ) {
1289: throw std ::@expr3825 runtime_error (@expr3826 "bad macro syntax" ) ; }
1290: tok@var489 =@expr1073745667 tok@var489 .@expr3834 next@var494 ;
1291: if (@expr1073745669 !@expr3836 tok@var489 ||@expr1073745671 !@expr1073745672 tok@var489 .@expr1073745673 name@var495 ||@expr1073745674 !@expr1073745675 sameline (@expr1073745676 hashtok@var493 , tok@var489 ) ) {
1292: throw std ::@expr3825 runtime_error (@expr3826 "bad macro syntax" ) ; }
1293: if (@expr1073745679 !@expr1073745680 parseDefine (@expr1073745681 tok@var489 ) ) {
1294: throw std ::@expr3825 runtime_error (@expr3826 "bad macro syntax" ) ; }
1295: }
1296:
1297: Macro ( const std :: string & name@var496 , const std :: string & value@var497 , std :: vector < std :: string > & f@var498 ) : nameTokDef@var794 ( nullptr ) , files@var799 ( f@var498 ) , tokenListDefine@var800 ( f@var498 ) , valueDefinedInCode_@var802 ( false ) {
1298: const std ::@expr1073745684 string def@var499 (@expr1073745685 name@var496 +@expr1073745686 ' ' +@expr1073745687 value@var497 ) ;
1299: std ::@expr1073745688 istringstream istr@var500 (@expr1073745689 def@var499 ) ;
1300: tokenListDefine@var800 .@expr1073745690 readfile (@expr1073745691 istr@var500 ) ;
1301: if (@expr1073745692 !@expr1073745693 parseDefine (@expr1073745694 tokenListDefine@var800 .@expr1073745695 cfront (@expr1073745696 ) ) ) {
1302: throw std ::@expr1073745697 runtime_error (@expr1073745698 "bad macro syntax. macroname=" +@expr1073745699 name@var496 +@expr1073745700 " value=" +@expr1073745701 value@var497 ) ; }
1303: }
1304:
1305: Macro ( const Macro & other@var501 ) : nameTokDef@var794 ( nullptr ) , files@var799 ( other@var501 . files@var502 ) , tokenListDefine@var800 ( other@var501 . files@var502 ) , valueDefinedInCode_@var802 ( other@var501 . valueDefinedInCode_@var503 ) {
1306: *@expr1073745702 this@expr1073745703 =@expr1073745704 other@var501 ;
1307: }
1308:
1309: Macro & operator= ( const Macro & other@var504 ) {
1310: if (@expr1073745705 this@expr3882 !=@expr1073745707 &@expr1073745708 other@var504 ) {
1311: files@var799 =@expr1073745709 other@var504 .@expr1073745710 files@var505 ;
1312: valueDefinedInCode_@var802 =@expr1073745711 other@var504 .@expr1073745712 valueDefinedInCode_@var506 ;
1313: if (@expr1073745713 other@var504 .@expr3890 tokenListDefine@var507 .@expr1073745715 empty (@expr1073745716 ) ) {
1314: parseDefine (@expr1073745717 other@var504 .@expr1073745718 nameTokDef@var508 ) ; }
1315: else {
1316: tokenListDefine@var800 =@expr1073745719 other@var504 .@expr3890 tokenListDefine@var507 ;
1317: parseDefine (@expr1073745721 tokenListDefine@var800 .@expr1073745722 cfront (@expr1073745723 ) ) ;
1318: }
1319: }
1320: return *@expr1073745724 this@expr3882 ;
1321: }
1322:
1323: bool valueDefinedInCode ( ) const {
1324: return valueDefinedInCode_@var802 ;
1325: }
1326:
|
1335:
1336: const Token * expand ( TokenList * const output@var509 ,
1337: const Token * rawtok@var510 ,
1338: const std :: unordered_map < std :: string , Macro > & macros@var511 ,
1339: std :: vector < std :: string > & inputFiles@var512 ) const {
1340: std ::@expr1073745725 set < std ::@expr3902 string > expandedmacros@var513 ;
1341:
1342: TokenList output2@var514 (@expr1073745727 inputFiles@var512 ) ;
1343:
1344: if (@expr1073745728 functionLike (@expr1073745729 ) &&@expr1073745730 rawtok@var510 .@expr3907 next@var515 &&@expr1073745732 rawtok@var510 .@expr3907 next@var515 .@expr1073745734 op@var516 ==@expr1073745735 '(' ) {
1345:
1346: const Token * const rawtok1@var517 ; rawtok1@var517 =@expr1073745736 rawtok@var510 ;
1347: TokenList rawtokens2@var518 (@expr1073745737 inputFiles@var512 ) ;
1348: rawtokens2@var518 .@expr3914 push_back (@expr3915 new Token (@expr3916 rawtok@var510 .@expr3917 str (@expr3918 ) , rawtok1@var517 .@expr3919 location@var519 ) ) ;
1349: rawtok@var510 =@expr1073745744 rawtok@var510 .@expr3907 next@var515 ;
1350: rawtokens2@var518 .@expr3914 push_back (@expr3915 new Token (@expr3916 rawtok@var510 .@expr3917 str (@expr3918 ) , rawtok1@var517 .@expr3919 location@var519 ) ) ;
1351: rawtok@var510 =@expr1073745752 rawtok@var510 .@expr3907 next@var515 ;
1352: int par@var520 ; par@var520 =@expr1073745754 1 ;
1353: while (@expr1073745755 rawtok@var510 &&@expr1073745756 par@var520 >@expr1073745757 0 ) {
1354: if (@expr3934 rawtok@var510 .@expr3935 op@var521 ==@expr3936 '(' ) {
1355: ++@expr1073745761 par@var520 ; }
1356: else { if (@expr1073745762 rawtok@var510 .@expr3935 op@var521 ==@expr1073745764 ')' ) {
1357: --@expr1073745765 par@var520 ; }
1358: else { if (@expr1073745766 rawtok@var510 .@expr3935 op@var521 ==@expr1073745768 '#' &&@expr1073745769 !@expr1073745770 sameline (@expr1073745771 rawtok@var510 .@expr1073745772 previous@var522 , rawtok@var510 ) ) {
1359: throw Error (@expr1073745773 rawtok@var510 .@expr3950 location@var523 , "it is invalid to use a preprocessor directive as macro parameter" ) ; } } }
1360: rawtokens2@var518 .@expr3914 push_back (@expr3915 new Token (@expr3916 rawtok@var510 .@expr3917 str (@expr3918 ) , rawtok1@var517 .@expr3919 location@var519 ) ) ;
1361: rawtok@var510 =@expr1073745781 rawtok@var510 .@expr3907 next@var515 ;
1362: }
1363: bool first@var524 ; first@var524 =@expr1073745783 true ;
1364: if (@expr1073745784 valueToken@var797 &&@expr1073745785 valueToken@var797 .@expr1073745786 str (@expr1073745787 ) ==@expr1073745788 rawtok1@var517 .@expr1073745789 str (@expr1073745790 ) ) {
1365: first@var524 =@expr1073745791 false ; }
1366: if (@expr1073745792 expand (@expr1073745793 &@expr3970 output2@var514 , rawtok1@var517 .@expr3919 location@var519 , rawtokens2@var518 .@expr1073745796 cfront (@expr1073745797 ) , macros@var511 , expandedmacros@var513 , first@var524 ) ) {
1367: rawtok@var510 =@expr1073745798 rawtok1@var517 .@expr1073745799 next@var525 ; }
1368: } else {
1369: rawtok@var510 =@expr1073745800 expand (@expr1073745801 &@expr3970 output2@var514 , rawtok@var510 .@expr3950 location@var523 , rawtok@var510 , macros@var511 , expandedmacros@var513 ) ;
1370: }
1371: while (@expr1073745804 output2@var514 .@expr3981 cback (@expr3982 ) &&@expr1073745807 rawtok@var510 ) {
1372: unsigned int par@var526 ; par@var526 =@expr1073745808 0 ;
1373: Token * macro2tok@var527 ; macro2tok@var527 =@expr1073745809 output2@var514 .@expr3986 back (@expr3987 ) ;
1374: while (@expr3988 macro2tok@var527 ) {
1375: if (@expr1073745813 macro2tok@var527 .@expr3990 op@var528 ==@expr1073745815 '(' ) {
1376: if (@expr1073745816 par@var526 ==@expr1073745817 0 ) {
1377: break ; }
1378: --@expr1073745818 par@var526 ;
1379: } else { if (@expr1073745819 macro2tok@var527 .@expr3990 op@var528 ==@expr1073745821 ')' ) {
1380: ++@expr1073745822 par@var526 ; } }
1381: macro2tok@var527 =@expr1073745823 macro2tok@var527 .@expr4000 previous@var529 ;
1382: }
1383: if (@expr1073745825 macro2tok@var527 ) {
1384: macro2tok@var527 =@expr1073745826 macro2tok@var527 .@expr4000 previous@var529 ;
1385: expandedmacros@var513 .@expr1073745828 insert (@expr1073745829 name (@expr4006 ) ) ;
1386: } else { if (@expr3934 rawtok@var510 .@expr3935 op@var521 ==@expr3936 '(' ) {
1387: macro2tok@var527 =@expr1073745834 output2@var514 .@expr3986 back (@expr3987 ) ; } }
1388: if (@expr1073745837 !@expr1073745838 macro2tok@var527 ||@expr1073745839 !@expr1073745840 macro2tok@var527 .@expr1073745841 name@var530 ) {
1389: break ; }
1390: if (@expr1073745842 output2@var514 .@expr1073745843 cfront (@expr1073745844 ) !=@expr1073745845 output2@var514 .@expr3981 cback (@expr3982 ) &&@expr1073745848 macro2tok@var527 .@expr4025 str (@expr4026 ) ==@expr1073745851 this@expr1073745852 .@expr1073745853 name (@expr4006 ) ) {
1391: break ; }
1392: const MacroMap ::@expr3902 const_iterator macro@var531 =@expr1073745856 macros@var511 .@expr1073745857 find (@expr1073745858 macro2tok@var527 .@expr4025 str (@expr4026 ) ) ;
1393: if (@expr1073745861 macro@var531 ==@expr1073745862 macros@var511 .@expr1073745863 end (@expr1073745864 ) ||@expr1073745865 !@expr1073745866 macro@var531 .@expr4043 second@var532 .@expr1073745868 functionLike (@expr1073745869 ) ) {
1394: break ; }
1395: TokenList rawtokens2@var533 (@expr1073745870 inputFiles@var512 ) ;
1396: const Location loc@var534 (@expr1073745871 macro2tok@var527 .@expr1073745872 location@var535 ) ;
1397: while (@expr3988 macro2tok@var527 ) {
1398: Token * next@var536 ; next@var536 =@expr1073745874 macro2tok@var527 .@expr1073745875 next@var537 ;
1399: rawtokens2@var533 .@expr4052 push_back (@expr1073745877 new Token (@expr1073745878 macro2tok@var527 .@expr4025 str (@expr4026 ) , loc@var534 ) ) ;
1400: output2@var514 .@expr1073745881 deleteToken (@expr1073745882 macro2tok@var527 ) ;
1401: macro2tok@var527 =@expr1073745883 next@var536 ;
1402: }
1403: par@var526 =@expr1073745884 (@expr1073745885 rawtokens2@var533 .@expr4062 cfront (@expr4063 ) !=@expr1073745888 rawtokens2@var533 .@expr1073745889 cback (@expr1073745890 ) ) ?@expr1073745891 1U :@expr1073745892 0U ;
1404: const Token * rawtok2@var538 ; rawtok2@var538 =@expr1073745893 rawtok@var510 ;
1405: for (@expr1073745894 ; rawtok2@var538 ; rawtok2@var538 =@expr1073745895 rawtok2@var538 .@expr4072 next@var539 ) {
1406: rawtokens2@var533 .@expr4052 push_back (@expr1073745898 new Token (@expr1073745899 rawtok2@var538 .@expr1073745900 str (@expr1073745901 ) , loc@var534 ) ) ;
1407: if (@expr1073745902 rawtok2@var538 .@expr4079 op@var540 ==@expr1073745904 '(' ) {
1408: ++@expr1073745905 par@var526 ; }
1409: else { if (@expr1073745906 rawtok2@var538 .@expr4079 op@var540 ==@expr1073745908 ')' ) {
1410: if (@expr1073745909 par@var526 <=@expr1073745910 1U ) {
1411: break ; }
1412: --@expr1073745911 par@var526 ;
1413: } }
1414: }
1415: if (@expr1073745912 !@expr1073745913 rawtok2@var538 ||@expr1073745914 par@var526 !=@expr1073745915 1U ) {
1416: break ; }
1417: if (@expr1073745916 macro@var531 .@expr4043 second@var532 .@expr1073745918 expand (@expr1073745919 &@expr3970 output2@var514 , rawtok@var510 .@expr3950 location@var523 , rawtokens2@var533 .@expr4062 cfront (@expr4063 ) , macros@var511 , expandedmacros@var513 ) !=@expr1073745924 nullptr ) {
1418: break ; }
1419: rawtok@var510 =@expr1073745925 rawtok2@var538 .@expr4072 next@var539 ;
1420: }
1421: output@var509 .@expr1073745927 takeTokens (@expr1073745928 output2@var514 ) ;
1422: return rawtok@var510 ;
1423: }
1424:
1425:
1426: const std :: string & name ( ) const {
1427: return nameTokDef@var794 .@expr1073745929 str (@expr1073745930 ) ;
1428: }
1429:
1430:
1431: const Location & defineLocation ( ) const {
1432: return nameTokDef@var794 .@expr1073745931 location@var803 ;
1433: }
1434:
1435:
1436: const std :: list < Location > & usage ( ) const {
1437: return usageList@var801 ;
1438: }
1439:
1440:
1441: bool functionLike ( ) const {
1442: return nameTokDef@var794 .@expr4108 next@var804 &&@expr1073745933
1443: nameTokDef@var794 .@expr4108 next@var804 .@expr1073745935 op@var805 ==@expr1073745936 '(' &&@expr1073745937
1444: sameline (@expr1073745938 nameTokDef@var794 , nameTokDef@var794 .@expr4108 next@var804 ) &&@expr1073745940
1445: nameTokDef@var794 .@expr4108 next@var804 .@expr1073745942 location@var806 .@expr1073745943 col@var807 ==@expr1073745944 nameTokDef@var794 .@expr1073745945 location@var803 .@expr1073745946 col@var808 +@expr1073745947 nameTokDef@var794 .@expr1073745948 str (@expr1073745949 ) .@expr1073745950 size (@expr1073745951 ) ;
1446: }
1447:
1448:
1449: struct Error {
1450: Error ( const Location & loc@var541 , const std :: string & s@var542 ) : location@var543 ( loc@var541 ) , what@var544 ( s@var542 ) { }
1451: const Location location@var543 ;
1452: const std :: string what@var544 ;
1453: } ;
1454:
1455:
1456: struct wrongNumberOfParameters : public Error {
1457: wrongNumberOfParameters ( const Location & loc@var545 , const std :: string & macroName@var546 ) : Error ( loc@var545 , "Wrong number of parameters for macro \'" + macroName@var546 + "\'." ) { }
1458: } ;
1459:
1460:
1461: struct invalidHashHash : public Error {
1462: static std :: string format ( const std :: string & macroName@var547 , const std :: string & message@var548 ) {
1463: return "Invalid ## usage when expanding \'" +@expr1073745952 macroName@var547 +@expr1073745953 "\': " +@expr1073745954 message@var548 ;
1464: }
1465:
1466: invalidHashHash ( const Location & loc@var549 , const std :: string & macroName@var550 , const std :: string & message@var551 )
1467: : Error ( loc@var549 , format ( macroName@var550 , message@var551 ) ) { }
1468:
1469: static invalidHashHash unexpectedToken ( const Location & loc@var552 , const std :: string & macroName@var553 , const Token * tokenA@var554 ) {
1470: return invalidHashHash (@expr1073745955 loc@var552 , macroName@var553 , "Unexpected token '" +@expr1073745956 tokenA@var554 .@expr1073745957 str (@expr1073745958 ) +@expr1073745959 "'" ) ;
1471: }
1472:
1473: static invalidHashHash cannotCombine ( const Location & loc@var555 , const std :: string & macroName@var556 , const Token * tokenA@var557 , const Token * tokenB@var558 ) {
1474: return invalidHashHash (@expr1073745960 loc@var555 , macroName@var556 , "Pasting '" +@expr1073745961 tokenA@var557 .@expr1073745962 str (@expr1073745963 ) +@expr1073745964 "' and '" +@expr1073745965 tokenB@var558 .@expr1073745966 str (@expr1073745967 ) +@expr1073745968 "' yields an invalid token." ) ;
1475: }
1476:
1477: static invalidHashHash unexpectedNewline ( const Location & loc@var559 , const std :: string & macroName@var560 ) {
1478: return invalidHashHash (@expr1073745969 loc@var559 , macroName@var560 , "Unexpected newline" ) ;
1479: }
1480: } ;
1481: private:
1482:
1483: Token * newMacroToken ( const std :: string & str@var561 , const Location & loc@var562 , bool replaced@var563 , const Token * expandedFromToken@var564 = nullptr ) const {
1484: Token * tok@var565 ; tok@var565 =@expr1073745970 new Token (@expr1073745971 str@var561 , loc@var562 ) ;
1485: if (@expr1073745972 replaced@var563 ) {
1486: tok@var565 .@expr1073745973 macro@var566 =@expr1073745974 nameTokDef@var794 .@expr1073745975 str (@expr1073745976 ) ; }
1487: if (@expr1073745977 expandedFromToken@var564 ) {
1488: tok@var565 .@expr1073745978 setExpandedFrom (@expr1073745979 expandedFromToken@var564 , this@expr1073745980 ) ; }
1489: return tok@var565 ;
1490: }
1491:
1492: bool parseDefine ( const Token * nametoken@var567 ) {
1493: nameTokDef@var794 =@expr1073745981 nametoken@var567 ;
1494: variadic@var796 =@expr1073745982 false ;
1495: if (@expr1073745983 !@expr1073745984 nameTokDef@var794 ) {
1496: valueToken@var797 =@expr1073745985 endToken@var798 =@expr1073745986 nullptr ;
1497: args@var795 .@expr4163 clear (@expr4164 ) ;
1498: return false ;
1499: }
1500:
1501:
1502: if (@expr1073745989 functionLike (@expr1073745990 ) ) {
1503: args@var795 .@expr4163 clear (@expr4164 ) ;
1504: const Token * argtok@var568 ; argtok@var568 =@expr1073745993 nameTokDef@var794 .@expr4170 next@var804 .@expr1073745995 next@var809 ;
1505: while (@expr1073745996 sameline (@expr4173 nametoken@var567 , argtok@var568 ) &&@expr1073745998 argtok@var568 .@expr4175 op@var569 !=@expr1073746000 ')' ) {
1506: if (@expr1073746001 argtok@var568 .@expr4178 str (@expr4179 ) ==@expr1073746004 "..." &&@expr1073746005
1507: argtok@var568 .@expr4182 next@var570 &&@expr1073746007 argtok@var568 .@expr4182 next@var570 .@expr1073746009 op@var571 ==@expr1073746010 ')' ) {
1508: variadic@var796 =@expr1073746011 true ;
1509: if (@expr1073746012 !@expr1073746013 argtok@var568 .@expr4190 previous@var572 .@expr1073746015 name@var573 ) {
1510: args@var795 .@expr4192 push_back (@expr1073746017 "__VA_ARGS__" ) ; }
1511: argtok@var568 =@expr1073746018 argtok@var568 .@expr4182 next@var570 ;
1512: break ;
1513: }
1514: if (@expr1073746020 argtok@var568 .@expr4175 op@var569 !=@expr1073746022 ',' ) {
1515: args@var795 .@expr4192 push_back (@expr1073746024 argtok@var568 .@expr4178 str (@expr4179 ) ) ; }
1516: argtok@var568 =@expr1073746027 argtok@var568 .@expr4182 next@var570 ;
1517: }
1518: if (@expr1073746029 !@expr1073746030 sameline (@expr4173 nametoken@var567 , argtok@var568 ) ) {
1519: endToken@var798 =@expr1073746032 argtok@var568 ?@expr1073746033 argtok@var568 .@expr4190 previous@var572 :@expr1073746035 argtok@var568 ;
1520: valueToken@var797 =@expr1073746036 nullptr ;
1521: return false ;
1522: }
1523: valueToken@var797 =@expr1073746037 argtok@var568 ?@expr1073746038 argtok@var568 .@expr4182 next@var570 :@expr1073746040 nullptr ;
1524: } else {
1525: args@var795 .@expr4163 clear (@expr4164 ) ;
1526: valueToken@var797 =@expr1073746043 nameTokDef@var794 .@expr4170 next@var804 ;
1527: }
1528:
1529: if (@expr1073746045 !@expr1073746046 sameline (@expr1073746047 valueToken@var797 , nameTokDef@var794 ) ) {
1530: valueToken@var797 =@expr1073746048 nullptr ; }
1531: endToken@var798 =@expr1073746049 valueToken@var797 ;
1532: while (@expr1073746050 sameline (@expr1073746051 endToken@var798 , nameTokDef@var794 ) ) {
1533: endToken@var798 =@expr1073746052 endToken@var798 .@expr1073746053 next@var810 ; }
1534: return true ;
1535: }
1536:
1537: unsigned int getArgNum ( const std :: string & str@var574 ) const {
1538: unsigned int par@var575 ; par@var575 =@expr1073746054 0 ;
1539: while (@expr1073746055 par@var575 <@expr1073746056 args@var795 .@expr1073746057 size (@expr1073746058 ) ) {
1540: if (@expr1073746059 str@var574 ==@expr1073746060 args@var795 [@expr1073746061 par@var575 ] ) {
1541: return par@var575 ; }
1542: par@var575 ++@expr1073746062 ;
1543: }
1544: return ~@expr1073746063 0U ;
1545: }
1546:
1547: std :: vector < const Token * > getMacroParameters ( const Token * nameTokInst@var576 , bool calledInDefine@var577 ) const {
1548: if (@expr1073746064 !@expr1073746065 nameTokInst@var576 .@expr4242 next@var578 ||@expr1073746067 nameTokInst@var576 .@expr4242 next@var578 .@expr1073746069 op@var579 !=@expr1073746070 '(' ||@expr1073746071 !@expr1073746072 functionLike (@expr1073746073 ) ) {
1549: return std ::@expr1073746074 vector < const Token *@expr4251 > (@expr1073746076 ) ; }
1550:
1551: std ::@expr1073746077 vector < const Token *@expr4251 > parametertokens@var580 ;
1552: parametertokens@var580 .@expr4255 push_back (@expr1073746080 nameTokInst@var576 .@expr4242 next@var578 ) ;
1553: unsigned int par@var581 ; par@var581 =@expr1073746082 0U ;
1554: for (@expr1073746083 const Token *@expr4251 tok@var582 =@expr1073746085 nameTokInst@var576 .@expr4242 next@var578 .@expr1073746087 next@var583 ; calledInDefine@var577 ?@expr1073746088 sameline (@expr1073746089 tok@var582 , nameTokInst@var576 ) :@expr1073746090 (@expr1073746091 tok@var582 !=@expr1073746092 nullptr ) ; tok@var582 =@expr1073746093 tok@var582 .@expr1073746094 next@var584 ) {
1555: if (@expr1073746095 tok@var582 .@expr4272 op@var585 ==@expr1073746097 '(' ) {
1556: ++@expr1073746098 par@var581 ; }
1557: else { if (@expr1073746099 tok@var582 .@expr4272 op@var585 ==@expr1073746101 ')' ) {
1558: if (@expr1073746102 par@var581 ==@expr4279 0U ) {
1559: parametertokens@var580 .@expr4255 push_back (@expr4281 tok@var582 ) ;
1560: break ;
1561: }
1562: --@expr1073746106 par@var581 ;
1563: } else { if (@expr1073746107 par@var581 ==@expr4279 0U &&@expr1073746109 tok@var582 .@expr4272 op@var585 ==@expr1073746111 ',' &&@expr1073746112 (@expr1073746113 !@expr1073746114 variadic@var796 ||@expr1073746115 parametertokens@var580 .@expr1073746116 size (@expr1073746117 ) <@expr1073746118 args@var795 .@expr1073746119 size (@expr1073746120 ) ) ) {
1564: parametertokens@var580 .@expr4255 push_back (@expr4281 tok@var582 ) ; } } }
1565: }
1566: return parametertokens@var580 ;
1567: }
1568:
1569: const Token * appendTokens ( TokenList * tokens@var586 ,
1570: const Location & rawloc@var587 ,
1571: const Token * const lpar@var588 ,
1572: const std :: unordered_map < std :: string , Macro > & macros@var589 ,
1573: const std :: set < std :: string > & expandedmacros@var590 ,
1574: const std :: vector < const Token * > & parametertokens@var591 ) const {
1575: if (@expr1073746123 !@expr1073746124 lpar@var588 ||@expr1073746125 lpar@var588 .@expr1073746126 op@var592 !=@expr1073746127 '(' ) {
1576: return nullptr ; }
1577: unsigned int par@var593 ; par@var593 =@expr1073746128 0 ;
1578: const Token * tok@var594 ; tok@var594 =@expr1073746129 lpar@var588 ;
1579: while (@expr1073746130 sameline (@expr4307 lpar@var588 , tok@var594 ) ) {
1580: if (@expr1073746132 tok@var594 .@expr4309 op@var595 ==@expr4310 '#' &&@expr4311 sameline (@expr4312 tok@var594 , tok@var594 .@expr4313 next@var596 ) &&@expr1073746138 tok@var594 .@expr4313 next@var596 .@expr4316 op@var597 ==@expr1073746141 '#' &&@expr1073746142 sameline (@expr1073746143 tok@var594 , tok@var594 .@expr4313 next@var596 .@expr1073746145 next@var598 ) ) {
1581:
1582: tok@var594 =@expr1073746146 expandHashHash (@expr1073746147 tokens@var586 , rawloc@var587 , tok@var594 , macros@var589 , expandedmacros@var590 , parametertokens@var591 ) ;
1583: } else { if (@expr1073746148 tok@var594 .@expr4309 op@var595 ==@expr4310 '#' &&@expr4311 sameline (@expr4312 tok@var594 , tok@var594 .@expr4313 next@var596 ) &&@expr1073746154 tok@var594 .@expr4313 next@var596 .@expr4316 op@var597 !=@expr1073746157 '#' ) {
1584: tok@var594 =@expr1073746158 expandHash (@expr1073746159 tokens@var586 , rawloc@var587 , tok@var594 , macros@var589 , expandedmacros@var590 , parametertokens@var591 ) ;
1585: } else {
1586: if (@expr1073746160 !@expr1073746161 expandArg (@expr1073746162 tokens@var586 , tok@var594 , rawloc@var587 , macros@var589 , expandedmacros@var590 , parametertokens@var591 ) ) {
1587: bool expanded@var599 ; expanded@var599 =@expr1073746163 false ;
1588: const MacroMap ::@expr1073746164 const_iterator it@var600 =@expr1073746165 macros@var589 .@expr1073746166 find (@expr1073746167 tok@var594 .@expr4344 str (@expr4345 ) ) ;
1589: if (@expr1073746170 it@var600 !=@expr1073746171 macros@var589 .@expr1073746172 end (@expr1073746173 ) &&@expr1073746174 expandedmacros@var590 .@expr1073746175 find (@expr1073746176 tok@var594 .@expr4344 str (@expr4345 ) ) ==@expr1073746179 expandedmacros@var590 .@expr1073746180 end (@expr1073746181 ) ) {
1590: const Macro &@expr1073746182 m@var601 =@expr1073746183 it@var600 .@expr1073746184 second@var602 ;
1591: if (@expr1073746185 !@expr1073746186 m@var601 .@expr1073746187 functionLike (@expr1073746188 ) ) {
1592: m@var601 .@expr1073746189 expand (@expr1073746190 tokens@var586 , rawloc@var587 , tok@var594 , macros@var589 , expandedmacros@var590 ) ;
1593: expanded@var599 =@expr1073746191 true ;
1594: }
1595: }
1596: if (@expr1073746192 !@expr1073746193 expanded@var599 ) {
1597: tokens@var586 .@expr1073746194 push_back (@expr1073746195 new Token (@expr1073746196 *@expr1073746197 tok@var594 ) ) ;
1598: if (@expr1073746198 tok@var594 .@expr1073746199 macro@var603 .@expr1073746200 empty (@expr1073746201 ) &&@expr1073746202 (@expr1073746203 par@var593 >@expr1073746204 0 ||@expr1073746205 tok@var594 .@expr4344 str (@expr4345 ) !=@expr1073746208 "(" ) ) {
1599: tokens@var586 .@expr1073746209 back (@expr1073746210 ) .@expr1073746211 macro@var1121 =@expr1073746212 name (@expr1073746213 ) ; }
1600: }
1601: }
1602:
1603: if (@expr1073746214 tok@var594 .@expr4309 op@var595 ==@expr1073746216 '(' ) {
1604: ++@expr1073746217 par@var593 ; }
1605: else { if (@expr1073746218 tok@var594 .@expr4309 op@var595 ==@expr1073746220 ')' ) {
1606: --@expr1073746221 par@var593 ;
1607: if (@expr1073746222 par@var593 ==@expr1073746223 0U ) {
1608: break ; }
1609: } }
1610: tok@var594 =@expr1073746224 tok@var594 .@expr4313 next@var596 ;
1611: } }
1612: }
1613: for (@expr1073746226 Token *@expr1073746227 tok2@var604 =@expr1073746228 tokens@var586 .@expr1073746229 front (@expr1073746230 ) ; tok2@var604 ; tok2@var604 =@expr1073746231 tok2@var604 .@expr1073746232 next@var605 ) {
1614: tok2@var604 .@expr1073746233 location@var606 =@expr1073746234 lpar@var588 .@expr1073746235 location@var607 ; }
1615: return sameline (@expr4307 lpar@var588 , tok@var594 ) ?@expr1073746237 tok@var594 :@expr1073746238 nullptr ;
1616: }
1617:
1618: const Token * expand ( TokenList * const output@var608 , const Location & loc@var609 , const Token * const nameTokInst@var610 , const std :: unordered_map < std :: string , Macro > & macros@var611 , std :: set < std :: string > expandedmacros@var612 , bool first@var613 = false ) const {
1619:
1620: if (@expr1073746239 !@expr1073746240 first@var613 ) {
1621: expandedmacros@var612 .@expr1073746241 insert (@expr1073746242 nameTokInst@var610 .@expr4419 str (@expr4420 ) ) ; }
1622:
1623: usageList@var801 .@expr1073746245 push_back (@expr1073746246 loc@var609 ) ;
1624:
1625: if (@expr1073746247 nameTokInst@var610 .@expr4419 str (@expr4420 ) ==@expr1073746250 "__FILE__" ) {
1626: output@var608 .@expr4427 push_back (@expr1073746252 new Token (@expr1073746253 '\"' +@expr1073746254 loc@var609 .@expr1073746255 file (@expr1073746256 ) +@expr1073746257 '\"' , loc@var609 ) ) ;
1627: return nameTokInst@var610 .@expr4434 next@var614 ;
1628: }
1629: if (@expr1073746259 nameTokInst@var610 .@expr4419 str (@expr4420 ) ==@expr1073746262 "__LINE__" ) {
1630: output@var608 .@expr4427 push_back (@expr1073746264 new Token (@expr1073746265 toString (@expr1073746266 loc@var609 .@expr4443 line@var615 ) , loc@var609 ) ) ;
1631: return nameTokInst@var610 .@expr4434 next@var614 ;
1632: }
1633: if (@expr1073746269 nameTokInst@var610 .@expr4419 str (@expr4420 ) ==@expr1073746272 "__COUNTER__" ) {
1634: output@var608 .@expr4427 push_back (@expr1073746274 new Token (@expr1073746275 toString (@expr1073746276 usageList@var801 .@expr1073746277 size (@expr1073746278 ) -@expr1073746279 1U ) , loc@var609 ) ) ;
1635: return nameTokInst@var610 .@expr4434 next@var614 ;
1636: }
1637:
1638: const bool calledInDefine@var616 =@expr1073746281 loc@var609 .@expr1073746282 fileIndex@var617 !=@expr1073746283 nameTokInst@var610 .@expr4460 location@var618 .@expr1073746285 fileIndex@var619 ||@expr1073746286
1639: loc@var609 .@expr4443 line@var615 <@expr1073746288 nameTokInst@var610 .@expr4460 location@var618 .@expr1073746290 line@var620 ;
1640:
1641: std ::@expr1073746291 vector < const Token *@expr4468 > parametertokens1@var621 (@expr1073746293 getMacroParameters (@expr1073746294 nameTokInst@var610 , calledInDefine@var616 ) ) ;
1642:
1643: if (@expr1073746295 functionLike (@expr4472 ) ) {
1644:
1645: if (@expr1073746297 nameTokInst@var610 .@expr4434 next@var614 &&@expr1073746299 nameTokInst@var610 .@expr4434 next@var614 .@expr1073746301 op@var622 !=@expr1073746302 '(' ) {
1646: output@var608 .@expr4427 push_back (@expr1073746304 new Token (@expr1073746305 nameTokInst@var610 .@expr4419 str (@expr4420 ) , loc@var609 ) ) ;
1647: return nameTokInst@var610 .@expr4434 next@var614 ;
1648: }
1649:
1650:
1651: if (@expr1073746309 variadic@var796 ) {
1652: if (@expr1073746310 parametertokens1@var621 .@expr4487 size (@expr4488 ) <@expr1073746313 args@var795 .@expr4490 size (@expr4491 ) ) {
1653: throw wrongNumberOfParameters (@expr4492 nameTokInst@var610 .@expr4460 location@var618 , name (@expr4494 ) ) ;
1654: }
1655: } else {
1656: if (@expr1073746319 parametertokens1@var621 .@expr4487 size (@expr4488 ) !=@expr1073746322 args@var795 .@expr4490 size (@expr4491 ) +@expr1073746325 (@expr1073746326 args@var795 .@expr1073746327 empty (@expr1073746328 ) ?@expr1073746329 2U :@expr1073746330 1U ) ) {
1657: throw wrongNumberOfParameters (@expr4492 nameTokInst@var610 .@expr4460 location@var618 , name (@expr4494 ) ) ; }
1658: }
1659: }
1660:
1661:
1662: TokenList tokensparams@var623 (@expr1073746334 files@var799 ) ;
1663: std ::@expr1073746335 vector < const Token *@expr4468 > parametertokens2@var624 ;
1664: if (@expr4513 !@expr4514 parametertokens1@var621 .@expr4515 empty (@expr4516 ) ) {
1665: bool counter@var625 ; counter@var625 =@expr1073746341 false ;
1666: for (@expr1073746342 const Token *@expr4468 tok@var626 =@expr1073746344 parametertokens1@var621 [@expr4521 0 ] ; tok@var626 !=@expr1073746346 parametertokens1@var621 .@expr1073746347 back (@expr1073746348 ) ; tok@var626 =@expr1073746349 tok@var626 .@expr1073746350 next@var627 ) {
1667: if (@expr1073746351 tok@var626 .@expr1073746352 str (@expr1073746353 ) ==@expr1073746354 "__COUNTER__" ) {
1668: counter@var625 =@expr1073746355 true ;
1669: break ;
1670: }
1671: }
1672:
1673: const MacroMap ::@expr1073746356 const_iterator m@var628 =@expr1073746357 macros@var611 .@expr1073746358 find (@expr1073746359 "__COUNTER__" ) ;
1674:
1675: if (@expr1073746360 !@expr1073746361 counter@var625 ||@expr1073746362 m@var628 ==@expr1073746363 macros@var611 .@expr1073746364 end (@expr1073746365 ) ) {
1676: parametertokens2@var624 .@expr1073746366 swap (@expr1073746367 parametertokens1@var621 ) ; }
1677: else {
1678: const Macro &@expr1073746368 counterMacro@var629 =@expr1073746369 m@var628 .@expr1073746370 second@var630 ;
1679: unsigned int par@var631 ; par@var631 =@expr1073746371 0 ;
1680: for (@expr1073746372 const Token *@expr4468 tok@var632 =@expr1073746374 parametertokens1@var621 [@expr4521 0 ] ; tok@var632 &&@expr1073746376 par@var631 <@expr1073746377 parametertokens1@var621 .@expr4487 size (@expr4488 ) ; tok@var632 =@expr1073746380 tok@var632 .@expr1073746381 next@var633 ) {
1681: if (@expr1073746382 tok@var632 .@expr1073746383 str (@expr1073746384 ) ==@expr1073746385 "__COUNTER__" ) {
1682: tokensparams@var623 .@expr4562 push_back (@expr1073746387 new Token (@expr1073746388 toString (@expr1073746389 counterMacro@var629 .@expr4566 usageList@var634 .@expr1073746391 size (@expr1073746392 ) ) , tok@var632 .@expr4569 location@var635 ) ) ;
1683: counterMacro@var629 .@expr4566 usageList@var634 .@expr1073746395 push_back (@expr1073746396 tok@var632 .@expr4569 location@var635 ) ;
1684: } else {
1685: tokensparams@var623 .@expr4562 push_back (@expr1073746399 new Token (@expr1073746400 *@expr1073746401 tok@var632 ) ) ;
1686: if (@expr1073746402 tok@var632 ==@expr1073746403 parametertokens1@var621 [@expr1073746404 par@var631 ] ) {
1687: parametertokens2@var624 .@expr1073746405 push_back (@expr1073746406 tokensparams@var623 .@expr1073746407 cback (@expr1073746408 ) ) ;
1688: par@var631 ++@expr1073746409 ;
1689: }
1690: }
1691: }
1692: }
1693: }
1694:
1695: Token * const output_end_1@var636 ; output_end_1@var636 =@expr1073746410 output@var608 .@expr1073746411 back (@expr1073746412 ) ;
1696:
1697:
1698: for (@expr1073746413 const Token *@expr4468 tok@var637 =@expr1073746415 valueToken@var797 ; tok@var637 !=@expr1073746416 endToken@var798 ; ) {
1699: if (@expr1073746417 tok@var637 .@expr4594 op@var638 !=@expr1073746419 '#' ) {
1700:
1701: if (@expr1073746420 sameline (@expr1073746421 tok@var637 , tok@var637 .@expr4598 next@var639 ) &&@expr1073746423 tok@var637 .@expr4598 next@var639 &&@expr1073746425 tok@var637 .@expr4598 next@var639 .@expr1073746427 op@var640 ==@expr1073746428 '#' &&@expr1073746429 tok@var637 .@expr4598 next@var639 .@expr4607 next@var641 &&@expr1073746432 tok@var637 .@expr4598 next@var639 .@expr4607 next@var641 .@expr1073746435 op@var642 ==@expr1073746436 '#' ) {
1702: if (@expr1073746437 !@expr1073746438 sameline (@expr1073746439 tok@var637 , tok@var637 .@expr4598 next@var639 .@expr4607 next@var641 .@expr1073746442 next@var643 ) ) {
1703: throw invalidHashHash ::@expr1073746443 unexpectedNewline (@expr1073746444 tok@var637 .@expr4621 location@var644 , name (@expr4494 ) ) ; }
1704: TokenList new_output@var645 (@expr1073746447 files@var799 ) ;
1705: if (@expr1073746448 !@expr1073746449 expandArg (@expr1073746450 &@expr1073746451 new_output@var645 , tok@var637 , parametertokens2@var624 ) ) {
1706: output@var608 .@expr4427 push_back (@expr1073746453 newMacroToken (@expr1073746454 tok@var637 .@expr1073746455 str (@expr1073746456 ) , loc@var609 , isReplaced (@expr4633 expandedmacros@var612 ) , tok@var637 ) ) ; }
1707: else { if (@expr1073746458 new_output@var645 .@expr1073746459 empty (@expr1073746460 ) ) {
1708: output@var608 .@expr4427 push_back (@expr1073746462 newMacroToken (@expr1073746463 "" , loc@var609 , isReplaced (@expr4633 expandedmacros@var612 ) ) ) ; }
1709: else {
1710: for (@expr1073746465 const Token *@expr4468 tok2@var646 =@expr1073746467 new_output@var645 .@expr1073746468 cfront (@expr1073746469 ) ; tok2@var646 ; tok2@var646 =@expr1073746470 tok2@var646 .@expr1073746471 next@var647 ) {
1711: output@var608 .@expr4427 push_back (@expr1073746473 newMacroToken (@expr1073746474 tok2@var646 .@expr1073746475 str (@expr1073746476 ) , loc@var609 , isReplaced (@expr4633 expandedmacros@var612 ) , tok2@var646 ) ) ; } } }
1712: tok@var637 =@expr1073746478 tok@var637 .@expr4598 next@var639 ;
1713: } else {
1714: tok@var637 =@expr1073746480 expandToken (@expr1073746481 output@var608 , loc@var609 , tok@var637 , macros@var611 , expandedmacros@var612 , parametertokens2@var624 ) ;
1715: }
1716: continue ;
1717: }
1718:
1719: int numberOfHash@var648 ; numberOfHash@var648 =@expr1073746482 1 ;
1720: const Token * hashToken@var649 ; hashToken@var649 =@expr1073746483 tok@var637 .@expr4598 next@var639 ;
1721: while (@expr1073746485 sameline (@expr1073746486 tok@var637 , hashToken@var649 ) &&@expr1073746487 hashToken@var649 .@expr1073746488 op@var650 ==@expr1073746489 '#' ) {
1722: hashToken@var649 =@expr1073746490 hashToken@var649 .@expr1073746491 next@var651 ;
1723: ++@expr1073746492 numberOfHash@var648 ;
1724: }
1725: if (@expr1073746493 numberOfHash@var648 ==@expr1073746494 4 &&@expr1073746495 tok@var637 .@expr4598 next@var639 .@expr4673 location@var652 .@expr4674 col@var653 +@expr1073746499 1 ==@expr1073746500 tok@var637 .@expr4598 next@var639 .@expr4607 next@var641 .@expr1073746503 location@var654 .@expr1073746504 col@var655 ) {
1726:
1727: output@var608 .@expr4427 push_back (@expr1073746506 newMacroToken (@expr1073746507 "##" , loc@var609 , isReplaced (@expr4633 expandedmacros@var612 ) ) ) ;
1728: tok@var637 =@expr1073746509 hashToken@var649 ;
1729: continue ;
1730: }
1731:
1732: if (@expr1073746510 numberOfHash@var648 >=@expr1073746511 2 &&@expr1073746512 tok@var637 .@expr4621 location@var644 .@expr1073746514 col@var656 +@expr1073746515 1 <@expr1073746516 tok@var637 .@expr4598 next@var639 .@expr4673 location@var652 .@expr4674 col@var653 ) {
1733: output@var608 .@expr4427 push_back (@expr1073746521 new Token (@expr1073746522 *@expr1073746523 tok@var637 ) ) ;
1734: tok@var637 =@expr1073746524 tok@var637 .@expr4598 next@var639 ;
1735: continue ;
1736: }
1737:
1738: tok@var637 =@expr1073746526 tok@var637 .@expr4598 next@var639 ;
1739: if (@expr1073746528 tok@var637 ==@expr1073746529 endToken@var798 ) {
1740: output@var608 .@expr4427 push_back (@expr1073746531 new Token (@expr1073746532 *@expr1073746533 tok@var637 .@expr4710 previous@var657 ) ) ;
1741: break ;
1742: }
1743: if (@expr1073746535 tok@var637 .@expr4594 op@var638 ==@expr1073746537 '#' ) {
1744:
1745: tok@var637 =@expr1073746538 expandHashHash (@expr1073746539 output@var608 , loc@var609 , tok@var637 .@expr4710 previous@var657 , macros@var611 , expandedmacros@var612 , parametertokens2@var624 ) ;
1746: } else {
1747:
1748: tok@var637 =@expr1073746541 expandHash (@expr1073746542 output@var608 , loc@var609 , tok@var637 .@expr4710 previous@var657 , macros@var611 , expandedmacros@var612 , parametertokens2@var624 ) ;
1749: }
1750: }
1751:
1752: if (@expr1073746544 !@expr1073746545 functionLike (@expr4472 ) ) {
1753: for (@expr1073746547 Token *@expr4468 tok@var658 =@expr1073746549 output_end_1@var636 ?@expr1073746550 output_end_1@var636 .@expr1073746551 next@var659 :@expr1073746552 output@var608 .@expr1073746553 front (@expr1073746554 ) ; tok@var658 ; tok@var658 =@expr1073746555 tok@var658 .@expr1073746556 next@var660 ) {
1754: tok@var658 .@expr1073746557 macro@var661 =@expr1073746558 nameTokInst@var610 .@expr4419 str (@expr4420 ) ;
1755: }
1756: }
1757:
1758: if (@expr4513 !@expr4514 parametertokens1@var621 .@expr4515 empty (@expr4516 ) ) {
1759: parametertokens1@var621 .@expr1073746565 swap (@expr1073746566 parametertokens2@var624 ) ; }
1760:
1761: return functionLike (@expr4472 ) ?@expr1073746568 parametertokens2@var624 .@expr1073746569 back (@expr1073746570 ) .@expr1073746571 next :@expr1073746572 nameTokInst@var610 .@expr4434 next@var614 ;
1762: }
1763:
1764: const Token * recursiveExpandToken ( TokenList * output@var662 , TokenList & temp@var663 , const Location & loc@var664 , const Token * tok@var665 , const std :: unordered_map < std :: string , Macro > & macros@var666 , const std :: set < std :: string > & expandedmacros@var667 , const std :: vector < const Token * > & parametertokens@var668 ) const {
1765: if (@expr1073746574 !@expr1073746575 (@expr1073746576 temp@var663 .@expr4753 cback (@expr4754 ) &&@expr1073746579 temp@var663 .@expr4753 cback (@expr4754 ) .@expr1073746582 name@var1122 &&@expr1073746583 tok@var665 .@expr4760 next@var669 &&@expr1073746585 tok@var665 .@expr4760 next@var669 .@expr1073746587 op@var670 ==@expr1073746588 '(' ) ) {
1766: output@var662 .@expr4765 takeTokens (@expr4766 temp@var663 ) ;
1767: return tok@var665 .@expr4760 next@var669 ;
1768: }
1769:
1770: if (@expr1073746592 !@expr1073746593 sameline (@expr1073746594 tok@var665 , tok@var665 .@expr4760 next@var669 ) ) {
1771: output@var662 .@expr4765 takeTokens (@expr4766 temp@var663 ) ;
1772: return tok@var665 .@expr4760 next@var669 ;
1773: }
1774:
1775: const MacroMap ::@expr1073746599 const_iterator it@var671 =@expr1073746600 macros@var666 .@expr1073746601 find (@expr1073746602 temp@var663 .@expr4753 cback (@expr4754 ) .@expr4781 str (@expr4782 ) ) ;
1776: if (@expr1073746607 it@var671 ==@expr1073746608 macros@var666 .@expr1073746609 end (@expr1073746610 ) ||@expr1073746611 expandedmacros@var667 .@expr1073746612 find (@expr1073746613 temp@var663 .@expr4753 cback (@expr4754 ) .@expr4781 str (@expr4782 ) ) !=@expr1073746618 expandedmacros@var667 .@expr1073746619 end (@expr1073746620 ) ) {
1777: output@var662 .@expr4765 takeTokens (@expr4766 temp@var663 ) ;
1778: return tok@var665 .@expr4760 next@var669 ;
1779: }
1780:
1781: const Macro &@expr1073746624 calledMacro@var672 =@expr1073746625 it@var671 .@expr1073746626 second@var673 ;
1782: if (@expr1073746627 !@expr1073746628 calledMacro@var672 .@expr1073746629 functionLike (@expr1073746630 ) ) {
1783: output@var662 .@expr4765 takeTokens (@expr4766 temp@var663 ) ;
1784: return tok@var665 .@expr4760 next@var669 ;
1785: }
1786:
1787: TokenList temp2@var674 (@expr1073746634 files@var799 ) ;
1788: temp2@var674 .@expr1073746635 push_back (@expr1073746636 new Token (@expr1073746637 temp@var663 .@expr4753 cback (@expr4754 ) .@expr4781 str (@expr4782 ) , tok@var665 .@expr1073746642 location@var675 ) ) ;
1789:
1790: const Token * tok2@var676 ; tok2@var676 =@expr1073746643 appendTokens (@expr1073746644 &@expr1073746645 temp2@var674 , loc@var664 , tok@var665 .@expr4760 next@var669 , macros@var666 , expandedmacros@var667 , parametertokens@var668 ) ;
1791: if (@expr1073746647 !@expr1073746648 tok2@var676 ) {
1792: return tok@var665 .@expr4760 next@var669 ; }
1793: output@var662 .@expr4765 takeTokens (@expr4766 temp@var663 ) ;
1794: output@var662 .@expr1073746652 deleteToken (@expr1073746653 output@var662 .@expr1073746654 back (@expr1073746655 ) ) ;
1795: calledMacro@var672 .@expr1073746656 expand (@expr1073746657 output@var662 , loc@var664 , temp2@var674 .@expr1073746658 cfront (@expr1073746659 ) , macros@var666 , expandedmacros@var667 ) ;
1796: return tok2@var676 .@expr1073746660 next@var677 ;
1797: }
1798:
1799: const Token * expandToken ( TokenList * output@var678 , const Location & loc@var679 , const Token * tok@var680 , const std :: unordered_map < std :: string , Macro > & macros@var681 , const std :: set < std :: string > & expandedmacros@var682 , const std :: vector < const Token * > & parametertokens@var683 ) const {
1800:
1801: if (@expr1073746661 !@expr1073746662 tok@var680 .@expr1073746663 name@var684 ) {
1802: output@var678 .@expr4840 push_back (@expr4841 newMacroToken (@expr4842 tok@var680 .@expr4843 str (@expr4844 ) , loc@var679 , true , tok@var680 ) ) ;
1803: return tok@var680 .@expr4845 next@var685 ;
1804: }
1805:
1806:
1807: {
1808: TokenList temp@var686 (@expr1073746670 files@var799 ) ;
1809: if (@expr1073746671 expandArg (@expr1073746672 &@expr1073746673 temp@var686 , tok@var680 , loc@var679 , macros@var681 , expandedmacros@var682 , parametertokens@var683 ) ) {
1810: return recursiveExpandToken (@expr1073746674 output@var678 , temp@var686 , loc@var679 , tok@var680 , macros@var681 , expandedmacros@var682 , parametertokens@var683 ) ; }
1811: }
1812:
1813:
1814: const MacroMap ::@expr4851 const_iterator it@var687 =@expr1073746676 macros@var681 .@expr4853 find (@expr1073746678 tok@var680 .@expr4843 str (@expr4844 ) ) ;
1815: if (@expr1073746681 it@var687 !=@expr1073746682 macros@var681 .@expr4859 end (@expr4860 ) &&@expr1073746685 expandedmacros@var682 .@expr1073746686 find (@expr1073746687 tok@var680 .@expr4843 str (@expr4844 ) ) ==@expr1073746690 expandedmacros@var682 .@expr1073746691 end (@expr1073746692 ) ) {
1816: std ::@expr1073746693 set < std ::@expr4851 string > expandedmacros2@var688 (@expr1073746695 expandedmacros@var682 ) ;
1817: expandedmacros2@var688 .@expr1073746696 insert (@expr1073746697 tok@var680 .@expr4843 str (@expr4844 ) ) ;
1818:
1819: const Macro &@expr1073746700 calledMacro@var689 =@expr1073746701 it@var687 .@expr1073746702 second@var690 ;
1820: if (@expr1073746703 !@expr1073746704 calledMacro@var689 .@expr1073746705 functionLike (@expr1073746706 ) ) {
1821: TokenList temp@var691 (@expr1073746707 files@var799 ) ;
1822: calledMacro@var689 .@expr4884 expand (@expr1073746709 &@expr1073746710 temp@var691 , loc@var679 , tok@var680 , macros@var681 , expandedmacros@var682 ) ;
1823: return recursiveExpandToken (@expr1073746711 output@var678 , temp@var691 , loc@var679 , tok@var680 , macros@var681 , expandedmacros2@var688 , parametertokens@var683 ) ;
1824: }
1825: if (@expr1073746712 !@expr1073746713 sameline (@expr1073746714 tok@var680 , tok@var680 .@expr4845 next@var685 ) ||@expr1073746716 tok@var680 .@expr4845 next@var685 .@expr1073746718 op@var692 !=@expr1073746719 '(' ) {
1826: output@var678 .@expr4840 push_back (@expr4841 newMacroToken (@expr4842 tok@var680 .@expr4843 str (@expr4844 ) , loc@var679 , true , tok@var680 ) ) ;
1827: return tok@var680 .@expr4845 next@var685 ;
1828: }
1829: TokenList tokens@var693 (@expr1073746726 files@var799 ) ;
1830: tokens@var693 .@expr1073746727 push_back (@expr1073746728 new Token (@expr1073746729 *@expr1073746730 tok@var680 ) ) ;
1831: const Token * tok2@var694 ; tok2@var694 =@expr1073746731 appendTokens (@expr1073746732 &@expr1073746733 tokens@var693 , loc@var679 , tok@var680 .@expr4845 next@var685 , macros@var681 , expandedmacros@var682 , parametertokens@var683 ) ;
1832: if (@expr1073746735 !@expr1073746736 tok2@var694 ) {
1833: output@var678 .@expr4840 push_back (@expr4841 newMacroToken (@expr4842 tok@var680 .@expr4843 str (@expr4844 ) , loc@var679 , true , tok@var680 ) ) ;
1834: return tok@var680 .@expr4845 next@var685 ;
1835: }
1836: TokenList temp@var695 (@expr1073746743 files@var799 ) ;
1837: calledMacro@var689 .@expr4884 expand (@expr1073746745 &@expr1073746746 temp@var695 , loc@var679 , tokens@var693 .@expr1073746747 cfront (@expr1073746748 ) , macros@var681 , expandedmacros@var682 ) ;
1838: return recursiveExpandToken (@expr1073746749 output@var678 , temp@var695 , loc@var679 , tok2@var694 , macros@var681 , expandedmacros2@var688 , parametertokens@var683 ) ;
1839: }
1840:
1841: else { if (@expr1073746750 tok@var680 .@expr4843 str (@expr4844 ) ==@expr1073746753 DEFINED@var160 ) {
1842: const Token * tok2@var696 ; tok2@var696 =@expr1073746754 tok@var680 .@expr4845 next@var685 ;
1843: const Token * tok3@var697 ; tok3@var697 =@expr1073746756 tok2@var696 ?@expr1073746757 tok2@var696 .@expr1073746758 next@var698 :@expr1073746759 nullptr ;
1844: const Token * tok4@var699 ; tok4@var699 =@expr1073746760 tok3@var697 ?@expr1073746761 tok3@var697 .@expr1073746762 next@var700 :@expr1073746763 nullptr ;
1845: const Token * defToken@var701 ; defToken@var701 =@expr1073746764 nullptr ;
1846: const Token * lastToken@var702 ; lastToken@var702 =@expr1073746765 nullptr ;
1847: if (@expr1073746766 sameline (@expr1073746767 tok@var680 , tok4@var699 ) &&@expr1073746768 tok2@var696 .@expr1073746769 op@var703 ==@expr1073746770 '(' &&@expr1073746771 tok3@var697 .@expr1073746772 name@var704 &&@expr1073746773 tok4@var699 .@expr1073746774 op@var705 ==@expr1073746775 ')' ) {
1848: defToken@var701 =@expr1073746776 tok3@var697 ;
1849: lastToken@var702 =@expr1073746777 tok4@var699 ;
1850: } else { if (@expr1073746778 sameline (@expr1073746779 tok@var680 , tok2@var696 ) &&@expr1073746780 tok2@var696 .@expr1073746781 name@var706 ) {
1851: defToken@var701 =@expr1073746782 lastToken@var702 =@expr1073746783 tok2@var696 ;
1852: } }
1853: if (@expr1073746784 defToken@var701 ) {
1854: std ::@expr1073746785 string macroName@var707 ; macroName@var707 =@expr1073746786 defToken@var701 .@expr1073746787 str (@expr1073746788 ) ;
1855: if (@expr1073746789 defToken@var701 .@expr4966 next@var708 &&@expr1073746791 defToken@var701 .@expr4966 next@var708 .@expr1073746793 op@var709 ==@expr1073746794 '#' &&@expr1073746795 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 &&@expr1073746798 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr1073746801 op@var711 ==@expr1073746802 '#' &&@expr1073746803 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 &&@expr1073746807 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 .@expr1073746811 name@var713 &&@expr1073746812 sameline (@expr1073746813 defToken@var701 , defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 ) ) {
1856: TokenList temp@var714 (@expr1073746817 files@var799 ) ;
1857: if (@expr1073746818 expandArg (@expr1073746819 &@expr4996 temp@var714 , defToken@var701 , parametertokens@var683 ) ) {
1858: macroName@var707 =@expr1073746821 temp@var714 .@expr4998 cback (@expr4999 ) .@expr5000 str (@expr5001 ) ; }
1859: if (@expr1073746826 expandArg (@expr1073746827 &@expr4996 temp@var714 , defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 , parametertokens@var683 ) ) {
1860: macroName@var707 +=@expr1073746832 temp@var714 .@expr4998 cback (@expr4999 ) .@expr5000 str (@expr5001 ) ; }
1861: else {
1862: macroName@var707 +=@expr1073746837 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 .@expr1073746841 str (@expr1073746842 ) ; }
1863: lastToken@var702 =@expr1073746843 defToken@var701 .@expr4966 next@var708 .@expr4973 next@var710 .@expr4982 next@var712 ;
1864: }
1865: const bool def@var715 =@expr1073746847 macros@var681 .@expr4853 find (@expr1073746849 macroName@var707 ) !=@expr1073746850 macros@var681 .@expr4859 end (@expr4860 ) ;
1866: output@var678 .@expr4840 push_back (@expr1073746854 newMacroToken (@expr1073746855 def@var715 ?@expr1073746856 "1" :@expr1073746857 "0" , loc@var679 , true ) ) ;
1867: return lastToken@var702 .@expr1073746858 next@var716 ;
1868: }
1869: } }
1870:
1871: output@var678 .@expr4840 push_back (@expr4841 newMacroToken (@expr4842 tok@var680 .@expr4843 str (@expr4844 ) , loc@var679 , true , tok@var680 ) ) ;
1872: return tok@var680 .@expr4845 next@var685 ;
1873: }
1874:
1875: bool expandArg ( TokenList * output@var717 , const Token * tok@var718 , const std :: vector < const Token * > & parametertokens@var719 ) const {
1876: if (@expr1073746865 !@expr1073746866 tok@var718 .@expr1073746867 name@var720 ) {
1877: return false ; }
1878:
1879: const unsigned int argnr@var721 =@expr1073746868 getArgNum (@expr1073746869 tok@var718 .@expr1073746870 str (@expr1073746871 ) ) ;
1880: if (@expr1073746872 argnr@var721 >=@expr1073746873 args@var795 .@expr1073746874 size (@expr1073746875 ) ) {
1881: return false ; }
1882:
1883:
1884: if (@expr1073746876 variadic@var796 &&@expr1073746877 argnr@var721 +@expr5054 1U >=@expr1073746879 parametertokens@var719 .@expr1073746880 size (@expr1073746881 ) ) {
1885: return true ; }
1886:
1887: for (@expr1073746882 const Token *@expr1073746883 partok@var722 =@expr1073746884 parametertokens@var719 [@expr1073746885 argnr@var721 ] .@expr1073746886 next@var1123 ; partok@var722 !=@expr1073746887 parametertokens@var719 [@expr1073746888 argnr@var721 +@expr5054 1U ] ; partok@var722 =@expr1073746890 partok@var722 .@expr1073746891 next@var723 ) {
1888: output@var717 .@expr1073746892 push_back (@expr1073746893 new Token (@expr1073746894 *@expr1073746895 partok@var722 ) ) ; }
1889:
1890: return true ;
1891: }
1892:
1893: bool expandArg ( TokenList * output@var724 , const Token * tok@var725 , const Location & loc@var726 , const std :: unordered_map < std :: string , Macro > & macros@var727 , const std :: set < std :: string > & expandedmacros@var728 , const std :: vector < const Token * > & parametertokens@var729 ) const {
1894: if (@expr1073746896 !@expr1073746897 tok@var725 .@expr1073746898 name@var730 ) {
1895: return false ; }
1896: const unsigned int argnr@var731 =@expr1073746899 getArgNum (@expr1073746900 tok@var725 .@expr1073746901 str (@expr1073746902 ) ) ;
1897: if (@expr1073746903 argnr@var731 >=@expr1073746904 args@var795 .@expr1073746905 size (@expr1073746906 ) ) {
1898: return false ; }
1899: if (@expr1073746907 variadic@var796 &&@expr1073746908 argnr@var731 +@expr5085 1U >=@expr1073746910 parametertokens@var729 .@expr1073746911 size (@expr1073746912 ) ) {
1900: return true ; }
1901: for (@expr1073746913 const Token *@expr1073746914 partok@var732 =@expr1073746915 parametertokens@var729 [@expr1073746916 argnr@var731 ] .@expr1073746917 next@var1124 ; partok@var732 !=@expr1073746918 parametertokens@var729 [@expr1073746919 argnr@var731 +@expr5085 1U ] ; ) {
1902: const MacroMap ::@expr1073746921 const_iterator it@var733 =@expr1073746922 macros@var727 .@expr1073746923 find (@expr1073746924 partok@var732 .@expr5101 str (@expr5102 ) ) ;
1903: if (@expr1073746927 it@var733 !=@expr1073746928 macros@var727 .@expr1073746929 end (@expr1073746930 ) &&@expr1073746931 !@expr1073746932 partok@var732 .@expr1073746933 isExpandedFrom (@expr1073746934 &@expr1073746935 it@var733 .@expr5112 second@var734 ) &&@expr1073746937 (@expr1073746938 partok@var732 .@expr5101 str (@expr5102 ) ==@expr1073746941 name (@expr1073746942 ) ||@expr1073746943 expandedmacros@var728 .@expr1073746944 find (@expr1073746945 partok@var732 .@expr5101 str (@expr5102 ) ) ==@expr1073746948 expandedmacros@var728 .@expr1073746949 end (@expr1073746950 ) ) ) {
1904: partok@var732 =@expr1073746951 it@var733 .@expr5112 second@var734 .@expr1073746953 expand (@expr1073746954 output@var724 , loc@var726 , partok@var732 , macros@var727 , expandedmacros@var728 ) ; }
1905: else {
1906: output@var724 .@expr1073746955 push_back (@expr1073746956 newMacroToken (@expr1073746957 partok@var732 .@expr5101 str (@expr5102 ) , loc@var726 , isReplaced (@expr1073746960 expandedmacros@var728 ) , partok@var732 ) ) ;
1907: output@var724 .@expr1073746961 back (@expr1073746962 ) .@expr1073746963 macro@var1121 =@expr1073746964 partok@var732 .@expr1073746965 macro@var735 ;
1908: partok@var732 =@expr1073746966 partok@var732 .@expr1073746967 next@var736 ;
1909: }
1910: }
1911: return true ;
1912: }
1913:
|
1923:
1924: const Token * expandHash ( TokenList * output@var737 , const Location & loc@var738 , const Token * tok@var739 , const std :: unordered_map < std :: string , Macro > & macros@var740 , const std :: set < std :: string > & expandedmacros@var741 , const std :: vector < const Token * > & parametertokens@var742 ) const {
1925: TokenList tokenListHash@var743 (@expr1073746968 files@var799 ) ;
1926: tok@var739 =@expr1073746969 expandToken (@expr1073746970 &@expr1073746971 tokenListHash@var743 , loc@var738 , tok@var739 .@expr1073746972 next@var744 , macros@var740 , expandedmacros@var741 , parametertokens@var742 ) ;
1927: std ::@expr1073746973 ostringstream ostr@var745 ;
1928: ostr@var745 <<@expr5150 '\"' ;
1929: for (@expr1073746975 const Token *@expr1073746976 hashtok@var746 =@expr1073746977 tokenListHash@var743 .@expr1073746978 cfront (@expr1073746979 ) ; hashtok@var746 ; hashtok@var746 =@expr1073746980 hashtok@var746 .@expr1073746981 next@var747 ) {
1930: ostr@var745 <<@expr1073746982 hashtok@var746 .@expr1073746983 str (@expr1073746984 ) ; }
1931: ostr@var745 <<@expr5150 '\"' ;
1932: output@var737 .@expr1073746986 push_back (@expr1073746987 newMacroToken (@expr1073746988 escapeString (@expr1073746989 ostr@var745 .@expr1073746990 str (@expr1073746991 ) ) , loc@var738 , isReplaced (@expr1073746992 expandedmacros@var741 ) ) ) ;
1933: return tok@var739 ;
1934: }
1935:
|
1946:
1947: const Token * expandHashHash ( TokenList * output@var748 , const Location & loc@var749 , const Token * tok@var750 , const std :: unordered_map < std :: string , Macro > & macros@var751 , const std :: set < std :: string > & expandedmacros@var752 , const std :: vector < const Token * > & parametertokens@var753 ) const {
1948: Token * A@var754 ; A@var754 =@expr1073746993 output@var748 .@expr1073746994 back (@expr1073746995 ) ;
1949: if (@expr1073746996 !@expr1073746997 A@var754 ) {
1950: throw invalidHashHash (@expr1073746998 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) , "Missing first argument" ) ; }
1951: if (@expr1073747001 !@expr1073747002 sameline (@expr1073747003 tok@var750 , tok@var750 .@expr5180 next@var756 ) ||@expr1073747005 !@expr1073747006 sameline (@expr1073747007 tok@var750 , tok@var750 .@expr5180 next@var756 .@expr5185 next@var757 ) ) {
1952: throw invalidHashHash ::@expr1073747010 unexpectedNewline (@expr1073747011 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) ) ; }
1953:
1954: bool canBeConcatenatedWithEqual@var758 ; canBeConcatenatedWithEqual@var758 =@expr1073747014 A@var754 .@expr1073747015 isOneOf (@expr1073747016 "+-*/%&|^" ) ||@expr1073747017 A@var754 .@expr5194 str (@expr5195 ) ==@expr1073747020 "<<" ||@expr1073747021 A@var754 .@expr5194 str (@expr5195 ) ==@expr1073747024 ">>" ;
1955: bool canBeConcatenatedStringOrChar@var759 ; canBeConcatenatedStringOrChar@var759 =@expr1073747025 isStringLiteral_ (@expr1073747026 A@var754 .@expr5194 str (@expr5195 ) ) ||@expr1073747029 isCharLiteral_ (@expr1073747030 A@var754 .@expr5194 str (@expr5195 ) ) ;
1956: if (@expr1073747033 !@expr1073747034 A@var754 .@expr1073747035 name@var760 &&@expr1073747036 !@expr1073747037 A@var754 .@expr1073747038 number@var761 &&@expr1073747039 A@var754 .@expr5216 op@var762 !=@expr1073747041 ',' &&@expr1073747042 !@expr1073747043 A@var754 .@expr5194 str (@expr5195 ) .@expr1073747046 empty (@expr1073747047 ) &&@expr1073747048 !@expr5225 canBeConcatenatedWithEqual@var758 &&@expr1073747050 !@expr1073747051 canBeConcatenatedStringOrChar@var759 ) {
1957: throw invalidHashHash ::@expr5228 unexpectedToken (@expr1073747053 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) , A@var754 ) ; }
1958:
1959: Token * B@var763 ; B@var763 =@expr1073747056 tok@var750 .@expr5180 next@var756 .@expr5185 next@var757 ;
1960: if (@expr1073747059 !@expr5236 B@var763 .@expr5237 name@var764 &&@expr1073747062 !@expr1073747063 B@var763 .@expr5240 number@var765 &&@expr1073747065 B@var763 .@expr5242 op@var766 &&@expr1073747067 !@expr1073747068 B@var763 .@expr1073747069 isOneOf (@expr1073747070 "#=" ) ) {
1961: throw invalidHashHash ::@expr5228 unexpectedToken (@expr1073747072 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) , B@var763 ) ; }
1962:
1963: if (@expr1073747075 (@expr1073747076 canBeConcatenatedWithEqual@var758 &&@expr1073747077 B@var763 .@expr5242 op@var766 !=@expr1073747079 '=' ) ||@expr1073747080
1964: (@expr1073747081 !@expr5225 canBeConcatenatedWithEqual@var758 &&@expr1073747083 B@var763 .@expr5242 op@var766 ==@expr1073747085 '=' ) ) {
1965: throw invalidHashHash ::@expr5262 cannotCombine (@expr5263 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) , A@var754 , B@var763 ) ; }
1966:
1967:
1968: if (@expr1073747090 canBeConcatenatedStringOrChar@var759 &&@expr1073747091 (@expr1073747092 B@var763 .@expr5240 number@var765 ||@expr1073747094 !@expr5236 B@var763 .@expr5237 name@var764 ) ) {
1969: throw invalidHashHash ::@expr5262 cannotCombine (@expr5263 tok@var750 .@expr5175 location@var755 , name (@expr5176 ) , A@var754 , B@var763 ) ; }
1970:
1971: TokenList tokensB@var767 (@expr1073747101 files@var799 ) ;
1972: const Token * nextTok@var768 ; nextTok@var768 =@expr1073747102 B@var763 .@expr5279 next@var769 ;
1973:
1974: if (@expr1073747104 canBeConcatenatedStringOrChar@var759 ) {
1975:
1976:
1977: if (@expr5281 expandArg (@expr5282 &@expr5283 tokensB@var767 , B@var763 , parametertokens@var753 ) ) {
1978: for (@expr1073747108 Token *@expr5285 b@var770 =@expr1073747110 tokensB@var767 .@expr5287 front (@expr5288 ) ; b@var770 ; b@var770 =@expr1073747113 b@var770 .@expr1073747114 next@var771 ) {
1979: b@var770 .@expr1073747115 location@var772 =@expr1073747116 loc@var749 ; }
1980: } else {
1981: tokensB@var767 .@expr1073747117 push_back (@expr1073747118 new Token (@expr1073747119 *@expr1073747120 B@var763 ) ) ;
1982: tokensB@var767 .@expr1073747121 back (@expr1073747122 ) .@expr1073747123 location@var1125 =@expr1073747124 loc@var749 ;
1983: }
1984: output@var748 .@expr5301 takeTokens (@expr5302 tokensB@var767 ) ;
1985: } else {
1986: std ::@expr1073747127 string strAB@var773 ;
1987:
1988: const bool varargs@var774 =@expr1073747128 variadic@var796 &&@expr1073747129 args@var795 .@expr5306 size (@expr5307 ) >=@expr1073747132 1U &&@expr1073747133 B@var763 .@expr5310 str (@expr5311 ) ==@expr1073747136 args@var795 [@expr1073747137 args@var795 .@expr5306 size (@expr5307 ) -@expr1073747140 1U ] ;
1989:
1990: if (@expr5281 expandArg (@expr5282 &@expr5283 tokensB@var767 , B@var763 , parametertokens@var753 ) ) {
1991: if (@expr1073747144 tokensB@var767 .@expr5321 empty (@expr5322 ) ) {
1992: strAB@var773 =@expr1073747147 A@var754 .@expr5194 str (@expr5195 ) ; }
1993: else { if (@expr1073747150 varargs@var774 &&@expr1073747151 A@var754 .@expr5216 op@var762 ==@expr1073747153 ',' ) {
1994: strAB@var773 =@expr1073747154 "," ;
1995: } else {
1996: strAB@var773 =@expr1073747155 A@var754 .@expr5194 str (@expr5195 ) +@expr1073747158 tokensB@var767 .@expr1073747159 cfront (@expr1073747160 ) .@expr1073747161 str (@expr1073747162 ) ;
1997: tokensB@var767 .@expr1073747163 deleteToken (@expr1073747164 tokensB@var767 .@expr5287 front (@expr5288 ) ) ;
1998: } }
1999: } else {
2000: strAB@var773 =@expr1073747167 A@var754 .@expr5194 str (@expr5195 ) +@expr1073747170 B@var763 .@expr5310 str (@expr5311 ) ;
2001: }
2002:
2003: if (@expr1073747173 varargs@var774 &&@expr1073747174 tokensB@var767 .@expr5321 empty (@expr5322 ) &&@expr1073747177 tok@var750 .@expr1073747178 previous@var775 .@expr1073747179 str (@expr1073747180 ) ==@expr1073747181 "," ) {
2004: output@var748 .@expr5358 deleteToken (@expr5359 A@var754 ) ; }
2005: else { if (@expr1073747184 strAB@var773 !=@expr1073747185 "," &&@expr1073747186 macros@var751 .@expr5363 find (@expr5364 strAB@var773 ) ==@expr1073747189 macros@var751 .@expr5366 end (@expr5367 ) ) {
2006: A@var754 .@expr1073747192 setstr (@expr1073747193 strAB@var773 ) ;
2007: for (@expr1073747194 Token *@expr5285 b@var776 =@expr1073747196 tokensB@var767 .@expr5287 front (@expr5288 ) ; b@var776 ; b@var776 =@expr1073747199 b@var776 .@expr1073747200 next@var777 ) {
2008: b@var776 .@expr1073747201 location@var778 =@expr1073747202 loc@var749 ; }
2009: output@var748 .@expr5301 takeTokens (@expr5302 tokensB@var767 ) ;
2010: } else { if (@expr1073747205 nextTok@var768 .@expr1073747206 op@var779 ==@expr1073747207 '#' &&@expr1073747208 nextTok@var768 .@expr1073747209 next@var780 .@expr1073747210 op@var781 ==@expr1073747211 '#' ) {
2011: TokenList output2@var782 (@expr1073747212 files@var799 ) ;
2012: output2@var782 .@expr1073747213 push_back (@expr1073747214 new Token (@expr5391 strAB@var773 , tok@var750 .@expr5175 location@var755 ) ) ;
2013: nextTok@var768 =@expr1073747217 expandHashHash (@expr1073747218 &@expr1073747219 output2@var782 , loc@var749 , nextTok@var768 , macros@var751 , expandedmacros@var752 , parametertokens@var753 ) ;
2014: output@var748 .@expr5358 deleteToken (@expr5359 A@var754 ) ;
2015: output@var748 .@expr5301 takeTokens (@expr1073747223 output2@var782 ) ;
2016: } else {
2017: output@var748 .@expr5358 deleteToken (@expr5359 A@var754 ) ;
2018: TokenList tokens@var783 (@expr1073747226 files@var799 ) ;
2019: tokens@var783 .@expr1073747227 push_back (@expr1073747228 new Token (@expr5391 strAB@var773 , tok@var750 .@expr5175 location@var755 ) ) ;
2020:
2021: if (@expr1073747231 tokensB@var767 .@expr5321 empty (@expr5322 ) &&@expr1073747234 sameline (@expr1073747235 B@var763 , B@var763 .@expr5279 next@var769 ) &&@expr1073747237 B@var763 .@expr5279 next@var769 .@expr1073747239 op@var784 ==@expr1073747240 '(' ) {
2022: const MacroMap ::@expr1073747241 const_iterator it@var785 =@expr1073747242 macros@var751 .@expr5363 find (@expr5364 strAB@var773 ) ;
2023: if (@expr1073747245 it@var785 !=@expr1073747246 macros@var751 .@expr5366 end (@expr5367 ) &&@expr1073747249 expandedmacros@var752 .@expr1073747250 find (@expr1073747251 strAB@var773 ) ==@expr1073747252 expandedmacros@var752 .@expr1073747253 end (@expr1073747254 ) &&@expr1073747255 it@var785 .@expr1073747256 second@var786 .@expr1073747257 functionLike (@expr1073747258 ) ) {
2024: const Token * tok2@var787 ; tok2@var787 =@expr1073747259 appendTokens (@expr1073747260 &@expr1073747261 tokens@var783 , loc@var749 , B@var763 .@expr5279 next@var769 , macros@var751 , expandedmacros@var752 , parametertokens@var753 ) ;
2025: if (@expr1073747263 tok2@var787 ) {
2026: nextTok@var768 =@expr1073747264 tok2@var787 .@expr1073747265 next@var788 ; }
2027: }
2028: }
2029: expandToken (@expr1073747266 output@var748 , loc@var749 , tokens@var783 .@expr1073747267 cfront (@expr1073747268 ) , macros@var751 , expandedmacros@var752 , parametertokens@var753 ) ;
2030: for (@expr1073747269 Token *@expr5285 b@var789 =@expr1073747271 tokensB@var767 .@expr5287 front (@expr5288 ) ; b@var789 ; b@var789 =@expr1073747274 b@var789 .@expr1073747275 next@var790 ) {
2031: b@var789 .@expr1073747276 location@var791 =@expr1073747277 loc@var749 ; }
2032: output@var748 .@expr5301 takeTokens (@expr5302 tokensB@var767 ) ;
2033: } } }
2034: }
2035:
2036: return nextTok@var768 ;
2037: }
2038:
2039: static bool isReplaced ( const std :: set < std :: string > & expandedmacros@var792 ) {
2040:
2041: std ::@expr1073747280 set < std ::@expr1073747281 string > ::@expr1073747282 const_iterator it@var793 ; it@var793 =@expr1073747283 expandedmacros@var792 .@expr1073747284 begin (@expr1073747285 ) ;
2042: if (@expr1073747286 it@var793 ==@expr1073747287 expandedmacros@var792 .@expr5464 end (@expr5465 ) ) {
2043: return false ; }
2044: ++@expr1073747290 it@var793 ;
2045: return (@expr1073747291 it@var793 !=@expr1073747292 expandedmacros@var792 .@expr5464 end (@expr5465 ) ) ;
2046: }
2047:
2048:
2049: const Token * nameTokDef@var794 ;
2050:
2051:
2052: std :: vector < std :: string > args@var795 ;
2053:
2054:
2055: bool variadic@var796 ;
2056:
2057:
2058: const Token * valueToken@var797 ;
2059:
2060:
2061: const Token * endToken@var798 ;
2062:
2063:
2064: std :: vector < std :: string > & files@var799 ;
2065:
2066:
2067: TokenList tokenListDefine@var800 ;
2068:
2069:
2070: mutable std :: list < Location > usageList@var801 ;
2071:
2072:
2073: bool valueDefinedInCode_@var802 ;
2074: } ;
2075: }
2076:
2077: namespace simplecpp {
2078:
2079: std :: string convertCygwinToWindowsPath ( const std :: string & cygwinPath@var811 )
2080: {
2081: std ::@expr1073747295 string windowsPath@var812 ;
2082:
2083: std ::@expr1073747296 string ::@expr1073747297 size_type pos@var813 ; pos@var813 =@expr1073747298 0 ;
2084: if (@expr1073747299 cygwinPath@var811 .@expr5476 size (@expr5477 ) >=@expr1073747302 11 &&@expr1073747303 startsWith (@expr1073747304 cygwinPath@var811 , "/cygdrive/" ) ) {
2085: unsigned char driveLetter@var814 ; driveLetter@var814 =@expr1073747305 cygwinPath@var811 [@expr1073747306 10 ] ;
2086: if (@expr1073747307 std ::@expr1073747308 isalpha (@expr1073747309 driveLetter@var814 ) ) {
2087: if (@expr1073747310 cygwinPath@var811 .@expr5476 size (@expr5477 ) ==@expr1073747313 11 ) {
2088: windowsPath@var812 =@expr1073747314 toupper (@expr5491 driveLetter@var814 ) ;
2089: windowsPath@var812 +=@expr1073747316 ":\\" ;
2090: pos@var813 =@expr1073747317 11 ;
2091: } else { if (@expr1073747318 cygwinPath@var811 [@expr1073747319 11 ] ==@expr1073747320 '/' ) {
2092: windowsPath@var812 =@expr1073747321 toupper (@expr5491 driveLetter@var814 ) ;
2093: windowsPath@var812 +=@expr1073747323 ":" ;
2094: pos@var813 =@expr1073747324 11 ;
2095: } }
2096: }
2097: }
2098:
2099: for (@expr1073747325 ; pos@var813 <@expr1073747326 cygwinPath@var811 .@expr5476 size (@expr5477 ) ; ++@expr1073747329 pos@var813 ) {
2100: unsigned char c@var815 ; c@var815 =@expr1073747330 cygwinPath@var811 [@expr1073747331 pos@var813 ] ;
2101: if (@expr1073747332 c@var815 ==@expr1073747333 '/' ) {
2102: c@var815 =@expr1073747334 '\\' ; }
2103: windowsPath@var812 +=@expr1073747335 c@var815 ;
2104: }
2105:
2106: return windowsPath@var812 ;
2107: }
2108: }
2109:
|
2265:
2266: static bool isAbsolutePath ( const std :: string & path@var816 )
2267: {
2268: return path@var816 .@expr1073747336 length (@expr1073747337 ) >@expr1073747338 1U &&@expr1073747339 path@var816 [@expr1073747340 0 ] ==@expr1073747341 '/' ;
2269: }
2270:
2271:
2272: namespace simplecpp {
2273:
2274:
2275:
2276: std :: string simplifyPath ( std :: string path@var817 )
2277: {
2278: if (@expr5519 path@var817 .@expr5520 empty (@expr5521 ) ) {
2279: return path@var817 ; }
2280:
2281: std ::@expr5522 string ::@expr1073747347 size_type pos@var818 ;
2282:
2283:
2284: std ::@expr1073747348 replace (@expr1073747349 path@var817 .@expr1073747350 begin (@expr1073747351 ) , path@var817 .@expr1073747352 end (@expr1073747353 ) , '\\' , '/' ) ;
2285:
2286: const bool unc@var819 (@expr1073747354 path@var817 .@expr1073747355 compare (@expr1073747356 0 , 2 , "//" ) ==@expr1073747357 0 ) ;
2287:
2288:
2289: pos@var818 =@expr1073747358 0 ;
2290: while (@expr1073747359 (@expr1073747360 pos@var818 =@expr1073747361 path@var817 .@expr5538 find (@expr1073747363 "//" , pos@var818 ) ) !=@expr1073747364 std ::@expr5522 string ::@expr5542 npos@expr5518 ) {
2291: path@var817 .@expr5543 erase (@expr1073747368 pos@var818 , 1 ) ;
2292: }
2293:
2294:
2295: pos@var818 =@expr1073747369 0 ;
2296: while (@expr1073747370 (@expr1073747371 pos@var818 =@expr1073747372 path@var817 .@expr5538 find (@expr1073747374 "./" , pos@var818 ) ) !=@expr1073747375 std ::@expr5522 string ::@expr5542 npos@expr5518 ) {
2297: if (@expr1073747378 pos@var818 ==@expr1073747379 0 ||@expr1073747380 path@var817 [@expr1073747381 pos@var818 -@expr5558 1U ] ==@expr1073747383 '/' ) {
2298: path@var817 .@expr5543 erase (@expr1073747385 pos@var818 , 2 ) ; }
2299: else {
2300: pos@var818 +=@expr1073747386 2 ; }
2301: }
2302:
2303:
2304: if (@expr1073747387 endsWith (@expr1073747388 path@var817 , "/." ) ) {
2305: path@var817 .@expr5543 erase (@expr1073747390 path@var817 .@expr5567 size (@expr5568 ) -@expr1073747393 1 ) ; }
2306:
2307:
2308: pos@var818 =@expr1073747394 1 ;
2309: while (@expr1073747395 (@expr1073747396 pos@var818 =@expr1073747397 path@var817 .@expr5538 find (@expr1073747399 "/.." , pos@var818 ) ) !=@expr1073747400 std ::@expr5522 string ::@expr5542 npos@expr5518 ) {
2310:
2311: if (@expr1073747403 pos@var818 +@expr5580 3 <@expr1073747405 path@var817 .@expr5567 size (@expr5568 ) &&@expr1073747408 path@var817 [@expr1073747409 pos@var818 +@expr5580 3 ] !=@expr1073747411 '/' ) {
2312: ++@expr1073747412 pos@var818 ;
2313: continue ;
2314: }
2315:
2316: std ::@expr5522 string ::@expr1073747414 size_type pos1@var820 ; pos1@var820 =@expr1073747415 path@var817 .@expr1073747416 rfind (@expr1073747417 '/' , pos@var818 -@expr5558 1U ) ;
2317: if (@expr1073747419 pos1@var820 ==@expr1073747420 std ::@expr5522 string ::@expr5542 npos@expr5518 ) {
2318: pos1@var820 =@expr1073747423 0 ;
2319: } else {
2320: pos1@var820 +=@expr1073747424 1U ;
2321: }
2322: const std ::@expr1073747425 string previousSubPath@var821 =@expr1073747426 path@var817 .@expr1073747427 substr (@expr1073747428 pos1@var820 , pos@var818 -@expr5605 pos1@var820 ) ;
2323: if (@expr1073747430 previousSubPath@var821 ==@expr1073747431 ".." ) {
2324:
2325: ++@expr1073747432 pos@var818 ;
2326: } else {
2327:
2328: path@var817 .@expr5543 erase (@expr1073747434 pos1@var820 , pos@var818 -@expr5605 pos1@var820 +@expr1073747436 4 ) ;
2329: if (@expr5519 path@var817 .@expr5520 empty (@expr5521 ) ) {
2330: path@var817 =@expr1073747440 "." ; }
2331:
2332: pos@var818 =@expr1073747441 (@expr1073747442 pos1@var820 ==@expr1073747443 0 ) ?@expr1073747444 1 :@expr1073747445 (@expr1073747446 pos1@var820 -@expr1073747447 1 ) ;
2333: }
2334: }
2335:
|
2339:
2340: if (@expr1073747448 unc@var819 ) {
2341: path@var817 =@expr1073747449 '/' +@expr1073747450 path@var817 ; }
2342:
2343: return path@var817 .@expr1073747451 find_first_of (@expr1073747452 "*?" ) ==@expr1073747453 std ::@expr5522 string ::@expr5542 npos@expr5518 ?@expr1073747456 path@var817 :@expr1073747457 path@var817 ;
2344: }
2345: }
2346:
2347:
2348: static void simplifySizeof ( simplecpp :: TokenList & expr@var822 , const std :: map < std :: string , unsigned long > & sizeOfType@var823 )
2349: {
2350: for (@expr1073747459 simplecpp ::@expr5636 Token *@expr5637 tok@var824 =@expr1073747462 expr@var822 .@expr1073747463 front (@expr1073747464 ) ; tok@var824 ; tok@var824 =@expr1073747465 tok@var824 .@expr5642 next@var825 ) {
2351: if (@expr1073747467 tok@var824 .@expr1073747468 str (@expr1073747469 ) !=@expr1073747470 "sizeof" ) {
2352: continue ; }
2353: simplecpp ::@expr5647 Token * tok1@var826 ; tok1@var826 =@expr1073747472 tok@var824 .@expr5642 next@var825 ;
2354: if (@expr1073747474 !@expr1073747475 tok1@var826 ) {
2355: throw std ::@expr5652 runtime_error (@expr5653 "missing sizeof argument" ) ;
2356: }
2357: simplecpp ::@expr5647 Token * tok2@var827 ; tok2@var827 =@expr1073747479 tok1@var826 .@expr5656 next@var828 ;
2358: if (@expr5657 !@expr5658 tok2@var827 ) {
2359: throw std ::@expr5652 runtime_error (@expr5653 "missing sizeof argument" ) ;
2360: }
2361: if (@expr1073747485 tok1@var826 .@expr1073747486 op@var829 ==@expr1073747487 '(' ) {
2362: tok1@var826 =@expr1073747488 tok1@var826 .@expr5656 next@var828 ;
2363: while (@expr1073747490 tok2@var827 .@expr1073747491 op@var830 !=@expr1073747492 ')' ) {
2364: tok2@var827 =@expr1073747493 tok2@var827 .@expr5670 next@var831 ;
2365: if (@expr5657 !@expr5658 tok2@var827 ) {
2366: throw std ::@expr5652 runtime_error (@expr1073747498 "invalid sizeof expression" ) ;
2367: }
2368: }
2369: }
2370:
2371: std ::@expr1073747499 string type@var832 ;
2372: for (@expr1073747500 simplecpp ::@expr5636 Token *@expr5637 typeToken@var833 =@expr1073747503 tok1@var826 ; typeToken@var833 !=@expr1073747504 tok2@var827 ; typeToken@var833 =@expr1073747505 typeToken@var833 .@expr5682 next@var834 ) {
2373: if (@expr1073747507 (@expr1073747508 typeToken@var833 .@expr5685 str (@expr5686 ) ==@expr1073747511 "unsigned" ||@expr1073747512 typeToken@var833 .@expr5685 str (@expr5686 ) ==@expr1073747515 "signed" ) &&@expr1073747516 typeToken@var833 .@expr5682 next@var834 .@expr1073747518 name@var835 ) {
2374: continue ; }
2375: if (@expr1073747519 typeToken@var833 .@expr5685 str (@expr5686 ) ==@expr1073747522 "*" &&@expr1073747523 type@var832 .@expr1073747524 find (@expr1073747525 '*' ) !=@expr1073747526 std ::@expr1073747527 string ::@expr1073747528 npos@expr1073747458 ) {
2376: continue ; }
2377: if (@expr1073747529 !@expr1073747530 type@var832 .@expr1073747531 empty (@expr1073747532 ) ) {
2378: type@var832 +=@expr1073747533 ' ' ; }
2379: type@var832 +=@expr1073747534 typeToken@var833 .@expr5685 str (@expr5686 ) ;
2380: }
2381:
2382: const std ::@expr1073747537 map < std ::@expr5636 string , unsigned long > ::@expr1073747539 const_iterator it@var836 =@expr1073747540 sizeOfType@var823 .@expr1073747541 find (@expr1073747542 type@var832 ) ;
2383: if (@expr1073747543 it@var836 !=@expr1073747544 sizeOfType@var823 .@expr1073747545 end (@expr1073747546 ) ) {
2384: tok@var824 .@expr1073747547 setstr (@expr1073747548 toString (@expr1073747549 it@var836 .@expr1073747550 second@var837 ) ) ; }
2385: else {
2386: continue ; }
2387:
2388: tok2@var827 =@expr1073747551 tok2@var827 .@expr5670 next@var831 ;
2389: while (@expr1073747553 tok@var824 .@expr5642 next@var825 !=@expr1073747555 tok2@var827 ) {
2390: expr@var822 .@expr1073747556 deleteToken (@expr1073747557 tok@var824 .@expr5642 next@var825 ) ; }
2391: }
2392: }
2393:
2394: static const char * const altopData@var838 [ 8 ] = { "and" , "or" , "bitand" , "bitor" , "compl" , "not" , "not_eq" , "xor" } ;
2395: static const std :: set < std :: string > altop@var839 ( & altopData@var838 [ 0 ] , & altopData@var838 [ 8 ] ) ;
2396: static void simplifyName ( simplecpp :: TokenList & expr@var840 )
2397: {
2398: for (@expr1073747559 simplecpp ::@expr1073747560 Token *@expr1073747561 tok@var841 =@expr1073747562 expr@var840 .@expr1073747563 front (@expr1073747564 ) ; tok@var841 ; tok@var841 =@expr1073747565 tok@var841 .@expr1073747566 next@var842 ) {
2399: if (@expr1073747567 tok@var841 .@expr1073747568 name@var843 ) {
2400: if (@expr1073747569 altop@var839 .@expr1073747570 find (@expr1073747571 tok@var841 .@expr5748 str (@expr5749 ) ) !=@expr1073747574 altop@var839 .@expr1073747575 end (@expr1073747576 ) ) {
2401: bool alt@var844 ;
2402: if (@expr1073747577 tok@var841 .@expr5748 str (@expr5749 ) ==@expr1073747580 "not" ||@expr1073747581 tok@var841 .@expr5748 str (@expr5749 ) ==@expr1073747584 "compl" ) {
2403: alt@var844 =@expr1073747585 isAlternativeUnaryOp (@expr1073747586 tok@var841 , tok@var841 .@expr5748 str (@expr5749 ) ) ;
2404: } else {
2405: alt@var844 =@expr1073747589 isAlternativeBinaryOp (@expr1073747590 tok@var841 , tok@var841 .@expr5748 str (@expr5749 ) ) ;
2406: }
2407: if (@expr1073747593 alt@var844 ) {
2408: continue ; }
2409: }
2410: tok@var841 .@expr1073747594 setstr (@expr1073747595 "0" ) ;
2411: }
2412: }
2413: }
2414:
|
2422:
2423: static unsigned long long stringToULLbounded (
2424: const std :: string & s@var845 ,
2425: unsigned long & pos@var846 ,
2426: int base@var847 = 0 ,
2427: long minlen@var848 = 1 ,
2428: unsigned long maxlen@var849 = std :: string :: npos
2429: )
2430: {
2431: std ::@expr1073747596 string sub@var850 ; sub@var850 =@expr1073747597 s@var845 .@expr1073747598 substr (@expr1073747599 pos@var846 , maxlen@var849 ) ;
2432: const char * start@var851 ; start@var851 =@expr1073747600 sub@var850 .@expr1073747601 c_str (@expr1073747602 ) ;
2433: char * end@var852 ;
2434: unsigned long long value@var853 ; value@var853 =@expr1073747603 std ::@expr1073747604 strtoull (@expr1073747605 start@var851 , &@expr1073747606 end@var852 , base@var847 ) ;
2435: pos@var846 +=@expr1073747607 end@var852 -@expr5784 start@var851 ;
2436: if (@expr1073747609 end@var852 -@expr5784 start@var851 <@expr1073747611 minlen@var848 ) {
2437: throw std ::@expr1073747612 runtime_error (@expr1073747613 "expected digit" ) ; }
2438: return value@var853 ;
2439: }
2440:
|
2468:
2469: long long simplecpp :: characterLiteralToLL ( const std :: string & str@var854 )
2470: {
2471:
2472: bool narrow@var855 ; narrow@var855 =@expr1073747615 false ;
2473: bool utf8@var856 ; utf8@var856 =@expr1073747616 false ;
2474: bool utf16@var857 ; utf16@var857 =@expr1073747617 false ;
2475:
2476: unsigned long pos@var858 ;
2477:
2478: if (@expr1073747618 str@var854 .@expr5795 size (@expr5796 ) >=@expr1073747621 1 &&@expr1073747622 str@var854 [@expr5799 0 ] ==@expr1073747624 '\'' ) {
2479: narrow@var855 =@expr1073747625 true ;
2480: pos@var858 =@expr1073747626 1 ;
2481: } else { if (@expr1073747627 str@var854 .@expr5795 size (@expr5796 ) >=@expr5806 2 &&@expr1073747631 str@var854 [@expr5799 0 ] ==@expr5809 'u' &&@expr1073747634 str@var854 [@expr5811 1 ] ==@expr5812 '\'' ) {
2482: utf16@var857 =@expr1073747637 true ;
2483: pos@var858 =@expr1073747638 2 ;
2484: } else { if (@expr1073747639 str@var854 .@expr5795 size (@expr5796 ) >=@expr1073747642 3 &&@expr1073747643 str@var854 [@expr5799 0 ] ==@expr5809 'u' &&@expr1073747646 str@var854 [@expr5811 1 ] ==@expr1073747648 '8' &&@expr1073747649 str@var854 [@expr1073747650 2 ] ==@expr1073747651 '\'' ) {
2485: utf8@var856 =@expr1073747652 true ;
2486: pos@var858 =@expr1073747653 3 ;
2487: } else { if (@expr1073747654 str@var854 .@expr5795 size (@expr5796 ) >=@expr5806 2 &&@expr1073747658 (@expr1073747659 str@var854 [@expr5799 0 ] ==@expr1073747661 'L' ||@expr1073747662 str@var854 [@expr5799 0 ] ==@expr1073747664 'U' ) &&@expr1073747665 str@var854 [@expr5811 1 ] ==@expr5812 '\'' ) {
2488: pos@var858 =@expr1073747668 2 ;
2489: } else {
2490: throw std ::@expr5845 runtime_error (@expr1073747670 "expected a character literal" ) ; } } } }
2491:
2492: unsigned long long multivalue@var859 ; multivalue@var859 =@expr1073747671 0 ;
2493:
2494: unsigned long nbytes@var860 ; nbytes@var860 =@expr1073747672 0 ;
2495:
2496: while (@expr1073747673 pos@var858 +@expr5850 1 <@expr1073747675 str@var854 .@expr5795 size (@expr5796 ) ) {
2497: if (@expr1073747678 str@var854 [@expr5855 pos@var858 ] ==@expr1073747680 '\'' ||@expr1073747681 str@var854 [@expr5855 pos@var858 ] ==@expr1073747683 '\n' ) {
2498: throw std ::@expr5845 runtime_error (@expr1073747685 "raw single quotes and newlines not allowed in character literals" ) ; }
2499:
2500: if (@expr1073747686 nbytes@var860 >=@expr1073747687 1 &&@expr1073747688 !@expr5865 narrow@var855 ) {
2501: throw std ::@expr5845 runtime_error (@expr1073747691 "multiple characters only supported in narrow character literals" ) ; }
2502:
2503: unsigned long long value@var861 ;
2504:
2505: if (@expr1073747692 str@var854 [@expr5855 pos@var858 ] ==@expr1073747694 '\\' ) {
2506: pos@var858 ++@expr1073747695 ;
2507: char escape@var862 ; escape@var862 =@expr1073747696 str@var854 [@expr1073747697 pos@var858 ++@expr1073747698 ] ;
2508:
2509: if (@expr1073747699 pos@var858 >=@expr1073747700 str@var854 .@expr5795 size (@expr5796 ) ) {
2510: throw std ::@expr5845 runtime_error (@expr1073747704 "unexpected end of character literal" ) ; }
2511:
2512: switch (@expr1073747705 escape@var862 ) {
2513:
2514: case '%' :@expr5882
2515: case '(' :@expr5882
2516: case '[' :@expr5882
2517: case '{' :@expr5882
2518:
2519: case '\'' :@expr5882
2520: case '"' :@expr5882
2521: case '?' :@expr5882
2522: case '\\' :@expr5882 ;
2523: value@var861 =@expr1073747714 static_cast < unsigned char > (@expr1073747715 escape@var862 ) ;
2524: break ;
2525:
2526: case 'a' :@expr5882 ;
2527: value@var861 =@expr1073747717 static_cast < unsigned char > (@expr1073747718 '\a' ) ;
2528: break ;
2529: case 'b' :@expr5882 ;
2530: value@var861 =@expr1073747720 static_cast < unsigned char > (@expr1073747721 '\b' ) ;
2531: break ;
2532: case 'f' :@expr5882 ;
2533: value@var861 =@expr1073747723 static_cast < unsigned char > (@expr1073747724 '\f' ) ;
2534: break ;
2535: case 'n' :@expr5882 ;
2536: value@var861 =@expr1073747726 static_cast < unsigned char > (@expr1073747727 '\n' ) ;
2537: break ;
2538: case 'r' :@expr5882 ;
2539: value@var861 =@expr1073747729 static_cast < unsigned char > (@expr1073747730 '\r' ) ;
2540: break ;
2541: case 't' :@expr5882 ;
2542: value@var861 =@expr1073747732 static_cast < unsigned char > (@expr1073747733 '\t' ) ;
2543: break ;
2544: case 'v' :@expr5882 ;
2545: value@var861 =@expr1073747735 static_cast < unsigned char > (@expr1073747736 '\v' ) ;
2546: break ;
2547:
2548:
2549: case 'e' :@expr5882
2550: case 'E' :@expr5882 ;
2551: value@var861 =@expr1073747739 static_cast < unsigned char > (@expr1073747740 '\x1b' ) ;
2552: break ;
2553:
2554: case '0' :@expr5882
2555: case '1' :@expr5882
2556: case '2' :@expr5882
2557: case '3' :@expr5882
2558: case '4' :@expr5882
2559: case '5' :@expr5882
2560: case '6' :@expr5882
2561: case '7' :@expr5882 ;
2562:
2563: value@var861 =@expr1073747749 stringToULLbounded (@expr1073747750 str@var854 , --@expr1073747751 pos@var858 , 8 , 1 , 3 ) ;
2564: break ;
2565:
2566: case 'x' :@expr5882 ;
2567:
2568: value@var861 =@expr1073747753 stringToULLbounded (@expr1073747754 str@var854 , pos@var858 , 16 ) ;
2569: break ;
2570:
2571: case 'u' :@expr5882
2572: case 'U' :@expr5882 ; {
2573:
2574: unsigned long ndigits@var863 ; ndigits@var863 =@expr1073747757 escape@var862 ==@expr1073747758 'u' ?@expr1073747759 4 :@expr1073747760 8 ;
2575: value@var861 =@expr1073747761 stringToULLbounded (@expr1073747762 str@var854 , pos@var858 , 16 , ndigits@var863 , ndigits@var863 ) ;
2576:
2577:
2578:
2579: if (@expr1073747763 (@expr1073747764 (@expr1073747765 narrow@var855 ||@expr5942 utf8@var856 ) &&@expr1073747767 value@var861 >@expr5944 0x7f ) ||@expr1073747769 (@expr1073747770 utf16@var857 &&@expr5947 value@var861 >@expr5948 0xffff ) ||@expr1073747773 value@var861 >@expr5950 0x10ffff ) {
2580: throw std ::@expr5845 runtime_error (@expr5952 "code point too large" ) ; }
2581:
2582: if (@expr5953 value@var861 >=@expr5954 0xd800 &&@expr5955 value@var861 <=@expr5956 0xdfff ) {
2583: throw std ::@expr5845 runtime_error (@expr1073747782 "surrogate code points not allowed in universal character names" ) ; }
2584:
2585: break ;
2586: }
2587:
2588: default :@expr5882 ;
2589: throw std ::@expr5845 runtime_error (@expr1073747785 "invalid escape sequence" ) ;
2590: }
2591: } else {
2592: value@var861 =@expr1073747786 static_cast < unsigned char > (@expr1073747787 str@var854 [@expr1073747788 pos@var858 ++@expr1073747789 ] ) ;
2593:
2594: if (@expr1073747790 !@expr5865 narrow@var855 &&@expr1073747792 value@var861 >=@expr1073747793 0x80 ) {
2595:
|
2598:
2599: int additional_bytes@var864 ;
2600: if (@expr1073747794 value@var861 >=@expr1073747795 0xf5 ) {
2601: throw std ::@expr5845 runtime_error (@expr5973 "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2602: else { if (@expr1073747798 value@var861 >=@expr1073747799 0xf0 ) {
2603: additional_bytes@var864 =@expr1073747800 3 ; }
2604: else { if (@expr1073747801 value@var861 >=@expr1073747802 0xe0 ) {
2605: additional_bytes@var864 =@expr1073747803 2 ; }
2606: else { if (@expr1073747804 value@var861 >=@expr1073747805 0xc2 ) {
2607: additional_bytes@var864 =@expr1073747806 1 ; }
2608: else {
2609: throw std ::@expr5845 runtime_error (@expr5973 "assumed UTF-8 encoded source, but sequence is invalid" ) ; } } } }
2610:
2611: value@var861 &=@expr1073747809 (@expr1073747810 1 <<@expr1073747811 (@expr1073747812 6 -@expr1073747813 additional_bytes@var864 ) ) -@expr1073747814 1 ;
2612:
2613: while (@expr1073747815 additional_bytes@var864 --@expr1073747816 ) {
2614: if (@expr1073747817 pos@var858 +@expr5850 1 >=@expr1073747819 str@var854 .@expr5795 size (@expr5796 ) ) {
2615: throw std ::@expr5845 runtime_error (@expr1073747823 "assumed UTF-8 encoded source, but character literal ends unexpectedly" ) ; }
2616:
2617: unsigned char c@var865 ; c@var865 =@expr1073747824 str@var854 [@expr1073747825 pos@var858 ++@expr1073747826 ] ;
2618:
2619: if (@expr1073747827 (@expr1073747828 (@expr1073747829 c@var865 >>@expr1073747830 6 ) !=@expr1073747831 2 )
2620: ||@expr1073747832 (@expr1073747833 !@expr6010 value@var861 &&@expr1073747835 additional_bytes@var864 ==@expr1073747836 1 &&@expr1073747837 c@var865 <@expr1073747838 0xa0 )
2621: ||@expr1073747839 (@expr1073747840 !@expr6010 value@var861 &&@expr1073747842 additional_bytes@var864 ==@expr1073747843 2 &&@expr1073747844 c@var865 <@expr1073747845 0x90 ) ) {
2622: throw std ::@expr5845 runtime_error (@expr5973 "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2623:
2624: value@var861 =@expr1073747848 (@expr1073747849 value@var861 <<@expr1073747850 6 ) |@expr1073747851 (@expr1073747852 c@var865 &@expr1073747853 (@expr1073747854 (@expr1073747855 1 <<@expr1073747856 7 ) -@expr1073747857 1 ) ) ;
2625: }
2626:
2627: if (@expr5953 value@var861 >=@expr5954 0xd800 &&@expr5955 value@var861 <=@expr5956 0xdfff ) {
2628: throw std ::@expr5845 runtime_error (@expr5973 "assumed UTF-8 encoded source, but sequence is invalid" ) ; }
2629:
2630: if (@expr1073747864 (@expr1073747865 utf8@var856 &&@expr1073747866 value@var861 >@expr5944 0x7f ) ||@expr1073747868 (@expr1073747869 utf16@var857 &&@expr5947 value@var861 >@expr5948 0xffff ) ||@expr1073747872 value@var861 >@expr5950 0x10ffff ) {
2631: throw std ::@expr5845 runtime_error (@expr5952 "code point too large" ) ; }
2632: }
2633: }
2634:
2635: if (@expr1073747876 (@expr1073747877 (@expr1073747878 narrow@var855 ||@expr5942 utf8@var856 ) &&@expr1073747880 value@var861 >@expr1073747881 std ::@expr1073747882 numeric_limits < unsigned char > ::@expr1073747883 max (@expr1073747884 ) ) ||@expr1073747885 (@expr1073747886 utf16@var857 &&@expr1073747887 value@var861 >>@expr1073747888 16 ) ||@expr1073747889 value@var861 >>@expr1073747890 32 ) {
2636: throw std ::@expr5845 runtime_error (@expr1073747892 "numeric escape sequence too large" ) ; }
2637:
2638: multivalue@var859 <<=@expr1073747893 CHAR_BIT@expr1073747614 ;
2639: multivalue@var859 |=@expr1073747894 value@var861 ;
2640: nbytes@var860 ++@expr1073747895 ;
2641: }
2642:
2643: if (@expr1073747896 pos@var858 +@expr5850 1 !=@expr1073747898 str@var854 .@expr5795 size (@expr5796 ) ||@expr1073747901 str@var854 [@expr5855 pos@var858 ] !=@expr1073747903 '\'' ) {
2644: throw std ::@expr5845 runtime_error (@expr1073747905 "missing closing quote in character literal" ) ; }
2645:
2646: if (@expr1073747906 !@expr1073747907 nbytes@var860 ) {
2647: throw std ::@expr5845 runtime_error (@expr1073747909 "empty character literal" ) ; }
2648:
2649:
2650: if (@expr1073747910 narrow@var855 &&@expr1073747911 nbytes@var860 ==@expr1073747912 1 ) {
2651: return static_cast < char > (@expr1073747913 multivalue@var859 ) ; }
2652:
2653:
2654: if (@expr1073747914 narrow@var855 ) {
2655: return static_cast < int > (@expr1073747915 multivalue@var859 ) ; }
2656:
2657:
2658:
2659: return multivalue@var859 ;
2660: }
2661:
2662: static void simplifyNumbers ( simplecpp :: TokenList & expr@var866 )
2663: {
2664: for (@expr1073747917 simplecpp ::@expr1073747918 Token *@expr1073747919 tok@var867 =@expr1073747920 expr@var866 .@expr1073747921 front (@expr1073747922 ) ; tok@var867 ; tok@var867 =@expr1073747923 tok@var867 .@expr1073747924 next@var868 ) {
2665: if (@expr1073747925 tok@var867 .@expr6102 str (@expr6103 ) .@expr1073747928 size (@expr1073747929 ) ==@expr1073747930 1U ) {
2666: continue ; }
2667: if (@expr1073747931 tok@var867 .@expr6102 str (@expr6103 ) .@expr1073747934 compare (@expr1073747935 0 , 2 , "0x" ) ==@expr1073747936 0 ) {
2668: tok@var867 .@expr6113 setstr (@expr1073747938 toString (@expr1073747939 stringToULL (@expr1073747940 tok@var867 .@expr6102 str (@expr6103 ) ) ) ) ; }
2669: else { if (@expr1073747943 !@expr1073747944 tok@var867 .@expr1073747945 number@var869 &&@expr1073747946 tok@var867 .@expr6102 str (@expr6103 ) .@expr1073747949 find (@expr1073747950 '\'' ) !=@expr1073747951 tok@var867 .@expr6102 str (@expr6103 ) .@expr1073747954 npos@expr1073747916 ) {
2670: tok@var867 .@expr6113 setstr (@expr1073747956 toString (@expr1073747957 simplecpp ::@expr1073747958 characterLiteralToLL (@expr1073747959 tok@var867 .@expr6102 str (@expr6103 ) ) ) ) ; } }
2671: }
2672: }
2673:
2674: static long long evaluate ( simplecpp :: TokenList & expr@var870 , const std :: map < std :: string , unsigned long > & sizeOfType@var871 )
2675: {
2676: simplifySizeof (@expr1073747962 expr@var870 , sizeOfType@var871 ) ;
2677: simplifyName (@expr1073747963 expr@var870 ) ;
2678: simplifyNumbers (@expr1073747964 expr@var870 ) ;
2679: expr@var870 .@expr1073747965 constFold (@expr1073747966 ) ;
2680:
2681: return expr@var870 .@expr6143 cfront (@expr6144 ) &&@expr1073747969 expr@var870 .@expr6143 cfront (@expr6144 ) ==@expr1073747972 expr@var870 .@expr1073747973 cback (@expr1073747974 ) &&@expr1073747975 expr@var870 .@expr6143 cfront (@expr6144 ) .@expr1073747978 number@var1126 ?@expr1073747979 stringToLL (@expr1073747980 expr@var870 .@expr6143 cfront (@expr6144 ) .@expr1073747983 str (@expr1073747984 ) ) :@expr1073747985 0LL ;
2682: }
2683:
2684: static const simplecpp :: Token * gotoNextLine ( const simplecpp :: Token * tok@var872 )
2685: {
2686: const unsigned int line@var873 =@expr1073747986 tok@var872 .@expr6163 location@var874 .@expr6164 line@var875 ;
2687: const unsigned int file@var876 =@expr1073747989 tok@var872 .@expr6163 location@var874 .@expr6167 fileIndex@var877 ;
2688: while (@expr1073747992 tok@var872 &&@expr1073747993 tok@var872 .@expr6163 location@var874 .@expr6164 line@var875 ==@expr1073747996 line@var873 &&@expr1073747997 tok@var872 .@expr6163 location@var874 .@expr6167 fileIndex@var877 ==@expr1073748000 file@var876 ) {
2689: tok@var872 =@expr1073748001 tok@var872 .@expr1073748002 next@var878 ; }
2690: return tok@var872 ;
2691: }
2692:
|
2723:
2724: static std :: string openHeader ( std :: ifstream & f@var879 , const std :: string & path@var880 )
2725: {
2726:
|
2738:
2739: f@var879 .@expr1073748003 open (@expr1073748004 path@var880 .@expr1073748005 c_str (@expr1073748006 ) ) ;
2740: return f@var879 .@expr1073748007 is_open (@expr1073748008 ) ?@expr1073748009 simplecpp ::@expr1073748010 simplifyPath (@expr1073748011 path@var880 ) :@expr1073748012 "" ;
2741:
2742: }
2743:
2744: static std :: string getRelativeFileName ( const std :: string & sourcefile@var881 , const std :: string & header@var882 )
2745: {
2746: if (@expr1073748014 sourcefile@var881 .@expr1073748015 find_first_of (@expr1073748016 "\\/" ) !=@expr1073748017 std ::@expr1073748018 string ::@expr1073748019 npos@expr1073748013 ) {
2747: return simplecpp ::@expr6196 simplifyPath (@expr1073748021 sourcefile@var881 .@expr1073748022 substr (@expr1073748023 0 , sourcefile@var881 .@expr1073748024 find_last_of (@expr1073748025 "\\/" ) +@expr1073748026 1U ) +@expr1073748027 header@var882 ) ; }
2748: return simplecpp ::@expr6196 simplifyPath (@expr1073748029 header@var882 ) ;
2749: }
2750:
2751: static std :: string openHeaderRelative ( std :: ifstream & f@var883 , const std :: string & sourcefile@var884 , const std :: string & header@var885 )
2752: {
2753: return openHeader (@expr1073748030 f@var883 , getRelativeFileName (@expr1073748031 sourcefile@var884 , header@var885 ) ) ;
2754: }
2755:
2756: static std :: string getIncludePathFileName ( const std :: string & includePath@var886 , const std :: string & header@var887 )
2757: {
2758: std ::@expr1073748032 string path@var888 ; path@var888 =@expr1073748033 includePath@var886 ;
2759: if (@expr1073748034 !@expr1073748035 path@var888 .@expr1073748036 empty (@expr1073748037 ) &&@expr1073748038 path@var888 [@expr6215 path@var888 .@expr6216 size (@expr6217 ) -@expr6218 1U ] !=@expr1073748043 '/' &&@expr1073748044 path@var888 [@expr6215 path@var888 .@expr6216 size (@expr6217 ) -@expr6218 1U ] !=@expr1073748049 '\\' ) {
2760: path@var888 +=@expr1073748050 '/' ; }
2761: return path@var888 +@expr1073748051 header@var887 ;
2762: }
2763:
2764: static std :: string openHeaderIncludePath ( std :: ifstream & f@var889 , const simplecpp :: DUI & dui@var890 , const std :: string & header@var891 )
2765: {
2766: for (@expr1073748052 std ::@expr6229 list < std ::@expr6229 string > ::@expr6229 const_iterator it@var892 =@expr1073748056 dui@var890 .@expr6233 includePaths@var893 .@expr1073748058 begin (@expr1073748059 ) ; it@var892 !=@expr1073748060 dui@var890 .@expr6233 includePaths@var893 .@expr1073748062 end (@expr1073748063 ) ; ++@expr1073748064 it@var892 ) {
2767: std ::@expr1073748065 string simplePath@var894 ; simplePath@var894 =@expr1073748066 openHeader (@expr1073748067 f@var889 , getIncludePathFileName (@expr1073748068 *@expr1073748069 it@var892 , header@var891 ) ) ;
2768: if (@expr1073748070 !@expr1073748071 simplePath@var894 .@expr1073748072 empty (@expr1073748073 ) ) {
2769: return simplePath@var894 ; }
2770: }
2771: return "" ;
2772: }
2773:
2774: static std :: string openHeader ( std :: ifstream & f@var895 , const simplecpp :: DUI & dui@var896 , const std :: string & sourcefile@var897 , const std :: string & header@var898 , bool systemheader@var899 )
2775: {
2776: if (@expr1073748074 isAbsolutePath (@expr1073748075 header@var898 ) ) {
2777: return openHeader (@expr1073748076 f@var895 , header@var898 ) ; }
2778:
2779: std ::@expr1073748077 string ret@var900 ;
2780:
2781: if (@expr1073748078 systemheader@var899 ) {
2782: ret@var900 =@expr1073748079 openHeaderIncludePath (@expr6256 f@var895 , dui@var896 , header@var898 ) ;
2783: return ret@var900 .@expr6257 empty (@expr6258 ) ?@expr1073748083 openHeaderRelative (@expr6260 f@var895 , sourcefile@var897 , header@var898 ) :@expr1073748085 ret@var900 ;
2784: }
2785:
2786: ret@var900 =@expr1073748086 openHeaderRelative (@expr6260 f@var895 , sourcefile@var897 , header@var898 ) ;
2787: return ret@var900 .@expr6257 empty (@expr6258 ) ?@expr1073748090 openHeaderIncludePath (@expr6256 f@var895 , dui@var896 , header@var898 ) :@expr1073748092 ret@var900 ;
2788: }
2789:
2790: static std :: string getFileName ( const std :: map < std :: string , simplecpp :: TokenList * > & filedata@var901 , const std :: string & sourcefile@var902 , const std :: string & header@var903 , const simplecpp :: DUI & dui@var904 , bool systemheader@var905 )
2791: {
2792: if (@expr1073748093 filedata@var901 .@expr1073748094 empty (@expr1073748095 ) ) {
2793: return "" ;
2794: }
2795: if (@expr1073748096 isAbsolutePath (@expr1073748097 header@var903 ) ) {
2796: return (@expr1073748098 filedata@var901 .@expr6275 find (@expr1073748100 header@var903 ) !=@expr1073748101 filedata@var901 .@expr6278 end (@expr6279 ) ) ?@expr1073748104 simplecpp ::@expr6281 simplifyPath (@expr1073748106 header@var903 ) :@expr1073748107 "" ;
2797: }
2798:
2799: const std ::@expr6284 string relativeFilename@var906 =@expr1073748109 getRelativeFileName (@expr1073748110 sourcefile@var902 , header@var903 ) ;
2800: if (@expr1073748111 !@expr1073748112 systemheader@var905 &&@expr1073748113 filedata@var901 .@expr6275 find (@expr6291 relativeFilename@var906 ) !=@expr6292 filedata@var901 .@expr6278 end (@expr6279 ) ) {
2801: return relativeFilename@var906 ; }
2802:
2803: for (@expr1073748119 std ::@expr6284 list < std ::@expr6284 string > ::@expr6284 const_iterator it@var907 =@expr1073748123 dui@var904 .@expr6300 includePaths@var908 .@expr1073748125 begin (@expr1073748126 ) ; it@var907 !=@expr1073748127 dui@var904 .@expr6300 includePaths@var908 .@expr1073748129 end (@expr1073748130 ) ; ++@expr1073748131 it@var907 ) {
2804: std ::@expr1073748132 string s@var909 ; s@var909 =@expr1073748133 simplecpp ::@expr6281 simplifyPath (@expr1073748135 getIncludePathFileName (@expr1073748136 *@expr1073748137 it@var907 , header@var903 ) ) ;
2805: if (@expr1073748138 filedata@var901 .@expr6275 find (@expr1073748140 s@var909 ) !=@expr1073748141 filedata@var901 .@expr6278 end (@expr6279 ) ) {
2806: return s@var909 ; }
2807: }
2808:
2809: if (@expr1073748144 filedata@var901 .@expr6275 find (@expr6291 relativeFilename@var906 ) !=@expr6292 filedata@var901 .@expr6278 end (@expr6279 ) ) {
2810: return relativeFilename@var906 ; }
2811:
2812: return "" ;
2813: }
2814:
2815: static bool hasFile ( const std :: map < std :: string , simplecpp :: TokenList * > & filedata@var910 , const std :: string & sourcefile@var911 , const std :: string & header@var912 , const simplecpp :: DUI & dui@var913 , bool systemheader@var914 )
2816: {
2817: return !@expr1073748150 getFileName (@expr1073748151 filedata@var910 , sourcefile@var911 , header@var912 , dui@var913 , systemheader@var914 ) .@expr1073748152 empty (@expr1073748153 ) ;
2818: }
2819:
2820: std :: map < std :: string , simplecpp :: TokenList * > simplecpp :: load ( const simplecpp :: TokenList & rawtokens@var915 , std :: vector < std :: string > & fileNumbers@var916 , const simplecpp :: DUI & dui@var917 , simplecpp :: OutputList * outputList@var918 )
2821: {
2822: std ::@expr1073748154 map < std ::@expr6331 string , simplecpp ::@expr6331 TokenList *@expr6333 > ret@var919 ;
2823:
2824: std ::@expr1073748158 list < const Token *@expr6333 > filelist@var920 ;
2825:
2826:
2827: for (@expr1073748160 std ::@expr6331 list < std ::@expr6331 string > ::@expr6331 const_iterator it@var921 =@expr1073748164 dui@var917 .@expr6341 includes@var922 .@expr1073748166 begin (@expr1073748167 ) ; it@var921 !=@expr1073748168 dui@var917 .@expr6341 includes@var922 .@expr1073748170 end (@expr1073748171 ) ; ++@expr1073748172 it@var921 ) {
2828: const std ::@expr6331 string &@expr6350 filename@var923 =@expr1073748175 *@expr1073748176 it@var921 ;
2829:
2830: if (@expr1073748177 ret@var919 .@expr1073748178 find (@expr1073748179 filename@var923 ) !=@expr1073748180 ret@var919 .@expr1073748181 end (@expr1073748182 ) ) {
2831: continue ; }
2832:
2833: std ::@expr1073748183 ifstream fin@var924 (@expr1073748184 filename@var923 .@expr1073748185 c_str (@expr1073748186 ) ) ;
2834: if (@expr1073748187 !@expr1073748188 fin@var924 .@expr1073748189 is_open (@expr1073748190 ) ) {
2835: if (@expr1073748191 outputList@var918 ) {
2836: simplecpp ::@expr1073748192 Output err@var925 (@expr1073748193 fileNumbers@var916 ) ;
2837: err@var925 .@expr1073748194 type@var926 =@expr1073748195 simplecpp ::@expr1073748196 Output ::@expr1073748197 EXPLICIT_INCLUDE_NOT_FOUND ;
2838: err@var925 .@expr1073748198 location@var927 =@expr1073748199 Location (@expr1073748200 fileNumbers@var916 ) ;
2839: err@var925 .@expr1073748201 msg@var928 =@expr1073748202 "Can not open include file '" +@expr1073748203 filename@var923 +@expr1073748204 "' that is explicitly included." ;
2840: outputList@var918 .@expr1073748205 push_back (@expr1073748206 err@var925 ) ;
2841: }
2842: continue ;
2843: }
2844:
2845: TokenList * tokenlist@var929 ; tokenlist@var929 =@expr1073748207 new TokenList (@expr1073748208 fin@var924 , fileNumbers@var916 , filename@var923 , outputList@var918 ) ;
2846: if (@expr1073748209 !@expr1073748210 tokenlist@var929 .@expr6387 front (@expr6388 ) ) {
2847: delete tokenlist@var929 ;
2848: continue ;
2849: }
2850:
2851: ret@var919 [@expr1073748213 filename@var923 ] =@expr1073748214 tokenlist@var929 ;
2852: filelist@var920 .@expr6391 push_back (@expr1073748216 tokenlist@var929 .@expr6387 front (@expr6388 ) ) ;
2853: }
2854:
2855: for (@expr1073748219 const Token *@expr6333 rawtok@var930 =@expr1073748221 rawtokens@var915 .@expr1073748222 cfront (@expr1073748223 ) ; rawtok@var930 ||@expr1073748224 !@expr1073748225 filelist@var920 .@expr1073748226 empty (@expr1073748227 ) ; rawtok@var930 =@expr1073748228 rawtok@var930 ?@expr1073748229 rawtok@var930 .@expr1073748230 next@var931 :@expr1073748231 nullptr ) {
2856: if (@expr1073748232 rawtok@var930 ==@expr1073748233 nullptr ) {
2857: rawtok@var930 =@expr1073748234 filelist@var920 .@expr1073748235 back (@expr1073748236 ) ;
2858: filelist@var920 .@expr1073748237 pop_back (@expr1073748238 ) ;
2859: }
2860:
2861: if (@expr1073748239 rawtok@var930 .@expr1073748240 op@var932 !=@expr1073748241 '#' ||@expr1073748242 sameline (@expr1073748243 rawtok@var930 .@expr1073748244 previousSkipComments (@expr1073748245 ) , rawtok@var930 ) ) {
2862: continue ; }
2863:
2864: rawtok@var930 =@expr1073748246 rawtok@var930 .@expr6423 nextSkipComments (@expr6424 ) ;
2865: if (@expr1073748249 !@expr1073748250 rawtok@var930 ||@expr1073748251 rawtok@var930 .@expr1073748252 str (@expr1073748253 ) !=@expr1073748254 INCLUDE@var154 ) {
2866: continue ; }
2867:
2868: const std ::@expr6331 string &@expr6350 sourcefile@var933 =@expr1073748257 rawtok@var930 .@expr1073748258 location@var934 .@expr1073748259 file (@expr1073748260 ) ;
2869:
2870: const Token * htok@var935 ; htok@var935 =@expr1073748261 rawtok@var930 .@expr6423 nextSkipComments (@expr6424 ) ;
2871: if (@expr1073748264 !@expr1073748265 sameline (@expr1073748266 rawtok@var930 , htok@var935 ) ) {
2872: continue ; }
2873:
2874: bool systemheader@var936 ; systemheader@var936 =@expr1073748267 htok@var935 .@expr6444 str (@expr6445 ) [@expr1073748270 0 ] ==@expr1073748271 '<' ;
2875: const std ::@expr1073748272 string header@var937 (@expr1073748273 htok@var935 .@expr6444 str (@expr6445 ) .@expr1073748276 substr (@expr1073748277 1U , htok@var935 .@expr6444 str (@expr6445 ) .@expr1073748280 size (@expr1073748281 ) -@expr1073748282 2U ) ) ;
2876: if (@expr1073748283 hasFile (@expr1073748284 ret@var919 , sourcefile@var933 , header@var937 , dui@var917 , systemheader@var936 ) ) {
2877: continue ; }
2878:
2879: std ::@expr1073748285 ifstream f@var938 ;
2880: const std ::@expr6331 string header2@var939 =@expr1073748287 openHeader (@expr1073748288 f@var938 , dui@var917 , sourcefile@var933 , header@var937 , systemheader@var936 ) ;
2881: if (@expr1073748289 !@expr1073748290 f@var938 .@expr1073748291 is_open (@expr1073748292 ) ) {
2882: continue ; }
2883:
2884: TokenList * tokens@var940 ; tokens@var940 =@expr1073748293 new TokenList (@expr1073748294 f@var938 , fileNumbers@var916 , header2@var939 , outputList@var918 ) ;
2885: ret@var919 [@expr1073748295 header2@var939 ] =@expr1073748296 tokens@var940 ;
2886: if (@expr1073748297 tokens@var940 .@expr6474 front (@expr6475 ) ) {
2887: filelist@var920 .@expr6391 push_back (@expr1073748301 tokens@var940 .@expr6474 front (@expr6475 ) ) ; }
2888: }
2889:
2890: return ret@var919 ;
2891: }
2892:
2893: static bool preprocessToken ( simplecpp :: TokenList & output@var941 , const simplecpp :: Token * * tok1@var942 , std :: unordered_map < std :: string , Macro > & macros@var943 , std :: vector < std :: string > & files@var944 , simplecpp :: OutputList * outputList@var945 )
2894: {
2895: const simplecpp ::@expr6481 Token * tok@var946 ; tok@var946 =@expr1073748306 *@expr6483 tok1@var942 ;
2896: const std ::@expr1073748308 unordered_map < std ::@expr1073748309 string , Macro > ::@expr1073748310 const_iterator it@var947 =@expr1073748311 macros@var943 .@expr1073748312 find (@expr1073748313 tok@var946 .@expr6490 str (@expr6491 ) ) ;
2897: if (@expr1073748316 it@var947 !=@expr1073748317 macros@var943 .@expr1073748318 end (@expr1073748319 ) ) {
2898: simplecpp ::@expr1073748320 TokenList value@var948 (@expr1073748321 files@var944 ) ;
2899: try {
2900: *@expr6483 tok1@var942 =@expr1073748323 it@var947 .@expr1073748324 second@var949 .@expr1073748325 expand (@expr1073748326 &@expr1073748327 value@var948 , tok@var946 , macros@var943 , files@var944 ) ;
2901: } catch (@expr1073748328 simplecpp ::@expr1073748329 Macro ::@expr1073748330 Error & err@var950 ) {
2902: if (@expr1073748331 outputList@var945 ) {
2903: simplecpp ::@expr1073748332 Output out@var951 (@expr1073748333 files@var944 ) ;
2904: out@var951 .@expr1073748334 type@var952 =@expr1073748335 simplecpp ::@expr1073748336 Output ::@expr1073748337 SYNTAX_ERROR@expr1073748304 ;
2905: out@var951 .@expr1073748338 location@var953 =@expr1073748339 err@var950 .@expr1073748340 location@var954 ;
2906: out@var951 .@expr1073748341 msg@var955 =@expr1073748342 "failed to expand \'" +@expr1073748343 tok@var946 .@expr6490 str (@expr6491 ) +@expr1073748346 "\', " +@expr1073748347 err@var950 .@expr1073748348 what@var956 ;
2907: outputList@var945 .@expr1073748349 push_back (@expr1073748350 out@var951 ) ;
2908: }
2909: return false ;
2910: }
2911: output@var941 .@expr1073748351 takeTokens (@expr1073748352 value@var948 ) ;
2912: } else {
2913: if (@expr1073748353 !@expr1073748354 tok@var946 .@expr1073748355 comment@var957 ) {
2914: output@var941 .@expr1073748356 push_back (@expr1073748357 new simplecpp ::@expr6481 Token (@expr1073748359 *@expr1073748360 tok@var946 ) ) ; }
2915: *@expr6483 tok1@var942 =@expr1073748362 tok@var946 .@expr1073748363 next@var958 ;
2916: }
2917: return true ;
2918: }
2919:
2920: static void getLocaltime ( struct tm & ltime@var959 ) {
2921: time_t t@var960 ;
2922: time (@expr1073748364 &@expr6541 t@var960 ) ;
2923:
2924: localtime_r (@expr1073748366 &@expr6541 t@var960 , &@expr1073748368 ltime@var959 ) ;
2925:
2926:
2927:
2928: }
2929:
2930: static std :: string getDateDefine ( struct tm * timep@var961 ) {
2931: char buf@var962 [@expr1073748369 12 ] =@expr1073748370 "??? ?? ????" ;
2932: strftime (@expr1073748371 buf@var962 , sizeof (@expr1073748372 buf@var962 ) , "%b %d %Y" , timep@var961 ) ;
2933: return std ::@expr1073748373 string (@expr1073748374 "\"" ) .@expr1073748375 append (@expr1073748376 buf@var962 ) .@expr1073748377 append (@expr1073748378 "\"" ) ;
2934: }
2935:
2936: static std :: string getTimeDefine ( struct tm * timep@var963 ) {
2937: char buf@var964 [@expr1073748379 9 ] =@expr1073748380 "??:??:??" ;
2938: strftime (@expr1073748381 buf@var964 , sizeof (@expr1073748382 buf@var964 ) , "%T" , timep@var963 ) ;
2939: return std ::@expr1073748383 string (@expr1073748384 "\"" ) .@expr1073748385 append (@expr1073748386 buf@var964 ) .@expr1073748387 append (@expr1073748388 "\"" ) ;
2940: }
2941:
2942: void simplecpp :: preprocess ( simplecpp :: TokenList & output@var965 , const simplecpp :: TokenList & rawtokens@var966 , std :: vector < std :: string > & files@var967 , std :: map < std :: string , simplecpp :: TokenList * > & filedata@var968 , const simplecpp :: DUI & dui@var969 , simplecpp :: OutputList * outputList@var970 , std :: list < simplecpp :: MacroUsage > * macroUsage@var971 , std :: list < simplecpp :: IfCond > * ifCond@var972 )
2943: {
2944: std ::@expr1073748400 map < std ::@expr6577 string , unsigned long > sizeOfType@var973 (@expr1073748402 rawtokens@var966 .@expr1073748403 sizeOfType@var974 ) ;
2945: sizeOfType@var973 .@expr6580 insert (@expr1073748405 std ::@expr6582 make_pair (@expr1073748407 "char" , sizeof (@expr6584 char ) ) ) ;
2946: sizeOfType@var973 .@expr6580 insert (@expr1073748410 std ::@expr6582 make_pair (@expr1073748412 "short" , sizeof (@expr6589 short ) ) ) ;
2947: sizeOfType@var973 .@expr6580 insert (@expr1073748415 std ::@expr6582 make_pair (@expr1073748417 "short int" , sizeOfType@var973 [@expr1073748418 "short" ] ) ) ;
2948: sizeOfType@var973 .@expr6580 insert (@expr1073748420 std ::@expr6582 make_pair (@expr1073748422 "int" , sizeof (@expr6599 int ) ) ) ;
2949: sizeOfType@var973 .@expr6580 insert (@expr1073748425 std ::@expr6582 make_pair (@expr1073748427 "long" , sizeof (@expr6604 long ) ) ) ;
2950: sizeOfType@var973 .@expr6580 insert (@expr1073748430 std ::@expr6582 make_pair (@expr1073748432 "long int" , sizeOfType@var973 [@expr1073748433 "long" ] ) ) ;
2951: sizeOfType@var973 .@expr6580 insert (@expr1073748435 std ::@expr6582 make_pair (@expr1073748437 "long long" , sizeof (@expr6614 long long ) ) ) ;
2952: sizeOfType@var973 .@expr6580 insert (@expr1073748440 std ::@expr6582 make_pair (@expr1073748442 "float" , sizeof (@expr6619 float ) ) ) ;
2953: sizeOfType@var973 .@expr6580 insert (@expr1073748445 std ::@expr6582 make_pair (@expr1073748447 "double" , sizeof (@expr6624 double ) ) ) ;
2954: sizeOfType@var973 .@expr6580 insert (@expr1073748450 std ::@expr6582 make_pair (@expr1073748452 "long double" , sizeof (@expr6629 long double ) ) ) ;
2955: sizeOfType@var973 .@expr6580 insert (@expr1073748455 std ::@expr6582 make_pair (@expr1073748457 "char *" , sizeof (@expr6584 char *@expr6635 ) ) ) ;
2956: sizeOfType@var973 .@expr6580 insert (@expr1073748461 std ::@expr6582 make_pair (@expr1073748463 "short *" , sizeof (@expr6589 short *@expr6635 ) ) ) ;
2957: sizeOfType@var973 .@expr6580 insert (@expr1073748467 std ::@expr6582 make_pair (@expr1073748469 "short int *" , sizeOfType@var973 [@expr1073748470 "short *" ] ) ) ;
2958: sizeOfType@var973 .@expr6580 insert (@expr1073748472 std ::@expr6582 make_pair (@expr1073748474 "int *" , sizeof (@expr6599 int *@expr6635 ) ) ) ;
2959: sizeOfType@var973 .@expr6580 insert (@expr1073748478 std ::@expr6582 make_pair (@expr1073748480 "long *" , sizeof (@expr6604 long *@expr6635 ) ) ) ;
2960: sizeOfType@var973 .@expr6580 insert (@expr1073748484 std ::@expr6582 make_pair (@expr1073748486 "long int *" , sizeOfType@var973 [@expr1073748487 "long *" ] ) ) ;
2961: sizeOfType@var973 .@expr6580 insert (@expr1073748489 std ::@expr6582 make_pair (@expr1073748491 "long long *" , sizeof (@expr6614 long long *@expr6635 ) ) ) ;
2962: sizeOfType@var973 .@expr6580 insert (@expr1073748495 std ::@expr6582 make_pair (@expr1073748497 "float *" , sizeof (@expr6619 float *@expr6635 ) ) ) ;
2963: sizeOfType@var973 .@expr6580 insert (@expr1073748501 std ::@expr6582 make_pair (@expr1073748503 "double *" , sizeof (@expr6624 double *@expr6635 ) ) ) ;
2964: sizeOfType@var973 .@expr6580 insert (@expr1073748507 std ::@expr6582 make_pair (@expr1073748509 "long double *" , sizeof (@expr6629 long double *@expr6635 ) ) ) ;
2965:
2966: const bool hasInclude@var975 =@expr1073748512 dui@var969 .@expr6689 std@var976 .@expr1073748514 size (@expr1073748515 ) ==@expr1073748516 5 &&@expr1073748517 dui@var969 .@expr6689 std@var976 .@expr1073748519 compare (@expr1073748520 0 , 3 , "c++" ) ==@expr1073748521 0 &&@expr1073748522 dui@var969 .@expr6689 std@var976 >=@expr1073748524 "c++17" ;
2967: std ::@expr1073748525 unordered_map < std ::@expr6577 string , Macro > macros@var977 ;
2968: for (@expr1073748527 std ::@expr6577 list < std ::@expr6577 string > ::@expr6577 const_iterator it@var978 =@expr1073748531 dui@var969 .@expr6708 defines@var979 .@expr1073748533 begin (@expr1073748534 ) ; it@var978 !=@expr1073748535 dui@var969 .@expr6708 defines@var979 .@expr1073748537 end (@expr1073748538 ) ; ++@expr1073748539 it@var978 ) {
2969: const std ::@expr6577 string &@expr6717 macrostr@var980 =@expr1073748542 *@expr1073748543 it@var978 ;
2970: const std ::@expr6577 string ::@expr6577 size_type eq@var981 =@expr1073748546 macrostr@var980 .@expr6723 find (@expr1073748548 '=' ) ;
2971: const std ::@expr6577 string ::@expr6577 size_type par@var982 =@expr1073748551 macrostr@var980 .@expr6723 find (@expr1073748553 '(' ) ;
2972: const std ::@expr6577 string macroname@var983 =@expr1073748555 macrostr@var980 .@expr6732 substr (@expr1073748557 0 , std ::@expr1073748558 min (@expr1073748559 eq@var981 , par@var982 ) ) ;
2973: if (@expr1073748560 dui@var969 .@expr6737 undefined@var984 .@expr6738 find (@expr1073748563 macroname@var983 ) !=@expr1073748564 dui@var969 .@expr6737 undefined@var984 .@expr6742 end (@expr6743 ) ) {
2974: continue ; }
2975: const std ::@expr1073748568 string lhs@var985 (@expr1073748569 macrostr@var980 .@expr6732 substr (@expr1073748571 0 , eq@var981 ) ) ;
2976: const std ::@expr1073748572 string rhs@var986 (@expr1073748573 eq@var981 ==@expr1073748574 std ::@expr6751 string ::@expr1073748576 npos@expr1073748389 ?@expr1073748577 std ::@expr6751 string (@expr1073748579 "1" ) :@expr1073748580 macrostr@var980 .@expr6732 substr (@expr1073748582 eq@var981 +@expr1073748583 1 ) ) ;
2977: const Macro macro@var987 (@expr1073748584 lhs@var985 , rhs@var986 , files@var967 ) ;
2978: macros@var977 .@expr6761 insert (@expr1073748586 std ::@expr6763 pair < std ::@expr6577 string , Macro > (@expr1073748589 macro@var987 .@expr1073748590 name (@expr1073748591 ) , macro@var987 ) ) ;
2979: }
2980:
2981: macros@var977 .@expr6761 insert (@expr1073748593 std ::@expr6582 make_pair (@expr1073748595 "__FILE__" , Macro (@expr1073748596 "__FILE__" , "__FILE__" , files@var967 ) ) ) ;
2982: macros@var977 .@expr6761 insert (@expr1073748598 std ::@expr6582 make_pair (@expr1073748600 "__LINE__" , Macro (@expr1073748601 "__LINE__" , "__LINE__" , files@var967 ) ) ) ;
2983: macros@var977 .@expr6761 insert (@expr1073748603 std ::@expr6582 make_pair (@expr1073748605 "__COUNTER__" , Macro (@expr1073748606 "__COUNTER__" , "__COUNTER__" , files@var967 ) ) ) ;
2984: struct tm ltime@var988 ; ltime@var988 =@expr1073748607 { } ;
2985: getLocaltime (@expr1073748608 ltime@var988 ) ;
2986: macros@var977 .@expr6761 insert (@expr1073748610 std ::@expr6582 make_pair (@expr1073748612 "__DATE__" , Macro (@expr1073748613 "__DATE__" , getDateDefine (@expr1073748614 &@expr6791 ltime@var988 ) , files@var967 ) ) ) ;
2987: macros@var977 .@expr6761 insert (@expr1073748617 std ::@expr6582 make_pair (@expr1073748619 "__TIME__" , Macro (@expr1073748620 "__TIME__" , getTimeDefine (@expr1073748621 &@expr6791 ltime@var988 ) , files@var967 ) ) ) ;
2988:
2989: if (@expr1073748623 !@expr1073748624 dui@var969 .@expr6689 std@var976 .@expr1073748626 empty (@expr1073748627 ) ) {
2990: std ::@expr1073748628 string std_def@var989 ; std_def@var989 =@expr1073748629 simplecpp ::@expr1073748630 getCStdString (@expr1073748631 dui@var969 .@expr6689 std@var976 ) ;
2991: if (@expr6809 !@expr6810 std_def@var989 .@expr6811 empty (@expr6812 ) ) {
2992: macros@var977 .@expr6761 insert (@expr1073748638 std ::@expr6582 make_pair (@expr1073748640 "__STDC_VERSION__" , Macro (@expr1073748641 "__STDC_VERSION__" , std_def@var989 , files@var967 ) ) ) ;
2993: } else {
2994: std_def@var989 =@expr1073748642 simplecpp ::@expr1073748643 getCppStdString (@expr1073748644 dui@var969 .@expr6689 std@var976 ) ;
2995: if (@expr6809 !@expr6810 std_def@var989 .@expr6811 empty (@expr6812 ) ) {
2996: macros@var977 .@expr6761 insert (@expr1073748651 std ::@expr6582 make_pair (@expr1073748653 "__cplusplus" , Macro (@expr1073748654 "__cplusplus" , std_def@var989 , files@var967 ) ) ) ; }
2997: }
2998: }
2999:
|
3002:
3003: enum IfState { TRUE , ELSE_IS_TRUE , ALWAYS_FALSE } ;
3004: std ::@expr1073748655 stack < int > ifstates@var990 ;
3005: ifstates@var990 .@expr6832 push (@expr1073748657 TRUE ) ;
3006:
3007: std ::@expr1073748658 stack < const Token *@expr6635 > includetokenstack@var991 ;
3008:
3009: std ::@expr1073748660 set < std ::@expr6577 string > pragmaOnce@var992 ;
3010:
3011: includetokenstack@var991 .@expr6838 push (@expr1073748663 rawtokens@var966 .@expr1073748664 cfront (@expr1073748665 ) ) ;
3012: for (@expr1073748666 std ::@expr6577 list < std ::@expr6577 string > ::@expr6577 const_iterator it@var993 =@expr1073748670 dui@var969 .@expr6847 includes@var994 .@expr1073748672 begin (@expr1073748673 ) ; it@var993 !=@expr1073748674 dui@var969 .@expr6847 includes@var994 .@expr1073748676 end (@expr1073748677 ) ; ++@expr1073748678 it@var993 ) {
3013: const std ::@expr1073748679 map < std ::@expr6577 string , TokenList *@expr6635 > ::@expr1073748682 const_iterator f@var995 =@expr1073748683 filedata@var968 .@expr6860 find (@expr1073748685 *@expr1073748686 it@var993 ) ;
3014: if (@expr1073748687 f@var995 !=@expr1073748688 filedata@var968 .@expr1073748689 end (@expr1073748690 ) ) {
3015: includetokenstack@var991 .@expr6838 push (@expr1073748692 f@var995 .@expr1073748693 second@var996 .@expr1073748694 cfront (@expr1073748695 ) ) ; }
3016: }
3017:
3018: std ::@expr1073748696 map < std ::@expr6577 string , std ::@expr6577 list < Location > > maybeUsedMacros@var997 ;
3019:
3020: for (@expr1073748699 const Token *@expr6635 rawtok@var998 =@expr1073748701 nullptr ; rawtok@var998 ||@expr1073748702 !@expr1073748703 includetokenstack@var991 .@expr1073748704 empty (@expr1073748705 ) ; ) {
3021: if (@expr1073748706 rawtok@var998 ==@expr1073748707 nullptr ) {
3022: rawtok@var998 =@expr1073748708 includetokenstack@var991 .@expr1073748709 top (@expr1073748710 ) ;
3023: includetokenstack@var991 .@expr1073748711 pop (@expr1073748712 ) ;
3024: continue ;
3025: }
3026:
3027: if (@expr1073748713 rawtok@var998 .@expr6890 op@var999 ==@expr6891 '#' &&@expr1073748716 !@expr1073748717 sameline (@expr1073748718 rawtok@var998 .@expr6895 previous@var1000 , rawtok@var998 ) ) {
3028: if (@expr6896 !@expr6897 sameline (@expr6898 rawtok@var998 , rawtok@var998 .@expr6899 next@var1001 ) ) {
3029: rawtok@var998 =@expr1073748724 rawtok@var998 .@expr6899 next@var1001 ;
3030: continue ;
3031: }
3032: rawtok@var998 =@expr1073748726 rawtok@var998 .@expr6899 next@var1001 ;
3033: if (@expr1073748728 !@expr1073748729 rawtok@var998 .@expr1073748730 name@var1002 ) {
3034: rawtok@var998 =@expr1073748731 gotoNextLine (@expr6908 rawtok@var998 ) ;
3035: continue ;
3036: }
3037:
3038: if (@expr1073748733 ifstates@var990 .@expr1073748734 size (@expr1073748735 ) <=@expr1073748736 1U &&@expr1073748737 (@expr1073748738 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6917 ELIF@var162 ||@expr1073748742 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6921 ELSE@var161 ||@expr1073748746 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6925 ENDIF@var163 ) ) {
3039: if (@expr6926 outputList@var970 ) {
3040: simplecpp ::@expr1073748751 Output err@var1003 (@expr1073748752 files@var967 ) ;
3041: err@var1003 .@expr1073748753 type@var1004 =@expr1073748754 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3042: err@var1003 .@expr1073748756 location@var1005 =@expr1073748757 rawtok@var998 .@expr6934 location@var1006 ;
3043: err@var1003 .@expr1073748759 msg@var1007 =@expr1073748760 "#" +@expr1073748761 rawtok@var998 .@expr6915 str (@expr6916 ) +@expr1073748764 " without #if" ;
3044: outputList@var970 .@expr6941 push_back (@expr1073748766 err@var1003 ) ;
3045: }
3046: output@var965 .@expr6943 clear (@expr6944 ) ;
3047: return ;
3048: }
3049:
3050: if (@expr1073748769 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr6948 TRUE &&@expr1073748773 (@expr1073748774 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6953 ERROR@var155 ||@expr1073748778 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr1073748781 WARNING@var156 ) ) {
3051: if (@expr6926 outputList@var970 ) {
3052: simplecpp ::@expr1073748783 Output err@var1008 (@expr1073748784 rawtok@var998 .@expr6934 location@var1006 .@expr6962 files@var1009 ) ;
3053: err@var1008 .@expr1073748787 type@var1010 =@expr1073748788 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6953 ERROR@var155 ?@expr1073748792 Output ::@expr1073748793 ERROR :@expr1073748794 Output ::@expr1073748795 WARNING@expr1073748391 ;
3054: err@var1008 .@expr1073748796 location@var1011 =@expr1073748797 rawtok@var998 .@expr6934 location@var1006 ;
3055: for (@expr1073748799 const Token *@expr6635 tok@var1012 =@expr1073748801 rawtok@var998 .@expr6899 next@var1001 ; tok@var1012 &&@expr1073748803 sameline (@expr1073748804 rawtok@var998 , tok@var1012 ) ; tok@var1012 =@expr1073748805 tok@var1012 .@expr1073748806 next@var1013 ) {
3056: if (@expr1073748807 !@expr1073748808 err@var1008 .@expr6985 msg@var1014 .@expr1073748810 empty (@expr1073748811 ) &&@expr1073748812 isNameChar (@expr1073748813 tok@var1012 .@expr6990 str (@expr6991 ) [@expr1073748816 0 ] ) ) {
3057: err@var1008 .@expr6985 msg@var1014 +=@expr1073748818 ' ' ; }
3058: err@var1008 .@expr6985 msg@var1014 +=@expr1073748820 tok@var1012 .@expr6990 str (@expr6991 ) ;
3059: }
3060: err@var1008 .@expr6985 msg@var1014 =@expr1073748824 '#' +@expr1073748825 rawtok@var998 .@expr6915 str (@expr6916 ) +@expr1073748828 ' ' +@expr1073748829 err@var1008 .@expr6985 msg@var1014 ;
3061: outputList@var970 .@expr6941 push_back (@expr1073748832 err@var1008 ) ;
3062: }
3063: if (@expr1073748833 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6953 ERROR@var155 ) {
3064: output@var965 .@expr6943 clear (@expr6944 ) ;
3065: return ;
3066: }
3067: }
3068:
3069: if (@expr1073748839 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr1073748842 DEFINE@var152 ) {
3070: if (@expr7019 ifstates@var990 .@expr6946 top (@expr6947 ) !=@expr7022 TRUE ) {
3071: continue ; }
3072: try {
3073: const Macro &@expr6717 macro@var1015 =@expr1073748848 Macro (@expr1073748849 rawtok@var998 .@expr6895 previous@var1000 , files@var967 ) ;
3074: if (@expr1073748851 dui@var969 .@expr6737 undefined@var984 .@expr6738 find (@expr1073748854 macro@var1015 .@expr7031 name (@expr7032 ) ) ==@expr1073748857 dui@var969 .@expr6737 undefined@var984 .@expr6742 end (@expr6743 ) ) {
3075: MacroMap ::@expr1073748861 iterator it@var1016 ; it@var1016 =@expr1073748862 macros@var977 .@expr7039 find (@expr1073748864 macro@var1015 .@expr7031 name (@expr7032 ) ) ;
3076: if (@expr1073748867 it@var1016 ==@expr1073748868 macros@var977 .@expr7045 end (@expr7046 ) ) {
3077: macros@var977 .@expr6761 insert (@expr1073748872 std ::@expr6763 pair < std ::@expr6577 string , Macro > (@expr1073748875 macro@var1015 .@expr7031 name (@expr7032 ) , macro@var1015 ) ) ; }
3078: else {
3079: it@var1016 .@expr1073748878 second@var1017 =@expr1073748879 macro@var1015 ; }
3080: }
3081: } catch (@expr1073748880 const std ::@expr1073748881 runtime_error &@expr6717 ) {
3082: if (@expr6926 outputList@var970 ) {
3083: simplecpp ::@expr1073748884 Output err@var1018 (@expr1073748885 files@var967 ) ;
3084: err@var1018 .@expr1073748886 type@var1019 =@expr1073748887 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3085: err@var1018 .@expr1073748889 location@var1020 =@expr1073748890 rawtok@var998 .@expr6934 location@var1006 ;
3086: err@var1018 .@expr1073748892 msg@var1021 =@expr1073748893 "Failed to parse #define" ;
3087: outputList@var970 .@expr6941 push_back (@expr1073748895 err@var1018 ) ;
3088: }
3089: output@var965 .@expr6943 clear (@expr6944 ) ;
3090: return ;
3091: }
3092: } else { if (@expr1073748898 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr6948 TRUE &&@expr1073748902 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr1073748905 INCLUDE@var154 ) {
3093: TokenList inc1@var1022 (@expr1073748906 files@var967 ) ;
3094: for (@expr1073748907 const Token *@expr6635 inctok@var1023 =@expr1073748909 rawtok@var998 .@expr6899 next@var1001 ; sameline (@expr1073748911 rawtok@var998 , inctok@var1023 ) ; inctok@var1023 =@expr1073748912 inctok@var1023 .@expr1073748913 next@var1024 ) {
3095: if (@expr1073748914 !@expr1073748915 inctok@var1023 .@expr1073748916 comment@var1025 ) {
3096: inc1@var1022 .@expr1073748917 push_back (@expr1073748918 new Token (@expr1073748919 *@expr1073748920 inctok@var1023 ) ) ; }
3097: }
3098: TokenList inc2@var1026 (@expr1073748921 files@var967 ) ;
3099: if (@expr1073748922 !@expr1073748923 inc1@var1022 .@expr1073748924 empty (@expr1073748925 ) &&@expr1073748926 inc1@var1022 .@expr7103 cfront (@expr7104 ) .@expr1073748929 name@expr1073748392 ) {
3100: const Token * inctok@var1027 ; inctok@var1027 =@expr1073748930 inc1@var1022 .@expr7103 cfront (@expr7104 ) ;
3101: if (@expr1073748933 !@expr1073748934 preprocessToken (@expr1073748935 inc2@var1026 , &@expr1073748936 inctok@var1027 , macros@var977 , files@var967 , outputList@var970 ) ) {
3102: output@var965 .@expr6943 clear (@expr6944 ) ;
3103: return ;
3104: }
3105: } else {
3106: inc2@var1026 .@expr1073748939 takeTokens (@expr1073748940 inc1@var1022 ) ;
3107: }
3108:
3109: if (@expr1073748941 !@expr1073748942 inc2@var1026 .@expr7119 empty (@expr7120 ) &&@expr1073748945 inc2@var1026 .@expr7122 cfront (@expr7123 ) .@expr1073748948 op@expr1073748393 ==@expr1073748949 '<' &&@expr1073748950 inc2@var1026 .@expr1073748951 cback (@expr1073748952 ) .@expr1073748953 op@expr1073748394 ==@expr1073748954 '>' ) {
3110: std ::@expr1073748955 string hdr@var1028 ;
3111:
3112:
3113: for (@expr1073748956 const Token *@expr6635 tok@var1029 =@expr1073748958 inc2@var1026 .@expr7122 cfront (@expr7123 ) ; tok@var1029 ; tok@var1029 =@expr1073748961 tok@var1029 .@expr1073748962 next@var1030 ) {
3114: hdr@var1028 +=@expr1073748963 tok@var1029 .@expr1073748964 str (@expr1073748965 ) ;
3115: }
3116: inc2@var1026 .@expr1073748966 clear (@expr1073748967 ) ;
3117: inc2@var1026 .@expr1073748968 push_back (@expr1073748969 new Token (@expr1073748970 hdr@var1028 , inc1@var1022 .@expr7103 cfront (@expr7104 ) .@expr1073748973 location@expr1073748395 ) ) ;
3118: inc2@var1026 .@expr1073748974 front (@expr1073748975 ) .@expr1073748976 op@expr1073748396 =@expr1073748977 '<' ;
3119: }
3120:
3121: if (@expr1073748978 inc2@var1026 .@expr7119 empty (@expr7120 ) ||@expr1073748981 inc2@var1026 .@expr7122 cfront (@expr7123 ) .@expr1073748984 str (@expr1073748985 ) .@expr1073748986 size (@expr1073748987 ) <=@expr1073748988 2U ) {
3122: if (@expr6926 outputList@var970 ) {
3123: simplecpp ::@expr1073748990 Output err@var1031 (@expr1073748991 files@var967 ) ;
3124: err@var1031 .@expr1073748992 type@var1032 =@expr1073748993 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3125: err@var1031 .@expr1073748995 location@var1033 =@expr1073748996 rawtok@var998 .@expr6934 location@var1006 ;
3126: err@var1031 .@expr1073748998 msg@var1034 =@expr1073748999 "No header in #include" ;
3127: outputList@var970 .@expr6941 push_back (@expr1073749001 err@var1031 ) ;
3128: }
3129: output@var965 .@expr6943 clear (@expr6944 ) ;
3130: return ;
3131: }
3132:
3133: const Token * inctok@var1035 ; inctok@var1035 =@expr1073749004 inc2@var1026 .@expr7122 cfront (@expr7123 ) ;
3134:
3135: const bool systemheader@var1036 =@expr1073749007 inctok@var1035 .@expr1073749008 op@var1037 ==@expr1073749009 '<' ;
3136: const std ::@expr1073749010 string header@var1038 (@expr1073749011 inctok@var1035 .@expr7188 str (@expr7189 ) .@expr1073749014 substr (@expr1073749015 1U , inctok@var1035 .@expr7188 str (@expr7189 ) .@expr1073749018 size (@expr1073749019 ) -@expr1073749020 2U ) ) ;
3137: std ::@expr1073749021 string header2@var1039 ; header2@var1039 =@expr1073749022 getFileName (@expr1073749023 filedata@var968 , rawtok@var998 .@expr6934 location@var1006 .@expr7201 file (@expr7202 ) , header@var1038 , dui@var969 , systemheader@var1036 ) ;
3138: if (@expr7203 header2@var1039 .@expr7204 empty (@expr7205 ) ) {
3139:
3140: std ::@expr1073749030 ifstream f@var1040 ;
3141: header2@var1039 =@expr1073749031 openHeader (@expr1073749032 f@var1040 , dui@var969 , rawtok@var998 .@expr6934 location@var1006 .@expr7201 file (@expr7202 ) , header@var1038 , systemheader@var1036 ) ;
3142: if (@expr1073749036 f@var1040 .@expr1073749037 is_open (@expr1073749038 ) ) {
3143: TokenList * tokens@var1041 ; tokens@var1041 =@expr1073749039 new TokenList (@expr1073749040 f@var1040 , files@var967 , header2@var1039 , outputList@var970 ) ;
3144: filedata@var968 [@expr1073749041 header2@var1039 ] =@expr1073749042 tokens@var1041 ;
3145: }
3146: }
3147: if (@expr7203 header2@var1039 .@expr7204 empty (@expr7205 ) ) {
3148: if (@expr6926 outputList@var970 ) {
3149: simplecpp ::@expr1073749047 Output out@var1042 (@expr1073749048 files@var967 ) ;
3150: out@var1042 .@expr1073749049 type@var1043 =@expr1073749050 Output ::@expr1073749051 MISSING_HEADER@expr1073748397 ;
3151: out@var1042 .@expr1073749052 location@var1044 =@expr1073749053 rawtok@var998 .@expr6934 location@var1006 ;
3152: out@var1042 .@expr1073749055 msg@var1045 =@expr1073749056 "Header not found: " +@expr1073749057 inctok@var1035 .@expr7188 str (@expr7189 ) ;
3153: outputList@var970 .@expr6941 push_back (@expr1073749061 out@var1042 ) ;
3154: }
3155: } else { if (@expr1073749062 includetokenstack@var991 .@expr1073749063 size (@expr1073749064 ) >=@expr1073749065 400 ) {
3156: if (@expr6926 outputList@var970 ) {
3157: simplecpp ::@expr1073749067 Output out@var1046 (@expr1073749068 files@var967 ) ;
3158: out@var1046 .@expr1073749069 type@var1047 =@expr1073749070 Output ::@expr1073749071 INCLUDE_NESTED_TOO_DEEPLY@expr1073748398 ;
3159: out@var1046 .@expr1073749072 location@var1048 =@expr1073749073 rawtok@var998 .@expr6934 location@var1006 ;
3160: out@var1046 .@expr1073749075 msg@var1049 =@expr1073749076 "#include nested too deeply" ;
3161: outputList@var970 .@expr6941 push_back (@expr1073749078 out@var1046 ) ;
3162: }
3163: } else { if (@expr1073749079 pragmaOnce@var992 .@expr1073749080 find (@expr1073749081 header2@var1039 ) ==@expr1073749082 pragmaOnce@var992 .@expr1073749083 end (@expr1073749084 ) ) {
3164: includetokenstack@var991 .@expr6838 push (@expr1073749086 gotoNextLine (@expr6908 rawtok@var998 ) ) ;
3165: const TokenList * includetokens@var1050 ; includetokens@var1050 =@expr1073749088 filedata@var968 .@expr6860 find (@expr1073749090 header2@var1039 ) .@expr1073749091 second@expr1073748399 ;
3166: rawtok@var998 =@expr1073749092 includetokens@var1050 ?@expr1073749093 includetokens@var1050 .@expr1073749094 cfront (@expr1073749095 ) :@expr1073749096 nullptr ;
3167: continue ;
3168: } } }
3169: } else { if (@expr1073749097 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7276 IF@var157 ||@expr1073749101 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7280 IFDEF@var158 ||@expr1073749105 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7284 IFNDEF@var159 ||@expr1073749109 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6917 ELIF@var162 ) {
3170: if (@expr6896 !@expr6897 sameline (@expr6898 rawtok@var998 , rawtok@var998 .@expr6899 next@var1001 ) ) {
3171: if (@expr6926 outputList@var970 ) {
3172: simplecpp ::@expr1073749118 Output out@var1051 (@expr1073749119 files@var967 ) ;
3173: out@var1051 .@expr1073749120 type@var1052 =@expr1073749121 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3174: out@var1051 .@expr1073749123 location@var1053 =@expr1073749124 rawtok@var998 .@expr6934 location@var1006 ;
3175: out@var1051 .@expr1073749126 msg@var1054 =@expr1073749127 "Syntax error in #" +@expr1073749128 rawtok@var998 .@expr6915 str (@expr6916 ) ;
3176: outputList@var970 .@expr6941 push_back (@expr1073749132 out@var1051 ) ;
3177: }
3178: output@var965 .@expr6943 clear (@expr6944 ) ;
3179: return ;
3180: }
3181:
3182: bool conditionIsTrue@var1055 ;
3183: if (@expr1073749135 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr1073749138 ALWAYS_FALSE ||@expr1073749139 (@expr1073749140 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr7319 ELSE_IS_TRUE &&@expr1073749144 rawtok@var998 .@expr6915 str (@expr6916 ) !=@expr7323 ELIF@var162 ) ) {
3184: conditionIsTrue@var1055 =@expr1073749148 false ; }
3185: else { if (@expr1073749149 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7280 IFDEF@var158 ) {
3186: conditionIsTrue@var1055 =@expr1073749153 macros@var977 .@expr7039 find (@expr7331 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ) !=@expr1073749159 macros@var977 .@expr7045 end (@expr7046 ) ||@expr1073749162 (@expr1073749163 hasInclude@var975 &&@expr7340 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ==@expr7344 HAS_INCLUDE@var166 ) ;
3187: maybeUsedMacros@var997 [@expr7345 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ] .@expr7349 push_back (@expr7350 rawtok@var998 .@expr6899 next@var1001 .@expr7352 location@var1056 ) ;
3188: } else { if (@expr1073749177 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7284 IFNDEF@var159 ) {
3189: conditionIsTrue@var1055 =@expr1073749181 macros@var977 .@expr7039 find (@expr7331 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ) ==@expr1073749187 macros@var977 .@expr7045 end (@expr7046 ) &&@expr1073749190 !@expr1073749191 (@expr1073749192 hasInclude@var975 &&@expr7340 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ==@expr7344 HAS_INCLUDE@var166 ) ;
3190: maybeUsedMacros@var997 [@expr7345 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ] .@expr7349 push_back (@expr7350 rawtok@var998 .@expr6899 next@var1001 .@expr7352 location@var1056 ) ;
3191: } else {
3192: TokenList expr@var1057 (@expr1073749206 files@var967 ) ;
3193: for (@expr1073749207 const Token *@expr6635 tok@var1058 =@expr1073749209 rawtok@var998 .@expr6899 next@var1001 ; tok@var1058 &&@expr1073749211 tok@var1058 .@expr7388 location@var1059 .@expr1073749213 sameline (@expr1073749214 rawtok@var998 .@expr6934 location@var1006 ) ; tok@var1058 =@expr1073749216 tok@var1058 .@expr7393 next@var1060 ) {
3194: if (@expr1073749218 !@expr1073749219 tok@var1058 .@expr1073749220 name@var1061 ) {
3195: expr@var1057 .@expr7397 push_back (@expr1073749222 new Token (@expr1073749223 *@expr1073749224 tok@var1058 ) ) ;
3196: continue ;
3197: }
3198:
3199: if (@expr1073749225 tok@var1058 .@expr7402 str (@expr7403 ) ==@expr1073749228 DEFINED@var160 ) {
3200: tok@var1058 =@expr1073749229 tok@var1058 .@expr7393 next@var1060 ;
3201: const bool par@var1062 =@expr1073749231 tok@var1058 &&@expr7408 tok@var1058 .@expr7409 op@var1063 ==@expr7410 '(' ;
3202: if (@expr7411 par@var1062 ) {
3203: tok@var1058 =@expr1073749236 tok@var1058 .@expr7393 next@var1060 ; }
3204: maybeUsedMacros@var997 [@expr7345 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ] .@expr7349 push_back (@expr7350 rawtok@var998 .@expr6899 next@var1001 .@expr7352 location@var1056 ) ;
3205: if (@expr7422 tok@var1058 ) {
3206: if (@expr1073749247 macros@var977 .@expr7039 find (@expr1073749249 tok@var1058 .@expr7402 str (@expr7403 ) ) !=@expr1073749252 macros@var977 .@expr7045 end (@expr7046 ) ) {
3207: expr@var1057 .@expr7397 push_back (@expr7432 new Token (@expr7433 "1" , tok@var1058 .@expr7388 location@var1059 ) ) ; }
3208: else { if (@expr7435 hasInclude@var975 &&@expr7436 tok@var1058 .@expr7402 str (@expr7403 ) ==@expr7439 HAS_INCLUDE@var166 ) {
3209: expr@var1057 .@expr7397 push_back (@expr7432 new Token (@expr7433 "1" , tok@var1058 .@expr7388 location@var1059 ) ) ; }
3210: else {
3211: expr@var1057 .@expr7397 push_back (@expr1073749269 new Token (@expr1073749270 "0" , tok@var1058 .@expr7388 location@var1059 ) ) ; } }
3212: }
3213: if (@expr7411 par@var1062 ) {
3214: tok@var1058 =@expr1073749273 tok@var1058 ?@expr7450 tok@var1058 .@expr7393 next@var1060 :@expr7452 nullptr ; }
3215: if (@expr1073749277 !@expr7454 tok@var1058 ||@expr7455 !@expr7456 sameline (@expr7457 rawtok@var998 , tok@var1058 ) ||@expr1073749282 (@expr1073749283 par@var1062 &&@expr1073749284 tok@var1058 .@expr7409 op@var1063 !=@expr7462 ')' ) ) {
3216: if (@expr6926 outputList@var970 ) {
3217: Output out@var1064 (@expr1073749288 rawtok@var998 .@expr6934 location@var1006 .@expr6962 files@var1009 ) ;
3218: out@var1064 .@expr1073749291 type@var1065 =@expr1073749292 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3219: out@var1064 .@expr1073749294 location@var1066 =@expr1073749295 rawtok@var998 .@expr6934 location@var1006 ;
3220: out@var1064 .@expr1073749297 msg@var1067 =@expr1073749298 "failed to evaluate " +@expr7475 std ::@expr6751 string (@expr7477 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7276 IF@var157 ?@expr7481 "#if" :@expr7482 "#elif" ) +@expr7483 " condition" ;
3221: outputList@var970 .@expr6941 push_back (@expr1073749309 out@var1064 ) ;
3222: }
3223: output@var965 .@expr6943 clear (@expr6944 ) ;
3224: return ;
3225: }
3226: continue ;
3227: }
3228:
3229: if (@expr7435 hasInclude@var975 &&@expr7436 tok@var1058 .@expr7402 str (@expr7403 ) ==@expr7439 HAS_INCLUDE@var166 ) {
3230: tok@var1058 =@expr1073749317 tok@var1058 .@expr7393 next@var1060 ;
3231: const bool par@var1068 =@expr1073749319 tok@var1058 &&@expr7408 tok@var1058 .@expr7409 op@var1063 ==@expr7410 '(' ;
3232: if (@expr7499 par@var1068 ) {
3233: tok@var1058 =@expr1073749324 tok@var1058 .@expr7393 next@var1060 ; }
3234: if (@expr7422 tok@var1058 ) {
3235: const std ::@expr6577 string &@expr6717 sourcefile@var1069 =@expr1073749329 rawtok@var998 .@expr6934 location@var1006 .@expr7201 file (@expr7202 ) ;
3236: const bool systemheader@var1070 =@expr1073749333 tok@var1058 .@expr7402 str (@expr7403 ) [@expr1073749336 0 ] ==@expr1073749337 '<' ;
3237: const std ::@expr1073749338 string header@var1071 (@expr1073749339 tok@var1058 .@expr7402 str (@expr7403 ) .@expr1073749342 substr (@expr1073749343 1U , tok@var1058 .@expr7402 str (@expr7403 ) .@expr1073749346 size (@expr1073749347 ) -@expr1073749348 2U ) ) ;
3238: std ::@expr1073749349 ifstream f@var1072 ;
3239: const std ::@expr6577 string header2@var1073 =@expr1073749351 openHeader (@expr1073749352 f@var1072 , dui@var969 , sourcefile@var1069 , header@var1071 , systemheader@var1070 ) ;
3240: expr@var1057 .@expr7397 push_back (@expr1073749354 new Token (@expr1073749355 header2@var1073 .@expr1073749356 empty (@expr1073749357 ) ?@expr1073749358 "0" :@expr1073749359 "1" , tok@var1058 .@expr7388 location@var1059 ) ) ;
3241: }
3242: if (@expr7499 par@var1068 ) {
3243: tok@var1058 =@expr1073749362 tok@var1058 ?@expr7450 tok@var1058 .@expr7393 next@var1060 :@expr7452 nullptr ; }
3244: if (@expr1073749366 !@expr7454 tok@var1058 ||@expr7455 !@expr7456 sameline (@expr7457 rawtok@var998 , tok@var1058 ) ||@expr1073749371 (@expr1073749372 par@var1068 &&@expr1073749373 tok@var1058 .@expr7409 op@var1063 !=@expr7462 ')' ) ) {
3245: if (@expr6926 outputList@var970 ) {
3246: Output out@var1074 (@expr1073749377 rawtok@var998 .@expr6934 location@var1006 .@expr6962 files@var1009 ) ;
3247: out@var1074 .@expr1073749380 type@var1075 =@expr1073749381 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3248: out@var1074 .@expr1073749383 location@var1076 =@expr1073749384 rawtok@var998 .@expr6934 location@var1006 ;
3249: out@var1074 .@expr1073749386 msg@var1077 =@expr1073749387 "failed to evaluate " +@expr7475 std ::@expr6751 string (@expr7477 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7276 IF@var157 ?@expr7481 "#if" :@expr7482 "#elif" ) +@expr7483 " condition" ;
3250: outputList@var970 .@expr6941 push_back (@expr1073749398 out@var1074 ) ;
3251: }
3252: output@var965 .@expr6943 clear (@expr6944 ) ;
3253: return ;
3254: }
3255: continue ;
3256: }
3257:
3258: maybeUsedMacros@var997 [@expr7345 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ] .@expr7349 push_back (@expr7350 rawtok@var998 .@expr6899 next@var1001 .@expr7352 location@var1056 ) ;
3259:
3260: const Token * tmp@var1078 ; tmp@var1078 =@expr1073749409 tok@var1058 ;
3261: if (@expr1073749410 !@expr1073749411 preprocessToken (@expr1073749412 expr@var1057 , &@expr1073749413 tmp@var1078 , macros@var977 , files@var967 , outputList@var970 ) ) {
3262: output@var965 .@expr6943 clear (@expr6944 ) ;
3263: return ;
3264: }
3265: if (@expr1073749416 !@expr1073749417 tmp@var1078 ) {
3266: break ; }
3267: tok@var1058 =@expr1073749418 tmp@var1078 .@expr1073749419 previous@var1079 ;
3268: }
3269: try {
3270: if (@expr1073749420 ifCond@var972 ) {
3271: std ::@expr1073749421 string E@var1080 ;
3272: for (@expr1073749422 const simplecpp ::@expr6577 Token *@expr6635 tok@var1081 =@expr1073749425 expr@var1057 .@expr1073749426 cfront (@expr1073749427 ) ; tok@var1081 ; tok@var1081 =@expr1073749428 tok@var1081 .@expr1073749429 next@var1082 ) {
3273: E@var1080 +=@expr1073749430 (@expr1073749431 E@var1080 .@expr1073749432 empty (@expr1073749433 ) ?@expr1073749434 "" :@expr1073749435 " " ) +@expr1073749436 tok@var1081 .@expr1073749437 str (@expr1073749438 ) ; }
3274: const long long result@var1083 =@expr1073749439 evaluate (@expr7616 expr@var1057 , sizeOfType@var973 ) ;
3275: conditionIsTrue@var1055 =@expr1073749441 result@var1083 !=@expr1073749442 0 ;
3276: ifCond@var972 .@expr1073749443 push_back (@expr1073749444 IfCond (@expr1073749445 rawtok@var998 .@expr6934 location@var1006 , E@var1080 , result@var1083 ) ) ;
3277: } else {
3278: const long long result@var1084 =@expr1073749447 evaluate (@expr7616 expr@var1057 , sizeOfType@var973 ) ;
3279: conditionIsTrue@var1055 =@expr1073749449 result@var1084 !=@expr1073749450 0 ;
3280: }
3281: } catch (@expr1073749451 const std ::@expr1073749452 exception & e@var1085 ) {
3282: if (@expr6926 outputList@var970 ) {
3283: Output out@var1086 (@expr1073749454 rawtok@var998 .@expr6934 location@var1006 .@expr6962 files@var1009 ) ;
3284: out@var1086 .@expr1073749457 type@var1087 =@expr1073749458 Output ::@expr6931 SYNTAX_ERROR@expr6566 ;
3285: out@var1086 .@expr1073749460 location@var1088 =@expr1073749461 rawtok@var998 .@expr6934 location@var1006 ;
3286: out@var1086 .@expr7639 msg@var1089 =@expr1073749464 "failed to evaluate " +@expr7475 std ::@expr6751 string (@expr7477 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr7276 IF@var157 ?@expr7481 "#if" :@expr7482 "#elif" ) +@expr7483 " condition" ;
3287: if (@expr1073749474 e@var1085 .@expr7651 what (@expr7652 ) &&@expr1073749477 *@expr1073749478 e@var1085 .@expr7651 what (@expr7652 ) ) {
3288: out@var1086 .@expr7639 msg@var1089 +=@expr1073749482 std ::@expr6751 string (@expr1073749484 ", " ) +@expr1073749485 e@var1085 .@expr7651 what (@expr7652 ) ; }
3289: outputList@var970 .@expr6941 push_back (@expr1073749489 out@var1086 ) ;
3290: }
3291: output@var965 .@expr6943 clear (@expr6944 ) ;
3292: return ;
3293: }
3294: } } }
3295:
3296: if (@expr1073749492 rawtok@var998 .@expr6915 str (@expr6916 ) !=@expr7323 ELIF@var162 ) {
3297:
3298: if (@expr7019 ifstates@var990 .@expr6946 top (@expr6947 ) !=@expr7022 TRUE ) {
3299: ifstates@var990 .@expr6832 push (@expr1073749501 ALWAYS_FALSE ) ; }
3300: else {
3301: ifstates@var990 .@expr6832 push (@expr1073749503 conditionIsTrue@var1055 ?@expr1073749504 TRUE :@expr1073749505 ELSE_IS_TRUE ) ; }
3302: } else { if (@expr7682 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr6948 TRUE ) {
3303: ifstates@var990 .@expr6946 top (@expr6947 ) =@expr1073749512 ALWAYS_FALSE ;
3304: } else { if (@expr1073749513 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr7319 ELSE_IS_TRUE &&@expr1073749517 conditionIsTrue@var1055 ) {
3305: ifstates@var990 .@expr6946 top (@expr6947 ) =@expr1073749520 TRUE ;
3306: } } }
3307: } else { if (@expr1073749521 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6921 ELSE@var161 ) {
3308: ifstates@var990 .@expr6946 top (@expr6947 ) =@expr1073749527 (@expr1073749528 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr7319 ELSE_IS_TRUE ) ?@expr1073749532 TRUE :@expr1073749533 ALWAYS_FALSE ;
3309: } else { if (@expr1073749534 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr6925 ENDIF@var163 ) {
3310: ifstates@var990 .@expr1073749538 pop (@expr1073749539 ) ;
3311: } else { if (@expr1073749540 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr1073749543 UNDEF@var153 ) {
3312: if (@expr7682 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr6948 TRUE ) {
3313: const Token * tok@var1090 ; tok@var1090 =@expr1073749548 rawtok@var998 .@expr6899 next@var1001 ;
3314: while (@expr1073749550 sameline (@expr7727 rawtok@var998 , tok@var1090 ) &&@expr1073749552 tok@var1090 .@expr1073749553 comment@var1091 ) {
3315: tok@var1090 =@expr1073749554 tok@var1090 .@expr1073749555 next@var1092 ; }
3316: if (@expr1073749556 sameline (@expr7727 rawtok@var998 , tok@var1090 ) ) {
3317: macros@var977 .@expr1073749558 erase (@expr1073749559 tok@var1090 .@expr1073749560 str (@expr1073749561 ) ) ; }
3318: }
3319: } else { if (@expr1073749562 ifstates@var990 .@expr6946 top (@expr6947 ) ==@expr6948 TRUE &&@expr1073749566 rawtok@var998 .@expr6915 str (@expr6916 ) ==@expr1073749569 PRAGMA@var164 &&@expr1073749570 rawtok@var998 .@expr6899 next@var1001 &&@expr1073749572 rawtok@var998 .@expr6899 next@var1001 .@expr7333 str (@expr7334 ) ==@expr1073749576 ONCE@var165 &&@expr1073749577 sameline (@expr6898 rawtok@var998 , rawtok@var998 .@expr6899 next@var1001 ) ) {
3320: pragmaOnce@var992 .@expr1073749580 insert (@expr1073749581 rawtok@var998 .@expr6934 location@var1006 .@expr7201 file (@expr7202 ) ) ;
3321: } } } } } } }
3322: rawtok@var998 =@expr1073749585 gotoNextLine (@expr6908 rawtok@var998 ) ;
3323: continue ;
3324: }
3325:
3326: if (@expr7019 ifstates@var990 .@expr6946 top (@expr6947 ) !=@expr7022 TRUE ) {
3327:
3328: rawtok@var998 =@expr1073749591 gotoNextLine (@expr6908 rawtok@var998 ) ;
3329: continue ;
3330: }
3331:
3332: bool hash@var1093 ; hash@var1093 =@expr1073749593 false ; bool hashhash@var1094 ; hashhash@var1094 =@expr1073749594 false ;
3333: if (@expr1073749595 rawtok@var998 .@expr6890 op@var999 ==@expr6891 '#' &&@expr1073749598 sameline (@expr6898 rawtok@var998 , rawtok@var998 .@expr6899 next@var1001 ) ) {
3334: if (@expr1073749601 rawtok@var998 .@expr6899 next@var1001 .@expr1073749603 op@var1095 !=@expr1073749604 '#' ) {
3335: hash@var1093 =@expr1073749605 true ;
3336: rawtok@var998 =@expr1073749606 rawtok@var998 .@expr6899 next@var1001 ;
3337: } else { if (@expr1073749608 sameline (@expr1073749609 rawtok@var998 , rawtok@var998 .@expr6899 next@var1001 .@expr7787 next@var1096 ) ) {
3338: hashhash@var1094 =@expr1073749612 true ;
3339: rawtok@var998 =@expr1073749613 rawtok@var998 .@expr6899 next@var1001 .@expr7787 next@var1096 ;
3340: } }
3341: }
3342:
3343: const Location loc@var1097 (@expr1073749616 rawtok@var998 .@expr6934 location@var1006 ) ;
3344: TokenList tokens@var1098 (@expr1073749618 files@var967 ) ;
3345:
3346: if (@expr1073749619 !@expr1073749620 preprocessToken (@expr1073749621 tokens@var1098 , &@expr1073749622 rawtok@var998 , macros@var977 , files@var967 , outputList@var970 ) ) {
3347: output@var965 .@expr6943 clear (@expr6944 ) ;
3348: return ;
3349: }
3350:
3351: if (@expr1073749625 hash@var1093 ||@expr1073749626 hashhash@var1094 ) {
3352: std ::@expr1073749627 string s@var1099 ;
3353: for (@expr1073749628 const Token *@expr6635 hashtok@var1100 =@expr1073749630 tokens@var1098 .@expr1073749631 cfront (@expr1073749632 ) ; hashtok@var1100 ; hashtok@var1100 =@expr1073749633 hashtok@var1100 .@expr1073749634 next@var1101 ) {
3354: s@var1099 +=@expr1073749635 hashtok@var1100 .@expr1073749636 str (@expr1073749637 ) ; }
3355: if (@expr1073749638 hash@var1093 ) {
3356: output@var965 .@expr7815 push_back (@expr1073749640 new Token (@expr1073749641 '\"' +@expr1073749642 s@var1099 +@expr1073749643 '\"' , loc@var1097 ) ) ; }
3357: else { if (@expr1073749644 output@var965 .@expr7821 back (@expr7822 ) ) {
3358: output@var965 .@expr7821 back (@expr7822 ) .@expr1073749649 setstr (@expr1073749650 output@var965 .@expr1073749651 cback (@expr1073749652 ) .@expr1073749653 str (@expr1073749654 ) +@expr1073749655 s@var1099 ) ; }
3359: else {
3360: output@var965 .@expr7815 push_back (@expr1073749657 new Token (@expr1073749658 s@var1099 , loc@var1097 ) ) ; } }
3361: } else {
3362: output@var965 .@expr1073749659 takeTokens (@expr1073749660 tokens@var1098 ) ;
3363: }
3364: }
3365:
3366: if (@expr1073749661 macroUsage@var971 ) {
3367: for (@expr1073749662 std ::@expr6577 unordered_map < std ::@expr6577 string , Macro > ::@expr6577 const_iterator macroIt@var1102 =@expr1073749666 macros@var977 .@expr1073749667 begin (@expr1073749668 ) ; macroIt@var1102 !=@expr1073749669 macros@var977 .@expr7045 end (@expr7046 ) ; ++@expr1073749672 macroIt@var1102 ) {
3368: const Macro &@expr6717 macro@var1103 =@expr1073749674 macroIt@var1102 .@expr1073749675 second@var1104 ;
3369: std ::@expr1073749676 list < Location > usage@var1105 ; usage@var1105 =@expr1073749677 macro@var1103 .@expr1073749678 usage (@expr1073749679 ) ;
3370: const std ::@expr1073749680 list < Location > & temp@var1106 =@expr1073749681 maybeUsedMacros@var997 [@expr1073749682 macro@var1103 .@expr7859 name (@expr7860 ) ] ;
3371: usage@var1105 .@expr1073749685 insert (@expr1073749686 usage@var1105 .@expr7863 end (@expr7864 ) , temp@var1106 .@expr1073749689 begin (@expr1073749690 ) , temp@var1106 .@expr1073749691 end (@expr1073749692 ) ) ;
3372: for (@expr1073749693 std ::@expr6577 list < Location > ::@expr6577 const_iterator usageIt@var1107 =@expr1073749696 usage@var1105 .@expr1073749697 begin (@expr1073749698 ) ; usageIt@var1107 !=@expr1073749699 usage@var1105 .@expr7863 end (@expr7864 ) ; ++@expr1073749702 usageIt@var1107 ) {
3373: MacroUsage mu@var1108 (@expr1073749703 usageIt@var1107 .@expr1073749704 files@var1109 , macro@var1103 .@expr1073749705 valueDefinedInCode (@expr1073749706 ) ) ;
3374: mu@var1108 .@expr1073749707 macroName@var1110 =@expr1073749708 macro@var1103 .@expr7859 name (@expr7860 ) ;
3375: mu@var1108 .@expr1073749711 macroLocation@var1111 =@expr1073749712 macro@var1103 .@expr1073749713 defineLocation (@expr1073749714 ) ;
3376: mu@var1108 .@expr1073749715 useLocation@var1112 =@expr1073749716 *@expr1073749717 usageIt@var1107 ;
3377: macroUsage@var971 .@expr1073749718 push_back (@expr1073749719 mu@var1108 ) ;
3378: }
3379: }
3380: }
3381: }
3382:
3383: void simplecpp :: cleanup ( std :: map < std :: string , TokenList * > & filedata@var1113 )
3384: {
3385: for (@expr1073749720 std ::@expr7897 map < std ::@expr7897 string , TokenList *@expr1073749723 > ::@expr7897 iterator it@var1114 =@expr1073749725 filedata@var1113 .@expr1073749726 begin (@expr1073749727 ) ; it@var1114 !=@expr1073749728 filedata@var1113 .@expr1073749729 end (@expr1073749730 ) ; ++@expr1073749731 it@var1114 ) {
3386: delete it@var1114 .@expr1073749732 second@var1115 ; }
3387: filedata@var1113 .@expr1073749733 clear (@expr1073749734 ) ;
3388: }
3389:
3390: std :: string simplecpp :: getCStdString ( const std :: string & std@var1116 )
3391: {
3392: if (@expr1073749735 std@var1116 ==@expr1073749736 "c90" ||@expr1073749737 std@var1116 ==@expr1073749738 "c89" ||@expr1073749739 std@var1116 ==@expr1073749740 "iso9899:1990" ||@expr1073749741 std@var1116 ==@expr1073749742 "iso9899:199409" ||@expr1073749743 std@var1116 ==@expr1073749744 "gnu90" ||@expr1073749745 std@var1116 ==@expr1073749746 "gnu89" ) {
3393:
3394: return "" ;
3395: }
3396: if (@expr1073749747 std@var1116 ==@expr1073749748 "c99" ||@expr1073749749 std@var1116 ==@expr1073749750 "c9x" ||@expr1073749751 std@var1116 ==@expr1073749752 "iso9899:1999" ||@expr1073749753 std@var1116 ==@expr1073749754 "iso9899:199x" ||@expr1073749755 std@var1116 ==@expr1073749756 "gnu99" ||@expr1073749757 std@var1116 ==@expr1073749758 "gnu9x" ) {
3397: return "199901L" ; }
3398: if (@expr1073749759 std@var1116 ==@expr1073749760 "c11" ||@expr1073749761 std@var1116 ==@expr1073749762 "c1x" ||@expr1073749763 std@var1116 ==@expr1073749764 "iso9899:2011" ||@expr1073749765 std@var1116 ==@expr1073749766 "gnu11" ||@expr1073749767 std@var1116 ==@expr1073749768 "gnu1x" ) {
3399: return "201112L" ; }
3400: if (@expr1073749769 std@var1116 ==@expr1073749770 "c17" ||@expr1073749771 std@var1116 ==@expr1073749772 "c18" ||@expr1073749773 std@var1116 ==@expr1073749774 "iso9899:2017" ||@expr1073749775 std@var1116 ==@expr1073749776 "iso9899:2018" ||@expr1073749777 std@var1116 ==@expr1073749778 "gnu17" ||@expr1073749779 std@var1116 ==@expr1073749780 "gnu18" ) {
3401: return "201710L" ; }
3402: if (@expr1073749781 std@var1116 ==@expr1073749782 "c2x" ||@expr1073749783 std@var1116 ==@expr1073749784 "gnu2x" ) {
3403:
3404: return "202000L" ;
3405: }
3406: return "" ;
3407: }
3408:
3409: std :: string simplecpp :: getCppStdString ( const std :: string & std@var1117 )
3410: {
3411: if (@expr1073749785 std@var1117 ==@expr1073749786 "c++98" ||@expr1073749787 std@var1117 ==@expr1073749788 "c++03" ||@expr1073749789 std@var1117 ==@expr1073749790 "gnu++98" ||@expr1073749791 std@var1117 ==@expr1073749792 "gnu++03" ) {
3412: return "199711L" ; }
3413: if (@expr1073749793 std@var1117 ==@expr1073749794 "c++11" ||@expr1073749795 std@var1117 ==@expr1073749796 "gnu++11" ||@expr1073749797 std@var1117 ==@expr1073749798 "c++0x" ||@expr1073749799 std@var1117 ==@expr1073749800 "gnu++0x" ) {
3414: return "201103L" ; }
3415: if (@expr1073749801 std@var1117 ==@expr1073749802 "c++14" ||@expr1073749803 std@var1117 ==@expr1073749804 "c++1y" ||@expr1073749805 std@var1117 ==@expr1073749806 "gnu++14" ||@expr1073749807 std@var1117 ==@expr1073749808 "gnu++1y" ) {
3416: return "201402L" ; }
3417: if (@expr1073749809 std@var1117 ==@expr1073749810 "c++17" ||@expr1073749811 std@var1117 ==@expr1073749812 "c++1z" ||@expr1073749813 std@var1117 ==@expr1073749814 "gnu++17" ||@expr1073749815 std@var1117 ==@expr1073749816 "gnu++1z" ) {
3418: return "201703L" ; }
3419: if (@expr1073749817 std@var1117 ==@expr1073749818 "c++20" ||@expr1073749819 std@var1117 ==@expr1073749820 "c++2a" ||@expr1073749821 std@var1117 ==@expr1073749822 "gnu++20" ||@expr1073749823 std@var1117 ==@expr1073749824 "gnu++2a" ) {
3420:
3421: return "202002L" ;
3422: }
3423: if (@expr1073749825 std@var1117 ==@expr1073749826 "c++23" ||@expr1073749827 std@var1117 ==@expr1073749828 "c++2b" ||@expr1073749829 std@var1117 ==@expr1073749830 "gnu++23" ||@expr1073749831 std@var1117 ==@expr1073749832 "gnu++2b" ) {
3424:
3425:
3426: return "202100L" ;
3427: }
3428: return "" ;
3429: }



##Value flow
Line 58
  ( possible lifetime[SubObject]=(std::vector<std::string>&f)
  fileIndex always !<=-1
  0 always 0
  line always !<=-1
  1U always 1
  col always !<=-1
  0U always 0
Line 60
  fileIndex always !<=-1
  . always !<=-1
  fileIndex always !<=-1
  line always !<=-1
  . always !<=-1
  line always !<=-1
  col always !<=-1
  . always !<=-1
  col always !<=-1
Line 63
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 64
  fileIndex always !<=-1
  = always !<=-1
  . always !<=-1
  fileIndex always !<=-1
Line 65
  line always !<=-1
  = always !<=-1
  . always !<=-1
  line always !<=-1
Line 66
  col always !<=-1
  = always !<=-1
  . always !<=-1
  col always !<=-1
Line 68
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
Line 76
  return always {!<=-1,!>=2}
  fileIndex always {!<=-1,!symbolic=(rhs.fileIndex)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(fileIndex)}
  fileIndex always !<=-1
Line 77
  line always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 78
  return always {!<=-1,!>=2}
  line always {!<=-1,!symbolic=(rhs.line)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(line)}
  line always !<=-1
Line 79
  return always {!<=-1,!>=2}
  col always !<=-1
  < always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 82
  ( always {!<=-1,!>=2}
Line 83
  return always {!<=-1,!>=2}
  fileIndex always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  && always {!<=-1,!>=2}
  line always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 87
  fileIndex always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  fileIndex {!<=-1,<=symbolic=(files.size()-1),!>=symbolic=(files.size())}
Line 91
  fileIndex always !<=-1
Line 92
  line always !<=-1
Line 93
  col always !<=-1
Line 105
  nullptr always 0
  nullptr always 0
Line 110
  comment always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
Line 114
  name always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  0 always 0
  || always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '$' always 36
Line 115
  && always {!<=-1,!>=2}
  ( {lifetime[Object]=(string),!0}
  '\'' always 39
  ( always !<=-1
  == always {!<=-1,!>=2}
  nullptr always 0
Line 116
  comment always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  string {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
  && always {!<=-1,!>=2}
  string {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '/' always 47
  || always {!<=-1,!>=2}
  string always !<=size=1
  1 always 1
  == always {!<=-1,!>=2}
  '*' always 42
Line 117
  number always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !<=-1
  0 always 0
  || always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  string {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
  && always {!<=-1,!>=2}
  ( always !<=-1
  string {>=size=2,!<=size=1}
  1 always 1
Line 118
  ( always !<=-1
  == always {!<=-1,!>=2}
  1U always 1
  string possible size=1
  0 always 0
  : always 0
  '\0' always 0
Line 125
  = possible {"0"@59,"&&"@124,"||"@126,"!="@160}
  s possible {"0"@59,"&&"@124,"||"@126,"!="@160}
Line 129
  ( always {!<=-1,!>=2}
Line 130
  ( always {!<=-1,!>=2}
Line 131
  ( always {!<=-1,!>=2}
Line 135
  comment always {!<=-1,!>=2}
Line 136
  name always {!<=-1,!>=2}
Line 137
  number always {!<=-1,!>=2}
Line 143
  this always !0
Line 144
  tok possible symbolic=(this->previous)
  && always {!<=-1,!>=2}
  tok {symbolic=(this->previous),!0}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 145
  tok always !0
Line 146
  tok possible {symbolic=(this->previous),0}
Line 150
  this always !0
Line 151
  tok possible symbolic=(this->next)
  && always {!<=-1,!>=2}
  tok {symbolic=(this->next),!0}
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 152
  tok always !0
Line 153
  tok possible {symbolic=(this->next),0}
Line 158
  mExpandedFrom possible lifetime[Object]=(m)
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExpandedFrom)
  m possible lifetime[Address]=(macros)@143
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExpandedFrom),end=0}
Line 177
  ERROR always 0
Line 179
  ERROR always 0
Line 180
  WARNING always 1
Line 181
  MISSING_HEADER always 2
Line 182
  INCLUDE_NESTED_TOO_DEEPLY always 3
Line 183
  SYNTAX_ERROR always 4
Line 184
  PORTABILITY_BACKSLASH always 5
Line 185
  UNHANDLED_CHAR_ERROR always 6
Line 186
  EXPLICIT_INCLUDE_NOT_FOUND always 7
Line 198
  ( inconclusive {lifetime[SubObject]=(std::istream&istr),lifetime[SubObject]=(std::vector<std::string>&filenames)}
  = always 0
  nullptr always 0
Line 201
  && always {!<=-1,!>=2}
Line 206
  && always {!<=-1,!>=2}
Line 210
  ( always {!<=-1,!>=2}
Line 211
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 218
  , always 0
  = always 0
  nullptr always 0
Line 240
  ! {!<=-1,!>=2,1@11}
  tok possible {symbolic=(frontToken),symbolic=(backToken),symbolic=(tok->previous)@122,0@11}
Line 242
  tok {symbolic=(frontToken),symbolic=(backToken),!0}
Line 243
  tok {symbolic=(frontToken),symbolic=(backToken),!0}
Line 244
  prev always symbolic=(tok->previous)
Line 245
  prev {symbolic=(tok->previous),!0}
  = always symbolic=(tok->next)
  next always symbolic=(tok->next)
Line 246
  next always symbolic=(tok->next)
Line 247
  next {symbolic=(tok->next),!0}
  = always symbolic=(tok->previous)
  prev always symbolic=(tok->previous)
Line 248
  == always {!<=-1,!>=2}
  tok {symbolic=(backToken),!0}
Line 249
  = always symbolic=(tok->next)
  next always symbolic=(tok->next)
Line 250
  == always {!<=-1,!>=2}
  tok always !0
Line 251
  = always symbolic=(tok->previous)
  prev always symbolic=(tok->previous)
Line 252
  tok always !0
Line 256
  ! always {!<=-1,!>=2}
Line 258
  ! always {!<=-1,!>=2}
Line 259
  = always !0
  . always !0
Line 261
  = always !0
  . always !0
Line 262
  . always !0
Line 265
  = always 0
  = always 0
  nullptr always 0
Line 283
  , always !<=-1
  bom always !<=-1
Line 286
  = always 100000
  100000 always 100000
Line 287
  ( always {!<=-1,!>=2}
  = always 100000
  100000 always 100000
Line 289
  ( always !<=-1
Line 298
  macroValueKnown_ always {!<=-1,!>=2}
  macroValueKnown always {!<=-1,!>=2}
  macroValueKnown_ always {!<=-1,!>=2}
Line 302
  macroValueKnown always {!<=-1,!>=2}
Line 328
  = always 0
  nullptr always 0
Line 342
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 51
  ( always {!<=-1,!>=2}
Line 53
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  s {>=size=3,!<=size=2}
  0 always 0
  2 always 2
  "0x" always "0x"
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  0 always 0
  2 always 2
  "0X" always "0X"
  == always {!<=-1,!>=2}
  0 always 0
Line 56
  ( always {!<=-1,!>=2}
Line 58
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '0' always 48
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  1 always 1
  >= always {!<=-1,!>=2}
  '0' always 48
  && always {!<=-1,!>=2}
  [ possible >=48
  1 always 1
  < {!<=-1,!>=2,>=1}
  '8' always 56
Line 62
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  s possible size=0@81
  ( {!<=-1,0@81}
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  ( {lifetime[Iterator]=(s),>=size=2,!<=size=1,start=0}
  == always {!<=-1,!>=2}
  '\"' always 34
Line 68
  ( always {!<=-1,!>=2}
Line 72
  return always {!<=-1,!>=2}
  s possible size=0@83
  ( {!<=-1,0@83}
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  ( {lifetime[Iterator]=(s),>=size=2,!<=size=1,start=0}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 75
  "define" always "define"
Line 76
  "undef" always "undef"
Line 78
  "include" always "include"
Line 80
  "error" always "error"
Line 81
  "warning" always "warning"
Line 83
  "if" always "if"
Line 84
  "ifdef" always "ifdef"
Line 85
  "ifndef" always "ifndef"
Line 86
  "defined" always "defined"
Line 87
  "else" always "else"
Line 88
  "elif" always "elif"
Line 89
  "endif" always "endif"
Line 91
  "pragma" always "pragma"
Line 92
  "once" always "once"
Line 94
  "__has_include" always "__has_include"
Line 99
  t possible {symbolic=(lhs/rhs)@231,symbolic=(lhs%rhs)@231}
Line 106
  hex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 107
  oct always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 108
  hex {!<=-1,!>=2,0}
  2 always 2
  oct {!<=-1,!>=2,0}
  1 always 1
Line 109
  hex always {!<=-1,!>=2}
Line 111
  oct always {!<=-1,!>=2}
Line 117
  ( always !<=-1
Line 119
  ret always !<=-1
Line 120
  hex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 121
  oct always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 122
  hex {!<=-1,!>=2,0}
  2 always 2
  oct {!<=-1,!>=2,0}
  1 always 1
Line 123
  hex always {!<=-1,!>=2}
Line 125
  oct always {!<=-1,!>=2}
Line 127
  ret always !<=-1
Line 128
  return always !<=-1
  ret always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 133
  return always {!<=-1,!>=2}
  str possible size=11@70
  ( {!<=-1,11@70}
  >= always {!<=-1,!>=2}
  s possible "/cygdrive/"@70
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  s possible "/cygdrive/"@70
  ( {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  s possible "/cygdrive/"@70
  == always {!<=-1,!>=2}
  0 always 0
Line 136
  ( always {!<=-1,!>=2}
Line 138
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  e possible "/."@69
  ( always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(e.size()),!<=symbolic=(e.size()-1)}
  - always !<=-1
  e possible "/."@69
  ( {!<=-1,<=symbolic=(s.size()),!>=symbolic=(s.size()+1)}
  e possible "/."@69
  ( {!<=-1,<=symbolic=(s.size()),!>=symbolic=(s.size()+1)}
  e possible "/."@69
  == always {!<=-1,!>=2}
  0 always 0
Line 141
  ( always {!<=-1,!>=2}
Line 143
  return always {!<=-1,!>=2}
  tok1 possible {symbolic=(tok)@27,0@52,symbolic=(B->next)@30794}
  && always {!<=-1,!>=2}
  tok2 possible {symbolic=(nextTok)@127,symbolic=(tok3?tok3->next:nullptr)@181,symbolic=(tok->next)@182,symbolic=(tok->next)@13,symbolic=(lpar)@27,symbolic=(nameTokDef->next->next)@48}
  && always {!<=-1,!>=2}
  tok1 {!0,symbolic=(tok)@27}
  ( always {!<=-1,!>=2}
  tok2 {!0,symbolic=(nextTok)@127,symbolic=(tok3?tok3->next:nullptr)@181,symbolic=(tok->next)@182,symbolic=(tok->next)@13,symbolic=(lpar)@27,symbolic=(nameTokDef->next->next)@48}
Line 146
  ( always {!<=-1,!>=2}
Line 148
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 149
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 150
  && always {!<=-1,!>=2}
Line 151
  && always {!<=-1,!>=2}
Line 152
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  ')' always 41
  && always {!<=-1,!>=2}
Line 153
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 156
  ( always {!<=-1,!>=2}
Line 158
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 159
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
Line 160
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 165
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  != always {!<=-1,!>=2}
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  + always !<=-1
  ( always !<=-1
Line 166
  pos always !<=-1
  ( always !<=-1
Line 174
  ( {lifetime[Object]=(str),!0}
  "\r\n" always "\r\n"
  == always {!<=-1,!>=2}
  nullptr always 0
Line 175
  col always !<=-1
  += always !<=-1
  ( always !<=-1
Line 179
  i always !<=-1
  = always 0
  0U always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 180
  col always !<=-1
  ++ always !<=-1
Line 181
  [ possible 13
  i always !<=-1
  == {!<=-1,!>=2,0}
  '\n' always 10
  || {!<=-1,!>=2,1}
  [ possible 13
  i always !<=-1
  == {!<=-1,!>=2,1}
  '\r' always 13
Line 182
  col always !<=-1
  = always 1
  1 always 1
Line 183
  line always !<=-1
  ++ always !<=-1
Line 184
  [ possible {10,13}
  i always !<=-1
  == {!<=-1,!>=2,0,1}
  '\r' always 13
  && always {!<=-1,!>=2}
  i always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  i {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 185
  ++ {!<=0,<=symbolic=(str.size()-1),!>=symbolic=(str.size())}
  i {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
Line 190
  ( always {!<=-1,!>=2}
Line 192
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '\0' always 0
  && always {!<=-1,!>=2}
  ops possible {"+-*/%&|^"@78,"#="@88}
  op always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 195
  ( always {!<=-1,!>=2}
Line 197
  return always {!<=-1,!>=2}
  c possible "<>=!"@161
  0 always 0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 200
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1U always 1
  != always {!<=-1,!>=2}
  nullptr always 0
Line 207
  = always !0
  this always !0
Line 208
  tok possible symbolic=(this)
  . possible 0
Line 209
  = always !0
  . always !0
Line 210
  tok possible symbolic=(this)
Line 212
  ( always {!<=-1,!>=2}
  . always !0
  ' ' always 32
  : always 10
  '\n' always 10
Line 221
  = always !0
  this always !0
  tok possible symbolic=(this)
  tok possible symbolic=(this)
Line 222
  != always {!<=-1,!>=2}
  this always !0
Line 223
  ( always {!<=-1,!>=2}
  tok always !symbolic=(this)
  tok always !symbolic=(this)
  ' ' always 32
  : always 10
  '\n' always 10
Line 225
  tok possible symbolic=(this)
Line 230
  nullptr always 0
  nullptr always 0
Line 233
  nullptr always 0
  nullptr always 0
Line 238
  nullptr always 0
  nullptr always 0
Line 240
  this always !0
Line 244
  && always {!<=-1,!>=2}
Line 246
  this always !0
  = possible lifetime[Object]=(other)
  ( possible lifetime[Object]=(other)
Line 257
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 264
  this always !0
Line 268
  && always {!<=-1,!>=2}
Line 270
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 273
  = always 0
  nullptr always 0
Line 275
  = always 0
  nullptr always 0
Line 279
  this always !0
Line 285
  = always 0
  nullptr always 0
Line 286
  frontToken possible symbolic=(frontToken->next)
Line 287
  frontToken {symbolic=(frontToken->next),!0}
Line 288
  frontToken {symbolic=(frontToken->next),!0}
Line 289
  = always symbolic=(frontToken->next)
  next always symbolic=(frontToken->next)
Line 296
  ! always {!<=-1,!>=2}
Line 314
  < always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 315
  "\n#line " always "\n#line "
  . possible <=symbolic=(loc.line-1)
  " \"" always " \""
  "\"\n" always "\"\n"
Line 319
  . possible symbolic=(loc)
  > always {!<=-1,!>=2}
  loc possible symbolic=(tok->location)
Line 320
  '\n' always 10
Line 324
  ( always {!<=-1,!>=2}
Line 325
  ' ' always 32
Line 335
  ( always !<=-1
  , always !<=-1
  bom always !<=-1
Line 337
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 341
  bom {!<=-1,65534}
  == {!<=-1,!>=2,0}
  0xfeff always 65279
  || always {!<=-1,!>=2}
  bom always {!<=-1,!65279}
  == always {!<=-1,!>=2}
  0xfffe always 65534
Line 342
  ch2 always !<=-1
  = always !<=-1
  ( always !<=-1
Line 343
  bom {!<=-1,65279,65534}
  == {!<=-1,!>=2,1,0}
  0xfeff always 65279
  ch always !<=-1
  8 always 8
  ch2 always !<=-1
  ch2 always !<=-1
  8 always 8
  ch always !<=-1
Line 344
  ch always !<=-1
  = {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!<=-1}
  ( {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!<=-1}
  ch16 always symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))
  >= always {!<=-1,!>=2}
  0x80 always 128
  ? possible {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  0xff always 255
  : always {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  ch16 {symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!>=128,<=127}
Line 348
  ch {symbolic=(static_cast<unsigned char>((ch16>=0x80)?0xff:ch16)),!<=-1,255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  == {!<=-1,!>=2,0}
  '\r' always 13
Line 349
  ch always !<=-1
  = always 10
  '\n' always 10
Line 350
  bom {!<=-1,65279,65534}
  == {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\n' always 10
Line 352
  bom {!<=-1,65534}
  == {!<=-1,!>=2,0}
  0xfeff always 65279
  || always {!<=-1,!>=2}
  bom always {!<=-1,!65279}
  == always {!<=-1,!>=2}
  0xfffe always 65534
Line 355
  bom {!<=-1,65279,65534}
  == {!<=-1,!>=2,1,0}
  0xfeff always 65279
  8 always 8
  8 always 8
Line 356
  ch16 always symbolic=((bom==0xfeff)?(c1<<8|c2):(c2<<8|c1))
  != always {!<=-1,!>=2}
  '\n' always 10
Line 363
  return always !<=-1
  ch {!<=-1,255,10}
Line 366
  ( always !<=-1
  , always !<=-1
  bom always !<=-1
Line 368
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
Line 372
  bom {!<=-1,65534}
  == {!<=-1,!>=2,0}
  0xfeff always 65279
  || always {!<=-1,!>=2}
  bom always {!<=-1,!65279}
  == always {!<=-1,!>=2}
  0xfffe always 65534
Line 374
  ch2 always !<=-1
  = always !<=-1
  ( always !<=-1
Line 376
  bom {!<=-1,65279,65534}
  == {!<=-1,!>=2,1,0}
  0xfeff always 65279
  ch always !<=-1
  8 always 8
  ch2 always !<=-1
  ch2 always !<=-1
  8 always 8
  ch always !<=-1
Line 377
  ch always !<=-1
  = {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!<=-1}
  ( {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!<=-1}
  ch16 always symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))
  >= always {!<=-1,!>=2}
  0x80 always 128
  ? possible {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  0xff always 255
  : always {255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  ch16 {symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch)),!>=128,<=127}
Line 381
  ch {symbolic=(static_cast<unsigned char>((ch16>=0x80)?0xff:ch16)),!<=-1,255,symbolic=((bom==0xfeff)?(ch<<8|ch2):(ch2<<8|ch))}
  == {!<=-1,!>=2,0}
  '\r' always 13
Line 382
  ch always !<=-1
  = always 10
  '\n' always 10
Line 384
  return always !<=-1
  ch {!<=-1,255,10}
Line 387
  , always !<=-1
  bom always !<=-1
Line 390
  bom {!<=-1,65534}
  == {!<=-1,!>=2,0}
  0xfeff always 65279
  || always {!<=-1,!>=2}
  bom always {!<=-1,!65279}
  == always {!<=-1,!>=2}
  0xfffe always 65534
Line 394
  ( always !<=-1
Line 399
  ch1 possible 239
  >= {!<=-1,!>=2,0}
  0xfe always 254
Line 400
  bom always !<=-1
  bom always !<=-1
  = always !<=-1
  ( always !<=-1
  8 always 8
Line 401
  >= always {!<=-1,!>=2}
  0xfe always 254
Line 402
  return always !<=-1
  bom always !<=-1
  ( always !<=-1
Line 404
  return always !<=-1
  0 always 0
Line 408
  ch1 {!>=254,<=253}
  == {!<=-1,!>=2,<=0}
  0xef always 239
Line 410
  == always {!<=-1,!>=2}
  0xbb always 187
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0xbf always 191
Line 418
  return always !<=-1
  0 always 0
Line 421
  ( always {!<=-1,!>=2}
  ch always !<=-1
Line 423
  return always {!<=-1,!>=2}
  ( possible 0
  ch {!<=-1,95,36}
  || always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  ch always {!<=-1,!95}
  == always {!<=-1,!>=2}
  '$' always 36
Line 429
  '\"' always 34
Line 430
  i always !<=-1
  = always 1
  1U always 1
  i {!<=-1,1}
  < always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1 always 1
  ++ always !<=0
  i always !<=-1
Line 431
  i {!<=-1,<=symbolic=(str.size()-1-1),!>=symbolic=(str.size()-1),1}
Line 432
  c {symbolic=(str[i]),34,39}
  == {!<=-1,!>=2,0}
  '\\' always 92
  || always {!<=-1,!>=2}
  c {symbolic=(str[i]),39,!92}
  == {!<=-1,!>=2,0}
  '\"' always 34
  || always {!<=-1,!>=2}
  c {symbolic=(str[i]),!92,!34}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 433
  '\\' always 92
Line 434
  c {symbolic=(str[i]),92,34,39}
Line 436
  '\"' always 34
Line 442
  ! always {!<=-1,!>=2}
Line 445
  = always 5
  :: always 5
  PORTABILITY_BACKSLASH always 5
Line 447
  = always "Combination 'backslash space newline' is not portable."
  "Combination 'backslash space newline' is not portable." always "Combination 'backslash space newline' is not portable."
Line 448
  outputList always !0
Line 451
  ( always {!<=-1,!>=2}
Line 453
  return always {!<=-1,!>=2}
  str possible {size=1,size=2,size=3}
  == {!<=-1,!>=2,0}
  "u" always "u"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "U" always "U"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "L" always "L"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 454
  == always {!<=-1,!>=2}
  "R" always "R"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "uR" always "uR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "UR" always "UR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "LR" always "LR"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "u8R" always "u8R"
Line 457
  fileIndex always !<=-1
  line always !<=-1
Line 459
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  || always {!<=-1,!>=2}
  line always !<=-1
  >= always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 460
  . always !<=-1
  fileIndex always !<=-1
  = always !<=-1
  fileIndex always !<=-1
Line 461
  . always !<=-1
  line always !<=-1
  = always !<=-1
  line always !<=-1
Line 465
  line always !<=-1
  + always !<=1
  2 always 2
  >= always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 466
  . always !<=-1
  line always !<=-1
  = {!<=-1,>=symbolic=(location->line-2),!<=symbolic=(location->line-3)}
  line {!<=-1,>=symbolic=(location->line-2),!<=symbolic=(location->line-3)}
Line 467
  != always {!<=-1,!>=2}
  '#' always 35
Line 474
  "*/" always "*/"
Line 480
  multiline always !<=-1
  multiline always !<=-1
  = always 0
  0U always 0
Line 482
  = always 0
  nullptr always 0
Line 484
  bom always !<=-1
  = always !<=-1
  ( always !<=-1
Line 488
  = always 1
  1U always 1
Line 489
  = always 1
  1U always 1
Line 491
  ch always !<=-1
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 492
  ! always {!<=-1,!>=2}
Line 494
  ch {!<=-1,9,10,13}
  < {!<=-1,!>=2,1}
  ' ' always 32
  && always {!<=-1,!>=2}
  ch {!<=-1,10,13,<=31,!>=32}
  != {!<=-1,!>=2,1}
  '\t' always 9
  && always {!<=-1,!>=2}
  ch {!<=-1,13,<=31,!>=32,!9}
  != {!<=-1,!>=2,1}
  '\n' always 10
  && always {!<=-1,!>=2}
  ch always {!<=-1,!9,!10}
  != always {!<=-1,!>=2}
  '\r' always 13
Line 495
  ch always !<=-1
  = always 32
  ' ' always 32
Line 497
  ch {!<=-1,32}
  >= {!<=-1,!>=2,0}
  0x80 always 128
Line 500
  = always 6
  :: always 6
  UNHANDLED_CHAR_ERROR always 6
Line 503
  ( always !<=127
  ch always !<=127
Line 504
  "The code contains unhandled character(s) (character code=" always "The code contains unhandled character(s) (character code="
  "). Neither unicode nor extended ascii is supported." always "). Neither unicode nor extended ascii is supported."
Line 511
  ch {!<=-1,32}
  == {!<=-1,!>=2,0}
  '\n' always 10
Line 512
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 513
  > always {!<=-1,!>=2}
  1U always 1
Line 515
  ++ always !<=0
  multiline always !<=-1
Line 518
  multiline always !<=-1
  + always !<=0
  1 always 1
Line 519
  multiline always !<=-1
  = always 0
  0U always 0
Line 521
  ! {!<=-1,!>=2,1}
  multiline {!<=-1,0}
Line 522
  = always 1
  1 always 1
Line 524
  != always {!<=-1,!>=2}
Line 526
  ! always {!<=-1,!>=2}
Line 528
  lastline possible {size=12,size=13,size=18,size=9}
Line 529
  lastline possible {size=12,size=13,size=18,size=9}
  == {!<=-1,!>=2,0}
  "# file %str%" always "# file %str%"
Line 534
  1U always 1
  2U always 2
Line 535
  = always 1
  1U always 1
Line 536
  lastline possible {size=13,size=18,size=9}
  == {!<=-1,!>=2,0}
  "# line %num%" always "# line %num%"
Line 540
  & {lifetime[Address]=(location),!0}
Line 541
  lastline possible {size=18,size=9}
  == {!<=-1,!>=2,0}
  "# %num% %str%" always "# %num% %str%"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "# line %num% %str%" always "# line %num% %str%"
Line 546
  numtok possible symbolic=(strtok->previous)
Line 548
  1U always 1
  2U always 2
  "\\\\" always "\\\\"
  "\\" always "\\"
Line 549
  numtok possible symbolic=(strtok->previous)
  & {lifetime[Address]=(location),!0}
Line 552
  == always {!<=-1,!>=2}
  "# endfile" always "# endfile"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 553
  loc always !size=0
Line 554
  loc always !size=0
Line 561
  ch {!<=-1,32,!10}
Line 568
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "# error" always "# error"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "# warning" always "# warning"
Line 569
  = always 32
  ' ' always 32
Line 570
  && always {!<=-1,!>=2}
  prev possible 32
  == {!<=-1,!>=2,0}
  '\\' always 92
  || always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '\r' always 13
  && always {!<=-1,!>=2}
  ch always {!<=-1,!13}
  != always {!<=-1,!>=2}
  '\n' always 10
Line 571
  ch {!<=-1,92}
Line 572
  = always !<=-1
  ch always !<=-1
Line 573
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 575
  bom always !<=-1
Line 576
  currentToken possible size=0
Line 582
  ( always {!<=-1,!>=2}
  ch {!<=-1,47,34,39}
Line 583
  num always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ch always !<=-1
Line 584
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ch always !<=-1
Line 585
  ch always !<=-1
Line 586
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 587
  num always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\'' always 39
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !<=-1
  bom always !<=-1
Line 588
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 591
  bom always !<=-1
Line 595
  ch {!<=-1,47,34,39}
  == {!<=-1,!>=2,1,0}
  '/' always 47
  && always {!<=-1,!>=2}
  ( always !<=-1
  bom always !<=-1
  == always {!<=-1,!>=2}
  '/' always 47
Line 596
  && always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '\r' always 13
  && always {!<=-1,!>=2}
  ch always {!<=-1,!13}
  != always {!<=-1,!>=2}
  '\n' always 10
Line 597
  ch always {!<=-1,!13,!10}
Line 598
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 600
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  " \t" always " \t"
Line 601
  pos always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1U always 1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(currentToken.size()-1U-1),!>=symbolic=(currentToken.size()-1U)}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 603
  ( {!<=-1,>=symbolic=(pos+2),<=symbolic=(pos+1)}
  - always !<=-1
  1U always 1
  == always {!<=-1,!>=2}
  '\\' always 92
Line 604
  ++ always !<=0
  multiline always !<=-1
Line 605
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 607
  bom always !<=-1
Line 612
  ch {!<=-1,34,39}
  == {!<=-1,!>=2,0}
  '/' always 47
  && always {!<=-1,!>=2}
  ( always !<=-1
  bom always !<=-1
  == always {!<=-1,!>=2}
  '*' always 42
Line 613
  = always "/*"
  "/*" always "/*"
Line 614
  ( always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 615
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 617
  ch always !<=-1
Line 618
  currentToken always !<=size=0
  ( always !<=0
  >= always {!<=-1,!>=2}
  4U always 4
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  currentToken {>=size=4,!<=size=3}
Line 620
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 624
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 625
  pos always !<=-1
  = always !<=-1
  currentToken possible {"/*",size=2}
  ( always !<=-1
  "\\\n" always "\\\n"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 626
  pos always !<=-1
  2 always 2
Line 627
  ++ always !<=0
  multiline always !<=-1
Line 629
  multiline always !<=-1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  10 always 10
  "# " always "# "
Line 630
  pos always !<=-1
  = always 0
  0 always 0
Line 631
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\n' always 10
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 632
  pos always !<=-1
  1 always 1
Line 633
  ++ always !<=0
  multiline always !<=-1
Line 639
  ch {!<=-1,39,34}
  == {!<=-1,!>=2,0,1}
  '\"' always 34
  || always {!<=-1,!>=2}
  ch always {!<=-1,!34}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 641
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 642
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 643
  == always {!<=-1,!>=2}
Line 647
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'R' always 82
Line 649
  = always 34
  ch always 34
Line 650
  prefix always !size=0
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 651
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 652
  && always {!<=-1,!>=2}
  ch always !<=-1
  != always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
  ch always {!<=-1,!40}
  != always {!<=-1,!>=2}
  '\n' always 10
Line 653
  ch always {!<=-1,!40,!10}
Line 654
  ch always !<=-1
  = always !<=-1
  ( always !<=-1
  bom always !<=-1
Line 656
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ch always !<=-1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 661
  = always "Invalid newline in raw string delimiter."
  "Invalid newline in raw string delimiter." always "Invalid newline in raw string delimiter."
Line 666
  ')' always 41
  currentToken always !<=-1
Line 667
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 668
  ( always !<=-1
  bom always !<=-1
Line 669
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 674
  = always "Raw string missing terminating delimiter."
  "Raw string missing terminating delimiter." always "Raw string missing terminating delimiter."
Line 679
  ( always !<=-1
  - always !<=-1
  ( always !<=-1
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 681
  ( possible lifetime[Iterator]=(currentToken)
  0 always 0
Line 684
  ( always !<=-1
  "\r\n" always "\r\n"
  == always {!<=-1,!>=2}
Line 685
  2 always 2
  + always !<=1
  2 always 2
  * always !<=-1
  ( always !<=-1
Line 687
  1 always 1
  + always !<=0
  ( always !<=-1
Line 692
  ch always !<=-1
  ch always !<=-1
  bom always !<=-1
Line 693
  ( always !<=-1
  < always {!<=-1,!>=2}
  2U always 2
Line 697
  = {!<=size=1,>=size=2}
  currentToken {!<=size=1,>=size=2}
Line 698
  :: always !<=-1
  pos always !<=-1
Line 699
  = always 0
  0 always 0
Line 700
  pos always !<=-1
  = always !<=-1
  s possible {symbolic=(currentToken),>=size=2}
  ( always !<=-1
  "\r\n" always "\r\n"
  != always {!<=-1,!>=2}
Line 701
  pos always !<=-1
  1 always 1
Line 705
  ( always {!<=-1,!>=2}
Line 708
  prefix always !size=0
Line 710
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  0 always 0
  9 always 9
  "# define " always "# define "
  == always {!<=-1,!>=2}
  0 always 0
Line 711
  multiline always !<=-1
  += always !<=-1
  newlines {>=1,!<=0}
Line 714
  currentToken always !<=size=1
Line 720
  ch always {!<=-1,!34,!39}
Line 723
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "# include" always "# include"
Line 724
  '<' always 60
  '>' always 62
  bom always !<=-1
Line 725
  ( always !<=-1
  < always {!<=-1,!>=2}
  2U always 2
Line 729
  currentToken possible >=size=2
Line 731
  multiline always !<=-1
Line 732
  ( always !<=-1
Line 745
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  '(' always 40
Line 746
  tok always !0
Line 749
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 760
  & {lifetime[Address]=(tok),!0}
Line 763
  != always {!<=-1,!>=2}
  '(' always 40
Line 766
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ')' always 41
Line 769
  = always !0
  . always !0
Line 770
  tok always !0
Line 771
  tok always !0
Line 775
  ( always {!<=-1,!>=2}
Line 777
  ! {!<=-1,!>=2,1@254}
  tok possible 0@254
  || always {!<=-1,!>=2}
  tok always !0
  ( always !<=-1
  != always {!<=-1,!>=2}
  1U always 1
Line 778
  return always {!<=-1,!>=2}
  false always 0
Line 779
  tok always !0
  ( always size=1
  0 always 0
Line 780
  return always {!<=-1,!>=2}
  c possible 108
  == {!<=-1,!>=2,0}
  'f' always 102
  || always {!<=-1,!>=2}
  c always !102
  == always {!<=-1,!>=2}
  'l' always 108
Line 786
  executableScope always size=0
  false always 0
Line 788
  . possible {125,46}
  == {!<=-1,!>=2,0}
  '{' always 123
Line 789
  ( always {!<=-1,!>=2}
Line 790
  true always 1
Line 794
  prev possible {symbolic=(tok->previous),0}
  && always {!<=-1,!>=2}
  prev {symbolic=(tok->previous),!0}
  ";{}()" always ";{}()"
Line 795
  prev always !0
Line 796
  prev possible {symbolic=(tok->previous),0}
  && always {!<=-1,!>=2}
  prev always !0
  == always {!<=-1,!>=2}
  ')' always 41
Line 799
  . {46,!123}
  == {!<=-1,!>=2,0}
  '}' always 125
Line 800
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 801
  executableScope {>=size=2,!<=size=1}
Line 805
  . always {!123,!125}
  == always {!<=-1,!>=2}
  '.' always 46
Line 807
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 808
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 809
  "..." always "..."
Line 815
  && always {!<=-1,!>=2}
Line 816
  '.' always 46
Line 818
  ( always {!<=-1,!>=2}
  . possible 0
  || always {!<=-1,!>=2}
  . possible 0
  && always {!<=-1,!>=2}
  "AaBbCcDdEeFfPp" always "AaBbCcDdEeFfPp"
Line 823
  && always {!<=-1,!>=2}
Line 829
  1 always 1
Line 830
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 831
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'E' always 69
  || always {!<=-1,!>=2}
  lastChar always !69
  == always {!<=-1,!>=2}
  'e' always 101
  || always {!<=-1,!>=2}
Line 832
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'P' always 80
  || always {!<=-1,!>=2}
  lastChar always !80
  == always {!<=-1,!>=2}
  'p' always 112
  && always {!<=-1,!>=2}
Line 833
  && always {!<=-1,!>=2}
  "+-" always "+-"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 839
  == always {!<=-1,!>=2}
  '\0' always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\0' always 0
Line 841
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
Line 843
  1U always 1
  != always {!<=-1,!>=2}
  . always !0
Line 846
  . possible {symbolic=(tok->op),58,62}
  == {!<=-1,!>=2,0}
  '=' always 61
  && always {!<=-1,!>=2}
  "=!<>+-*/%&|^" always "=!<>+-*/%&|^"
Line 847
  == always {!<=-1,!>=2}
  '&' always 38
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 850
  = always 0
  0 always 0
Line 852
  indentlevel possible 0
  >= {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  start possible symbolic=(tok)
Line 853
  start {symbolic=(tok),!0}
  . possible 40
  == {!<=-1,!>=2,0}
  ')' always 41
Line 854
  ++ always !<=0
  indentlevel always !<=-1
Line 855
  start always !0
  . always !41
  == always {!<=-1,!>=2}
  '(' always 40
Line 856
  -- always !<=-2
  indentlevel always !<=-1
Line 857
  start always !0
  ";{}" always ";{}"
Line 859
  start always !0
Line 861
  indentlevel possible {>=0,<=-1}
  == {!<=-1,!>=2,>=0,<=1}
  -1 always -1
  && always {!<=-1,!>=2}
Line 862
  = always !0
  start always !0
Line 863
  isFuncDecl always {!<=-1,!>=2}
  isFuncDecl always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ftok {symbolic=(start),!0}
Line 864
  isFuncDecl {symbolic=(ftok->name),!<=-1,!>=2}
Line 865
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '*' always 42
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '&' always 38
Line 866
  isFuncDecl always {!<=-1,!>=2}
  = always 0
  false always 0
Line 867
  ! always {!<=-1,!>=2}
Line 869
  . always !0
  ";{}:" always ";{}:"
Line 873
  isFuncDecl always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  start possible symbolic=(ftok)
  != {!<=-1,!>=2,0}
  ftok possible symbolic=(start)
  && always {!<=-1,!>=2}
  start always !symbolic=(ftok)
Line 874
  isFuncDecl always {!<=-1,!>=2}
Line 880
  "=" always "="
Line 882
  . possible {symbolic=(tok->next->op),38,58,45,60,62,43}
  == {!<=-1,!>=2,0}
  '|' always 124
  || {!<=-1,!>=2,0}
  . possible {58,45,60,62,43}
  == {!<=-1,!>=2,0}
  '&' always 38
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 885
  . possible {symbolic=(tok->next->op),45,60,62,43}
  == {!<=-1,!>=2,0}
  ':' always 58
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ':' always 58
Line 888
  . possible {symbolic=(tok->next->op),60,62,43,45}
  == {!<=-1,!>=2,0,1}
  '-' always 45
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '>' always 62
Line 891
  . possible {symbolic=(tok->next->op),62,43,45}
  == {!<=-1,!>=2,0}
  '<' always 60
  || {!<=-1,!>=2,0}
  . possible {43,45}
  == {!<=-1,!>=2,0}
  '>' always 62
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 893
  . possible 0
Line 894
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '=' always 61
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '=' always 61
Line 898
  . possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '-' always 45
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 899
  1U always 1
  != always {!<=-1,!>=2}
Line 901
  && always {!<=-1,!>=2}
Line 903
  && always {!<=-1,!>=2}
Line 911
  "compl" always "compl"
Line 912
  "not" always "not"
Line 915
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 917
  ( always {!<=-1,!>=2}
Line 918
  = always 33
  '!' always 33
Line 920
  ( always {!<=-1,!>=2}
Line 921
  = always 126
  '~' always 126
Line 923
  . possible {33,126}
  == {!<=-1,!>=2,1,0}
  '!' always 33
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 924
  == always {!<=-1,!>=2}
  "0" always "0"
  "1" always "1"
  : always "0"
  "0" always "0"
Line 926
  . possible 126
  == {!<=-1,!>=2,1}
  '~' always 126
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 930
  && always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 932
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 935
  '+' always 43
Line 939
  '-' always 45
Line 950
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 951
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 953
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 957
  . possible {47,37}
  == {!<=-1,!>=2,0}
  '*' always 42
Line 959
  . {37,!42}
  == {!<=-1,!>=2,0}
  '/' always 47
  || always {!<=-1,!>=2}
  . always {!42,!47}
  == always {!<=-1,!>=2}
  '%' always 37
Line 961
  rhs {symbolic=(stringToLL(tok->next->str())),0,-1}
  == {!<=-1,!>=2,1,0}
  0 always 0
Line 962
  "division/modulo by zero" always "division/modulo by zero"
Line 964
  rhs always !0
  == always {!<=-1,!>=2}
  -1 always -1
  && always {!<=-1,!>=2}
  lhs always symbolic=(stringToLL(tok->previous->str()))
  == always {!<=-1,!>=2}
Line 965
  "division overflow" always "division overflow"
Line 966
  == always {!<=-1,!>=2}
  '/' always 47
Line 967
  lhs always symbolic=(stringToLL(tok->previous->str()))
  rhs always !0
Line 969
  lhs always symbolic=(stringToLL(tok->previous->str()))
  rhs always !0
Line 974
  result possible {symbolic=(lhs/rhs),symbolic=(lhs%rhs)}
Line 982
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 983
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 985
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 989
  . possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
Line 991
  . always !43
  == always {!<=-1,!>=2}
  '-' always 45
Line 1005
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1006
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1008
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1012
  ( possible size=2
  == always {!<=-1,!>=2}
  "<<" always "<<"
Line 1014
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 1026
  "not_eq" always "not_eq"
Line 1029
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1030
  ( always {!<=-1,!>=2}
Line 1031
  "!=" always "!="
Line 1033
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<>=!" always "<>=!"
Line 1035
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1037
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1041
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
Line 1042
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1043
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "!=" always "!="
Line 1044
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1045
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 1046
  = always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 1047
  ( possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 1048
  = always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 1049
  ( possible size=2
  == {!<=-1,!>=2,0}
  "<" always "<"
Line 1050
  = always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 1051
  == always {!<=-1,!>=2}
  "<=" always "<="
Line 1052
  = always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 1063
  "bitand" always "bitand"
Line 1064
  "bitor" always "bitor"
Line 1065
  "xor" always "xor"
Line 1069
  = always "&^|"
  "&^|" always "&^|"
  * possible {38,124}
  op possible "&^|"
Line 1071
  * possible 124
  == {!<=-1,!>=2,0}
  '&' always 38
Line 1072
  = {&,lifetime[Address]=(BITAND),!0}
  & {&,lifetime[Address]=(BITAND),!0}
Line 1073
  * always !38
  == always {!<=-1,!>=2}
  '|' always 124
Line 1074
  = {&,lifetime[Address]=(BITOR),!0}
  & {&,lifetime[Address]=(BITOR),!0}
Line 1076
  = {&,lifetime[Address]=(XOR),!0}
  & {&,lifetime[Address]=(XOR),!0}
Line 1077
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1078
  != always {!<=-1,!>=2}
  * possible {38,94}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  alternativeOp possible {lifetime[Address]=(BITAND),lifetime[Address]=(BITOR),lifetime[Address]=(XOR)}
Line 1080
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1082
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1085
  * possible 94
  == {!<=-1,!>=2,0}
  '&' always 38
Line 1087
  * always !38
  == always {!<=-1,!>=2}
  '^' always 94
Line 1099
  "and" always "and"
Line 1100
  "or" always "or"
Line 1103
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 1104
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1105
  ( always {!<=-1,!>=2}
Line 1106
  "&&" always "&&"
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  "||" always "||"
Line 1110
  ( possible size=2
  != always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "||" always "||"
Line 1112
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1114
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
Line 1118
  == always {!<=-1,!>=2}
  "||" always "||"
Line 1119
  = always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1121
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1132
  gotoTok1 always {!<=-1,!>=2}
  gotoTok1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
  gotoTok1 {!<=-1,!>=2,1}
Line 1134
  gotoTok1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  != always {!<=-1,!>=2}
  "?" always "?"
Line 1137
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1138
  "invalid expression" always "invalid expression"
Line 1139
  ! always {!<=-1,!>=2}
  . always !0
Line 1141
  . always !0
  . always !0
  != always {!<=-1,!>=2}
  ':' always 58
Line 1145
  trueTok always symbolic=(tok->next)
Line 1146
  ! always {!<=-1,!>=2}
  falseTok always symbolic=(trueTok->next->next)
Line 1147
  "invalid expression" always "invalid expression"
Line 1148
  condTok always symbolic=(tok->previous)
  == always {!<=-1,!>=2}
Line 1149
  condTok always {symbolic=(tok->previous),symbolic=(*tok1)}
  != always {!<=-1,!>=2}
  "0" always "0"
  trueTok always symbolic=(tok->next)
  : always {1,symbolic=(tok->next),symbolic=(trueTok->next->next)}
  falseTok {symbolic=(trueTok->next->next),!0}
Line 1150
  condTok always symbolic=(tok->previous)
Line 1151
  trueTok always symbolic=(tok->next)
Line 1152
  condTok always symbolic=(tok->previous)
  == always {!<=-1,!>=2}
  "0" always "0"
  trueTok always symbolic=(tok->next)
  : always {1,symbolic=(tok->next)}
  falseTok always !0
Line 1153
  condTok always symbolic=(tok->previous)
Line 1154
  gotoTok1 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1161
  tok possible symbolic=(frontToken)
Line 1162
  = {symbolic=(frontToken),!0}
  tok {symbolic=(frontToken),!0}
Line 1163
  tok {symbolic=(frontToken),symbolic=(tok1),!0}
Line 1164
  tok1 {symbolic=(frontToken),!0}
Line 1165
  tok1 always !0
Line 1174
  backslash always {!<=-1,!>=2}
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1175
  = always 0
  0 always 0
Line 1176
  ch possible {symbolic=(next),0}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ch {!symbolic=(end),0}
  != {!<=-1,!>=2,1}
  '\r' always 13
  && always {!<=-1,!>=2}
  ch {!symbolic=(end),0,!13}
  != {!<=-1,!>=2,1}
  '\n' always 10
  && always {!<=-1,!>=2}
Line 1177
  = always !<=-1
  ( always !<=-1
Line 1178
  backslash always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\n' always 10
Line 1179
  = always 0
  0 always 0
Line 1180
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1183
  backslash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1184
  ch possible 92
Line 1185
  == always {!<=-1,!>=2}
  '\\' always 92
Line 1186
  update_ch always {!<=-1,!>=2}
  update_ch always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1187
  = always 0
  0 always 0
Line 1189
  = always !<=-1
  ( always !<=-1
Line 1190
  next possible {10,92}
  == {!<=-1,!>=2,0}
  '\r' always 13
  || always {!<=-1,!>=2}
  next {92,!13}
  == {!<=-1,!>=2,0}
  '\n' always 10
Line 1191
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 1192
  backslash always {!<=-1,!>=2}
  = {!<=-1,!>=2,1,0}
  next possible {13,10}
  == {!<=-1,!>=2,1,0}
  '\r' always 13
Line 1193
  update_ch always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1194
  next always {!13,!10}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 1195
  update_ch always {!<=-1,!>=2}
  = {!<=-1,!>=2,1,0}
  ! {!<=-1,!>=2,1,0}
  update_ch {!<=-1,!>=2,0,1}
Line 1196
  next possible {13,10,92}
Line 1197
  == always {!<=-1,!>=2}
  '\\' always 92
Line 1198
  update_ch always {!<=-1,!>=2}
Line 1203
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1209
  "No pair for character (" always "No pair for character ("
  "). Can't process file. File is either invalid or unicode, which is currently not supported." always "). Can't process file. File is either invalid or unicode, which is currently not supported."
Line 1212
  "" always ""
Line 1221
  = always 0
  0 always 0
Line 1223
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1228
  > always {!<=-1,!>=2}
Line 1229
  "" always ""
Line 1230
  ! {!<=-1,!>=2,0}
  ret possible size=0
  ( {!<=-1,!>=2,1}
Line 1231
  ret always !size=0
  ( possible lifetime[Iterator]=(ret)
  0 always 0
  1 always 1
  ' ' always 32
Line 1232
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
Line 1233
  ( possible lifetime[Iterator]=(ret)
  0 always 0
  "%str%" always "%str%"
Line 1235
  ( possible lifetime[Iterator]=(ret)
  0 always 0
  "%num%" always "%num%"
Line 1237
  ( possible lifetime[Iterator]=(ret)
  0 always 0
Line 1242
  ( always {!<=-1,!>=2}
Line 1244
  = always 0
  nullptr always 0
Line 1245
  = always 0
  0 always 0
Line 1247
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1251
  > always {!<=-1,!>=2}
Line 1252
  return always {!<=-1,!>=2}
  false always 0
Line 1255
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  prevTok always !0
  0 always 0
  == always {!<=-1,!>=2}
  '#' always 35
Line 1258
  ( always !<=-1
Line 1260
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  i always !<=-1
Line 1261
  i {!<=-1,<=symbolic=(files.size()-1),!>=symbolic=(files.size())}
  == always {!<=-1,!>=2}
Line 1262
  return always !<=-1
  i always {!<=-1,!>=symbolic=(files.size())}
Line 1265
  return always !<=-1
  files always !size=0
  ( always !<=0
  - always !<=-1
  1U always 1
Line 1279
  nullptr always 0
  variadic always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  false always 0
Line 1281
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  true always 1
Line 1282
  ( always {!<=-1,!>=2}
Line 1283
  "bad macro syntax" always "bad macro syntax"
Line 1284
  != always {!<=-1,!>=2}
  '#' always 35
Line 1285
  "bad macro syntax" always "bad macro syntax"
Line 1287
  tok always symbolic=(hashtok)
Line 1288
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1289
  "bad macro syntax" always "bad macro syntax"
Line 1290
  tok always !0
Line 1291
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1292
  "bad macro syntax" always "bad macro syntax"
Line 1293
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1294
  "bad macro syntax" always "bad macro syntax"
Line 1297
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  false always 0
Line 1298
  ' ' always 32
Line 1301
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1302
  "bad macro syntax. macroname=" always "bad macro syntax. macroname="
  " value=" always " value="
Line 1305
  nullptr always 0
  valueDefinedInCode_ always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1306
  this always !0
Line 1310
  this always !0
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(other),!0}
Line 1312
  valueDefinedInCode_ always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1313
  ( always {!<=-1,!>=2}
Line 1314
  ( always {!<=-1,!>=2}
Line 1317
  ( always {!<=-1,!>=2}
Line 1320
  this always !0
Line 1323
  ( always {!<=-1,!>=2}
Line 1324
  return always {!<=-1,!>=2}
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 1344
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 1348
  rawtok always symbolic=(rawtok1)
  rawtok1 always symbolic=(rawtok)
Line 1349
  = always !0
  rawtok always symbolic=(rawtok1)
  . always !0
Line 1350
  rawtok always !0
Line 1351
  rawtok always !0
Line 1352
  = always 1
  1 always 1
Line 1353
  && always {!<=-1,!>=2}
  par possible 1
  > {!<=-1,!>=2,1}
  0 always 0
Line 1354
  rawtok always !0
  . possible {41,35}
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1355
  ++ always !<=1
  par always !<=0
Line 1356
  rawtok always !0
  . {35,!40}
  == {!<=-1,!>=2,0}
  ')' always 41
Line 1357
  -- always !<=-1
  par always !<=0
Line 1358
  rawtok always !0
  . always {!40,!41}
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rawtok always !0
  rawtok always !0
Line 1359
  rawtok always !0
  "it is invalid to use a preprocessor directive as macro parameter" always "it is invalid to use a preprocessor directive as macro parameter"
Line 1360
  rawtok always !0
Line 1361
  rawtok always !0
Line 1363
  first always {!<=-1,!>=2}
  first always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1364
  && always {!<=-1,!>=2}
  valueToken always !0
  == always {!<=-1,!>=2}
Line 1365
  first always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1366
  & {lifetime[Address]=(output2),!0}
  expandedmacros always size=0
  first {!<=-1,!>=2,1,0}
Line 1369
  & {lifetime[Address]=(output2),!0}
  expandedmacros always size=0
Line 1371
  && always {!<=-1,!>=2}
  rawtok possible symbolic=(rawtok2->next)
Line 1372
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1375
  macro2tok always !0
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1376
  par always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 1378
  -- always !<=-1
  par always !<=0
Line 1379
  macro2tok always !0
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1380
  ++ always !<=0
  par always !<=-1
Line 1381
  macro2tok always !0
Line 1383
  macro2tok possible 0
Line 1384
  macro2tok always !0
Line 1386
  rawtok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 1388
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  macro2tok always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1390
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  macro2tok always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1392
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  macro2tok always !0
Line 1393
  macro {lifetime[Iterator]=(macros),symbolic=(macros.find(macro2tok->str()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  macro {lifetime[Iterator]=(macros),symbolic=(macros.find(macro2tok->str())),!symbolic=(macros.end()),!end=0}
Line 1397
  macro2tok possible symbolic=(next)
Line 1398
  next possible symbolic=(macro2tok)
  macro2tok {symbolic=(next),!0}
Line 1399
  macro2tok always !0
Line 1400
  macro2tok always !0
Line 1403
  par always !<=-1
  = always !<=-1
  != always {!<=-1,!>=2}
  ? always !<=-1
  1U always 1
  : always 0
  0U always 0
Line 1405
  rawtok2 possible symbolic=(rawtok)
Line 1406
  rawtok2 possible symbolic=(rawtok)
Line 1407
  rawtok2 possible symbolic=(rawtok)
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1408
  ++ always !<=0
  par always !<=-1
Line 1409
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1410
  par always !<=-1
  <= always {!<=-1,!>=2}
  1U always 1
Line 1412
  -- {!<=0,>=1}
  par {!<=1,>=2}
Line 1415
  ! always {!<=-1,!>=2}
  rawtok2 possible symbolic=(rawtok)
  || always {!<=-1,!>=2}
  par always !<=-1
  != always {!<=-1,!>=2}
  1U always 1
Line 1417
  & {lifetime[Address]=(output2),!0}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1419
  rawtok2 always !0
Line 1422
  rawtok possible {symbolic=(rawtok2->next),0}
Line 1441
  ( always {!<=-1,!>=2}
Line 1442
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1443
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
Line 1444
  ( always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
Line 1445
  . always !<=-1
  col always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=-1
  ( always !<=-1
Line 1457
  "Wrong number of parameters for macro \'" always "Wrong number of parameters for macro \'"
  "\'." always "\'."
Line 1463
  "Invalid ## usage when expanding \'" always "Invalid ## usage when expanding \'"
  "\': " always "\': "
Line 1470
  "Unexpected token '" always "Unexpected token '"
  tokenA possible symbolic=(tok->next->next)@89
  "'" always "'"
Line 1474
  "Pasting '" always "Pasting '"
  "' and '" always "' and '"
  tokenB possible symbolic=(tok->next->next)@91
  "' yields an invalid token." always "' yields an invalid token."
Line 1478
  "Unexpected newline" always "Unexpected newline"
Line 1483
  , always {!<=-1,!>=2}
  replaced always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 1484
  ( possible lifetime[SubObject]=(loc)
  str possible {"1"@193,"0"@193,""@5,"##"@15}
Line 1485
  replaced {!<=-1,!>=2,1@157}
Line 1486
  tok always size=0
Line 1488
  tok always size=0
  expandedFromToken always !0
  this always !0
Line 1489
  tok always size=0
Line 1492
  ( always {!<=-1,!>=2}
Line 1494
  variadic always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1495
  ! always {!<=-1,!>=2}
Line 1496
  = always 0
  = always 0
  nullptr always 0
Line 1498
  return always {!<=-1,!>=2}
  false always 0
Line 1502
  ( always {!<=-1,!>=2}
Line 1504
  nameTokDef always !0
Line 1505
  ( always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
  && always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
  != always {!<=-1,!>=2}
  ')' always 41
Line 1506
  == always {!<=-1,!>=2}
  "..." always "..."
  && always {!<=-1,!>=2}
Line 1507
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  ')' always 41
Line 1508
  variadic always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1509
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1510
  "__VA_ARGS__" always "__VA_ARGS__"
Line 1511
  = always !0
  . always !0
Line 1514
  . always !41
  != always {!<=-1,!>=2}
  ',' always 44
Line 1518
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argtok possible symbolic=(nameTokDef->next->next)
Line 1519
  = possible 0
  ? possible 0
  argtok always !0
  : possible 0
  argtok possible 0
Line 1520
  = always 0
  nullptr always 0
Line 1521
  return always {!<=-1,!>=2}
  false always 0
Line 1523
  = possible 0
  ? possible 0
  argtok always !0
  : always 0
  nullptr always 0
Line 1526
  nameTokDef always !0
Line 1529
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  valueToken possible 0
  nameTokDef always !0
Line 1530
  = always 0
  nullptr always 0
Line 1531
  = possible 0
  valueToken possible 0
Line 1532
  ( always {!<=-1,!>=2}
  endToken possible 0
  nameTokDef always !0
Line 1534
  return always {!<=-1,!>=2}
  true always 1
Line 1537
  ( always !<=-1
Line 1538
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1539
  par {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1540
  == always {!<=-1,!>=2}
  par {!<=-1,<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
Line 1541
  return always !<=-1
  par always {!<=-1,!>=symbolic=(args.size())}
Line 1542
  par always {!<=-1,!>=symbolic=(args.size())}
  ++ always {!<=-1,!>=symbolic=(args.size())}
Line 1544
  return always !<=-1
  ~ always 4294967295
  0U always 0
Line 1547
  calledInDefine always {!<=-1,!>=2}
Line 1548
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  '(' always 40
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1549
  ( always size=0
Line 1552
  parametertokens always size=0
Line 1553
  par always !<=-1
  par always !<=-1
  = always 0
  0U always 0
Line 1554
  calledInDefine {!<=-1,!>=2,0}
  ? always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1555
  . possible {41,44}
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1556
  ++ always !<=0
  par always !<=-1
Line 1557
  . {44,!40}
  == {!<=-1,!>=2,0}
  ')' always 41
Line 1558
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
Line 1562
  -- always !<=-1
  par always !<=0
Line 1563
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  . always {!40,!41}
  == always {!<=-1,!>=2}
  ',' always 44
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1575
  ! always {!<=-1,!>=2}
  lpar possible symbolic=(nextTok)@128
  || always {!<=-1,!>=2}
  lpar {!0,symbolic=(nextTok)@128}
  != always {!<=-1,!>=2}
  '(' always 40
Line 1576
  nullptr always 0
Line 1577
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1578
  = {!0,symbolic=(nextTok)@128}
  lpar {!0,symbolic=(nextTok)@128}
Line 1579
  ( always {!<=-1,!>=2}
  lpar {symbolic=(tok),!0,symbolic=(nextTok)@128}
  tok possible {symbolic=(lpar),symbolic=(nextTok)@128}
Line 1580
  . possible {35,40,41}
  == {!<=-1,!>=2,1,0}
  '#' always 35
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1583
  . possible {40,41}
  == {!<=-1,!>=2,0}
  '#' always 35
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '#' always 35
Line 1586
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1587
  expanded {!<=-1,!>=2,0}
  expanded always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1588
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 1589
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 1590
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str())),!symbolic=(macros.end()),!end=0}
Line 1591
  ! always {!<=-1,!>=2}
  m always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 1592
  m always symbolic=(it->second)
Line 1593
  expanded always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1596
  ! {!<=-1,!>=2,1,0}
  expanded {!<=-1,!>=2,0,1}
Line 1598
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  par always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
Line 1603
  . possible 41
  == {!<=-1,!>=2,0}
  '(' always 40
Line 1604
  ++ always !<=0
  par always !<=-1
Line 1605
  . always !40
  == always {!<=-1,!>=2}
  ')' always 41
Line 1606
  -- {!<=-1,0}
  par {!<=-1,1}
Line 1607
  par always !<=-1
  == always {!<=-1,!>=2}
  0U always 0
Line 1614
  lpar always !0
Line 1615
  ( always {!<=-1,!>=2}
  lpar always !0
  : always 0
  nullptr always 0
Line 1618
  , always 0
  first always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1620
  ! {!<=-1,!>=2,0@80,1@80}
  first {!<=-1,!>=2,1@80,0@80}
Line 1621
  expandedmacros possible size=0@80
Line 1623
  usageList possible lifetime[Object]=(loc)
Line 1625
  ( possible {size=8,size=11}
  == {!<=-1,!>=2,0}
  "__FILE__" always "__FILE__"
Line 1626
  output possible {lifetime[Address]=(temp)@165,lifetime[Address]=(temp)@177,lifetime[Address]=(output2)@82}
  ( possible lifetime[SubObject]=(loc)
  '\"' always 34
  '\"' always 34
Line 1629
  ( possible size=11
  == {!<=-1,!>=2,0}
  "__LINE__" always "__LINE__"
Line 1630
  ( possible lifetime[SubObject]=(loc)
  . always !<=-1
  line always !<=-1
Line 1633
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1634
  ( possible lifetime[SubObject]=(loc)
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 1638
  calledInDefine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  fileIndex always !<=-1
  || always {!<=-1,!>=2}
Line 1639
  . always !<=-1
  line always !<=-1
  < always {!<=-1,!>=2}
  . always !<=-1
  line always !<=-1
Line 1641
  calledInDefine always {!<=-1,!>=2}
Line 1643
  ( always {!<=-1,!>=2}
Line 1645
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  '(' always 40
Line 1646
  ( possible lifetime[SubObject]=(loc)
Line 1647
  . always !0
Line 1651
  variadic always {!<=-1,!>=2}
Line 1652
  ( always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1656
  ( always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
  + always !<=-1
  ( always {!<=-1,!>=2}
  ? always !<=-1
  2U always 2
  : always 1
  1U always 1
Line 1664
  ! {!<=-1,!>=2,0}
  parametertokens1 possible size=0
  ( {!<=-1,!>=2,1}
Line 1665
  counter always {!<=-1,!>=2}
  counter always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1666
  parametertokens1 always !size=0
  0 always 0
  != always {!<=-1,!>=2}
  parametertokens1 always !size=0
Line 1667
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1668
  counter always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1673
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  "__COUNTER__" always "__COUNTER__"
Line 1675
  ! {!<=-1,!>=2,1,0}
  counter {!<=-1,!>=2,0,1}
  || always {!<=-1,!>=2}
  m {lifetime[Iterator]=(macros),symbolic=(macros.find("__COUNTER__"))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 1676
  parametertokens1 always !size=0
Line 1678
  m {lifetime[Iterator]=(macros),symbolic=(macros.find("__COUNTER__")),!symbolic=(macros.end()),!end=0}
Line 1679
  par always !<=-1
  par always !<=-1
  = always 0
  0 always 0
Line 1680
  parametertokens1 always !size=0
  0 always 0
  && always {!<=-1,!>=2}
  par {!<=-1,0}
  < always {!<=-1,!>=2}
  parametertokens1 always !size=0
  ( always !<=0
Line 1681
  tok possible symbolic=(parametertokens1[par])
  == always {!<=-1,!>=2}
  "__COUNTER__" always "__COUNTER__"
Line 1682
  ( always !<=-1
Line 1685
  tok possible symbolic=(parametertokens1[par])
Line 1686
  == always {!<=-1,!>=2}
  parametertokens1 always !size=0
  par always !<=-1
Line 1688
  par always !<=-1
  ++ always !<=-1
Line 1698
  != always {!<=-1,!>=2}
Line 1699
  != always {!<=-1,!>=2}
  '#' always 35
Line 1701
  ( always {!<=-1,!>=2}
  . possible 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
Line 1702
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
  . always !0
Line 1705
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(new_output),!0}
Line 1706
  ( always {!<=-1,!>=2}
Line 1707
  ( always {!<=-1,!>=2}
Line 1708
  "" always ""
  ( always {!<=-1,!>=2}
Line 1711
  ( always {!<=-1,!>=2}
Line 1712
  = always !0
  . always !0
Line 1719
  = always 1
  1 always 1
Line 1721
  ( always {!<=-1,!>=2}
  hashToken possible symbolic=(tok->next)
  && always {!<=-1,!>=2}
  hashToken possible symbolic=(tok->next)
  == always {!<=-1,!>=2}
  '#' always 35
Line 1725
  numberOfHash possible {>=2,<=1}
  == {!<=-1,!>=2,>=0}
  4 always 4
  && always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 1727
  "##" always "##"
  ( always {!<=-1,!>=2}
Line 1732
  >= always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  . always !<=-1
  col always !<=-1
Line 1738
  = possible symbolic=(hashToken)
  . possible symbolic=(hashToken)
Line 1739
  tok possible symbolic=(hashToken)
  == always {!<=-1,!>=2}
Line 1740
  tok always symbolic=(endToken)
Line 1743
  tok always !symbolic=(endToken)
  == always {!<=-1,!>=2}
  '#' always 35
Line 1745
  tok always !symbolic=(endToken)
Line 1748
  tok always !symbolic=(endToken)
Line 1752
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1758
  ! {!<=-1,!>=2,0}
  parametertokens1 possible size=0
  ( {!<=-1,!>=2,1}
Line 1759
  parametertokens1 always !size=0
Line 1761
  ( always {!<=-1,!>=2}
Line 1765
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 1767
  . possible 0
Line 1770
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
Line 1772
  . always !0
Line 1775
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 1776
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(temp.cback()->str()))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 1778
  . always !0
Line 1781
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(temp.cback()->str()))}
Line 1782
  ! always {!<=-1,!>=2}
  calledMacro always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 1790
  & {lifetime[Address]=(temp2),!0}
Line 1791
  ! always {!<=-1,!>=2}
Line 1796
  tok2 always !0
Line 1801
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1802
  output possible lifetime[Address]=(tokenListHash)@133
  true always 1
Line 1809
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
Line 1814
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 1815
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(tok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 1819
  it possible lifetime[Iterator]=(macros)
Line 1820
  ! always {!<=-1,!>=2}
  calledMacro always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 1822
  & {lifetime[Address]=(temp),!0}
Line 1823
  expandedmacros2 always !size=0
Line 1825
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '(' always 40
Line 1826
  true always 1
Line 1831
  & {lifetime[Address]=(tokens),!0}
Line 1832
  ! always {!<=-1,!>=2}
Line 1833
  true always 1
Line 1837
  & {lifetime[Address]=(temp),!0}
Line 1838
  tok2 always !0
Line 1841
  == always {!<=-1,!>=2}
Line 1843
  = possible 0
  tok2 always symbolic=(tok->next)
  ? possible 0
  tok2 {symbolic=(tok->next),!0}
  : always 0
  nullptr always 0
Line 1844
  = possible 0
  tok3 {symbolic=(tok2?tok2->next:nullptr),0}
  ? possible 0
  tok3 {symbolic=(tok2?tok2->next:nullptr),!0}
  : always 0
  nullptr always 0
Line 1845
  = always 0
  nullptr always 0
Line 1846
  = always 0
  nullptr always 0
Line 1847
  ( always {!<=-1,!>=2}
  tok4 {symbolic=(tok3?tok3->next:nullptr),0}
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  == always {!<=-1,!>=2}
  '(' always 40
  && always {!<=-1,!>=2}
  tok3 always symbolic=(tok2?tok2->next:nullptr)
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok4 always symbolic=(tok3?tok3->next:nullptr)
  == always {!<=-1,!>=2}
  ')' always 41
Line 1848
  = always symbolic=(tok2?tok2->next:nullptr)
  tok3 always symbolic=(tok2?tok2->next:nullptr)
Line 1849
  = always symbolic=(tok3?tok3->next:nullptr)
  tok4 always symbolic=(tok3?tok3->next:nullptr)
Line 1850
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next)
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1851
  = always symbolic=(tok->next)
  = always symbolic=(tok->next)
  tok2 always symbolic=(tok->next)
Line 1853
  defToken possible {symbolic=(tok3),symbolic=(tok2?tok2->next:nullptr),symbolic=(tok->next)}
Line 1854
  defToken always !0
Line 1855
  defToken always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  && always {!<=-1,!>=2}
  defToken always !0
  . always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  defToken always !0
  defToken always !0
  . always !0
Line 1857
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
  defToken always !0
Line 1859
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(temp),!0}
  defToken always !0
  . always !0
  . always !0
  . always !0
Line 1862
  defToken always !0
  . always !0
  . always !0
Line 1863
  defToken always !0
  . always !0
Line 1865
  def always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  macroName possible symbolic=(defToken->str())
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 1866
  def always {!<=-1,!>=2}
  ? possible {"1","0"}
  "1" always "1"
  : always "0"
  "0" always "0"
  true always 1
Line 1871
  true always 1
Line 1875
  ( always {!<=-1,!>=2}
Line 1876
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1877
  return always {!<=-1,!>=2}
  false always 0
Line 1879
  argnr always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1880
  argnr {symbolic=(getArgNum(tok->str())),!<=-1}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 1881
  return always {!<=-1,!>=2}
  false always 0
Line 1884
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argnr {symbolic=(getArgNum(tok->str())),!<=-1,!>=symbolic=(args.size())}
  + always !<=0
  1U always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 1885
  return always {!<=-1,!>=2}
  true always 1
Line 1887
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  != always {!<=-1,!>=2}
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  + always !<=0
  1U always 1
Line 1890
  return always {!<=-1,!>=2}
  true always 1
Line 1893
  ( always {!<=-1,!>=2}
Line 1894
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1895
  return always {!<=-1,!>=2}
  false always 0
Line 1896
  argnr always !<=-1
  = always !<=-1
  ( always !<=-1
Line 1897
  argnr {symbolic=(getArgNum(tok->str())),!<=-1}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 1898
  return always {!<=-1,!>=2}
  false always 0
Line 1899
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argnr {symbolic=(getArgNum(tok->str())),!<=-1,!>=symbolic=(args.size())}
  + always !<=0
  1U always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 1900
  return always {!<=-1,!>=2}
  true always 1
Line 1901
  [ possible lifetime[Lambda]=(if(it!=macros.end()&&!partok->isExpandedFrom(&it->second)&&(partok->str()==name()||expandedmacros.find(partok->str())==expandedmacros.end())))
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  != always {!<=-1,!>=2}
  argnr {!<=-1,!>=symbolic=(args.size()),<=symbolic=(parametertokens.size()-2)}
  + always !<=0
  1U always 1
Line 1902
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 1903
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(partok->str()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(macros),!0}
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(partok->str())),!symbolic=(macros.end()),!end=0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  ( always !symbolic=(name())
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 1904
  it possible lifetime[Iterator]=(macros)
Line 1906
  ( always {!<=-1,!>=2}
Line 1911
  return always {!<=-1,!>=2}
  true always 1
Line 1926
  & {lifetime[Address]=(tokenListHash),!0}
Line 1928
  '\"' always 34
Line 1931
  '\"' always 34
Line 1932
  ( always {!<=-1,!>=2}
Line 1948
  output possible lifetime[Address]=(output2)@120
Line 1949
  ! always {!<=-1,!>=2}
Line 1950
  "Missing first argument" always "Missing first argument"
Line 1951
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(B->next)@120
  tok possible symbolic=(B->next)@120
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1954
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  A always !0
  ( always {!<=-1,!>=2}
  "+-*/%&|^" always "+-*/%&|^"
  || always {!<=-1,!>=2}
  A always !0
  == always {!<=-1,!>=2}
  "<<" always "<<"
  || always {!<=-1,!>=2}
  A always !0
  == always {!<=-1,!>=2}
  ">>" always ">>"
Line 1955
  canBeConcatenatedStringOrChar always {!<=-1,!>=2}
  canBeConcatenatedStringOrChar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  A always !0
  ( possible size=0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  A always !0
  ( possible size=0
Line 1956
  ! always {!<=-1,!>=2}
  A always !0
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  A always !0
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  A always !0
  != always {!<=-1,!>=2}
  ',' always 44
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  A always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  canBeConcatenatedStringOrChar {symbolic=(isStringLiteral_(A->str())||isCharLiteral_(A->str())),!<=-1,!>=2}
Line 1957
  A always !0
Line 1960
  ! {!<=-1,!>=2,1}
  B always symbolic=(tok->next->next)
  . {!<=-1,!>=2,0}
  name always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  ( always {!<=-1,!>=2}
  "#=" always "#="
Line 1961
  B always symbolic=(tok->next->next)
Line 1963
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  != always {!<=-1,!>=2}
  '=' always 61
  || always {!<=-1,!>=2}
Line 1964
  ! always {!<=-1,!>=2}
  canBeConcatenatedWithEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  B always symbolic=(tok->next->next)
  == always {!<=-1,!>=2}
  '=' always 61
Line 1965
  B always symbolic=(tok->next->next)
Line 1968
  canBeConcatenatedStringOrChar {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 1974
  canBeConcatenatedStringOrChar {!<=-1,!>=2,0}
Line 1977
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tokensB),!0}
Line 1988
  varargs always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  args {>=size=1,!<=size=0}
  args {>=size=1,!<=size=0}
  ( {>=1,!<=0}
  - {!<=-1,>=0}
  1U always 1
Line 1990
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(tokensB),!0}
Line 1991
  ( always {!<=-1,!>=2}
Line 1993
  varargs {symbolic=(variadic&&args.size()>=1U&&B->str()==args[args.size()-1U]),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ',' always 44
Line 1994
  = always ","
  "," always ","
Line 2003
  varargs {symbolic=(variadic&&args.size()>=1U&&B->str()==args[args.size()-1U]),!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
Line 2005
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 2010
  nextTok always symbolic=(B->next)
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  nextTok always symbolic=(B->next)
  == always {!<=-1,!>=2}
  '#' always 35
Line 2013
  & {lifetime[Address]=(output2),!0}
  nextTok always symbolic=(B->next)
Line 2021
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always symbolic=(nextTok)
  && always {!<=-1,!>=2}
  . always symbolic=(nextTok)
  == always {!<=-1,!>=2}
  '(' always 40
Line 2022
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 2023
  it {lifetime[Iterator]=(macros),symbolic=(macros.find(strAB))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(expandedmacros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
  && always {!<=-1,!>=2}
  it {lifetime[Iterator]=(macros),!symbolic=(macros.end()),!end=0}
Line 2024
  & {lifetime[Address]=(tokens),!0}
  . always symbolic=(nextTok)
Line 2026
  tok2 always !0
Line 2036
  nextTok possible symbolic=(B->next)
Line 2039
  ( always {!<=-1,!>=2}
Line 2041
  = {lifetime[Iterator]=(expandedmacros),start=0}
  ( {lifetime[Iterator]=(expandedmacros),start=0}
Line 2042
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()),start=0}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2043
  return always {!<=-1,!>=2}
  false always 0
Line 2044
  ++ {!symbolic=(expandedmacros.end()+1),symbolic=(expandedmacros.begin()+1)}
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()),!symbolic=(expandedmacros.end()),!end=0,start=0}
Line 2045
  return always {!<=-1,!>=2}
  it {lifetime[Iterator]=(expandedmacros),symbolic=(expandedmacros.begin()+1),!symbolic=(expandedmacros.end()+1)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expandedmacros),end=0}
Line 2055
  variadic always {!<=-1,!>=2}
Line 2073
  valueDefinedInCode_ always {!<=-1,!>=2}
Line 2083
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 2084
  cygwinPath possible size=11
  ( {!<=-1,11}
  >= {!<=-1,!>=2,1}
  11 always 11
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cygwinPath {size=11,!<=size=10}
  "/cygdrive/" always "/cygdrive/"
Line 2085
  driveLetter always !<=-1
  driveLetter always !<=-1
  = always !<=-1
  cygwinPath {size=11,!<=size=10}
  10 always 10
Line 2086
  driveLetter {symbolic=(cygwinPath[10]),!<=-1}
Line 2087
  cygwinPath always !<=size=10
  ( always !<=10
  == always {!<=-1,!>=2}
  11 always 11
Line 2088
  driveLetter {symbolic=(cygwinPath[10]),!<=-1}
Line 2089
  ":\\" always ":\\"
Line 2090
  pos always !<=-1
  = always 11
  11 always 11
Line 2091
  cygwinPath always !<=size=11
  11 always 11
  == always {!<=-1,!>=2}
  '/' always 47
Line 2092
  driveLetter always !<=-1
Line 2093
  ":" always ":"
Line 2094
  pos always !<=-1
  = always 11
  11 always 11
Line 2099
  pos {!<=-1,0,11}
  < {!<=-1,!>=2,>=0,<=1}
  cygwinPath possible {>=size=11,<=size=10}
  ( {!<=-1,>=11,<=10}
  ++ always !<=0
  pos always !<=-1
Line 2100
  c always !<=-1
  c always !<=-1
  = always !<=-1
  pos {!<=-1,<=symbolic=(cygwinPath.size()-1),!>=symbolic=(cygwinPath.size())}
Line 2101
  c {symbolic=(cygwinPath[pos]),!<=-1}
  == always {!<=-1,!>=2}
  '/' always 47
Line 2102
  c always !<=-1
  = always 92
  '\\' always 92
Line 2103
  c {symbolic=(cygwinPath[pos]),!<=-1,92}
Line 2266
  ( always {!<=-1,!>=2}
Line 2268
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  path {>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
Line 2278
  ( always {!<=-1,!>=2}
Line 2279
  path always size=0
Line 2281
  :: always !<=-1
  pos always !<=-1
Line 2284
  path always !size=0
  ( {lifetime[Iterator]=(path),!size=0,start=0}
  path always !size=0
  ( {lifetime[Iterator]=(path),!size=0,end=0}
  '\\' always 92
  '/' always 47
Line 2286
  unc {!<=-1,!>=2,0}
  path always !size=0
  0 always 0
  2 always 2
  "//" always "//"
  == always {!<=-1,!>=2}
  0 always 0
Line 2289
  pos always !<=-1
  = always 0
  0 always 0
Line 2290
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "//" always "//"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 2291
  pos always !<=-1
  1 always 1
Line 2295
  pos always !<=-1
  = always 0
  0 always 0
Line 2296
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "./" always "./"
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 2297
  pos always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  pos always !<=0
  - always !<=-1
  1U always 1
  == always {!<=-1,!>=2}
  '/' always 47
Line 2298
  pos {!<=-1,0}
  2 always 2
Line 2300
  pos always !<=0
  += always !<=-1
  2 always 2
Line 2304
  ( always {!<=-1,!>=2}
  "/." always "/."
Line 2305
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 2308
  pos always !<=-1
  = always 1
  1 always 1
Line 2309
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "/.." always "/.."
  pos {symbolic=((pos1==0)?1:(pos1-1)),!<=-1,1}
  != always {!<=-1,!>=2}
Line 2311
  pos always !<=-1
  + always !<=2
  3 always 3
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(path.size()-4),!>=symbolic=(path.size()-3)}
  + always !<=2
  3 always 3
  != always {!<=-1,!>=2}
  '/' always 47
Line 2312
  ++ {!<=0,<=symbolic=(path.size()-3),!>=symbolic=(path.size()-2)}
  pos {!<=-1,<=symbolic=(path.size()-4),!>=symbolic=(path.size()-3)}
Line 2316
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  '/' always 47
  pos {!<=-1,>=symbolic=(path.size()-3)}
  - always !<=-1
  1U always 1
Line 2317
  pos1 always !<=-1
  == always {!<=-1,!>=2}
Line 2318
  pos1 always !<=-1
  = always 0
  0 always 0
Line 2320
  pos1 always !<=-1
  += always !<=-1
  1U always 1
Line 2322
  pos1 {!<=-1,0}
  pos always !<=-1
  - always !<=-1
  pos1 {!<=-1,0}
Line 2323
  == always {!<=-1,!>=2}
  ".." always ".."
Line 2325
  ++ always !<=0
  pos always !<=-1
Line 2328
  pos1 always !<=-1
  pos always !<=-1
  - always !<=-1
  pos1 always !<=-1
  + always !<=3
  4 always 4
Line 2329
  ( always {!<=-1,!>=2}
Line 2330
  = always "."
  "." always "."
Line 2332
  pos always !<=-1
  = {1,!<=-1}
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  ? {1,!<=-1}
  1 always 1
  : always 1
  pos1 always !<=0
  - always !<=-1
  1 always 1
Line 2340
  unc always {!<=-1,!>=2}
Line 2341
  '/' always 47
Line 2343
  ( always !<=-1
  "*?" always "*?"
  == always {!<=-1,!>=2}
Line 2350
  = possible symbolic=(tok2)
  . possible symbolic=(tok2)
Line 2351
  != always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 2354
  ! {!<=-1,!>=2,1}
  tok1 {symbolic=(tok->next),0}
Line 2355
  "missing sizeof argument" always "missing sizeof argument"
Line 2357
  tok1 {symbolic=(tok->next),!0}
Line 2358
  ! {!<=-1,!>=2,1}
  tok2 {symbolic=(tok1->next),0}
Line 2359
  "missing sizeof argument" always "missing sizeof argument"
Line 2361
  tok1 always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 2362
  = {symbolic=(tok2),!0}
  tok1 always !0
  . {symbolic=(tok2),!0}
Line 2363
  tok2 possible symbolic=(tok1)
  != always {!<=-1,!>=2}
  ')' always 41
Line 2365
  ! always {!<=-1,!>=2}
Line 2366
  "invalid sizeof expression" always "invalid sizeof expression"
Line 2372
  != always {!<=-1,!>=2}
Line 2373
  ( possible {size=6,size=1}
  == {!<=-1,!>=2,0}
  "unsigned" always "unsigned"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "signed" always "signed"
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2375
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always !<=-1
  '*' always 42
  != always {!<=-1,!>=2}
Line 2377
  ! {!<=-1,!>=2,0}
  type possible size=0
  ( {!<=-1,!>=2,1}
Line 2378
  ' ' always 32
Line 2382
  :: possible {symbolic=(sizeOfType.end()),end=0}
  it possible {symbolic=(sizeOfType.end()),end=0}
  = possible lifetime[Iterator]=(sizeOfType)
  ( possible lifetime[Iterator]=(sizeOfType)
  type possible size=0
Line 2383
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(sizeOfType),end=0}
Line 2384
  it always !end=0
Line 2389
  != always {!<=-1,!>=2}
Line 2394
  8 always 8
  "and" always "and"
  "or" always "or"
  "bitand" always "bitand"
  "bitor" always "bitor"
  "compl" always "compl"
  "not" always "not"
  "not_eq" always "not_eq"
  "xor" always "xor"
Line 2395
  & always !0
  altopData always {
  0 always 0
  & always !0
  altopData always {
  8 always 8
Line 2399
  . always {!<=-1,!>=2}
  name always {!<=-1,!>=2}
Line 2400
  ( possible lifetime[Iterator]=(altop)
  ( possible {size=3,size=5}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(altop),end=0}
Line 2401
  alt always {!<=-1,!>=2}
Line 2402
  ( possible size=5
  == {!<=-1,!>=2,0}
  "not" always "not"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "compl" always "compl"
Line 2403
  alt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( possible {size=3,size=5}
Line 2405
  alt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2407
  alt always {!<=-1,!>=2}
Line 2410
  "0" always "0"
Line 2423
  ( always !<=-1
Line 2425
  pos always !<=-1
  , always 0
Line 2426
  = always 0
  0 always 0
  , always 1
Line 2427
  = always 1
  1 always 1
  , always !<=-1
Line 2428
  maxlen always !<=-1
  = always !<=-1
Line 2431
  pos always !<=-1
  maxlen {!<=-1,3@48,symbolic=(escape=='u'?4:8)@50,4@50,8@50}
Line 2432
  = {lifetime[Object]=(sub),!0}
  ( {lifetime[Object]=(sub),!0}
Line 2434
  value always !<=-1
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
  & {lifetime[Address]=(end),!0,Uninit*}
  end always Uninit
  base possible {8@48,16@49,0}
Line 2435
  pos always !<=-1
  += always !<=-1
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
Line 2436
  start {lifetime[Object]=(sub),symbolic=(sub.c_str()),!0}
  < always {!<=-1,!>=2}
  minlen possible {1@48,symbolic=(escape=='u'?4:8)@50,4@50}
Line 2437
  "expected digit" always "expected digit"
Line 2438
  return always !<=-1
  value always !<=-1
Line 2472
  narrow {!<=-1,!>=2,0}
  narrow always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2473
  utf8 {!<=-1,!>=2,0}
  utf8 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2474
  utf16 {!<=-1,!>=2,0}
  utf16 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2476
  pos always !<=-1
Line 2478
  str possible {>=size=2,<=size=1}
  ( {!<=-1,>=2,<=1}
  >= {!<=-1,!>=2,>=1}
  1 always 1
  && always {!<=-1,!>=2}
  str {>=size=2,<=size=1,!<=size=0}
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2479
  narrow always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2480
  pos always !<=-1
  = always 1
  1 always 1
Line 2481
  str possible {>=size=3,<=size=2}
  ( {!<=-1,>=3,<=2}
  >= {!<=-1,!>=2,>=1}
  2 always 2
  && always {!<=-1,!>=2}
  str {>=size=3,<=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  'u' always 117
  && always {!<=-1,!>=2}
  str {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2482
  utf16 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2483
  pos always !<=-1
  = always 2
  2 always 2
Line 2484
  str possible {>=size=2,<=size=1}
  ( {!<=-1,>=2,<=1}
  >= {!<=-1,!>=2,>=0}
  3 always 3
  && always {!<=-1,!>=2}
  str {>=size=3,!<=size=2}
  0 always 0
  == always {!<=-1,!>=2}
  'u' always 117
  && always {!<=-1,!>=2}
  str {>=size=3,!<=size=2}
  1 always 1
  == always {!<=-1,!>=2}
  '8' always 56
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2485
  utf8 always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2486
  pos always !<=-1
  = always 3
  3 always 3
Line 2487
  str possible <=size=2
  ( {!<=-1,<=2}
  >= {!<=-1,!>=2,<=1}
  2 always 2
  && always {!<=-1,!>=2}
  str {<=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  'L' always 76
  || always {!<=-1,!>=2}
  str always !<=size=1
  0 always 0
  == always {!<=-1,!>=2}
  'U' always 85
  && always {!<=-1,!>=2}
  str {>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '\'' always 39
Line 2488
  pos always !<=-1
  = always 2
  2 always 2
Line 2490
  "expected a character literal" always "expected a character literal"
Line 2492
  multivalue always !<=-1
  multivalue always !<=-1
  = always 0
  0 always 0
Line 2494
  nbytes always !<=-1
  nbytes always !<=-1
  = always 0
  0 always 0
Line 2496
  pos {!<=-1,1,2,3}
  + {!<=0,2,3,4}
  1 always 1
  < {!<=-1,!>=2,>=0}
  str possible >=size=1
  ( {!<=-1,>=1}
Line 2497
  [ possible 10
  pos {!<=-1,<=symbolic=(str.size()-2),!>=symbolic=(str.size()-1)}
  == {!<=-1,!>=2,0}
  '\'' always 39
  || always {!<=-1,!>=2}
  pos always {!<=-1,!>=symbolic=(str.size()-1)}
  == always {!<=-1,!>=2}
  '\n' always 10
Line 2498
  "raw single quotes and newlines not allowed in character literals" always "raw single quotes and newlines not allowed in character literals"
Line 2500
  nbytes always !<=-1
  >= always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  narrow always {!<=-1,!>=2}
Line 2501
  "multiple characters only supported in narrow character literals" always "multiple characters only supported in narrow character literals"
Line 2503
  value always !<=-1
Line 2505
  [ always {!39,!10}
  pos {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
  == always {!<=-1,!>=2}
  '\\' always 92
Line 2506
  pos {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
  ++ {!<=-1,>=symbolic=(str.size()-2),<=symbolic=(str.size()-3)}
Line 2507
  pos {!<=-1,>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
  ++ {!<=-1,>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
Line 2509
  pos always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2510
  "unexpected end of character literal" always "unexpected end of character literal"
Line 2514
  '%' always 37
Line 2515
  '(' always 40
Line 2516
  '[' always 91
Line 2517
  '{' always 123
Line 2519
  '\'' always 39
Line 2520
  '"' always 34
Line 2521
  '?' always 63
Line 2522
  '\\' always 92
Line 2523
  value always !<=-1
  = always !<=-1
  ( always !<=-1
Line 2526
  'a' always 97
Line 2527
  value always !<=-1
  = always 7
  ( always 7
  '\a' always 7
Line 2529
  'b' always 98
Line 2530
  value always !<=-1
  = always 8
  ( always 8
  '\b' always 8
Line 2532
  'f' always 102
Line 2533
  value always !<=-1
  = always 12
  ( always 12
  '\f' always 12
Line 2535
  'n' always 110
Line 2536
  value always !<=-1
  = always 10
  ( always 10
  '\n' always 10
Line 2538
  'r' always 114
Line 2539
  value always !<=-1
  = always 13
  ( always 13
  '\r' always 13
Line 2541
  't' always 116
Line 2542
  value always !<=-1
  = always 9
  ( always 9
  '\t' always 9
Line 2544
  'v' always 118
Line 2545
  value always !<=-1
  = always 11
  ( always 11
  '\v' always 11
Line 2549
  'e' always 101
Line 2550
  'E' always 69
Line 2551
  value always !<=-1
  = always 27
  ( always 27
  '\x1b' always 27
Line 2554
  '0' always 48
Line 2555
  '1' always 49
Line 2556
  '2' always 50
Line 2557
  '3' always 51
Line 2558
  '4' always 52
Line 2559
  '5' always 53
Line 2560
  '6' always 54
Line 2561
  '7' always 55
Line 2563
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  -- always !<=-1
  pos always !<=-1
  8 always 8
  1 always 1
  3 always 3
Line 2566
  'x' always 120
Line 2568
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  16 always 16
Line 2571
  'u' always 117
Line 2572
  'U' always 85
Line 2574
  ndigits always !<=-1
  ndigits always !<=-1
  = {4,8,!<=-1}
  == always {!<=-1,!>=2}
  'u' always 117
  ? possible {4,8}
  4 always 4
  : always 8
  8 always 8
Line 2575
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  16 always 16
  ndigits {symbolic=(escape=='u'?4:8),!<=-1,4,8}
  ndigits {symbolic=(escape=='u'?4:8),!<=-1,4,8}
Line 2579
  narrow always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x7f always 127
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0xffff always 65535
  || always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x10ffff always 1114111
Line 2580
  "code point too large" always "code point too large"
Line 2582
  value {!<=-1,<=57343,>=57344,!>=1114112,<=1114111}
  >= {!<=-1,!>=2,<=1}
  0xd800 always 55296
  && always {!<=-1,!>=2}
  value {!>=1114112,<=1114111,>=55296,!<=55295}
  <= {!<=-1,!>=2,<=0,>=1}
  0xdfff always 57343
Line 2583
  "surrogate code points not allowed in universal character names" always "surrogate code points not allowed in universal character names"
Line 2589
  "invalid escape sequence" always "invalid escape sequence"
Line 2592
  value always !<=-1
  = always !<=-1
  ( always !<=-1
  pos always !<=-1
  ++ always !<=-1
Line 2594
  ! always {!<=-1,!>=2}
  narrow always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  >= always {!<=-1,!>=2}
  0x80 always 128
Line 2600
  value {>=240,<=239,>=224,<=223,>=194,<=193,>=128,!<=127}
  >= {!<=-1,!>=2,>=0}
  0xf5 always 245
Line 2601
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2602
  value {>=224,<=223,>=194,<=193,>=128,!<=127,!>=245,<=244}
  >= {!<=-1,!>=2,>=0,<=1}
  0xf0 always 240
Line 2603
  = always 3
  3 always 3
Line 2604
  value {>=194,<=193,>=128,!<=127,!>=240,<=239}
  >= {!<=-1,!>=2,>=0,<=1}
  0xe0 always 224
Line 2605
  = always 2
  2 always 2
Line 2606
  value {>=128,!<=127,!>=224,<=223}
  >= {!<=-1,!>=2,>=0,<=1}
  0xc2 always 194
Line 2607
  = always 1
  1 always 1
Line 2609
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2611
  value always !<=-1
  &= always !<=-1
  1 always 1
  << possible {8,16,32}
  6 always 6
  - possible {3,4,5}
  additional_bytes possible {3,2,1}
  - possible {7,15,31}
  1 always 1
Line 2613
  additional_bytes possible {3,2,1}
  -- possible {3,2,1}
Line 2614
  pos always !<=-1
  + always !<=0
  1 always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2615
  "assumed UTF-8 encoded source, but character literal ends unexpectedly" always "assumed UTF-8 encoded source, but character literal ends unexpectedly"
Line 2617
  c always !<=-1
  c always !<=-1
  = always !<=-1
  pos {!<=-1,!>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
  ++ {!<=-1,!>=symbolic=(str.size()-1),<=symbolic=(str.size()-2)}
Line 2619
  c always !<=-1
  6 always 6
  != always {!<=-1,!>=2}
  2 always 2
Line 2620
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  value always !<=-1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  c always !<=-1
  < always {!<=-1,!>=2}
  0xa0 always 160
Line 2621
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  value always !<=-1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  c always !<=-1
  < always {!<=-1,!>=2}
  0x90 always 144
Line 2622
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2624
  value always !<=-1
  = always !<=-1
  value always !<=-1
  << always !<=-1
  6 always 6
  | always !<=-1
  c always !<=-1
  1 always 1
  << always 128
  7 always 7
  - always 127
  1 always 1
Line 2627
  value {!<=-1,<=57343,>=57344}
  >= {!<=-1,!>=2,<=1}
  0xd800 always 55296
  && always {!<=-1,!>=2}
  value {>=55296,!<=55295}
  <= {!<=-1,!>=2,>=1}
  0xdfff always 57343
Line 2628
  "assumed UTF-8 encoded source, but sequence is invalid" always "assumed UTF-8 encoded source, but sequence is invalid"
Line 2630
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x7f always 127
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0xffff always 65535
  || always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  0x10ffff always 1114111
Line 2631
  "code point too large" always "code point too large"
Line 2635
  narrow always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf8 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  utf16 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  value always !<=-1
  >> always !<=-1
  16 always 16
  || always {!<=-1,!>=2}
  value always !<=-1
  >> always !<=-1
  32 always 32
Line 2636
  "numeric escape sequence too large" always "numeric escape sequence too large"
Line 2638
  multivalue always !<=-1
  <<= always !<=-1
Line 2639
  multivalue always !<=-1
  |= always !<=-1
  value always !<=-1
Line 2640
  nbytes always !<=-1
  ++ always !<=-1
Line 2643
  pos {!<=-1,<=symbolic=(str.size()-2),>=symbolic=(str.size()-1),1,2,3}
  + {!<=0,2,3,4}
  1 always 1
  != always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(pos+1+1),<=symbolic=(pos+1)}
  || always {!<=-1,!>=2}
  pos {!<=-1,symbolic=(str.size()-1)}
  != always {!<=-1,!>=2}
  '\'' always 39
Line 2644
  "missing closing quote in character literal" always "missing closing quote in character literal"
Line 2646
  ! {!<=-1,!>=2,0}
  nbytes {!<=-1,1}
Line 2647
  "empty character literal" always "empty character literal"
Line 2650
  narrow {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  nbytes always !<=0
  == always {!<=-1,!>=2}
  1 always 1
Line 2651
  multivalue always !<=-1
Line 2654
  narrow {!<=-1,!>=2,0}
Line 2655
  multivalue always !<=-1
Line 2659
  multivalue always !<=-1
Line 2665
  ( always !<=-1
  == always {!<=-1,!>=2}
  1U always 1
Line 2667
  ( always !size=1
  0 always 0
  2 always 2
  "0x" always "0x"
  == always {!<=-1,!>=2}
  0 always 0
Line 2668
  ( always !<=-1
Line 2669
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  '\'' always 39
  != always {!<=-1,!>=2}
Line 2681
  ( possible symbolic=(expr.cback())
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( {!0,symbolic=(expr.cback())}
  . always {!<=-1,!>=2}
  number always {!<=-1,!>=2}
  ( {symbolic=(expr.cback()),!0}
  : always 0
  0LL always 0
Line 2686
  line always !<=-1
  = always !<=-1
  . always !<=-1
  line always !<=-1
Line 2687
  file always !<=-1
  = always !<=-1
  . always !<=-1
  fileIndex always !<=-1
Line 2688
  && always {!<=-1,!>=2}
  tok always !0
  . {symbolic=(line),!<=-1}
  line always !<=-1
  == {!<=-1,!>=2,1}
  line {symbolic=(tok->location.line),!<=-1}
  && always {!<=-1,!>=2}
  tok always !0
  . {symbolic=(file),!<=-1}
  fileIndex always !<=-1
  == {!<=-1,!>=2,1}
  file {symbolic=(tok->location.fileIndex),!<=-1}
Line 2689
  tok always !0
Line 2690
  tok possible 0
Line 2739
  ( {lifetime[Object]=(path),!0}
Line 2740
  : always ""
  "" always ""
Line 2746
  ( always !<=-1
  "\\/" always "\\/"
  != always {!<=-1,!>=2}
Line 2747
  0 always 0
  ( always !<=-1
  "\\/" always "\\/"
  + always !<=0
  1U always 1
Line 2759
  ! {!<=-1,!>=2,0}
  path {symbolic=(includePath),size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  path {symbolic=(includePath),!size=0}
  path {symbolic=(includePath),!size=0}
  ( always !<=0
  - always !<=-1
  1U always 1
  != always {!<=-1,!>=2}
  '/' always 47
  && always {!<=-1,!>=2}
  path {symbolic=(includePath),!size=0}
  path {symbolic=(includePath),!size=0}
  ( always !<=0
  - always !<=-1
  1U always 1
  != always {!<=-1,!>=2}
  '\\' always 92
Line 2760
  path always symbolic=(includePath)
  '/' always 47
Line 2761
  path possible symbolic=(includePath)
Line 2766
  = {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  ( {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  it possible {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),end=0}
Line 2767
  it {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),!symbolic=(dui.includePaths.end()),!end=0}
Line 2768
  ! {!<=-1,!>=2,0}
  simplePath possible size=0
  ( {!<=-1,!>=2,1}
Line 2769
  simplePath always !size=0
Line 2771
  "" always ""
Line 2774
  , always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2776
  ( always {!<=-1,!>=2}
Line 2781
  systemheader always {!<=-1,!>=2}
Line 2783
  ( always {!<=-1,!>=2}
  ret always !size=0
Line 2787
  ( always {!<=-1,!>=2}
  ret always !size=0
Line 2790
  , always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2792
  ( always {!<=-1,!>=2}
Line 2793
  "" always ""
Line 2795
  ( always {!<=-1,!>=2}
Line 2796
  filedata always !size=0
  ( {lifetime[Iterator]=(filedata),!size=0}
  != always {!<=-1,!>=2}
  filedata always !size=0
  ( {lifetime[Iterator]=(filedata),!size=0,end=0}
  : always ""
  "" always ""
Line 2800
  ! always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  filedata always !size=0
  ( {lifetime[Iterator]=(filedata),!size=0}
  relativeFilename always symbolic=(getRelativeFileName(sourcefile,header))
  != always {!<=-1,!>=2}
  filedata always !size=0
  ( {lifetime[Iterator]=(filedata),!size=0,end=0}
Line 2803
  = {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  ( {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  it possible {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),end=0}
Line 2804
  it {lifetime[Iterator]=(dui.includePaths),lifetime[Object]=(includePaths),!symbolic=(dui.includePaths.end()),!end=0}
Line 2805
  ( possible lifetime[Iterator]=(filedata)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filedata),end=0}
Line 2809
  ( possible lifetime[Iterator]=(filedata)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filedata),end=0}
Line 2812
  "" always ""
Line 2815
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2817
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2827
  != always {!<=-1,!>=2}
Line 2830
  ( possible lifetime[Iterator]=(ret)
  filename always symbolic=(*it)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(ret),end=0}
Line 2833
  filename inconclusive symbolic=(*it)
  ( {lifetime[Object]=(*it),!0}
Line 2834
  ! always {!<=-1,!>=2}
Line 2837
  = always 7
  :: always 7
  EXPLICIT_INCLUDE_NOT_FOUND always 7
Line 2839
  "Can not open include file '" always "Can not open include file '"
  "' that is explicitly included." always "' that is explicitly included."
Line 2846
  ! always {!<=-1,!>=2}
  tokenlist always size=0
Line 2852
  tokenlist always symbolic=(ret[filename])
Line 2855
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  = possible 0
  ? possible 0
  : always 0
  nullptr always 0
Line 2856
  == always {!<=-1,!>=2}
  nullptr always 0
Line 2861
  != always {!<=-1,!>=2}
  '#' always 35
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2865
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  rawtok always !0
  != always {!<=-1,!>=2}
Line 2868
  rawtok always !0
Line 2870
  rawtok always !0
Line 2871
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rawtok always !0
Line 2874
  systemheader always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 2875
  1U always 1
  2U always 2
Line 2876
  ( always {!<=-1,!>=2}
  systemheader always {!<=-1,!>=2}
Line 2880
  systemheader always {!<=-1,!>=2}
Line 2881
  ! always {!<=-1,!>=2}
Line 2885
  = always size=0
  tokens always size=0
Line 2886
  tokens always {symbolic=(ret[header2]),size=0}
Line 2887
  tokens always symbolic=(ret[header2])
Line 2893
  ( always {!<=-1,!>=2}
Line 2896
  :: possible {symbolic=(macros.end()),end=0}
  it possible {symbolic=(macros.end()),end=0}
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
  tok always symbolic=(*tok1)
Line 2897
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 2900
  it always !end=0
  & {lifetime[Address]=(value),!0}
Line 2906
  "failed to expand \'" always "failed to expand \'"
  "\', " always "\', "
Line 2907
  outputList always !0
Line 2909
  return always {!<=-1,!>=2}
  false always 0
Line 2913
  ! always {!<=-1,!>=2}
  tok always symbolic=(*tok1)
  . always {!<=-1,!>=2}
  comment always {!<=-1,!>=2}
Line 2915
  tok possible symbolic=(*tok1)
Line 2917
  return always {!<=-1,!>=2}
  true always 1
Line 2922
  & {lifetime[Address]=(t),!0,Uninit*}
  t always Uninit
Line 2924
  & {lifetime[Address]=(t),!0}
  & {lifetime[Address]=(ltime),!0}
Line 2931
  12 always 12
  = always "??? ?? ????"
  "??? ?? ????" always "??? ?? ????"
Line 2932
  ( always !<=-1
  sizeof always 12
  ( always 12
  "%b %d %Y" always "%b %d %Y"
Line 2933
  "\"" always "\""
  "\"" always "\""
Line 2937
  9 always 9
  = always "??:??:??"
  "??:??:??" always "??:??:??"
Line 2938
  ( always !<=-1
  sizeof always 9
  ( always 9
  "%T" always "%T"
Line 2939
  "\"" always "\""
  "\"" always "\""
Line 2945
  "char" always "char"
  ( always 1
Line 2946
  sizeOfType always !size=0
  "short" always "short"
  ( always 2
Line 2947
  sizeOfType always {!size=1,!size=0}
  "short int" always "short int"
  sizeOfType always {!size=2,!size=1}
  [ always !<=-1
  "short" always "short"
Line 2948
  sizeOfType always !size=0
  "int" always "int"
  ( always 4
Line 2949
  sizeOfType always {!size=1,!size=0}
  "long" always "long"
  ( always 8
Line 2950
  sizeOfType always {!size=2,!size=1,!size=0}
  "long int" always "long int"
  sizeOfType always {!size=3,!size=2,!size=1}
  [ always !<=-1
  "long" always "long"
Line 2951
  sizeOfType always !size=0
  "long long" always "long long"
  ( always 8
Line 2952
  sizeOfType always {!size=1,!size=0}
  "float" always "float"
  ( always 4
Line 2953
  sizeOfType always {!size=2,!size=1,!size=0}
  "double" always "double"
  ( always 8
Line 2954
  sizeOfType always {!size=3,!size=2,!size=1,!size=0}
  "long double" always "long double"
  ( always 16
Line 2955
  sizeOfType always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "char *" always "char *"
  ( always 8
Line 2956
  sizeOfType always {!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "short *" always "short *"
  ( always 8
Line 2957
  sizeOfType always {!size=6,!size=5,!size=4,!size=3,!size=2,!size=1,!size=0}
  "short int *" always "short int *"
  sizeOfType always {!size=7,!size=6,!size=5,!size=4,!size=3,!size=2,!size=1}
  [ always !<=-1
  "short *" always "short *"
Line 2958
  sizeOfType always !size=0
  "int *" always "int *"
  ( always 8
Line 2959
  sizeOfType always {!size=1,!size=0}
  "long *" always "long *"
  ( always 8
Line 2960
  sizeOfType always {!size=2,!size=1,!size=0}
  "long int *" always "long int *"
  sizeOfType always {!size=3,!size=2,!size=1}
  [ always !<=-1
  "long *" always "long *"
Line 2961
  sizeOfType always !size=0
  "long long *" always "long long *"
  ( always 8
Line 2962
  sizeOfType always {!size=1,!size=0}
  "float *" always "float *"
  ( always 8
Line 2963
  sizeOfType always {!size=2,!size=1,!size=0}
  "double *" always "double *"
  ( always 8
Line 2964
  sizeOfType always {!size=3,!size=2,!size=1,!size=0}
  "long double *" always "long double *"
  ( always 8
Line 2966
  hasInclude always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  5 always 5
  && always {!<=-1,!>=2}
  0 always 0
  3 always 3
  "c++" always "c++"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 2968
  != always {!<=-1,!>=2}
Line 2970
  eq always !<=-1
  = always !<=-1
  macrostr always symbolic=(*it)
  ( always !<=-1
  '=' always 61
Line 2971
  par always !<=-1
  = always !<=-1
  macrostr always symbolic=(*it)
  ( always !<=-1
  '(' always 40
Line 2972
  macrostr always symbolic=(*it)
  0 always 0
  eq always !<=-1
  par always !<=-1
Line 2973
  != always {!<=-1,!>=2}
Line 2975
  macrostr always symbolic=(*it)
  0 always 0
  eq always !<=-1
Line 2976
  eq always !<=-1
  == always {!<=-1,!>=2}
  "1" always "1"
  macrostr always symbolic=(*it)
  eq always !<=-1
  + always !<=0
  1 always 1
Line 2981
  "__FILE__" always "__FILE__"
  "__FILE__" always "__FILE__"
  "__FILE__" always "__FILE__"
Line 2982
  macros always !size=0
  "__LINE__" always "__LINE__"
  "__LINE__" always "__LINE__"
  "__LINE__" always "__LINE__"
Line 2983
  macros always {!size=1,!size=0}
  "__COUNTER__" always "__COUNTER__"
  "__COUNTER__" always "__COUNTER__"
  "__COUNTER__" always "__COUNTER__"
Line 2986
  macros always {!size=2,!size=1,!size=0}
  "__DATE__" always "__DATE__"
  "__DATE__" always "__DATE__"
  & {lifetime[Address]=(ltime),!0}
Line 2987
  macros always {!size=3,!size=2,!size=1,!size=0}
  "__TIME__" always "__TIME__"
  "__TIME__" always "__TIME__"
  & {lifetime[Address]=(ltime),!0}
Line 2989
  ! always {!<=-1,!>=2}
Line 2991
  ! {!<=-1,!>=2,0}
  std_def {symbolic=(simplecpp::getCStdString(dui.std)),size=0}
  ( {!<=-1,!>=2,1}
Line 2992
  macros always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "__STDC_VERSION__" always "__STDC_VERSION__"
  "__STDC_VERSION__" always "__STDC_VERSION__"
  std_def always !size=0
Line 2995
  ! {!<=-1,!>=2,0}
  std_def {symbolic=(simplecpp::getCppStdString(dui.std)),size=0}
  ( {!<=-1,!>=2,1}
Line 2996
  macros always {!size=4,!size=3,!size=2,!size=1,!size=0}
  "__cplusplus" always "__cplusplus"
  "__cplusplus" always "__cplusplus"
  std_def always !size=0
Line 3003
  TRUE always 0
  ELSE_IS_TRUE always 1
  ALWAYS_FALSE always 2
Line 3005
  ifstates always size=0
  TRUE always 0
Line 3011
  includetokenstack always size=0
Line 3012
  != always {!<=-1,!>=2}
Line 3014
  != always {!<=-1,!>=2}
Line 3020
  = always 0
  nullptr always 0
  rawtok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3021
  == always {!<=-1,!>=2}
  nullptr always 0
Line 3027
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3028
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3033
  ! always {!<=-1,!>=2}
Line 3038
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3043
  "#" always "#"
  " without #if" always " without #if"
Line 3050
  ( possible {0,2,1}
  == {!<=-1,!>=2,1,0}
  TRUE always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3053
  == always {!<=-1,!>=2}
Line 3055
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 3056
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  0 always 0
Line 3057
  ' ' always 32
Line 3060
  '#' always 35
  ' ' always 32
Line 3063
  == always {!<=-1,!>=2}
Line 3069
  == always {!<=-1,!>=2}
Line 3070
  != always {!<=-1,!>=2}
  TRUE always 0
Line 3074
  == always {!<=-1,!>=2}
Line 3075
  = possible lifetime[Iterator]=(macros)
  ( possible lifetime[Iterator]=(macros)
Line 3076
  it possible lifetime[Iterator]=(macros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 3079
  it {lifetime[Iterator]=(macros),!symbolic=(macros.end()),!end=0}
Line 3086
  = always "Failed to parse #define"
  "Failed to parse #define" always "Failed to parse #define"
Line 3092
  ( possible {2,1,0}
  == {!<=-1,!>=2,0,1}
  TRUE always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3094
  ( always {!<=-1,!>=2}
Line 3095
  ! always {!<=-1,!>=2}
Line 3099
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3101
  ! always {!<=-1,!>=2}
  & {lifetime[Address]=(inctok),!0}
Line 3109
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '>' always 62
Line 3116
  inc2 always NonMovedVariable
Line 3117
  inc2 always NonMovedVariable
  hdr possible size=0
Line 3118
  = always 60
  '<' always 60
Line 3121
  || always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  2U always 2
Line 3126
  = always "No header in #include"
  "No header in #include" always "No header in #include"
Line 3135
  systemheader always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '<' always 60
Line 3136
  1U always 1
  2U always 2
Line 3137
  systemheader {symbolic=(inctok->op=='<'),!<=-1,!>=2}
Line 3138
  ( always {!<=-1,!>=2}
Line 3141
  systemheader {symbolic=(inctok->op=='<'),!<=-1,!>=2}
Line 3144
  = always size=0
  tokens always size=0
Line 3147
  ( always {!<=-1,!>=2}
Line 3152
  "Header not found: " always "Header not found: "
Line 3155
  ( always !<=-1
  >= always {!<=-1,!>=2}
  400 always 400
Line 3160
  = always "#include nested too deeply"
  "#include nested too deeply" always "#include nested too deeply"
Line 3163
  ( possible lifetime[Iterator]=(pragmaOnce)
  header2 always !size=0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(pragmaOnce),end=0}
Line 3164
  includetokenstack always !>=size=400
Line 3166
  = possible 0
  ? possible 0
  includetokens always !0
  : always 0
  nullptr always 0
Line 3169
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3170
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3175
  "Syntax error in #" always "Syntax error in #"
Line 3182
  conditionIsTrue always {!<=-1,!>=2}
Line 3183
  ( possible {1,0}
  == {!<=-1,!>=2,0}
  ALWAYS_FALSE always 2
  || always {!<=-1,!>=2}
  ( {0,1,!2}
  == {!<=-1,!>=2,0,1}
  ELSE_IS_TRUE always 1
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 3184
  conditionIsTrue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3185
  == always {!<=-1,!>=2}
Line 3186
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  || always {!<=-1,!>=2}
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3188
  == always {!<=-1,!>=2}
Line 3189
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(macros)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3193
  && always {!<=-1,!>=2}
  tok always !0
  tok possible symbolic=(tmp->previous)
Line 3194
  ! always {!<=-1,!>=2}
Line 3199
  == always {!<=-1,!>=2}
Line 3201
  par always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 3202
  par {symbolic=(tok&&tok->op=='('),!<=-1,!>=2,0}
Line 3206
  ( possible lifetime[Iterator]=(macros)
  tok always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
Line 3207
  "1" always "1"
  tok always !0
Line 3208
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 3209
  "1" always "1"
  tok always !0
Line 3211
  "0" always "0"
  tok always !0
Line 3213
  par {!<=-1,!>=2,0}
Line 3214
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 3215
  ! {!<=-1,!>=2,1}
  tok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  par always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 3220
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3229
  hasInclude always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3231
  par always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  '(' always 40
Line 3232
  par {symbolic=(tok&&tok->op=='('),!<=-1,!>=2,0}
Line 3236
  systemheader always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok always !0
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 3237
  tok always !0
  1U always 1
  tok always !0
  2U always 2
Line 3239
  systemheader always {!<=-1,!>=2}
Line 3240
  ( always {!<=-1,!>=2}
  "0" always "0"
  : always "1"
  "1" always "1"
  tok always !0
Line 3242
  par {!<=-1,!>=2,0}
Line 3243
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 3244
  ! {!<=-1,!>=2,1}
  tok possible 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  par always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ')' always 41
Line 3249
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3261
  ! always {!<=-1,!>=2}
  & {lifetime[Address]=(tmp),!0}
  tmp {symbolic=(tok),0}
Line 3265
  ! always {!<=-1,!>=2}
Line 3267
  tmp always !0
Line 3273
  ( always {!<=-1,!>=2}
  "" always ""
  : always " "
  " " always " "
Line 3275
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 3276
  E possible size=0
Line 3279
  conditionIsTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 3286
  "failed to evaluate " always "failed to evaluate "
  == always {!<=-1,!>=2}
  "#if" always "#if"
  : always "#elif"
  "#elif" always "#elif"
  " condition" always " condition"
Line 3287
  && always {!<=-1,!>=2}
Line 3288
  ", " always ", "
Line 3296
  != always {!<=-1,!>=2}
Line 3298
  != always {!<=-1,!>=2}
  TRUE always 0
Line 3299
  ALWAYS_FALSE always 2
Line 3301
  conditionIsTrue always {!<=-1,!>=2}
  ? possible {0,1}
  TRUE always 0
  : always 1
  ELSE_IS_TRUE always 1
Line 3302
  ( possible 1
  == {!<=-1,!>=2,0}
  TRUE always 0
Line 3303
  = always 2
  ALWAYS_FALSE always 2
Line 3304
  ( always !0
  == always {!<=-1,!>=2}
  ELSE_IS_TRUE always 1
  && always {!<=-1,!>=2}
  conditionIsTrue always {!<=-1,!>=2}
Line 3305
  = always 0
  TRUE always 0
Line 3307
  == always {!<=-1,!>=2}
Line 3308
  == always {!<=-1,!>=2}
  ELSE_IS_TRUE always 1
  TRUE always 0
  : always 2
  ALWAYS_FALSE always 2
Line 3309
  == always {!<=-1,!>=2}
Line 3311
  == always {!<=-1,!>=2}
Line 3312
  == always {!<=-1,!>=2}
  TRUE always 0
Line 3314
  ( always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
  && always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
Line 3316
  ( always {!<=-1,!>=2}
  tok possible symbolic=(rawtok->next)
Line 3319
  == always {!<=-1,!>=2}
  TRUE always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3326
  != always {!<=-1,!>=2}
  TRUE always 0
Line 3332
  hash {!<=-1,!>=2,0}
  hash always {!<=-1,!>=2}
  = always 0
  false always 0
  hashhash {!<=-1,!>=2,0}
  hashhash always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3333
  == always {!<=-1,!>=2}
  '#' always 35
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3334
  != always {!<=-1,!>=2}
  '#' always 35
Line 3335
  hash always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3337
  ( always {!<=-1,!>=2}
Line 3338
  hashhash always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3346
  ! always {!<=-1,!>=2}
  & {lifetime[Address]=(rawtok),!0}
  rawtok possible 0
Line 3351
  hash {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  hashhash always {!<=-1,!>=2}
Line 3355
  hash always {!<=-1,!>=2}
Line 3356
  '\"' always 34
  '\"' always 34
Line 3367
  = {lifetime[Iterator]=(macros),start=0}
  ( {lifetime[Iterator]=(macros),start=0}
  macroIt possible {lifetime[Iterator]=(macros),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(macros),end=0}
  macroIt possible lifetime[Iterator]=(macros)
Line 3368
  macroIt possible lifetime[Iterator]=(macros)
Line 3369
  macro always symbolic=(macroIt->second)
Line 3371
  ( possible lifetime[Iterator]=(usage)
  ( {lifetime[Iterator]=(usage),end=0}
  ( {lifetime[Iterator]=(maybeUsedMacros[macro.name()]),lifetime[Object]=(maybeUsedMacros),start=0}
  ( {lifetime[Iterator]=(maybeUsedMacros[macro.name()]),lifetime[Object]=(maybeUsedMacros),end=0}
Line 3372
  = {lifetime[Iterator]=(usage),start=0}
  ( {lifetime[Iterator]=(usage),start=0}
  usageIt possible {lifetime[Iterator]=(usage),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(usage),end=0}
Line 3373
  usageIt possible lifetime[Iterator]=(usage)
Line 3385
  = {lifetime[Iterator]=(filedata),start=0}
  ( {lifetime[Iterator]=(filedata),start=0}
  it possible {lifetime[Iterator]=(filedata),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filedata),end=0}
  it possible lifetime[Iterator]=(filedata)
Line 3386
  it {lifetime[Iterator]=(filedata),!symbolic=(filedata.end()),!end=0}
Line 3387
  filedata always NonMovedVariable
Line 3392
  std possible {size=3,size=12,size=14,size=5}
  == {!<=-1,!>=2,0}
  "c90" always "c90"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:1990" always "iso9899:1990"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:199409" always "iso9899:199409"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu90" always "gnu90"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu89" always "gnu89"
Line 3394
  "" always ""
Line 3396
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c9x" always "c9x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:1999" always "iso9899:1999"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:199x" always "iso9899:199x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu99" always "gnu99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu9x" always "gnu9x"
Line 3397
  "199901L" always "199901L"
Line 3398
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c1x" always "c1x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2011" always "iso9899:2011"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu11" always "gnu11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu1x" always "gnu1x"
Line 3399
  "201112L" always "201112L"
Line 3400
  std possible {size=3,size=12,size=5}
  == {!<=-1,!>=2,0}
  "c17" always "c17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c18" always "c18"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2017" always "iso9899:2017"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "iso9899:2018" always "iso9899:2018"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu17" always "gnu17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu18" always "gnu18"
Line 3401
  "201710L" always "201710L"
Line 3402
  std possible size=5
  == {!<=-1,!>=2,0}
  "c2x" always "c2x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu2x" always "gnu2x"
Line 3404
  "202000L" always "202000L"
Line 3406
  "" always ""
Line 3411
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++98" always "c++98"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++98" always "gnu++98"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++03" always "gnu++03"
Line 3412
  "199711L" always "199711L"
Line 3413
  std possible {size=7,size=5}
  == {!<=-1,!>=2,0}
  "c++11" always "c++11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++11" always "gnu++11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++0x" always "c++0x"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++0x" always "gnu++0x"
Line 3414
  "201103L" always "201103L"
Line 3415
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++14" always "c++14"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++1y" always "c++1y"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++14" always "gnu++14"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++1y" always "gnu++1y"
Line 3416
  "201402L" always "201402L"
Line 3417
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++17" always "c++17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++1z" always "c++1z"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++17" always "gnu++17"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++1z" always "gnu++1z"
Line 3418
  "201703L" always "201703L"
Line 3419
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++20" always "c++20"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++2a" always "c++2a"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++20" always "gnu++20"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++2a" always "gnu++2a"
Line 3421
  "202002L" always "202002L"
Line 3423
  std possible {size=5,size=7}
  == {!<=-1,!>=2,0}
  "c++23" always "c++23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "c++2b" always "c++2b"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++23" always "gnu++23"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "gnu++2b" always "gnu++2b"
Line 3426
  "202100L" always "202100L"
Line 3428
  "" always ""
