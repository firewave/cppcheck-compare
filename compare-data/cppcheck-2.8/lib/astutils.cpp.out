

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var13 ;
42: double mDoubleValue@var14 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var15 ;
44: bool mIsUnsigned@var16 ;
45:
46: void promote ( const value & v@var17 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var18 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var15 !=@expr1073745128 Type ::@expr1073745129 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var15 ==@expr1073745130 Type ::@expr1073745131 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745132 ) ?@expr1073745133 mDoubleValue@var14 :@expr1073745134 (@expr1073745135 double ) mIntValue@var13 ;
60: }
61:
62: static value calc ( char op@var19 , const value & v1@var20 , const value & v2@var21 ) ;
63: int compare ( const value & v@var22 ) const ;
64: value add ( int v@var23 ) const ;
65: value shiftLeft ( const value & v@var24 ) const ;
66: value shiftRight ( const value & v@var25 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var26 ;
72:
73: static long long toLongNumber ( const std :: string & str@var27 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var28 ) ;
75:
76: template < class T > static std :: string toString ( T value@var29 ) {
77: std ::@expr1073745136 ostringstream result@var30 ;
78: result@var30 <<@expr1073745137 value@var29 ;
79: return result@var30 .@expr1073745138 str (@expr1073745139 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var31 ) ;
82:
83: static bool isInt ( const std :: string & str@var32 ) ;
84: static bool isFloat ( const std :: string & str@var33 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var34 ) ;
86: static bool isNegative ( const std :: string & str@var35 ) ;
87: static bool isPositive ( const std :: string & str@var36 ) ;
88: static bool isDec ( const std :: string & str@var37 ) ;
89: static bool isFloatHex ( const std :: string & str@var38 ) ;
90: static bool isIntHex ( const std :: string & str@var39 ) ;
91: static bool isOct ( const std :: string & str@var40 ) ;
92: static bool isBin ( const std :: string & str@var41 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var42 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var43 , bool supportMicrosoftExtensions@var44 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var45 , const std :: string & second@var46 ) ;
105: static std :: string subtract ( const std :: string & first@var47 , const std :: string & second@var48 ) ;
106: static std :: string multiply ( const std :: string & first@var49 , const std :: string & second@var50 ) ;
107: static std :: string divide ( const std :: string & first@var51 , const std :: string & second@var52 ) ;
108: static std :: string mod ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
109: static std :: string incdec ( const std :: string & var@var55 , const std :: string & op@var56 ) ;
110: static std :: string calculate ( const std :: string & first@var57 , const std :: string & second@var58 , char action@var59 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var60 ) ;
113: static std :: string cos ( const std :: string & tok@var61 ) ;
114: static std :: string tan ( const std :: string & tok@var62 ) ;
115: static std :: string abs ( const std :: string & tok@var63 ) ;
116: static bool isEqual ( const std :: string & first@var64 , const std :: string & second@var65 ) ;
117: static bool isNotEqual ( const std :: string & first@var66 , const std :: string & second@var67 ) ;
118: static bool isGreater ( const std :: string & first@var68 , const std :: string & second@var69 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var70 , const std :: string & second@var71 ) ;
120: static bool isLess ( const std :: string & first@var72 , const std :: string & second@var73 ) ;
121: static bool isLessEqual ( const std :: string & first@var74 , const std :: string & second@var75 ) ;
122: static bool isNullValue ( const std :: string & str@var76 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var77 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var78 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var79 , std :: string :: size_type iPos@var80 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var81 , const MathLib :: value & v2@var82 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var83 , const MathLib :: value & v2@var84 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var85 , const MathLib :: value & v2@var86 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var87 , const MathLib :: value & v2@var88 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var89 , const MathLib :: value & v2@var90 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var91 , const MathLib :: value & v2@var92 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var93 , const MathLib :: value & v2@var94 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var95 , const MathLib :: value & v2@var96 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var97 , const MathLib :: value & v2@var98 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var99 , const MathLib :: value & v2@var100 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var101 ) ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var102 ) const {
35: return p@var102 .@expr1073745140 first@var103 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var104 ) const {
42: return p@var104 .@expr1073745141 second@var105 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var106 , const T & x@var107 )
48: {
49: return std ::@expr1073745142 find (@expr1073745143 r@var106 .@expr1073745144 begin (@expr1073745145 ) , r@var106 .@expr3322 end (@expr3323 ) , x@var107 ) !=@expr1073745148 r@var106 .@expr3322 end (@expr3323 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var108 , const T & x@var109 )
54: {
55: return std ::@expr1073745151 find (@expr1073745152 r@var108 .@expr1073745153 begin (@expr1073745154 ) , r@var108 .@expr3331 end (@expr3332 ) , x@var109 ) !=@expr1073745157 r@var108 .@expr3331 end (@expr3332 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var110 , const U & x@var111 )
60: {
61: return std ::@expr1073745160 find (@expr1073745161 r@var110 .@expr1073745162 begin (@expr1073745163 ) , r@var110 .@expr3340 end (@expr3341 ) , x@var111 ) !=@expr1073745166 r@var110 .@expr3340 end (@expr3341 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var112 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745169 t@var112 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var113 , char c@var114 )
74: {
75: return !@expr1073745170 str@var113 .@expr1073745171 empty (@expr1073745172 ) &&@expr1073745173 str@var113 .@expr1073745174 back (@expr1073745175 ) ==@expr1073745176 c@var114 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var115 , const char end@var116 [ ] , unsigned long endlen@var117 )
79: {
80: return (@expr3353 str@var115 .@expr3354 size (@expr3355 ) >=@expr1073745180 endlen@var117 ) &&@expr1073745181 (@expr3353 str@var115 .@expr1073745183 compare (@expr1073745184 str@var115 .@expr3354 size (@expr3355 ) -@expr1073745187 endlen@var117 , endlen@var117 , end@var116 ) ==@expr1073745188 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var118 , const char ( & end@var119 ) [ N ] )
85: {
86: return endsWith (@expr1073745190 str@var118 , end@var119 , N@expr1073745189 -@expr1073745191 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var120 , char q@var121 , const std :: string & p@var122 )
90: {
91: if (@expr1073745192 !@expr1073745193 endsWith (@expr1073745194 str@var120 , q@var121 ) ) {
92: return false ; }
93: if (@expr1073745195 (@expr1073745196 str@var120 .@expr1073745197 length (@expr1073745198 ) +@expr1073745199 1 ) >@expr1073745200 p@var122 .@expr1073745201 length (@expr1073745202 ) &&@expr1073745203 (@expr1073745204 str@var120 .@expr1073745205 compare (@expr1073745206 0 , p@var122 .@expr1073745207 size (@expr1073745208 ) +@expr1073745209 1 , p@var122 +@expr1073745210 q@var121 ) ==@expr1073745211 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var123 , char q@var124 )
99: {
100: static const std ::@expr3388 vector < std ::@expr3388 string > suffixes@var125 {@expr1073745214 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745215 const std ::@expr3388 string &@expr1073745217 p@var126 :@expr1073745218 suffixes@var125 ) {
102: if (@expr1073745219 isPrefixStringCharLiteral (@expr1073745220 str@var123 , q@var124 , p@var126 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var127 )
109: {
110: return isStringCharLiteral (@expr1073745221 str@var127 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var128 )
114: {
115: return isStringCharLiteral (@expr1073745222 str@var128 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var129 , char q@var130 )
119: {
120: const unsigned long quotePos@var131 =@expr1073745223 str@var129 .@expr1073745224 find (@expr1073745225 q@var130 ) ;
121: return str@var129 .@expr1073745226 substr (@expr1073745227 quotePos@var131 +@expr1073745228 1U , str@var129 .@expr1073745229 size (@expr1073745230 ) -@expr1073745231 quotePos@var131 -@expr1073745232 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var132 )
125: {
126: if (@expr1073745233 isStringLiteral (@expr1073745234 str@var132 ) ) {
127: return getStringCharLiteral (@expr1073745235 str@var132 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var133 )
132: {
133: if (@expr1073745236 isCharLiteral (@expr1073745237 str@var133 ) ) {
134: return getStringCharLiteral (@expr1073745238 str@var133 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var134 )
139: {
140: if (@expr1073745239 i@var134 ==@expr1073745240 1 ) {
141: return "st" ; }
142: if (@expr1073745241 i@var134 ==@expr1073745242 2 ) {
143: return "nd" ; }
144: if (@expr1073745243 i@var134 ==@expr1073745244 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var135 , const std :: string & rhs@var136 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var137 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var138 , const std :: string & name@var139 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var140 , const std :: string & name@var141 ) ;
156:
157: void strTolower ( std :: string & str@var142 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var143 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var144 ;
42:
43:
44: std :: string stdValue@var145 ;
45:
46:
47: Standards ( ) : c@var143 ( CLatest ) , cpp@var144 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var146 ) {
50: stdValue@var145 =@expr1073745245 str@var146 ;
51: if (@expr1073745246 str@var146 ==@expr1073745247 "c89" ||@expr1073745248 str@var146 ==@expr1073745249 "C89" ) {
52: c@var143 =@expr1073745250 C89 ;
53: return true ;
54: }
55: if (@expr1073745251 str@var146 ==@expr1073745252 "c99" ||@expr1073745253 str@var146 ==@expr1073745254 "C99" ) {
56: c@var143 =@expr1073745255 C99 ;
57: return true ;
58: }
59: if (@expr1073745256 str@var146 ==@expr1073745257 "c11" ||@expr1073745258 str@var146 ==@expr1073745259 "C11" ) {
60: c@var143 =@expr1073745260 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745261 c@var143 ) {
67: case C89 :@expr3438 ;
68: return "c89" ;
69: case C99 :@expr3438 ;
70: return "c99" ;
71: case C11 :@expr3438 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var147 ) {
77: if (@expr1073745265 std@var147 ==@expr1073745266 "c89" ) {
78: return Standards ::@expr1073745267 C89 ;
79: }
80: if (@expr1073745268 std@var147 ==@expr1073745269 "c99" ) {
81: return Standards ::@expr1073745270 C99 ;
82: }
83: if (@expr1073745271 std@var147 ==@expr1073745272 "c11" ) {
84: return Standards ::@expr1073745273 C11 ;
85: }
86: return Standards ::@expr1073745274 CLatest ;
87: }
88: bool setCPP ( std :: string str@var148 ) {
89: stdValue@var145 =@expr1073745275 str@var148 ;
90: strTolower (@expr1073745276 str@var148 ) ;
91: cpp@var144 =@expr1073745277 getCPP (@expr1073745278 str@var148 ) ;
92: return !@expr1073745279 stdValue@var145 .@expr1073745280 empty (@expr1073745281 ) &&@expr1073745282 str@var148 ==@expr1073745283 getCPP (@expr1073745284 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745285 cpp@var144 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var149 ) {
98: switch (@expr1073745286 std@var149 ) {
99: case CPP03 :@expr3463 ;
100: return "c++03" ;
101: case CPP11 :@expr3463 ;
102: return "c++11" ;
103: case CPP14 :@expr3463 ;
104: return "c++14" ;
105: case CPP17 :@expr3463 ;
106: return "c++17" ;
107: case CPP20 :@expr3463 ;
108: return "c++20" ;
109: case CPP23 :@expr3463 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var150 ) {
115: if (@expr1073745293 std@var150 ==@expr1073745294 "c++03" ) {
116: return Standards ::@expr1073745295 CPP03 ;
117: }
118: if (@expr1073745296 std@var150 ==@expr1073745297 "c++11" ) {
119: return Standards ::@expr1073745298 CPP11 ;
120: }
121: if (@expr1073745299 std@var150 ==@expr1073745300 "c++14" ) {
122: return Standards ::@expr1073745301 CPP14 ;
123: }
124: if (@expr1073745302 std@var150 ==@expr1073745303 "c++17" ) {
125: return Standards ::@expr1073745304 CPP17 ;
126: }
127: if (@expr1073745305 std@var150 ==@expr1073745306 "c++20" ) {
128: return Standards ::@expr1073745307 CPP20 ;
129: }
130: if (@expr1073745308 std@var150 ==@expr1073745309 "c++23" ) {
131: return Standards ::@expr1073745310 CPP23 ;
132: }
133: return Standards ::@expr1073745311 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var154 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var151 ) : errorcode@var154 ( e@var151 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var152 , T && r@var153 ) : errorcode@var154 ( e@var152 ) , reason@var155 ( r@var153 ) { }
66: ErrorCode errorcode@var154 ;
67: std :: string reason@var155 ;
68: } ;
69:
70: Error load ( const char exename@var156 [ ] , const char path@var157 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var158 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var159 [ ] , unsigned long len@var160 ) ;
75:
76: struct AllocFunc {
77: int groupId@var161 ;
78: int arg@var162 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var163 ;
81: int bufferSizeArg1@var164 ;
82: int bufferSizeArg2@var165 ;
83: int reallocArg@var166 ;
84: bool initData@var167 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var168 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var169 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var170 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var171 , int arg@var172 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var173 , int arg@var174 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var175 , int arg@var176 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var177 [ ] ) const {
107: return getAllocDealloc (@expr1073745312 mAlloc@var443 , name@var177 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var178 [ ] ) const {
112: return getAllocDealloc (@expr1073745313 mDealloc@var444 , name@var178 ) ;
113: }
114:
115:
116: int allocId ( const char name@var179 [ ] ) const {
117: const AllocFunc * af@var180 ; af@var180 =@expr1073745314 getAllocDealloc (@expr1073745315 mAlloc@var443 , name@var179 ) ;
118: return af@var180 ?@expr1073745316 af@var180 .@expr1073745317 groupId@var181 :@expr1073745318 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var182 [ ] ) const {
123: const AllocFunc * af@var183 ; af@var183 =@expr1073745319 getAllocDealloc (@expr1073745320 mDealloc@var444 , name@var182 ) ;
124: return af@var183 ?@expr1073745321 af@var183 .@expr1073745322 groupId@var184 :@expr1073745323 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var185 , int id@var186 , int arg@var187 ) {
129: mAlloc@var443 [@expr3500 functionname@var185 ] .@expr1073745325 groupId@var3304 =@expr1073745326 id@var186 ;
130: mAlloc@var443 [@expr3500 functionname@var185 ] .@expr1073745328 arg@var3305 =@expr1073745329 arg@var187 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var188 , int id@var189 , int arg@var190 ) {
134: mDealloc@var444 [@expr3506 functionname@var188 ] .@expr1073745331 groupId@var3306 =@expr1073745332 id@var189 ;
135: mDealloc@var444 [@expr3506 functionname@var188 ] .@expr1073745334 arg@var3307 =@expr1073745335 arg@var190 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var191 , int id@var192 , int arg@var193 , int reallocArg@var194 = 1 ) {
139: mRealloc@var445 [@expr3512 functionname@var191 ] .@expr1073745337 groupId@var3308 =@expr1073745338 id@var192 ;
140: mRealloc@var445 [@expr3512 functionname@var191 ] .@expr1073745340 arg@var3309 =@expr1073745341 arg@var193 ;
141: mRealloc@var445 [@expr3512 functionname@var191 ] .@expr1073745343 reallocArg@var3310 =@expr1073745344 reallocArg@var194 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var195 , bool noreturn@var196 ) {
146: mNoReturn@var446 [@expr1073745345 funcname@var195 ] =@expr1073745346 noreturn@var196 ?@expr1073745347 FalseTrueMaybe ::@expr1073745348 True :@expr1073745349 FalseTrueMaybe ::@expr1073745350 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var197 ) ;
150:
151:
152: static bool ismemory ( const int id@var198 ) {
153: return (@expr3527 (@expr3527 id@var198 >@expr1073745353 0 ) &&@expr1073745354 (@expr3527 (@expr3527 id@var198 &@expr1073745357 1 ) ==@expr1073745358 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var199 ) {
156: return (@expr3535 (@expr3535 func@var199 .@expr3537 groupId@var200 >@expr1073745362 0 ) &&@expr1073745363 (@expr3535 (@expr3535 func@var199 .@expr3537 groupId@var200 &@expr1073745367 1 ) ==@expr1073745368 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var201 ) {
161: return (@expr3545 (@expr3545 id@var201 >@expr1073745371 0 ) &&@expr1073745372 (@expr3545 (@expr3545 id@var201 &@expr1073745375 1 ) ==@expr1073745376 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var202 ) {
164: return (@expr3553 (@expr3553 func@var202 .@expr3555 groupId@var203 >@expr1073745380 0 ) &&@expr1073745381 (@expr3553 (@expr3553 func@var202 .@expr3555 groupId@var203 &@expr1073745385 1 ) ==@expr1073745386 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var204 ) const ;
168: int formatstr_argno ( const Token * ftok@var205 ) const ;
169: bool formatstr_scan ( const Token * ftok@var206 ) const ;
170: bool formatstr_secure ( const Token * ftok@var207 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var208 ;
174: int ptr2Arg@var209 ;
175: int sizeArg@var210 ;
176: int strlenArg@var211 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var212 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var213 ;
182: Standards standards@var214 ;
183: Severity :: SeverityType severity@var215 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var216 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var217 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var218 ) const ;
191: bool matchArguments ( const Token * ftok@var219 , const std :: string & functionName@var220 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var221 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var222 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var223 ) const ;
198: int returnValueContainer ( const Token * ftok@var224 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var225 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var226 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var227 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var228 , std :: string * unknownFunc@var229 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var239 ( -1 ) ,
210: size_templateArgNo@var241 ( -1 ) ,
211: arrayLike_indexOp@var242 ( false ) ,
212: stdStringLike@var243 ( false ) ,
213: stdAssociativeLike@var244 ( false ) ,
214: opLessAllowed@var245 ( true ) ,
215: hasInitializerListConstructor@var246 ( false ) ,
216: unstableErase@var247 ( false ) ,
217: unstableInsert@var248 ( false ) ,
218: view@var249 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var230 ;
248: Yield yield@var231 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var232 ;
252: int templateParameter@var233 ;
253: } ;
254: std :: string startPattern@var234 ; std :: string startPattern2@var235 ; std :: string endPattern@var236 ; std :: string itEndPattern@var237 ;
255: std :: map < std :: string , Function > functions@var238 ;
256: int type_templateArgNo@var239 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var240 ;
258: int size_templateArgNo@var241 ;
259: bool arrayLike_indexOp@var242 ;
260: bool stdStringLike@var243 ;
261: bool stdAssociativeLike@var244 ;
262: bool opLessAllowed@var245 ;
263: bool hasInitializerListConstructor@var246 ;
264: bool unstableErase@var247 ;
265: bool unstableInsert@var248 ;
266: bool view@var249 ;
267:
268: Action getAction ( const std :: string & function@var250 ) const {
269: const std ::@expr1073745387 map < std ::@expr1073745388 string , Function > ::@expr1073745389 const_iterator i@var251 =@expr1073745390 functions@var238 .@expr1073745391 find (@expr1073745392 function@var250 ) ;
270: if (@expr1073745393 i@var251 !=@expr1073745394 functions@var238 .@expr1073745395 end (@expr1073745396 ) ) {
271: return i@var251 .@expr1073745397 second@var252 .@expr1073745398 action@var253 ; }
272: return Action ::@expr1073745399 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var254 ) const {
276: const std ::@expr1073745400 map < std ::@expr1073745401 string , Function > ::@expr1073745402 const_iterator i@var255 =@expr1073745403 functions@var238 .@expr1073745404 find (@expr1073745405 function@var254 ) ;
277: if (@expr1073745406 i@var255 !=@expr1073745407 functions@var238 .@expr1073745408 end (@expr1073745409 ) ) {
278: return i@var255 .@expr1073745410 second@var256 .@expr1073745411 yield@var257 ; }
279: return Yield ::@expr1073745412 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var258 ) ;
283: static Action actionFrom ( const std :: string & actionName@var259 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var260 ;
286: const Container * detectContainer ( const Token * typeStart@var261 , bool iterator@var262 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var263 , bool * isIterator@var264 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var265 ( false ) ,
293: notnull@var266 ( false ) ,
294: notuninit@var267 ( -1 ) ,
295: formatstr@var268 ( false ) ,
296: strz@var269 ( false ) ,
297: optional@var270 ( false ) ,
298: variadic@var271 ( false ) ,
299: iteratorInfo@var277 ( ) ,
300: direction@var285 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var265 ;
303: bool notnull@var266 ;
304: int notuninit@var267 ;
305: bool formatstr@var268 ;
306: bool strz@var269 ;
307: bool optional@var270 ;
308: bool variadic@var271 ;
309: std :: string valid@var272 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var273 ( 0 ) , it@var274 ( false ) , first@var275 ( false ) , last@var276 ( false ) { }
314:
315: int container@var273 ;
316: bool it@var274 ;
317: bool first@var275 ;
318: bool last@var276 ;
319: } ;
320: IteratorInfo iteratorInfo@var277 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var278 , int a@var279 ) : type@var280 ( t@var278 ) , arg@var281 ( a@var279 ) , arg2@var282 ( 0 ) , value@var283 ( 0 ) { }
326: Type type@var280 ;
327: int arg@var281 ;
328: int arg2@var282 ;
329: long long value@var283 ;
330: } ;
331: std :: vector < MinSize > minsizes@var284 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var285 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var286 ;
344: bool use@var287 ;
345: bool leakignore@var288 ;
346: bool isconst@var289 ;
347: bool ispure@var290 ;
348: UseRetValType useretval@var291 ;
349: bool ignore@var292 ;
350: bool formatstr@var293 ;
351: bool formatstr_scan@var294 ;
352: bool formatstr_secure@var295 ;
353: Container :: Action containerAction@var296 ;
354: Container :: Yield containerYield@var297 ;
355: Function ( )
356: : use@var287 ( false ) ,
357: leakignore@var288 ( false ) ,
358: isconst@var289 ( false ) ,
359: ispure@var290 ( false ) ,
360: useretval@var291 ( UseRetValType :: NONE ) ,
361: ignore@var292 ( false ) ,
362: formatstr@var293 ( false ) ,
363: formatstr_scan@var294 ( false ) ,
364: formatstr_secure@var295 ( false ) ,
365: containerAction@var296 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var297 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var298 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var299 ;
372: bool isUse ( const std :: string & functionName@var300 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var301 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var302 , bool pure@var303 ) const ;
375: bool isFunctionConst ( const Token * ftok@var304 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var305 , int argnr@var306 ) const {
378: const ArgumentChecks * arg@var307 ; arg@var307 =@expr1073745413 getarg (@expr1073745414 ftok@var305 , argnr@var306 ) ;
379: return arg@var307 &&@expr1073745415 arg@var307 .@expr1073745416 notbool@var308 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var309 , int argnr@var310 ) const ;
383: bool isuninitargbad ( const Token * ftok@var311 , int argnr@var312 , int indirect@var313 = 0 , bool * hasIndirect@var314 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var315 , int argnr@var316 ) const {
386: const ArgumentChecks * arg@var317 ; arg@var317 =@expr1073745417 getarg (@expr1073745418 ftok@var315 , argnr@var316 ) ;
387: return arg@var317 &&@expr1073745419 arg@var317 .@expr1073745420 formatstr@var318 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var319 , int argnr@var320 ) const {
391: const ArgumentChecks * arg@var321 ; arg@var321 =@expr1073745421 getarg (@expr1073745422 ftok@var319 , argnr@var320 ) ;
392: return arg@var321 &&@expr1073745423 arg@var321 .@expr1073745424 strz@var322 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var323 , int argnr@var324 , const long long argvalue@var325 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var326 , int argnr@var327 , double argvalue@var328 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var329 , int argnr@var330 ) const {
399: const ArgumentChecks * arg@var331 ; arg@var331 =@expr1073745425 getarg (@expr1073745426 ftok@var329 , argnr@var330 ) ;
400: return arg@var331 ?@expr1073745427 arg@var331 .@expr1073745428 valid@var332 :@expr1073745429 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var333 ;
405: std :: string op1@var334 ;
406: std :: string op2@var335 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745430 isInt (@expr1073745431 op1@var334 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var336 , int argnr@var337 ) const {
413: const ArgumentChecks * arg@var338 ; arg@var338 =@expr1073745432 getarg (@expr1073745433 ftok@var336 , argnr@var337 ) ;
414: return arg@var338 &&@expr1073745434 arg@var338 .@expr3611 iteratorInfo@var339 .@expr1073745436 it@var340 ?@expr1073745437 &@expr1073745438 arg@var338 .@expr3611 iteratorInfo@var339 :@expr1073745440 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var341 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var342 , int argnr@var343 ) const {
420: const ArgumentChecks * arg@var344 ; arg@var344 =@expr1073745441 getarg (@expr1073745442 ftok@var342 , argnr@var343 ) ;
421: return arg@var344 ?@expr1073745443 &@expr1073745444 arg@var344 .@expr1073745445 minsizes@var345 :@expr1073745446 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var346 , int argnr@var347 ) const ;
425:
426: bool markupFile ( const std :: string & path@var348 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var349 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var453 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var350 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var351 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var352 , const std :: string & token@var353 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var354 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var355 ) const ;
443: const std :: string & blockend ( const std :: string & file@var356 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var357 , const std :: string & keyword@var358 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var359 ) const {
448: return mExporters@var456 .@expr1073745447 find (@expr1073745448 prefix@var359 ) !=@expr1073745449 mExporters@var456 .@expr1073745450 end (@expr1073745451 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var360 , const std :: string & token@var361 ) const {
452: const std ::@expr1073745452 map < std ::@expr1073745453 string , ExportedFunctions > ::@expr1073745454 const_iterator it@var362 =@expr1073745455 mExporters@var456 .@expr1073745456 find (@expr1073745457 prefix@var360 ) ;
453: return (@expr1073745458 it@var362 !=@expr1073745459 mExporters@var456 .@expr1073745460 end (@expr1073745461 ) &&@expr1073745462 it@var362 .@expr1073745463 second@var363 .@expr1073745464 isPrefix (@expr1073745465 token@var361 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var364 , const std :: string & token@var365 ) const {
457: const std ::@expr1073745466 map < std ::@expr1073745467 string , ExportedFunctions > ::@expr1073745468 const_iterator it@var366 =@expr1073745469 mExporters@var456 .@expr1073745470 find (@expr1073745471 prefix@var364 ) ;
458: return (@expr1073745472 it@var366 !=@expr1073745473 mExporters@var456 .@expr1073745474 end (@expr1073745475 ) &&@expr1073745476 it@var366 .@expr1073745477 second@var367 .@expr1073745478 isSuffix (@expr1073745479 token@var365 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var368 , const std :: string & importer@var369 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var370 , Container :: Yield yield@var371 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var372 , Container :: Action action@var373 ) const ;
465:
466: bool isreflection ( const std :: string & token@var374 ) const {
467: return mReflection@var458 .@expr1073745480 find (@expr1073745481 token@var374 ) !=@expr1073745482 mReflection@var458 .@expr1073745483 end (@expr1073745484 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var375 ) const {
471: const std ::@expr1073745485 map < std ::@expr1073745486 string , int > ::@expr1073745487 const_iterator it@var376 =@expr1073745488 mReflection@var458 .@expr1073745489 find (@expr1073745490 token@var375 ) ;
472: if (@expr1073745491 it@var376 !=@expr1073745492 mReflection@var458 .@expr1073745493 end (@expr1073745494 ) ) {
473: return it@var376 .@expr1073745495 second@var377 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var378 ;
478:
479: struct SmartPointer {
480: std :: string name@var379 ; name@var379 = "" ;
481: bool unique@var380 ; unique@var380 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var381 ;
485: bool isSmartPointer ( const Token * tok@var382 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var383 ) const ;
487:
488: struct PodType {
489: unsigned int size@var384 ;
490: char sign@var385 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var386 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var387 ) const {
494: const std ::@expr1073745496 unordered_map < std ::@expr1073745497 string , PodType > ::@expr1073745498 const_iterator it@var388 =@expr1073745499 mPodTypes@var459 .@expr1073745500 find (@expr1073745501 name@var387 ) ;
495: return (@expr3678 it@var388 !=@expr1073745503 mPodTypes@var459 .@expr1073745504 end (@expr1073745505 ) ) ?@expr1073745506 &@expr1073745507 (@expr3678 it@var388 .@expr1073745509 second@var389 ) :@expr1073745510 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var400 ( false )
501: , mUnsigned@var401 ( false )
502: , mLong@var402 ( false )
503: , mPointer@var403 ( false )
504: , mPtrPtr@var404 ( false )
505: , mConstPtr@var405 ( false ) { }
506: bool operator== ( const PlatformType & type@var390 ) const {
507: return (@expr1073745511 mSigned@var400 ==@expr1073745512 type@var390 .@expr1073745513 mSigned@var391 &&@expr1073745514
508: mUnsigned@var401 ==@expr1073745515 type@var390 .@expr1073745516 mUnsigned@var392 &&@expr1073745517
509: mLong@var402 ==@expr1073745518 type@var390 .@expr1073745519 mLong@var393 &&@expr1073745520
510: mPointer@var403 ==@expr1073745521 type@var390 .@expr1073745522 mPointer@var394 &&@expr1073745523
511: mPtrPtr@var404 ==@expr1073745524 type@var390 .@expr1073745525 mPtrPtr@var395 &&@expr1073745526
512: mConstPtr@var405 ==@expr1073745527 type@var390 .@expr1073745528 mConstPtr@var396 &&@expr1073745529
513: mType@var399 ==@expr1073745530 type@var390 .@expr1073745531 mType@var397 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var398 ) const {
516: return !@expr1073745532 (@expr1073745533 *@expr1073745534 this@expr1073745535 ==@expr1073745536 type@var398 ) ;
517: }
518: std :: string mType@var399 ;
519: bool mSigned@var400 ;
520: bool mUnsigned@var401 ;
521: bool mLong@var402 ;
522: bool mPointer@var403 ;
523: bool mPtrPtr@var404 ;
524: bool mConstPtr@var405 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var406 ) const {
529: const std ::@expr1073745537 map < std ::@expr1073745538 string , PlatformType > ::@expr1073745539 const_iterator it@var407 =@expr1073745540 mPlatformTypes@var409 .@expr1073745541 find (@expr1073745542 name@var406 ) ;
530: return (@expr3719 it@var407 !=@expr1073745544 mPlatformTypes@var409 .@expr1073745545 end (@expr1073745546 ) ) ?@expr1073745547 &@expr1073745548 (@expr3719 it@var407 .@expr1073745550 second@var408 ) :@expr1073745551 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var409 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var410 , const std :: string & platform@var411 ) const {
536: const std ::@expr1073745552 map < std ::@expr3729 string , Platform > ::@expr1073745554 const_iterator it@var412 =@expr1073745555 mPlatforms@var461 .@expr1073745556 find (@expr1073745557 platform@var411 ) ;
537: if (@expr1073745558 it@var412 !=@expr1073745559 mPlatforms@var461 .@expr1073745560 end (@expr1073745561 ) ) {
538: const PlatformType * const type@var413 ; type@var413 =@expr1073745562 it@var412 .@expr1073745563 second@var414 .@expr1073745564 platform_type (@expr1073745565 name@var410 ) ;
539: if (@expr1073745566 type@var413 ) {
540: return type@var413 ; }
541: }
542:
543: const std ::@expr1073745567 map < std ::@expr3729 string , PlatformType > ::@expr1073745569 const_iterator it2@var415 =@expr1073745570 mPlatformTypes@var460 .@expr1073745571 find (@expr1073745572 name@var410 ) ;
544: return (@expr3749 it2@var415 !=@expr1073745574 mPlatformTypes@var460 .@expr1073745575 end (@expr1073745576 ) ) ?@expr1073745577 &@expr1073745578 (@expr3749 it2@var415 .@expr1073745580 second@var416 ) :@expr1073745581 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var417 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var418 , Library :: Container :: Yield y@var419 , const std :: string & fallback@var420 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var421 , const std :: string & typeName@var422 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var423 , const std :: string & name@var424 , std :: set < std :: string > & unknown_elements@var425 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var426 ) {
565: mPrefixes@var430 .@expr1073745582 insert (@expr1073745583 prefix@var426 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var427 ) {
568: mSuffixes@var431 .@expr1073745584 insert (@expr1073745585 suffix@var427 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var428 ) const {
571: return (@expr1073745586 mPrefixes@var430 .@expr1073745587 find (@expr1073745588 prefix@var428 ) !=@expr1073745589 mPrefixes@var430 .@expr1073745590 end (@expr1073745591 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var429 ) const {
574: return (@expr1073745592 mSuffixes@var431 .@expr1073745593 find (@expr1073745594 suffix@var429 ) !=@expr1073745595 mSuffixes@var431 .@expr1073745596 end (@expr1073745597 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var430 ;
579: std :: set < std :: string > mSuffixes@var431 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var439 ( 0 ) { }
584:
585: void setStart ( const char * s@var432 ) {
586: mStart@var437 =@expr1073745598 s@var432 ;
587: }
588: void setEnd ( const char * e@var433 ) {
589: mEnd@var438 =@expr1073745599 e@var433 ;
590: }
591: void setOffset ( const int o@var434 ) {
592: mOffset@var439 =@expr1073745600 o@var434 ;
593: }
594: void addBlock ( const char * blockName@var435 ) {
595: mBlocks@var440 .@expr1073745601 insert (@expr1073745602 blockName@var435 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var437 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var438 ;
602: }
603: int offset ( ) const {
604: return mOffset@var439 ;
605: }
606: bool isBlock ( const std :: string & blockName@var436 ) const {
607: return mBlocks@var440 .@expr1073745603 find (@expr1073745604 blockName@var436 ) !=@expr1073745605 mBlocks@var440 .@expr1073745606 end (@expr1073745607 ) ;
608: }
609:
610: private:
611: std :: string mStart@var437 ;
612: std :: string mEnd@var438 ;
613: int mOffset@var439 ;
614: std :: set < std :: string > mBlocks@var440 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var441 ;
618: std :: set < std :: string > mFiles@var442 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var443 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var444 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var445 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var446 ;
623: std :: map < std :: string , std :: string > mReturnValue@var447 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var448 ;
625: std :: map < std :: string , int > mReturnValueContainer@var449 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var450 ;
627: std :: map < std :: string , bool > mReportErrors@var451 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var452 ;
629: std :: set < std :: string > mMarkupExtensions@var453 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var454 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var455 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var456 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var457 ;
634: std :: map < std :: string , int > mReflection@var458 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var459 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var460 ;
637: std :: map < std :: string , Platform > mPlatforms@var461 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var462 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var463 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var464 , int argnr@var465 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var466 , bool * error@var467 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var468 , const std :: string & name@var469 ) {
646: const std ::@expr1073745608 map < std ::@expr1073745609 string , AllocFunc > ::@expr1073745610 const_iterator it@var470 =@expr1073745611 data@var468 .@expr1073745612 find (@expr1073745613 name@var469 ) ;
647: return (@expr1073745614 it@var470 ==@expr1073745615 data@var468 .@expr1073745616 end (@expr1073745617 ) ) ?@expr1073745618 nullptr :@expr1073745619 &@expr1073745620 it@var470 .@expr1073745621 second@var471 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var472 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var473 ,
654: const Settings * settings@var474 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var475 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var476 ) const {
54: x@var476 ++@expr1073745622 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var477 ) const {
60: x@var477 --@expr1073745623 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var478 , const U & y@var479 ) const {
67: return x@var478 <@expr1073745624 y@var479 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var480 , const U & y@var481 ) const {
74: return std ::@expr1073745625 abs (@expr1073745626 x@var480 -@expr1073745627 y@var481 ) ==@expr1073745628 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var482 , T x@var483 , U y@var484 ) const {
81: result@var482 =@expr1073745629 !@expr1073745630 (@expr1073745631 x@var483 >@expr1073745632 y@var484 ||@expr1073745633 x@var483 <@expr1073745634 y@var484 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var485 = 0 , Bound b@var486 = Bound :: Point )
91: : valueType@var526 ( ValueType :: INT ) ,
92: bound@var527 ( b@var486 ) ,
93: intvalue@var528 ( val@var485 ) ,
94: tokvalue@var529 ( nullptr ) ,
95: floatValue@var530 ( 0.0 ) ,
96: moveKind@var531 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var532 ( val@var485 ) ,
98: condition@var533 ( nullptr ) ,
99: varId@var535 ( 0U ) ,
100: safe@var536 ( false ) ,
101: conditional@var537 ( false ) ,
102: macro@var538 ( false ) ,
103: defaultArg@var539 ( false ) ,
104: indirect@var540 ( 0 ) ,
105: path@var541 ( 0 ) ,
106: wideintvalue@var542 ( val@var485 ) ,
107: subexpressions@var543 ( ) ,
108: capturetok@var544 ( nullptr ) ,
109: lifetimeKind@var545 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var546 ( LifetimeScope :: Local ) ,
111: valueKind@var551 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var487 , long long val@var488 , Bound b@var489 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var490 ) const {
118: if (@expr1073745635 valueType@var526 !=@expr1073745636 rhs@var490 .@expr1073745637 valueType@var491 ) {
119: return false ; }
120: switch (@expr1073745638 valueType@var526 ) {
121: case ValueType ::@expr1073745639 INT :@expr3816
122: case ValueType ::@expr1073745641 CONTAINER_SIZE :@expr3816
123: case ValueType ::@expr1073745643 BUFFER_SIZE :@expr3816
124: case ValueType ::@expr1073745645 ITERATOR_START :@expr3816
125: case ValueType ::@expr1073745647 ITERATOR_END :@expr3816 ;
126: if (@expr3825 intvalue@var528 !=@expr3826 rhs@var490 .@expr3827 intvalue@var492 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745652 TOK :@expr3816 ;
130: if (@expr3830 tokvalue@var529 !=@expr3831 rhs@var490 .@expr3832 tokvalue@var493 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745657 FLOAT :@expr3816 ;
134:
135: if (@expr1073745659 floatValue@var530 >@expr1073745660 rhs@var490 .@expr3837 floatValue@var494 ||@expr1073745662 floatValue@var530 <@expr1073745663 rhs@var490 .@expr3837 floatValue@var494 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745665 MOVED :@expr3816 ;
139: if (@expr1073745667 moveKind@var531 !=@expr1073745668 rhs@var490 .@expr1073745669 moveKind@var495 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745670 UNINIT :@expr3816 ;
143: break ;
144: case ValueType ::@expr1073745672 LIFETIME :@expr3816 ;
145: if (@expr3830 tokvalue@var529 !=@expr3831 rhs@var490 .@expr3832 tokvalue@var493 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745677 SYMBOLIC :@expr3816 ;
149: if (@expr1073745679 !@expr1073745680 sameToken (@expr1073745681 tokvalue@var529 , rhs@var490 .@expr3832 tokvalue@var493 ) ) {
150: return false ; }
151: if (@expr3825 intvalue@var528 !=@expr3826 rhs@var490 .@expr3827 intvalue@var492 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var496 , F f@var497 ) {
160: switch (@expr1073745686 self@var496 .@expr1073745687 valueType@var498 ) {
161: case ValueType ::@expr1073745688 INT :@expr3865
162: case ValueType ::@expr1073745690 SYMBOLIC :@expr3865
163: case ValueType ::@expr1073745692 BUFFER_SIZE :@expr3865
164: case ValueType ::@expr1073745694 CONTAINER_SIZE :@expr3865
165: case ValueType ::@expr1073745696 ITERATOR_START :@expr3865
166: case ValueType ::@expr1073745698 ITERATOR_END :@expr3865 ; {
167: f@var497 (@expr1073745700 self@var496 .@expr1073745701 intvalue@var499 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745702 FLOAT :@expr3865 ; {
171: f@var497 (@expr1073745704 self@var496 .@expr1073745705 floatValue@var500 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745706 UNINIT :@expr3865
175: case ValueType ::@expr1073745708 TOK :@expr3865
176: case ValueType ::@expr1073745710 LIFETIME :@expr3865
177: case ValueType ::@expr1073745712 MOVED :@expr3865 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var501 , Compare compare@var502 , T x@var503 , U y@var504 ) const {
186: result@var501 =@expr1073745714 compare@var502 (@expr1073745715 x@var503 , y@var504 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var505 , const Value & rhs@var506 , Compare compare@var507 , T x@var508 ) const {
191: visitValue (@expr1073745717 rhs@var506 ,
192: std ::@expr1073745718 bind (@expr1073745719 innerVisitor {@expr1073745720 } , std ::@expr1073745721 ref (@expr1073745722 result@var505 ) , std ::@expr1073745723 move (@expr1073745724 compare@var507 ) , x@var508 , std ::@expr1073745725 placeholders ::@expr1073745726 _1@expr1073745716 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var509 , Compare compare@var510 ) const {
198: assert (@expr1073745728 (@expr1073745729 !@expr1073745730 this@expr3907 .@expr1073745732 isSymbolicValue (@expr1073745733 ) &&@expr1073745734 !@expr1073745735 rhs@var509 .@expr1073745736 isSymbolicValue (@expr1073745737 ) ) ||@expr1073745738
199: (@expr1073745739 this@expr3907 .@expr1073745740 valueType@var526 ==@expr1073745741 rhs@var509 .@expr1073745742 valueType@var511 &&@expr1073745743 sameToken (@expr1073745744 this@expr3907 .@expr1073745745 tokvalue@var529 , rhs@var509 .@expr1073745746 tokvalue@var512 ) ) ) ;
200: bool result@var513 ; result@var513 =@expr1073745747 false ;
201: visitValue (@expr1073745748
202: *@expr1073745749 this@expr3907 ,
203: std ::@expr1073745750 bind (@expr1073745751 compareVisitor {@expr1073745752 } , std ::@expr3929 ref (@expr1073745754 result@var513 ) , std ::@expr3929 ref (@expr1073745756 rhs@var509 ) , std ::@expr1073745757 move (@expr1073745758 compare@var510 ) , std ::@expr1073745759 placeholders ::@expr1073745760 _1@expr1073745727 ) ) ;
204: return result@var513 ;
205: }
206:
207: bool operator== ( const Value & rhs@var514 ) const {
208: if (@expr1073745761 !@expr1073745762 equalValue (@expr1073745763 rhs@var514 ) ) {
209: return false ; }
210:
211: return varvalue@var532 ==@expr1073745764 rhs@var514 .@expr1073745765 varvalue@var515 &&@expr1073745766
212: condition@var533 ==@expr1073745767 rhs@var514 .@expr1073745768 condition@var516 &&@expr1073745769
213: varId@var535 ==@expr1073745770 rhs@var514 .@expr1073745771 varId@var517 &&@expr1073745772
214: conditional@var537 ==@expr1073745773 rhs@var514 .@expr1073745774 conditional@var518 &&@expr1073745775
215: defaultArg@var539 ==@expr1073745776 rhs@var514 .@expr1073745777 defaultArg@var519 &&@expr1073745778
216: indirect@var540 ==@expr1073745779 rhs@var514 .@expr1073745780 indirect@var520 &&@expr1073745781
217: valueKind@var551 ==@expr1073745782 rhs@var514 .@expr1073745783 valueKind@var521 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var522 ) const {
221: return !@expr1073745784 (@expr1073745785 *@expr1073745786 this@expr1073745787 ==@expr1073745788 rhs@var522 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var523 ) const {
226: bool result@var524 ; result@var524 =@expr1073745790 false ;
227: visitValue (@expr1073745791 *@expr1073745792 this@expr1073745793 , std ::@expr1073745794 bind (@expr1073745795 equalVisitor {@expr1073745796 } , std ::@expr1073745797 ref (@expr1073745798 result@var524 ) , x@var523 , std ::@expr1073745799 placeholders ::@expr1073745800 _1@expr1073745789 ) ) ;
228: return result@var524 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745801 bound@var527 ==@expr1073745802 Bound ::@expr1073745803 Lower ) {
233: visitValue (@expr1073745804 *@expr3981 this@expr3982 , increment {@expr1073745807 } ) ; }
234: else { if (@expr1073745808 bound@var527 ==@expr1073745809 Bound ::@expr1073745810 Upper ) {
235: visitValue (@expr1073745811 *@expr3981 this@expr3982 , decrement {@expr1073745813 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745814 bound@var527 ==@expr1073745815 Bound ::@expr3992 Lower ) {
240: bound@var527 =@expr1073745817 Bound ::@expr3994 Upper ; }
241: else { if (@expr1073745819 bound@var527 ==@expr1073745820 Bound ::@expr3994 Upper ) {
242: bound@var527 =@expr1073745822 Bound ::@expr3992 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745824 ) ;
247: decreaseRange (@expr1073745825 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var525 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var526 ;
267: bool isIntValue ( ) const {
268: return valueType@var526 ==@expr1073745826 ValueType ::@expr1073745827 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var526 ==@expr1073745828 ValueType ::@expr1073745829 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var526 ==@expr1073745830 ValueType ::@expr1073745831 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var526 ==@expr1073745832 ValueType ::@expr1073745833 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var526 ==@expr1073745834 ValueType ::@expr1073745835 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var526 ==@expr1073745836 ValueType ::@expr1073745837 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var526 ==@expr1073745838 ValueType ::@expr1073745839 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var526 ==@expr1073745840 ValueType ::@expr1073745841 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var526 ==@expr1073745842 ValueType ::@expr1073745843 ITERATOR_START ||@expr1073745844 valueType@var526 ==@expr1073745845 ValueType ::@expr1073745846 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var526 ==@expr1073745847 ValueType ::@expr1073745848 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var526 ==@expr1073745849 ValueType ::@expr1073745850 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var526 ==@expr1073745851 ValueType ::@expr1073745852 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var526 ==@expr1073745854 ValueType ::@expr1073745855 LIFETIME &&@expr1073745856 lifetimeScope@var546 ==@expr1073745857 LifetimeScope ::@expr1073745858 Local@expr1073745853 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var526 ==@expr1073745859 ValueType ::@expr1073745860 LIFETIME &&@expr1073745861 lifetimeScope@var546 ==@expr1073745862 LifetimeScope ::@expr1073745863 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var526 ==@expr1073745864 ValueType ::@expr1073745865 LIFETIME &&@expr1073745866 lifetimeScope@var546 ==@expr1073745867 LifetimeScope ::@expr1073745868 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745869 ) ||@expr1073745870 isUninitValue (@expr1073745871 ) ||@expr1073745872 isLifetimeValue (@expr1073745873 ) ;
318: }
319:
320:
321: Bound bound@var527 ;
322:
323:
324: long long intvalue@var528 ;
325:
326:
327: const Token * tokvalue@var529 ;
328:
329:
330: double floatValue@var530 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var531 ;
334:
335:
336: long long varvalue@var532 ;
337:
338:
339: const Token * condition@var533 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var534 ;
342:
343:
344: int varId@var535 ;
345:
346:
347: bool safe@var536 ;
348:
349:
350: bool conditional@var537 ;
351:
352:
353: bool macro@var538 ;
354:
355:
356: bool defaultArg@var539 ;
357:
358: int indirect@var540 ;
359:
360:
361: long long path@var541 ;
362:
363:
364: long long wideintvalue@var542 ;
365:
366: std :: vector < std :: string > subexpressions@var543 ;
367:
368:
369: const Token * capturetok@var544 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var545 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var546 ;
385:
386: static const char * toString ( MoveKind moveKind@var547 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var548 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var549 ) ;
389: static const char * toString ( Bound bound@var550 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var551 ;
402:
403: void setKnown ( ) {
404: valueKind@var551 =@expr1073745874 ValueKind ::@expr1073745875 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var551 ==@expr1073745876 ValueKind ::@expr1073745877 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var551 =@expr1073745879 ValueKind ::@expr1073745880 Possible@expr1073745878 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var551 ==@expr1073745882 ValueKind ::@expr1073745883 Possible@expr1073745881 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var551 ==@expr1073745884 ValueKind ::@expr1073745885 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var551 =@expr1073745886 ValueKind ::@expr1073745887 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var552 = true ) {
428: if (@expr1073745888 inconclusive@var552 ) {
429: valueKind@var551 =@expr1073745889 ValueKind ::@expr1073745890 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var551 ==@expr1073745891 ValueKind ::@expr1073745892 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745894 isKnown (@expr1073745895 ) ) {
438: valueKind@var551 =@expr1073745896 ValueKind ::@expr1073745897 Possible@expr1073745893 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745898 condition@var533 &&@expr1073745899 !@expr1073745900 defaultArg@var539 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var553 , const Token * tok2@var554 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var555 , const Settings * settings@var556 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var557 , SymbolDatabase * symboldatabase@var558 , ErrorLogger * errorLogger@var559 , const Settings * settings@var560 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var561 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var562 , const Settings * settings@var563 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var564 ,
459: const Settings * settings@var565 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var566 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var567 , const Token * indexTok@var568 , bool possible@var569 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var570 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var571 , const Settings * settings@var572 = nullptr , int depth@var573 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var574 ;
471: bool addressOf@var575 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var576 ;
473: bool inconclusive@var577 ;
474:
475: LifetimeToken ( ) : token@var574 ( nullptr ) , addressOf@var575 ( false ) , errorPath@var576 ( ) , inconclusive@var577 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var578 , ValueFlow :: Value :: ErrorPath errorPath@var579 )
478: : token@var574 ( token@var578 ) , addressOf@var575 ( false ) , errorPath@var576 ( std :: move ( errorPath@var579 ) ) , inconclusive@var577 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var580 , bool addressOf@var581 , ValueFlow :: Value :: ErrorPath errorPath@var582 )
482: : token@var574 ( token@var580 ) , addressOf@var575 ( addressOf@var581 ) , errorPath@var576 ( std :: move ( errorPath@var582 ) ) , inconclusive@var577 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var583 , bool b@var584 ) {
486: for (@expr1073745901 LifetimeToken &@expr1073745902 x@var585 :@expr1073745903 v@var583 ) {
487: x@var585 .@expr1073745904 addressOf@var586 =@expr1073745905 b@var584 ; }
488: return v@var583 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var587 , bool b@var588 ) {
492: for (@expr1073745906 LifetimeToken &@expr1073745907 x@var589 :@expr1073745908 v@var587 ) {
493: x@var589 .@expr1073745909 inconclusive@var590 =@expr1073745910 b@var588 ; }
494: return v@var587 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var591 , ValueFlow :: Value & true_value@var592 , ValueFlow :: Value & false_value@var593 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var594 ) ;
499: const Token * parseCompareInt ( const Token * tok@var595 , ValueFlow :: Value & true_value@var596 , ValueFlow :: Value & false_value@var597 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var598 , long long val@var599 , const Token * varTok@var600 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var601 , const Token * varTok@var602 , long long val@var603 ) ;
503:
504: ValuePtr<InferModel> makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var604 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var605 ,
508: ValueFlow :: Value & value@var606 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var607 ,
511: bool escape@var608 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var609 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var610 , const Token * lifetime@var611 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var612 , ValueFlow :: Value :: ErrorPath & errorPath@var613 , bool * addressOf@var614 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var615 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var616 , const Settings * settings@var617 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var618 , const ValueFlow :: Value * val@var619 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var620 , const ValueFlow :: Value * val@var621 , ValueFlow :: Value :: ErrorPath & errorPath@var622 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var623 , bool inconclusive@var624 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var625 ,
529: bool inconclusive@var626 = false ,
530: long long path@var627 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var628 , const Scope * defaultScope@var629 = nullptr , bool smallest@var630 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var631 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var632 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var633 ;
69: std :: string mScope@var634 ;
70: std :: string mName@var635 ;
71: std :: string mFullName@var636 ;
72: const Token * mNameToken@var637 ;
73: const Token * mParamEnd@var638 ;
74: unsigned int mFlags@var639 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var640 ) {
90: setFlag (@expr1073745911 fIsClass , state@var640 ) ;
91: }
92: void isFunction ( bool state@var641 ) {
93: setFlag (@expr1073745912 fIsFunction , state@var641 ) ;
94: }
95: void isVariable ( bool state@var642 ) {
96: setFlag (@expr1073745913 fIsVariable , state@var642 ) ;
97: }
98: void isAlias ( bool state@var643 ) {
99: setFlag (@expr1073745914 fIsAlias , state@var643 ) ;
100: }
101: void isSpecialization ( bool state@var644 ) {
102: setFlag (@expr1073745915 fIsSpecialization , state@var644 ) ;
103: }
104: void isPartialSpecialization ( bool state@var645 ) {
105: setFlag (@expr1073745916 fIsPartialSpecialization , state@var645 ) ;
106: }
107: void isForwardDeclaration ( bool state@var646 ) {
108: setFlag (@expr1073745917 fIsForwardDeclaration , state@var646 ) ;
109: }
110: void isVariadic ( bool state@var647 ) {
111: setFlag (@expr1073745918 fIsVariadic , state@var647 ) ;
112: }
113: void isFriend ( bool state@var648 ) {
114: setFlag (@expr1073745919 fIsFriend , state@var648 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var649 ) const {
123: return (@expr4096 (@expr4096 mFlags@var639 &@expr1073745922 flag@var649 ) !=@expr1073745923 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var650 , bool state@var651 ) {
132: mFlags@var639 =@expr1073745924 state@var651 ?@expr1073745925 mFlags@var639 |@expr1073745926 flag@var650 :@expr1073745927 mFlags@var639 &@expr1073745928 ~@expr1073745929 flag@var650 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var652 , const std :: string & scope@var653 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var654 , const std :: string & scope@var655 , const Token * nameToken@var656 , const Token * paramEnd@var657 ) ;
150: TokenAndName ( const TokenAndName & other@var658 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var659 ) const {
154: return mToken@var633 ==@expr1073745930 rhs@var659 .@expr1073745931 mToken@var660 &&@expr1073745932 mScope@var634 ==@expr1073745933 rhs@var659 .@expr1073745934 mScope@var661 &&@expr1073745935 mName@var635 ==@expr1073745936 rhs@var659 .@expr1073745937 mName@var662 &&@expr1073745938 mFullName@var636 ==@expr1073745939 rhs@var659 .@expr1073745940 mFullName@var663 &&@expr1073745941
155: mNameToken@var637 ==@expr1073745942 rhs@var659 .@expr1073745943 mNameToken@var664 &&@expr1073745944 mParamEnd@var638 ==@expr1073745945 rhs@var659 .@expr1073745946 mParamEnd@var665 &&@expr1073745947 mFlags@var639 ==@expr1073745948 rhs@var659 .@expr1073745949 mFlags@var666 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var633 ;
160: }
161: void token ( Token * token@var667 ) {
162: mToken@var633 =@expr1073745950 token@var667 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var634 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var635 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var636 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var637 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var638 ;
178: }
179: void paramEnd ( const Token * end@var668 ) {
180: mParamEnd@var638 =@expr1073745951 end@var668 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745952 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745953 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745954 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745955 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745956 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745957 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745958 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745959 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745960 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var669 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var670 ) const {
243:
244:
245: return (@expr4137 (@expr4137 mFlags@var639 &@expr1073745963 fFamilyMask ) &@expr1073745964 (@expr4137 decl@var670 .@expr1073745966 mFlags@var671 &@expr1073745967 fFamilyMask ) ) !=@expr1073745968 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var672 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var673 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var674 , const unsigned long numberOfArguments@var675 , bool variadic@var676 , const char patternAfter@var677 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var678 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var679 , int & namepos@var680 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var681 , int & namepos@var682 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var683 , int & namepos@var684 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var685 ,
306: bool & codeWithTemplates@var686 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var687 , bool isTemplate@var688 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var689 = nullptr , Token * backToken@var690 = nullptr , bool isTemplate@var691 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var692 , Token * end@var693 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var694 , const std :: string & scope@var695 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var696 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var697 ,
393: const std :: list < const Token * > & specializations@var698 ,
394: const std :: time_t maxtime@var699 ,
395: std :: set < std :: string > & expandedtemplates@var700 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var701 , const Token * tok@var702 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var703 , const Token * tok@var704 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var705 ,
422: const TokenAndName & templateInstantiation@var706 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var707 ,
424: const std :: string & newName@var708 ,
425: bool copy@var709 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var710 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var711 ,
435: const std :: string & newName@var712 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var713 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var714 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var715 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var716 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var717 ,
458: const Token * templateInstantiationNameToken@var718 ,
459: const std :: list < const Token * > & specializations@var719 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var720 , const Token * end@var721 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var722 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var723 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var724 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var725 ,
487: const std :: string & indent@var726 = "    " ) const ;
488: void printOut ( const std :: string & text@var727 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var728 ;
491: TokenList & mTokenList@var729 ;
492: const Settings * mSettings@var730 ;
493: ErrorLogger * mErrorLogger@var731 ;
494: bool mChanged@var732 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var733 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var734 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var735 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var736 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var737 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var738 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var739 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var740 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var741 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var742 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var743 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var744 ;
57: Token * back@var745 ;
58: const TokenList * list@var746 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var747 , const Token * bodyEnd_@var748 , const std :: set < std :: string > & usingNamespaces_@var749 = std :: set < std :: string > ( ) ) : name@var750 ( name_@var747 ) , bodyEnd@var751 ( bodyEnd_@var748 ) , usingNamespaces@var752 ( usingNamespaces_@var749 ) { }
63: std :: string name@var750 ;
64: const Token * const bodyEnd@var751 ;
65: std :: set < std :: string > usingNamespaces@var752 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var753 ;
70: int mFileIndex@var754 ;
71: int mLineNumber@var755 ;
72: int mColumn@var756 ;
73: int mExprId@var757 ;
74:
75:
76: Token * mAstOperand1@var758 ;
77: Token * mAstOperand2@var759 ;
78: Token * mAstParent@var760 ;
79:
80:
81: const Scope * mScope@var761 ;
82: union {
83: const Function * mFunction@var762 ;
84: const Variable * mVariable@var763 ;
85: const :: Type * mType@var764 ;
86: const Enumerator * mEnumerator@var765 ;
87: } ;
88:
|
92:
93: int mProgressValue@var766 ;
94:
|
97:
98: int mIndex@var767 ;
99:
100:
101: std :: string * mOriginalName@var768 ;
102:
103:
104: ValueType * mValueType@var769 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var770 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var771 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var772 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var773 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var774 ;
119: long long value@var775 ;
120: struct CppcheckAttributes * next@var776 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var777 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var778 ;
126:
127:
128: unsigned char mBits@var779 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var780 , long long value@var781 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var782 , long long * value@var783 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var753 ( 0 )
135: , mFileIndex@var754 ( 0 )
136: , mLineNumber@var755 ( 0 )
137: , mColumn@var756 ( 0 )
138: , mExprId@var757 ( 0 )
139: , mAstOperand1@var758 ( nullptr )
140: , mAstOperand2@var759 ( nullptr )
141: , mAstParent@var760 ( nullptr )
142: , mScope@var761 ( nullptr )
143: , mFunction@var762 ( nullptr )
144: , mProgressValue@var766 ( 0 )
145: , mIndex@var767 ( 0 )
146: , mOriginalName@var768 ( nullptr )
147: , mValueType@var769 ( nullptr )
148: , mValues@var770 ( nullptr )
149: , mTemplateSimplifierPointers@var772 ( nullptr )
150: , mScopeInfo@var773 ( nullptr )
151: , mCppcheckAttributes@var777 ( nullptr )
152: , mCpp11init@var778 ( Cpp11init :: UNKNOWN )
153: , mBits@var779 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var784 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var785 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var786 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var787 ) {
199: mStr@var999 =@expr1073745969 s@var787 ;
200: mImpl@var1005 .@expr1073745970 mVarId@var1036 =@expr1073745971 0 ;
201:
202: update_property_info (@expr1073745972 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var788 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var999 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var789 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var790 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var791 ) const ;
236: Token * tokAt ( int index@var792 ) {
237: return const_cast < Token *@expr4149 > (@expr1073745974 const_cast < const Token *@expr4149 > (@expr1073745976 this@expr1073745977 ) .@expr1073745978 tokAt (@expr1073745979 index@var792 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var793 ) const ;
245: Token * linkAt ( int index@var794 ) {
246: return const_cast < Token *@expr4156 > (@expr1073745981 const_cast < const Token *@expr4156 > (@expr1073745983 this@expr1073745984 ) .@expr1073745985 linkAt (@expr1073745986 index@var794 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var795 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var796 , const char ( & pattern@var797 ) [ count ] ) {
276: return simpleMatch (@expr1073745988 tok@var796 , pattern@var797 , count@expr1073745987 -@expr1073745989 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var798 , const char pattern@var799 [ ] , unsigned long pattern_len@var800 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var801 , const char pattern@var802 [ ] , int varid@var803 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var804 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var805 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var806 , const Settings * const settings@var807 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var808 , long long index@var809 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1005 .@expr1073745990 mValueType@var1037 ;
366: }
367: void setValueType ( ValueType * vt@var810 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var811 ; top@var811 =@expr1073745991 this@expr1073745992 ;
371: while (@expr1073745993 top@var811 &&@expr1073745994 !@expr1073745995 Token ::@expr1073745996 Match (@expr1073745997 top@var811 .@expr4174 astParent (@expr4175 ) , ",|(" ) ) {
372: top@var811 =@expr1073746000 top@var811 .@expr4174 astParent (@expr4175 ) ; }
373: return top@var811 ?@expr1073746003 top@var811 .@expr1073746004 mImpl@var812 .@expr1073746005 mValueType@var813 :@expr1073746006 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1003 ;
378: }
379: void tokType ( Token :: Type t@var814 ) {
380: mTokType@var1003 =@expr1073746007 t@var814 ;
381:
382: const bool memoizedIsName@var815 =@expr1073746008 mTokType@var1003 ==@expr1073746009 eName ||@expr1073746010 mTokType@var1003 ==@expr1073746011 eType ||@expr1073746012 mTokType@var1003 ==@expr1073746013 eVariable ||@expr1073746014
383: mTokType@var1003 ==@expr1073746015 eFunction ||@expr1073746016 mTokType@var1003 ==@expr1073746017 eKeyword ||@expr1073746018 mTokType@var1003 ==@expr4195 eBoolean ||@expr1073746020
384: mTokType@var1003 ==@expr4197 eEnumerator ;
385: setFlag (@expr1073746022 fIsName , memoizedIsName@var815 ) ;
386:
387: const bool memoizedIsLiteral@var816 =@expr1073746023 mTokType@var1003 ==@expr1073746024 eNumber ||@expr1073746025 mTokType@var1003 ==@expr1073746026 eString ||@expr1073746027 mTokType@var1003 ==@expr1073746028 eChar ||@expr1073746029
388: mTokType@var1003 ==@expr4195 eBoolean ||@expr1073746031 mTokType@var1003 ==@expr1073746032 eLiteral ||@expr1073746033 mTokType@var1003 ==@expr4197 eEnumerator ;
389: setFlag (@expr1073746035 fIsLiteral , memoizedIsLiteral@var816 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1003 ==@expr1073746036 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073746037 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1004 ==@expr1073746038 fIsName &&@expr1073746039 mTokType@var1003 ==@expr1073746040 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073746041 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1003 ==@expr1073746042 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1003 ==@expr1073746043 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073746044 isConstOp (@expr1073746045 ) ||@expr1073746046
412: isAssignmentOp (@expr1073746047 ) ||@expr1073746048
413: mTokType@var1003 ==@expr1073746049 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073746050 isArithmeticalOp (@expr1073746051 ) ||@expr1073746052
417: mTokType@var1003 ==@expr1073746053 eLogicalOp ||@expr1073746054
418: mTokType@var1003 ==@expr1073746055 eComparisonOp ||@expr1073746056
419: mTokType@var1003 ==@expr1073746057 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073746058 ) ||@expr1073746059
423: mTokType@var1003 ==@expr1073746060 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1003 ==@expr1073746061 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1003 ==@expr1073746062 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1003 ==@expr1073746063 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1003 ==@expr1073746064 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1003 ==@expr1073746065 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073746066 ) !=@expr1073746067 nullptr &&@expr1073746068 astOperand2 (@expr1073746069 ) !=@expr1073746070 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var817 ) const {
444: return s@var817 ==@expr1073746071 mStr@var999 &&@expr1073746072 astOperand1 (@expr1073746073 ) !=@expr1073746074 nullptr &&@expr1073746075 astOperand2 (@expr1073746076 ) ==@expr1073746077 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1004 ;
450: }
451: void flags ( const unsigned int flags_@var818 ) {
452: mFlags@var1004 =@expr1073746078 flags_@var818 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073746079 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var819 ) {
458: setFlag (@expr1073746080 fIsUnsigned , sign@var819 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073746081 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var820 ) {
464: setFlag (@expr1073746082 fIsSigned , sign@var820 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073746083 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var821 ) {
470: setFlag (@expr1073746084 fIsPointerCompare , b@var821 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073746085 fIsLong ) ;
474: }
475: void isLong ( bool size@var822 ) {
476: setFlag (@expr1073746086 fIsLong , size@var822 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073746087 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var823 ) {
482: setFlag (@expr1073746088 fIsStandardType , b@var823 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073746089 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var824 ) {
488: setFlag (@expr1073746090 fIsExpandedMacro , m@var824 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073746091 fIsCast ) ;
492: }
493: void isCast ( bool c@var825 ) {
494: setFlag (@expr1073746092 fIsCast , c@var825 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073746093 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var826 ) {
500: setFlag (@expr1073746094 fIsAttributeConstructor , ac@var826 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073746095 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var827 ) {
506: setFlag (@expr1073746096 fIsAttributeDestructor , value@var827 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073746097 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var828 ) {
512: setFlag (@expr1073746098 fIsAttributeUnused , unused@var828 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073746099 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var829 ) {
518: setFlag (@expr1073746100 fIsAttributeUsed , unused@var829 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073746101 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var830 ) {
524: setFlag (@expr1073746102 fIsAttributePure , value@var830 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073746103 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var831 ) {
530: setFlag (@expr1073746104 fIsAttributeConst , value@var831 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073746105 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var832 ) {
536: setFlag (@expr1073746106 fIsAttributeNoreturn , value@var832 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073746107 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var833 ) {
542: setFlag (@expr1073746108 fIsAttributeNothrow , value@var833 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073746109 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var834 ) {
548: setFlag (@expr1073746110 fIsAttributePacked , value@var834 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073746111 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var835 ) {
554: setFlag (@expr1073746112 fIsAttributeNodiscard , value@var835 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073746113 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var836 ) {
560: setFlag (@expr1073746114 fIsAttributeMaybeUnused , value@var836 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var837 , long long value@var838 ) {
563: mImpl@var1005 .@expr1073746115 setCppcheckAttribute (@expr1073746116 type@var837 , value@var838 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var839 , long long * value@var840 ) const {
566: return mImpl@var1005 .@expr1073746117 getCppcheckAttribute (@expr1073746118 type@var839 , value@var840 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073746119 mImpl@var1005 .@expr1073746120 mCppcheckAttributes@var1038 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073746121 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073746122 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var841 ) {
578: setFlag (@expr1073746123 fIsOperatorKeyword , value@var841 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073746124 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var842 ) {
584: setFlag (@expr1073746125 fIsComplex , value@var842 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073746126 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var843 ) {
590: setFlag (@expr1073746127 fIsEnumType , value@var843 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073746128 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var844 ) {
596: setFlag (@expr1073746129 fAtAddress , b@var844 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073746130 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var845 ) {
602: setFlag (@expr1073746131 fIncompleteVar , b@var845 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073746132 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var846 ) {
609: setFlag (@expr1073746133 fIsIncompleteConstant , b@var846 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073746134 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var847 ) {
616: setFlag (@expr1073746135 fConstexpr , b@var847 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073746136 fExternC ) ;
621: }
622: void isExternC ( bool b@var848 ) {
623: setFlag (@expr1073746137 fExternC , b@var848 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073746138 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var849 ) {
630: setFlag (@expr1073746139 fIsSplitVarDeclComma , b@var849 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073746140 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var850 ) {
637: setFlag (@expr1073746141 fIsSplitVarDeclEq , b@var850 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073746142 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var851 ) {
644: setFlag (@expr1073746143 fIsImplicitInt , b@var851 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073746144 fIsInline ) ;
649: }
650: void isInline ( bool b@var852 ) {
651: setFlag (@expr1073746145 fIsInline , b@var852 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073746146 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var853 ) {
658: setFlag (@expr1073746147 fIsRemovedVoidParameter , b@var853 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073746148 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var854 ) {
665: setFlag (@expr1073746149 fIsTemplate , b@var854 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073746150 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var855 ) {
672: setFlag (@expr1073746151 fIsSimplifedScope , b@var855 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1005 .@expr1073746152 mBits@var1039 >@expr1073746153 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1005 .@expr1073746154 mBits@var1039 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1005 .@expr1073746155 mTemplateSimplifierPointers@var1040 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var856 ) {
685: if (@expr1073746156 !@expr1073746157 mImpl@var1005 .@expr4334 mTemplateSimplifierPointers@var1040 ) {
686: mImpl@var1005 .@expr4334 mTemplateSimplifierPointers@var1040 =@expr1073746160 new std ::@expr1073746161 set < TemplateSimplifier ::@expr1073746162 TokenAndName *@expr1073746163 > ; }
687: mImpl@var1005 .@expr4334 mTemplateSimplifierPointers@var1040 .@expr1073746165 insert (@expr1073746166 tokenAndName@var856 ) ;
688: }
689: void setBits ( const unsigned char b@var857 ) {
690: mImpl@var1005 .@expr1073746167 mBits@var1039 =@expr1073746168 b@var857 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4345 (@expr4345 (@expr4345 mTokType@var1003 ==@expr1073746172 eString ) &&@expr1073746173 isPrefixStringCharLiteral (@expr1073746174 mStr@var999 , '"' , "u8" ) ) ||@expr1073746175
695: (@expr4345 (@expr4345 mTokType@var1003 ==@expr1073746178 eChar ) &&@expr1073746179 isPrefixStringCharLiteral (@expr1073746180 mStr@var999 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4357 (@expr4357 (@expr4357 mTokType@var1003 ==@expr1073746184 eString ) &&@expr1073746185 isPrefixStringCharLiteral (@expr1073746186 mStr@var999 , '"' , "u" ) ) ||@expr1073746187
700: (@expr4357 (@expr4357 mTokType@var1003 ==@expr1073746190 eChar ) &&@expr1073746191 isPrefixStringCharLiteral (@expr1073746192 mStr@var999 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4369 (@expr4369 (@expr4369 mTokType@var1003 ==@expr1073746196 eString ) &&@expr1073746197 isPrefixStringCharLiteral (@expr1073746198 mStr@var999 , '"' , "U" ) ) ||@expr1073746199
705: (@expr4369 (@expr4369 mTokType@var1003 ==@expr1073746202 eChar ) &&@expr1073746203 isPrefixStringCharLiteral (@expr1073746204 mStr@var999 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4381 (@expr4381 (@expr4381 mTokType@var1003 ==@expr1073746208 eString ) &&@expr1073746209 isPrefixStringCharLiteral (@expr1073746210 mStr@var999 , '"' , "" ) ) ||@expr1073746211
710: (@expr4381 (@expr4381 mTokType@var1003 ==@expr1073746214 eChar ) &&@expr1073746215 isPrefixStringCharLiteral (@expr1073746216 mStr@var999 , '\'' , "" ) &&@expr1073746217 mStr@var999 .@expr1073746218 length (@expr1073746219 ) ==@expr1073746220 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4397 (@expr4397 (@expr4397 mTokType@var1003 ==@expr1073746224 eChar ) &&@expr1073746225 isPrefixStringCharLiteral (@expr1073746226 mStr@var999 , '\'' , "" ) ) &&@expr1073746227
715: (@expr4397 mStr@var999 .@expr1073746229 length (@expr1073746230 ) >@expr1073746231 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073746232 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var858 ) {
738: setFlag (@expr1073746233 fIsTemplateArg , value@var858 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var859 , const char ( & pattern@var860 ) [ count ] ) {
743: return findsimplematch (@expr1073746235 startTok@var859 , pattern@var860 , count@expr1073746234 -@expr1073746236 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var861 , const char pattern@var862 [ ] , unsigned long pattern_len@var863 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var864 , const char ( & pattern@var865 ) [ count ] , const Token * const end@var866 ) {
749: return findsimplematch (@expr1073746238 startTok@var864 , pattern@var865 , count@expr1073746237 -@expr1073746239 1 , end@var866 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var867 , const char pattern@var868 [ ] , unsigned long pattern_len@var869 , const Token * const end@var870 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var871 , const char pattern@var872 [ ] , const int varId@var873 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var874 , const char pattern@var875 [ ] , const Token * const end@var876 , const int varId@var877 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var878 , const char ( & pattern@var879 ) [ count ] ) {
758: return findsimplematch (@expr1073746241 startTok@var878 , pattern@var879 , count@expr1073746240 -@expr1073746242 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var880 , const char pattern@var881 [ ] , unsigned long pattern_len@var882 ) {
761: return const_cast < Token *@expr4419 > (@expr1073746244 findsimplematch (@expr1073746245 const_cast < const Token *@expr4419 > (@expr1073746247 startTok@var880 ) , pattern@var881 , pattern_len@var882 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var883 , const char ( & pattern@var884 ) [ count ] , const Token * const end@var885 ) {
765: return findsimplematch (@expr1073746249 startTok@var883 , pattern@var884 , count@expr1073746248 -@expr1073746250 1 , end@var885 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var886 , const char pattern@var887 [ ] , unsigned long pattern_len@var888 , const Token * const end@var889 ) {
768: return const_cast < Token *@expr4427 > (@expr1073746252 findsimplematch (@expr1073746253 const_cast < const Token *@expr4427 > (@expr1073746255 startTok@var886 ) , pattern@var887 , pattern_len@var888 , end@var889 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var890 , const char pattern@var891 [ ] , const int varId@var892 = 0 ) {
772: return const_cast < Token *@expr4432 > (@expr1073746257 findmatch (@expr1073746258 const_cast < const Token *@expr4432 > (@expr1073746260 startTok@var890 ) , pattern@var891 , varId@var892 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var893 , const char pattern@var894 [ ] , const Token * const end@var895 , const int varId@var896 = 0 ) {
775: return const_cast < Token *@expr4437 > (@expr1073746262 findmatch (@expr1073746263 const_cast < const Token *@expr4437 > (@expr1073746265 startTok@var893 ) , pattern@var894 , end@var895 , varId@var896 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var897 , const char * haystack@var898 , int varid@var899 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1005 .@expr1073746266 mFileIndex@var1041 ;
796: }
797: void fileIndex ( int indexOfFile@var900 ) {
798: mImpl@var1005 .@expr1073746267 mFileIndex@var1041 =@expr1073746268 indexOfFile@var900 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1005 .@expr1073746269 mLineNumber@var1042 ;
803: }
804: void linenr ( int lineNumber@var901 ) {
805: mImpl@var1005 .@expr1073746270 mLineNumber@var1042 =@expr1073746271 lineNumber@var901 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1005 .@expr1073746272 mColumn@var1043 ;
810: }
811: void column ( int c@var902 ) {
812: mImpl@var1005 .@expr1073746273 mColumn@var1043 =@expr1073746274 c@var902 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1000 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var903 , const Token * end@var904 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var905 , const std :: string & originalNameStr@var906 = emptyString@var1 , bool prepend@var907 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var908 , const std :: string & originalNameStr@var909 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746275 tokenStr@var908 , originalNameStr@var909 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1001 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1005 .@expr1073746276 mVarId@var1036 ;
851: }
852: void varId ( int id@var910 ) {
853: mImpl@var1005 .@expr1073746277 mVarId@var1036 =@expr1073746278 id@var910 ;
854: if (@expr1073746279 id@var910 !=@expr1073746280 0 ) {
855: tokType (@expr1073746281 eVariable ) ;
856: isStandardType (@expr1073746282 false ) ;
857: } else {
858: update_property_info (@expr1073746283 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746284 mImpl@var1005 .@expr4461 mExprId@var1044 ) {
864: return mImpl@var1005 .@expr4461 mExprId@var1044 ; }
865: return mImpl@var1005 .@expr1073746287 mVarId@var1036 ;
866: }
867: void exprId ( int id@var911 ) {
868: mImpl@var1005 .@expr1073746288 mExprId@var1044 =@expr1073746289 id@var911 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var912 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var913 , const std :: vector < std :: string > & fileNames@var914 ) const ;
888:
|
891:
892: void printLines ( int lines@var915 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var916 , Token * start@var917 , Token * end@var918 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var919 ; varid@var919 = false ;
905: bool exprid@var920 ; exprid@var920 = false ;
906: bool idtype@var921 ; idtype@var921 = false ;
907: bool attributes@var922 ; attributes@var922 = false ;
908: bool macro@var923 ; macro@var923 = false ;
909: bool linenumbers@var924 ; linenumbers@var924 = false ;
910: bool linebreaks@var925 ; linebreaks@var925 = false ;
911: bool files@var926 ; files@var926 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var927 ;
914: options@var927 .@expr1073746290 attributes@var928 =@expr1073746291 true ;
915: options@var927 .@expr1073746292 macro@var929 =@expr1073746293 true ;
916: options@var927 .@expr1073746294 linenumbers@var930 =@expr1073746295 true ;
917: options@var927 .@expr1073746296 linebreaks@var931 =@expr1073746297 true ;
918: options@var927 .@expr1073746298 files@var932 =@expr1073746299 true ;
919: return options@var927 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var933 ; options@var933 =@expr1073746300 forDebug (@expr1073746301 ) ;
923: options@var933 .@expr1073746302 varid@var934 =@expr1073746303 true ;
924: return options@var933 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var935 ; options@var935 =@expr1073746304 forDebug (@expr1073746305 ) ;
928: options@var935 .@expr1073746306 exprid@var936 =@expr1073746307 true ;
929: return options@var935 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var937 ; options@var937 =@expr1073746308 forDebug (@expr1073746309 ) ;
933: options@var937 .@expr1073746310 exprid@var938 =@expr1073746311 true ;
934: options@var937 .@expr1073746312 varid@var939 =@expr1073746313 true ;
935: options@var937 .@expr1073746314 idtype@var940 =@expr1073746315 true ;
936: return options@var937 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var941 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var942 , bool attributes@var943 , bool macro@var944 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var945 , const std :: vector < std :: string > * fileNames@var946 = nullptr , const Token * end@var947 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var948 , bool attributes@var949 = true ) const ;
952: std :: string stringifyList ( bool varid@var950 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var951 , bool attributes@var952 , bool linenumbers@var953 , bool linebreaks@var954 , bool files@var955 , const std :: vector < std :: string > * fileNames@var956 = nullptr , const Token * end@var957 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var958 ) {
983: mLink@var1002 =@expr1073746316 linkToToken@var958 ;
984: if (@expr1073746317 mStr@var999 ==@expr1073746318 "<" ||@expr1073746319 mStr@var999 ==@expr1073746320 ">" ) {
985: update_property_info (@expr1073746321 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1002 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var959 ) {
1006: mImpl@var1005 .@expr1073746322 mScope@var1045 =@expr1073746323 s@var959 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1005 .@expr1073746324 mScope@var1045 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var960 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1003 ==@expr1073746325 eFunction ||@expr1073746326 mTokType@var1003 ==@expr1073746327 eLambda ?@expr1073746328 mImpl@var1005 .@expr1073746329 mFunction@var1046 :@expr1073746330 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var961 ) {
1034: mImpl@var1005 .@expr1073746331 mVariable@var1047 =@expr1073746332 v@var961 ;
1035: if (@expr1073746333 v@var961 ||@expr1073746334 mImpl@var1005 .@expr1073746335 mVarId@var1036 ) {
1036: tokType (@expr1073746336 eVariable ) ; }
1037: else { if (@expr1073746337 mTokType@var1003 ==@expr1073746338 eVariable ) {
1038: tokType (@expr1073746339 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1003 ==@expr1073746340 eVariable ?@expr1073746341 mImpl@var1005 .@expr1073746342 mVariable@var1047 :@expr1073746343 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var962 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1003 ==@expr1073746344 eType ?@expr1073746345 mImpl@var1005 .@expr1073746346 mType@var1048 :@expr1073746347 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var963 , const Token * * typeTok@var964 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var965 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var966 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1003 ==@expr1073746348 eEnumerator ?@expr1073746349 mImpl@var1005 .@expr1073746350 mEnumerator@var1049 :@expr1073746351 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var967 ) {
1079: mImpl@var1005 .@expr1073746352 mEnumerator@var1049 =@expr1073746353 e@var967 ;
1080: if (@expr1073746354 e@var967 ) {
1081: tokType (@expr1073746355 eEnumerator ) ; }
1082: else { if (@expr1073746356 mTokType@var1003 ==@expr1073746357 eEnumerator ) {
1083: tokType (@expr1073746358 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var968 , Token * end@var969 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var970 , Token * srcEnd@var971 , Token * newLocation@var972 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1005 .@expr1073746359 mProgressValue@var1050 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var973 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1005 .@expr4536 mOriginalName@var1051 ?@expr1073746361 *@expr1073746362 mImpl@var1005 .@expr4536 mOriginalName@var1051 :@expr1073746364 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1005 .@expr4541 mValues@var1024 ?@expr1073746366 *@expr1073746367 mImpl@var1005 .@expr4541 mValues@var1024 :@expr1073746369 TokenImpl ::@expr1073746370 mEmptyValueList@var771 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var974 ) {
1164: if (@expr1073746371 !@expr1073746372 mImpl@var1005 .@expr4549 mOriginalName@var1051 ) {
1165: mImpl@var1005 .@expr4549 mOriginalName@var1051 =@expr1073746375 new std ::@expr1073746376 string (@expr1073746377 name@var974 ) ; }
1166: else {
1167: *@expr1073746378 mImpl@var1005 .@expr4549 mOriginalName@var1051 =@expr1073746380 name@var974 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var975 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var976 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var977 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1005 .@expr1073746382 mValues@var1024 .@expr1073746383 front (@expr1073746384 ) .@expr1073746385 intvalue@expr1073746381 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var978 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var979 , long long path@var980 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var981 , const Settings * settings@var982 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var983 , const Settings * settings@var984 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var985 , int argnr@var986 , const Settings * settings@var987 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var988 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var989 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var990 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var991 ) {
1200: if (@expr1073746386 mImpl@var1005 .@expr4563 mValues@var1024 ) {
1201: mImpl@var1005 .@expr4563 mValues@var1024 .@expr1073746389 remove_if (@expr1073746390 pred@var991 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1005 .@expr1073746391 mIndex@var1052 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var992 ) {
1213: mNext@var1000 =@expr1073746392 nextToken@var992 ;
1214: }
1215: void previous ( Token * previousToken@var993 ) {
1216: mPrevious@var1001 =@expr1073746393 previousToken@var993 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var994 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var995 , const char * word@var996 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var997 , char c@var998 ) ;
1235:
1236: std :: string mStr@var999 ;
1237:
1238: Token * mNext@var1000 ;
1239: Token * mPrevious@var1001 ;
1240: Token * mLink@var1002 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1003 ;
1283:
1284: uint64_t mFlags@var1004 ;
1285:
1286: TokenImpl * mImpl@var1005 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1006 ) const {
1294: return (@expr4570 (@expr4570 mFlags@var1004 &@expr1073746396 flag_@var1006 ) !=@expr1073746397 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1007 , bool state_@var1008 ) {
1303: mFlags@var1004 =@expr1073746398 state_@var1008 ?@expr1073746399 mFlags@var1004 |@expr1073746400 flag_@var1007 :@expr1073746401 mFlags@var1004 &@expr1073746402 ~@expr1073746403 flag_@var1007 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1009 , const int indent1@var1010 = 0 , const int indent2@var1011 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1012 ) ;
1321: void astOperand2 ( Token * tok@var1013 ) ;
1322: void astParent ( Token * tok@var1014 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1005 .@expr1073746404 mAstOperand1@var1015 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1005 .@expr1073746405 mAstOperand1@var1015 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1005 .@expr1073746406 mAstOperand2@var1016 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1005 .@expr1073746407 mAstOperand2@var1016 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1005 .@expr1073746408 mAstParent@var1017 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1005 .@expr1073746409 mAstParent@var1017 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746410 !@expr1073746411 astParent (@expr4588 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746413 this@expr4590 ==@expr1073746415 astParent (@expr4588 ) .@expr4593 astOperand1 (@expr4594 ) ) {
1346: return astParent (@expr4588 ) .@expr4596 astOperand2 (@expr4597 ) ; }
1347: else { if (@expr1073746422 this@expr4590 ==@expr1073746423 astParent (@expr4588 ) .@expr4596 astOperand2 (@expr4597 ) ) {
1348: return astParent (@expr4588 ) .@expr4593 astOperand1 (@expr4594 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746430 !@expr1073746431 astParent (@expr4608 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746433 this@expr4610 ==@expr1073746435 astParent (@expr4608 ) .@expr4613 astOperand1 (@expr4614 ) ) {
1356: return astParent (@expr4608 ) .@expr4616 astOperand2 (@expr4617 ) ; }
1357: else { if (@expr1073746442 this@expr4610 ==@expr1073746443 astParent (@expr4608 ) .@expr4616 astOperand2 (@expr4617 ) ) {
1358: return astParent (@expr4608 ) .@expr4613 astOperand1 (@expr4614 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1018 ; ret@var1018 =@expr1073746450 this@expr1073746451 ;
1364: while (@expr1073746452 ret@var1018 .@expr4629 mImpl@var1019 .@expr4630 mAstParent@var1020 ) {
1365: ret@var1018 =@expr1073746455 ret@var1018 .@expr4629 mImpl@var1019 .@expr4630 mAstParent@var1020 ; }
1366: return ret@var1018 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1021 ; ret@var1021 =@expr1073746458 this@expr1073746459 ;
1371: while (@expr1073746460 ret@var1021 .@expr4637 mImpl@var1022 .@expr4638 mAstParent@var1023 ) {
1372: ret@var1021 =@expr1073746463 ret@var1021 .@expr4637 mImpl@var1022 .@expr4638 mAstParent@var1023 ; }
1373: return ret@var1021 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1005 .@expr1073746466 mAstOperand1@var1015 =@expr1073746467 mImpl@var1005 .@expr1073746468 mAstOperand2@var1016 =@expr1073746469 mImpl@var1005 .@expr1073746470 mAstParent@var1017 =@expr1073746471 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1005 .@expr4648 mValues@var1024 ;
1393: mImpl@var1005 .@expr4648 mValues@var1024 =@expr1073746474 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1025 = "" ) const {
1397: std ::@expr1073746475 string ret@var1026 ;
1398: if (@expr1073746476 mImpl@var1005 .@expr4653 mAstOperand1@var1015 ) {
1399: ret@var1026 =@expr1073746478 mImpl@var1005 .@expr4653 mAstOperand1@var1015 .@expr1073746480 astString (@expr1073746481 sep@var1025 ) ; }
1400: if (@expr1073746482 mImpl@var1005 .@expr4659 mAstOperand2@var1016 ) {
1401: ret@var1026 +=@expr1073746484 mImpl@var1005 .@expr4659 mAstOperand2@var1016 .@expr1073746486 astString (@expr1073746487 sep@var1025 ) ; }
1402: return ret@var1026 +@expr1073746488 sep@var1025 +@expr1073746489 mStr@var999 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1027 , bool xml@var1028 , const std :: vector < std :: string > & fileNames@var1029 , std :: ostream & out@var1030 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1031 , std :: ostream & out@var1032 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1033 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1034 ) const {
1419: mImpl@var1005 .@expr1073746490 mCpp11init@var1035 =@expr1073746491 cpp11init@var1034 ?@expr1073746492 TokenImpl ::@expr4669 Cpp11init ::@expr1073746494 CPP11INIT :@expr1073746495 TokenImpl ::@expr4669 Cpp11init ::@expr1073746497 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1005 .@expr1073746498 mCpp11init@var1035 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1053 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1054 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1055 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1056 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1057 ( nullptr ) , num@var1058 ( 0 ) , known@var1059 ( true ) { }
62:
63: const Token * tok@var1057 ;
64: long long num@var1058 ;
65: bool known@var1059 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1060 ;
72: const Scope * classScope@var1061 ;
73: const Scope * enclosingScope@var1062 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1063 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1065 ( nullptr ) , nameTok@var1066 ( nullptr ) , access@var1067 ( AccessControl :: Public ) , isVirtual@var1068 ( false ) { }
82:
83: std :: string name@var1064 ;
84: const Type * type@var1065 ;
85: const Token * nameTok@var1066 ;
86: AccessControl access@var1067 ;
87: bool isVirtual@var1068 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1069 ) const {
90: return this@expr1073746499 .@expr1073746500 type@var1065 <@expr1073746501 rhs@var1069 .@expr1073746502 type@var1070 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1071 ( nullptr ) , nameEnd@var1072 ( nullptr ) , type@var1073 ( nullptr ) { }
97:
98: const Token * nameStart@var1071 ;
99: const Token * nameEnd@var1072 ;
100: const Type * type@var1073 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1074 ;
104: std :: vector < FriendInfo > friendList@var1075 ;
105:
106: const Token * typeStart@var1076 ;
107: const Token * typeEnd@var1077 ;
108: long long sizeOf@var1078 ;
109:
110: Type ( const Token * classDef_@var1079 = nullptr , const Scope * classScope_@var1080 = nullptr , const Scope * enclosingScope_@var1081 = nullptr ) :
111: classDef@var1060 ( classDef_@var1079 ) ,
112: classScope@var1061 ( classScope_@var1080 ) ,
113: enclosingScope@var1062 ( enclosingScope_@var1081 ) ,
114: needInitialization@var1063 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1076 ( nullptr ) ,
116: typeEnd@var1077 ( nullptr ) ,
117: sizeOf@var1078 ( 0 ) {
118: if (@expr1073746503 classDef_@var1079 &&@expr1073746504 classDef_@var1079 .@expr4681 str (@expr4682 ) ==@expr1073746507 "enum" ) {
119: needInitialization@var1063 =@expr1073746508 NeedInitialization ::@expr1073746509 True ; }
120: else { if (@expr1073746510 classDef_@var1079 &&@expr1073746511 classDef_@var1079 .@expr4681 str (@expr4682 ) ==@expr1073746514 "using" ) {
121: typeStart@var1076 =@expr1073746515 classDef@var1060 .@expr1073746516 tokAt (@expr1073746517 3 ) ;
122: typeEnd@var1077 =@expr1073746518 typeStart@var1076 ;
123: while (@expr1073746519 typeEnd@var1077 .@expr4696 next (@expr4697 ) &&@expr1073746522 typeEnd@var1077 .@expr4696 next (@expr4697 ) .@expr1073746525 str (@expr1073746526 ) !=@expr1073746527 ";" ) {
124: typeEnd@var1077 =@expr1073746528 typeEnd@var1077 .@expr4696 next (@expr4697 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1060 ?@expr1073746531 classDef@var1060 .@expr1073746532 str (@expr1073746533 ) :@expr1073746534 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1060 &&@expr1073746535 classDef@var1060 .@expr1073746536 str (@expr1073746537 ) ==@expr1073746538 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1082 , const Token * tok1@var1083 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1084 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1085 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1086 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1087 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1088 ) : scope@var1089 ( scope_@var1088 ) , name@var1090 ( nullptr ) , value@var1091 ( 0 ) , start@var1092 ( nullptr ) , end@var1093 ( nullptr ) , value_known@var1094 ( false ) { }
167: const Scope * scope@var1089 ;
168: const Token * name@var1090 ;
169: long long value@var1091 ;
170: const Token * start@var1092 ;
171: const Token * end@var1093 ;
172: bool value_known@var1094 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1095 ) const {
204: return (@expr4715 (@expr4715 mFlags@var1131 &@expr1073746541 flag_@var1095 ) !=@expr1073746542 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1096 , bool state_@var1097 ) {
213: mFlags@var1131 =@expr1073746543 state_@var1097 ?@expr1073746544 mFlags@var1131 |@expr1073746545 flag_@var1096 :@expr1073746546 mFlags@var1131 &@expr1073746547 ~@expr1073746548 flag_@var1096 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1098 , bool * isContainer@var1099 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1100 , const Token * start_@var1101 , const Token * end_@var1102 ,
226: int index_@var1103 , AccessControl access_@var1104 , const Type * type_@var1105 ,
227: const Scope * scope_@var1106 , const Settings * settings@var1107 )
228: : mNameToken@var1126 ( name_@var1100 ) ,
229: mTypeStartToken@var1127 ( start_@var1101 ) ,
230: mTypeEndToken@var1128 ( end_@var1102 ) ,
231: mIndex@var1129 ( index_@var1103 ) ,
232: mAccess@var1130 ( access_@var1104 ) ,
233: mFlags@var1131 ( 0 ) ,
234: mType@var1132 ( type_@var1105 ) ,
235: mScope@var1133 ( scope_@var1106 ) ,
236: mValueType@var1134 ( nullptr ) {
237: evaluate (@expr1073746549 settings@var1107 ) ;
238: }
239:
240: Variable ( const Token * name_@var1108 , const std :: string & clangType@var1109 , const Token * typeStart@var1110 ,
241: const Token * typeEnd@var1111 , int index_@var1112 , AccessControl access_@var1113 ,
242: const Type * type_@var1114 , const Scope * scope_@var1115 ) ;
243:
244: Variable ( const Variable & var@var1116 , const Scope * scope@var1117 ) ;
245:
246: Variable ( const Variable & var@var1118 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1119 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1126 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1127 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1128 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746550 mNameToken@var1126 ) {
300: return mNameToken@var1126 .@expr1073746551 str (@expr1073746552 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746553 mNameToken@var1126 ) {
312: return mNameToken@var1126 .@expr1073746554 varId (@expr1073746555 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1129 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1130 ==@expr1073746556 AccessControl ::@expr1073746557 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1130 ==@expr1073746558 AccessControl ::@expr1073746559 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1130 ==@expr1073746560 AccessControl ::@expr1073746561 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1130 ==@expr1073746562 AccessControl ::@expr1073746563 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1130 ==@expr1073746564 AccessControl ::@expr1073746565 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1130 ==@expr1073746566 AccessControl ::@expr1073746567 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746569 mAccess@var1130 ==@expr1073746570 AccessControl ::@expr1073746571 Local@expr1073746568 ) &&@expr1073746572 !@expr1073746573 isExtern (@expr1073746574 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746575 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746576 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746577 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746578 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746579 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1130 ==@expr1073746580 AccessControl ::@expr1073746581 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746582 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746583 fIsArray ) &&@expr1073746584 !@expr1073746585 getFlag (@expr1073746586 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746587 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746588 ) &&@expr1073746589 getFlag (@expr1073746590 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746591 fIsArray ) ||@expr1073746592 getFlag (@expr1073746593 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746594 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746595 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746596 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746597 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1132 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1132 ?@expr1073746598 mType@var1132 .@expr1073746599 classScope@var1137 :@expr1073746600 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1133 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1135 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1120 ) const {
550: return mDimensions@var1135 [@expr1073746601 index_@var1120 ] .@expr1073746602 num@var3311 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1121 ) const {
558: return mDimensions@var1135 [@expr1073746603 index_@var1121 ] .@expr1073746604 known@var3312 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746605 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746606 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746607 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1122 ) const {
602: return isStlType (@expr1073746608 ) &&@expr1073746609 stlType@var1122 ==@expr1073746610 mTypeStartToken@var1127 .@expr1073746611 strAt (@expr1073746612 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1123 ) const {
616: return isStlType (@expr1073746613 ) &&@expr1073746614 stlTypes@var1123 .@expr1073746615 find (@expr1073746616 mTypeStartToken@var1127 .@expr1073746617 strAt (@expr1073746618 2 ) ) !=@expr1073746619 stlTypes@var1123 .@expr1073746620 end (@expr1073746621 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746622 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4799 ) &&@expr1073746624 type (@expr4799 ) .@expr1073746626 isEnumType (@expr1073746627 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746628 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1134 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1124 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1130 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1125 ) {
660: mType@var1132 =@expr1073746629 t@var1125 ;
661: }
662:
663:
664: const Token * mNameToken@var1126 ;
665:
666:
667: const Token * mTypeStartToken@var1127 ;
668:
669:
670: const Token * mTypeEndToken@var1128 ;
671:
672:
673: int mIndex@var1129 ;
674:
675:
676: AccessControl mAccess@var1130 ;
677:
678:
679: unsigned int mFlags@var1131 ;
680:
681:
682: const Type * mType@var1132 ;
683:
684:
685: const Scope * mScope@var1133 ;
686:
687: ValueType * mValueType@var1134 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1135 ;
691:
692:
693: void evaluate ( const Settings * settings@var1136 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1138 ) const {
735: return (@expr4806 (@expr4806 mFlags@var1187 &@expr1073746632 flag@var1138 ) !=@expr1073746633 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1139 , bool state@var1140 ) {
744: mFlags@var1187 =@expr1073746634 state@var1140 ?@expr1073746635 mFlags@var1187 |@expr1073746636 flag@var1139 :@expr1073746637 mFlags@var1187 &@expr1073746638 ~@expr1073746639 flag@var1139 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1141 , const Token * tok@var1142 , const Scope * scope@var1143 , const Token * tokDef@var1144 , const Token * tokArgDef@var1145 ) ;
751: Function ( const Token * tokenDef@var1146 , const std :: string & clangType@var1147 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1157 .@expr1073746640 str (@expr1073746641 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1165 .@expr1073746642 size (@expr1073746643 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1165 .@expr1073746644 size (@expr1073746645 ) -@expr1073746646 initArgCount@var1166 ;
764: }
765: const Variable * getArgumentVar ( int num@var1148 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1166 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1149 , const Scope * scope@var1150 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1151 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1152 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1167 ==@expr1073746647 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1167 ==@expr1073746648 eConstructor ||@expr1073746649
785: type@var1167 ==@expr1073746650 eCopyConstructor ||@expr1073746651
786: type@var1167 ==@expr1073746652 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1167 ==@expr1073746653 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1157 .@expr1073746654 isAttributeConstructor (@expr1073746655 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1157 .@expr1073746656 isAttributeDestructor (@expr1073746657 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1157 .@expr1073746658 isAttributePure (@expr1073746659 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1157 .@expr1073746660 isAttributeConst (@expr1073746661 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1157 .@expr1073746662 isAttributeNoreturn (@expr1073746663 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1157 .@expr1073746664 isAttributeNothrow (@expr1073746665 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1157 .@expr1073746666 isAttributeNodiscard (@expr1073746667 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746668 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746669 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746670 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746671 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746672 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746673 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746674 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746675 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746676 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746677 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746678 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746679 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746680 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746681 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746682 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746683 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746684 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746685 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746686 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746687 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746688 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746689 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1153 ) {
881: setFlag (@expr1073746690 fHasBody , state@var1153 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746691 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746692 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1154 ) {
891: setFlag (@expr1073746693 fIsEscapeFunction , state@var1154 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746694 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1155 ) {
898: setFlag (@expr1073746695 fIsConstexpr , state@var1155 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1156 ) const ;
901:
902: const Token * tokenDef@var1157 ;
903: const Token * argDef@var1158 ;
904: const Token * token@var1159 ;
905: const Token * arg@var1160 ;
906: const Token * retDef@var1161 ;
907: const :: Type * retType@var1162 ;
908: const Scope * functionScope@var1163 ;
909: const Scope * nestedIn@var1164 ;
910: std :: list < Variable > argumentList@var1165 ;
911: int initArgCount@var1166 ;
912: Type type@var1167 ;
913: AccessControl access@var1168 ;
914: const Token * noexceptArg@var1169 ;
915: const Token * throwArg@var1170 ;
916: const Token * templateDef@var1171 ;
917: const Token * functionPointerUsage@var1172 ;
918:
919: bool argsMatch ( const Scope * scope@var1173 , const Token * first@var1174 , const Token * second@var1175 , const std :: string & path@var1176 , int path_length@var1177 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1178 , bool unknown@var1179 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1180 , bool unknown@var1181 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1182 , bool unknown@var1183 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1184 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746696 this@expr1073746697 .@expr1073746698 hasTrailingReturnType (@expr1073746699 ) ) {
931: return Token ::@expr1073746700 findmatch (@expr1073746701 retDef@var1161 , "{|;" ) ;
932: } else {
933: return tokenDef@var1157 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1185 , bool * foundAllBaseClasses@var1186 ) const ;
946:
947: unsigned int mFlags@var1187 ;
948:
949: void isInline ( bool state@var1188 ) {
950: setFlag (@expr1073746702 fIsInline , state@var1188 ) ;
951: }
952: void isConst ( bool state@var1189 ) {
953: setFlag (@expr1073746703 fIsConst , state@var1189 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1190 ) {
956: setFlag (@expr1073746704 fHasVirtualSpecifier , state@var1190 ) ;
957: }
958: void isPure ( bool state@var1191 ) {
959: setFlag (@expr1073746705 fIsPure , state@var1191 ) ;
960: }
961: void isStatic ( bool state@var1192 ) {
962: setFlag (@expr1073746706 fIsStatic , state@var1192 ) ;
963: }
964: void isStaticLocal ( bool state@var1193 ) {
965: setFlag (@expr1073746707 fIsStaticLocal , state@var1193 ) ;
966: }
967: void isExtern ( bool state@var1194 ) {
968: setFlag (@expr1073746708 fIsExtern , state@var1194 ) ;
969: }
970: void isFriend ( bool state@var1195 ) {
971: setFlag (@expr1073746709 fIsFriend , state@var1195 ) ;
972: }
973: void isExplicit ( bool state@var1196 ) {
974: setFlag (@expr1073746710 fIsExplicit , state@var1196 ) ;
975: }
976: void isDefault ( bool state@var1197 ) {
977: setFlag (@expr1073746711 fIsDefault , state@var1197 ) ;
978: }
979: void isDelete ( bool state@var1198 ) {
980: setFlag (@expr1073746712 fIsDelete , state@var1198 ) ;
981: }
982: void isNoExcept ( bool state@var1199 ) {
983: setFlag (@expr1073746713 fIsNoExcept , state@var1199 ) ;
984: }
985: void isThrow ( bool state@var1200 ) {
986: setFlag (@expr1073746714 fIsThrow , state@var1200 ) ;
987: }
988: void isOperator ( bool state@var1201 ) {
989: setFlag (@expr1073746715 fIsOperator , state@var1201 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1202 ) {
992: setFlag (@expr1073746716 fHasLvalRefQual , state@var1202 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1203 ) {
995: setFlag (@expr1073746717 fHasRvalRefQual , state@var1203 ) ;
996: }
997: void isVariadic ( bool state@var1204 ) {
998: setFlag (@expr1073746718 fIsVariadic , state@var1204 ) ;
999: }
1000: void isVolatile ( bool state@var1205 ) {
1001: setFlag (@expr1073746719 fIsVolatile , state@var1205 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1206 ) {
1004: return setFlag (@expr1073746720 fHasTrailingReturnType , state@var1206 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1207 ) {
1007: setFlag (@expr1073746721 fIsInlineKeyword , state@var1207 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1208 , const Scope * scope@var1209 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1210 ;
1019: const Scope * scope@var1211 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1212 , const Token * classDef_@var1213 , const Scope * nestedIn_@var1214 ) ;
1025: Scope ( const SymbolDatabase * check_@var1215 , const Token * classDef_@var1216 , const Scope * nestedIn_@var1217 , ScopeType type_@var1218 , const Token * start_@var1219 ) ;
1026:
1027: const SymbolDatabase * check@var1220 ;
1028: std :: string className@var1221 ;
1029: const Token * classDef@var1222 ;
1030: const Token * bodyStart@var1223 ;
1031: const Token * bodyEnd@var1224 ;
1032: std :: list < Function > functionList@var1225 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1226 ;
1034: std :: list < Variable > varlist@var1227 ;
1035: const Scope * nestedIn@var1228 ;
1036: std :: list < Scope * > nestedList@var1229 ;
1037: int numConstructors@var1230 ;
1038: int numCopyOrMoveConstructors@var1231 ;
1039: std :: list < UsingInfo > usingList@var1232 ;
1040: ScopeType type@var1233 ;
1041: Type * definedType@var1234 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1235 ;
1043: std :: vector < const Token * > bodyStartList@var1236 ;
1044:
1045:
1046: const Scope * functionOf@var1237 ;
1047: Function * function@var1238 ;
1048:
1049:
1050: const Token * enumType@var1239 ;
1051: bool enumClass@var1240 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1241 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1242 ) {
1056: bodyStart@var1223 =@expr1073746722 start@var1242 ;
1057: bodyEnd@var1224 =@expr1073746723 start@var1242 ?@expr1073746724 start@var1242 .@expr1073746725 link (@expr1073746726 ) :@expr1073746727 nullptr ;
1058: if (@expr1073746728 start@var1242 ) {
1059: bodyStartList@var1236 .@expr1073746729 push_back (@expr1073746730 start@var1242 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1221 .@expr1073746731 size (@expr1073746732 ) >@expr1073746733 9 &&@expr1073746734 className@var1221 .@expr1073746735 compare (@expr1073746736 0 , 9 , "Anonymous" ) ==@expr1073746737 0 &&@expr1073746738 std ::@expr1073746739 isdigit (@expr1073746740 className@var1221 [@expr1073746741 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1243 ) const {
1068: for (@expr1073746742 const Enumerator &@expr1073746743 i@var1244 :@expr1073746744 enumeratorList@var1241 ) {
1069: if (@expr1073746745 i@var1244 .@expr1073746746 name@var1245 .@expr1073746747 str (@expr1073746748 ) ==@expr1073746749 name@var1243 ) {
1070: return &@expr1073746750 i@var1244 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1246 ) const {
1076: if (@expr1073746751 !@expr1073746752 outer@var1246 ) {
1077: return false ; }
1078: if (@expr1073746753 outer@var1246 ==@expr1073746754 this@expr1073746755 ) {
1079: return true ; }
1080: const Scope * parent@var1247 ; parent@var1247 =@expr1073746756 nestedIn@var1228 ;
1081: while (@expr1073746757 outer@var1246 !=@expr1073746758 parent@var1247 &&@expr1073746759 parent@var1247 ) {
1082: parent@var1247 =@expr1073746760 parent@var1247 .@expr1073746761 nestedIn@var1248 ; }
1083: if (@expr1073746762 parent@var1247 &&@expr1073746763 parent@var1247 ==@expr1073746764 outer@var1246 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1249 ) {
1089: while (@expr1073746765 scope@var1249 ) {
1090: if (@expr1073746766 scope@var1249 .@expr1073746767 type@var1250 ==@expr1073746768 Scope ::@expr1073746769 eFunction ) {
1091: break ; }
1092: scope@var1249 =@expr1073746770 scope@var1249 .@expr1073746771 nestedIn@var1251 ;
1093: }
1094: if (@expr1073746772 !@expr1073746773 scope@var1249 ) {
1095: return nullptr ; }
1096: return scope@var1249 .@expr1073746774 function@var1252 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746775 type@var1233 ==@expr1073746776 eClass ||@expr1073746777 type@var1233 ==@expr1073746778 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746779 type@var1233 ==@expr1073746780 eClass ||@expr1073746781 type@var1233 ==@expr1073746782 eStruct ||@expr1073746783 type@var1233 ==@expr1073746784 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1233 !=@expr1073746785 eClass &&@expr1073746786 type@var1233 !=@expr1073746787 eStruct &&@expr1073746788 type@var1233 !=@expr1073746789 eUnion &&@expr1073746790 type@var1233 !=@expr1073746791 eGlobal &&@expr1073746792 type@var1233 !=@expr1073746793 eNamespace &&@expr1073746794 type@var1233 !=@expr1073746795 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1233 ==@expr1073746796 Scope ::@expr4973 ScopeType ::@expr1073746798 eFor ||@expr1073746799 type@var1233 ==@expr1073746800 Scope ::@expr4973 ScopeType ::@expr1073746802 eWhile ||@expr1073746803 type@var1233 ==@expr1073746804 Scope ::@expr4973 ScopeType ::@expr1073746806 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746807 type@var1233 ==@expr1073746808 eIf ||@expr1073746809 type@var1233 ==@expr1073746810 eElse ||@expr1073746811
1117: type@var1233 ==@expr1073746812 eFor ||@expr1073746813 type@var1233 ==@expr1073746814 eWhile ||@expr1073746815 type@var1233 ==@expr1073746816 eDo ||@expr1073746817
1118: type@var1233 ==@expr1073746818 eSwitch ||@expr1073746819 type@var1233 ==@expr1073746820 eUnconditional ||@expr1073746821
1119: type@var1233 ==@expr1073746822 eTry ||@expr1073746823 type@var1233 ==@expr1073746824 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1253 , bool requireConst@var1254 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1255 , bool isC@var1256 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1257 ) {
1135: return const_cast < Scope *@expr5001 > (@expr1073746826 const_cast < const Scope *@expr5001 > (@expr1073746828 this@expr1073746829 ) .@expr1073746830 findRecordInNestedList (@expr1073746831 name@var1257 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1258 ) const ;
1139: Type * findType ( const std :: string & name@var1259 ) {
1140: return const_cast < Type *@expr5008 > (@expr1073746833 const_cast < const Scope *@expr5008 > (@expr1073746835 this@expr1073746836 ) .@expr1073746837 findType (@expr1073746838 name@var1259 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1260 ) ;
1148:
1149: void addVariable ( const Token * token_@var1261 , const Token * start_@var1262 ,
1150: const Token * end_@var1263 , AccessControl access_@var1264 , const Type * type_@var1265 ,
1151: const Scope * scope_@var1266 , const Settings * settings@var1267 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1268 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1269 ) {
1159: functionList@var1225 .@expr1073746839 push_back (@expr1073746840 func@var1269 ) ;
1160:
1161: const Function * back@var1270 ; back@var1270 =@expr1073746841 &@expr1073746842 functionList@var1225 .@expr1073746843 back (@expr1073746844 ) ;
1162:
1163: functionMap@var1226 .@expr1073746845 insert (@expr1073746846 make_pair (@expr1073746847 back@var1270 .@expr1073746848 tokenDef@var1271 .@expr1073746849 str (@expr1073746850 ) , back@var1270 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1272 , AccessControl varaccess@var1273 , const Settings * settings@var1274 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1275 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1276 , bool isCpp@var1277 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1278 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1279 , const Token * & vartok@var1280 , const Token * & typetok@var1281 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1282 , int args@var1283 , std :: vector < const Function * > & matches@var1284 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1285 , const Token * start@var1286 , const Token * end@var1287 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1288 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1289 ;
1239: int bits@var1290 ;
1240: int pointer@var1291 ;
1241: int constness@var1292 ;
1242: Reference reference@var1293 ; reference@var1293 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1294 ;
1245: const :: Type * smartPointerType@var1295 ;
1246: const Token * smartPointerTypeToken@var1296 ;
1247: const Library :: SmartPointer * smartPointer@var1297 ;
1248: const Library :: Container * container@var1298 ;
1249:
1250: const Token * containerTypeToken@var1299 ;
1251:
1252: std :: string originalTypeName@var1300 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1288 ( UNKNOWN_SIGN ) ,
1257: type@var1289 ( UNKNOWN_TYPE ) ,
1258: bits@var1290 ( 0 ) ,
1259: pointer@var1291 ( 0U ) ,
1260: constness@var1292 ( 0U ) ,
1261: typeScope@var1294 ( nullptr ) ,
1262: smartPointerType@var1295 ( nullptr ) ,
1263: smartPointerTypeToken@var1296 ( nullptr ) ,
1264: smartPointer@var1297 ( nullptr ) ,
1265: container@var1298 ( nullptr ) ,
1266: containerTypeToken@var1299 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1301 , enum Type t@var1302 , int p@var1303 )
1269: : sign@var1288 ( s@var1301 ) ,
1270: type@var1289 ( t@var1302 ) ,
1271: bits@var1290 ( 0 ) ,
1272: pointer@var1291 ( p@var1303 ) ,
1273: constness@var1292 ( 0U ) ,
1274: typeScope@var1294 ( nullptr ) ,
1275: smartPointerType@var1295 ( nullptr ) ,
1276: smartPointerTypeToken@var1296 ( nullptr ) ,
1277: smartPointer@var1297 ( nullptr ) ,
1278: container@var1298 ( nullptr ) ,
1279: containerTypeToken@var1299 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1304 , enum Type t@var1305 , int p@var1306 , int c@var1307 )
1282: : sign@var1288 ( s@var1304 ) ,
1283: type@var1289 ( t@var1305 ) ,
1284: bits@var1290 ( 0 ) ,
1285: pointer@var1291 ( p@var1306 ) ,
1286: constness@var1292 ( c@var1307 ) ,
1287: typeScope@var1294 ( nullptr ) ,
1288: smartPointerType@var1295 ( nullptr ) ,
1289: smartPointerTypeToken@var1296 ( nullptr ) ,
1290: smartPointer@var1297 ( nullptr ) ,
1291: container@var1298 ( nullptr ) ,
1292: containerTypeToken@var1299 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1308 , enum Type t@var1309 , int p@var1310 , int c@var1311 , const std :: string & otn@var1312 )
1295: : sign@var1288 ( s@var1308 ) ,
1296: type@var1289 ( t@var1309 ) ,
1297: bits@var1290 ( 0 ) ,
1298: pointer@var1291 ( p@var1310 ) ,
1299: constness@var1292 ( c@var1311 ) ,
1300: typeScope@var1294 ( nullptr ) ,
1301: smartPointerType@var1295 ( nullptr ) ,
1302: smartPointerTypeToken@var1296 ( nullptr ) ,
1303: smartPointer@var1297 ( nullptr ) ,
1304: container@var1298 ( nullptr ) ,
1305: containerTypeToken@var1299 ( nullptr ) ,
1306: originalTypeName@var1300 ( otn@var1312 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1313 , const Settings * settings@var1314 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1315 , bool longType@var1316 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1317 , const ValueType * func@var1318 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1319 , const Variable * callVar@var1320 , const Variable * funcVar@var1321 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746851 type@var1289 >=@expr1073746852 ValueType ::@expr1073746853 Type ::@expr1073746854 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746855 type@var1289 >=@expr1073746856 ValueType ::@expr5033 Type ::@expr1073746858 BOOL &&@expr1073746859 type@var1289 <=@expr1073746860 ValueType ::@expr5033 Type ::@expr1073746862 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746863 type@var1289 >=@expr1073746864 ValueType ::@expr5041 Type ::@expr1073746866 FLOAT &&@expr1073746867 type@var1289 <=@expr1073746868 ValueType ::@expr5041 Type ::@expr1073746870 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1322 , const Settings * settings@var1323 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1294 &&@expr1073746871 typeScope@var1294 .@expr1073746872 type@var1324 ==@expr1073746873 Scope ::@expr1073746874 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1325 , bool p@var1326 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1327 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1328 , const Settings * settings@var1329 , ErrorLogger * errorLogger@var1330 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1331 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1332 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1333 ;
1359:
1360:
1361: std :: list < Type > typeList@var1334 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1335 , const Token * typeTok@var1336 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1337 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1338 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1339 , const Scope * startScope@var1340 , bool lookOutside@var1341 = false ) const ;
1382: Type * findType ( const Token * startTok@var1342 , Scope * startScope@var1343 , bool lookOutside@var1344 = false ) const {
1383: return const_cast < Type *@expr5051 > (@expr1073746876 this@expr1073746877 .@expr1073746878 findType (@expr1073746879 startTok@var1342 , const_cast < const Scope *@expr5051 > (@expr1073746881 startScope@var1343 ) , lookOutside@var1344 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1345 , const Scope * startScope@var1346 ) const ;
1387: Scope * findScope ( const Token * tok@var1347 , Scope * startScope@var1348 ) const {
1388: return const_cast < Scope *@expr5058 > (@expr1073746883 this@expr1073746884 .@expr1073746885 findScope (@expr1073746886 tok@var1347 , const_cast < const Scope *@expr5058 > (@expr1073746888 startScope@var1348 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1349 ) const {
1392: return varid@var1349 <@expr1073746889 mVariableList@var1406 .@expr1073746890 size (@expr1073746891 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1350 ) const {
1396: return mVariableList@var1406 .@expr1073746892 at (@expr1073746893 varId@var1350 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1406 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1351 , const std :: string & type@var1352 , const std :: string & msg@var1353 ) const ;
1407:
1408: void printOut ( const char * title@var1354 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1355 , const char * indent@var1356 ) const ;
1410: void printXml ( std :: ostream & out@var1357 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1358 , Token * tokens@var1359 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1360 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1361 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1362 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1363 , const Token * * tok@var1364 , const Token * argStart@var1365 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1366 , const Token * tok@var1367 , const Token * argStart@var1368 , const Token * funcStart@var1369 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1370 , const Token * & tok@var1371 , const Token * argStart@var1372 , const Token * funcStart@var1373 ) ;
1469: void addNewFunction ( Scope * * scope@var1374 , const Token * * tok@var1375 ) ;
1470: bool isFunction ( const Token * tok@var1376 , const Scope * outerScope@var1377 , const Token * * funcStart@var1378 , const Token * * argStart@var1379 , const Token * * declEnd@var1380 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1381 , const Scope * startScope@var1382 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1383 , const Scope * scope@var1384 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1385 , const Scope * ns@var1386 , const std :: string & path@var1387 , int path_length@var1388 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1389 , const Token * typeTok@var1390 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1391 , const Token * vartok@var1392 , Token * membertok@var1393 , const Variable * membervar@var1394 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1395 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1396 ) const ;
1485:
1486: void setValueType ( Token * tok@var1397 , const ValueType & valuetype@var1398 ) ;
1487: void setValueType ( Token * tok@var1399 , const Variable & var@var1400 ) ;
1488: void setValueType ( Token * tok@var1401 , const Enumerator & enumerator@var1402 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1403 ;
1491: const Settings * mSettings@var1404 ;
1492: ErrorLogger * mErrorLogger@var1405 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1406 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1407 ;
1499:
1500: bool mIsCpp@var1408 ;
1501: ValueType :: Sign mDefaultSignedness@var1409 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1410 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1411 , const TFunc & visitor@var1412 )
52: {
53: if (@expr1073746894 !@expr1073746895 ast@var1411 ) {
54: return ; }
55:
56: std ::@expr1073746896 stack < T *@expr5073 , std ::@expr1073746898 vector < T *@expr5073 > > tokens@var1413 ;
57: T * tok@var1414 ; tok@var1414 =@expr1073746900 ast@var1411 ;
58: do {
59: ChildrenToVisit c@var1415 ; c@var1415 =@expr1073746901 visitor@var1412 (@expr1073746902 tok@var1414 ) ;
60:
61: if (@expr1073746903 c@var1415 ==@expr1073746904 ChildrenToVisit ::@expr1073746905 done ) {
62: break ; }
63: if (@expr1073746906 c@var1415 ==@expr1073746907 ChildrenToVisit ::@expr1073746908 op2 ||@expr1073746909 c@var1415 ==@expr5086 ChildrenToVisit ::@expr5087 op1_and_op2 ) {
64: T * t2@var1416 ; t2@var1416 =@expr1073746912 tok@var1414 .@expr1073746913 astOperand2 (@expr1073746914 ) ;
65: if (@expr1073746915 t2@var1416 ) {
66: tokens@var1413 .@expr5092 push (@expr1073746917 t2@var1416 ) ; }
67: }
68: if (@expr1073746918 c@var1415 ==@expr1073746919 ChildrenToVisit ::@expr1073746920 op1 ||@expr1073746921 c@var1415 ==@expr5086 ChildrenToVisit ::@expr5087 op1_and_op2 ) {
69: T * t1@var1417 ; t1@var1417 =@expr1073746924 tok@var1414 .@expr1073746925 astOperand1 (@expr1073746926 ) ;
70: if (@expr1073746927 t1@var1417 ) {
71: tokens@var1413 .@expr5092 push (@expr1073746929 t1@var1417 ) ; }
72: }
73:
74: if (@expr1073746930 tokens@var1413 .@expr1073746931 empty (@expr1073746932 ) ) {
75: break ; }
76:
77: tok@var1414 =@expr1073746933 tokens@var1413 .@expr1073746934 top (@expr1073746935 ) ;
78: tokens@var1413 .@expr1073746936 pop (@expr1073746937 ) ;
79: } while (@expr1073746938 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1418 , const std :: function < bool ( const Token * ) > & pred@var1419 ) ;
83: const Token * findExpression ( const int exprid@var1420 ,
84: const Token * start@var1421 ,
85: const Token * end@var1422 ,
86: const std :: function < bool ( const Token * ) > & pred@var1423 ) ;
87: const Token * findExpression ( const Token * start@var1424 , const int exprid@var1425 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1426 , const char * op@var1427 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1428 , const char * op@var1429 ) ;
91:
92: int astCount ( const Token * tok@var1430 , const char * op@var1431 , int depth@var1432 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1433 , const Token * tok@var1434 ) ;
95:
96: bool astHasVar ( const Token * tok@var1435 , int varid@var1436 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1437 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1438 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1439 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1440 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1441 , bool unknown@var1442 ) ;
107: bool astIsUnsigned ( const Token * tok@var1443 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1444 , bool unknown@var1445 ) ;
110:
111: bool astIsBool ( const Token * tok@var1446 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1447 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1448 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1449 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1450 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1451 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1452 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1453 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1454 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1455 , const std :: string & comp@var1456 , const std :: string & rhs@var1457 , const Token * * vartok@var1458 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1459 ) ;
140:
141: bool isTemporary ( bool cpp@var1460 , const Token * tok@var1461 , const Library * library@var1462 , bool unknown@var1463 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1464 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1465 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1466 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1467 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1468 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1469 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1470 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1471 ) ;
155: const Token * getParentLifetime ( bool cpp@var1472 , const Token * tok@var1473 , const Library * library@var1474 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1475 ) ;
158: bool astIsRHS ( const Token * tok@var1476 ) ;
159:
160: Token * getCondTok ( Token * tok@var1477 ) ;
161: const Token * getCondTok ( const Token * tok@var1478 ) ;
162:
163: Token * getInitTok ( Token * tok@var1479 ) ;
164: const Token * getInitTok ( const Token * tok@var1480 ) ;
165:
166: Token * getStepTok ( Token * tok@var1481 ) ;
167: const Token * getStepTok ( const Token * tok@var1482 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1483 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1484 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1485 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1486 ,
180: int * const varid@var1487 ,
181: bool * const knownInitValue@var1488 ,
182: long long * const initValue@var1489 ,
183: bool * const partialCond@var1490 ,
184: long long * const stepValue@var1491 ,
185: long long * const lastValue@var1492 ) ;
186:
187: bool precedes ( const Token * tok1@var1493 , const Token * tok2@var1494 ) ;
188: bool succeeds ( const Token * tok1@var1495 , const Token * tok2@var1496 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1497 , bool onVar@var1498 = true , int depth@var1499 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1500 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1501 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1502 ,
198: bool temporary@var1503 = true ,
199: bool inconclusive@var1504 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1505 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1506 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1507 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1508 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1509 , bool macro@var1510 , const Token * tok1@var1511 , const Token * tok2@var1512 , const Library & library@var1513 , bool pure@var1514 , bool followVar@var1515 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1516 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1517 , const Token * const tok2@var1518 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1519 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1520 , bool cpp@var1521 , const Token * const cond1@var1522 , const Token * const cond2@var1523 , const Library & library@var1524 , bool pure@var1525 , bool followVar@var1526 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1527 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1528 , const Token * const tok1@var1529 , const Token * const tok2@var1530 , const Library & library@var1531 , bool pure@var1532 , bool followVar@var1533 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1534 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1535 , const Library & library@var1536 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1537 , const Library & library@var1538 , bool pure@var1539 , bool cpp@var1540 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1541 , const Token * tok@var1542 , bool checkArrayAccess@var1543 = false , bool checkReference@var1544 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1545 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1546 , const Library * library@var1547 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1548 ,
238: const Library * library@var1549 = nullptr ,
239: const Token * * unknownFunc@var1550 = nullptr ,
240: bool functionScope@var1551 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1552 ,
244: const Variable * var@var1553 ,
245: Scope :: ScopeType type@var1554 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1555 , int & argn@var1556 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1557 , int & argn@var1558 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1559 , int argnr@var1560 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1561 , int indirect@var1562 , int varid@var1563 , const Settings * settings@var1564 , bool * inconclusive@var1565 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1566 , int indirect@var1567 , const Settings * settings@var1568 , bool * inconclusive@var1569 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1570 , const Token * end@var1571 , const int exprid@var1572 , bool globalvar@var1573 , const Settings * settings@var1574 , bool cpp@var1575 , int depth@var1576 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1577 , const Token * end@var1578 , int indirect@var1579 , const int exprid@var1580 , bool globalvar@var1581 , const Settings * settings@var1582 , bool cpp@var1583 , int depth@var1584 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1585 , int indirect@var1586 , const Settings * settings@var1587 , bool cpp@var1588 , int depth@var1589 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1590 , const Settings * settings@var1591 , bool cpp@var1592 , int depth@var1593 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1594 ,
283: const Token * end@var1595 ,
284: int indirect@var1596 ,
285: std :: vector < const Variable * > vars@var1597 ,
286: const Settings * settings@var1598 ,
287: bool cpp@var1599 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1600 , int indirect@var1601 , const Settings * settings@var1602 , bool cpp@var1603 ) ;
290: bool isThisChanged ( const Token * start@var1604 , const Token * end@var1605 , int indirect@var1606 , const Settings * settings@var1607 , bool cpp@var1608 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1609 , const Token * end@var1610 , int indirect@var1611 , const int exprid@var1612 , bool globalvar@var1613 , const Settings * settings@var1614 , bool cpp@var1615 , int depth@var1616 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1617 , const Token * end@var1618 , int indirect@var1619 , const int exprid@var1620 , bool globalvar@var1621 , const Settings * settings@var1622 , bool cpp@var1623 , int depth@var1624 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1625 ,
296: const Token * start@var1626 ,
297: const Token * end@var1627 ,
298: const Settings * settings@var1628 ,
299: bool cpp@var1629 ,
300: int depth@var1630 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1631 ,
303: const Token * tok@var1632 ,
304: int indirect@var1633 ,
305: bool globalvar@var1634 ,
306: const Settings * settings@var1635 ,
307: bool cpp@var1636 ,
308: int depth@var1637 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1638 , int varid@var1639 , bool * inconclusive@var1640 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1641 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1642 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1643 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1644 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1645 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1646 , const Function * f@var1647 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1648 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1649 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1650 ) ;
346: Token * findLambdaEndToken ( Token * first@var1651 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1652 , const Token * stream@var1653 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1654 , const Token * op@var1655 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1656 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1657 , const char * skipMatch@var1658 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1659 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1660 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1661 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1662 , const Library & library@var1663 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1664 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1665 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1666 , bool cpp@var1667 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1668 , const Library & library@var1669 ) : mCpp@var1702 ( cpp@var1668 ) , mLibrary@var1703 ( library@var1669 ) , mWhat@var1704 ( What :: Reassign ) , mValueFlowKnown@var1706 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1670 , const Token * lhs@var1671 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1672 , const Token * startToken@var1673 , const Token * endToken@var1674 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1675 , const Token * startToken@var1676 , const Token * endToken@var1677 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1678 ;
407: const Token * token@var1679 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1680 , const Token * startToken@var1681 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1682 , bool * localOut@var1683 = nullptr , bool * unknownVarIdOut@var1684 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1685 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1686 ;
420: explicit Result ( Type type@var1687 ) : type@var1686 ( type@var1687 ) , token@var1690 ( nullptr ) { }
421: Result ( Type type@var1688 , const Token * token@var1689 ) : type@var1686 ( type@var1688 ) , token@var1690 ( token@var1689 ) { }
422: const Token * token@var1690 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1691 , const Token * startToken@var1692 , const Token * endToken@var1693 ) ;
426: struct Result checkRecursive ( const Token * expr@var1694 , const Token * startToken@var1695 , const Token * endToken@var1696 , const std :: set < int > & exprVarIds@var1697 , bool local@var1698 , bool inInnerClass@var1699 , int depth@var1700 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1701 ) const ;
430:
431: const bool mCpp@var1702 ;
432: const Library & mLibrary@var1703 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1704 ;
434: std :: vector < KnownAndToken > mValueFlow@var1705 ;
435: bool mValueFlowKnown@var1706 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1707 ) ;

##file cppcheck-2.8/lib/infer.h

1:
|
29:
30: struct Interval ;
31:
32:
33: struct InferModel {
34: virtual bool match ( const ValueFlow :: Value & value@var1708 ) const = 0 ;
35: virtual ValueFlow :: Value yield ( long long value@var1709 ) const = 0 ;
36: virtual ~ InferModel ( ) { }
37: } ;
38:
39: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var1710 ,
40: const std :: string & op@var1711 ,
41: std :: list < ValueFlow :: Value > lhsValues@var1712 ,
42: std :: list < ValueFlow :: Value > rhsValues@var1713 ) ;
43:
44: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var1714 ,
45: const std :: string & op@var1715 ,
46: long long lhs@var1716 ,
47: std :: list < ValueFlow :: Value > rhsValues@var1717 ) ;
48:
49: std :: vector < ValueFlow :: Value > infer ( const ValuePtr<InferModel> & model@var1718 ,
50: const std :: string & op@var1719 ,
51: std :: list < ValueFlow :: Value > lhsValues@var1720 ,
52: long long rhs@var1721 ) ;
53:
54: std :: vector < long long > getMinValue ( const ValuePtr<InferModel> & model@var1722 , const std :: list < ValueFlow :: Value > & values@var1723 ) ;
55: std :: vector < long long > getMaxValue ( const ValuePtr<InferModel> & model@var1724 , const std :: list < ValueFlow :: Value > & values@var1725 ) ;
56:
57: std :: string toString ( const Interval & i@var1726 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1727 ) {
44: if (@expr1073746939 bit@var1727 >=@expr1073746940 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746941 (@expr1073746942 1LL <<@expr1073746943 (@expr1073746944 bit@var1727 -@expr1073746945 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1728 ) {
50: if (@expr1073746946 bit@var1728 >=@expr1073746947 64 ) {
51: return (@expr5124 ~@expr1073746949 0ULL ) >>@expr1073746950 1 ; }
52: return (@expr5124 1LL <<@expr1073746952 (@expr5124 bit@var1728 -@expr1073746954 1 ) ) -@expr1073746955 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1729 ) const {
59: return value@var1729 >=@expr1073746956 min_value (@expr1073746957 int_bit@var1739 ) &&@expr1073746958 value@var1729 <=@expr1073746959 max_value (@expr1073746960 int_bit@var1739 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1730 ) const {
63: unsigned long long intMax@var1731 ; intMax@var1731 =@expr1073746961 max_value (@expr1073746962 int_bit@var1739 ) ;
64: return value@var1730 <=@expr1073746963 intMax@var1731 ;
65: }
66:
67: bool isLongValue ( long long value@var1732 ) const {
68: return value@var1732 >=@expr1073746964 min_value (@expr1073746965 long_bit@var1740 ) &&@expr1073746966 value@var1732 <=@expr1073746967 max_value (@expr1073746968 long_bit@var1740 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1733 ) const {
72: unsigned long long longMax@var1734 ; longMax@var1734 =@expr1073746969 max_value (@expr1073746970 long_bit@var1740 ) ;
73: return value@var1733 <=@expr1073746971 longMax@var1734 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1735 ) const {
77: unsigned long long longLongMax@var1736 ; longLongMax@var1736 =@expr1073746972 max_value (@expr1073746973 long_long_bit@var1741 ) ;
78: return value@var1735 <=@expr1073746974 longLongMax@var1736 ;
79: }
80:
81: int char_bit@var1737 ;
82: int short_bit@var1738 ;
83: int int_bit@var1739 ;
84: int long_bit@var1740 ;
85: int long_long_bit@var1741 ;
86:
87:
88: int sizeof_bool@var1742 ;
89: int sizeof_short@var1743 ;
90: int sizeof_int@var1744 ;
91: int sizeof_long@var1745 ;
92: int sizeof_long_long@var1746 ;
93: int sizeof_float@var1747 ;
94: int sizeof_double@var1748 ;
95: int sizeof_long_double@var1749 ;
96: int sizeof_wchar_t@var1750 ;
97: int sizeof_size_t@var1751 ;
98: int sizeof_pointer@var1752 ;
99:
100: char defaultSign@var1753 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1754 ;
115:
116:
117: bool platform ( PlatformType type@var1755 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1756 [ ] , const std :: string & filename@var1757 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1758 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1754 ==@expr1073746975 Win32A ||@expr1073746976
136: platformType@var1754 ==@expr1073746977 Win32W ||@expr1073746978
137: platformType@var1754 ==@expr1073746979 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746980 platformType@var1754 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1759 ) {
145: switch (@expr1073746981 pt@var1759 ) {
146: case Unspecified :@expr5158 ;
147: return "Unspecified" ;
148: case Native :@expr5158 ;
149: return "Native" ;
150: case Win32A :@expr5158 ;
151: return "win32A" ;
152: case Win32W :@expr5158 ;
153: return "win32W" ;
154: case Win64 :@expr5158 ;
155: return "win64" ;
156: case Unix32 :@expr5158 ;
157: return "unix32" ;
158: case Unix64 :@expr5158 ;
159: return "unix64" ;
160: case PlatformFile :@expr5158 ;
161: return "platformFile" ;
162: default :@expr5158 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746991 char_bit@var1737 +@expr1073746992 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746993 char_bit@var1737 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746994 char_bit@var1737 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1760 , const std :: string & rhs@var1761 ) const {
41: return caseInsensitiveStringCompare (@expr1073746995 lhs@var1760 , rhs@var1761 ) <@expr1073746996 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1769 ( cppcheck :: Platform :: Unspecified ) , msc@var1770 ( false ) , useMfc@var1771 ( false ) { }
67: std :: string cfg@var1762 ;
68: std :: string filename@var1763 ;
69: std :: string defines@var1764 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1764 +@expr1073746997 (@expr1073746998 msc@var1770 ?@expr1073746999 ";_MSC_VER=1900" :@expr1073747000 "" ) +@expr1073747001 (@expr1073747002 useMfc@var1771 ?@expr1073747003 ";__AFXWIN_H__=1" :@expr1073747004 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1765 ;
74: std :: list < std :: string > includePaths@var1766 ;
75: std :: list < std :: string > systemIncludePaths@var1767 ;
76: std :: string standard@var1768 ;
77: cppcheck :: Platform :: PlatformType platformType@var1769 ;
78: bool msc@var1770 ;
79: bool useMfc@var1771 ;
80:
81: void parseCommand ( std :: string command@var1772 ) ;
82: void setDefines ( std :: string defs@var1773 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1774 , const std :: list < std :: string > & in@var1775 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1776 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1777 ;
86: Type projectType@var1778 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1779 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var1780 ;
97: std :: vector < std :: string > pathNames@var1781 ;
98: std :: list < std :: string > libraries@var1782 ;
99: std :: list < std :: string > excludedPaths@var1783 ;
100: std :: list < std :: string > checkVsConfigs@var1784 ;
101: std :: string projectFile@var1785 ;
102: std :: string platform@var1786 ;
103: } ; struct Anonymous4 guiProject@var1787 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1788 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1789 ) ;
107:
108: Type import ( const std :: string & filename@var1790 , Settings * settings@var1791 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1792 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1793 , Settings * settings@var1794 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1795 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1796 , const std :: string & path@var1797 , const std :: vector < std :: string > & fileFilters@var1798 ) ;
115: bool importVcxproj ( const std :: string & filename@var1799 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1800 , const std :: string & additionalIncludeDirectories@var1801 , const std :: vector < std :: string > & fileFilters@var1802 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1803 ) ;
117:
118: static void printError ( const std :: string & message@var1804 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1805 ) ;
121:
122: std :: string mPath@var1806 ;
123: std :: set < std :: string > mAllVSConfigs@var1807 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1808 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1809 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1810 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1811 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1812 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1813 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1814 [ 7 ] = "parser" ;
135: const char BugHunting@var1815 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1816 [ 11 ] = "includedir" ;
137: const char DirElementName@var1817 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1818 [ 5 ] = "name" ;
139: const char DefinesElementName@var1819 [ 8 ] = "defines" ;
140: const char DefineName@var1820 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1821 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1822 [ 10 ] = "undefines" ;
143: const char UndefineName@var1823 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1824 [ 6 ] = "paths" ;
145: const char PathName@var1825 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1826 [ 5 ] = "name" ;
147: const char RootPathName@var1827 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1828 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1829 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1830 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1831 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1832 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1833 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1834 [ 5 ] = "name" ;
155: const char FunctionContracts@var1835 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1836 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1837 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1838 [ 8 ] = "library" ;
159: const char PlatformElementName@var1839 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1840 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1841 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1842 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1843 [ 7 ] = "addons" ;
164: const char ToolElementName@var1844 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1845 [ 6 ] = "tools" ;
166: const char TagsElementName@var1846 [ 5 ] = "tags" ;
167: const char TagElementName@var1847 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1848 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1849 [ 4 ] = "tag" ;
170: const char WarningElementName@var1850 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1851 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1852 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1853 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1854 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1855 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1856 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1857 [ 11 ] = "clang-tidy" ;
178: const char Name@var1858 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1859 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1860 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1861 ;
43: std :: string errorId@var1862 ;
44: void setFileName ( const std :: string & s@var1863 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1867 ;
47: }
48: int lineNumber@var1864 ;
49: Certainty :: CertaintyLevel certainty@var1865 ;
50: std :: string symbolNames@var1866 ;
51: private:
52: std :: string mFileName@var1867 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1901 ( NO_LINE ) , hash@var1903 ( 0 ) , thisAndNextLine@var1904 ( false ) , matched@var1905 ( false ) , checked@var1906 ( false ) { }
57: Suppression ( const Suppression & other@var1868 ) {
58: *@expr1073747005 this@expr1073747006 =@expr1073747007 other@var1868 ;
59: }
60: Suppression ( const std :: string & id@var1869 , const std :: string & file@var1870 , int line@var1871 = NO_LINE ) : errorId@var1899 ( id@var1869 ) , fileName@var1900 ( file@var1870 ) , lineNumber@var1901 ( line@var1871 ) , hash@var1903 ( 0 ) , thisAndNextLine@var1904 ( false ) , matched@var1905 ( false ) , checked@var1906 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1872 ) {
63: errorId@var1899 =@expr1073747008 other@var1872 .@expr1073747009 errorId@var1873 ;
64: fileName@var1900 =@expr1073747010 other@var1872 .@expr1073747011 fileName@var1874 ;
65: lineNumber@var1901 =@expr1073747012 other@var1872 .@expr1073747013 lineNumber@var1875 ;
66: symbolName@var1902 =@expr1073747014 other@var1872 .@expr1073747015 symbolName@var1876 ;
67: hash@var1903 =@expr1073747016 other@var1872 .@expr1073747017 hash@var1877 ;
68: thisAndNextLine@var1904 =@expr1073747018 other@var1872 .@expr1073747019 thisAndNextLine@var1878 ;
69: matched@var1905 =@expr1073747020 other@var1872 .@expr1073747021 matched@var1879 ;
70: checked@var1906 =@expr1073747022 other@var1872 .@expr1073747023 checked@var1880 ;
71: return *@expr1073747024 this@expr1073747025 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1881 ) const {
75: if (@expr1073747026 errorId@var1899 !=@expr1073747027 other@var1881 .@expr5204 errorId@var1882 ) {
76: return errorId@var1899 <@expr1073747029 other@var1881 .@expr5204 errorId@var1882 ; }
77: if (@expr1073747031 lineNumber@var1901 <@expr1073747032 other@var1881 .@expr1073747033 lineNumber@var1883 ) {
78: return true ; }
79: if (@expr1073747034 fileName@var1900 !=@expr1073747035 other@var1881 .@expr5212 fileName@var1884 ) {
80: return fileName@var1900 <@expr1073747037 other@var1881 .@expr5212 fileName@var1884 ; }
81: if (@expr1073747039 symbolName@var1902 !=@expr1073747040 other@var1881 .@expr5217 symbolName@var1885 ) {
82: return symbolName@var1902 <@expr1073747042 other@var1881 .@expr5217 symbolName@var1885 ; }
83: if (@expr1073747044 hash@var1903 !=@expr1073747045 other@var1881 .@expr5222 hash@var1886 ) {
84: return hash@var1903 <@expr1073747047 other@var1881 .@expr5222 hash@var1886 ; }
85: if (@expr1073747049 thisAndNextLine@var1904 !=@expr1073747050 other@var1881 .@expr1073747051 thisAndNextLine@var1887 ) {
86: return thisAndNextLine@var1904 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1888 , std :: string * errorMessage@var1889 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1890 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1891 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073747053 fileName@var1900 .@expr1073747054 empty (@expr1073747055 ) &&@expr1073747056 fileName@var1900 .@expr1073747057 find_first_of (@expr1073747058 "?*" ) ==@expr1073747059 std ::@expr1073747060 string ::@expr1073747061 npos@expr1073747052 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1892 ) const {
109: return errorId@var1899 ==@expr1073747062 other@var1892 .@expr1073747063 errorId@var1893 &&@expr1073747064
110: fileName@var1900 ==@expr1073747065 other@var1892 .@expr1073747066 fileName@var1894 &&@expr1073747067
111: lineNumber@var1901 ==@expr1073747068 other@var1892 .@expr1073747069 lineNumber@var1895 &&@expr1073747070
112: symbolName@var1902 ==@expr1073747071 other@var1892 .@expr1073747072 symbolName@var1896 &&@expr1073747073
113: hash@var1903 ==@expr1073747074 other@var1892 .@expr1073747075 hash@var1897 &&@expr1073747076
114: thisAndNextLine@var1904 ==@expr1073747077 other@var1892 .@expr1073747078 thisAndNextLine@var1898 ;
115: }
116:
117: std :: string errorId@var1899 ;
118: std :: string fileName@var1900 ;
119: int lineNumber@var1901 ;
120: std :: string symbolName@var1902 ;
121: unsigned long hash@var1903 ;
122: bool thisAndNextLine@var1904 ;
123: bool matched@var1905 ;
124: bool checked@var1906 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1907 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1908 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1909 , std :: string * errorMessage@var1910 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1911 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1912 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1913 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1914 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1915 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1916 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1917 , const bool unusedFunctionChecking@var1918 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1919 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1920 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1921 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var1922 , std :: clock_t clocks@var1923 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var1924 ;
45: long mNumberOfResults@var1925 ;
46:
47: TimerResultsData ( )
48: : mClocks@var1924 ( 0 )
49: , mNumberOfResults@var1925 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var1926 =@expr1073747080 (@expr1073747081 double ) (@expr1073747082 (@expr1073747083 unsigned long ) mClocks@var1924 ) /@expr1073747084 (@expr1073747085 double ) CLOCKS_PER_SEC@expr1073747079 ;
53: return ret@var1926 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var1927 ) const ;
62: void addResults ( const std :: string & str@var1928 , std :: clock_t clocks@var1929 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var1930 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var1931 , SHOWTIME_MODES showtimeMode@var1932 , TimerResultsIntf * timerResults@var1933 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var1934 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var1935 ;
79: TimerResultsIntf * mTimerResults@var1936 ;
80: std :: clock_t mStart@var1937 ;
81: const SHOWTIME_MODES mShowTimeMode@var1938 ;
82: bool mStopped@var1939 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var1940 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var1941 ;
103:
104:
105: std :: string addonPython@var1942 ;
106:
107:
108: std :: vector < std :: string > basePaths@var1943 ;
109:
110:
111: std :: string buildDir@var1944 ;
112:
113:
114: bool checkAllConfigurations@var1945 ;
115:
116:
117: bool checkConfiguration@var1946 ;
118:
|
121:
122: bool checkHeaders@var1947 ;
123:
124:
125: bool checkLibrary@var1948 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var1949 ;
129:
130:
131: bool checkUnusedTemplates@var1950 ;
132:
133:
134: bool clang@var1951 ;
135:
136:
137: std :: string clangExecutable@var1952 ;
138:
139:
140: bool clangTidy@var1953 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var1954 ;
144:
145:
146: std :: string cppcheckCfgProductName@var1955 ;
147:
148:
149: std :: string cppcheckCfgAbout@var1956 ;
150:
151:
152: bool daca@var1957 ;
153:
154:
155: bool debugnormal@var1958 ;
156:
157:
158: bool debugSimplified@var1959 ;
159:
160:
161: bool debugtemplate@var1960 ;
162:
163:
164: bool debugwarnings@var1961 ;
165:
166:
167: bool dump@var1962 ;
168: std :: string dumpFile@var1963 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var1964 ;
176:
177:
178: bool exceptionHandling@var1965 ;
179:
180:
181: std :: string exename@var1966 ;
182:
183:
184:
185: int exitCode@var1967 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var1968 ;
189:
190:
191: bool force@var1969 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var1970 ;
196:
197:
198: bool inlineSuppressions@var1971 ;
199:
200:
201:
202: unsigned int jobs@var1972 ;
203:
|
206:
207: bool jointSuppressionReport@var1973 ;
208:
209:
210: std :: list < std :: string > libraries@var1974 ;
211:
212:
213: Library library@var1975 ;
214:
215:
216:
217: int loadAverage@var1976 ;
218:
|
221:
222: int maxConfigs@var1977 ;
223:
224:
225: int maxCtuDepth@var1978 ;
226:
227:
228: int maxTemplateRecursion@var1979 ;
229:
230:
231: Suppressions nofail@var1980 ;
232:
233:
234: Suppressions nomsg@var1981 ;
235:
236:
237: std :: string outputFile@var1982 ;
238:
239:
240: std :: string plistOutput@var1983 ;
241:
242:
243: bool preprocessOnly@var1984 ;
244:
245: ImportProject project@var1985 ;
246:
247:
248: bool quiet@var1986 ;
249:
250:
251: bool relativePaths@var1987 ;
252:
253:
254: bool reportProgress@var1988 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var1989 ( "simple" )
261: , id@var1991 ( "rule" )
262: , severity@var1993 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var1989 ;
266: std :: string pattern@var1990 ;
267: std :: string id@var1991 ;
268: std :: string summary@var1992 ;
269: Severity :: SeverityType severity@var1993 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var1994 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2000 ( false ) , externalFunctions@var2001 ( false ) , internalFunctions@var2002 ( false ) , externalVariables@var2003 ( false ) { }
281:
282: static const char XmlRootName@var1995 [ ] ;
283: static const char XmlClasses@var1996 [ ] ;
284: static const char XmlExternalFunctions@var1997 [ ] ;
285: static const char XmlInternalFunctions@var1998 [ ] ;
286: static const char XmlExternalVariables@var1999 [ ] ;
287:
288: void clear ( ) {
289: classes@var2000 =@expr1073747086 externalFunctions@var2001 =@expr1073747087 internalFunctions@var2002 =@expr1073747088 externalVariables@var2003 =@expr1073747089 false ;
290: }
291:
|
297:
298: bool classes@var2000 ;
299:
|
304:
305: bool externalFunctions@var2001 ;
306:
|
310:
311: bool internalFunctions@var2002 ;
312:
|
316:
317: bool externalVariables@var2003 ;
318: } ;
319:
320: SafeChecks safeChecks@var2004 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2005 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2006 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2007 ;
325:
326:
327: SHOWTIME_MODES showtime@var2008 ;
328:
329:
330: Standards standards@var2009 ;
331:
332:
333:
334: std :: string templateFormat@var2010 ;
335:
336:
337:
338: std :: string templateLocation@var2011 ;
339:
340:
341: std :: string userDefines@var2012 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2013 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2014 ;
348:
349:
350: bool verbose@var2015 ;
351:
352:
353: bool xml@var2016 ;
354:
355:
356: int xml_version@var2017 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2018 ) const {
363: for (@expr1073747090 const std ::@expr1073747091 string &@expr1073747092 configExcludePath@var2019 :@expr1073747093 configExcludePaths@var1954 ) {
364: if (@expr1073747094 file@var2018 .@expr1073747095 length (@expr1073747096 ) >=@expr1073747097 configExcludePath@var2019 .@expr5274 length (@expr5275 ) &&@expr1073747100 file@var2018 .@expr1073747101 compare (@expr1073747102 0 , configExcludePath@var2019 .@expr5274 length (@expr5275 ) , configExcludePath@var2019 ) ==@expr1073747105 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2020 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2021 , bool inconclusiveCheck@var2022 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073747106 find (@expr1073747107 libraries@var1974 .@expr1073747108 begin (@expr1073747109 ) , libraries@var1974 .@expr5286 end (@expr5287 ) , "posix" ) !=@expr1073747112 libraries@var1974 .@expr5286 end (@expr5287 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2023 = true ) {
392: Settings ::@expr1073747115 mTerminated@var1940 =@expr1073747116 t@var2023 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073747117 mTerminated@var1940 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2024 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueptr.h

1:
|
27:
28: class ValuePtr<InferModel> ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var2025 ) ;
62:
63:
64: Check ( const std :: string & aname@var2026 , const Tokenizer * tokenizer@var2027 , const Settings * settings@var2028 , ErrorLogger * errorLogger@var2029 )
65: : mTokenizer@var2040 ( tokenizer@var2027 ) , mSettings@var2041 ( settings@var2028 ) , mErrorLogger@var2042 ( errorLogger@var2029 ) , mName@var2075 ( aname@var2026 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073747118 !@expr1073747119 mTokenizer@var2040 ) {
69: instances (@expr1073747120 ) .@expr1073747121 remove (@expr1073747122 this@expr1073747123 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var2030 , const Settings * settings@var2031 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var2075 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var2032 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073747124 string (@expr1073747125 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2033 , const Settings * settings@var2034 ) const {
107: (@expr1073747126 void ) tokenizer@var2033 ;
108: (@expr1073747127 void ) settings@var2034 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2035 ) const {
113: (@expr1073747128 void ) xmlElement@var2035 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2036 , const std :: list < FileInfo * > & fileInfo@var2037 , const Settings & , ErrorLogger & ) {
119: (@expr1073747129 void ) ctu@var2036 ;
120: (@expr1073747130 void ) fileInfo@var2037 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var2038 , const char id@var2039 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var2040 ;
130: const Settings * const mSettings@var2041 ;
131: ErrorLogger * const mErrorLogger@var2042 ;
132:
133:
134: void reportError ( const Token * tok@var2043 , const Severity :: SeverityType severity@var2044 , const std :: string & id@var2045 , const std :: string & msg@var2046 ) {
135: reportError (@expr1073747131 tok@var2043 , severity@var2044 , id@var2045 , msg@var2046 , CWE (@expr1073747132 0U ) , Certainty ::@expr1073747133 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var2047 , const Severity :: SeverityType severity@var2048 , const std :: string & id@var2049 , const std :: string & msg@var2050 , const CWE & cwe@var2051 , Certainty :: CertaintyLevel certainty@var2052 ) {
140: const std ::@expr1073747134 list < const Token *@expr1073747135 > callstack@var2053 (@expr1073747136 1 , tok@var2047 ) ;
141: reportError (@expr1073747137 callstack@var2053 , severity@var2048 , id@var2049 , msg@var2050 , cwe@var2051 , certainty@var2052 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var2054 , Severity :: SeverityType severity@var2055 , const std :: string & id@var2056 , const std :: string & msg@var2057 ) {
146: reportError (@expr1073747138 callstack@var2054 , severity@var2055 , id@var2056 , msg@var2057 , CWE (@expr1073747139 0U ) , Certainty ::@expr1073747140 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var2058 , Severity :: SeverityType severity@var2059 , const std :: string & id@var2060 , const std :: string & msg@var2061 , const CWE & cwe@var2062 , Certainty :: CertaintyLevel certainty@var2063 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var2064 , Severity :: SeverityType severity@var2065 , const char id@var2066 [ ] , const std :: string & msg@var2067 , const CWE & cwe@var2068 , Certainty :: CertaintyLevel certainty@var2069 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var2070 , const ValueFlow :: Value * value@var2071 , const std :: string & bug@var2072 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var2073 , const char * str@var2074 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var2075 ;
167: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2076 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2077 ) {
47: mSettings@var2112 =@expr1073747141 settings@var2077 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2112 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2114 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2115 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2078 ) ;
72:
73: void addtoken ( const std :: string & str@var2079 , const int lineno@var2080 , const int column@var2081 , const int fileno@var2082 , bool split@var2083 = false ) ;
74: void addtoken ( const std :: string & str@var2084 , const Token * locationTok@var2085 ) ;
75:
76: void addtoken ( const Token * tok@var2086 , const int lineno@var2087 , const int column@var2088 , const int fileno@var2089 ) ;
77: void addtoken ( const Token * tok@var2090 , const Token * locationTok@var2091 ) ;
78: void addtoken ( const Token * tok@var2092 ) ;
79:
80: static void insertTokens ( Token * dest@var2093 , const Token * src@var2094 , int n@var2095 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2096 , const Token * first@var2097 , const Token * last@var2098 , bool one_line@var2099 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2100 , const std :: string & file0@var2101 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2102 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2103 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2109 .@expr1073747142 front@var2116 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2109 .@expr1073747143 front@var2116 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2109 .@expr1073747144 back@var2117 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2109 .@expr1073747145 back@var2117 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2110 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2104 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2105 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2106 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2107 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2108 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2109 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2110 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2111 ;
212:
213:
214: const Settings * mSettings@var2112 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2113 ;
217:
218:
219: bool mIsC@var2114 ;
220: bool mIsCpp@var2115 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2118 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2119 ;
67: mutable int mVarId@var2120 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2121 ) ;
73: bool hasVariable ( const std :: string & varname@var2122 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2123 ) const {
75: return mVariableId@var2118 .@expr1073747146 find (@expr1073747147 varname@var2123 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2118 .@expr1073747148 end (@expr1073747149 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2118 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073747150 mVarId@var2120 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2124 , ErrorLogger * errorLogger@var2125 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2126 ) {
95: mTimerResults@var2246 =@expr1073747151 tr@var2126 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2224 .@expr1073747152 isC (@expr1073747153 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2224 .@expr1073747154 isCPP (@expr1073747155 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2127 , bool * unknown@var2128 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2129 , const std :: string & FileName@var2130 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2131 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2132 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2133 ,
142: const char FileName@var2134 [ ] ,
143: const std :: string & configuration@var2135 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2136 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2137 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2138 , const Token * end@var2139 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2140 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2141 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2142 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2143 , const Token * const tokEnd@var2144 , const bool only_k_r_fpar@var2145 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2146 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2147 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2148 , bool commandWithCondition@var2149 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2150 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2151 , Token * * _tok2@var2152 , Token * * _tok3@var2153 , std :: string & value@var2154 , int & valueVarId@var2155 , bool & valueIsPointer@var2156 , bool floatvar@var2157 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2158 , Token * tok3@var2159 , int varid@var2160 , const std :: string & structname@var2161 , std :: string & value@var2162 , int valueVarId@var2163 , bool valueIsPointer@var2164 , const Token * const valueToken@var2165 , int indentlevel@var2166 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2167 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2168 , const std :: string & endsWith@var2169 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2170 , const std :: string & endsWith@var2171 , bool cpp@var2172 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2173 ) {
585: mPreprocessor@var2247 =@expr1073747156 preprocessor@var2173 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2247 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2174 , const Token * end@var2175 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2176 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2177 , const std :: string & code@var2178 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2179 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2180 , const std :: string & what@var2181 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2182 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2183 , const std :: string & msg@var2184 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2185 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2186 , const std :: string & macroName@var2187 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2188 , const Token * end@var2189 , bool allowSemicolon@var2190 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2191 , const Severity :: SeverityType severity@var2192 , const std :: string & id@var2193 , const std :: string & msg@var2194 , bool inconclusive@var2195 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2196 , Severity :: SeverityType severity@var2197 , const std :: string & id@var2198 , const std :: string & msg@var2199 , bool inconclusive@var2200 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2201 , const Token * name@var2202 , const Token * typeDef@var2203 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2204 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2205 ,
821: const VariableMap & variableMap@var2206 ,
822: const int scopeStartVarId@var2207 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2208 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2209 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2210 ,
827: int * varId@var2211 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2212 ,
830: Token * const startToken@var2213 ,
831: const Token * const endToken@var2214 ,
832: const std :: map < std :: string , int > & varlist@var2215 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2216 ,
834: int * varId_@var2217 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2218 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2219 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2245 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2220 ) {
861: mSettings@var2231 =@expr1073747157 settings@var2220 ;
862: list@var2224 .@expr1073747158 setSettings (@expr1073747159 settings@var2220 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2233 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2221 ) const ;
877:
878: void dump ( std :: ostream & out@var2222 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2223 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2243 ;
888: }
889:
|
892:
893: TokenList list@var2224 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2224 .@expr1073747160 front (@expr1073747161 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2225 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2226 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2227 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2228 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2231 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2229 , bool inOperator@var2230 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073747162 mVarId@var2243 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2231 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2232 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2233 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2234 ;
973:
974:
975:
976: std :: string mConfiguration@var2235 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2236 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2237 ;
983: std :: string filename@var2238 ;
984: int lineNumber@var2239 ;
985: int column@var2240 ;
986: bool used@var2241 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2242 ;
989:
990:
991: int mVarId@var2243 ;
992:
993:
994: int mUnnamedCount@var2244 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2245 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2246 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2247 ;
1013: } ;

##file cppcheck-2.8/lib/checkclass.h

1:
|
35:
36: class ErrorLogger ;
37: class Settings ;
38: class Token ;
39:
40: namespace CTU {
41: class FileInfo ;
42: }
43:
44: namespace tinyxml2 {
45: class XMLElement ;
46: }
47:
|
52:
53: class CheckClass : public Check {
54: public:
55:
56: CheckClass ( ) : Check ( myName ( ) ) , mSymbolDatabase@var2280 ( nullptr ) { }
57:
58:
59: CheckClass ( const Tokenizer * tokenizer@var2248 , const Settings * settings@var2249 , ErrorLogger * errorLogger@var2250 ) ;
60:
61:
62: void runChecks ( const Tokenizer * tokenizer@var2251 , const Settings * settings@var2252 , ErrorLogger * errorLogger@var2253 ) override {
63: if (@expr1073747163 tokenizer@var2251 .@expr1073747164 isC (@expr1073747165 ) ) {
64: return ; }
65:
66: CheckClass checkClass@var2254 (@expr1073747166 tokenizer@var2251 , settings@var2252 , errorLogger@var2253 ) ;
67:
68:
69: checkClass@var2254 .@expr1073747167 checkMemset (@expr1073747168 ) ;
70: checkClass@var2254 .@expr1073747169 constructors (@expr1073747170 ) ;
71: checkClass@var2254 .@expr1073747171 privateFunctions (@expr1073747172 ) ;
72: checkClass@var2254 .@expr1073747173 operatorEqRetRefThis (@expr1073747174 ) ;
73: checkClass@var2254 .@expr1073747175 thisSubtraction (@expr1073747176 ) ;
74: checkClass@var2254 .@expr1073747177 operatorEqToSelf (@expr1073747178 ) ;
75: checkClass@var2254 .@expr1073747179 initializerListOrder (@expr1073747180 ) ;
76: checkClass@var2254 .@expr1073747181 initializationListUsage (@expr1073747182 ) ;
77: checkClass@var2254 .@expr1073747183 checkSelfInitialization (@expr1073747184 ) ;
78: checkClass@var2254 .@expr1073747185 virtualDestructor (@expr1073747186 ) ;
79: checkClass@var2254 .@expr1073747187 checkConst (@expr1073747188 ) ;
80: checkClass@var2254 .@expr1073747189 copyconstructors (@expr1073747190 ) ;
81: checkClass@var2254 .@expr1073747191 checkVirtualFunctionCallInConstructor (@expr1073747192 ) ;
82: checkClass@var2254 .@expr1073747193 checkDuplInheritedMembers (@expr1073747194 ) ;
83: checkClass@var2254 .@expr1073747195 checkExplicitConstructors (@expr1073747196 ) ;
84: checkClass@var2254 .@expr1073747197 checkCopyCtorAndEqOperator (@expr1073747198 ) ;
85: checkClass@var2254 .@expr1073747199 checkOverride (@expr1073747200 ) ;
86: checkClass@var2254 .@expr1073747201 checkThisUseAfterFree (@expr1073747202 ) ;
87: checkClass@var2254 .@expr1073747203 checkUnsafeClassRefMember (@expr1073747204 ) ;
88: }
89:
90:
91: void constructors ( ) ;
92:
93:
94:
95: void checkExplicitConstructors ( ) ;
96:
97:
98: void privateFunctions ( ) ;
99:
|
107:
108: void checkMemset ( ) ;
109: void checkMemsetType ( const Scope * start@var2255 , const Token * tok@var2256 , const Scope * type@var2257 , bool allocation@var2258 , std :: set < const Scope * > parsedTypes@var2259 ) ;
110:
111:
112: void operatorEqRetRefThis ( ) ;
113:
114:
115: void operatorEqToSelf ( ) ;
116:
117:
118: void virtualDestructor ( ) ;
119:
120:
121: void thisSubtraction ( ) ;
122:
123:
124: void checkConst ( ) ;
125:
126:
127: void initializerListOrder ( ) ;
128:
129:
130: void initializationListUsage ( ) ;
131:
132:
133: void checkSelfInitialization ( ) ;
134:
135: void copyconstructors ( ) ;
136:
137:
138: void checkVirtualFunctionCallInConstructor ( ) ;
139:
140:
141: void checkDuplInheritedMembers ( ) ;
142:
143:
144: void checkCopyCtorAndEqOperator ( ) ;
145:
146:
147: void checkOverride ( ) ;
148:
149:
150: void checkThisUseAfterFree ( ) ;
151:
152:
153: void checkUnsafeClassRefMember ( ) ;
154:
155:
156:
157: class MyFileInfo : public Check :: FileInfo {
158: public:
159: struct NameLoc {
160: std :: string className@var2260 ;
161: std :: string fileName@var2261 ;
162: int lineNumber@var2262 ;
163: int column@var2263 ;
164: unsigned long hash@var2264 ;
165:
166: bool operator== ( const NameLoc & other@var2265 ) const {
167: return isSameLocation (@expr1073747205 other@var2265 ) &&@expr1073747206 hash@var2264 ==@expr1073747207 other@var2265 .@expr1073747208 hash@var2266 ;
168: }
169:
170: bool isSameLocation ( const NameLoc & other@var2267 ) const {
171: return fileName@var2261 ==@expr1073747209 other@var2267 .@expr1073747210 fileName@var2268 &&@expr1073747211
172: lineNumber@var2262 ==@expr1073747212 other@var2267 .@expr1073747213 lineNumber@var2269 &&@expr1073747214
173: column@var2263 ==@expr1073747215 other@var2267 .@expr1073747216 column@var2270 ;
174: }
175: } ;
176: std :: vector < NameLoc > classDefinitions@var2271 ;
177:
178:
179: std :: string toString ( ) const override ;
180: } ;
181:
182:
183: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2272 , const Settings * settings@var2273 ) const override ;
184:
185: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2274 ) const override ;
186:
187:
188: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2275 , const std :: list < Check :: FileInfo * > & fileInfo@var2276 , const Settings & settings@var2277 , ErrorLogger & errorLogger@var2278 ) override ;
189:
190:
191: static const std :: set < std :: string > stl_containers_not_const@var2279 ;
192:
193: private:
194: const SymbolDatabase * mSymbolDatabase@var2280 ;
195:
196:
197: void noConstructorError ( const Token * tok@var2281 , const std :: string & classname@var2282 , bool isStruct@var2283 ) ;
198: void noExplicitConstructorError ( const Token * tok@var2284 , const std :: string & classname@var2285 , bool isStruct@var2286 ) ;
199:
200: void copyConstructorShallowCopyError ( const Token * tok@var2287 , const std :: string & varname@var2288 ) ;
201: void noCopyConstructorError ( const Scope * scope@var2289 , bool isdefault@var2290 , const Token * alloc@var2291 , bool inconclusive@var2292 ) ;
202: void noOperatorEqError ( const Scope * scope@var2293 , bool isdefault@var2294 , const Token * alloc@var2295 , bool inconclusive@var2296 ) ;
203: void noDestructorError ( const Scope * scope@var2297 , bool isdefault@var2298 , const Token * alloc@var2299 ) ;
204: void uninitVarError ( const Token * tok@var2300 , bool isprivate@var2301 , Function :: Type functionType@var2302 , const std :: string & classname@var2303 , const std :: string & varname@var2304 , bool derived@var2305 , bool inconclusive@var2306 ) ;
205: void uninitVarError ( const Token * tok@var2307 , const std :: string & classname@var2308 , const std :: string & varname@var2309 ) ;
206: void missingMemberCopyError ( const Token * tok@var2310 , Function :: Type functionType@var2311 , const std :: string & classname@var2312 , const std :: string & varname@var2313 ) ;
207: void operatorEqVarError ( const Token * tok@var2314 , const std :: string & classname@var2315 , const std :: string & varname@var2316 , bool inconclusive@var2317 ) ;
208: void unusedPrivateFunctionError ( const Token * tok@var2318 , const std :: string & classname@var2319 , const std :: string & funcname@var2320 ) ;
209: void memsetError ( const Token * tok@var2321 , const std :: string & memfunc@var2322 , const std :: string & classname@var2323 , const std :: string & type@var2324 ) ;
210: void memsetErrorReference ( const Token * tok@var2325 , const std :: string & memfunc@var2326 , const std :: string & type@var2327 ) ;
211: void memsetErrorFloat ( const Token * tok@var2328 , const std :: string & type@var2329 ) ;
212: void mallocOnClassError ( const Token * tok@var2330 , const std :: string & memfunc@var2331 , const Token * classTok@var2332 , const std :: string & classname@var2333 ) ;
213: void mallocOnClassWarning ( const Token * tok@var2334 , const std :: string & memfunc@var2335 , const Token * classTok@var2336 ) ;
214: void virtualDestructorError ( const Token * tok@var2337 , const std :: string & Base@var2338 , const std :: string & Derived@var2339 , bool inconclusive@var2340 ) ;
215: void thisSubtractionError ( const Token * tok@var2341 ) ;
216: void operatorEqRetRefThisError ( const Token * tok@var2342 ) ;
217: void operatorEqShouldBeLeftUnimplementedError ( const Token * tok@var2343 ) ;
218: void operatorEqMissingReturnStatementError ( const Token * tok@var2344 , bool error@var2345 ) ;
219: void operatorEqToSelfError ( const Token * tok@var2346 ) ;
220: void checkConstError ( const Token * tok@var2347 , const std :: string & classname@var2348 , const std :: string & funcname@var2349 , bool suggestStatic@var2350 ) ;
221: void checkConstError2 ( const Token * tok1@var2351 , const Token * tok2@var2352 , const std :: string & classname@var2353 , const std :: string & funcname@var2354 , bool suggestStatic@var2355 ) ;
222: void initializerListError ( const Token * tok1@var2356 , const Token * tok2@var2357 , const std :: string & classname@var2358 , const std :: string & varname@var2359 ) ;
223: void suggestInitializationList ( const Token * tok@var2360 , const std :: string & varname@var2361 ) ;
224: void selfInitializationError ( const Token * tok@var2362 , const std :: string & varname@var2363 ) ;
225: void pureVirtualFunctionCallInConstructorError ( const Function * scopeFunction@var2364 , const std :: list < const Token * > & tokStack@var2365 , const std :: string & purefuncname@var2366 ) ;
226: void virtualFunctionCallInConstructorError ( const Function * scopeFunction@var2367 , const std :: list < const Token * > & tokStack@var2368 , const std :: string & funcname@var2369 ) ;
227: void duplInheritedMembersError ( const Token * tok1@var2370 , const Token * tok2@var2371 , const std :: string & derivedName@var2372 , const std :: string & baseName@var2373 , const std :: string & variableName@var2374 , bool derivedIsStruct@var2375 , bool baseIsStruct@var2376 ) ;
228: void copyCtorAndEqOperatorError ( const Token * tok@var2377 , const std :: string & classname@var2378 , bool isStruct@var2379 , bool hasCopyCtor@var2380 ) ;
229: void overrideError ( const Function * funcInBase@var2381 , const Function * funcInDerived@var2382 ) ;
230: void thisUseAfterFree ( const Token * self@var2383 , const Token * free@var2384 , const Token * use@var2385 ) ;
231: void unsafeClassRefMemberError ( const Token * tok@var2386 , const std :: string & varname@var2387 ) ;
232: void checkDuplInheritedMembersRecursive ( const Type * typeCurrent@var2388 , const Type * typeBase@var2389 ) ;
233:
234: void getErrorMessages ( ErrorLogger * errorLogger@var2390 , const Settings * settings@var2391 ) const override {
235: CheckClass c@var2392 (@expr1073747217 nullptr , settings@var2391 , errorLogger@var2390 ) ;
236: c@var2392 .@expr1073747218 noConstructorError (@expr1073747219 nullptr , "classname" , false ) ;
237: c@var2392 .@expr1073747220 noExplicitConstructorError (@expr1073747221 nullptr , "classname" , false ) ;
238:
239: c@var2392 .@expr1073747222 copyConstructorShallowCopyError (@expr1073747223 nullptr , "var" ) ;
240: c@var2392 .@expr1073747224 noCopyConstructorError (@expr1073747225 nullptr , false , nullptr , false ) ;
241: c@var2392 .@expr1073747226 noOperatorEqError (@expr1073747227 nullptr , false , nullptr , false ) ;
242: c@var2392 .@expr1073747228 noDestructorError (@expr1073747229 nullptr , false , nullptr ) ;
243: c@var2392 .@expr5406 uninitVarError (@expr1073747231 nullptr , false , Function ::@expr5408 eConstructor , "classname" , "varname" , false , false ) ;
244: c@var2392 .@expr5406 uninitVarError (@expr1073747234 nullptr , true , Function ::@expr5408 eConstructor , "classname" , "varnamepriv" , false , false ) ;
245: c@var2392 .@expr5406 uninitVarError (@expr1073747237 nullptr , false , Function ::@expr5408 eConstructor , "classname" , "varname" , true , false ) ;
246: c@var2392 .@expr5406 uninitVarError (@expr1073747240 nullptr , true , Function ::@expr5408 eConstructor , "classname" , "varnamepriv" , true , false ) ;
247: c@var2392 .@expr1073747242 missingMemberCopyError (@expr1073747243 nullptr , Function ::@expr5408 eConstructor , "classname" , "varnamepriv" ) ;
248: c@var2392 .@expr1073747245 operatorEqVarError (@expr1073747246 nullptr , "classname" , emptyString@var1 , false ) ;
249: c@var2392 .@expr1073747247 unusedPrivateFunctionError (@expr1073747248 nullptr , "classname" , "funcname" ) ;
250: c@var2392 .@expr1073747249 memsetError (@expr1073747250 nullptr , "memfunc" , "classname" , "class" ) ;
251: c@var2392 .@expr1073747251 memsetErrorReference (@expr1073747252 nullptr , "memfunc" , "class" ) ;
252: c@var2392 .@expr1073747253 memsetErrorFloat (@expr1073747254 nullptr , "class" ) ;
253: c@var2392 .@expr1073747255 mallocOnClassWarning (@expr1073747256 nullptr , "malloc" , nullptr ) ;
254: c@var2392 .@expr1073747257 mallocOnClassError (@expr1073747258 nullptr , "malloc" , nullptr , "std::string" ) ;
255: c@var2392 .@expr1073747259 virtualDestructorError (@expr1073747260 nullptr , "Base" , "Derived" , false ) ;
256: c@var2392 .@expr1073747261 thisSubtractionError (@expr1073747262 nullptr ) ;
257: c@var2392 .@expr1073747263 operatorEqRetRefThisError (@expr1073747264 nullptr ) ;
258: c@var2392 .@expr1073747265 operatorEqMissingReturnStatementError (@expr1073747266 nullptr , true ) ;
259: c@var2392 .@expr1073747267 operatorEqShouldBeLeftUnimplementedError (@expr1073747268 nullptr ) ;
260: c@var2392 .@expr1073747269 operatorEqToSelfError (@expr1073747270 nullptr ) ;
261: c@var2392 .@expr5447 checkConstError (@expr1073747272 nullptr , "class" , "function" , false ) ;
262: c@var2392 .@expr5447 checkConstError (@expr1073747274 nullptr , "class" , "function" , true ) ;
263: c@var2392 .@expr1073747275 initializerListError (@expr1073747276 nullptr , nullptr , "class" , "variable" ) ;
264: c@var2392 .@expr1073747277 suggestInitializationList (@expr1073747278 nullptr , "variable" ) ;
265: c@var2392 .@expr1073747279 selfInitializationError (@expr1073747280 nullptr , "var" ) ;
266: c@var2392 .@expr1073747281 duplInheritedMembersError (@expr1073747282 nullptr , nullptr , "class" , "class" , "variable" , false , false ) ;
267: c@var2392 .@expr1073747283 copyCtorAndEqOperatorError (@expr1073747284 nullptr , "class" , false , false ) ;
268: c@var2392 .@expr1073747285 pureVirtualFunctionCallInConstructorError (@expr1073747286 nullptr , std ::@expr5463 list < const Token *@expr5464 > (@expr5465 ) , "f" ) ;
269: c@var2392 .@expr1073747290 virtualFunctionCallInConstructorError (@expr1073747291 nullptr , std ::@expr5463 list < const Token *@expr5464 > (@expr5465 ) , "f" ) ;
270: c@var2392 .@expr1073747295 overrideError (@expr1073747296 nullptr , nullptr ) ;
271: c@var2392 .@expr1073747297 thisUseAfterFree (@expr1073747298 nullptr , nullptr , nullptr ) ;
272: c@var2392 .@expr1073747299 unsafeClassRefMemberError (@expr1073747300 nullptr , "UnsafeClass::var" ) ;
273: }
274:
275: static std :: string myName ( ) {
276: return "Class" ;
277: }
278:
279: std :: string classInfo ( ) const override {
280: return "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
281:
|
301:
302: ;
303: }
304:
305:
306: void checkReturnPtrThis ( const Scope * scope@var2393 , const Function * func@var2394 , const Token * tok@var2395 , const Token * last@var2396 ) ;
307: void checkReturnPtrThis ( const Scope * scope@var2397 , const Function * func@var2398 , const Token * tok@var2399 , const Token * last@var2400 , std :: set < const Function * > & analyzedFunctions@var2401 ) ;
308:
309:
310: bool hasAllocation ( const Function * func@var2402 , const Scope * scope@var2403 ) const ;
311: bool hasAllocation ( const Function * func@var2404 , const Scope * scope@var2405 , const Token * start@var2406 , const Token * end@var2407 ) const ;
312: bool hasAllocationInIfScope ( const Function * func@var2408 , const Scope * scope@var2409 , const Token * ifStatementScopeStart@var2410 ) const ;
313: static bool hasAssignSelf ( const Function * func@var2411 , const Token * rhs@var2412 , const Token * * out_ifStatementScopeStart@var2413 ) ;
314: enum class Bool { TRUE , FALSE , BAILOUT } ;
315: static Bool isInverted ( const Token * tok@var2414 , const Token * rhs@var2415 ) ;
316: static const Token * getIfStmtBodyStart ( const Token * tok@var2416 , const Token * rhs@var2417 ) ;
317:
318:
319: bool isMemberVar ( const Scope * scope@var2418 , const Token * tok@var2419 ) const ;
320: bool isMemberFunc ( const Scope * scope@var2420 , const Token * tok@var2421 ) const ;
321: bool isConstMemberFunc ( const Scope * scope@var2422 , const Token * tok@var2423 ) const ;
322: bool checkConstFunc ( const Scope * scope@var2424 , const Function * func@var2425 , bool & memberAccessed@var2426 ) const ;
323:
324:
325:
326: struct Usage {
327: explicit Usage ( const Variable * var@var2427 ) : var@var2428 ( var@var2427 ) , assign@var2429 ( false ) , init@var2430 ( false ) { }
328:
329:
330: const Variable * var@var2428 ;
331:
332:
333: bool assign@var2429 ;
334:
335:
336: bool init@var2430 ;
337: } ;
338:
339: static bool isBaseClassFunc ( const Token * tok@var2431 , const Scope * scope@var2432 ) ;
340:
|
345:
346: static std :: vector < Usage > createUsageList ( const Scope * scope@var2433 ) ;
347:
|
352:
353: static void assignVar ( std :: vector < Usage > & usageList@var2434 , int varid@var2435 ) ;
354:
|
359:
360: static void initVar ( std :: vector < Usage > & usageList@var2436 , int varid@var2437 ) ;
361:
|
365:
366: static void assignAllVar ( std :: vector < Usage > & usageList@var2438 ) ;
367:
|
371:
372: static void clearAllVar ( std :: vector < Usage > & usageList@var2439 ) ;
373:
|
380:
381: void initializeVarList ( const Function & func@var2440 , std :: list < const Function * > & callstack@var2441 , const Scope * scope@var2442 , std :: vector < Usage > & usage@var2443 ) ;
382:
|
388:
389: const std :: list < const Token * > & getVirtualFunctionCalls (
390: const Function & function@var2444 ,
391: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var2445 ) ;
392:
|
398:
399: void getFirstVirtualFunctionCallStack (
400: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var2446 ,
401: const Token * callToken@var2447 ,
402: std :: list < const Token * > & pureFuncStack@var2448 ) ;
403:
404: static bool canNotCopy ( const Scope * scope@var2449 ) ;
405:
406: static bool canNotMove ( const Scope * scope@var2450 ) ;
407:
|
410:
411: bool checkThisUseAfterFreeRecursive ( const Scope * classScope@var2451 , const Function * func@var2452 , const Variable * selfPointer@var2453 , std :: set < const Function * > callstack@var2454 , const Token * * freeToken@var2455 ) ;
412: } ;

##file cppcheck-2.8/lib/astutils.cpp

1:
|
47:
48: const Token * findAstNode ( const Token * ast@var2456 , const std :: function < bool ( const Token * ) > & pred@var2457 )
49: {
50: const Token * result@var2458 ; result@var2458 =@expr1073747301 nullptr ;
51: visitAstNodes (@expr1073747302 ast@var2456 , [@expr1073747303 &@expr1073747304 ] (@expr1073747305 const Token *@expr1073747306 tok@var2459 ) {
52: if (@expr1073747307 pred@var2457 (@expr1073747308 tok@var2459 ) ) {
53: result@var2458 =@expr1073747309 tok@var2459 ;
54: return ChildrenToVisit ::@expr1073747310 done ;
55: }
56: return ChildrenToVisit ::@expr1073747311 op1_and_op2 ;
57: } ) ;
58: return result@var2458 ;
59: }
60:
61: const Token * findExpression ( const int exprid@var2460 ,
62: const Token * start@var2461 ,
63: const Token * end@var2462 ,
64: const std :: function < bool ( const Token * ) > & pred@var2463 )
65: {
66: if (@expr1073747312 !@expr1073747313 precedes (@expr1073747314 start@var2461 , end@var2462 ) ) {
67: return nullptr ; }
68: if (@expr1073747315 exprid@var2460 ==@expr1073747316 0 ) {
69: return nullptr ; }
70: for (@expr1073747317 const Token *@expr1073747318 tok@var2464 =@expr1073747319 start@var2461 ; tok@var2464 !=@expr1073747320 end@var2462 ; tok@var2464 =@expr1073747321 tok@var2464 .@expr1073747322 next (@expr1073747323 ) ) {
71: if (@expr1073747324 tok@var2464 .@expr1073747325 exprId (@expr1073747326 ) !=@expr1073747327 exprid@var2460 ) {
72: continue ; }
73: if (@expr1073747328 pred@var2463 (@expr1073747329 tok@var2464 ) ) {
74: return tok@var2464 ; }
75: }
76: return nullptr ;
77: }
78:
79: static int findArgumentPosRecursive ( const Token * tok@var2465 , const Token * tokToFind@var2466 , bool & found@var2467 , int depth@var2468 = 0 )
80: {
81: ++@expr1073747330 depth@var2468 ;
82: if (@expr1073747331 !@expr1073747332 tok@var2465 ||@expr1073747333 depth@var2468 >=@expr1073747334 100 ) {
83: return -1 ; }
84: if (@expr1073747335 tok@var2465 .@expr1073747336 str (@expr1073747337 ) ==@expr1073747338 "," ) {
85: int res@var2469 ; res@var2469 =@expr1073747339 findArgumentPosRecursive (@expr1073747340 tok@var2465 .@expr1073747341 astOperand1 (@expr1073747342 ) , tokToFind@var2466 , found@var2467 , depth@var2468 ) ;
86: if (@expr5519 res@var2469 ==@expr5520 -1 ) {
87: return -1 ; }
88: if (@expr1073747345 found@var2467 ) {
89: return res@var2469 ; }
90: int argn@var2470 ; argn@var2470 =@expr1073747346 res@var2469 ;
91: res@var2469 =@expr1073747347 findArgumentPosRecursive (@expr1073747348 tok@var2465 .@expr1073747349 astOperand2 (@expr1073747350 ) , tokToFind@var2466 , found@var2467 , depth@var2468 ) ;
92: if (@expr5519 res@var2469 ==@expr5520 -1 ) {
93: return -1 ; }
94: return argn@var2470 +@expr1073747353 res@var2469 ;
95: } else {
96: if (@expr1073747354 tokToFind@var2466 ==@expr1073747355 tok@var2465 ) {
97: found@var2467 =@expr1073747356 true ; }
98: return 1 ;
99: }
100: }
101:
102: static int findArgumentPos ( const Token * tok@var2471 , const Token * tokToFind@var2472 ) {
103: bool found@var2473 ; found@var2473 =@expr1073747357 false ;
104: int argn@var2474 ; argn@var2474 =@expr1073747358 findArgumentPosRecursive (@expr1073747359 tok@var2471 , tokToFind@var2472 , found@var2473 , 0 ) ;
105: if (@expr1073747360 found@var2473 ) {
106: return argn@var2474 -@expr1073747361 1 ; }
107: return -1 ;
108: }
109:
110: static int getArgumentPos ( const Token * ftok@var2475 , const Token * tokToFind@var2476 ) {
111: const Token * tok@var2477 ; tok@var2477 =@expr1073747362 ftok@var2475 ;
112: if (@expr1073747363 Token ::@expr5540 Match (@expr1073747365 tok@var2477 , "%name% (|{" ) ) {
113: tok@var2477 =@expr1073747366 ftok@var2475 .@expr1073747367 next (@expr1073747368 ) ; }
114: if (@expr1073747369 !@expr1073747370 Token ::@expr5540 Match (@expr1073747372 tok@var2477 , "(|{|[" ) ) {
115: return -1 ; }
116: const Token * startTok@var2478 ; startTok@var2478 =@expr1073747373 tok@var2477 .@expr1073747374 astOperand2 (@expr1073747375 ) ;
117: if (@expr1073747376 !@expr1073747377 startTok@var2478 &&@expr1073747378 tok@var2477 .@expr1073747379 next (@expr1073747380 ) !=@expr1073747381 tok@var2477 .@expr1073747382 link (@expr1073747383 ) ) {
118: startTok@var2478 =@expr1073747384 tok@var2477 .@expr1073747385 astOperand1 (@expr1073747386 ) ; }
119: return findArgumentPos (@expr1073747387 startTok@var2478 , tokToFind@var2476 ) ;
120: }
121:
122: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
123: static void astFlattenRecursive ( T * tok@var2479 , std :: vector < T * > * result@var2480 , const char * op@var2481 , int depth@var2482 = 0 )
124: {
125: ++@expr1073747388 depth@var2482 ;
126: if (@expr1073747389 !@expr1073747390 tok@var2479 ||@expr1073747391 depth@var2482 >=@expr1073747392 100 ) {
127: return ; }
128: if (@expr1073747393 tok@var2479 .@expr1073747394 str (@expr1073747395 ) ==@expr1073747396 op@var2481 ) {
129: astFlattenRecursive (@expr1073747397 tok@var2479 .@expr1073747398 astOperand1 (@expr1073747399 ) , result@var2480 , op@var2481 , depth@var2482 ) ;
130: astFlattenRecursive (@expr1073747400 tok@var2479 .@expr1073747401 astOperand2 (@expr1073747402 ) , result@var2480 , op@var2481 , depth@var2482 ) ;
131: } else {
132: result@var2480 .@expr1073747403 push_back (@expr1073747404 tok@var2479 ) ;
133: }
134: }
135:
136: std :: vector < const Token * > astFlatten ( const Token * tok@var2483 , const char * op@var2484 )
137: {
138: std ::@expr1073747405 vector < const Token *@expr1073747406 > result@var2485 ;
139: astFlattenRecursive (@expr1073747407 tok@var2483 , &@expr1073747408 result@var2485 , op@var2484 ) ;
140: return result@var2485 ;
141: }
142:
143: std :: vector < Token * > astFlatten ( Token * tok@var2486 , const char * op@var2487 )
144: {
145: std ::@expr1073747409 vector < Token *@expr1073747410 > result@var2488 ;
146: astFlattenRecursive (@expr1073747411 tok@var2486 , &@expr1073747412 result@var2488 , op@var2487 ) ;
147: return result@var2488 ;
148: }
149:
150: int astCount ( const Token * tok@var2489 , const char * op@var2490 , int depth@var2491 )
151: {
152: --@expr1073747413 depth@var2491 ;
153: if (@expr1073747414 !@expr1073747415 tok@var2489 ||@expr1073747416 depth@var2491 <@expr1073747417 0 ) {
154: return 0 ; }
155: if (@expr1073747418 tok@var2489 .@expr1073747419 str (@expr1073747420 ) ==@expr1073747421 op@var2490 ) {
156: return astCount (@expr1073747422 tok@var2489 .@expr1073747423 astOperand1 (@expr1073747424 ) , op@var2490 , depth@var2491 ) +@expr1073747425 astCount (@expr1073747426 tok@var2489 .@expr1073747427 astOperand2 (@expr1073747428 ) , op@var2490 , depth@var2491 ) ; }
157: else {
158: return 1 ; }
159: }
160:
161: bool astHasToken ( const Token * root@var2492 , const Token * tok@var2493 )
162: {
163: if (@expr1073747429 !@expr1073747430 root@var2492 ) {
164: return false ; }
165: while (@expr1073747431 tok@var2493 .@expr5608 astParent (@expr5609 ) &&@expr1073747434 tok@var2493 !=@expr1073747435 root@var2492 ) {
166: tok@var2493 =@expr1073747436 tok@var2493 .@expr5608 astParent (@expr5609 ) ; }
167: return root@var2492 ==@expr1073747439 tok@var2493 ;
168: }
169:
170: bool astHasVar ( const Token * tok@var2494 , int varid@var2495 )
171: {
172: if (@expr1073747440 !@expr1073747441 tok@var2494 ) {
173: return false ; }
174: if (@expr1073747442 tok@var2494 .@expr1073747443 varId (@expr1073747444 ) ==@expr1073747445 varid@var2495 ) {
175: return true ; }
176: return astHasVar (@expr1073747446 tok@var2494 .@expr1073747447 astOperand1 (@expr1073747448 ) , varid@var2495 ) ||@expr1073747449 astHasVar (@expr1073747450 tok@var2494 .@expr1073747451 astOperand2 (@expr1073747452 ) , varid@var2495 ) ;
177: }
178:
179: static bool astIsCharWithSign ( const Token * tok@var2496 , ValueType :: Sign sign@var2497 )
180: {
181: if (@expr1073747453 !@expr1073747454 tok@var2496 ) {
182: return false ; }
183: const ValueType * valueType@var2498 ; valueType@var2498 =@expr1073747455 tok@var2496 .@expr1073747456 valueType (@expr1073747457 ) ;
184: if (@expr1073747458 !@expr1073747459 valueType@var2498 ) {
185: return false ; }
186: return valueType@var2498 .@expr1073747460 type@var2499 ==@expr1073747461 ValueType ::@expr1073747462 Type ::@expr1073747463 CHAR &&@expr1073747464 valueType@var2498 .@expr1073747465 pointer@var2500 ==@expr1073747466 0U &&@expr1073747467 valueType@var2498 .@expr1073747468 sign@var2501 ==@expr1073747469 sign@var2497 ;
187: }
188:
189: bool astIsSignedChar ( const Token * tok@var2502 )
190: {
191: return astIsCharWithSign (@expr1073747470 tok@var2502 , ValueType ::@expr1073747471 Sign ::@expr1073747472 SIGNED ) ;
192: }
193:
194: bool astIsUnknownSignChar ( const Token * tok@var2503 )
195: {
196: return astIsCharWithSign (@expr1073747473 tok@var2503 , ValueType ::@expr1073747474 Sign ::@expr1073747475 UNKNOWN_SIGN ) ;
197: }
198:
199: bool astIsGenericChar ( const Token * tok@var2504 )
200: {
201: return !@expr1073747476 astIsPointer (@expr1073747477 tok@var2504 ) &&@expr1073747478 tok@var2504 &&@expr1073747479 tok@var2504 .@expr5656 valueType (@expr5657 ) &&@expr1073747482 (@expr1073747483 tok@var2504 .@expr5656 valueType (@expr5657 ) .@expr5662 type@var3313 ==@expr1073747487 ValueType ::@expr5664 Type ::@expr1073747489 CHAR ||@expr1073747490 tok@var2504 .@expr5656 valueType (@expr5657 ) .@expr5662 type@var3313 ==@expr1073747494 ValueType ::@expr5664 Type ::@expr1073747496 WCHAR_T ) ;
202: }
203:
204: bool astIsPrimitive ( const Token * tok@var2505 )
205: {
206: const ValueType * vt@var2506 ; vt@var2506 =@expr1073747497 tok@var2505 ?@expr1073747498 tok@var2505 .@expr1073747499 valueType (@expr1073747500 ) :@expr1073747501 nullptr ;
207: if (@expr1073747502 !@expr1073747503 vt@var2506 ) {
208: return false ; }
209: return vt@var2506 .@expr1073747504 isPrimitive (@expr1073747505 ) ;
210: }
211:
212: bool astIsIntegral ( const Token * tok@var2507 , bool unknown@var2508 )
213: {
214: const ValueType * vt@var2509 ; vt@var2509 =@expr1073747506 tok@var2507 ?@expr1073747507 tok@var2507 .@expr1073747508 valueType (@expr1073747509 ) :@expr1073747510 nullptr ;
215: if (@expr1073747511 !@expr1073747512 vt@var2509 ) {
216: return unknown@var2508 ; }
217: return vt@var2509 .@expr1073747513 isIntegral (@expr1073747514 ) &&@expr1073747515 vt@var2509 .@expr1073747516 pointer@var2510 ==@expr1073747517 0U ;
218: }
219:
220: bool astIsUnsigned ( const Token * tok@var2511 )
221: {
222: return tok@var2511 &&@expr1073747518 tok@var2511 .@expr5695 valueType (@expr5696 ) &&@expr1073747521 tok@var2511 .@expr5695 valueType (@expr5696 ) .@expr1073747524 sign@var3314 ==@expr1073747525 ValueType ::@expr1073747526 UNSIGNED ;
223: }
224:
225: bool astIsFloat ( const Token * tok@var2512 , bool unknown@var2513 )
226: {
227: const ValueType * vt@var2514 ; vt@var2514 =@expr1073747527 tok@var2512 ?@expr1073747528 tok@var2512 .@expr1073747529 valueType (@expr1073747530 ) :@expr1073747531 nullptr ;
228: if (@expr1073747532 !@expr1073747533 vt@var2514 ) {
229: return unknown@var2513 ; }
230: return vt@var2514 .@expr1073747534 type@var2515 >=@expr1073747535 ValueType ::@expr1073747536 Type ::@expr1073747537 FLOAT &&@expr1073747538 vt@var2514 .@expr1073747539 pointer@var2516 ==@expr1073747540 0U ;
231: }
232:
233: bool astIsBool ( const Token * tok@var2517 )
234: {
235: return tok@var2517 &&@expr1073747541 (@expr1073747542 tok@var2517 .@expr1073747543 isBoolean (@expr1073747544 ) ||@expr1073747545 (@expr1073747546 tok@var2517 .@expr5723 valueType (@expr5724 ) &&@expr1073747549 tok@var2517 .@expr5723 valueType (@expr5724 ) .@expr1073747552 type@var3313 ==@expr1073747553 ValueType ::@expr1073747554 Type ::@expr1073747555 BOOL &&@expr1073747556 !@expr1073747557 tok@var2517 .@expr5723 valueType (@expr5724 ) .@expr1073747560 pointer@var3315 ) ) ;
236: }
237:
238: bool astIsPointer ( const Token * tok@var2518 )
239: {
240: return tok@var2518 &&@expr1073747561 tok@var2518 .@expr5738 valueType (@expr5739 ) &&@expr1073747564 tok@var2518 .@expr5738 valueType (@expr5739 ) .@expr1073747567 pointer@var3315 ;
241: }
242:
243: bool astIsSmartPointer ( const Token * tok@var2519 )
244: {
245: return tok@var2519 &&@expr1073747568 tok@var2519 .@expr5745 valueType (@expr5746 ) &&@expr1073747571 tok@var2519 .@expr5745 valueType (@expr5746 ) .@expr1073747574 smartPointerTypeToken@var3316 ;
246: }
247:
248: bool astIsUniqueSmartPointer ( const Token * tok@var2520 )
249: {
250: if (@expr1073747575 !@expr1073747576 astIsSmartPointer (@expr1073747577 tok@var2520 ) ) {
251: return false ; }
252: if (@expr1073747578 !@expr1073747579 tok@var2520 .@expr5756 valueType (@expr5757 ) .@expr5758 smartPointer@var3317 ) {
253: return false ; }
254: return tok@var2520 .@expr5756 valueType (@expr5757 ) .@expr5758 smartPointer@var3317 .@expr1073747586 unique@var3318 ;
255: }
256:
257: bool astIsIterator ( const Token * tok@var2521 )
258: {
259: return tok@var2521 &&@expr1073747587 tok@var2521 .@expr5764 valueType (@expr5765 ) &&@expr1073747590 tok@var2521 .@expr5764 valueType (@expr5765 ) .@expr1073747593 type@var3313 ==@expr1073747594 ValueType ::@expr1073747595 Type ::@expr1073747596 ITERATOR ;
260: }
261:
262: bool astIsContainer ( const Token * tok@var2522 ) {
263: return getLibraryContainer (@expr1073747597 tok@var2522 ) !=@expr1073747598 nullptr &&@expr1073747599 !@expr1073747600 astIsIterator (@expr1073747601 tok@var2522 ) ;
264: }
265:
266: bool astIsContainerView ( const Token * tok@var2523 )
267: {
268: const Library ::@expr1073747602 Container * container@var2524 ; container@var2524 =@expr1073747603 getLibraryContainer (@expr1073747604 tok@var2523 ) ;
269: return container@var2524 &&@expr1073747605 !@expr1073747606 astIsIterator (@expr1073747607 tok@var2523 ) &&@expr1073747608 container@var2524 .@expr1073747609 view@var2525 ;
270: }
271:
272: bool astIsContainerOwned ( const Token * tok@var2526 ) {
273: return astIsContainer (@expr1073747610 tok@var2526 ) &&@expr1073747611 !@expr1073747612 astIsContainerView (@expr1073747613 tok@var2526 ) ;
274: }
275:
276: std :: string astCanonicalType ( const Token * expr@var2527 )
277: {
278: if (@expr1073747614 !@expr1073747615 expr@var2527 ) {
279: return "" ; }
280: std ::@expr1073747616 pair < const Token *@expr5793 , const Token *@expr5793 > decl@var2528 ; decl@var2528 =@expr1073747619 Token ::@expr1073747620 typeDecl (@expr1073747621 expr@var2527 ) ;
281: if (@expr1073747622 decl@var2528 .@expr5799 first@var2529 &&@expr1073747624 decl@var2528 .@expr5801 second@var2530 ) {
282: std ::@expr1073747626 string ret@var2531 ;
283: for (@expr1073747627 const Token *@expr5793 type@var2532 =@expr1073747629 decl@var2528 .@expr5799 first@var2529 ; Token ::@expr5807 Match (@expr1073747632 type@var2532 , "%name%|::" ) &&@expr1073747633 type@var2532 !=@expr1073747634 decl@var2528 .@expr5801 second@var2530 ; type@var2532 =@expr1073747636 type@var2532 .@expr1073747637 next (@expr1073747638 ) ) {
284: if (@expr1073747639 !@expr1073747640 Token ::@expr5807 Match (@expr1073747642 type@var2532 , "const|static" ) ) {
285: ret@var2531 +=@expr1073747643 type@var2532 .@expr1073747644 str (@expr1073747645 ) ; }
286: }
287: return ret@var2531 ;
288: }
289: return "" ;
290: }
291:
292: static bool match ( const Token * tok@var2533 , const std :: string & rhs@var2534 )
293: {
294: if (@expr1073747647 tok@var2533 .@expr1073747648 str (@expr1073747649 ) ==@expr1073747650 rhs@var2534 ) {
295: return true ; }
296: if (@expr1073747651 !@expr1073747652 tok@var2533 .@expr1073747653 varId (@expr1073747654 ) &&@expr1073747655 tok@var2533 .@expr1073747656 hasKnownIntValue (@expr1073747657 ) &&@expr1073747658 MathLib ::@expr1073747659 toString (@expr1073747660 tok@var2533 .@expr1073747661 values (@expr1073747662 ) .@expr1073747663 front (@expr1073747664 ) .@expr1073747665 intvalue@expr1073747646 ) ==@expr1073747666 rhs@var2534 ) {
297: return true ; }
298: return false ;
299: }
300:
301: const Token * astIsVariableComparison ( const Token * tok@var2535 , const std :: string & comp@var2536 , const std :: string & rhs@var2537 , const Token * * vartok@var2538 )
302: {
303: if (@expr1073747667 !@expr1073747668 tok@var2535 ) {
304: return nullptr ; }
305:
306: const Token * ret@var2539 ; ret@var2539 =@expr1073747669 nullptr ;
307: if (@expr1073747670 tok@var2535 .@expr1073747671 isComparisonOp (@expr1073747672 ) ) {
308: if (@expr1073747673 tok@var2535 .@expr5850 astOperand1 (@expr5851 ) &&@expr1073747676 match (@expr1073747677 tok@var2535 .@expr5850 astOperand1 (@expr5851 ) , rhs@var2537 ) ) {
309:
310: std ::@expr1073747680 string s@var2540 ; s@var2540 =@expr1073747681 tok@var2535 .@expr5858 str (@expr5859 ) ;
311: if (@expr1073747684 s@var2540 [@expr5861 0 ] ==@expr1073747686 '>' ) {
312: s@var2540 [@expr5861 0 ] =@expr1073747688 '<' ; }
313: else { if (@expr1073747689 s@var2540 [@expr5861 0 ] ==@expr1073747691 '<' ) {
314: s@var2540 [@expr5861 0 ] =@expr1073747693 '>' ; } }
315: if (@expr1073747694 s@var2540 ==@expr1073747695 comp@var2536 ) {
316: ret@var2539 =@expr1073747696 tok@var2535 .@expr5873 astOperand2 (@expr5874 ) ;
317: }
318: } else { if (@expr1073747699 tok@var2535 .@expr5858 str (@expr5859 ) ==@expr1073747702 comp@var2536 &&@expr1073747703 tok@var2535 .@expr5873 astOperand2 (@expr5874 ) &&@expr1073747706 match (@expr1073747707 tok@var2535 .@expr5873 astOperand2 (@expr5874 ) , rhs@var2537 ) ) {
319: ret@var2539 =@expr1073747710 tok@var2535 .@expr5850 astOperand1 (@expr5851 ) ;
320: } }
321: } else { if (@expr1073747713 comp@var2536 ==@expr1073747714 "!=" &&@expr1073747715 rhs@var2537 ==@expr5892 std ::@expr5893 string (@expr5894 "0" ) ) {
322: if (@expr5895 tok@var2535 .@expr5858 str (@expr5859 ) ==@expr5898 "!" ) {
323: ret@var2539 =@expr1073747723 tok@var2535 .@expr5850 astOperand1 (@expr5851 ) ;
324:
325: astIsVariableComparison (@expr1073747726 ret@var2539 , "==" , "0" , &@expr5903 ret@var2539 ) ;
326: } else {
327: ret@var2539 =@expr1073747728 tok@var2535 ; }
328: } else { if (@expr1073747729 comp@var2536 ==@expr1073747730 "==" &&@expr1073747731 rhs@var2537 ==@expr5892 std ::@expr5893 string (@expr5894 "0" ) ) {
329: if (@expr5895 tok@var2535 .@expr5858 str (@expr5859 ) ==@expr5898 "!" ) {
330: ret@var2539 =@expr1073747739 tok@var2535 .@expr5850 astOperand1 (@expr5851 ) ;
331:
332: astIsVariableComparison (@expr1073747742 ret@var2539 , "!=" , "0" , &@expr5903 ret@var2539 ) ;
333: }
334: } } }
335: while (@expr1073747744 ret@var2539 &&@expr1073747745 ret@var2539 .@expr5922 str (@expr5923 ) ==@expr1073747748 "." ) {
336: ret@var2539 =@expr1073747749 ret@var2539 .@expr1073747750 astOperand2 (@expr1073747751 ) ; }
337: if (@expr1073747752 ret@var2539 &&@expr1073747753 ret@var2539 .@expr5922 str (@expr5923 ) ==@expr1073747756 "=" &&@expr1073747757 ret@var2539 .@expr5934 astOperand1 (@expr5935 ) &&@expr1073747760 ret@var2539 .@expr5934 astOperand1 (@expr5935 ) .@expr1073747763 varId (@expr1073747764 ) ) {
338: ret@var2539 =@expr1073747765 ret@var2539 .@expr5934 astOperand1 (@expr5935 ) ; }
339: else { if (@expr1073747768 ret@var2539 &&@expr1073747769 ret@var2539 .@expr1073747770 varId (@expr1073747771 ) ==@expr1073747772 0U ) {
340: ret@var2539 =@expr1073747773 nullptr ; } }
341: if (@expr1073747774 vartok@var2538 ) {
342: *@expr1073747775 vartok@var2538 =@expr1073747776 ret@var2539 ; }
343: return ret@var2539 ;
344: }
345:
346: bool isVariableDecl ( const Token * tok@var2541 )
347: {
348: if (@expr1073747777 !@expr1073747778 tok@var2541 ) {
349: return false ; }
350: const Variable * var@var2542 ; var@var2542 =@expr1073747779 tok@var2541 .@expr1073747780 variable (@expr1073747781 ) ;
351: if (@expr1073747782 !@expr1073747783 var@var2542 ) {
352: return false ; }
353: if (@expr1073747784 var@var2542 .@expr1073747785 nameToken (@expr1073747786 ) ==@expr1073747787 tok@var2541 ) {
354: return true ; }
355: if (@expr1073747788 Token ::@expr1073747789 Match (@expr1073747790 var@var2542 .@expr5967 declEndToken (@expr5968 ) , "; %var%" ) &&@expr1073747793 var@var2542 .@expr5967 declEndToken (@expr5968 ) .@expr1073747796 next (@expr1073747797 ) ==@expr1073747798 tok@var2541 ) {
356: return true ; }
357: return false ;
358: }
359:
360: bool isTemporary ( bool cpp@var2543 , const Token * tok@var2544 , const Library * library@var2545 , bool unknown@var2546 )
361: {
362: if (@expr1073747799 !@expr1073747800 tok@var2544 ) {
363: return false ; }
364: if (@expr1073747801 Token ::@expr5978 simpleMatch (@expr1073747803 tok@var2544 , "." ) ) {
365: return (@expr5980 tok@var2544 .@expr1073747805 originalName (@expr1073747806 ) !=@expr1073747807 "->" &&@expr1073747808 isTemporary (@expr5985 cpp@var2543 , tok@var2544 .@expr5986 astOperand1 (@expr5987 ) , library@var2545 ) ) ||@expr1073747812
366: isTemporary (@expr5989 cpp@var2543 , tok@var2544 .@expr5990 astOperand2 (@expr5991 ) , library@var2545 ) ; }
367: if (@expr1073747816 Token ::@expr5993 Match (@expr1073747818 tok@var2544 , ",|::" ) ) {
368: return isTemporary (@expr5989 cpp@var2543 , tok@var2544 .@expr5990 astOperand2 (@expr5991 ) , library@var2545 ) ; }
369: if (@expr1073747822 tok@var2544 .@expr5999 isCast (@expr6000 ) ||@expr1073747825 (@expr5980 cpp@var2543 &&@expr1073747827 isCPPCast (@expr1073747828 tok@var2544 ) ) ) {
370: return isTemporary (@expr5989 cpp@var2543 , tok@var2544 .@expr5990 astOperand2 (@expr5991 ) , library@var2545 ) ; }
371: if (@expr1073747832 Token ::@expr5993 Match (@expr1073747834 tok@var2544 , "?|.|[|++|--|%name%|%assign%" ) ) {
372: return false ; }
373: if (@expr1073747835 tok@var2544 .@expr1073747836 isUnaryOp (@expr1073747837 "*" ) ) {
374: return false ; }
375: if (@expr1073747838 Token ::@expr5993 Match (@expr1073747840 tok@var2544 , "&|<<|>>" ) &&@expr1073747841 isLikelyStream (@expr1073747842 cpp@var2543 , tok@var2544 .@expr5986 astOperand1 (@expr5987 ) ) ) {
376: return false ; }
377: if (@expr1073747845 Token ::@expr5978 simpleMatch (@expr6023 tok@var2544 , "(" ) &&@expr1073747848 tok@var2544 .@expr5986 astOperand1 (@expr5987 ) &&@expr1073747851
378: (@expr5980 tok@var2544 .@expr5990 astOperand2 (@expr5991 ) ||@expr1073747855 Token ::@expr5978 simpleMatch (@expr1073747857 tok@var2544 .@expr1073747858 next (@expr1073747859 ) , ")" ) ) ) {
379: if (@expr1073747860 tok@var2544 .@expr6037 valueType (@expr6038 ) ) {
380: return tok@var2544 .@expr6037 valueType (@expr6038 ) .@expr1073747865 reference@var3319 ==@expr1073747866 Reference ::@expr1073747867 None ;
381: }
382: const Token * ftok@var2547 ; ftok@var2547 =@expr1073747868 nullptr ;
383: if (@expr1073747869 Token ::@expr5978 simpleMatch (@expr1073747871 tok@var2544 .@expr6048 previous (@expr6049 ) , ">" ) &&@expr1073747874 tok@var2544 .@expr6048 previous (@expr6049 ) .@expr6053 link (@expr6054 ) ) {
384: ftok@var2547 =@expr1073747879 tok@var2544 .@expr6048 previous (@expr6049 ) .@expr6053 link (@expr6054 ) .@expr1073747884 previous (@expr1073747885 ) ; }
385: else {
386: ftok@var2547 =@expr1073747886 tok@var2544 .@expr6048 previous (@expr6049 ) ; }
387: if (@expr1073747889 !@expr1073747890 ftok@var2547 ) {
388: return false ; }
389: if (@expr1073747891 const Function *@expr1073747892 f@var2548 =@expr1073747893 ftok@var2547 .@expr1073747894 function (@expr1073747895 ) ) {
390: return !@expr1073747896 Function ::@expr1073747897 returnsReference (@expr1073747898 f@var2548 , true ) ;
391: } else { if (@expr1073747899 ftok@var2547 .@expr1073747900 type (@expr1073747901 ) ) {
392: return true ;
393: } else { if (@expr1073747902 library@var2545 ) {
394: std ::@expr1073747903 string returnType@var2549 ; returnType@var2549 =@expr1073747904 library@var2545 .@expr1073747905 returnValueType (@expr1073747906 ftok@var2547 ) ;
395: return !@expr1073747907 returnType@var2549 .@expr1073747908 empty (@expr1073747909 ) &&@expr1073747910 returnType@var2549 .@expr1073747911 back (@expr1073747912 ) !=@expr1073747913 '&' ;
396: } else {
397: return unknown@var2546 ;
398: } } }
399: }
400: if (@expr1073747914 tok@var2544 .@expr5999 isCast (@expr6000 ) ) {
401: return false ; }
402:
403: if (@expr1073747917 Token ::@expr5978 simpleMatch (@expr6023 tok@var2544 , "(" ) &&@expr1073747920 Token ::@expr5978 simpleMatch (@expr1073747922 tok@var2544 .@expr5986 astOperand1 (@expr5987 ) , "(" ) ) {
404: return unknown@var2546 ; }
405: if (@expr1073747925 Token ::@expr5978 simpleMatch (@expr1073747927 tok@var2544 , "{" ) &&@expr1073747928 Token ::@expr5978 simpleMatch (@expr1073747930 tok@var2544 .@expr1073747931 astParent (@expr1073747932 ) , "return" ) &&@expr1073747933 tok@var2544 .@expr5986 astOperand1 (@expr5987 ) &&@expr1073747936
406: !@expr1073747937 tok@var2544 .@expr5990 astOperand2 (@expr5991 ) ) {
407: return isTemporary (@expr5985 cpp@var2543 , tok@var2544 .@expr5986 astOperand1 (@expr5987 ) , library@var2545 ) ; }
408: return true ;
409: }
410:
411: static bool isFunctionCall ( const Token * tok@var2550 )
412: {
413: if (@expr1073747943 Token ::@expr6120 Match (@expr1073747945 tok@var2550 , "%name% (" ) ) {
414: return true ; }
415: if (@expr1073747946 Token ::@expr6120 Match (@expr1073747948 tok@var2550 , "%name% <" ) &&@expr1073747949 Token ::@expr1073747950 simpleMatch (@expr1073747951 tok@var2550 .@expr1073747952 next (@expr1073747953 ) .@expr1073747954 link (@expr1073747955 ) , "> (" ) ) {
416: return true ; }
417: if (@expr1073747956 Token ::@expr6120 Match (@expr1073747958 tok@var2550 , "%name% ::" ) ) {
418: return isFunctionCall (@expr1073747959 tok@var2550 .@expr1073747960 tokAt (@expr1073747961 2 ) ) ; }
419: return false ;
420: }
421:
422: static bool hasToken ( const Token * startTok@var2551 , const Token * stopTok@var2552 , const Token * tok@var2553 )
423: {
424: for (@expr1073747962 const Token *@expr1073747963 tok2@var2554 =@expr1073747964 startTok@var2551 ; tok2@var2554 !=@expr1073747965 stopTok@var2552 ; tok2@var2554 =@expr1073747966 tok2@var2554 .@expr1073747967 next (@expr1073747968 ) ) {
425: if (@expr1073747969 tok2@var2554 ==@expr1073747970 tok@var2553 ) {
426: return true ; }
427: }
428: return false ;
429: }
430:
431: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
432: static T * previousBeforeAstLeftmostLeafGeneric ( T * tok@var2555 )
433: {
434: if (@expr1073747971 !@expr1073747972 tok@var2555 ) {
435: return nullptr ; }
436: T * leftmostLeaf@var2556 ; leftmostLeaf@var2556 =@expr1073747973 tok@var2555 ;
437: while (@expr1073747974 leftmostLeaf@var2556 .@expr6151 astOperand1 (@expr6152 ) ) {
438: leftmostLeaf@var2556 =@expr1073747977 leftmostLeaf@var2556 .@expr6151 astOperand1 (@expr6152 ) ; }
439: return leftmostLeaf@var2556 .@expr1073747980 previous (@expr1073747981 ) ;
440: }
441:
442: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var2557 )
443: {
444: return previousBeforeAstLeftmostLeafGeneric (@expr1073747982 tok@var2557 ) ;
445: }
446: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var2558 )
447: {
448: return previousBeforeAstLeftmostLeafGeneric (@expr1073747983 tok@var2558 ) ;
449: }
450:
451: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
452: static T * nextAfterAstRightmostLeafGeneric ( T * tok@var2559 )
453: {
454: const Token * rightmostLeaf@var2560 ; rightmostLeaf@var2560 =@expr1073747984 tok@var2559 ;
455: if (@expr1073747985 !@expr1073747986 rightmostLeaf@var2560 ||@expr1073747987 !@expr1073747988 rightmostLeaf@var2560 .@expr6165 astOperand1 (@expr6166 ) ) {
456: return nullptr ; }
457: do {
458: if (@expr1073747991 const Token *@expr1073747992 lam@var2561 =@expr1073747993 findLambdaEndToken (@expr1073747994 rightmostLeaf@var2560 ) ) {
459: rightmostLeaf@var2560 =@expr1073747995 lam@var2561 ;
460: break ;
461: }
462: if (@expr1073747996 rightmostLeaf@var2560 .@expr6173 astOperand2 (@expr6174 ) &&@expr1073747999 precedes (@expr1073748000 rightmostLeaf@var2560 , rightmostLeaf@var2560 .@expr6173 astOperand2 (@expr6174 ) ) ) {
463: rightmostLeaf@var2560 =@expr1073748003 rightmostLeaf@var2560 .@expr6173 astOperand2 (@expr6174 ) ; }
464: else { if (@expr1073748006 rightmostLeaf@var2560 .@expr6165 astOperand1 (@expr6166 ) &&@expr1073748009 precedes (@expr1073748010 rightmostLeaf@var2560 , rightmostLeaf@var2560 .@expr6165 astOperand1 (@expr6166 ) ) ) {
465: rightmostLeaf@var2560 =@expr1073748013 rightmostLeaf@var2560 .@expr6165 astOperand1 (@expr6166 ) ; }
466: else {
467: break ; } }
468: } while (@expr1073748016 rightmostLeaf@var2560 .@expr6165 astOperand1 (@expr6166 ) ||@expr1073748019 rightmostLeaf@var2560 .@expr6173 astOperand2 (@expr6174 ) ) ;
469: while (@expr1073748022 Token ::@expr6199 Match (@expr1073748024 rightmostLeaf@var2560 .@expr6201 next (@expr6202 ) , "]|)" ) &&@expr1073748027 !@expr1073748028 hasToken (@expr1073748029 rightmostLeaf@var2560 .@expr6201 next (@expr6202 ) .@expr1073748032 link (@expr1073748033 ) , rightmostLeaf@var2560 .@expr6201 next (@expr6202 ) , tok@var2559 ) ) {
470: rightmostLeaf@var2560 =@expr1073748036 rightmostLeaf@var2560 .@expr6201 next (@expr6202 ) ; }
471: if (@expr1073748039 Token ::@expr6199 Match (@expr1073748041 rightmostLeaf@var2560 , "{|(|[" ) &&@expr1073748042 rightmostLeaf@var2560 .@expr6219 link (@expr6220 ) ) {
472: rightmostLeaf@var2560 =@expr1073748045 rightmostLeaf@var2560 .@expr6219 link (@expr6220 ) ; }
473: return rightmostLeaf@var2560 .@expr6201 next (@expr6202 ) ;
474: }
475:
476: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var2562 )
477: {
478: return nextAfterAstRightmostLeafGeneric (@expr1073748050 tok@var2562 ) ;
479: }
480: Token * nextAfterAstRightmostLeaf ( Token * tok@var2563 )
481: {
482: return nextAfterAstRightmostLeafGeneric (@expr1073748051 tok@var2563 ) ;
483: }
484:
485: const Token * astParentSkipParens ( const Token * tok@var2564 )
486: {
487: return astParentSkipParens (@expr1073748052 const_cast < Token *@expr1073748053 > (@expr1073748054 tok@var2564 ) ) ;
488: }
489: Token * astParentSkipParens ( Token * tok@var2565 )
490: {
491: if (@expr1073748055 !@expr1073748056 tok@var2565 ) {
492: return nullptr ; }
493: Token * parent@var2566 ; parent@var2566 =@expr1073748057 tok@var2565 .@expr1073748058 astParent (@expr1073748059 ) ;
494: if (@expr1073748060 !@expr1073748061 Token ::@expr6238 simpleMatch (@expr1073748063 parent@var2566 , "(" ) ) {
495: return parent@var2566 ; }
496: if (@expr1073748064 parent@var2566 .@expr1073748065 link (@expr1073748066 ) !=@expr1073748067 nextAfterAstRightmostLeaf (@expr1073748068 tok@var2565 ) ) {
497: return parent@var2566 ; }
498: if (@expr1073748069 Token ::@expr1073748070 Match (@expr1073748071 parent@var2566 .@expr6248 previous (@expr6249 ) , "%name% (" ) ||@expr1073748074
499: (@expr1073748075 Token ::@expr6238 simpleMatch (@expr1073748077 parent@var2566 .@expr6248 previous (@expr6249 ) , "> (" ) &&@expr1073748080 parent@var2566 .@expr6248 previous (@expr6249 ) .@expr1073748083 link (@expr1073748084 ) ) ) {
500: return parent@var2566 ; }
501: return astParentSkipParens (@expr1073748085 parent@var2566 ) ;
502: }
503:
504: const Token * getParentMember ( const Token * tok@var2567 )
505: {
506: if (@expr1073748086 !@expr1073748087 tok@var2567 ) {
507: return tok@var2567 ; }
508: const Token * parent@var2568 ; parent@var2568 =@expr1073748088 tok@var2567 .@expr1073748089 astParent (@expr1073748090 ) ;
509: if (@expr1073748091 !@expr1073748092 Token ::@expr6269 simpleMatch (@expr1073748094 parent@var2568 , "." ) ) {
510: return tok@var2567 ; }
511: if (@expr1073748095 astIsRHS (@expr1073748096 tok@var2567 ) ) {
512: if (@expr1073748097 Token ::@expr6269 simpleMatch (@expr1073748099 parent@var2568 .@expr6276 astOperand1 (@expr6277 ) , "." ) ) {
513: return parent@var2568 .@expr6276 astOperand1 (@expr6277 ) .@expr1073748104 astOperand2 (@expr1073748105 ) ; }
514: return parent@var2568 .@expr6276 astOperand1 (@expr6277 ) ;
515: }
516: const Token * gparent@var2569 ; gparent@var2569 =@expr1073748108 parent@var2568 .@expr1073748109 astParent (@expr1073748110 ) ;
517: if (@expr1073748111 !@expr1073748112 Token ::@expr6269 simpleMatch (@expr1073748114 gparent@var2569 , "." ) ||@expr1073748115 gparent@var2569 .@expr1073748116 astOperand2 (@expr1073748117 ) !=@expr1073748118 parent@var2568 ) {
518: return tok@var2567 ; }
519: if (@expr1073748119 gparent@var2569 .@expr6296 astOperand1 (@expr6297 ) ) {
520: return gparent@var2569 .@expr6296 astOperand1 (@expr6297 ) ; }
521: return tok@var2567 ;
522: }
523:
524: const Token * getParentLifetime ( const Token * tok@var2570 )
525: {
526: if (@expr1073748124 !@expr1073748125 tok@var2570 ) {
527: return tok@var2570 ; }
528:
529: if (@expr1073748126 !@expr1073748127 Token ::@expr1073748128 simpleMatch (@expr1073748129 tok@var2570 .@expr1073748130 previous (@expr1073748131 ) , ". *" ) ) {
530: const Variable * var@var2571 ; var@var2571 =@expr1073748132 tok@var2570 .@expr1073748133 variable (@expr1073748134 ) ;
531:
532: if (@expr1073748135 !@expr1073748136 var@var2571 ) {
533: return tok@var2570 ; }
534: if (@expr1073748137 var@var2571 .@expr1073748138 isLocal (@expr1073748139 ) ||@expr1073748140 var@var2571 .@expr1073748141 isArgument (@expr1073748142 ) ) {
535: return tok@var2570 ; }
536: }
537: const Token * parent@var2572 ; parent@var2572 =@expr1073748143 getParentMember (@expr1073748144 tok@var2570 ) ;
538: if (@expr1073748145 parent@var2572 !=@expr1073748146 tok@var2570 ) {
539: return getParentLifetime (@expr1073748147 parent@var2572 ) ; }
540: return tok@var2570 ;
541: }
542:
543: static std :: vector < const Token * > getParentMembers ( const Token * tok@var2573 )
544: {
545: if (@expr1073748148 !@expr1073748149 tok@var2573 ) {
546: return { } ; }
547: if (@expr1073748150 !@expr1073748151 Token ::@expr6328 simpleMatch (@expr1073748153 tok@var2573 .@expr1073748154 astParent (@expr1073748155 ) , "." ) ) {
548: return {@expr1073748156 tok@var2573 } ; }
549: const Token * parent@var2574 ; parent@var2574 =@expr1073748157 tok@var2573 ;
550: while (@expr1073748158 Token ::@expr6328 simpleMatch (@expr1073748160 parent@var2574 .@expr6337 astParent (@expr6338 ) , "." ) ) {
551: parent@var2574 =@expr1073748163 parent@var2574 .@expr6337 astParent (@expr6338 ) ; }
552: std ::@expr1073748166 vector < const Token *@expr6343 > result@var2575 ;
553: for (@expr1073748168 const Token *@expr6343 tok2@var2576 :@expr1073748170 astFlatten (@expr1073748171 parent@var2574 , "." ) ) {
554: if (@expr1073748172 Token ::@expr6328 simpleMatch (@expr1073748174 tok2@var2576 , "(" ) &&@expr1073748175 Token ::@expr6328 simpleMatch (@expr1073748177 tok2@var2576 .@expr6354 astOperand1 (@expr6355 ) , "." ) ) {
555: std ::@expr1073748180 vector < const Token *@expr6343 > sub@var2577 ; sub@var2577 =@expr1073748182 getParentMembers (@expr1073748183 tok2@var2576 .@expr6354 astOperand1 (@expr6355 ) ) ;
556: result@var2575 .@expr1073748186 insert (@expr1073748187 result@var2575 .@expr1073748188 end (@expr1073748189 ) , sub@var2577 .@expr1073748190 begin (@expr1073748191 ) , sub@var2577 .@expr1073748192 end (@expr1073748193 ) ) ;
557: }
558: result@var2575 .@expr1073748194 push_back (@expr1073748195 tok2@var2576 ) ;
559: }
560: return result@var2575 ;
561: }
562:
563: const Token * getParentLifetime ( bool cpp@var2578 , const Token * tok@var2579 , const Library * library@var2580 )
564: {
565: std ::@expr1073748196 vector < const Token *@expr6373 > members@var2581 ; members@var2581 =@expr1073748198 getParentMembers (@expr1073748199 tok@var2579 ) ;
566: if (@expr1073748200 members@var2581 .@expr1073748201 size (@expr1073748202 ) <@expr1073748203 2 ) {
567: return tok@var2579 ; }
568:
569: auto it@var2582 ; it@var2582 =@expr1073748204 std ::@expr1073748205 find_if (@expr1073748206 members@var2581 .@expr1073748207 rbegin (@expr1073748208 ) , members@var2581 .@expr6385 rend (@expr6386 ) , [@expr1073748211 &@expr6388 ] (@expr1073748213 const Token *@expr6373 tok2@var2583 ) {
570: const Variable * var@var2584 ; var@var2584 =@expr1073748215 tok2@var2583 .@expr1073748216 variable (@expr1073748217 ) ;
571: if (@expr1073748218 var@var2584 ) {
572: return var@var2584 .@expr1073748219 isLocal (@expr1073748220 ) ||@expr1073748221 var@var2584 .@expr1073748222 isArgument (@expr1073748223 ) ;
573: } else {
574: return isTemporary (@expr1073748224 cpp@var2578 , tok2@var2583 , library@var2580 ) ;
575: }
576: } ) ;
577: if (@expr1073748225 it@var2582 ==@expr1073748226 members@var2581 .@expr6385 rend (@expr6386 ) ) {
578: return tok@var2579 ; }
579:
580: if (@expr1073748229 std ::@expr1073748230 any_of (@expr1073748231 it@var2582 .@expr1073748232 base (@expr1073748233 ) -@expr1073748234 1 , members@var2581 .@expr1073748235 end (@expr1073748236 ) -@expr1073748237 1 , [@expr1073748238 &@expr6388 ] (@expr1073748240 const Token *@expr6373 tok2@var2585 ) {
581: if (@expr1073748242 astIsPointer (@expr1073748243 tok2@var2585 ) ||@expr1073748244 astIsContainerView (@expr1073748245 tok2@var2585 ) ||@expr1073748246 astIsIterator (@expr1073748247 tok2@var2585 ) ) {
582: return true ; }
583: if (@expr1073748248 !@expr1073748249 astIsUniqueSmartPointer (@expr1073748250 tok2@var2585 ) ) {
584: if (@expr1073748251 astIsSmartPointer (@expr1073748252 tok2@var2585 ) ) {
585: return true ; }
586: const Token *@expr1073748253 dotTok@var2586 ; dotTok@var2586 =@expr1073748254 tok2@var2585 .@expr6431 next (@expr6432 ) ;
587: if (@expr1073748257 !@expr1073748258 Token ::@expr6435 simpleMatch (@expr6436 dotTok@var2586 , "." ) ) {
588: const Token *@expr1073748261 endTok@var2587 ; endTok@var2587 =@expr1073748262 nextAfterAstRightmostLeaf (@expr1073748263 tok2@var2585 ) ;
589: if (@expr1073748264 !@expr1073748265 endTok@var2587 ) {
590: dotTok@var2586 =@expr1073748266 tok2@var2585 .@expr6431 next (@expr6432 ) ; }
591: else { if (@expr1073748269 Token ::@expr6435 simpleMatch (@expr1073748271 endTok@var2587 , "." ) ) {
592: dotTok@var2586 =@expr1073748272 endTok@var2587 ; }
593: else { if (@expr1073748273 Token ::@expr6435 simpleMatch (@expr1073748275 endTok@var2587 .@expr6452 next (@expr6453 ) , "." ) ) {
594: dotTok@var2586 =@expr1073748278 endTok@var2587 .@expr6452 next (@expr6453 ) ; } } }
595: }
596:
597: if (@expr1073748281 Token ::@expr6435 simpleMatch (@expr6436 dotTok@var2586 , "." ) &&@expr1073748284 dotTok@var2586 .@expr1073748285 originalName (@expr1073748286 ) ==@expr1073748287 "->" ) {
598: return true ; }
599: }
600: const Variable *@expr1073748288 var@var2588 ; var@var2588 =@expr1073748289 tok2@var2585 .@expr1073748290 variable (@expr1073748291 ) ;
601: return var@var2588 &&@expr1073748292 var@var2588 .@expr1073748293 isReference (@expr1073748294 ) ;
602: } ) ) {
603: return nullptr ; }
604: return *@expr1073748295 it@var2582 ;
605: }
606:
607: bool astIsLHS ( const Token * tok@var2589 )
608: {
609: if (@expr1073748296 !@expr1073748297 tok@var2589 ) {
610: return false ; }
611: const Token * parent@var2590 ; parent@var2590 =@expr1073748298 tok@var2589 .@expr1073748299 astParent (@expr1073748300 ) ;
612: if (@expr1073748301 !@expr1073748302 parent@var2590 ) {
613: return false ; }
614: if (@expr1073748303 !@expr1073748304 parent@var2590 .@expr6481 astOperand1 (@expr6482 ) ) {
615: return false ; }
616: if (@expr1073748307 !@expr1073748308 parent@var2590 .@expr1073748309 astOperand2 (@expr1073748310 ) ) {
617: return false ; }
618: return parent@var2590 .@expr6481 astOperand1 (@expr6482 ) ==@expr1073748313 tok@var2589 ;
619: }
620: bool astIsRHS ( const Token * tok@var2591 )
621: {
622: if (@expr1073748314 !@expr1073748315 tok@var2591 ) {
623: return false ; }
624: const Token * parent@var2592 ; parent@var2592 =@expr1073748316 tok@var2591 .@expr1073748317 astParent (@expr1073748318 ) ;
625: if (@expr1073748319 !@expr1073748320 parent@var2592 ) {
626: return false ; }
627: if (@expr1073748321 !@expr1073748322 parent@var2592 .@expr1073748323 astOperand1 (@expr1073748324 ) ) {
628: return false ; }
629: if (@expr1073748325 !@expr1073748326 parent@var2592 .@expr6503 astOperand2 (@expr6504 ) ) {
630: return false ; }
631: return parent@var2592 .@expr6503 astOperand2 (@expr6504 ) ==@expr1073748331 tok@var2591 ;
632: }
633:
634: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
635: static T * getCondTokImpl ( T * tok@var2593 )
636: {
637: if (@expr1073748332 !@expr1073748333 tok@var2593 ) {
638: return nullptr ; }
639: if (@expr1073748334 Token ::@expr6511 simpleMatch (@expr1073748336 tok@var2593 , "(" ) ) {
640: return getCondTok (@expr1073748337 tok@var2593 .@expr1073748338 previous (@expr1073748339 ) ) ; }
641: if (@expr1073748340 Token ::@expr6511 simpleMatch (@expr1073748342 tok@var2593 , "for" ) &&@expr1073748343 Token ::@expr6511 simpleMatch (@expr6521 tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) , ";" ) &&@expr1073748350
642: tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) .@expr6531 astOperand2 (@expr6532 ) ) {
643: return tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) .@expr6531 astOperand2 (@expr6532 ) .@expr1073748363 astOperand1 (@expr1073748364 ) ; }
644: if (@expr1073748365 Token ::@expr6511 simpleMatch (@expr6521 tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) , ";" ) ) {
645: return tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) .@expr1073748376 astOperand1 (@expr1073748377 ) ; }
646: return tok@var2593 .@expr6522 next (@expr6523 ) .@expr6524 astOperand2 (@expr6525 ) ;
647: }
648:
649: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
650: static T * getCondTokFromEndImpl ( T * endBlock@var2594 )
651: {
652: if (@expr1073748382 !@expr1073748383 Token ::@expr6560 simpleMatch (@expr1073748385 endBlock@var2594 , "}" ) ) {
653: return nullptr ; }
654: T * startBlock@var2595 ; startBlock@var2595 =@expr1073748386 endBlock@var2594 .@expr1073748387 link (@expr1073748388 ) ;
655: if (@expr1073748389 !@expr1073748390 Token ::@expr6560 simpleMatch (@expr1073748392 startBlock@var2595 , "{" ) ) {
656: return nullptr ; }
657: if (@expr1073748393 Token ::@expr6560 simpleMatch (@expr1073748395 startBlock@var2595 .@expr6572 previous (@expr6573 ) , ")" ) ) {
658: return getCondTok (@expr1073748398 startBlock@var2595 .@expr6572 previous (@expr6573 ) .@expr1073748401 link (@expr1073748402 ) ) ;
659: } else { if (@expr1073748403 Token ::@expr6560 simpleMatch (@expr1073748405 startBlock@var2595 .@expr6582 tokAt (@expr6583 -2 ) , "} else {" ) ) {
660: return getCondTokFromEnd (@expr1073748408 startBlock@var2595 .@expr6582 tokAt (@expr6583 -2 ) ) ;
661: } }
662: return nullptr ;
663: }
664:
665: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
666: static T * getInitTokImpl ( T * tok@var2596 )
667: {
668: if (@expr1073748411 !@expr1073748412 tok@var2596 ) {
669: return nullptr ; }
670: if (@expr1073748413 Token ::@expr1073748414 Match (@expr1073748415 tok@var2596 , "%name% (" ) ) {
671: return getInitTokImpl (@expr1073748416 tok@var2596 .@expr1073748417 next (@expr1073748418 ) ) ; }
672: if (@expr1073748419 tok@var2596 .@expr1073748420 str (@expr1073748421 ) !=@expr1073748422 "(" ) {
673: return nullptr ; }
674: if (@expr1073748423 !@expr1073748424 Token ::@expr6601 simpleMatch (@expr1073748426 tok@var2596 .@expr6603 astOperand2 (@expr6604 ) , ";" ) ) {
675: return nullptr ; }
676: if (@expr1073748429 Token ::@expr6601 simpleMatch (@expr1073748431 tok@var2596 .@expr6603 astOperand2 (@expr6604 ) .@expr6610 astOperand1 (@expr6611 ) , ";" ) ) {
677: return nullptr ; }
678: return tok@var2596 .@expr6603 astOperand2 (@expr6604 ) .@expr6610 astOperand1 (@expr6611 ) ;
679: }
680:
681: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
682: static T * getStepTokImpl ( T * tok@var2597 )
683: {
684: if (@expr1073748440 !@expr1073748441 tok@var2597 ) {
685: return nullptr ; }
686: if (@expr1073748442 Token ::@expr1073748443 Match (@expr1073748444 tok@var2597 , "%name% (" ) ) {
687: return getStepTokImpl (@expr1073748445 tok@var2597 .@expr1073748446 next (@expr1073748447 ) ) ; }
688: if (@expr1073748448 tok@var2597 .@expr1073748449 str (@expr1073748450 ) !=@expr1073748451 "(" ) {
689: return nullptr ; }
690: if (@expr1073748452 !@expr1073748453 Token ::@expr6630 simpleMatch (@expr1073748455 tok@var2597 .@expr6632 astOperand2 (@expr6633 ) , ";" ) ) {
691: return nullptr ; }
692: if (@expr1073748458 !@expr1073748459 Token ::@expr6630 simpleMatch (@expr1073748461 tok@var2597 .@expr6632 astOperand2 (@expr6633 ) .@expr6640 astOperand2 (@expr6641 ) , ";" ) ) {
693: return nullptr ; }
694: return tok@var2597 .@expr6632 astOperand2 (@expr6633 ) .@expr6640 astOperand2 (@expr6641 ) .@expr1073748470 astOperand2 (@expr1073748471 ) ;
695: }
696:
697: Token * getCondTok ( Token * tok@var2598 )
698: {
699: return getCondTokImpl (@expr1073748472 tok@var2598 ) ;
700: }
701: const Token * getCondTok ( const Token * tok@var2599 )
702: {
703: return getCondTokImpl (@expr1073748473 tok@var2599 ) ;
704: }
705:
706: Token * getCondTokFromEnd ( Token * endBlock@var2600 )
707: {
708: return getCondTokFromEndImpl (@expr1073748474 endBlock@var2600 ) ;
709: }
710: const Token * getCondTokFromEnd ( const Token * endBlock@var2601 )
711: {
712: return getCondTokFromEndImpl (@expr1073748475 endBlock@var2601 ) ;
713: }
714:
715: Token * getInitTok ( Token * tok@var2602 ) {
716: return getInitTokImpl (@expr1073748476 tok@var2602 ) ;
717: }
718: const Token * getInitTok ( const Token * tok@var2603 ) {
719: return getInitTokImpl (@expr1073748477 tok@var2603 ) ;
720: }
721:
722: Token * getStepTok ( Token * tok@var2604 ) {
723: return getStepTokImpl (@expr1073748478 tok@var2604 ) ;
724: }
725: const Token * getStepTok ( const Token * tok@var2605 ) {
726: return getStepTokImpl (@expr1073748479 tok@var2605 ) ;
727: }
728:
729: const Token * findNextTokenFromBreak ( const Token * breakToken@var2606 )
730: {
731: const Scope * scope@var2607 ; scope@var2607 =@expr1073748480 breakToken@var2606 .@expr1073748481 scope (@expr1073748482 ) ;
732: while (@expr1073748483 scope@var2607 ) {
733: if (@expr1073748484 scope@var2607 .@expr1073748485 isLoopScope (@expr1073748486 ) ||@expr1073748487 scope@var2607 .@expr6664 type@var2608 ==@expr1073748489 Scope ::@expr6666 ScopeType ::@expr1073748491 eSwitch ) {
734: if (@expr1073748492 scope@var2607 .@expr6664 type@var2608 ==@expr1073748494 Scope ::@expr6666 ScopeType ::@expr1073748496 eDo &&@expr1073748497 Token ::@expr1073748498 simpleMatch (@expr1073748499 scope@var2607 .@expr6676 bodyEnd@var2609 , "} while (" ) ) {
735: return scope@var2607 .@expr6676 bodyEnd@var2609 .@expr1073748502 linkAt (@expr1073748503 2 ) .@expr1073748504 next (@expr1073748505 ) ; }
736: return scope@var2607 .@expr6676 bodyEnd@var2609 ;
737: }
738: scope@var2607 =@expr1073748507 scope@var2607 .@expr1073748508 nestedIn@var2610 ;
739: }
740: return nullptr ;
741: }
742:
743: bool extractForLoopValues ( const Token * forToken@var2611 ,
744: int * const varid@var2612 ,
745: bool * const knownInitValue@var2613 ,
746: long long * const initValue@var2614 ,
747: bool * const partialCond@var2615 ,
748: long long * const stepValue@var2616 ,
749: long long * const lastValue@var2617 )
750: {
751: if (@expr1073748509 !@expr1073748510 Token ::@expr6687 simpleMatch (@expr1073748512 forToken@var2611 , "for (" ) ||@expr1073748513 !@expr1073748514 Token ::@expr6687 simpleMatch (@expr1073748516 forToken@var2611 .@expr6693 next (@expr6694 ) .@expr6695 astOperand2 (@expr6696 ) , ";" ) ) {
752: return false ; }
753: const Token * initExpr@var2618 ; initExpr@var2618 =@expr1073748521 forToken@var2611 .@expr6693 next (@expr6694 ) .@expr6695 astOperand2 (@expr6696 ) .@expr1073748526 astOperand1 (@expr1073748527 ) ;
754: const Token * condExpr@var2619 ; condExpr@var2619 =@expr1073748528 forToken@var2611 .@expr6693 next (@expr6694 ) .@expr6695 astOperand2 (@expr6696 ) .@expr6709 astOperand2 (@expr6710 ) .@expr1073748535 astOperand1 (@expr1073748536 ) ;
755: const Token * incExpr@var2620 ; incExpr@var2620 =@expr1073748537 forToken@var2611 .@expr6693 next (@expr6694 ) .@expr6695 astOperand2 (@expr6696 ) .@expr6709 astOperand2 (@expr6710 ) .@expr1073748544 astOperand2 (@expr1073748545 ) ;
756: if (@expr1073748546 !@expr1073748547 initExpr@var2618 ||@expr1073748548 !@expr1073748549 initExpr@var2618 .@expr1073748550 isBinaryOp (@expr1073748551 ) ||@expr1073748552 initExpr@var2618 .@expr1073748553 str (@expr1073748554 ) !=@expr1073748555 "=" ||@expr1073748556 !@expr1073748557 Token ::@expr6734 Match (@expr1073748559 initExpr@var2618 .@expr6736 astOperand1 (@expr6737 ) , "%var%" ) ) {
757: return false ; }
758: std ::@expr1073748562 vector < long long > minInitValue@var2621 ; minInitValue@var2621 =@expr1073748563 getMinValue (@expr1073748564 makeIntegralInferModel (@expr1073748565 ) , initExpr@var2618 .@expr6742 astOperand2 (@expr6743 ) .@expr1073748568 values (@expr1073748569 ) ) ;
759: *@expr6746 varid@var2612 =@expr1073748571 initExpr@var2618 .@expr6736 astOperand1 (@expr6737 ) .@expr1073748574 varId (@expr1073748575 ) ;
760: *@expr1073748576 knownInitValue@var2613 =@expr1073748577 initExpr@var2618 .@expr6742 astOperand2 (@expr6743 ) .@expr1073748580 hasKnownIntValue (@expr1073748581 ) ;
761: *@expr1073748582 initValue@var2614 =@expr1073748583 minInitValue@var2621 .@expr1073748584 empty (@expr1073748585 ) ?@expr1073748586 0 :@expr1073748587 minInitValue@var2621 .@expr1073748588 front (@expr1073748589 ) ;
762: *@expr1073748590 partialCond@var2615 =@expr1073748591 Token ::@expr6734 Match (@expr6769 condExpr@var2619 , "%oror%|&&" ) ;
763: visitAstNodes (@expr1073748594 condExpr@var2619 , [@expr1073748595 varid@var2612 , &@expr1073748596 condExpr@var2619 ] (@expr1073748597 const Token *@expr1073748598 tok@var2622 ) {
764: if (@expr1073748599 Token ::@expr6734 Match (@expr1073748601 tok@var2622 , "%oror%|&&" ) ) {
765: return ChildrenToVisit ::@expr1073748602 op1_and_op2 ; }
766: if (@expr1073748603 Token ::@expr6734 Match (@expr1073748605 tok@var2622 , "<|<=" ) &&@expr1073748606 tok@var2622 .@expr1073748607 isBinaryOp (@expr1073748608 ) &&@expr1073748609 tok@var2622 .@expr1073748610 astOperand1 (@expr1073748611 ) .@expr1073748612 varId (@expr1073748613 ) ==@expr1073748614 *@expr6746 varid@var2612 &&@expr1073748616 tok@var2622 .@expr6793 astOperand2 (@expr6794 ) .@expr1073748619 hasKnownIntValue (@expr1073748620 ) ) {
767: if (@expr1073748621 Token ::@expr6734 Match (@expr6769 condExpr@var2619 , "%oror%|&&" ) ||@expr1073748624 tok@var2622 .@expr6793 astOperand2 (@expr6794 ) .@expr1073748627 getKnownIntValue (@expr1073748628 ) <@expr1073748629 condExpr@var2619 .@expr6806 astOperand2 (@expr6807 ) .@expr6808 getKnownIntValue (@expr6809 ) ) {
768: condExpr@var2619 =@expr1073748634 tok@var2622 ; }
769: }
770: return ChildrenToVisit ::@expr1073748635 none ;
771: } ) ;
772: if (@expr1073748636 !@expr1073748637 Token ::@expr6734 Match (@expr1073748639 condExpr@var2619 , "<|<=" ) ||@expr1073748640 !@expr1073748641 condExpr@var2619 .@expr1073748642 isBinaryOp (@expr1073748643 ) ||@expr1073748644 condExpr@var2619 .@expr1073748645 astOperand1 (@expr1073748646 ) .@expr1073748647 varId (@expr1073748648 ) !=@expr1073748649 *@expr6746 varid@var2612 ||@expr1073748651 !@expr1073748652 condExpr@var2619 .@expr6806 astOperand2 (@expr6807 ) .@expr1073748655 hasKnownIntValue (@expr1073748656 ) ) {
773: return false ; }
774: if (@expr1073748657 !@expr1073748658 incExpr@var2620 ||@expr1073748659 !@expr1073748660 incExpr@var2620 .@expr1073748661 isUnaryOp (@expr1073748662 "++" ) ||@expr1073748663 incExpr@var2620 .@expr1073748664 astOperand1 (@expr1073748665 ) .@expr1073748666 varId (@expr1073748667 ) !=@expr1073748668 *@expr6746 varid@var2612 ) {
775: return false ; }
776: *@expr1073748670 stepValue@var2616 =@expr1073748671 1 ;
777: if (@expr1073748672 condExpr@var2619 .@expr1073748673 str (@expr1073748674 ) ==@expr1073748675 "<" ) {
778: *@expr6852 lastValue@var2617 =@expr1073748677 condExpr@var2619 .@expr6806 astOperand2 (@expr6807 ) .@expr6808 getKnownIntValue (@expr6809 ) -@expr1073748682 1 ; }
779: else {
780: *@expr6852 lastValue@var2617 =@expr1073748684 condExpr@var2619 .@expr6806 astOperand2 (@expr6807 ) .@expr6808 getKnownIntValue (@expr6809 ) ; }
781: return true ;
782: }
783:
784:
785: static const Token * getVariableInitExpression ( const Variable * var@var2623 )
786: {
787: if (@expr1073748689 !@expr1073748690 var@var2623 ) {
788: return nullptr ; }
789: const Token * varDeclEndToken@var2624 ; varDeclEndToken@var2624 =@expr1073748691 var@var2623 .@expr1073748692 declEndToken (@expr1073748693 ) ;
790: if (@expr1073748694 !@expr1073748695 varDeclEndToken@var2624 ) {
791: return nullptr ; }
792: if (@expr1073748696 Token ::@expr1073748697 Match (@expr1073748698 varDeclEndToken@var2624 , "; %varid% =" , var@var2623 .@expr1073748699 declarationId (@expr1073748700 ) ) ) {
793: return varDeclEndToken@var2624 .@expr1073748701 tokAt (@expr1073748702 2 ) .@expr1073748703 astOperand2 (@expr1073748704 ) ; }
794: return varDeclEndToken@var2624 .@expr1073748705 astOperand2 (@expr1073748706 ) ;
795: }
796:
797: static bool isInLoopCondition ( const Token * tok@var2625 )
798: {
799: return Token ::@expr1073748707 Match (@expr1073748708 tok@var2625 .@expr1073748709 astTop (@expr1073748710 ) .@expr1073748711 previous (@expr1073748712 ) , "for|while (" ) ;
800: }
801:
802:
803: bool precedes ( const Token * tok1@var2626 , const Token * tok2@var2627 )
804: {
805: if (@expr1073748713 tok1@var2626 ==@expr1073748714 tok2@var2627 ) {
806: return false ; }
807: if (@expr1073748715 !@expr1073748716 tok1@var2626 ) {
808: return false ; }
809: if (@expr1073748717 !@expr1073748718 tok2@var2627 ) {
810: return true ; }
811: return tok1@var2626 .@expr1073748719 index (@expr1073748720 ) <@expr1073748721 tok2@var2627 .@expr1073748722 index (@expr1073748723 ) ;
812: }
813:
814:
815: bool succeeds ( const Token * tok1@var2628 , const Token * tok2@var2629 )
816: {
817: if (@expr1073748724 tok1@var2628 ==@expr1073748725 tok2@var2629 ) {
818: return false ; }
819: if (@expr1073748726 !@expr1073748727 tok1@var2628 ) {
820: return false ; }
821: if (@expr1073748728 !@expr1073748729 tok2@var2629 ) {
822: return true ; }
823: return tok1@var2628 .@expr1073748730 index (@expr1073748731 ) >@expr1073748732 tok2@var2629 .@expr1073748733 index (@expr1073748734 ) ;
824: }
825:
826: bool isAliasOf ( const Token * tok@var2630 , int varid@var2631 , bool * inconclusive@var2632 )
827: {
828: if (@expr1073748735 tok@var2630 .@expr1073748736 varId (@expr1073748737 ) ==@expr1073748738 varid@var2631 ) {
829: return false ; }
830: for (@expr1073748739 const ValueFlow ::@expr1073748740 Value &@expr1073748741 val@var2633 :@expr1073748742 tok@var2630 .@expr1073748743 values (@expr1073748744 ) ) {
831: if (@expr1073748745 !@expr1073748746 val@var2633 .@expr1073748747 isLocalLifetimeValue (@expr1073748748 ) ) {
832: continue ; }
833: if (@expr1073748749 val@var2633 .@expr1073748750 tokvalue@var2634 .@expr1073748751 varId (@expr1073748752 ) ==@expr1073748753 varid@var2631 ) {
834: if (@expr1073748754 val@var2633 .@expr1073748755 isInconclusive (@expr1073748756 ) ) {
835: if (@expr1073748757 inconclusive@var2632 ) {
836: *@expr1073748758 inconclusive@var2632 =@expr1073748759 true ; }
837: else {
838: continue ; }
839: }
840: return true ;
841: }
842: }
843: return false ;
844: }
845:
846: static bool isAliased ( const Token * startTok@var2635 , const Token * endTok@var2636 , int varid@var2637 )
847: {
848: if (@expr1073748760 !@expr1073748761 precedes (@expr1073748762 startTok@var2635 , endTok@var2636 ) ) {
849: return false ; }
850: for (@expr1073748763 const Token *@expr1073748764 tok@var2638 =@expr1073748765 startTok@var2635 ; tok@var2638 !=@expr1073748766 endTok@var2636 ; tok@var2638 =@expr1073748767 tok@var2638 .@expr1073748768 next (@expr1073748769 ) ) {
851: if (@expr1073748770 Token ::@expr1073748771 Match (@expr1073748772 tok@var2638 , "= & %varid% ;" , varid@var2637 ) ) {
852: return true ; }
853: if (@expr1073748773 isAliasOf (@expr1073748774 tok@var2638 , varid@var2637 ) ) {
854: return true ; }
855: }
856: return false ;
857: }
858:
859: bool isAliased ( const Variable * var@var2639 )
860: {
861: if (@expr1073748775 !@expr1073748776 var@var2639 ) {
862: return false ; }
863: if (@expr1073748777 !@expr1073748778 var@var2639 .@expr6955 scope (@expr6956 ) ) {
864: return false ; }
865: const Token * start@var2640 ; start@var2640 =@expr1073748781 var@var2639 .@expr1073748782 declEndToken (@expr1073748783 ) ;
866: if (@expr1073748784 !@expr1073748785 start@var2640 ) {
867: return false ; }
868: return isAliased (@expr1073748786 start@var2640 , var@var2639 .@expr6955 scope (@expr6956 ) .@expr1073748789 bodyEnd@var3320 , var@var2639 .@expr1073748790 declarationId (@expr1073748791 ) ) ;
869: }
870:
871: bool exprDependsOnThis ( const Token * expr@var2641 , bool onVar@var2642 , int depth@var2643 )
872: {
873: if (@expr1073748792 !@expr1073748793 expr@var2641 ) {
874: return false ; }
875: if (@expr1073748794 expr@var2641 .@expr1073748795 str (@expr1073748796 ) ==@expr1073748797 "this" ) {
876: return true ; }
877: if (@expr1073748798 depth@var2643 >=@expr1073748799 1000 ) {
878:
879: return true ; }
880: ++@expr1073748800 depth@var2643 ;
881:
882: if (@expr1073748801 Token ::@expr6978 Match (@expr1073748803 expr@var2641 .@expr1073748804 previous (@expr1073748805 ) , "!!:: %name% (" ) &&@expr1073748806 expr@var2641 .@expr6983 function (@expr6984 ) &&@expr1073748809 expr@var2641 .@expr6983 function (@expr6984 ) .@expr6988 nestedIn@var3321 &&@expr1073748813
883: expr@var2641 .@expr6983 function (@expr6984 ) .@expr6988 nestedIn@var3321 .@expr1073748817 isClassOrStruct (@expr1073748818 ) ) {
884:
885: const Scope * fScope@var2644 ; fScope@var2644 =@expr1073748819 expr@var2641 .@expr1073748820 scope (@expr1073748821 ) ;
886: while (@expr1073748822 !@expr1073748823 fScope@var2644 .@expr7000 functionOf@var2645 &&@expr1073748825 fScope@var2644 .@expr7002 nestedIn@var2646 ) {
887: fScope@var2644 =@expr1073748827 fScope@var2644 .@expr7002 nestedIn@var2646 ; }
888:
889: const Scope * classScope@var2647 ; classScope@var2647 =@expr1073748829 fScope@var2644 .@expr7000 functionOf@var2645 ;
890: if (@expr1073748831 classScope@var2647 &&@expr1073748832 classScope@var2647 .@expr7009 function@var2648 ) {
891: classScope@var2647 =@expr1073748834 classScope@var2647 .@expr7009 function@var2648 .@expr1073748836 token@var2649 .@expr1073748837 scope (@expr1073748838 ) ; }
892:
893: if (@expr1073748839 classScope@var2647 &&@expr1073748840 classScope@var2647 .@expr1073748841 isClassOrStruct (@expr1073748842 ) ) {
894: return contains (@expr1073748843 classScope@var2647 .@expr1073748844 findAssociatedScopes (@expr1073748845 ) , expr@var2641 .@expr6983 function (@expr6984 ) .@expr6988 nestedIn@var3321 ) ; }
895: return false ;
896: } else { if (@expr1073748849 onVar@var2642 &&@expr1073748850 Token ::@expr6978 Match (@expr1073748852 expr@var2641 , "%var%" ) &&@expr1073748853 expr@var2641 .@expr7030 variable (@expr7031 ) ) {
897: const Variable * var@var2650 ; var@var2650 =@expr1073748856 expr@var2641 .@expr7030 variable (@expr7031 ) ;
898: return (@expr1073748859 var@var2650 .@expr1073748860 isPrivate (@expr1073748861 ) ||@expr1073748862 var@var2650 .@expr1073748863 isPublic (@expr1073748864 ) ||@expr1073748865 var@var2650 .@expr1073748866 isProtected (@expr1073748867 ) ) ;
899: } }
900: if (@expr1073748868 Token ::@expr1073748869 simpleMatch (@expr1073748870 expr@var2641 , "." ) ) {
901: return exprDependsOnThis (@expr7047 expr@var2641 .@expr7048 astOperand1 (@expr7049 ) , onVar@var2642 , depth@var2643 ) ; }
902: return exprDependsOnThis (@expr7047 expr@var2641 .@expr7048 astOperand1 (@expr7049 ) , onVar@var2642 , depth@var2643 ) ||@expr1073748877 exprDependsOnThis (@expr1073748878 expr@var2641 .@expr1073748879 astOperand2 (@expr1073748880 ) , onVar@var2642 , depth@var2643 ) ;
903: }
904:
905: static bool hasUnknownVars ( const Token * startTok@var2651 )
906: {
907: bool result@var2652 ; result@var2652 =@expr1073748881 false ;
908: visitAstNodes (@expr1073748882 startTok@var2651 , [@expr1073748883 &@expr1073748884 ] (@expr1073748885 const Token *@expr1073748886 tok@var2653 ) {
909: if (@expr1073748887 tok@var2653 .@expr1073748888 varId (@expr1073748889 ) >@expr1073748890 0 &&@expr1073748891 !@expr1073748892 tok@var2653 .@expr1073748893 variable (@expr1073748894 ) ) {
910: result@var2652 =@expr1073748895 true ;
911: return ChildrenToVisit ::@expr1073748896 done ;
912: }
913: return ChildrenToVisit ::@expr1073748897 op1_and_op2 ;
914: } ) ;
915: return result@var2652 ;
916: }
917:
918: static bool isStructuredBindingVariable ( const Variable * var@var2654 )
919: {
920: if (@expr1073748898 !@expr1073748899 var@var2654 ) {
921: return false ; }
922: const Token * tok@var2655 ; tok@var2655 =@expr1073748900 var@var2654 .@expr1073748901 nameToken (@expr1073748902 ) ;
923: while (@expr1073748903 Token ::@expr1073748904 Match (@expr1073748905 tok@var2655 .@expr7082 astParent (@expr7083 ) , "[|," ) ) {
924: tok@var2655 =@expr1073748908 tok@var2655 .@expr7082 astParent (@expr7083 ) ; }
925: return Token ::@expr1073748911 simpleMatch (@expr1073748912 tok@var2655 , "[" ) ;
926: }
927:
|
930:
931: static const Token * followVariableExpression ( const Token * tok@var2656 , bool cpp@var2657 , const Token * end@var2658 = nullptr )
932: {
933: if (@expr1073748913 !@expr1073748914 tok@var2656 ) {
934: return tok@var2656 ; }
935:
936: if (@expr1073748915 end@var2658 &&@expr1073748916 end@var2658 .@expr1073748917 fileIndex (@expr1073748918 ) !=@expr1073748919 tok@var2656 .@expr1073748920 fileIndex (@expr1073748921 ) ) {
937: return tok@var2656 ; }
938:
939: if (@expr1073748922 Token ::@expr7099 Match (@expr1073748924 tok@var2656 , "%var% [" ) ) {
940: return tok@var2656 ; }
941:
942: if (@expr1073748925 tok@var2656 .@expr1073748926 astParent (@expr1073748927 ) &&@expr1073748928 tok@var2656 .@expr1073748929 isUnaryOp (@expr1073748930 "*" ) ) {
943: return tok@var2656 ; }
944:
945: if (@expr1073748931 Token ::@expr7099 Match (@expr1073748933 tok@var2656 .@expr1073748934 next (@expr1073748935 ) , "%assign%" ) ) {
946: return tok@var2656 ; }
947: const Variable * var@var2659 ; var@var2659 =@expr1073748936 tok@var2656 .@expr1073748937 variable (@expr1073748938 ) ;
948: const Token * varTok@var2660 ; varTok@var2660 =@expr1073748939 getVariableInitExpression (@expr1073748940 var@var2659 ) ;
949: if (@expr1073748941 !@expr1073748942 varTok@var2660 ) {
950: return tok@var2656 ; }
951: if (@expr1073748943 hasUnknownVars (@expr1073748944 varTok@var2660 ) ) {
952: return tok@var2656 ; }
953: if (@expr1073748945 var@var2659 .@expr1073748946 isVolatile (@expr1073748947 ) ) {
954: return tok@var2656 ; }
955: if (@expr1073748948 !@expr1073748949 var@var2659 .@expr1073748950 isLocal (@expr1073748951 ) &&@expr1073748952 !@expr7129 var@var2659 .@expr7130 isConst (@expr7131 ) ) {
956: return tok@var2656 ; }
957: if (@expr1073748956 var@var2659 .@expr1073748957 isStatic (@expr1073748958 ) &&@expr1073748959 !@expr7129 var@var2659 .@expr7130 isConst (@expr7131 ) ) {
958: return tok@var2656 ; }
959: if (@expr1073748963 var@var2659 .@expr1073748964 isArgument (@expr1073748965 ) ) {
960: return tok@var2656 ; }
961: if (@expr1073748966 isStructuredBindingVariable (@expr1073748967 var@var2659 ) ) {
962: return tok@var2656 ; }
963:
964: if (@expr1073748968 var@var2659 .@expr7145 valueType (@expr7146 ) &&@expr1073748971 var@var2659 .@expr7145 valueType (@expr7146 ) .@expr1073748974 isIntegral (@expr1073748975 ) &&@expr1073748976 varTok@var2660 .@expr7153 valueType (@expr7154 ) &&@expr1073748979 varTok@var2660 .@expr7153 valueType (@expr7154 ) .@expr1073748982 isFloat (@expr1073748983 ) ) {
965: return tok@var2656 ; }
966: const Token * lastTok@var2661 ; lastTok@var2661 =@expr1073748984 precedes (@expr1073748985 tok@var2656 , end@var2658 ) ?@expr1073748986 end@var2658 :@expr1073748987 tok@var2656 ;
967:
968: const Token * endToken@var2662 ; endToken@var2662 =@expr1073748988 (@expr1073748989 isInLoopCondition (@expr1073748990 tok@var2656 ) ||@expr1073748991 isInLoopCondition (@expr1073748992 varTok@var2660 ) ||@expr1073748993 var@var2659 .@expr7170 scope (@expr7171 ) !=@expr1073748996 tok@var2656 .@expr1073748997 scope (@expr1073748998 ) ) ?@expr1073748999 var@var2659 .@expr7170 scope (@expr7171 ) .@expr1073749002 bodyEnd@var3320 :@expr1073749003 lastTok@var2661 ;
969: if (@expr1073749004 !@expr7129 var@var2659 .@expr7130 isConst (@expr7131 ) &&@expr1073749008 (@expr1073749009 !@expr1073749010 precedes (@expr7187 varTok@var2660 , endToken@var2662 ) ||@expr1073749012 isVariableChanged (@expr1073749013 varTok@var2660 , endToken@var2662 , tok@var2656 .@expr7190 varId (@expr7191 ) , false , nullptr , cpp@var2657 ) ) ) {
970: return tok@var2656 ; }
971: if (@expr1073749016 precedes (@expr7187 varTok@var2660 , endToken@var2662 ) &&@expr1073749018 isAliased (@expr1073749019 varTok@var2660 , endToken@var2662 , tok@var2656 .@expr7190 varId (@expr7191 ) ) ) {
972: return tok@var2656 ; }
973: const Token * startToken@var2663 ; startToken@var2663 =@expr1073749022 nextAfterAstRightmostLeaf (@expr1073749023 varTok@var2660 ) ;
974: if (@expr1073749024 !@expr1073749025 startToken@var2663 ) {
975: startToken@var2663 =@expr1073749026 varTok@var2660 ; }
976: if (@expr1073749027 varTok@var2660 .@expr1073749028 exprId (@expr1073749029 ) ==@expr1073749030 0 ) {
977: if (@expr1073749031 !@expr1073749032 varTok@var2660 .@expr1073749033 isLiteral (@expr1073749034 ) ) {
978: return tok@var2656 ; }
979: } else { if (@expr1073749035 !@expr1073749036 precedes (@expr1073749037 startToken@var2663 , endToken@var2662 ) ) {
980: return tok@var2656 ;
981: } else { if (@expr1073749038 isExpressionChanged (@expr1073749039 varTok@var2660 , startToken@var2663 , endToken@var2662 , nullptr , cpp@var2657 ) ) {
982: return tok@var2656 ;
983: } } }
984: return varTok@var2660 ;
985: }
986:
987: static void followVariableExpressionError ( const Token * tok1@var2664 , const Token * tok2@var2665 , std :: list < std :: pair < const Token * , std :: string > > * errors@var2666 )
988: {
989: if (@expr1073749040 !@expr1073749041 errors@var2666 ) {
990: return ; }
991: if (@expr1073749042 !@expr1073749043 tok1@var2664 ) {
992: return ; }
993: if (@expr1073749044 !@expr1073749045 tok2@var2665 ) {
994: return ; }
995: std ::@expr1073749046 pair < const Token *@expr1073749047 , std ::@expr1073749048 string > item@var2667 ; item@var2667 =@expr1073749049 std ::@expr1073749050 make_pair (@expr1073749051 tok2@var2665 , "'" +@expr1073749052 tok1@var2664 .@expr1073749053 str (@expr1073749054 ) +@expr1073749055 "' is assigned value '" +@expr1073749056 tok2@var2665 .@expr1073749057 expressionString (@expr1073749058 ) +@expr1073749059 "' here." ) ;
996: if (@expr1073749060 std ::@expr1073749061 find (@expr1073749062 errors@var2666 .@expr1073749063 begin (@expr1073749064 ) , errors@var2666 .@expr7241 end (@expr7242 ) , item@var2667 ) !=@expr1073749067 errors@var2666 .@expr7241 end (@expr7242 ) ) {
997: return ; }
998: errors@var2666 .@expr1073749070 push_back (@expr1073749071 item@var2667 ) ;
999: }
1000:
1001: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var2668 ,
1002: bool temporary@var2669 ,
1003: bool inconclusive@var2670 ,
1004: std :: list < std :: pair < const Token * , std :: string > > errors@var2671 ,
1005: int depth@var2672 )
1006: {
1007: struct ReferenceTokenLess {
1008: bool operator() (@expr1073749072 const ReferenceToken & x@var2673 , const ReferenceToken & y@var2674 ) const {
1009: return x@var2673 .@expr1073749354 token@var2675 <@expr1073749355 y@var2674 .@expr1073749356 token@var2676 ;
1010: }
1011: } ;
1012: if (@expr1073749076 !@expr1073749077 tok@var2668 ) {
1013: return std ::@expr7254 vector < ReferenceToken > {@expr1073749079 } ; }
1014: if (@expr1073749080 depth@var2672 <@expr1073749081 0 ) {
1015: return {@expr1073749082 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1016: const Variable * var@var2677 ; var@var2677 =@expr1073749085 tok@var2668 .@expr1073749086 variable (@expr1073749087 ) ;
1017: if (@expr1073749088 var@var2677 &&@expr1073749089 var@var2677 .@expr1073749090 declarationId (@expr1073749091 ) ==@expr1073749092 tok@var2668 .@expr1073749093 varId (@expr1073749094 ) ) {
1018: if (@expr1073749095 var@var2677 .@expr1073749096 nameToken (@expr1073749097 ) ==@expr1073749098 tok@var2668 ||@expr1073749099 isStructuredBindingVariable (@expr1073749100 var@var2677 ) ) {
1019: return {@expr1073749101 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ;
1020: } else { if (@expr1073749104 var@var2677 .@expr1073749105 isReference (@expr1073749106 ) ||@expr1073749107 var@var2677 .@expr7284 isRValueReference (@expr7285 ) ) {
1021: if (@expr1073749110 !@expr1073749111 var@var2677 .@expr7288 declEndToken (@expr7289 ) ) {
1022: return {@expr1073749114 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1023: if (@expr1073749117 var@var2677 .@expr1073749118 isArgument (@expr1073749119 ) ) {
1024: errors@var2671 .@expr7296 emplace_back (@expr1073749121 var@var2677 .@expr7288 declEndToken (@expr7289 ) , "Passed to reference." ) ;
1025: return {@expr1073749124 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ;
1026: } else { if (@expr1073749127 Token ::@expr7304 simpleMatch (@expr1073749129 var@var2677 .@expr7288 declEndToken (@expr7289 ) , "=" ) ) {
1027: if (@expr1073749132 astHasToken (@expr1073749133 var@var2677 .@expr7288 declEndToken (@expr7289 ) , tok@var2668 ) ) {
1028: return std ::@expr7254 vector < ReferenceToken > {@expr1073749137 } ; }
1029: errors@var2671 .@expr7296 emplace_back (@expr1073749139 var@var2677 .@expr7288 declEndToken (@expr7289 ) , "Assigned to reference." ) ;
1030: const Token * vartok@var2678 ; vartok@var2678 =@expr1073749142 var@var2677 .@expr7288 declEndToken (@expr7289 ) .@expr1073749145 astOperand2 (@expr1073749146 ) ;
1031: if (@expr1073749147 vartok@var2678 ==@expr1073749148 tok@var2668 ||@expr1073749149 (@expr1073749150 !@expr1073749151 temporary@var2669 &&@expr1073749152 isTemporary (@expr1073749153 true , vartok@var2678 , nullptr , true ) &&@expr1073749154
1032: (@expr1073749155 var@var2677 .@expr1073749156 isConst (@expr1073749157 ) ||@expr1073749158 var@var2677 .@expr7284 isRValueReference (@expr7285 ) ) ) ) {
1033: return {@expr1073749161 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1034: if (@expr1073749164 vartok@var2678 ) {
1035: return followAllReferences (@expr1073749165 vartok@var2678 , temporary@var2669 , inconclusive@var2670 , std ::@expr7259 move (@expr7260 errors@var2671 ) , depth@var2672 -@expr7344 1 ) ; }
1036: } else {
1037: return {@expr1073749169 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ;
1038: } }
1039: } }
1040: } else { if (@expr1073749172 Token ::@expr7304 simpleMatch (@expr1073749174 tok@var2668 , "?" ) &&@expr1073749175 Token ::@expr7304 simpleMatch (@expr1073749177 tok@var2668 .@expr7354 astOperand2 (@expr7355 ) , ":" ) ) {
1041: std ::@expr1073749180 set < ReferenceToken , ReferenceTokenLess > result@var2679 ;
1042: const Token * tok2@var2680 ; tok2@var2680 =@expr1073749181 tok@var2668 .@expr7354 astOperand2 (@expr7355 ) ;
1043:
1044: std ::@expr1073749184 vector < ReferenceToken > refs@var2681 ;
1045: refs@var2681 =@expr1073749185 followAllReferences (@expr1073749186 tok2@var2680 .@expr1073749187 astOperand1 (@expr1073749188 ) , temporary@var2669 , inconclusive@var2670 , errors@var2671 , depth@var2672 -@expr7344 1 ) ;
1046: result@var2679 .@expr7366 insert (@expr7367 refs@var2681 .@expr7368 begin (@expr7369 ) , refs@var2681 .@expr7370 end (@expr7371 ) ) ;
1047: refs@var2681 =@expr1073749196 followAllReferences (@expr1073749197 tok2@var2680 .@expr1073749198 astOperand2 (@expr1073749199 ) , temporary@var2669 , inconclusive@var2670 , errors@var2671 , depth@var2672 -@expr7344 1 ) ;
1048: result@var2679 .@expr7366 insert (@expr7367 refs@var2681 .@expr7368 begin (@expr7369 ) , refs@var2681 .@expr7370 end (@expr7371 ) ) ;
1049:
1050: if (@expr1073749207 !@expr7384 inconclusive@var2670 &&@expr1073749209 result@var2679 .@expr1073749210 size (@expr1073749211 ) !=@expr1073749212 1 ) {
1051: return {@expr1073749213 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1052:
1053: if (@expr1073749216 !@expr1073749217 result@var2679 .@expr1073749218 empty (@expr1073749219 ) ) {
1054: return std ::@expr7254 vector < ReferenceToken > (@expr1073749221 result@var2679 .@expr1073749222 begin (@expr1073749223 ) , result@var2679 .@expr1073749224 end (@expr1073749225 ) ) ; }
1055:
1056: } else { if (@expr1073749226 Token ::@expr1073749227 Match (@expr1073749228 tok@var2668 .@expr7405 previous (@expr7406 ) , "%name% (" ) ) {
1057: const Function * f@var2682 ; f@var2682 =@expr1073749231 tok@var2668 .@expr7405 previous (@expr7406 ) .@expr1073749234 function (@expr1073749235 ) ;
1058: if (@expr1073749236 f@var2682 ) {
1059: if (@expr1073749237 !@expr1073749238 Function ::@expr1073749239 returnsReference (@expr1073749240 f@var2682 ) ) {
1060: return {@expr1073749241 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1061: std ::@expr1073749244 set < ReferenceToken , ReferenceTokenLess > result@var2683 ;
1062: std ::@expr1073749245 vector < const Token *@expr7422 > returns@var2684 ; returns@var2684 =@expr1073749247 Function ::@expr1073749248 findReturns (@expr1073749249 f@var2682 ) ;
1063: for (@expr1073749250 const Token *@expr7422 returnTok@var2685 :@expr1073749252 returns@var2684 ) {
1064: if (@expr1073749253 returnTok@var2685 ==@expr1073749254 tok@var2668 ) {
1065: continue ; }
1066: for (@expr1073749255 const ReferenceToken &@expr1073749256 rt@var2686 :@expr1073749257
1067: followAllReferences (@expr1073749258 returnTok@var2685 , temporary@var2669 , inconclusive@var2670 , errors@var2671 , depth@var2672 -@expr7435 returns@var2684 .@expr7436 size (@expr7437 ) ) ) {
1068: const Variable * argvar@var2687 ; argvar@var2687 =@expr1073749262 rt@var2686 .@expr1073749263 token@var2688 .@expr1073749264 variable (@expr1073749265 ) ;
1069: if (@expr1073749266 !@expr1073749267 argvar@var2687 ) {
1070: return {@expr1073749268 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1071: if (@expr1073749271 argvar@var2687 .@expr1073749272 isArgument (@expr1073749273 ) &&@expr1073749274 (@expr1073749275 argvar@var2687 .@expr1073749276 isReference (@expr1073749277 ) ||@expr1073749278 argvar@var2687 .@expr1073749279 isRValueReference (@expr1073749280 ) ) ) {
1072: int n@var2689 ; n@var2689 =@expr1073749281 getArgumentPos (@expr1073749282 argvar@var2687 , f@var2682 ) ;
1073: if (@expr1073749283 n@var2689 <@expr1073749284 0 ) {
1074: return {@expr1073749285 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1075: std ::@expr1073749288 vector < const Token *@expr7422 > args@var2690 ; args@var2690 =@expr1073749290 getArguments (@expr1073749291 tok@var2668 .@expr7405 previous (@expr7406 ) ) ;
1076: if (@expr1073749294 n@var2689 >=@expr1073749295 args@var2690 .@expr1073749296 size (@expr1073749297 ) ) {
1077: return {@expr1073749298 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1078: const Token * argTok@var2691 ; argTok@var2691 =@expr1073749301 args@var2690 [@expr1073749302 n@var2689 ] ;
1079: std ::@expr1073749303 list < std ::@expr7480 pair < const Token *@expr7422 , std ::@expr7480 string > > er@var2692 ; er@var2692 =@expr1073749307 errors@var2671 ;
1080: er@var2692 .@expr7484 emplace_back (@expr1073749309 returnTok@var2685 , "Return reference." ) ;
1081: er@var2692 .@expr7484 emplace_back (@expr1073749311 tok@var2668 .@expr7405 previous (@expr7406 ) , "Called function passing '" +@expr1073749314 argTok@var2691 .@expr1073749315 expressionString (@expr1073749316 ) +@expr1073749317 "'." ) ;
1082: std ::@expr1073749318 vector < ReferenceToken > refs@var2693 ; refs@var2693 =@expr1073749319
1083: followAllReferences (@expr1073749320 argTok@var2691 , temporary@var2669 , inconclusive@var2670 , std ::@expr7259 move (@expr1073749322 er@var2692 ) , depth@var2672 -@expr7435 returns@var2684 .@expr7436 size (@expr7437 ) ) ;
1084: result@var2683 .@expr1073749326 insert (@expr1073749327 refs@var2693 .@expr1073749328 begin (@expr1073749329 ) , refs@var2693 .@expr1073749330 end (@expr1073749331 ) ) ;
1085: if (@expr1073749332 !@expr7384 inconclusive@var2670 &&@expr1073749334 result@var2683 .@expr1073749335 size (@expr1073749336 ) >@expr1073749337 1 ) {
1086: return {@expr1073749338 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ; }
1087: }
1088: }
1089: }
1090: if (@expr1073749341 !@expr1073749342 result@var2683 .@expr1073749343 empty (@expr1073749344 ) ) {
1091: return std ::@expr7254 vector < ReferenceToken > (@expr1073749346 result@var2683 .@expr1073749347 begin (@expr1073749348 ) , result@var2683 .@expr1073749349 end (@expr1073749350 ) ) ; }
1092: }
1093: } } }
1094: return {@expr1073749351 tok@var2668 , std ::@expr7259 move (@expr7260 errors@var2671 ) } ;
1095: }
1096:
1097: const Token * followReferences ( const Token * tok@var2694 , std :: list < std :: pair < const Token * , std :: string > > * errors@var2695 )
1098: {
1099: if (@expr1073749357 !@expr1073749358 tok@var2694 ) {
1100: return nullptr ; }
1101: std ::@expr1073749359 vector < ReferenceToken > refs@var2696 ; refs@var2696 =@expr1073749360 followAllReferences (@expr1073749361 tok@var2694 , true , false ) ;
1102: if (@expr1073749362 refs@var2696 .@expr1073749363 size (@expr1073749364 ) ==@expr1073749365 1 ) {
1103: if (@expr1073749366 errors@var2695 ) {
1104: *@expr1073749367 errors@var2695 =@expr1073749368 refs@var2696 .@expr7545 front (@expr7546 ) .@expr1073749371 errors@var3322 ; }
1105: return refs@var2696 .@expr7545 front (@expr7546 ) .@expr1073749374 token@var3323 ;
1106: }
1107: return nullptr ;
1108: }
1109:
1110: static bool isSameLifetime ( const Token * const tok1@var2697 , const Token * const tok2@var2698 )
1111: {
1112: ValueFlow ::@expr1073749375 Value v1@var2699 ; v1@var2699 =@expr1073749376 getLifetimeObjValue (@expr1073749377 tok1@var2697 ) ;
1113: ValueFlow ::@expr1073749378 Value v2@var2700 ; v2@var2700 =@expr1073749379 getLifetimeObjValue (@expr1073749380 tok2@var2698 ) ;
1114: if (@expr1073749381 !@expr1073749382 v1@var2699 .@expr1073749383 isLifetimeValue (@expr1073749384 ) ||@expr1073749385 !@expr1073749386 v2@var2700 .@expr1073749387 isLifetimeValue (@expr1073749388 ) ) {
1115: return false ; }
1116: return v1@var2699 .@expr1073749389 tokvalue@var2701 ==@expr1073749390 v2@var2700 .@expr1073749391 tokvalue@var2702 ;
1117: }
1118:
1119: static bool compareKnownValue ( const Token * const tok1@var2703 , const Token * const tok2@var2704 , std :: function < bool ( const ValueFlow :: Value & , const ValueFlow :: Value & , bool ) > compare@var2705 )
1120: {
1121: static const auto isKnownFn@var2706 =@expr1073749392 std ::@expr1073749393 mem_fn (@expr1073749394 &@expr1073749395 ValueFlow ::@expr1073749396 Value ::@expr1073749397 isKnown ) ;
1122:
1123: const auto v1@var2707 =@expr1073749398 std ::@expr7575 find_if (@expr1073749400 tok1@var2703 .@expr7577 values (@expr7578 ) .@expr1073749403 begin (@expr1073749404 ) , tok1@var2703 .@expr7577 values (@expr7578 ) .@expr7583 end (@expr7584 ) , isKnownFn@var2706 ) ;
1124: if (@expr1073749409 v1@var2707 ==@expr1073749410 tok1@var2703 .@expr7577 values (@expr7578 ) .@expr7583 end (@expr7584 ) ) {
1125: return false ;
1126: }
1127: if (@expr1073749415 v1@var2707 .@expr1073749416 isNonValue (@expr1073749417 ) ||@expr1073749418 v1@var2707 .@expr1073749419 isContainerSizeValue (@expr1073749420 ) ||@expr1073749421 v1@var2707 .@expr1073749422 isSymbolicValue (@expr1073749423 ) ) {
1128: return false ; }
1129: const auto v2@var2708 =@expr1073749424 std ::@expr7575 find_if (@expr1073749426 tok2@var2704 .@expr7603 values (@expr7604 ) .@expr1073749429 begin (@expr1073749430 ) , tok2@var2704 .@expr7603 values (@expr7604 ) .@expr7609 end (@expr7610 ) , isKnownFn@var2706 ) ;
1130: if (@expr1073749435 v2@var2708 ==@expr1073749436 tok2@var2704 .@expr7603 values (@expr7604 ) .@expr7609 end (@expr7610 ) ) {
1131: return false ;
1132: }
1133: if (@expr1073749441 v1@var2707 .@expr1073749442 valueType@var2709 !=@expr1073749443 v2@var2708 .@expr1073749444 valueType@var2710 ) {
1134: return false ;
1135: }
1136: const bool sameLifetime@var2711 =@expr1073749445 isSameLifetime (@expr1073749446 tok1@var2703 , tok2@var2704 ) ;
1137: return compare@var2705 (@expr1073749447 *@expr1073749448 v1@var2707 , *@expr1073749449 v2@var2708 , sameLifetime@var2711 ) ;
1138: }
1139:
1140: bool isEqualKnownValue ( const Token * const tok1@var2712 , const Token * const tok2@var2713 )
1141: {
1142: return compareKnownValue (@expr1073749450 tok1@var2712 , tok2@var2713 , [@expr1073749451 &@expr7628 ] (@expr1073749453 const ValueFlow ::@expr7630 Value &@expr7628 v1@var2714 , const ValueFlow ::@expr7630 Value &@expr7628 v2@var2715 , bool sameLifetime@var2716 ) {
1143: bool r@var2717 ; r@var2717 =@expr1073749458 v1@var2714 .@expr1073749459 equalValue (@expr1073749460 v2@var2715 ) ;
1144: if (@expr1073749461 v1@var2714 .@expr1073749462 isIteratorValue (@expr1073749463 ) ) {
1145: r@var2717 &=@expr1073749464 sameLifetime@var2716 ;
1146: }
1147: return r@var2717 ;
1148: } ) ;
1149: }
1150:
1151: static bool isDifferentKnownValues ( const Token * const tok1@var2718 , const Token * const tok2@var2719 )
1152: {
1153: return compareKnownValue (@expr1073749465 tok1@var2718 , tok2@var2719 , [@expr1073749466 &@expr7643 ] (@expr1073749468 const ValueFlow ::@expr7645 Value &@expr7643 v1@var2720 , const ValueFlow ::@expr7645 Value &@expr7643 v2@var2721 , bool sameLifetime@var2722 ) {
1154: bool r@var2723 ; r@var2723 =@expr1073749473 v1@var2720 .@expr1073749474 equalValue (@expr1073749475 v2@var2721 ) ;
1155: if (@expr1073749476 v1@var2720 .@expr1073749477 isIteratorValue (@expr1073749478 ) ) {
1156: r@var2723 &=@expr1073749479 sameLifetime@var2722 ;
1157: }
1158: return !@expr1073749480 r@var2723 ;
1159: } ) ;
1160: }
1161:
1162: static bool isSameConstantValue ( bool macro@var2724 , const Token * tok1@var2725 , const Token * tok2@var2726 )
1163: {
1164: if (@expr1073749481 tok1@var2725 ==@expr1073749482 nullptr ||@expr1073749483 tok2@var2726 ==@expr1073749484 nullptr ) {
1165: return false ; }
1166:
1167: auto adjustForCast@var2727 ; adjustForCast@var2727 =@expr1073749485 [@expr1073749486 ] (@expr1073749487 const Token *@expr1073749488 tok@var2728 ) {
1168: if (@expr1073749489 Token ::@expr1073749490 Match (@expr1073749491 tok@var2728 .@expr7668 previous (@expr7669 ) , "%type% (|{" ) &&@expr1073749494 tok@var2728 .@expr7668 previous (@expr7669 ) .@expr1073749497 isStandardType (@expr1073749498 ) &&@expr1073749499 tok@var2728 .@expr7676 astOperand2 (@expr7677 ) ) {
1169: return tok@var2728 .@expr7676 astOperand2 (@expr7677 ) ; }
1170: return tok@var2728 ;
1171: } ;
1172: tok1@var2725 =@expr1073749504 adjustForCast@var2727 (@expr1073749505 tok1@var2725 ) ;
1173: tok2@var2726 =@expr1073749506 adjustForCast@var2727 (@expr1073749507 tok2@var2726 ) ;
1174:
1175: if (@expr1073749508 !@expr1073749509 tok1@var2725 .@expr1073749510 isNumber (@expr1073749511 ) ||@expr1073749512 !@expr1073749513 tok2@var2726 .@expr1073749514 isNumber (@expr1073749515 ) ) {
1176: return false ; }
1177:
1178: if (@expr1073749516 macro@var2724 &&@expr1073749517 (@expr1073749518 tok1@var2725 .@expr1073749519 isExpandedMacro (@expr1073749520 ) ||@expr1073749521 tok2@var2726 .@expr1073749522 isExpandedMacro (@expr1073749523 ) ||@expr1073749524 tok1@var2725 .@expr1073749525 isTemplateArg (@expr1073749526 ) ||@expr1073749527 tok2@var2726 .@expr1073749528 isTemplateArg (@expr1073749529 ) ) ) {
1179: return false ; }
1180:
1181: const ValueType * v1@var2729 ; v1@var2729 =@expr1073749530 tok1@var2725 .@expr1073749531 valueType (@expr1073749532 ) ;
1182: const ValueType * v2@var2730 ; v2@var2730 =@expr1073749533 tok2@var2726 .@expr1073749534 valueType (@expr1073749535 ) ;
1183:
1184: if (@expr1073749536 !@expr1073749537 v1@var2729 ||@expr1073749538 !@expr1073749539 v2@var2730 ||@expr1073749540 v1@var2729 .@expr1073749541 sign@var2731 !=@expr1073749542 v2@var2730 .@expr1073749543 sign@var2732 ||@expr1073749544 v1@var2729 .@expr1073749545 type@var2733 !=@expr1073749546 v2@var2730 .@expr1073749547 type@var2734 ||@expr1073749548 v1@var2729 .@expr1073749549 pointer@var2735 !=@expr1073749550 v2@var2730 .@expr1073749551 pointer@var2736 ) {
1185: return false ; }
1186:
1187: return isEqualKnownValue (@expr1073749552 tok1@var2725 , tok2@var2726 ) ;
1188: }
1189:
1190:
1191: static bool isForLoopCondition ( const Token * const tok@var2737 )
1192: {
1193: if (@expr1073749553 !@expr1073749554 tok@var2737 ) {
1194: return false ; }
1195: const Token * const parent@var2738 ; parent@var2738 =@expr1073749555 tok@var2737 .@expr1073749556 astParent (@expr1073749557 ) ;
1196: return Token ::@expr7734 simpleMatch (@expr1073749559 parent@var2738 , ";" ) &&@expr1073749560 parent@var2738 .@expr1073749561 astOperand1 (@expr1073749562 ) ==@expr1073749563 tok@var2737 &&@expr1073749564
1197: Token ::@expr7734 simpleMatch (@expr1073749566 parent@var2738 .@expr7743 astParent (@expr7744 ) , ";" ) &&@expr1073749569
1198: Token ::@expr7734 simpleMatch (@expr1073749571 parent@var2738 .@expr7743 astParent (@expr7744 ) .@expr7750 astParent (@expr7751 ) , "(" ) &&@expr1073749576
1199: parent@var2738 .@expr7743 astParent (@expr7744 ) .@expr7750 astParent (@expr7751 ) .@expr1073749581 astOperand1 (@expr1073749582 ) .@expr1073749583 str (@expr1073749584 ) ==@expr1073749585 "for" ;
1200: }
1201:
1202: static bool isZeroConstant ( const Token * tok@var2739 )
1203: {
1204: while (@expr1073749586 tok@var2739 &&@expr1073749587 tok@var2739 .@expr1073749588 isCast (@expr1073749589 ) ) {
1205: tok@var2739 =@expr1073749590 tok@var2739 .@expr7767 astOperand2 (@expr7768 ) ?@expr1073749593 tok@var2739 .@expr7767 astOperand2 (@expr7768 ) :@expr1073749596 tok@var2739 .@expr1073749597 astOperand1 (@expr1073749598 ) ; }
1206: return Token ::@expr1073749599 simpleMatch (@expr1073749600 tok@var2739 , "0" ) &&@expr1073749601 !@expr1073749602 tok@var2739 .@expr1073749603 isExpandedMacro (@expr1073749604 ) ;
1207: }
1208:
|
1216:
1217: static bool isUsedAsBool_internal ( const Token * const tok@var2740 , bool checkingParent@var2741 )
1218: {
1219: if (@expr1073749605 !@expr1073749606 tok@var2740 ) {
1220: return false ; }
1221: const Token ::@expr1073749607 Type type@var2742 =@expr1073749608 tok@var2740 .@expr1073749609 tokType (@expr1073749610 ) ;
1222: if (@expr1073749611 type@var2742 ==@expr1073749612 Token ::@expr1073749613 eBitOp ||@expr1073749614 type@var2742 ==@expr1073749615 Token ::@expr1073749616 eIncDecOp ||@expr1073749617 (@expr1073749618 type@var2742 ==@expr1073749619 Token ::@expr1073749620 eArithmeticalOp &&@expr1073749621 !@expr1073749622 tok@var2740 .@expr1073749623 isUnaryOp (@expr1073749624 "*" ) ) ) {
1223:
1224: return false ; }
1225: if (@expr1073749625 type@var2742 ==@expr1073749626 Token ::@expr1073749627 eComparisonOp ) {
1226: if (@expr1073749628 !@expr1073749629 checkingParent@var2741 ) {
1227:
1228: return true ; }
1229: if (@expr1073749630 Token ::@expr7807 Match (@expr1073749632 tok@var2740 , "==|!=" ) ) {
1230: return isZeroConstant (@expr1073749633 tok@var2740 .@expr1073749634 astOperand1 (@expr1073749635 ) ) ||@expr1073749636 isZeroConstant (@expr1073749637 tok@var2740 .@expr1073749638 astOperand2 (@expr1073749639 ) ) ; }
1231: return false ;
1232: }
1233: if (@expr1073749640 type@var2742 ==@expr1073749641 Token ::@expr1073749642 eLogicalOp ) {
1234: return true ; }
1235: if (@expr1073749643 astIsBool (@expr1073749644 tok@var2740 ) ) {
1236: return true ; }
1237:
1238: const Token * const parent@var2743 ; parent@var2743 =@expr1073749645 tok@var2740 .@expr1073749646 astParent (@expr1073749647 ) ;
1239: if (@expr1073749648 !@expr1073749649 parent@var2743 ) {
1240: return false ; }
1241: if (@expr1073749650 parent@var2743 .@expr1073749651 str (@expr1073749652 ) ==@expr1073749653 "(" &&@expr1073749654 parent@var2743 .@expr1073749655 astOperand2 (@expr1073749656 ) ==@expr1073749657 tok@var2740 ) {
1242: if (@expr1073749658 Token ::@expr7807 Match (@expr1073749660 parent@var2743 .@expr1073749661 astOperand1 (@expr1073749662 ) , "if|while" ) ) {
1243: return true ; }
1244:
1245: if (@expr1073749663 !@expr1073749664 parent@var2743 .@expr1073749665 isCast (@expr1073749666 ) ) {
1246:
1247: int argnr@var2744 ;
1248: const Token * const func@var2745 ; func@var2745 =@expr1073749667 getTokenArgumentFunction (@expr1073749668 tok@var2740 , argnr@var2744 ) ;
1249: if (@expr1073749669 !@expr1073749670 func@var2745 ||@expr1073749671 !@expr1073749672 func@var2745 .@expr7849 function (@expr7850 ) ) {
1250: return false ; }
1251: const Variable * var@var2746 ; var@var2746 =@expr1073749675 func@var2745 .@expr7849 function (@expr7850 ) .@expr1073749678 getArgumentVar (@expr1073749679 argnr@var2744 ) ;
1252: return var@var2746 &&@expr1073749680 (@expr1073749681 var@var2746 .@expr1073749682 getTypeName (@expr1073749683 ) ==@expr1073749684 "bool" ) ;
1253: }
1254: } else { if (@expr1073749685 isForLoopCondition (@expr1073749686 tok@var2740 ) ) {
1255: return true ; }
1256: else { if (@expr1073749687 Token ::@expr1073749688 simpleMatch (@expr1073749689 parent@var2743 , "?" ) &&@expr1073749690 astIsLHS (@expr1073749691 tok@var2740 ) ) {
1257: return true ; } } }
1258:
1259: return isUsedAsBool_internal (@expr1073749692 parent@var2743 , true ) ;
1260: }
1261:
1262: bool isUsedAsBool ( const Token * const tok@var2747 )
1263: {
1264: return isUsedAsBool_internal (@expr1073749693 tok@var2747 , false ) ;
1265: }
1266:
1267: static bool astIsBoolLike ( const Token * tok@var2748 )
1268: {
1269: return astIsBool (@expr1073749694 tok@var2748 ) ||@expr1073749695 isUsedAsBool (@expr1073749696 tok@var2748 ) ;
1270: }
1271:
1272: bool isSameExpression ( bool cpp@var2749 , bool macro@var2750 , const Token * tok1@var2751 , const Token * tok2@var2752 , const Library & library@var2753 , bool pure@var2754 , bool followVar@var2755 , std :: list < std :: pair < const Token * , std :: string > > * errors@var2756 )
1273: {
1274: if (@expr1073749697 tok1@var2751 ==@expr7874 nullptr &&@expr1073749699 tok2@var2752 ==@expr7876 nullptr ) {
1275: return true ; }
1276: if (@expr1073749701 tok1@var2751 ==@expr7874 nullptr ||@expr1073749703 tok2@var2752 ==@expr7876 nullptr ) {
1277: return false ; }
1278: if (@expr1073749705 cpp@var2749 ) {
1279: if (@expr1073749706 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073749709 "." &&@expr1073749710 tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) &&@expr1073749713 tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) .@expr1073749716 str (@expr1073749717 ) ==@expr1073749718 "this" ) {
1280: tok1@var2751 =@expr1073749719 tok1@var2751 .@expr7896 astOperand2 (@expr7897 ) ; }
1281: if (@expr1073749722 tok2@var2752 .@expr7899 str (@expr7900 ) ==@expr1073749725 "." &&@expr1073749726 tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) &&@expr1073749729 tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) .@expr1073749732 str (@expr1073749733 ) ==@expr1073749734 "this" ) {
1282: tok2@var2752 =@expr1073749735 tok2@var2752 .@expr7912 astOperand2 (@expr7913 ) ; }
1283: }
1284:
1285: if (@expr1073749738 Token ::@expr7915 simpleMatch (@expr1073749740 tok1@var2751 , "!" ) &&@expr1073749741 Token ::@expr7915 simpleMatch (@expr1073749743 tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) , "!" ) &&@expr1073749746 !@expr1073749747 Token ::@expr7915 simpleMatch (@expr1073749749 tok1@var2751 .@expr1073749750 astParent (@expr1073749751 ) , "=" ) ) {
1286: return isSameExpression (@expr1073749752 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) .@expr1073749755 astOperand1 (@expr1073749756 ) , tok2@var2752 , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1287: }
1288: if (@expr1073749757 Token ::@expr7915 simpleMatch (@expr1073749759 tok2@var2752 , "!" ) &&@expr1073749760 Token ::@expr7915 simpleMatch (@expr1073749762 tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) , "!" ) &&@expr1073749765 !@expr1073749766 Token ::@expr7915 simpleMatch (@expr1073749768 tok2@var2752 .@expr1073749769 astParent (@expr1073749770 ) , "=" ) ) {
1289: return isSameExpression (@expr1073749771 cpp@var2749 , macro@var2750 , tok1@var2751 , tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) .@expr1073749774 astOperand1 (@expr1073749775 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1290: }
1291: const bool tok_str_eq@var2757 =@expr1073749776 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073749779 tok2@var2752 .@expr7899 str (@expr7900 ) ;
1292: if (@expr1073749782 !@expr7959 tok_str_eq@var2757 &&@expr1073749784 isDifferentKnownValues (@expr1073749785 tok1@var2751 , tok2@var2752 ) ) {
1293: return false ; }
1294: if (@expr1073749786 isSameConstantValue (@expr1073749787 macro@var2750 , tok1@var2751 , tok2@var2752 ) ) {
1295: return true ; }
1296:
1297:
1298: if (@expr1073749788 followVar@var2755 &&@expr1073749789 !@expr7959 tok_str_eq@var2757 &&@expr1073749791 (@expr1073749792 Token ::@expr7969 Match (@expr1073749794 tok1@var2751 , "%var%" ) ||@expr1073749795 Token ::@expr7969 Match (@expr1073749797 tok2@var2752 , "%var%" ) ) ) {
1299: const Token * varTok1@var2758 ; varTok1@var2758 =@expr1073749798 followVariableExpression (@expr1073749799 tok1@var2751 , cpp@var2749 , tok2@var2752 ) ;
1300: if (@expr1073749800 (@expr1073749801 varTok1@var2758 .@expr7978 str (@expr7979 ) ==@expr1073749804 tok2@var2752 .@expr7899 str (@expr7900 ) ) ||@expr1073749807 isSameConstantValue (@expr1073749808 macro@var2750 , varTok1@var2758 , tok2@var2752 ) ) {
1301: followVariableExpressionError (@expr7985 tok1@var2751 , varTok1@var2758 , errors@var2756 ) ;
1302: return isSameExpression (@expr1073749810 cpp@var2749 , macro@var2750 , varTok1@var2758 , tok2@var2752 , library@var2753 , true , followVar@var2755 , errors@var2756 ) ;
1303: }
1304: const Token * varTok2@var2759 ; varTok2@var2759 =@expr1073749811 followVariableExpression (@expr1073749812 tok2@var2752 , cpp@var2749 , tok1@var2751 ) ;
1305: if (@expr1073749813 (@expr1073749814 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073749817 varTok2@var2759 .@expr7994 str (@expr7995 ) ) ||@expr1073749820 isSameConstantValue (@expr1073749821 macro@var2750 , tok1@var2751 , varTok2@var2759 ) ) {
1306: followVariableExpressionError (@expr7998 tok2@var2752 , varTok2@var2759 , errors@var2756 ) ;
1307: return isSameExpression (@expr1073749823 cpp@var2749 , macro@var2750 , tok1@var2751 , varTok2@var2759 , library@var2753 , true , followVar@var2755 , errors@var2756 ) ;
1308: }
1309: if (@expr1073749824 (@expr1073749825 varTok1@var2758 .@expr7978 str (@expr7979 ) ==@expr1073749828 varTok2@var2759 .@expr7994 str (@expr7995 ) ) ||@expr1073749831 isSameConstantValue (@expr1073749832 macro@var2750 , varTok1@var2758 , varTok2@var2759 ) ) {
1310: followVariableExpressionError (@expr7985 tok1@var2751 , varTok1@var2758 , errors@var2756 ) ;
1311: followVariableExpressionError (@expr7998 tok2@var2752 , varTok2@var2759 , errors@var2756 ) ;
1312: return isSameExpression (@expr1073749835 cpp@var2749 , macro@var2750 , varTok1@var2758 , varTok2@var2759 , library@var2753 , true , followVar@var2755 , errors@var2756 ) ;
1313: }
1314: }
1315:
1316: if (@expr1073749836 !@expr7959 tok_str_eq@var2757 ) {
1317: const Token * refTok1@var2760 ; refTok1@var2760 =@expr1073749838 followReferences (@expr1073749839 tok1@var2751 , errors@var2756 ) ;
1318: const Token * refTok2@var2761 ; refTok2@var2761 =@expr1073749840 followReferences (@expr1073749841 tok2@var2752 , errors@var2756 ) ;
1319: if (@expr1073749842 refTok1@var2760 !=@expr1073749843 tok1@var2751 ||@expr1073749844 refTok2@var2761 !=@expr1073749845 tok2@var2752 ) {
1320: return isSameExpression (@expr1073749846 cpp@var2749 , macro@var2750 , refTok1@var2760 , refTok2@var2761 , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ; }
1321: }
1322: if (@expr1073749847 tok1@var2751 .@expr1073749848 varId (@expr1073749849 ) !=@expr1073749850 tok2@var2752 .@expr1073749851 varId (@expr1073749852 ) ||@expr1073749853 !@expr7959 tok_str_eq@var2757 ||@expr1073749855 tok1@var2751 .@expr1073749856 originalName (@expr1073749857 ) !=@expr1073749858 tok2@var2752 .@expr1073749859 originalName (@expr1073749860 ) ) {
1323: if (@expr1073749861 (@expr1073749862 Token ::@expr7969 Match (@expr1073749864 tok1@var2751 , "<|>" ) &&@expr1073749865 Token ::@expr7969 Match (@expr1073749867 tok2@var2752 , "<|>" ) ) ||@expr1073749868
1324: (@expr1073749869 Token ::@expr7969 Match (@expr1073749871 tok1@var2751 , "<=|>=" ) &&@expr1073749872 Token ::@expr7969 Match (@expr1073749874 tok2@var2752 , "<=|>=" ) ) ) {
1325: return isSameExpression (@expr8051 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) , tok2@var2752 .@expr7912 astOperand2 (@expr7913 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) &&@expr1073749880
1326: isSameExpression (@expr8057 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7896 astOperand2 (@expr7897 ) , tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1327: }
1328: const Token * condTok@var2762 ; condTok@var2762 =@expr1073749886 nullptr ;
1329: const Token * exprTok@var2763 ; exprTok@var2763 =@expr1073749887 nullptr ;
1330: if (@expr1073749888 Token ::@expr7969 Match (@expr1073749890 tok1@var2751 , "==|!=" ) ) {
1331: condTok@var2762 =@expr1073749891 tok1@var2751 ;
1332: exprTok@var2763 =@expr1073749892 tok2@var2752 ;
1333: } else { if (@expr1073749893 Token ::@expr7969 Match (@expr1073749895 tok2@var2752 , "==|!=" ) ) {
1334: condTok@var2762 =@expr1073749896 tok2@var2752 ;
1335: exprTok@var2763 =@expr1073749897 tok1@var2751 ;
1336: } }
1337: if (@expr1073749898 condTok@var2762 &&@expr1073749899 condTok@var2762 .@expr8076 astOperand1 (@expr8077 ) &&@expr1073749902 condTok@var2762 .@expr8079 astOperand2 (@expr8080 ) &&@expr1073749905 !@expr1073749906 Token ::@expr7969 Match (@expr1073749908 exprTok@var2763 , "%comp%" ) ) {
1338: const Token * varTok1@var2764 ; varTok1@var2764 =@expr1073749909 nullptr ;
1339: const Token * varTok2@var2765 ; varTok2@var2765 =@expr1073749910 exprTok@var2763 ;
1340: const ValueFlow ::@expr1073749911 Value * value@var2766 ; value@var2766 =@expr1073749912 nullptr ;
1341: if (@expr1073749913 condTok@var2762 .@expr8076 astOperand1 (@expr8077 ) .@expr1073749916 hasKnownIntValue (@expr1073749917 ) ) {
1342: value@var2766 =@expr1073749918 &@expr1073749919 condTok@var2762 .@expr8076 astOperand1 (@expr8077 ) .@expr1073749922 values (@expr1073749923 ) .@expr1073749924 front (@expr1073749925 ) ;
1343: varTok1@var2764 =@expr1073749926 condTok@var2762 .@expr8079 astOperand2 (@expr8080 ) ;
1344: } else { if (@expr1073749929 condTok@var2762 .@expr8079 astOperand2 (@expr8080 ) .@expr1073749932 hasKnownIntValue (@expr1073749933 ) ) {
1345: value@var2766 =@expr1073749934 &@expr1073749935 condTok@var2762 .@expr8079 astOperand2 (@expr8080 ) .@expr1073749938 values (@expr1073749939 ) .@expr1073749940 front (@expr1073749941 ) ;
1346: varTok1@var2764 =@expr1073749942 condTok@var2762 .@expr8076 astOperand1 (@expr8077 ) ;
1347: } }
1348: if (@expr1073749945 Token ::@expr7915 simpleMatch (@expr8123 exprTok@var2763 , "!" ) ) {
1349: varTok2@var2765 =@expr1073749948 exprTok@var2763 .@expr1073749949 astOperand1 (@expr1073749950 ) ; }
1350: bool compare@var2767 ; compare@var2767 =@expr1073749951 false ;
1351: if (@expr1073749952 value@var2766 ) {
1352: if (@expr1073749953 value@var2766 .@expr8130 intvalue@var2768 ==@expr8131 0 &&@expr1073749956 Token ::@expr7915 simpleMatch (@expr8123 exprTok@var2763 , "!" ) &&@expr1073749959 Token ::@expr7915 simpleMatch (@expr8137 condTok@var2762 , "==" ) ) {
1353: compare@var2767 =@expr1073749962 true ;
1354: } else { if (@expr1073749963 value@var2766 .@expr8130 intvalue@var2768 ==@expr8131 0 &&@expr1073749966 !@expr8143 Token ::@expr7915 simpleMatch (@expr8123 exprTok@var2763 , "!" ) &&@expr1073749970 Token ::@expr7915 simpleMatch (@expr8148 condTok@var2762 , "!=" ) ) {
1355: compare@var2767 =@expr1073749973 true ;
1356: } else { if (@expr1073749974 value@var2766 .@expr8130 intvalue@var2768 !=@expr8152 0 &&@expr1073749977 Token ::@expr7915 simpleMatch (@expr8123 exprTok@var2763 , "!" ) &&@expr1073749980 Token ::@expr7915 simpleMatch (@expr8148 condTok@var2762 , "!=" ) ) {
1357: compare@var2767 =@expr1073749983 true ;
1358: } else { if (@expr1073749984 value@var2766 .@expr8130 intvalue@var2768 !=@expr8152 0 &&@expr1073749987 !@expr8143 Token ::@expr7915 simpleMatch (@expr8123 exprTok@var2763 , "!" ) &&@expr1073749991 Token ::@expr7915 simpleMatch (@expr8137 condTok@var2762 , "==" ) ) {
1359: compare@var2767 =@expr1073749994 true ;
1360: } } } }
1361:
1362: }
1363: if (@expr1073749995 compare@var2767 &&@expr1073749996 astIsBoolLike (@expr1073749997 varTok1@var2764 ) &&@expr1073749998 astIsBoolLike (@expr1073749999 varTok2@var2765 ) ) {
1364: return isSameExpression (@expr1073750000 cpp@var2749 , macro@var2750 , varTok1@var2764 , varTok2@var2765 , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ; }
1365:
1366: }
1367: return false ;
1368: }
1369: auto flagsDiffer@var2769 ; flagsDiffer@var2769 =@expr1073750001 [@expr1073750002 ] (@expr1073750003 const Token *@expr8180 tok1@var2770 , const Token *@expr8180 tok2@var2771 , bool macro@var2772 ) {
1370: if (@expr1073750006 macro@var2772 &&@expr1073750007 (@expr1073750008 tok1@var2770 .@expr1073750009 isExpandedMacro (@expr1073750010 ) ||@expr1073750011 tok2@var2771 .@expr1073750012 isExpandedMacro (@expr1073750013 ) ||@expr1073750014 tok1@var2770 .@expr1073750015 isTemplateArg (@expr1073750016 ) ||@expr1073750017 tok2@var2771 .@expr1073750018 isTemplateArg (@expr1073750019 ) ) ) {
1371: return true ; }
1372: if (@expr1073750020 tok1@var2770 .@expr1073750021 isComplex (@expr1073750022 ) !=@expr1073750023 tok2@var2771 .@expr1073750024 isComplex (@expr1073750025 ) ) {
1373: return true ; }
1374: if (@expr1073750026 tok1@var2770 .@expr1073750027 isLong (@expr1073750028 ) !=@expr1073750029 tok2@var2771 .@expr1073750030 isLong (@expr1073750031 ) ) {
1375: return true ; }
1376: if (@expr1073750032 tok1@var2770 .@expr1073750033 isUnsigned (@expr1073750034 ) !=@expr1073750035 tok2@var2771 .@expr1073750036 isUnsigned (@expr1073750037 ) ) {
1377: return true ; }
1378: if (@expr1073750038 tok1@var2770 .@expr1073750039 isSigned (@expr1073750040 ) !=@expr1073750041 tok2@var2771 .@expr1073750042 isSigned (@expr1073750043 ) ) {
1379: return true ; }
1380: return false ;
1381: } ;
1382: if (@expr1073750044 flagsDiffer@var2769 (@expr1073750045 tok1@var2751 , tok2@var2752 , macro@var2750 ) ) {
1383: return false ; }
1384:
1385: if (@expr1073750046 pure@var2754 &&@expr1073750047 tok1@var2751 .@expr1073750048 isName (@expr1073750049 ) &&@expr1073750050 tok1@var2751 .@expr8227 next (@expr8228 ) .@expr1073750053 str (@expr1073750054 ) ==@expr1073750055 "(" &&@expr1073750056 tok1@var2751 .@expr7883 str (@expr7884 ) !=@expr1073750059 "sizeof" &&@expr1073750060 !@expr1073750061 (@expr1073750062 tok1@var2751 .@expr8239 variable (@expr8240 ) &&@expr1073750065 tok1@var2751 ==@expr1073750066 tok1@var2751 .@expr8239 variable (@expr8240 ) .@expr1073750069 nameToken (@expr1073750070 ) ) ) {
1386: if (@expr1073750071 !@expr1073750072 tok1@var2751 .@expr8249 function (@expr8250 ) ) {
1387: if (@expr1073750075 Token ::@expr7915 simpleMatch (@expr1073750077 tok1@var2751 .@expr8254 previous (@expr8255 ) , "." ) ) {
1388: const Token * lhs@var2773 ; lhs@var2773 =@expr1073750080 tok1@var2751 .@expr8254 previous (@expr8255 ) ;
1389: while (@expr1073750083 Token ::@expr7969 Match (@expr1073750085 lhs@var2773 , "(|.|[" ) ) {
1390: lhs@var2773 =@expr1073750086 lhs@var2773 .@expr1073750087 astOperand1 (@expr1073750088 ) ; }
1391: if (@expr1073750089 !@expr1073750090 lhs@var2773 ) {
1392: return false ; }
1393: const bool lhsIsConst@var2774 =@expr1073750091 (@expr1073750092 lhs@var2773 .@expr8269 variable (@expr8270 ) &&@expr1073750095 lhs@var2773 .@expr8269 variable (@expr8270 ) .@expr1073750098 isConst (@expr1073750099 ) ) ||@expr1073750100
1394: (@expr1073750101 lhs@var2773 .@expr8278 valueType (@expr8279 ) &&@expr1073750104 lhs@var2773 .@expr8278 valueType (@expr8279 ) .@expr1073750107 constness@var3324 >@expr1073750108 0 ) ||@expr1073750109
1395: (@expr1073750110 Token ::@expr7969 Match (@expr1073750112 lhs@var2773 , "%var% . %name% (" ) &&@expr1073750113 library@var2753 .@expr8290 isFunctionConst (@expr1073750115 lhs@var2773 .@expr1073750116 tokAt (@expr1073750117 2 ) ) ) ;
1396: if (@expr1073750118 !@expr1073750119 lhsIsConst@var2774 ) {
1397: return false ; }
1398: } else {
1399: const Token * ftok@var2775 ; ftok@var2775 =@expr1073750120 tok1@var2751 ;
1400: if (@expr1073750121 Token ::@expr7915 simpleMatch (@expr1073750123 tok1@var2751 .@expr8254 previous (@expr8255 ) , "::" ) ) {
1401: ftok@var2775 =@expr1073750126 tok1@var2751 .@expr8254 previous (@expr8255 ) ; }
1402: if (@expr1073750129 !@expr1073750130 library@var2753 .@expr8290 isFunctionConst (@expr1073750132 ftok@var2775 ) &&@expr1073750133 !@expr1073750134 ftok@var2775 .@expr1073750135 isAttributeConst (@expr1073750136 ) &&@expr1073750137 !@expr1073750138 ftok@var2775 .@expr1073750139 isAttributePure (@expr1073750140 ) ) {
1403: return false ; }
1404: }
1405: } else {
1406: if (@expr1073750141 tok1@var2751 .@expr8249 function (@expr8250 ) &&@expr1073750144 !@expr1073750145 tok1@var2751 .@expr8249 function (@expr8250 ) .@expr8324 isConst (@expr8325 ) &&@expr1073750150 !@expr1073750151 tok1@var2751 .@expr8249 function (@expr8250 ) .@expr1073750154 isAttributeConst (@expr1073750155 ) &&@expr1073750156 !@expr1073750157 tok1@var2751 .@expr8249 function (@expr8250 ) .@expr1073750160 isAttributePure (@expr1073750161 ) ) {
1407: return false ; }
1408: }
1409: }
1410:
1411: if (@expr1073750162 (@expr1073750163 Token ::@expr7969 Match (@expr1073750165 tok1@var2751 , "%name% <" ) &&@expr1073750166 tok1@var2751 .@expr8227 next (@expr8228 ) .@expr8345 link (@expr8346 ) ) ||@expr1073750171
1412: (@expr1073750172 Token ::@expr7969 Match (@expr1073750174 tok2@var2752 , "%name% <" ) &&@expr1073750175 tok2@var2752 .@expr8352 next (@expr8353 ) .@expr1073750178 link (@expr1073750179 ) ) ) {
1413:
1414:
1415: if (@expr1073750180 pure@var2754 &&@expr1073750181 Token ::@expr7915 simpleMatch (@expr1073750183 tok1@var2751 .@expr8227 next (@expr8228 ) .@expr8345 link (@expr8346 ) , "> (" ) &&@expr1073750188
1416: !@expr1073750189 (@expr1073750190 tok1@var2751 .@expr8249 function (@expr8250 ) &&@expr1073750193 tok1@var2751 .@expr8249 function (@expr8250 ) .@expr8324 isConst (@expr8325 ) ) &&@expr1073750198
1417: tok1@var2751 .@expr7883 str (@expr7884 ) !=@expr1073750201 "dynamic_cast" ) {
1418: return false ; }
1419:
1420:
1421: const Token * t1@var2776 ; t1@var2776 =@expr1073750202 tok1@var2751 .@expr8227 next (@expr8228 ) ;
1422: const Token * t2@var2777 ; t2@var2777 =@expr1073750205 tok2@var2752 .@expr8352 next (@expr8353 ) ;
1423: const Token * end1@var2778 ; end1@var2778 =@expr1073750208 t1@var2776 .@expr1073750209 link (@expr1073750210 ) ;
1424: const Token * end2@var2779 ; end2@var2779 =@expr1073750211 t2@var2777 .@expr1073750212 link (@expr1073750213 ) ;
1425: while (@expr1073750214 t1@var2776 &&@expr1073750215 t2@var2777 &&@expr1073750216 t1@var2776 !=@expr8393 end1@var2778 &&@expr1073750218 t2@var2777 !=@expr8395 end2@var2779 ) {
1426: if (@expr1073750220 t1@var2776 .@expr1073750221 str (@expr1073750222 ) !=@expr1073750223 t2@var2777 .@expr1073750224 str (@expr1073750225 ) ||@expr1073750226 flagsDiffer@var2769 (@expr1073750227 t1@var2776 , t2@var2777 , macro@var2750 ) ) {
1427: return false ; }
1428: t1@var2776 =@expr1073750228 t1@var2776 .@expr1073750229 next (@expr1073750230 ) ;
1429: t2@var2777 =@expr1073750231 t2@var2777 .@expr1073750232 next (@expr1073750233 ) ;
1430: }
1431: if (@expr1073750234 t1@var2776 !=@expr8393 end1@var2778 ||@expr1073750236 t2@var2777 !=@expr8395 end2@var2779 ) {
1432: return false ; }
1433: }
1434: if (@expr1073750238 tok1@var2751 .@expr1073750239 tokType (@expr1073750240 ) ==@expr1073750241 Token ::@expr1073750242 eIncDecOp ||@expr1073750243 tok1@var2751 .@expr1073750244 isAssignmentOp (@expr1073750245 ) ) {
1435: return false ; }
1436:
1437: if (@expr1073750246 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073750249 "{" ) {
1438: return false ; }
1439:
1440: if (@expr1073750250 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073750253 "(" &&@expr1073750254 tok1@var2751 .@expr8254 previous (@expr8255 ) &&@expr1073750257
1441: !@expr1073750258 tok1@var2751 .@expr8254 previous (@expr8255 ) .@expr1073750261 isName (@expr1073750262 ) &&@expr1073750263
1442: !@expr1073750264 (@expr1073750265 tok1@var2751 .@expr8254 previous (@expr8255 ) .@expr1073750268 str (@expr1073750269 ) ==@expr1073750270 ">" &&@expr1073750271 tok1@var2751 .@expr8254 previous (@expr8255 ) .@expr1073750274 link (@expr1073750275 ) ) ) {
1443: const Token * t1@var2780 ; t1@var2780 =@expr1073750276 tok1@var2751 .@expr8227 next (@expr8228 ) ;
1444: const Token * t2@var2781 ; t2@var2781 =@expr1073750279 tok2@var2752 .@expr8352 next (@expr8353 ) ;
1445: while (@expr1073750282 t1@var2780 &&@expr1073750283 t2@var2781 &&@expr1073750284
1446: t1@var2780 .@expr8461 str (@expr8462 ) ==@expr1073750287 t2@var2781 .@expr8464 str (@expr8465 ) &&@expr1073750290
1447: !@expr1073750291 flagsDiffer@var2769 (@expr1073750292 t1@var2780 , t2@var2781 , macro@var2750 ) &&@expr1073750293
1448: (@expr1073750294 t1@var2780 .@expr1073750295 isName (@expr1073750296 ) ||@expr1073750297 t1@var2780 .@expr8461 str (@expr8462 ) ==@expr1073750300 "*" ) ) {
1449: t1@var2780 =@expr1073750301 t1@var2780 .@expr1073750302 next (@expr1073750303 ) ;
1450: t2@var2781 =@expr1073750304 t2@var2781 .@expr1073750305 next (@expr1073750306 ) ;
1451: }
1452: if (@expr1073750307 !@expr1073750308 t1@var2780 ||@expr1073750309 !@expr1073750310 t2@var2781 ||@expr1073750311 t1@var2780 .@expr8461 str (@expr8462 ) !=@expr1073750314 ")" ||@expr1073750315 t2@var2781 .@expr8464 str (@expr8465 ) !=@expr1073750318 ")" ) {
1453: return false ; }
1454: }
1455: bool noncommutativeEquals@var2782 ; noncommutativeEquals@var2782 =@expr1073750319
1456: isSameExpression (@expr1073750320 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) , tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1457: noncommutativeEquals@var2782 =@expr1073750325 noncommutativeEquals@var2782 &&@expr1073750326
1458: isSameExpression (@expr1073750327 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7896 astOperand2 (@expr7897 ) , tok2@var2752 .@expr7912 astOperand2 (@expr7913 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1459:
1460: if (@expr1073750332 noncommutativeEquals@var2782 ) {
1461: return true ; }
1462:
1463:
1464: if (@expr1073750333 cpp@var2749 &&@expr1073750334 tok1@var2751 .@expr7883 str (@expr7884 ) ==@expr1073750337 "+" &&@expr1073750338 tok1@var2751 .@expr8515 isBinaryOp (@expr8516 ) ) {
1465: const ValueType * vt1@var2783 ; vt1@var2783 =@expr1073750341 tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) .@expr1073750344 valueType (@expr1073750345 ) ;
1466: const ValueType * vt2@var2784 ; vt2@var2784 =@expr1073750346 tok1@var2751 .@expr7896 astOperand2 (@expr7897 ) .@expr1073750349 valueType (@expr1073750350 ) ;
1467: if (@expr1073750351 !@expr1073750352 (@expr1073750353 vt1@var2783 &&@expr1073750354 (@expr1073750355 vt1@var2783 .@expr1073750356 type@var2785 >=@expr1073750357 ValueType ::@expr8534 VOID ||@expr1073750359 vt1@var2783 .@expr1073750360 pointer@var2786 ) &&@expr1073750361 vt2@var2784 &&@expr1073750362 (@expr1073750363 vt2@var2784 .@expr1073750364 type@var2787 >=@expr1073750365 ValueType ::@expr8534 VOID ||@expr1073750367 vt2@var2784 .@expr1073750368 pointer@var2788 ) ) ) {
1468: return false ; }
1469: }
1470:
1471: const bool commutative@var2789 =@expr1073750369 tok1@var2751 .@expr8515 isBinaryOp (@expr8516 ) &&@expr1073750372 Token ::@expr7969 Match (@expr1073750374 tok1@var2751 , "%or%|%oror%|+|*|&|&&|^|==|!=" ) ;
1472: bool commutativeEquals@var2790 ; commutativeEquals@var2790 =@expr1073750375 commutative@var2789 &&@expr1073750376
1473: isSameExpression (@expr8057 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7896 astOperand2 (@expr7897 ) , tok2@var2752 .@expr7903 astOperand1 (@expr7904 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1474: commutativeEquals@var2790 =@expr1073750382 commutativeEquals@var2790 &&@expr1073750383
1475: isSameExpression (@expr8051 cpp@var2749 , macro@var2750 , tok1@var2751 .@expr7887 astOperand1 (@expr7888 ) , tok2@var2752 .@expr7912 astOperand2 (@expr7913 ) , library@var2753 , pure@var2754 , followVar@var2755 , errors@var2756 ) ;
1476:
1477:
1478: return commutativeEquals@var2790 ;
1479: }
1480:
1481: static bool isZeroBoundCond ( const Token * const cond@var2791 )
1482: {
1483: if (@expr1073750389 cond@var2791 ==@expr1073750390 nullptr ) {
1484: return false ; }
1485:
1486:
1487: const bool isZero@var2792 =@expr1073750391 cond@var2791 .@expr1073750392 astOperand2 (@expr1073750393 ) .@expr1073750394 getValue (@expr1073750395 0 ) ;
1488: if (@expr1073750396 cond@var2791 .@expr8573 str (@expr8574 ) ==@expr1073750399 "==" ||@expr1073750400 cond@var2791 .@expr8573 str (@expr8574 ) ==@expr1073750403 ">=" ) {
1489: return isZero@var2792 ; }
1490: if (@expr1073750404 cond@var2791 .@expr8573 str (@expr8574 ) ==@expr1073750407 "<=" ) {
1491: return true ; }
1492: if (@expr1073750408 cond@var2791 .@expr8573 str (@expr8574 ) ==@expr1073750411 "<" ) {
1493: return !@expr1073750412 isZero@var2792 ; }
1494: if (@expr1073750413 cond@var2791 .@expr8573 str (@expr8574 ) ==@expr1073750416 ">" ) {
1495: return false ; }
1496: return false ;
1497: }
1498:
1499: bool isOppositeCond ( bool isNot@var2793 , bool cpp@var2794 , const Token * const cond1@var2795 , const Token * const cond2@var2796 , const Library & library@var2797 , bool pure@var2798 , bool followVar@var2799 , std :: list < std :: pair < const Token * , std :: string > > * errors@var2800 )
1500: {
1501: if (@expr1073750417 !@expr1073750418 cond1@var2795 ||@expr1073750419 !@expr1073750420 cond2@var2796 ) {
1502: return false ; }
1503:
1504: if (@expr1073750421 !@expr8598 isNot@var2793 &&@expr1073750423 cond1@var2795 .@expr8600 str (@expr8601 ) ==@expr1073750426 "&&" &&@expr1073750427 cond2@var2796 .@expr8604 str (@expr8605 ) ==@expr1073750430 "&&" ) {
1505: for (@expr1073750431 const Token *@expr8608 tok1@var2801 :@expr1073750433 {@expr1073750434
1506: cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond1@var2795 .@expr8613 astOperand2 (@expr8614 )
1507: } ) {
1508: for (@expr1073750439 const Token *@expr8608 tok2@var2802 :@expr1073750441 {@expr1073750442
1509: cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 )
1510: } ) {
1511: if (@expr1073750447 isSameExpression (@expr1073750448 cpp@var2794 , true , tok1@var2801 , tok2@var2802 , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1512: if (@expr1073750449 isOppositeCond (@expr1073750450 isNot@var2793 , cpp@var2794 , tok1@var2801 .@expr1073750451 astSibling (@expr1073750452 ) , tok2@var2802 .@expr1073750453 astSibling (@expr1073750454 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1513: return true ; }
1514: }
1515: }
1516: }
1517: }
1518:
1519: if (@expr1073750455 cond1@var2795 .@expr8600 str (@expr8601 ) ==@expr1073750458 "!" ) {
1520: if (@expr1073750459 cond2@var2796 .@expr8604 str (@expr8605 ) ==@expr1073750462 "!=" ) {
1521: if (@expr1073750463 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) &&@expr1073750466 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) .@expr1073750469 str (@expr1073750470 ) ==@expr1073750471 "0" ) {
1522: return isSameExpression (@expr8648 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ; }
1523: if (@expr1073750477 cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) &&@expr1073750480 cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) .@expr1073750483 str (@expr1073750484 ) ==@expr1073750485 "0" ) {
1524: return isSameExpression (@expr8662 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ; }
1525: }
1526: if (@expr1073750491 !@expr1073750492 isUsedAsBool (@expr1073750493 cond2@var2796 ) ) {
1527: return false ; }
1528: return isSameExpression (@expr1073750494 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ;
1529: }
1530:
1531: if (@expr1073750497 cond2@var2796 .@expr8604 str (@expr8605 ) ==@expr1073750500 "!" ) {
1532: return isOppositeCond (@expr1073750501 isNot@var2793 , cpp@var2794 , cond2@var2796 , cond1@var2795 , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ; }
1533:
1534: if (@expr1073750502 !@expr8598 isNot@var2793 ) {
1535: if (@expr1073750504 cond1@var2795 .@expr8600 str (@expr8601 ) ==@expr8683 "==" &&@expr1073750508 cond2@var2796 .@expr8604 str (@expr8605 ) ==@expr1073750511 "==" ) {
1536: if (@expr1073750512 isSameExpression (@expr8662 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1537: return isDifferentKnownValues (@expr1073750518 cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) ) ; }
1538: if (@expr1073750523 isSameExpression (@expr8700 cpp@var2794 , true , cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1539: return isDifferentKnownValues (@expr1073750529 cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) ) ; }
1540: }
1541:
1542: if (@expr1073750534 Library ::@expr8711 isContainerYield (@expr1073750536 cond1@var2795 , Library ::@expr8713 Container ::@expr8714 Yield ::@expr8715 EMPTY , "empty" ) &&@expr1073750540
1543: Library ::@expr8711 isContainerYield (@expr1073750542 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , Library ::@expr8713 Container ::@expr8714 Yield ::@expr8723 SIZE , "size" ) &&@expr1073750548
1544: isSameExpression (@expr1073750549 cpp@var2794 ,
1545: true ,
1546: cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) .@expr8728 astOperand1 (@expr8729 ) ,
1547: cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) .@expr8732 astOperand1 (@expr8733 ) .@expr1073750558 astOperand1 (@expr1073750559 ) ,
1548: library@var2797 ,
1549: pure@var2798 ,
1550: followVar@var2799 ,
1551: errors@var2800 ) ) {
1552: return !@expr1073750560 isZeroBoundCond (@expr1073750561 cond2@var2796 ) ;
1553: }
1554:
1555: if (@expr1073750562 Library ::@expr8711 isContainerYield (@expr1073750564 cond2@var2796 , Library ::@expr8713 Container ::@expr8714 Yield ::@expr8715 EMPTY , "empty" ) &&@expr1073750568
1556: Library ::@expr8711 isContainerYield (@expr1073750570 cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , Library ::@expr8713 Container ::@expr8714 Yield ::@expr8723 SIZE , "size" ) &&@expr1073750576
1557: isSameExpression (@expr1073750577 cpp@var2794 ,
1558: true ,
1559: cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) .@expr8732 astOperand1 (@expr8733 ) ,
1560: cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) .@expr8728 astOperand1 (@expr8729 ) .@expr1073750586 astOperand1 (@expr1073750587 ) ,
1561: library@var2797 ,
1562: pure@var2798 ,
1563: followVar@var2799 ,
1564: errors@var2800 ) ) {
1565: return !@expr1073750588 isZeroBoundCond (@expr1073750589 cond1@var2795 ) ;
1566: }
1567: }
1568:
1569:
1570: if (@expr1073750590 !@expr1073750591 cond1@var2795 .@expr1073750592 isComparisonOp (@expr1073750593 ) ||@expr1073750594 !@expr1073750595 cond2@var2796 .@expr1073750596 isComparisonOp (@expr1073750597 ) ) {
1571: return false ; }
1572:
1573: const std ::@expr8774 string &@expr8775 comp1@var2803 =@expr1073750600 cond1@var2795 .@expr8600 str (@expr8601 ) ;
1574:
1575:
1576: std ::@expr1073750603 string comp2@var2804 ;
1577: if (@expr1073750604 isSameExpression (@expr8662 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) &&@expr1073750610
1578: isSameExpression (@expr8700 cpp@var2794 , true , cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1579: comp2@var2804 =@expr1073750616 cond2@var2796 .@expr8604 str (@expr8605 ) ;
1580: } else { if (@expr1073750619 isSameExpression (@expr8648 cpp@var2794 , true , cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) , cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) &&@expr1073750625
1581: isSameExpression (@expr1073750626 cpp@var2794 , true , cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) , cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1582: comp2@var2804 =@expr1073750631 cond2@var2796 .@expr8604 str (@expr8605 ) ;
1583: if (@expr1073750634 comp2@var2804 [@expr8811 0 ] ==@expr1073750636 '>' ) {
1584: comp2@var2804 [@expr8811 0 ] =@expr1073750638 '<' ; }
1585: else { if (@expr1073750639 comp2@var2804 [@expr8811 0 ] ==@expr1073750641 '<' ) {
1586: comp2@var2804 [@expr8811 0 ] =@expr1073750643 '>' ; } }
1587: } }
1588:
1589: if (@expr1073750644 !@expr8598 isNot@var2793 &&@expr1073750646 comp2@var2804 .@expr1073750647 empty (@expr1073750648 ) ) {
1590: const Token * expr1@var2805 ; expr1@var2805 =@expr1073750649 nullptr ; const Token * value1@var2806 ; value1@var2806 =@expr1073750650 nullptr ; const Token * expr2@var2807 ; expr2@var2807 =@expr1073750651 nullptr ; const Token * value2@var2808 ; value2@var2808 =@expr1073750652 nullptr ;
1591: std ::@expr1073750653 string op1@var2809 ; op1@var2809 =@expr1073750654 cond1@var2795 .@expr8600 str (@expr8601 ) ; std ::@expr1073750657 string op2@var2810 ; op2@var2810 =@expr1073750658 cond2@var2796 .@expr8604 str (@expr8605 ) ;
1592: if (@expr1073750661 cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) .@expr1073750664 hasKnownIntValue (@expr1073750665 ) ) {
1593: expr1@var2805 =@expr1073750666 cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) ;
1594: value1@var2806 =@expr1073750669 cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) ;
1595: } else { if (@expr1073750672 cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) .@expr1073750675 hasKnownIntValue (@expr1073750676 ) ) {
1596: expr1@var2805 =@expr1073750677 cond1@var2795 .@expr8613 astOperand2 (@expr8614 ) ;
1597: value1@var2806 =@expr1073750680 cond1@var2795 .@expr8611 astOperand1 (@expr8612 ) ;
1598: if (@expr1073750683 op1@var2809 [@expr8860 0 ] ==@expr1073750685 '>' ) {
1599: op1@var2809 [@expr8860 0 ] =@expr1073750687 '<' ; }
1600: else { if (@expr1073750688 op1@var2809 [@expr8860 0 ] ==@expr1073750690 '<' ) {
1601: op1@var2809 [@expr8860 0 ] =@expr1073750692 '>' ; } }
1602: } }
1603: if (@expr1073750693 cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) .@expr1073750696 hasKnownIntValue (@expr1073750697 ) ) {
1604: expr2@var2807 =@expr1073750698 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) ;
1605: value2@var2808 =@expr1073750701 cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) ;
1606: } else { if (@expr1073750704 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) .@expr1073750707 hasKnownIntValue (@expr1073750708 ) ) {
1607: expr2@var2807 =@expr1073750709 cond2@var2796 .@expr8621 astOperand2 (@expr8622 ) ;
1608: value2@var2808 =@expr1073750712 cond2@var2796 .@expr8619 astOperand1 (@expr8620 ) ;
1609: if (@expr1073750715 op2@var2810 [@expr8892 0 ] ==@expr1073750717 '>' ) {
1610: op2@var2810 [@expr8892 0 ] =@expr1073750719 '<' ; }
1611: else { if (@expr1073750720 op2@var2810 [@expr8892 0 ] ==@expr1073750722 '<' ) {
1612: op2@var2810 [@expr8892 0 ] =@expr1073750724 '>' ; } }
1613: } }
1614: if (@expr1073750725 !@expr1073750726 expr1@var2805 ||@expr1073750727 !@expr1073750728 value1@var2806 ||@expr1073750729 !@expr1073750730 expr2@var2807 ||@expr1073750731 !@expr1073750732 value2@var2808 ) {
1615: return false ;
1616: }
1617: if (@expr1073750733 !@expr1073750734 isSameExpression (@expr1073750735 cpp@var2794 , true , expr1@var2805 , expr2@var2807 , library@var2797 , pure@var2798 , followVar@var2799 , errors@var2800 ) ) {
1618: return false ; }
1619:
1620: const ValueFlow ::@expr8774 Value &@expr8775 rhsValue1@var2811 =@expr1073750738 value1@var2806 .@expr1073750739 values (@expr1073750740 ) .@expr1073750741 front (@expr1073750742 ) ;
1621: const ValueFlow ::@expr8774 Value &@expr8775 rhsValue2@var2812 =@expr1073750745 value2@var2808 .@expr1073750746 values (@expr1073750747 ) .@expr1073750748 front (@expr1073750749 ) ;
1622:
1623: if (@expr1073750750 op1@var2809 ==@expr1073750751 "<" ||@expr1073750752 op1@var2809 ==@expr1073750753 "<=" ) {
1624: return (@expr8930 op2@var2810 ==@expr8931 "==" ||@expr1073750756 op2@var2810 ==@expr1073750757 ">" ||@expr1073750758 op2@var2810 ==@expr1073750759 ">=" ) &&@expr1073750760 (@expr8930 rhsValue1@var2811 .@expr8938 intvalue@var2813 <@expr1073750763 rhsValue2@var2812 .@expr8940 intvalue@var2814 ) ; }
1625: else { if (@expr1073750765 op1@var2809 ==@expr1073750766 ">=" ||@expr1073750767 op1@var2809 ==@expr1073750768 ">" ) {
1626: return (@expr8930 op2@var2810 ==@expr8931 "==" ||@expr1073750771 op2@var2810 ==@expr1073750772 "<" ||@expr1073750773 op2@var2810 ==@expr1073750774 "<=" ) &&@expr1073750775 (@expr8930 rhsValue1@var2811 .@expr8938 intvalue@var2813 >@expr1073750778 rhsValue2@var2812 .@expr8940 intvalue@var2814 ) ; } }
1627:
1628: return false ;
1629: }
1630:
1631:
1632: return (@expr8930 (@expr8930 comp1@var2803 ==@expr8683 "==" &&@expr1073750783 comp2@var2804 ==@expr8960 "!=" ) ||@expr1073750785
1633: (@expr8930 comp1@var2803 ==@expr8963 "!=" &&@expr1073750788 comp2@var2804 ==@expr8965 "==" ) ||@expr1073750790
1634: (@expr8930 comp1@var2803 ==@expr8968 "<" &&@expr1073750793 comp2@var2804 ==@expr1073750794 ">=" ) ||@expr1073750795
1635: (@expr8930 comp1@var2803 ==@expr1073750797 "<=" &&@expr1073750798 comp2@var2804 ==@expr8975 ">" ) ||@expr1073750800
1636: (@expr8930 comp1@var2803 ==@expr8978 ">" &&@expr1073750803 comp2@var2804 ==@expr1073750804 "<=" ) ||@expr1073750805
1637: (@expr8930 comp1@var2803 ==@expr1073750807 ">=" &&@expr1073750808 comp2@var2804 ==@expr8985 "<" ) ||@expr1073750810
1638: (@expr8930 !@expr8598 isNot@var2793 &&@expr1073750813 (@expr8930 (@expr8930 comp1@var2803 ==@expr8968 "<" &&@expr1073750817 comp2@var2804 ==@expr8975 ">" ) ||@expr1073750819
1639: (@expr8930 comp1@var2803 ==@expr8978 ">" &&@expr1073750822 comp2@var2804 ==@expr8985 "<" ) ||@expr1073750824
1640: (@expr8930 comp1@var2803 ==@expr8683 "==" &&@expr1073750827 (@expr8930 comp2@var2804 ==@expr8960 "!=" ||@expr1073750830 comp2@var2804 ==@expr8975 ">" ||@expr1073750832 comp2@var2804 ==@expr8985 "<" ) ) ||@expr1073750834
1641: (@expr8930 (@expr8930 comp1@var2803 ==@expr8963 "!=" ||@expr1073750838 comp1@var2803 ==@expr8978 ">" ||@expr1073750840 comp1@var2803 ==@expr8968 "<" ) &&@expr1073750842 comp2@var2804 ==@expr8965 "==" )
1642: ) ) ) ;
1643: }
1644:
1645: bool isOppositeExpression ( bool cpp@var2815 , const Token * const tok1@var2816 , const Token * const tok2@var2817 , const Library & library@var2818 , bool pure@var2819 , bool followVar@var2820 , std :: list < std :: pair < const Token * , std :: string > > * errors@var2821 )
1646: {
1647: if (@expr1073750844 !@expr1073750845 tok1@var2816 ||@expr1073750846 !@expr1073750847 tok2@var2817 ) {
1648: return false ; }
1649: if (@expr1073750848 isOppositeCond (@expr1073750849 true , cpp@var2815 , tok1@var2816 , tok2@var2817 , library@var2818 , pure@var2819 , followVar@var2820 , errors@var2821 ) ) {
1650: return true ; }
1651: if (@expr1073750850 tok1@var2816 .@expr1073750851 isUnaryOp (@expr1073750852 "-" ) &&@expr1073750853 !@expr9030 (@expr1073750855 tok2@var2817 .@expr9032 astParent (@expr9033 ) &&@expr9034 tok2@var2817 .@expr9032 astParent (@expr9033 ) .@expr9037 tokType (@expr9038 ) ==@expr9039 Token ::@expr9040 eBitOp ) ) {
1652: return isSameExpression (@expr1073750865 cpp@var2815 , true , tok1@var2816 .@expr1073750866 astOperand1 (@expr1073750867 ) , tok2@var2817 , library@var2818 , pure@var2819 , followVar@var2820 , errors@var2821 ) ; }
1653: if (@expr1073750868 tok2@var2817 .@expr1073750869 isUnaryOp (@expr1073750870 "-" ) &&@expr1073750871 !@expr9030 (@expr1073750873 tok2@var2817 .@expr9032 astParent (@expr9033 ) &&@expr9034 tok2@var2817 .@expr9032 astParent (@expr9033 ) .@expr9037 tokType (@expr9038 ) ==@expr9039 Token ::@expr9040 eBitOp ) ) {
1654: return isSameExpression (@expr1073750883 cpp@var2815 , true , tok2@var2817 .@expr1073750884 astOperand1 (@expr1073750885 ) , tok1@var2816 , library@var2818 , pure@var2819 , followVar@var2820 , errors@var2821 ) ; }
1655: return false ;
1656: }
1657:
1658: static bool functionModifiesArguments ( const Function * f@var2822 )
1659: {
1660: return std ::@expr1073750886 any_of (@expr1073750887 f@var2822 .@expr9064 argumentList@var2823 .@expr1073750889 begin (@expr1073750890 ) , f@var2822 .@expr9064 argumentList@var2823 .@expr1073750892 end (@expr1073750893 ) , [@expr1073750894 ] (@expr1073750895 const Variable &@expr1073750896 var@var2824 ) {
1661: if (@expr1073750897 var@var2824 .@expr1073750898 isReference (@expr1073750899 ) ||@expr1073750900 var@var2824 .@expr1073750901 isPointer (@expr1073750902 ) ) {
1662: return !@expr1073750903 var@var2824 .@expr1073750904 isConst (@expr1073750905 ) ; }
1663: return true ;
1664: } ) ;
1665: }
1666:
1667: bool isConstFunctionCall ( const Token * ftok@var2825 , const Library & library@var2826 )
1668: {
1669: if (@expr1073750906 !@expr1073750907 Token ::@expr9084 Match (@expr1073750909 ftok@var2825 , "%name% (" ) ) {
1670: return false ; }
1671: if (@expr1073750910 const Function *@expr9087 f@var2827 =@expr1073750912 ftok@var2825 .@expr1073750913 function (@expr1073750914 ) ) {
1672: if (@expr1073750915 f@var2827 .@expr1073750916 isAttributePure (@expr1073750917 ) ||@expr1073750918 f@var2827 .@expr1073750919 isAttributeConst (@expr1073750920 ) ) {
1673: return true ; }
1674:
1675: if (@expr1073750921 functionModifiesArguments (@expr1073750922 f@var2827 ) ) {
1676: return false ; }
1677: if (@expr1073750923 Function ::@expr1073750924 returnsVoid (@expr1073750925 f@var2827 ) ) {
1678: return false ; }
1679:
1680: if (@expr1073750926 Token ::@expr1073750927 simpleMatch (@expr1073750928 ftok@var2825 .@expr9105 previous (@expr9106 ) , "." ) ||@expr1073750931 exprDependsOnThis (@expr1073750932 ftok@var2825 .@expr1073750933 next (@expr1073750934 ) ) ) {
1681: if (@expr1073750935 f@var2827 .@expr1073750936 isConst (@expr1073750937 ) ) {
1682: return true ; }
1683:
1684: if (@expr1073750938 !@expr1073750939 Function ::@expr9116 returnsConst (@expr1073750941 f@var2827 ) ) {
1685: std ::@expr1073750942 vector < const Function *@expr9087 > fs@var2828 ; fs@var2828 =@expr1073750944 f@var2827 .@expr1073750945 getOverloadedFunctions (@expr1073750946 ) ;
1686: if (@expr1073750947 std ::@expr1073750948 any_of (@expr1073750949 fs@var2828 .@expr1073750950 begin (@expr1073750951 ) , fs@var2828 .@expr1073750952 end (@expr1073750953 ) , [@expr1073750954 &@expr1073750955 ] (@expr1073750956 const Function *@expr9087 g@var2829 ) {
1687: if (@expr1073750958 f@var2827 ==@expr1073750959 g@var2829 ) {
1688: return false ; }
1689: if (@expr1073750960 f@var2827 .@expr9137 argumentList@var2830 .@expr1073750962 size (@expr1073750963 ) !=@expr1073750964 g@var2829 .@expr1073750965 argumentList@var2831 .@expr1073750966 size (@expr1073750967 ) ) {
1690: return false ; }
1691: if (@expr1073750968 functionModifiesArguments (@expr1073750969 g@var2829 ) ) {
1692: return false ; }
1693: if (@expr1073750970 g@var2829 .@expr1073750971 isConst (@expr1073750972 ) &&@expr1073750973 Function ::@expr9116 returnsConst (@expr1073750975 g@var2829 ) ) {
1694: return true ; }
1695: return false ;
1696: } ) ) {
1697: return true ; }
1698: }
1699: return false ;
1700: } else { if (@expr1073750976 f@var2827 .@expr9137 argumentList@var2830 .@expr1073750978 empty (@expr1073750979 ) ) {
1701: return f@var2827 .@expr1073750980 isConstexpr (@expr1073750981 ) ;
1702: } }
1703: } else { if (@expr1073750982 Token ::@expr9084 Match (@expr9160 ftok@var2825 .@expr9105 previous (@expr9106 ) , ". %name% (" ) &&@expr1073750987 ftok@var2825 .@expr9105 previous (@expr9106 ) .@expr1073750990 originalName (@expr1073750991 ) !=@expr1073750992 "->" &&@expr1073750993
1704: astIsSmartPointer (@expr1073750994 ftok@var2825 .@expr9105 previous (@expr9106 ) .@expr9173 astOperand1 (@expr9174 ) ) ) {
1705: return Token ::@expr9084 Match (@expr1073751000 ftok@var2825 , "get|get_deleter ( )" ) ;
1706: } else { if (@expr1073751001 Token ::@expr9084 Match (@expr9160 ftok@var2825 .@expr9105 previous (@expr9106 ) , ". %name% (" ) &&@expr1073751006 astIsContainer (@expr1073751007 ftok@var2825 .@expr9105 previous (@expr9106 ) .@expr9173 astOperand1 (@expr9174 ) ) ) {
1707: const Library ::@expr9188 Container * container@var2832 ; container@var2832 =@expr1073751013 ftok@var2825 .@expr9105 previous (@expr9106 ) .@expr9173 astOperand1 (@expr9174 ) .@expr1073751018 valueType (@expr1073751019 ) .@expr1073751020 container@var3327 ;
1708: if (@expr1073751021 !@expr1073751022 container@var2832 ) {
1709: return false ; }
1710: if (@expr1073751023 container@var2832 .@expr1073751024 getYield (@expr1073751025 ftok@var2825 .@expr9202 str (@expr9203 ) ) !=@expr1073751028 Library ::@expr9188 Container ::@expr9206 Yield ::@expr9207 NO_YIELD ) {
1711: return true ; }
1712: if (@expr1073751032 container@var2832 .@expr1073751033 getAction (@expr1073751034 ftok@var2825 .@expr9202 str (@expr9203 ) ) ==@expr1073751037 Library ::@expr9188 Container ::@expr9215 Action ::@expr9216 FIND ) {
1713: return true ; }
1714: return false ;
1715: } else { if (@expr1073751041 const Library ::@expr1073751042 Function *@expr9087 lf@var2833 =@expr1073751044 library@var2826 .@expr1073751045 getFunction (@expr1073751046 ftok@var2825 ) ) {
1716: if (@expr1073751047 lf@var2833 .@expr1073751048 ispure@var2834 ) {
1717: return true ; }
1718: if (@expr1073751049 lf@var2833 .@expr1073751050 containerYield@var2835 !=@expr1073751051 Library ::@expr9188 Container ::@expr9206 Yield ::@expr9207 NO_YIELD ) {
1719: return true ; }
1720: if (@expr1073751055 lf@var2833 .@expr1073751056 containerAction@var2836 ==@expr1073751057 Library ::@expr9188 Container ::@expr9215 Action ::@expr9216 FIND ) {
1721: return true ; }
1722: return false ;
1723: } else {
1724: bool memberFunction@var2837 ; memberFunction@var2837 =@expr1073751061 Token ::@expr9084 Match (@expr9160 ftok@var2825 .@expr9105 previous (@expr9106 ) , ". %name% (" ) ;
1725: bool constMember@var2838 ; constMember@var2838 =@expr1073751066 !@expr1073751067 memberFunction@var2837 ;
1726: if (@expr1073751068 Token ::@expr9084 Match (@expr1073751070 ftok@var2825 .@expr9247 tokAt (@expr9248 -2 ) , "%var% . %name% (" ) ) {
1727: const Variable * var@var2839 ; var@var2839 =@expr1073751073 ftok@var2825 .@expr9247 tokAt (@expr9248 -2 ) .@expr1073751076 variable (@expr1073751077 ) ;
1728: if (@expr1073751078 var@var2839 ) {
1729: constMember@var2838 =@expr1073751079 var@var2839 .@expr1073751080 isConst (@expr1073751081 ) ; }
1730: }
1731:
1732: std ::@expr1073751082 vector < const Token *@expr9087 > args@var2840 ; args@var2840 =@expr1073751084 getArguments (@expr1073751085 ftok@var2825 ) ;
1733: if (@expr1073751086 args@var2840 .@expr1073751087 empty (@expr1073751088 ) ) {
1734: return false ; }
1735: return constMember@var2838 &&@expr1073751089 std ::@expr1073751090 all_of (@expr1073751091 args@var2840 .@expr1073751092 begin (@expr1073751093 ) , args@var2840 .@expr1073751094 end (@expr1073751095 ) , [@expr1073751096 ] (@expr1073751097 const Token *@expr9087 tok@var2841 ) {
1736: const Variable * var@var2842 ; var@var2842 =@expr1073751099 tok@var2841 .@expr1073751100 variable (@expr1073751101 ) ;
1737: if (@expr1073751102 var@var2842 ) {
1738: return var@var2842 .@expr1073751103 isConst (@expr1073751104 ) ; }
1739: return false ;
1740: } ) ;
1741: } } } }
1742: return true ;
1743: }
1744:
1745: bool isConstExpression ( const Token * tok@var2843 , const Library & library@var2844 , bool pure@var2845 , bool cpp@var2846 )
1746: {
1747: if (@expr1073751105 !@expr1073751106 tok@var2843 ) {
1748: return true ; }
1749: if (@expr1073751107 tok@var2843 .@expr9284 variable (@expr9285 ) &&@expr1073751110 tok@var2843 .@expr9284 variable (@expr9285 ) .@expr1073751113 isVolatile (@expr1073751114 ) ) {
1750: return false ; }
1751: if (@expr1073751115 tok@var2843 .@expr1073751116 isName (@expr1073751117 ) &&@expr1073751118 tok@var2843 .@expr1073751119 next (@expr1073751120 ) .@expr1073751121 str (@expr1073751122 ) ==@expr1073751123 "(" ) {
1752: if (@expr1073751124 !@expr1073751125 isConstFunctionCall (@expr1073751126 tok@var2843 , library@var2844 ) ) {
1753: return false ; }
1754: }
1755: if (@expr1073751127 tok@var2843 .@expr1073751128 tokType (@expr1073751129 ) ==@expr1073751130 Token ::@expr1073751131 eIncDecOp ) {
1756: return false ; }
1757: if (@expr1073751132 tok@var2843 .@expr1073751133 isAssignmentOp (@expr1073751134 ) ) {
1758: return false ; }
1759: if (@expr1073751135 isLikelyStreamRead (@expr1073751136 cpp@var2846 , tok@var2843 ) ) {
1760: return false ; }
1761:
1762: if (@expr1073751137 tok@var2843 .@expr1073751138 str (@expr1073751139 ) ==@expr1073751140 "{" ) {
1763: return false ; }
1764: return isConstExpression (@expr1073751141 tok@var2843 .@expr1073751142 astOperand1 (@expr1073751143 ) , library@var2844 , pure@var2845 , cpp@var2846 ) &&@expr1073751144 isConstExpression (@expr1073751145 tok@var2843 .@expr1073751146 astOperand2 (@expr1073751147 ) , library@var2844 , pure@var2845 , cpp@var2846 ) ;
1765: }
1766:
1767: bool isWithoutSideEffects ( bool cpp@var2847 , const Token * tok@var2848 , bool checkArrayAccess@var2849 , bool checkReference@var2850 )
1768: {
1769: if (@expr1073751148 !@expr1073751149 cpp@var2847 ) {
1770: return true ; }
1771:
1772: while (@expr1073751150 tok@var2848 &&@expr1073751151 tok@var2848 .@expr9328 astOperand2 (@expr9329 ) &&@expr1073751154 tok@var2848 .@expr9328 astOperand2 (@expr9329 ) .@expr1073751157 str (@expr1073751158 ) !=@expr1073751159 "(" ) {
1773: tok@var2848 =@expr1073751160 tok@var2848 .@expr9328 astOperand2 (@expr9329 ) ; }
1774: if (@expr1073751163 tok@var2848 &&@expr1073751164 tok@var2848 .@expr1073751165 varId (@expr1073751166 ) ) {
1775: const Variable * var@var2851 ; var@var2851 =@expr1073751167 tok@var2848 .@expr1073751168 variable (@expr1073751169 ) ;
1776: return var@var2851 &&@expr1073751170 (@expr1073751171 (@expr1073751172 !@expr1073751173 var@var2851 .@expr1073751174 isClass (@expr1073751175 ) &&@expr1073751176 (@expr1073751177 checkReference@var2850 ||@expr1073751178 !@expr1073751179 var@var2851 .@expr1073751180 isReference (@expr1073751181 ) ) ) ||@expr1073751182 var@var2851 .@expr1073751183 isPointer (@expr1073751184 ) ||@expr1073751185 (@expr1073751186 checkArrayAccess@var2849 ?@expr1073751187 var@var2851 .@expr9364 isStlType (@expr9365 ) &&@expr1073751190 !@expr1073751191 var@var2851 .@expr9364 isStlType (@expr1073751193 CheckClass ::@expr1073751194 stl_containers_not_const@var2279 ) :@expr1073751195 var@var2851 .@expr9364 isStlType (@expr9365 ) ) ) ;
1777: }
1778: return true ;
1779: }
1780:
1781: bool isUniqueExpression ( const Token * tok@var2852 )
1782: {
1783: if (@expr1073751198 !@expr1073751199 tok@var2852 ) {
1784: return true ; }
1785: if (@expr1073751200 tok@var2852 .@expr9377 function (@expr9378 ) ) {
1786: const Function * fun@var2853 ; fun@var2853 =@expr1073751203 tok@var2852 .@expr9377 function (@expr9378 ) ;
1787: const Scope * scope@var2854 ; scope@var2854 =@expr1073751206 fun@var2853 .@expr1073751207 nestedIn@var2855 ;
1788: if (@expr1073751208 !@expr1073751209 scope@var2854 ) {
1789: return true ; }
1790: const std ::@expr9386 string returnType@var2856 =@expr1073751211 fun@var2853 .@expr9388 retType@var2857 ?@expr1073751213 fun@var2853 .@expr9388 retType@var2857 .@expr1073751215 name (@expr1073751216 ) :@expr1073751217 fun@var2853 .@expr1073751218 retDef@var2858 .@expr1073751219 stringifyList (@expr1073751220 fun@var2853 .@expr1073751221 tokenDef@var2859 ) ;
1791: for (@expr1073751222 const Function &@expr9399 f@var2860 :@expr1073751224 scope@var2854 .@expr1073751225 functionList@var2861 ) {
1792: if (@expr1073751226 f@var2860 .@expr1073751227 type@var2862 !=@expr1073751228 Function ::@expr1073751229 eFunction ) {
1793: continue ; }
1794:
1795: const std ::@expr9386 string freturnType@var2863 =@expr1073751231 f@var2860 .@expr9408 retType@var2864 ?@expr1073751233 f@var2860 .@expr9408 retType@var2864 .@expr1073751235 name (@expr1073751236 ) :@expr1073751237 f@var2860 .@expr1073751238 retDef@var2865 .@expr1073751239 stringifyList (@expr1073751240 f@var2860 .@expr1073751241 returnDefEnd (@expr1073751242 ) ) ;
1796: if (@expr1073751243 f@var2860 .@expr1073751244 argumentList@var2866 .@expr1073751245 size (@expr1073751246 ) ==@expr1073751247 fun@var2853 .@expr1073751248 argumentList@var2867 .@expr1073751249 size (@expr1073751250 ) &&@expr1073751251
1797: returnType@var2856 ==@expr1073751252 freturnType@var2863 &&@expr1073751253
1798: f@var2860 .@expr1073751254 name (@expr1073751255 ) !=@expr1073751256 fun@var2853 .@expr1073751257 name (@expr1073751258 ) ) {
1799: return false ;
1800: }
1801: }
1802: } else { if (@expr1073751259 tok@var2852 .@expr9436 variable (@expr9437 ) ) {
1803: const Variable * var@var2868 ; var@var2868 =@expr1073751262 tok@var2852 .@expr9436 variable (@expr9437 ) ;
1804: const Scope * scope@var2869 ; scope@var2869 =@expr1073751265 var@var2868 .@expr1073751266 scope (@expr1073751267 ) ;
1805: if (@expr1073751268 !@expr1073751269 scope@var2869 ) {
1806: return true ; }
1807: const Type * varType@var2870 ; varType@var2870 =@expr1073751270 var@var2868 .@expr1073751271 type (@expr1073751272 ) ;
1808:
1809: const Function * fun@var2871 ; fun@var2871 =@expr1073751273 scope@var2869 .@expr1073751274 function@var2872 ;
1810: const std ::@expr1073751275 list < Variable > * setOfVars@var2873 [@expr1073751276 2 ] =@expr1073751277 {@expr1073751278 &@expr1073751279 scope@var2869 .@expr1073751280 varlist@var2874 , fun@var2871 ?@expr1073751281 &@expr1073751282 fun@var2871 .@expr1073751283 argumentList@var2875 :@expr1073751284 nullptr } ;
1811:
1812: for (@expr1073751285 const std ::@expr9386 list < Variable > *@expr1073751287 vars@var2876 :@expr1073751288 setOfVars@var2873 ) {
1813: if (@expr1073751289 !@expr1073751290 vars@var2876 ) {
1814: continue ; }
1815: bool other@var2877 ; other@var2877 =@expr1073751291 std ::@expr1073751292 any_of (@expr1073751293 vars@var2876 .@expr1073751294 cbegin (@expr1073751295 ) , vars@var2876 .@expr1073751296 cend (@expr1073751297 ) , [@expr1073751298 =@expr1073751299 ] (@expr1073751300 const Variable &@expr9399 v@var2878 ) {
1816: if (@expr1073751302 varType@var2870 ) {
1817: return v@var2878 .@expr9479 type (@expr9480 ) &&@expr1073751305 v@var2878 .@expr9479 type (@expr9480 ) .@expr1073751308 name (@expr1073751309 ) ==@expr1073751310 varType@var2870 .@expr1073751311 name (@expr1073751312 ) &&@expr1073751313 v@var2878 .@expr9490 name (@expr9491 ) !=@expr9492 var@var2868 .@expr9493 name (@expr9494 ) ; }
1818: return v@var2878 .@expr1073751319 isFloatingType (@expr1073751320 ) ==@expr1073751321 var@var2868 .@expr1073751322 isFloatingType (@expr1073751323 ) &&@expr1073751324
1819: v@var2878 .@expr1073751325 isEnumType (@expr1073751326 ) ==@expr1073751327 var@var2868 .@expr1073751328 isEnumType (@expr1073751329 ) &&@expr1073751330
1820: v@var2878 .@expr1073751331 isClass (@expr1073751332 ) ==@expr1073751333 var@var2868 .@expr1073751334 isClass (@expr1073751335 ) &&@expr1073751336
1821: v@var2878 .@expr1073751337 isArray (@expr1073751338 ) ==@expr1073751339 var@var2868 .@expr1073751340 isArray (@expr1073751341 ) &&@expr1073751342
1822: v@var2878 .@expr1073751343 isPointer (@expr1073751344 ) ==@expr1073751345 var@var2868 .@expr1073751346 isPointer (@expr1073751347 ) &&@expr1073751348
1823: v@var2878 .@expr9490 name (@expr9491 ) !=@expr9492 var@var2868 .@expr9493 name (@expr9494 ) ;
1824: } ) ;
1825: if (@expr1073751354 other@var2877 ) {
1826: return false ; }
1827: }
1828: } else { if (@expr1073751355 !@expr1073751356 isUniqueExpression (@expr1073751357 tok@var2852 .@expr1073751358 astOperand1 (@expr1073751359 ) ) ) {
1829: return false ;
1830: } } }
1831:
1832: return isUniqueExpression (@expr1073751360 tok@var2852 .@expr1073751361 astOperand2 (@expr1073751362 ) ) ;
1833: }
1834:
1835: static bool isEscaped ( const Token * tok@var2879 , bool functionsScope@var2880 , const Library * library@var2881 )
1836: {
1837: if (@expr1073751363 library@var2881 &&@expr1073751364 library@var2881 .@expr1073751365 isnoreturn (@expr1073751366 tok@var2879 ) ) {
1838: return true ; }
1839: if (@expr1073751367 functionsScope@var2880 ) {
1840: return Token ::@expr1073751368 simpleMatch (@expr1073751369 tok@var2879 , "throw" ) ; }
1841: else {
1842: return Token ::@expr1073751370 Match (@expr1073751371 tok@var2879 , "return|throw" ) ; }
1843: }
1844:
1845: static bool isEscapedOrJump ( const Token * tok@var2882 , bool functionsScope@var2883 , const Library * library@var2884 )
1846: {
1847: if (@expr1073751372 library@var2884 &&@expr1073751373 library@var2884 .@expr1073751374 isnoreturn (@expr1073751375 tok@var2882 ) ) {
1848: return true ; }
1849: if (@expr1073751376 functionsScope@var2883 ) {
1850: return Token ::@expr1073751377 simpleMatch (@expr1073751378 tok@var2882 , "throw" ) ; }
1851: else {
1852: return Token ::@expr1073751379 Match (@expr1073751380 tok@var2882 , "return|goto|throw|continue|break" ) ; }
1853: }
1854:
1855: bool isEscapeFunction ( const Token * ftok@var2885 , const Library * library@var2886 )
1856: {
1857: if (@expr1073751381 !@expr1073751382 Token ::@expr1073751383 Match (@expr1073751384 ftok@var2885 , "%name% (" ) ) {
1858: return false ; }
1859: const Function * function@var2887 ; function@var2887 =@expr1073751385 ftok@var2885 .@expr1073751386 function (@expr1073751387 ) ;
1860: if (@expr1073751388 function@var2887 ) {
1861: if (@expr1073751389 function@var2887 .@expr1073751390 isEscapeFunction (@expr1073751391 ) ) {
1862: return true ; }
1863: if (@expr1073751392 function@var2887 .@expr1073751393 isAttributeNoreturn (@expr1073751394 ) ) {
1864: return true ; }
1865: } else { if (@expr1073751395 library@var2886 ) {
1866: if (@expr1073751396 library@var2886 .@expr1073751397 isnoreturn (@expr1073751398 ftok@var2885 ) ) {
1867: return true ; }
1868: } }
1869: return false ;
1870: }
1871:
1872: static bool hasNoreturnFunction ( const Token * tok@var2888 , const Library * library@var2889 , const Token * * unknownFunc@var2890 )
1873: {
1874: if (@expr1073751399 !@expr1073751400 tok@var2888 ) {
1875: return false ; }
1876: const Token * ftok@var2891 ; ftok@var2891 =@expr1073751401 tok@var2888 .@expr1073751402 str (@expr1073751403 ) ==@expr1073751404 "(" ?@expr1073751405 tok@var2888 .@expr1073751406 previous (@expr1073751407 ) :@expr1073751408 nullptr ;
1877: while (@expr1073751409 Token ::@expr1073751410 simpleMatch (@expr1073751411 ftok@var2891 , "(" ) ) {
1878: ftok@var2891 =@expr1073751412 ftok@var2891 .@expr1073751413 astOperand1 (@expr1073751414 ) ; }
1879: if (@expr1073751415 ftok@var2891 ) {
1880: const Function * function@var2892 ; function@var2892 =@expr1073751416 ftok@var2891 .@expr1073751417 function (@expr1073751418 ) ;
1881: if (@expr1073751419 function@var2892 ) {
1882: if (@expr1073751420 function@var2892 .@expr1073751421 isEscapeFunction (@expr1073751422 ) ) {
1883: return true ; }
1884: if (@expr1073751423 function@var2892 .@expr1073751424 isAttributeNoreturn (@expr1073751425 ) ) {
1885: return true ; }
1886: } else { if (@expr1073751426 library@var2889 &&@expr1073751427 library@var2889 .@expr1073751428 isnoreturn (@expr1073751429 ftok@var2891 ) ) {
1887: return true ;
1888: } else { if (@expr1073751430 Token ::@expr1073751431 Match (@expr1073751432 ftok@var2891 , "exit|abort" ) ) {
1889: return true ;
1890: } } }
1891: if (@expr1073751433 unknownFunc@var2890 &&@expr1073751434 !@expr1073751435 function@var2892 &&@expr1073751436 library@var2889 &&@expr1073751437 library@var2889 .@expr1073751438 functions@var2893 .@expr1073751439 count (@expr1073751440 library@var2889 .@expr1073751441 getFunctionName (@expr1073751442 ftok@var2891 ) ) ==@expr1073751443 0 ) {
1892: *@expr1073751444 unknownFunc@var2890 =@expr1073751445 ftok@var2891 ; }
1893: return false ;
1894: } else { if (@expr1073751446 tok@var2888 .@expr1073751447 isConstOp (@expr1073751448 ) ) {
1895: return hasNoreturnFunction (@expr1073751449 tok@var2888 .@expr1073751450 astOperand1 (@expr1073751451 ) , library@var2889 , unknownFunc@var2890 ) ||@expr1073751452 hasNoreturnFunction (@expr1073751453 tok@var2888 .@expr1073751454 astOperand2 (@expr1073751455 ) , library@var2889 , unknownFunc@var2890 ) ;
1896: } }
1897:
1898: return false ;
1899: }
1900:
1901: bool isReturnScope ( const Token * const endToken@var2894 , const Library * library@var2895 , const Token * * unknownFunc@var2896 , bool functionScope@var2897 )
1902: {
1903: if (@expr1073751456 !@expr1073751457 endToken@var2894 ||@expr1073751458 endToken@var2894 .@expr1073751459 str (@expr1073751460 ) !=@expr1073751461 "}" ) {
1904: return false ; }
1905:
1906: const Token * prev@var2898 ; prev@var2898 =@expr1073751462 endToken@var2894 .@expr1073751463 previous (@expr1073751464 ) ;
1907: while (@expr1073751465 prev@var2898 &&@expr1073751466 Token ::@expr9643 simpleMatch (@expr1073751468 prev@var2898 .@expr9645 previous (@expr9646 ) , "; ;" ) ) {
1908: prev@var2898 =@expr1073751471 prev@var2898 .@expr9645 previous (@expr9646 ) ; }
1909: if (@expr1073751474 prev@var2898 &&@expr1073751475 Token ::@expr9643 simpleMatch (@expr1073751477 prev@var2898 .@expr9645 previous (@expr9646 ) , "} ;" ) ) {
1910: prev@var2898 =@expr1073751480 prev@var2898 .@expr9645 previous (@expr9646 ) ; }
1911:
1912: if (@expr1073751483 Token ::@expr9643 simpleMatch (@expr1073751485 prev@var2898 , "}" ) ) {
1913: if (@expr1073751486 Token ::@expr9643 simpleMatch (@expr1073751488 prev@var2898 .@expr9665 link (@expr9666 ) .@expr9667 tokAt (@expr9668 -2 ) , "} else {" ) ) {
1914: return isReturnScope (@expr9669 prev@var2898 , library@var2895 , unknownFunc@var2896 , functionScope@var2897 ) &&@expr1073751494
1915: isReturnScope (@expr1073751495 prev@var2898 .@expr9665 link (@expr9666 ) .@expr9667 tokAt (@expr9668 -2 ) , library@var2895 , unknownFunc@var2896 , functionScope@var2897 ) ; }
1916:
1917: if (@expr1073751500 !@expr1073751501 functionScope@var2897 &&@expr1073751502 Token ::@expr9643 simpleMatch (@expr1073751504 prev@var2898 .@expr9665 link (@expr9666 ) .@expr9683 previous (@expr9684 ) , ") {" ) &&@expr1073751509
1918: Token ::@expr9643 simpleMatch (@expr1073751511 prev@var2898 .@expr9665 link (@expr9666 ) .@expr1073751514 linkAt (@expr1073751515 -1 ) .@expr1073751516 previous (@expr1073751517 ) , "switch (" ) &&@expr1073751518
1919: !@expr1073751519 Token ::@expr1073751520 findsimplematch (@expr1073751521 prev@var2898 .@expr9665 link (@expr9666 ) , "break" , prev@var2898 ) ) {
1920: return isReturnScope (@expr9669 prev@var2898 , library@var2895 , unknownFunc@var2896 , functionScope@var2897 ) ;
1921: }
1922: if (@expr1073751525 isEscaped (@expr1073751526 prev@var2898 .@expr9665 link (@expr9666 ) .@expr1073751529 astTop (@expr1073751530 ) , functionScope@var2897 , library@var2895 ) ) {
1923: return true ; }
1924: if (@expr1073751531 Token ::@expr9708 Match (@expr1073751533 prev@var2898 .@expr9665 link (@expr9666 ) .@expr9683 previous (@expr9684 ) , "[;{}] {" ) ) {
1925: return isReturnScope (@expr9669 prev@var2898 , library@var2895 , unknownFunc@var2896 , functionScope@var2897 ) ; }
1926: } else { if (@expr1073751539 Token ::@expr9643 simpleMatch (@expr1073751541 prev@var2898 , ";" ) ) {
1927: if (@expr1073751542 prev@var2898 .@expr9719 tokAt (@expr9720 -2 ) &&@expr1073751545 hasNoreturnFunction (@expr1073751546 prev@var2898 .@expr9719 tokAt (@expr9720 -2 ) .@expr1073751549 astTop (@expr1073751550 ) , library@var2895 , unknownFunc@var2896 ) ) {
1928: return true ; }
1929:
1930: if (@expr1073751551 Token ::@expr9708 Match (@expr1073751553 prev@var2898 .@expr9719 tokAt (@expr9720 -2 ) , ";|}|{ %name% ;" ) &&@expr1073751556 prev@var2898 .@expr9645 previous (@expr9646 ) .@expr1073751559 isIncompleteVar (@expr1073751560 ) ) {
1931: if (@expr1073751561 unknownFunc@var2896 ) {
1932: *@expr1073751562 unknownFunc@var2896 =@expr1073751563 prev@var2898 .@expr9645 previous (@expr9646 ) ; }
1933: return false ;
1934: }
1935: if (@expr1073751566 Token ::@expr9643 simpleMatch (@expr1073751568 prev@var2898 .@expr9645 previous (@expr9646 ) , ") ;" ) &&@expr1073751571 prev@var2898 .@expr9645 previous (@expr9646 ) .@expr9750 link (@expr9751 ) &&@expr1073751576
1936: isEscaped (@expr1073751577 prev@var2898 .@expr9645 previous (@expr9646 ) .@expr9750 link (@expr9751 ) .@expr1073751582 astTop (@expr1073751583 ) , functionScope@var2897 , library@var2895 ) ) {
1937: return true ; }
1938: if (@expr1073751584 isEscaped (@expr1073751585 prev@var2898 .@expr9645 previous (@expr9646 ) .@expr1073751588 astTop (@expr1073751589 ) , functionScope@var2897 , library@var2895 ) ) {
1939: return true ; }
1940:
1941: prev@var2898 =@expr1073751590 prev@var2898 .@expr9645 previous (@expr9646 ) ;
1942: while (@expr1073751593 prev@var2898 &&@expr1073751594 !@expr1073751595 Token ::@expr9708 Match (@expr1073751597 prev@var2898 , ";|{|}" ) &&@expr1073751598 !@expr1073751599 isEscapedOrJump (@expr1073751600 prev@var2898 , functionScope@var2897 , library@var2895 ) ) {
1943: prev@var2898 =@expr1073751601 prev@var2898 .@expr9645 previous (@expr9646 ) ; }
1944: return prev@var2898 &&@expr1073751604 prev@var2898 .@expr1073751605 isName (@expr1073751606 ) ;
1945: } }
1946: return false ;
1947: }
1948:
1949: bool isWithinScope ( const Token * tok@var2899 , const Variable * var@var2900 , Scope :: ScopeType type@var2901 )
1950: {
1951: if (@expr1073751607 !@expr1073751608 tok@var2899 ||@expr1073751609 !@expr1073751610 var@var2900 ) {
1952: return false ; }
1953: const Scope * scope@var2902 ; scope@var2902 =@expr1073751611 tok@var2899 .@expr1073751612 scope (@expr1073751613 ) ;
1954: while (@expr1073751614 scope@var2902 &&@expr1073751615 scope@var2902 !=@expr1073751616 var@var2900 .@expr1073751617 scope (@expr1073751618 ) ) {
1955: if (@expr1073751619 scope@var2902 .@expr1073751620 type@var2903 ==@expr1073751621 type@var2901 ) {
1956: return true ; }
1957: scope@var2902 =@expr1073751622 scope@var2902 .@expr1073751623 nestedIn@var2904 ;
1958: }
1959: return false ;
1960: }
1961:
1962: bool isVariableChangedByFunctionCall ( const Token * tok@var2905 , int indirect@var2906 , int varid@var2907 , const Settings * settings@var2908 , bool * inconclusive@var2909 )
1963: {
1964: if (@expr1073751624 !@expr1073751625 tok@var2905 ) {
1965: return false ; }
1966: if (@expr1073751626 tok@var2905 .@expr1073751627 varId (@expr1073751628 ) ==@expr1073751629 varid@var2907 ) {
1967: return isVariableChangedByFunctionCall (@expr1073751630 tok@var2905 , indirect@var2906 , settings@var2908 , inconclusive@var2909 ) ; }
1968: return isVariableChangedByFunctionCall (@expr1073751631 tok@var2905 .@expr1073751632 astOperand1 (@expr1073751633 ) , indirect@var2906 , varid@var2907 , settings@var2908 , inconclusive@var2909 ) ||@expr1073751634
1969: isVariableChangedByFunctionCall (@expr1073751635 tok@var2905 .@expr1073751636 astOperand2 (@expr1073751637 ) , indirect@var2906 , varid@var2907 , settings@var2908 , inconclusive@var2909 ) ;
1970: }
1971:
1972: bool isScopeBracket ( const Token * tok@var2910 )
1973: {
1974: if (@expr1073751638 !@expr1073751639 Token ::@expr1073751640 Match (@expr1073751641 tok@var2910 , "{|}" ) ) {
1975: return false ; }
1976: if (@expr1073751642 !@expr1073751643 tok@var2910 .@expr9820 scope (@expr9821 ) ) {
1977: return false ; }
1978: if (@expr1073751646 tok@var2910 .@expr9823 str (@expr9824 ) ==@expr1073751649 "{" ) {
1979: return tok@var2910 .@expr9820 scope (@expr9821 ) .@expr1073751652 bodyStart@var3325 ==@expr1073751653 tok@var2910 ; }
1980: if (@expr1073751654 tok@var2910 .@expr9823 str (@expr9824 ) ==@expr1073751657 "}" ) {
1981: return tok@var2910 .@expr9820 scope (@expr9821 ) .@expr1073751660 bodyEnd@var3320 ==@expr1073751661 tok@var2910 ; }
1982: return false ;
1983: }
1984:
1985: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
1986: T * getTokenArgumentFunctionImpl ( T * tok@var2911 , int & argn@var2912 )
1987: {
1988: argn@var2912 =@expr1073751663 -1 ;
1989: {
1990: T * parent@var2913 ; parent@var2913 =@expr1073751664 tok@var2911 .@expr9841 astParent (@expr9842 ) ;
1991: if (@expr1073751667 parent@var2913 &&@expr1073751668 parent@var2913 .@expr1073751669 isUnaryOp (@expr1073751670 "&" ) ) {
1992: parent@var2913 =@expr1073751671 parent@var2913 .@expr9848 astParent (@expr9849 ) ; }
1993: while (@expr1073751674 parent@var2913 &&@expr1073751675 parent@var2913 .@expr1073751676 isCast (@expr1073751677 ) ) {
1994: parent@var2913 =@expr1073751678 parent@var2913 .@expr9848 astParent (@expr9849 ) ; }
1995: if (@expr1073751681 Token ::@expr9858 Match (@expr1073751683 parent@var2913 , "[+-]" ) &&@expr1073751684 parent@var2913 .@expr9861 valueType (@expr9862 ) &&@expr1073751687 parent@var2913 .@expr9861 valueType (@expr9862 ) .@expr1073751690 pointer@expr1073751662 ) {
1996: parent@var2913 =@expr1073751691 parent@var2913 .@expr9848 astParent (@expr9849 ) ; }
1997:
1998:
1999: if (@expr1073751694 Token ::@expr9858 Match (@expr1073751696 parent@var2913 , "[(,{]" ) ) {
2000: ; }
2001: else { if (@expr1073751697 Token ::@expr9874 simpleMatch (@expr1073751699 parent@var2913 , ":" ) ) {
2002: while (@expr1073751700 Token ::@expr9858 Match (@expr1073751702 parent@var2913 , "[?:]" ) ) {
2003: parent@var2913 =@expr1073751703 parent@var2913 .@expr9848 astParent (@expr9849 ) ; }
2004: while (@expr1073751706 Token ::@expr9874 simpleMatch (@expr1073751708 parent@var2913 , "," ) ) {
2005: parent@var2913 =@expr1073751709 parent@var2913 .@expr9848 astParent (@expr9849 ) ; }
2006: if (@expr1073751712 !@expr1073751713 parent@var2913 ||@expr1073751714 parent@var2913 .@expr1073751715 str (@expr1073751716 ) !=@expr1073751717 "(" ) {
2007: return nullptr ; }
2008: } else {
2009: return nullptr ; } }
2010: }
2011:
2012: T * argtok@var2914 ; argtok@var2914 =@expr1073751718 tok@var2911 ;
2013: while (@expr1073751719 argtok@var2914 &&@expr1073751720 argtok@var2914 .@expr9897 astParent (@expr9898 ) &&@expr1073751723 (@expr1073751724 !@expr1073751725 Token ::@expr9858 Match (@expr1073751727 argtok@var2914 .@expr9897 astParent (@expr9898 ) , ",|(|{" ) ||@expr1073751730 argtok@var2914 .@expr9897 astParent (@expr9898 ) .@expr1073751733 isCast (@expr1073751734 ) ) ) {
2014: argtok@var2914 =@expr1073751735 argtok@var2914 .@expr9897 astParent (@expr9898 ) ;
2015: }
2016: if (@expr1073751738 !@expr1073751739 argtok@var2914 ) {
2017: return nullptr ; }
2018: if (@expr1073751740 Token ::@expr9874 simpleMatch (@expr1073751742 argtok@var2914 , "," ) ) {
2019: argtok@var2914 =@expr1073751743 argtok@var2914 .@expr1073751744 astOperand1 (@expr1073751745 ) ; }
2020: if (@expr1073751746 Token ::@expr9874 simpleMatch (@expr1073751748 argtok@var2914 , "(" ) &&@expr1073751749 argtok@var2914 .@expr9926 astOperand2 (@expr9927 ) ) {
2021: argtok@var2914 =@expr1073751752 argtok@var2914 .@expr9926 astOperand2 (@expr9927 ) ; }
2022: tok@var2911 =@expr1073751755 argtok@var2914 ;
2023: while (@expr1073751756 Token ::@expr9858 Match (@expr1073751758 tok@var2911 .@expr9841 astParent (@expr9842 ) , ",|(|{" ) ) {
2024: tok@var2911 =@expr1073751761 tok@var2911 .@expr9841 astParent (@expr9842 ) ;
2025: if (@expr1073751764 Token ::@expr9858 Match (@expr1073751766 tok@var2911 , "(|{" ) ) {
2026: break ; }
2027: }
2028: argn@var2912 =@expr1073751767 getArgumentPos (@expr1073751768 tok@var2911 , argtok@var2914 ) ;
2029: if (@expr1073751769 argn@var2912 ==@expr1073751770 -1 ) {
2030: return nullptr ; }
2031: if (@expr1073751771 !@expr1073751772 Token ::@expr9858 Match (@expr1073751774 tok@var2911 , "{|(" ) ) {
2032: return nullptr ; }
2033: if (@expr1073751775 tok@var2911 .@expr9952 astOperand2 (@expr9953 ) ) {
2034: tok@var2911 =@expr1073751778 tok@var2911 .@expr9955 astOperand1 (@expr9956 ) ; }
2035: while (@expr1073751781 tok@var2911 &&@expr1073751782 (@expr1073751783 tok@var2911 .@expr1073751784 isUnaryOp (@expr1073751785 "*" ) ||@expr1073751786 tok@var2911 .@expr9963 str (@expr9964 ) ==@expr1073751789 "[" ) ) {
2036: tok@var2911 =@expr1073751790 tok@var2911 .@expr9955 astOperand1 (@expr9956 ) ; }
2037: while (@expr1073751793 Token ::@expr9874 simpleMatch (@expr1073751795 tok@var2911 , "." ) ) {
2038: tok@var2911 =@expr1073751796 tok@var2911 .@expr9952 astOperand2 (@expr9953 ) ; }
2039: while (@expr1073751799 Token ::@expr9874 simpleMatch (@expr1073751801 tok@var2911 , "::" ) ) {
2040:
2041: if (@expr1073751802 !@expr1073751803 tok@var2911 .@expr9952 astOperand2 (@expr9953 ) &&@expr1073751806 tok@var2911 .@expr9955 astOperand1 (@expr9956 ) ) {
2042: tok@var2911 =@expr1073751809 tok@var2911 .@expr9955 astOperand1 (@expr9956 ) ;
2043: break ;
2044: }
2045: tok@var2911 =@expr1073751812 tok@var2911 .@expr9952 astOperand2 (@expr9953 ) ;
2046: if (@expr1073751815 Token ::@expr9874 simpleMatch (@expr1073751817 tok@var2911 , "<" ) &&@expr1073751818 tok@var2911 .@expr9995 link (@expr9996 ) ) {
2047: tok@var2911 =@expr1073751821 tok@var2911 .@expr9955 astOperand1 (@expr9956 ) ; }
2048: }
2049: if (@expr1073751824 tok@var2911 &&@expr1073751825 tok@var2911 .@expr9995 link (@expr9996 ) &&@expr1073751828 tok@var2911 .@expr9963 str (@expr9964 ) ==@expr1073751831 ">" ) {
2050: tok@var2911 =@expr1073751832 tok@var2911 .@expr9995 link (@expr9996 ) .@expr1073751835 previous (@expr1073751836 ) ; }
2051: if (@expr1073751837 !@expr1073751838 Token ::@expr9858 Match (@expr1073751840 tok@var2911 , "%name%|(|{" ) ) {
2052: return nullptr ; }
2053:
2054: if (@expr1073751841 Token ::@expr9858 Match (@expr1073751843 tok@var2911 , "%name% :" ) ) {
2055: return nullptr ; }
2056: return tok@var2911 ;
2057: }
2058:
2059: const Token * getTokenArgumentFunction ( const Token * tok@var2915 , int & argn@var2916 ) {
2060: return getTokenArgumentFunctionImpl (@expr1073751844 tok@var2915 , argn@var2916 ) ;
2061: }
2062:
2063: Token * getTokenArgumentFunction ( Token * tok@var2917 , int & argn@var2918 ) {
2064: return getTokenArgumentFunctionImpl (@expr1073751845 tok@var2917 , argn@var2918 ) ;
2065: }
2066:
2067: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var2919 , int argnr@var2920 )
2068: {
2069: std ::@expr1073751846 vector < const Variable *@expr1073751847 > result@var2921 ;
2070: if (@expr1073751848 !@expr1073751849 tok@var2919 ) {
2071: return result@var2921 ; }
2072: if (@expr1073751850 tok@var2919 .@expr10027 function (@expr10028 ) ) {
2073: const Variable * argvar@var2922 ; argvar@var2922 =@expr1073751853 tok@var2919 .@expr10027 function (@expr10028 ) .@expr1073751856 getArgumentVar (@expr1073751857 argnr@var2920 ) ;
2074: if (@expr1073751858 argvar@var2922 ) {
2075: return {@expr1073751859 argvar@var2922 } ; }
2076: else {
2077: return result@var2921 ; }
2078: }
2079: if (@expr1073751860 Token ::@expr1073751861 Match (@expr1073751862 tok@var2919 .@expr1073751863 previous (@expr1073751864 ) , "%type% (|{" ) ||@expr1073751865 Token ::@expr10042 simpleMatch (@expr10043 tok@var2919 , "{" ) ||@expr1073751868 tok@var2919 .@expr10045 variable (@expr10046 ) ) {
2080: const bool constructor@var2923 =@expr1073751871 Token ::@expr10042 simpleMatch (@expr10043 tok@var2919 , "{" ) ||@expr1073751874 (@expr1073751875 tok@var2919 .@expr10045 variable (@expr10046 ) &&@expr1073751878 tok@var2919 .@expr10045 variable (@expr10046 ) .@expr1073751881 nameToken (@expr1073751882 ) ==@expr1073751883 tok@var2919 ) ;
2081: const Type * type@var2924 ; type@var2924 =@expr1073751884 Token ::@expr1073751885 typeOf (@expr1073751886 tok@var2919 ) ;
2082: if (@expr1073751887 !@expr1073751888 type@var2924 ) {
2083: return result@var2921 ; }
2084: const Scope * typeScope@var2925 ; typeScope@var2925 =@expr1073751889 type@var2924 .@expr1073751890 classScope@var2926 ;
2085: if (@expr1073751891 !@expr1073751892 typeScope@var2925 ) {
2086: return result@var2921 ; }
2087:
2088: if (@expr1073751893 Token ::@expr10042 simpleMatch (@expr10043 tok@var2919 , "{" ) &&@expr1073751896 typeScope@var2925 .@expr1073751897 numConstructors@var2927 ==@expr1073751898 0 &&@expr1073751899 argnr@var2920 <@expr1073751900 typeScope@var2925 .@expr10077 varlist@var2928 .@expr1073751902 size (@expr1073751903 ) ) {
2089: auto it@var2929 ; it@var2929 =@expr1073751904 std ::@expr1073751905 next (@expr1073751906 typeScope@var2925 .@expr10077 varlist@var2928 .@expr1073751908 begin (@expr1073751909 ) , argnr@var2920 ) ;
2090: return {@expr1073751910 &@expr1073751911 *@expr1073751912 it@var2929 } ;
2091: }
2092: const int argCount@var2930 =@expr1073751913 numberOfArguments (@expr1073751914 tok@var2919 ) ;
2093: for (@expr1073751915 const Function &@expr1073751916 function@var2931 :@expr1073751917 typeScope@var2925 .@expr1073751918 functionList@var2932 ) {
2094: if (@expr1073751919 function@var2931 .@expr1073751920 argCount (@expr1073751921 ) <@expr1073751922 argCount@var2930 ) {
2095: continue ; }
2096: if (@expr1073751923 constructor@var2923 &&@expr1073751924 !@expr1073751925 function@var2931 .@expr1073751926 isConstructor (@expr1073751927 ) ) {
2097: continue ; }
2098: if (@expr1073751928 !@expr1073751929 constructor@var2923 &&@expr1073751930 !@expr1073751931 Token ::@expr10042 simpleMatch (@expr1073751933 function@var2931 .@expr1073751934 token@var2933 , "operator()" ) ) {
2099: continue ; }
2100: const Variable * argvar@var2934 ; argvar@var2934 =@expr1073751935 function@var2931 .@expr1073751936 getArgumentVar (@expr1073751937 argnr@var2920 ) ;
2101: if (@expr1073751938 argvar@var2934 ) {
2102: result@var2921 .@expr1073751939 push_back (@expr1073751940 argvar@var2934 ) ; }
2103: }
2104: }
2105: return result@var2921 ;
2106: }
2107:
2108: static bool isCPPCastKeyword ( const Token * tok@var2935 )
2109: {
2110: if (@expr1073751941 !@expr1073751942 tok@var2935 ) {
2111: return false ; }
2112: return endsWith (@expr1073751943 tok@var2935 .@expr1073751944 str (@expr1073751945 ) , "_cast" ) ;
2113: }
2114:
2115: static bool isTrivialConstructor ( const Token * tok@var2936 )
2116: {
2117: const Token * typeTok@var2937 ; typeTok@var2937 =@expr1073751946 nullptr ;
2118: const Type * t@var2938 ; t@var2938 =@expr1073751947 Token ::@expr1073751948 typeOf (@expr1073751949 tok@var2936 , &@expr1073751950 typeTok@var2937 ) ;
2119: if (@expr1073751951 t@var2938 ) {
2120: return false ; }
2121: if (@expr1073751952 typeTok@var2937 .@expr10129 valueType (@expr10130 ) &&@expr1073751955 typeTok@var2937 .@expr10129 valueType (@expr10130 ) .@expr1073751958 isPrimitive (@expr1073751959 ) ) {
2122: return true ; }
2123: return false ;
2124: }
2125:
2126: static bool isArray ( const Token * tok@var2939 )
2127: {
2128: if (@expr1073751960 !@expr1073751961 tok@var2939 ) {
2129: return false ; }
2130: if (@expr1073751962 tok@var2939 .@expr10139 variable (@expr10140 ) ) {
2131: return tok@var2939 .@expr10139 variable (@expr10140 ) .@expr1073751967 isArray (@expr1073751968 ) ; }
2132: if (@expr1073751969 Token ::@expr1073751970 simpleMatch (@expr1073751971 tok@var2939 , "." ) ) {
2133: return isArray (@expr1073751972 tok@var2939 .@expr1073751973 astOperand2 (@expr1073751974 ) ) ; }
2134: return false ;
2135: }
2136:
2137: bool isVariableChangedByFunctionCall ( const Token * tok@var2940 , int indirect@var2941 , const Settings * settings@var2942 , bool * inconclusive@var2943 )
2138: {
2139: if (@expr10151 !@expr10152 tok@var2940 ) {
2140: return false ; }
2141:
2142: if (@expr1073751977 Token ::@expr10154 simpleMatch (@expr1073751979 tok@var2940 , "," ) ) {
2143: return false ; }
2144:
2145: const Token * const tok1@var2944 ; tok1@var2944 =@expr1073751980 tok@var2940 ;
2146:
2147:
2148: if (@expr1073751981 tok@var2940 .@expr10158 astParent (@expr10159 ) &&@expr1073751984 tok@var2940 .@expr10158 astParent (@expr10159 ) .@expr1073751987 isUnaryOp (@expr1073751988 "&" ) ) {
2149: indirect@var2941 ++@expr1073751989 ; }
2150:
2151: int argnr@var2945 ;
2152: tok@var2940 =@expr1073751990 getTokenArgumentFunction (@expr1073751991 tok@var2940 , argnr@var2945 ) ;
2153: if (@expr10151 !@expr10152 tok@var2940 ) {
2154: return false ; }
2155: if (@expr1073751994 Token ::@expr10154 simpleMatch (@expr1073751996 tok@var2940 , "{" ) &&@expr1073751997 isTrivialConstructor (@expr1073751998 tok@var2940 ) ) {
2156: return false ; }
2157: if (@expr1073751999 tok@var2940 .@expr1073752000 isKeyword (@expr1073752001 ) &&@expr1073752002 !@expr1073752003 isCPPCastKeyword (@expr1073752004 tok@var2940 ) &&@expr1073752005 tok@var2940 .@expr1073752006 str (@expr1073752007 ) .@expr1073752008 compare (@expr1073752009 0 , 8 , "operator" ) !=@expr1073752010 0 ) {
2158: return false ; }
2159:
2160: if (@expr1073752011 Token ::@expr10188 Match (@expr1073752013 tok@var2940 , "%type% (|{" ) &&@expr1073752014 tok@var2940 .@expr1073752015 tokType (@expr1073752016 ) ==@expr1073752017 Token ::@expr1073752018 eType &&@expr1073752019 astIsPrimitive (@expr1073752020 tok@var2940 .@expr10197 next (@expr10198 ) ) ) {
2161: return false ; }
2162: const Token * parenTok@var2946 ; parenTok@var2946 =@expr1073752023 tok@var2940 .@expr10197 next (@expr10198 ) ;
2163: if (@expr1073752026 Token ::@expr10154 simpleMatch (@expr1073752028 parenTok@var2946 , "<" ) &&@expr1073752029 parenTok@var2946 .@expr10206 link (@expr10207 ) ) {
2164: parenTok@var2946 =@expr1073752032 parenTok@var2946 .@expr10206 link (@expr10207 ) .@expr1073752035 next (@expr1073752036 ) ; }
2165: const bool possiblyPassedByReference@var2947 =@expr1073752037 parenTok@var2946 .@expr1073752038 next (@expr1073752039 ) ==@expr1073752040 tok1@var2944 ||@expr1073752041 Token ::@expr10188 Match (@expr1073752043 tok1@var2944 .@expr1073752044 previous (@expr1073752045 ) , ", %name% [,)}]" ) ;
2166:
2167: if (@expr1073752046 !@expr1073752047 tok@var2940 .@expr1073752048 function (@expr1073752049 ) &&@expr1073752050 !@expr1073752051 tok@var2940 .@expr1073752052 variable (@expr1073752053 ) &&@expr1073752054 Token ::@expr10188 Match (@expr1073752056 tok@var2940 , "%name%" ) ) {
2168: if (@expr1073752057 settings@var2942 ) {
2169: const bool requireInit@var2948 =@expr1073752058 settings@var2942 .@expr10235 library@var2949 .@expr1073752060 isuninitargbad (@expr1073752061 tok@var2940 , 1 +@expr10238 argnr@var2945 ) ;
2170: const bool requireNonNull@var2950 =@expr1073752063 settings@var2942 .@expr10235 library@var2949 .@expr1073752065 isnullargbad (@expr1073752066 tok@var2940 , 1 +@expr10238 argnr@var2945 ) ;
2171:
2172: const Library ::@expr10244 ArgumentChecks ::@expr10244 Direction argDirection@var2951 =@expr1073752070 settings@var2942 .@expr10235 library@var2949 .@expr1073752072 getArgDirection (@expr1073752073 tok@var2940 , 1 +@expr10238 argnr@var2945 ) ;
2173: if (@expr1073752075 argDirection@var2951 ==@expr1073752076 Library ::@expr10253 ArgumentChecks ::@expr10254 Direction ::@expr1073752079 DIR_IN ) {
2174: return false ; }
2175: else { if (@expr1073752080 argDirection@var2951 ==@expr1073752081 Library ::@expr10253 ArgumentChecks ::@expr10254 Direction ::@expr1073752084 DIR_OUT ||@expr1073752085
2176: argDirection@var2951 ==@expr1073752086 Library ::@expr10253 ArgumentChecks ::@expr10254 Direction ::@expr1073752089 DIR_INOUT ) {
2177: if (@expr1073752090 indirect@var2941 ==@expr10267 0 &&@expr1073752092 isArray (@expr1073752093 tok1@var2944 ) ) {
2178: return true ; }
2179:
2180: if (@expr1073752094 indirect@var2941 >@expr10271 0 &&@expr1073752096 requireInit@var2948 &&@expr1073752097 requireNonNull@var2950 ) {
2181: return true ; }
2182: } }
2183:
2184:
2185:
2186: if (@expr1073752098 indirect@var2941 ==@expr10267 0 &&@expr1073752100 requireNonNull@var2950 ) {
2187: return false ; }
2188: }
2189:
2190: if (@expr1073752101 possiblyPassedByReference@var2947 ) {
2191: if (@expr1073752102 inconclusive@var2943 !=@expr1073752103 nullptr ) {
2192: *@expr10280 inconclusive@var2943 =@expr1073752105 true ; }
2193: return false ;
2194: }
2195:
2196: return true ;
2197: }
2198:
2199: std ::@expr1073752106 vector < const Variable *@expr10283 > args@var2952 ; args@var2952 =@expr1073752108 getArgumentVars (@expr1073752109 tok@var2940 , argnr@var2945 ) ;
2200: bool conclusive@var2953 ; conclusive@var2953 =@expr1073752110 false ;
2201: for (@expr1073752111 const Variable *@expr10283 arg@var2954 :@expr1073752113 args@var2952 ) {
2202: if (@expr1073752114 !@expr1073752115 arg@var2954 ) {
2203: continue ; }
2204: conclusive@var2953 =@expr1073752116 true ;
2205: if (@expr1073752117 indirect@var2941 >@expr10271 0 ) {
2206: if (@expr1073752119 !@expr10296 arg@var2954 .@expr10297 isConst (@expr10298 ) &&@expr1073752123 arg@var2954 .@expr10300 isPointer (@expr10301 ) ) {
2207: return true ; }
2208:
2209: if (@expr1073752126 Token ::@expr10154 simpleMatch (@expr1073752128 arg@var2954 .@expr1073752129 typeEndToken (@expr1073752130 ) , "* const" ) ) {
2210: return true ; }
2211: if (@expr1073752131 !@expr1073752132 arg@var2954 .@expr10300 isPointer (@expr10301 ) ) {
2212: return true ; }
2213: }
2214: if (@expr1073752135 !@expr10296 arg@var2954 .@expr10297 isConst (@expr10298 ) &&@expr1073752139 arg@var2954 .@expr1073752140 isReference (@expr1073752141 ) ) {
2215: return true ; }
2216: }
2217: if (@expr1073752142 !@expr1073752143 conclusive@var2953 &&@expr1073752144 inconclusive@var2943 ) {
2218: *@expr10280 inconclusive@var2943 =@expr1073752146 true ;
2219: }
2220: return false ;
2221: }
2222:
2223: bool isVariableChanged ( const Token * tok@var2955 , int indirect@var2956 , const Settings * settings@var2957 , bool cpp@var2958 , int depth@var2959 )
2224: {
2225: if (@expr1073752147 !@expr1073752148 tok@var2955 ) {
2226: return false ; }
2227:
2228: if (@expr1073752149 indirect@var2956 ==@expr10326 0 &&@expr1073752151 isConstVarExpression (@expr1073752152 tok@var2955 ) ) {
2229: return false ; }
2230:
2231: const Token * tok2@var2960 ; tok2@var2960 =@expr1073752153 tok@var2955 ;
2232: int derefs@var2961 ; derefs@var2961 =@expr1073752154 0 ;
2233: while (@expr1073752155 Token ::@expr10332 simpleMatch (@expr1073752157 tok2@var2960 .@expr10334 astParent (@expr10335 ) , "*" ) ||@expr1073752160
2234: (@expr1073752161 Token ::@expr10332 simpleMatch (@expr1073752163 tok2@var2960 .@expr10334 astParent (@expr10335 ) , "." ) &&@expr1073752166 !@expr1073752167 Token ::@expr10332 simpleMatch (@expr1073752169 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) , "(" ) ) ||@expr1073752174
2235: (@expr1073752175 tok2@var2960 .@expr10334 astParent (@expr10335 ) &&@expr10354 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10357 isUnaryOp (@expr10358 "&" ) &&@expr1073752183 !@expr1073752184 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10363 astOperand2 (@expr10364 ) &&@expr1073752189 Token ::@expr10332 simpleMatch (@expr10367 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) , "." ) &&@expr1073752196 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) .@expr10377 originalName (@expr10378 ) ==@expr10379 "->" ) ||@expr1073752204
2236: (@expr1073752205 Token ::@expr10332 simpleMatch (@expr1073752207 tok2@var2960 .@expr10334 astParent (@expr10335 ) , "[" ) &&@expr1073752210 tok2@var2960 ==@expr10387 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10390 astOperand1 (@expr10391 ) ) ) {
2237: if (@expr1073752216 tok2@var2960 .@expr10334 astParent (@expr10335 ) &&@expr1073752219 (@expr1073752220 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10357 isUnaryOp (@expr1073752224 "*" ) ||@expr1073752225 (@expr1073752226 astIsLHS (@expr10403 tok2@var2960 ) &&@expr1073752228 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr1073752231 originalName (@expr1073752232 ) ==@expr1073752233 "->" ) ) ) {
2238: derefs@var2961 ++@expr1073752234 ; }
2239: if (@expr1073752235 derefs@var2961 >@expr1073752236 indirect@var2956 ) {
2240: break ; }
2241: if (@expr1073752237 tok2@var2960 .@expr10334 astParent (@expr10335 ) &&@expr10354 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10357 isUnaryOp (@expr10358 "&" ) &&@expr1073752245 Token ::@expr10332 simpleMatch (@expr10367 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) , "." ) &&@expr1073752252 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) .@expr10377 originalName (@expr10378 ) ==@expr10379 "->" ) {
2242: tok2@var2960 =@expr1073752260 tok2@var2960 .@expr10334 astParent (@expr10335 ) ; }
2243: tok2@var2960 =@expr1073752263 tok2@var2960 .@expr10334 astParent (@expr10335 ) ;
2244: }
2245:
2246: while (@expr1073752266 Token ::@expr10332 simpleMatch (@expr1073752268 tok2@var2960 .@expr10334 astParent (@expr10335 ) , "?" ) ||@expr1073752271 (@expr1073752272 Token ::@expr10332 simpleMatch (@expr10450 tok2@var2960 .@expr10334 astParent (@expr10335 ) , ":" ) &&@expr1073752277 Token ::@expr10332 simpleMatch (@expr1073752279 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) , "?" ) ) ) {
2247: tok2@var2960 =@expr1073752284 tok2@var2960 .@expr10334 astParent (@expr10335 ) ; }
2248:
2249: if (@expr1073752287 Token ::@expr10464 Match (@expr1073752289 tok2@var2960 .@expr10334 astParent (@expr10335 ) , "++|--" ) ) {
2250: return true ; }
2251:
2252: auto skipRedundantPtrOp@var2962 ; skipRedundantPtrOp@var2962 =@expr1073752292 [@expr1073752293 ] (@expr1073752294 const Token *@expr10471 tok@var2963 , const Token *@expr10471 parent@var2964 ) {
2253: const Token * gparent@var2965 ; gparent@var2965 =@expr1073752297 parent@var2964 ?@expr1073752298 parent@var2964 .@expr10475 astParent (@expr10476 ) :@expr1073752301 nullptr ;
2254: while (@expr1073752302 parent@var2964 &&@expr1073752303 gparent@var2965 &&@expr1073752304 (@expr1073752305 (@expr1073752306 parent@var2964 .@expr10483 isUnaryOp (@expr1073752308 "*" ) &&@expr1073752309 gparent@var2965 .@expr10486 isUnaryOp (@expr1073752311 "&" ) ) ||@expr1073752312 (@expr1073752313 parent@var2964 .@expr10483 isUnaryOp (@expr1073752315 "&" ) &&@expr1073752316 gparent@var2965 .@expr10486 isUnaryOp (@expr1073752318 "*" ) ) ) ) {
2255: tok@var2963 =@expr1073752319 gparent@var2965 ;
2256: parent@var2964 =@expr1073752320 gparent@var2965 .@expr1073752321 astParent (@expr1073752322 ) ;
2257: if (@expr1073752323 parent@var2964 ) {
2258: gparent@var2965 =@expr1073752324 parent@var2964 .@expr10475 astParent (@expr10476 ) ; }
2259: }
2260: return tok@var2963 ;
2261: } ;
2262: tok2@var2960 =@expr1073752327 skipRedundantPtrOp@var2962 (@expr1073752328 tok2@var2960 , tok2@var2960 .@expr10334 astParent (@expr10335 ) ) ;
2263:
2264: if (@expr1073752331 tok2@var2960 .@expr10334 astParent (@expr10335 ) &&@expr1073752334 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr1073752337 isAssignmentOp (@expr1073752338 ) ) {
2265: if (@expr1073752339 tok2@var2960 ==@expr10387 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10390 astOperand1 (@expr10391 ) ) {
2266: return true ; }
2267:
2268: const Variable * var@var2966 ; var@var2966 =@expr1073752345 getLHSVariable (@expr1073752346 tok2@var2960 .@expr10334 astParent (@expr10335 ) ) ;
2269: if (@expr1073752349 var@var2966 &&@expr1073752350 var@var2966 .@expr1073752351 isReference (@expr1073752352 ) &&@expr1073752353 !@expr1073752354 var@var2966 .@expr1073752355 isConst (@expr1073752356 ) &&@expr1073752357 var@var2966 .@expr10534 nameToken (@expr10535 ) &&@expr1073752360 var@var2966 .@expr10534 nameToken (@expr10535 ) .@expr1073752363 next (@expr1073752364 ) ==@expr1073752365 tok2@var2960 .@expr10334 astParent (@expr10335 ) ) {
2270: if (@expr1073752368 !@expr1073752369 var@var2966 .@expr1073752370 isLocal (@expr1073752371 ) ||@expr1073752372 isVariableChanged (@expr1073752373 var@var2966 , settings@var2957 , cpp@var2958 , depth@var2959 -@expr10550 1 ) ) {
2271: return true ; }
2272: }
2273: }
2274:
2275: if (@expr1073752375 cpp@var2958 &&@expr1073752376 Token ::@expr10464 Match (@expr1073752378 tok2@var2960 .@expr10334 astParent (@expr10335 ) , ">>|&" ) &&@expr1073752381 astIsRHS (@expr1073752382 tok2@var2960 ) &&@expr1073752383 isLikelyStreamRead (@expr1073752384 cpp@var2958 , tok2@var2960 .@expr10334 astParent (@expr10335 ) ) ) {
2276: return true ; }
2277:
2278: if (@expr1073752387 isLikelyStream (@expr1073752388 cpp@var2958 , tok2@var2960 ) ) {
2279: return true ; }
2280:
2281:
2282: if (@expr1073752389 tok@var2955 .@expr10566 variable (@expr10567 ) &&@expr1073752392 Token ::@expr10464 Match (@expr1073752394 tok2@var2960 .@expr10334 astParent (@expr10335 ) , ". %name%" ) &&@expr1073752397 isFunctionCall (@expr1073752398 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr1073752401 next (@expr1073752402 ) ) &&@expr1073752403 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10390 astOperand1 (@expr10391 ) ==@expr10387 tok2@var2960 ) {
2283: const Variable * var@var2967 ; var@var2967 =@expr1073752409 tok@var2955 .@expr10566 variable (@expr10567 ) ;
2284:
2285: if (@expr1073752412 indirect@var2956 ==@expr10326 0 &&@expr1073752414 astIsPointer (@expr1073752415 tok@var2955 ) ) {
2286: return false ; }
2287: bool isConst@var2968 ; isConst@var2968 =@expr1073752416 var@var2967 &&@expr1073752417 var@var2967 .@expr1073752418 isConst (@expr1073752419 ) ;
2288: if (@expr1073752420 !@expr1073752421 isConst@var2968 ) {
2289: const ValueType * valueType@var2969 ; valueType@var2969 =@expr1073752422 var@var2967 .@expr1073752423 valueType (@expr1073752424 ) ;
2290: isConst@var2968 =@expr1073752425 valueType@var2969 &&@expr1073752426 valueType@var2969 .@expr1073752427 pointer@var2970 ==@expr1073752428 1 &&@expr1073752429 valueType@var2969 .@expr1073752430 constness@var2971 ==@expr1073752431 1 ;
2291: }
2292: if (@expr1073752432 isConst@var2968 ) {
2293: return false ; }
2294:
2295: const Token * ftok@var2972 ; ftok@var2972 =@expr1073752433 tok@var2955 .@expr1073752434 tokAt (@expr1073752435 2 ) ;
2296: if (@expr1073752436 settings@var2957 ) {
2297: return !@expr1073752437 settings@var2957 .@expr1073752438 library@var2973 .@expr1073752439 isFunctionConst (@expr1073752440 ftok@var2972 ) ; }
2298:
2299: const Function * fun@var2974 ; fun@var2974 =@expr1073752441 ftok@var2972 .@expr1073752442 function (@expr1073752443 ) ;
2300: if (@expr1073752444 !@expr1073752445 fun@var2974 ) {
2301: return true ; }
2302: return !@expr1073752446 fun@var2974 .@expr1073752447 isConst (@expr1073752448 ) ;
2303: }
2304:
2305: const Token * ftok@var2975 ; ftok@var2975 =@expr1073752449 tok2@var2960 ;
2306: while (@expr1073752450 ftok@var2975 &&@expr1073752451 (@expr1073752452 !@expr1073752453 Token ::@expr10464 Match (@expr1073752455 ftok@var2975 , "[({]" ) ||@expr1073752456 ftok@var2975 .@expr1073752457 isCast (@expr1073752458 ) ) ) {
2307: ftok@var2975 =@expr1073752459 ftok@var2975 .@expr1073752460 astParent (@expr1073752461 ) ; }
2308:
2309: if (@expr1073752462 ftok@var2975 &&@expr1073752463 Token ::@expr10464 Match (@expr1073752465 ftok@var2975 .@expr1073752466 link (@expr1073752467 ) , ")|} !!{" ) ) {
2310: const Token * ptok@var2976 ; ptok@var2976 =@expr1073752468 tok2@var2960 ;
2311: while (@expr1073752469 Token ::@expr10464 Match (@expr1073752471 ptok@var2976 .@expr10648 astParent (@expr10649 ) , ".|::|[" ) ) {
2312: ptok@var2976 =@expr1073752474 ptok@var2976 .@expr10648 astParent (@expr10649 ) ; }
2313: bool inconclusive@var2977 ; inconclusive@var2977 =@expr1073752477 false ;
2314: bool isChanged@var2978 ; isChanged@var2978 =@expr1073752478 isVariableChangedByFunctionCall (@expr1073752479 ptok@var2976 , indirect@var2956 , settings@var2957 , &@expr1073752480 inconclusive@var2977 ) ;
2315: isChanged@var2978 |=@expr1073752481 inconclusive@var2977 ;
2316: if (@expr1073752482 isChanged@var2978 ) {
2317: return true ; }
2318: }
2319:
2320: const Token * parent@var2979 ; parent@var2979 =@expr1073752483 tok2@var2960 .@expr10334 astParent (@expr10335 ) ;
2321: while (@expr1073752486 Token ::@expr10464 Match (@expr1073752488 parent@var2979 , ".|::" ) ) {
2322: parent@var2979 =@expr1073752489 parent@var2979 .@expr10666 astParent (@expr10667 ) ; }
2323: if (@expr1073752492 parent@var2979 &&@expr1073752493 parent@var2979 .@expr1073752494 tokType (@expr1073752495 ) ==@expr1073752496 Token ::@expr1073752497 eIncDecOp ) {
2324: return true ; }
2325:
2326:
2327: if (@expr1073752498 Token ::@expr10464 Match (@expr1073752500 tok2@var2960 .@expr10334 astParent (@expr10335 ) , ":|=" ) &&@expr1073752503 tok2@var2960 ==@expr1073752504 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10363 astOperand2 (@expr10364 ) &&@expr1073752509 Token ::@expr10332 simpleMatch (@expr1073752511 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10690 previous (@expr10691 ) , "]" ) ) {
2328: const Token * typeStart@var2980 ; typeStart@var2980 =@expr1073752516 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10690 previous (@expr10691 ) .@expr1073752521 link (@expr1073752522 ) .@expr1073752523 previous (@expr1073752524 ) ;
2329: if (@expr1073752525 Token ::@expr10332 simpleMatch (@expr1073752527 typeStart@var2980 , "&" ) ) {
2330: typeStart@var2980 =@expr1073752528 typeStart@var2980 .@expr10705 previous (@expr10706 ) ; }
2331: if (@expr1073752531 typeStart@var2980 &&@expr1073752532 Token ::@expr10464 Match (@expr1073752534 typeStart@var2980 .@expr10705 previous (@expr10706 ) , "[;{}(] auto &| [" ) ) {
2332: for (@expr1073752537 const Token *@expr10471 vartok@var2981 =@expr1073752539 typeStart@var2980 .@expr1073752540 tokAt (@expr1073752541 2 ) ; vartok@var2981 !=@expr1073752542 tok2@var2960 ; vartok@var2981 =@expr1073752543 vartok@var2981 .@expr1073752544 next (@expr1073752545 ) ) {
2333: if (@expr1073752546 vartok@var2981 .@expr1073752547 varId (@expr1073752548 ) ) {
2334: const Variable * refvar@var2982 ; refvar@var2982 =@expr1073752549 vartok@var2981 .@expr1073752550 variable (@expr1073752551 ) ;
2335: if (@expr1073752552 !@expr1073752553 refvar@var2982 ||@expr1073752554 (@expr1073752555 !@expr1073752556 refvar@var2982 .@expr1073752557 isConst (@expr1073752558 ) &&@expr1073752559 refvar@var2982 .@expr1073752560 isReference (@expr1073752561 ) ) ) {
2336: return true ; }
2337: }
2338: }
2339: }
2340: }
2341:
2342: if (@expr1073752562 Token ::@expr10332 simpleMatch (@expr10450 tok2@var2960 .@expr10334 astParent (@expr10335 ) , ":" ) &&@expr1073752567 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) &&@expr1073752572 Token ::@expr10332 simpleMatch (@expr1073752574 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10348 astParent (@expr10349 ) .@expr1073752579 previous (@expr1073752580 ) , "for (" ) ) {
2343:
2344: if (@expr1073752581 astIsLHS (@expr10403 tok2@var2960 ) ) {
2345: return true ; }
2346: const Token * varTok@var2983 ; varTok@var2983 =@expr1073752583 tok2@var2960 .@expr10334 astParent (@expr10335 ) .@expr10690 previous (@expr10691 ) ;
2347: if (@expr1073752588 !@expr1073752589 varTok@var2983 ) {
2348: return false ; }
2349: const Variable * loopVar@var2984 ; loopVar@var2984 =@expr1073752590 varTok@var2983 .@expr1073752591 variable (@expr1073752592 ) ;
2350: if (@expr1073752593 !@expr1073752594 loopVar@var2984 ) {
2351: return false ; }
2352: if (@expr1073752595 !@expr1073752596 loopVar@var2984 .@expr1073752597 isConst (@expr1073752598 ) &&@expr1073752599 loopVar@var2984 .@expr1073752600 isReference (@expr1073752601 ) &&@expr1073752602 isVariableChanged (@expr1073752603 loopVar@var2984 , settings@var2957 , cpp@var2958 , depth@var2959 -@expr10550 1 ) ) {
2353: return true ; }
2354: return false ;
2355: }
2356:
2357: if (@expr1073752605 indirect@var2956 >@expr1073752606 0 ) {
2358:
2359: parent@var2979 =@expr1073752607 tok2@var2960 .@expr10334 astParent (@expr10335 ) ;
2360: while (@expr1073752610 parent@var2979 &&@expr1073752611 parent@var2979 .@expr1073752612 isArithmeticalOp (@expr1073752613 ) &&@expr1073752614 parent@var2979 .@expr1073752615 isBinaryOp (@expr1073752616 ) ) {
2361: parent@var2979 =@expr1073752617 parent@var2979 .@expr10666 astParent (@expr10667 ) ;
2362: }
2363: if (@expr1073752620 Token ::@expr10332 simpleMatch (@expr1073752622 parent@var2979 , "*" ) ) {
2364: if (@expr1073752623 parent@var2979 .@expr10666 astParent (@expr10667 ) &&@expr1073752626 parent@var2979 .@expr10666 astParent (@expr10667 ) .@expr1073752629 isAssignmentOp (@expr1073752630 ) &&@expr1073752631
2365: (@expr1073752632 parent@var2979 .@expr10666 astParent (@expr10667 ) .@expr1073752635 astOperand1 (@expr1073752636 ) ==@expr1073752637 parent@var2979 ) ) {
2366: return true ;
2367: }
2368: }
2369: }
2370:
2371: return false ;
2372: }
2373:
2374: bool isVariableChanged ( const Token * start@var2985 , const Token * end@var2986 , const int exprid@var2987 , bool globalvar@var2988 , const Settings * settings@var2989 , bool cpp@var2990 , int depth@var2991 )
2375: {
2376: return findVariableChanged (@expr1073752638 start@var2985 , end@var2986 , 0 , exprid@var2987 , globalvar@var2988 , settings@var2989 , cpp@var2990 , depth@var2991 ) !=@expr1073752639 nullptr ;
2377: }
2378:
2379: bool isVariableChanged ( const Token * start@var2992 , const Token * end@var2993 , int indirect@var2994 , const int exprid@var2995 , bool globalvar@var2996 , const Settings * settings@var2997 , bool cpp@var2998 , int depth@var2999 )
2380: {
2381: return findVariableChanged (@expr1073752640 start@var2992 , end@var2993 , indirect@var2994 , exprid@var2995 , globalvar@var2996 , settings@var2997 , cpp@var2998 , depth@var2999 ) !=@expr1073752641 nullptr ;
2382: }
2383:
2384: const Token * findExpression ( const Token * start@var3000 , const int exprid@var3001 )
2385: {
2386: Function * f@var3002 ; f@var3002 =@expr1073752642 Scope ::@expr1073752643 nestedInFunction (@expr1073752644 start@var3000 .@expr1073752645 scope (@expr1073752646 ) ) ;
2387: if (@expr1073752647 !@expr1073752648 f@var3002 ) {
2388: return nullptr ; }
2389: const Scope * scope@var3003 ; scope@var3003 =@expr1073752649 f@var3002 .@expr1073752650 functionScope@var3004 ;
2390: if (@expr1073752651 !@expr1073752652 scope@var3003 ) {
2391: return nullptr ; }
2392: for (@expr1073752653 const Token *@expr1073752654 tok@var3005 =@expr1073752655 scope@var3003 .@expr1073752656 bodyStart@var3006 ; tok@var3005 !=@expr1073752657 scope@var3003 .@expr1073752658 bodyEnd@var3007 ; tok@var3005 =@expr1073752659 tok@var3005 .@expr1073752660 next (@expr1073752661 ) ) {
2393: if (@expr1073752662 tok@var3005 .@expr1073752663 exprId (@expr1073752664 ) !=@expr1073752665 exprid@var3001 ) {
2394: continue ; }
2395: return tok@var3005 ;
2396: }
2397: return nullptr ;
2398: }
2399:
2400:
2401: template < class F , class R = decltype ( std :: declval < F > ( ) ( ) ) >
2402: static std :: function < R ( ) > memoize ( F f@var3008 )
2403: {
2404: bool init@var3009 ; init@var3009 =@expr1073752666 false ;
2405: R result@var3010 {@expr1073752667 } ;
2406: return [@expr1073752668 =@expr1073752669 ] (@expr1073752670 ) mutable .@expr1073752671 R {
2407: if (@expr1073752672 init@var3009 ) {
2408: return result@var3010 ; }
2409: result@var3010 =@expr1073752673 f@var3008 (@expr1073752674 ) ;
2410: init@var3009 =@expr1073752675 true ;
2411: return result@var3010 ;
2412: } ;
2413: }
2414:
2415: template < class F ,
2416: $class $= $typename $std $:: $enable_if $< std :: is_convertible < decltype ( std :: declval < F > ( ) ( ) ) , const Token * > $:: $value $> $:: $type
2417: >
2418: static bool isExpressionChangedAt ( const F & getExprTok@var3011 ,
2419: const Token * tok@var3012 ,
2420: int indirect@var3013 ,
2421: const int exprid@var3014 ,
2422: bool globalvar@var3015 ,
2423: const Settings * settings@var3016 ,
2424: bool cpp@var3017 ,
2425: int depth@var3018 )
2426: {
2427: if (@expr1073752676 depth@var3018 <@expr1073752677 0 ) {
2428: return true ; }
2429: if (@expr1073752678 tok@var3012 .@expr1073752679 exprId (@expr1073752680 ) !=@expr1073752681 exprid@var3014 ) {
2430: if (@expr1073752682 globalvar@var3015 &&@expr1073752683 !@expr1073752684 tok@var3012 .@expr1073752685 isKeyword (@expr1073752686 ) &&@expr1073752687 Token ::@expr10864 Match (@expr1073752689 tok@var3012 , "%name% (" ) &&@expr1073752690 !@expr1073752691 (@expr1073752692 tok@var3012 .@expr10869 function (@expr10870 ) &&@expr1073752695 tok@var3012 .@expr10869 function (@expr10870 ) .@expr1073752698 isAttributePure (@expr1073752699 ) ) ) {
2431:
2432: return true ; }
2433: const bool pointer@var3019 =@expr1073752700 astIsPointer (@expr1073752701 tok@var3012 ) ;
2434: bool aliased@var3020 ; aliased@var3020 =@expr1073752702 false ;
2435:
2436: if (@expr1073752703 !@expr1073752704 getExprTok@var3011 (@expr10881 ) ) {
2437: aliased@var3020 =@expr1073752706 true ; }
2438: if (@expr10883 !@expr10884 aliased@var3020 ) {
2439: aliased@var3020 =@expr1073752709 findAstNode (@expr1073752710 getExprTok@var3011 (@expr10881 ) , [@expr1073752712 &@expr10889 ] (@expr1073752714 const Token *@expr10891 childTok@var3021 ) {
2440: for (@expr1073752716 const ValueFlow ::@expr1073752717 Value &@expr10889 val@var3022 :@expr1073752719 tok@var3012 .@expr1073752720 values (@expr1073752721 ) ) {
2441: if (@expr1073752722 val@var3022 .@expr1073752723 isImpossible (@expr1073752724 ) ) {
2442: continue ; }
2443: if (@expr1073752725 val@var3022 .@expr1073752726 isLocalLifetimeValue (@expr1073752727 ) ||@expr1073752728 (@expr1073752729 pointer@var3019 &&@expr1073752730 val@var3022 .@expr1073752731 isSymbolicValue (@expr1073752732 ) &&@expr1073752733 val@var3022 .@expr1073752734 intvalue@var3023 ==@expr1073752735 0 ) ) {
2444: if (@expr1073752736 findAstNode (@expr1073752737 val@var3022 .@expr1073752738 tokvalue@var3024 ,
2445: [@expr1073752739 &@expr10889 ] (@expr1073752741 const Token *@expr10891 aliasTok@var3025 ) {
2446: return aliasTok@var3025 .@expr1073752743 exprId (@expr1073752744 ) ==@expr1073752745 childTok@var3021 .@expr1073752746 exprId (@expr1073752747 ) ;
2447: } ) ) {
2448: return true ; }
2449: }
2450: }
2451: return false ;
2452: } ) ;
2453: }
2454: if (@expr10883 !@expr10884 aliased@var3020 ) {
2455: return false ; }
2456: if (@expr1073752750 isVariableChanged (@expr1073752751 tok@var3012 , 1 , settings@var3016 , cpp@var3017 , depth@var3018 ) ) {
2457: return true ; }
2458:
2459: if (@expr1073752752 Token ::@expr10864 Match (@expr1073752754 tok@var3012 , "%var% (" ) ) {
2460: return true ; }
2461: return false ;
2462: }
2463: return (@expr1073752755 isVariableChanged (@expr1073752756 tok@var3012 , indirect@var3013 , settings@var3016 , cpp@var3017 , depth@var3018 ) ) ;
2464: }
2465:
2466: bool isExpressionChangedAt ( const Token * expr@var3026 ,
2467: const Token * tok@var3027 ,
2468: int indirect@var3028 ,
2469: bool globalvar@var3029 ,
2470: const Settings * settings@var3030 ,
2471: bool cpp@var3031 ,
2472: int depth@var3032 )
2473: {
2474: return isExpressionChangedAt (@expr1073752757 [@expr1073752758 &@expr1073752759 ] {
2475: return expr@var3026 ;
2476: } , tok@var3027 , indirect@var3028 , expr@var3026 .@expr1073752760 exprId (@expr1073752761 ) , globalvar@var3029 , settings@var3030 , cpp@var3031 , depth@var3032 ) ;
2477: }
2478:
2479: Token * findVariableChanged ( Token * start@var3033 , const Token * end@var3034 , int indirect@var3035 , const int exprid@var3036 , bool globalvar@var3037 , const Settings * settings@var3038 , bool cpp@var3039 , int depth@var3040 )
2480: {
2481: if (@expr1073752762 !@expr1073752763 precedes (@expr1073752764 start@var3033 , end@var3034 ) ) {
2482: return nullptr ; }
2483: if (@expr1073752765 depth@var3040 <@expr1073752766 0 ) {
2484: return start@var3033 ; }
2485: auto getExprTok@var3041 ; getExprTok@var3041 =@expr1073752767 memoize (@expr1073752768 [@expr1073752769 &@expr1073752770 ] {
2486: return findExpression (@expr1073752771 start@var3033 , exprid@var3036 ) ;
2487: } ) ;
2488: for (@expr1073752772 Token *@expr1073752773 tok@var3042 =@expr1073752774 start@var3033 ; tok@var3042 !=@expr1073752775 end@var3034 ; tok@var3042 =@expr1073752776 tok@var3042 .@expr1073752777 next (@expr1073752778 ) ) {
2489: if (@expr1073752779 isExpressionChangedAt (@expr1073752780 getExprTok@var3041 , tok@var3042 , indirect@var3035 , exprid@var3036 , globalvar@var3037 , settings@var3038 , cpp@var3039 , depth@var3040 ) ) {
2490: return tok@var3042 ; }
2491: }
2492: return nullptr ;
2493: }
2494:
2495: const Token * findVariableChanged ( const Token * start@var3043 , const Token * end@var3044 , int indirect@var3045 , const int exprid@var3046 , bool globalvar@var3047 , const Settings * settings@var3048 , bool cpp@var3049 , int depth@var3050 )
2496: {
2497: return findVariableChanged (@expr1073752781 const_cast < Token *@expr1073752782 > (@expr1073752783 start@var3043 ) , end@var3044 , indirect@var3045 , exprid@var3046 , globalvar@var3047 , settings@var3048 , cpp@var3049 , depth@var3050 ) ;
2498: }
2499:
2500: bool isVariableChanged ( const Variable * var@var3051 , const Settings * settings@var3052 , bool cpp@var3053 , int depth@var3054 )
2501: {
2502: if (@expr1073752784 !@expr1073752785 var@var3051 ) {
2503: return false ; }
2504: if (@expr1073752786 !@expr1073752787 var@var3051 .@expr10964 scope (@expr10965 ) ) {
2505: return false ; }
2506: const Token * start@var3055 ; start@var3055 =@expr1073752790 var@var3051 .@expr1073752791 declEndToken (@expr1073752792 ) ;
2507: if (@expr1073752793 !@expr1073752794 start@var3055 ) {
2508: return false ; }
2509: if (@expr1073752795 Token ::@expr1073752796 Match (@expr1073752797 start@var3055 , "; %varid% =" , var@var3051 .@expr1073752798 declarationId (@expr1073752799 ) ) ) {
2510: start@var3055 =@expr1073752800 start@var3055 .@expr1073752801 tokAt (@expr1073752802 2 ) ; }
2511: return isExpressionChanged (@expr1073752803 var@var3051 .@expr1073752804 nameToken (@expr1073752805 ) , start@var3055 .@expr1073752806 next (@expr1073752807 ) , var@var3051 .@expr10964 scope (@expr10965 ) .@expr1073752810 bodyEnd@var3320 , settings@var3052 , cpp@var3053 , depth@var3054 ) ;
2512: }
2513:
2514: bool isVariablesChanged ( const Token * start@var3056 ,
2515: const Token * end@var3057 ,
2516: int indirect@var3058 ,
2517: std :: vector < const Variable * > vars@var3059 ,
2518: const Settings * settings@var3060 ,
2519: bool cpp@var3061 )
2520: {
2521: std ::@expr1073752811 set < int > varids@var3062 ;
2522: std ::@expr1073752812 transform (@expr1073752813 vars@var3059 .@expr10990 begin (@expr10991 ) , vars@var3059 .@expr10992 end (@expr10993 ) , std ::@expr1073752818 inserter (@expr1073752819 varids@var3062 , varids@var3062 .@expr1073752820 begin (@expr1073752821 ) ) , [@expr1073752822 ] (@expr1073752823 const Variable *@expr11000 var@var3063 ) {
2523: return var@var3063 .@expr1073752825 declarationId (@expr1073752826 ) ;
2524: } ) ;
2525: const bool globalvar@var3064 =@expr1073752827 std ::@expr1073752828 any_of (@expr1073752829 vars@var3059 .@expr10990 begin (@expr10991 ) , vars@var3059 .@expr10992 end (@expr10993 ) , [@expr1073752834 ] (@expr1073752835 const Variable *@expr11000 var@var3065 ) {
2526: return var@var3065 .@expr1073752837 isGlobal (@expr1073752838 ) ;
2527: } ) ;
2528: for (@expr1073752839 const Token *@expr11000 tok@var3066 =@expr1073752841 start@var3056 ; tok@var3066 !=@expr1073752842 end@var3057 ; tok@var3066 =@expr1073752843 tok@var3066 .@expr1073752844 next (@expr1073752845 ) ) {
2529: if (@expr1073752846 tok@var3066 .@expr11023 varId (@expr11024 ) ==@expr1073752849 0 ||@expr1073752850 varids@var3062 .@expr1073752851 count (@expr1073752852 tok@var3066 .@expr11023 varId (@expr11024 ) ) ==@expr1073752855 0 ) {
2530: if (@expr1073752856 globalvar@var3064 &&@expr1073752857 Token ::@expr1073752858 Match (@expr1073752859 tok@var3066 , "%name% (" ) ) {
2531:
2532: return true ; }
2533: continue ;
2534: }
2535: if (@expr1073752860 isVariableChanged (@expr1073752861 tok@var3066 , indirect@var3058 , settings@var3060 , cpp@var3061 ) ) {
2536: return true ; }
2537: }
2538: return false ;
2539: }
2540:
2541: bool isThisChanged ( const Token * tok@var3067 , int indirect@var3068 , const Settings * settings@var3069 , bool cpp@var3070 )
2542: {
2543: if (@expr1073752862 (@expr1073752863 Token ::@expr11040 Match (@expr1073752865 tok@var3067 .@expr11042 previous (@expr11043 ) , "%name% (" ) &&@expr1073752868 !@expr1073752869 Token ::@expr1073752870 simpleMatch (@expr1073752871 tok@var3067 .@expr1073752872 astOperand1 (@expr1073752873 ) , "." ) ) ||@expr1073752874
2544: Token ::@expr11040 Match (@expr1073752876 tok@var3067 .@expr1073752877 tokAt (@expr1073752878 -3 ) , "this . %name% (" ) ) {
2545: if (@expr1073752879 tok@var3067 .@expr11042 previous (@expr11043 ) .@expr11058 function (@expr11059 ) ) {
2546: return (@expr1073752884 !@expr1073752885 tok@var3067 .@expr11042 previous (@expr11043 ) .@expr11058 function (@expr11059 ) .@expr1073752890 isConst (@expr1073752891 ) ) ;
2547: } else { if (@expr1073752892 !@expr1073752893 tok@var3067 .@expr11042 previous (@expr11043 ) .@expr1073752896 isKeyword (@expr1073752897 ) ) {
2548: return true ;
2549: } }
2550: }
2551: if (@expr1073752898 isVariableChanged (@expr1073752899 tok@var3067 , indirect@var3068 , settings@var3069 , cpp@var3070 ) ) {
2552: return true ; }
2553: return false ;
2554: }
2555:
2556: bool isThisChanged ( const Token * start@var3071 , const Token * end@var3072 , int indirect@var3073 , const Settings * settings@var3074 , bool cpp@var3075 )
2557: {
2558: if (@expr1073752900 !@expr1073752901 precedes (@expr1073752902 start@var3071 , end@var3072 ) ) {
2559: return false ; }
2560: for (@expr1073752903 const Token *@expr1073752904 tok@var3076 =@expr1073752905 start@var3071 ; tok@var3076 !=@expr1073752906 end@var3072 ; tok@var3076 =@expr1073752907 tok@var3076 .@expr1073752908 next (@expr1073752909 ) ) {
2561: if (@expr1073752910 !@expr1073752911 exprDependsOnThis (@expr1073752912 tok@var3076 ) ) {
2562: continue ; }
2563: if (@expr1073752913 isThisChanged (@expr1073752914 tok@var3076 , indirect@var3073 , settings@var3074 , cpp@var3075 ) ) {
2564: return true ; }
2565: }
2566: return false ;
2567: }
2568:
2569: bool isExpressionChanged ( const Token * expr@var3077 , const Token * start@var3078 , const Token * end@var3079 , const Settings * settings@var3080 , bool cpp@var3081 , int depth@var3082 )
2570: {
2571: if (@expr1073752915 depth@var3082 <@expr1073752916 0 ) {
2572: return true ; }
2573: if (@expr1073752917 !@expr1073752918 precedes (@expr1073752919 start@var3078 , end@var3079 ) ) {
2574: return false ; }
2575: const Token * result@var3083 ; result@var3083 =@expr1073752920 findAstNode (@expr1073752921 expr@var3077 , [@expr1073752922 &@expr1073752923 ] (@expr1073752924 const Token *@expr11101 tok@var3084 ) {
2576: if (@expr1073752926 exprDependsOnThis (@expr1073752927 tok@var3084 ) &&@expr1073752928 isThisChanged (@expr1073752929 start@var3078 , end@var3079 , false , settings@var3080 , cpp@var3081 ) ) {
2577: return true ;
2578: }
2579: bool global@var3085 ; global@var3085 =@expr1073752930 false ;
2580: if (@expr1073752931 tok@var3084 .@expr11108 variable (@expr11109 ) ) {
2581: if (@expr1073752934 tok@var3084 .@expr11108 variable (@expr11109 ) .@expr1073752937 isConst (@expr1073752938 ) ) {
2582: return false ; }
2583: global@var3085 =@expr1073752939 !@expr1073752940 tok@var3084 .@expr11108 variable (@expr11109 ) .@expr1073752943 isLocal (@expr1073752944 ) &&@expr1073752945 !@expr1073752946 tok@var3084 .@expr11108 variable (@expr11109 ) .@expr1073752949 isArgument (@expr1073752950 ) ;
2584: } else { if (@expr1073752951 tok@var3084 .@expr1073752952 isIncompleteVar (@expr1073752953 ) &&@expr1073752954 !@expr1073752955 tok@var3084 .@expr1073752956 isIncompleteConstant (@expr1073752957 ) ) {
2585: global@var3085 =@expr1073752958 true ;
2586: } }
2587:
2588: if (@expr1073752959 tok@var3084 .@expr1073752960 exprId (@expr1073752961 ) >@expr1073752962 0 ) {
2589: for (@expr1073752963 const Token *@expr11101 tok2@var3086 =@expr1073752965 start@var3078 ; tok2@var3086 !=@expr1073752966 end@var3079 ; tok2@var3086 =@expr1073752967 tok2@var3086 .@expr1073752968 next (@expr1073752969 ) ) {
2590: if (@expr1073752970 isExpressionChangedAt (@expr1073752971
2591: tok@var3084 , tok2@var3086 , tok@var3084 .@expr11148 valueType (@expr11149 ) ?@expr1073752974 tok@var3084 .@expr11148 valueType (@expr11149 ) .@expr1073752977 pointer@var3315 :@expr1073752978 0 , global@var3085 , settings@var3080 , cpp@var3081 , depth@var3082 ) ) {
2592: return true ; }
2593: }
2594: }
2595: return false ;
2596: } ) ;
2597: return result@var3083 ;
2598: }
2599:
2600: const Token * getArgumentStart ( const Token * ftok@var3087 )
2601: {
2602: const Token * tok@var3088 ; tok@var3088 =@expr1073752979 ftok@var3087 ;
2603: if (@expr1073752980 Token ::@expr11157 Match (@expr1073752982 tok@var3088 , "%name% (|{" ) ) {
2604: tok@var3088 =@expr1073752983 ftok@var3087 .@expr1073752984 next (@expr1073752985 ) ; }
2605: if (@expr1073752986 !@expr1073752987 Token ::@expr11157 Match (@expr1073752989 tok@var3088 , "(|{|[" ) ) {
2606: return nullptr ; }
2607: const Token * startTok@var3089 ; startTok@var3089 =@expr1073752990 tok@var3088 .@expr1073752991 astOperand2 (@expr1073752992 ) ;
2608: if (@expr1073752993 !@expr1073752994 startTok@var3089 &&@expr1073752995 tok@var3088 .@expr1073752996 next (@expr1073752997 ) !=@expr1073752998 tok@var3088 .@expr1073752999 link (@expr1073753000 ) ) {
2609: startTok@var3089 =@expr1073753001 tok@var3088 .@expr1073753002 astOperand1 (@expr1073753003 ) ; }
2610: return startTok@var3089 ;
2611: }
2612:
2613: int numberOfArguments ( const Token * ftok@var3090 ) {
2614: return astCount (@expr1073753004 getArgumentStart (@expr1073753005 ftok@var3090 ) , "," ) ;
2615: }
2616:
2617: int numberOfArgumentsWithoutAst ( const Token * start@var3091 )
2618: {
2619: int arguments@var3092 ; arguments@var3092 =@expr1073753006 0 ;
2620: const Token * const openBracket@var3093 ; openBracket@var3093 =@expr1073753007 start@var3091 .@expr1073753008 next (@expr1073753009 ) ;
2621: if (@expr1073753010 openBracket@var3093 &&@expr1073753011 openBracket@var3093 .@expr1073753012 str (@expr1073753013 ) ==@expr1073753014 "(" &&@expr1073753015 openBracket@var3093 .@expr11192 next (@expr11193 ) &&@expr1073753018 openBracket@var3093 .@expr11192 next (@expr11193 ) .@expr1073753021 str (@expr1073753022 ) !=@expr1073753023 ")" ) {
2622: const Token * argument@var3094 ; argument@var3094 =@expr1073753024 openBracket@var3093 .@expr11192 next (@expr11193 ) ;
2623: while (@expr1073753027 argument@var3094 ) {
2624: ++@expr1073753028 arguments@var3092 ;
2625: argument@var3094 =@expr1073753029 argument@var3094 .@expr1073753030 nextArgument (@expr1073753031 ) ;
2626: }
2627: }
2628: return arguments@var3092 ;
2629: }
2630:
2631: std :: vector < const Token * > getArguments ( const Token * ftok@var3095 ) {
2632: return astFlatten (@expr1073753032 getArgumentStart (@expr1073753033 ftok@var3095 ) , "," ) ;
2633: }
2634:
2635: int getArgumentPos ( const Variable * var@var3096 , const Function * f@var3097 )
2636: {
2637: auto arg_it@var3098 ; arg_it@var3098 =@expr1073753034 std ::@expr1073753035 find_if (@expr1073753036 f@var3097 .@expr11213 argumentList@var3099 .@expr11214 begin (@expr11215 ) , f@var3097 .@expr11213 argumentList@var3099 .@expr11217 end (@expr11218 ) , [@expr1073753043 &@expr11220 ] (@expr1073753045 const Variable &@expr11220 v@var3100 ) {
2638: return v@var3100 .@expr1073753047 nameToken (@expr1073753048 ) ==@expr1073753049 var@var3096 .@expr1073753050 nameToken (@expr1073753051 ) ;
2639: } ) ;
2640: if (@expr1073753052 arg_it@var3098 ==@expr1073753053 f@var3097 .@expr11213 argumentList@var3099 .@expr11217 end (@expr11218 ) ) {
2641: return -1 ; }
2642: return std ::@expr1073753057 distance (@expr1073753058 f@var3097 .@expr11213 argumentList@var3099 .@expr11214 begin (@expr11215 ) , arg_it@var3098 ) ;
2643: }
2644:
2645: bool isIteratorPair ( std :: vector < const Token * > args@var3101 )
2646: {
2647: return args@var3101 .@expr1073753062 size (@expr1073753063 ) ==@expr1073753064 2 &&@expr1073753065
2648: (@expr1073753066 (@expr1073753067 astIsIterator (@expr1073753068 args@var3101 [@expr11245 0 ] ) &&@expr1073753070 astIsIterator (@expr1073753071 args@var3101 [@expr11248 1 ] ) ) ||@expr1073753073 (@expr1073753074 astIsPointer (@expr1073753075 args@var3101 [@expr11245 0 ] ) &&@expr1073753077 astIsPointer (@expr1073753078 args@var3101 [@expr11248 1 ] ) ) ) ;
2649: }
2650:
2651: const Token * findLambdaStartToken ( const Token * last@var3102 )
2652: {
2653: if (@expr1073753080 !@expr1073753081 last@var3102 ||@expr1073753082 last@var3102 .@expr1073753083 str (@expr1073753084 ) !=@expr1073753085 "}" ) {
2654: return nullptr ; }
2655: const Token * tok@var3103 ; tok@var3103 =@expr1073753086 last@var3102 .@expr1073753087 link (@expr1073753088 ) ;
2656: if (@expr1073753089 Token ::@expr11266 simpleMatch (@expr1073753091 tok@var3103 .@expr11268 astParent (@expr11269 ) , "(" ) ) {
2657: tok@var3103 =@expr1073753094 tok@var3103 .@expr11268 astParent (@expr11269 ) ; }
2658: if (@expr1073753097 Token ::@expr11266 simpleMatch (@expr1073753099 tok@var3103 .@expr11268 astParent (@expr11269 ) , "[" ) ) {
2659: return tok@var3103 .@expr11268 astParent (@expr11269 ) ; }
2660: return nullptr ;
2661: }
2662:
2663: template < class T >
2664: T * findLambdaEndTokenGeneric ( T * first@var3104 )
2665: {
2666: if (@expr1073753104 !@expr1073753105 first@var3104 ||@expr1073753106 first@var3104 .@expr1073753107 str (@expr1073753108 ) !=@expr1073753109 "[" ) {
2667: return nullptr ; }
2668: if (@expr1073753110 !@expr1073753111 Token ::@expr1073753112 Match (@expr1073753113 first@var3104 .@expr11290 link (@expr11291 ) , "] (|{" ) ) {
2669: return nullptr ; }
2670: if (@expr1073753116 first@var3104 .@expr1073753117 astOperand1 (@expr1073753118 ) !=@expr1073753119 first@var3104 .@expr11290 link (@expr11291 ) .@expr1073753122 next (@expr1073753123 ) ) {
2671: return nullptr ; }
2672: const Token * tok@var3105 ; tok@var3105 =@expr1073753124 first@var3104 ;
2673:
2674: if (@expr1073753125 tok@var3105 .@expr11302 astOperand1 (@expr11303 ) &&@expr1073753128 tok@var3105 .@expr11302 astOperand1 (@expr11303 ) .@expr11307 str (@expr11308 ) ==@expr1073753133 "(" ) {
2675: tok@var3105 =@expr1073753134 tok@var3105 .@expr11302 astOperand1 (@expr11303 ) ; }
2676: if (@expr1073753137 tok@var3105 .@expr11302 astOperand1 (@expr11303 ) &&@expr1073753140 tok@var3105 .@expr11302 astOperand1 (@expr11303 ) .@expr11307 str (@expr11308 ) ==@expr1073753145 "{" ) {
2677: return tok@var3105 .@expr11302 astOperand1 (@expr11303 ) .@expr1073753148 link (@expr1073753149 ) ; }
2678: return nullptr ;
2679: }
2680:
2681: const Token * findLambdaEndToken ( const Token * first@var3106 )
2682: {
2683: return findLambdaEndTokenGeneric (@expr1073753150 first@var3106 ) ;
2684: }
2685: Token * findLambdaEndToken ( Token * first@var3107 )
2686: {
2687: return findLambdaEndTokenGeneric (@expr1073753151 first@var3107 ) ;
2688: }
2689:
2690: bool isLikelyStream ( bool cpp@var3108 , const Token * stream@var3109 )
2691: {
2692: if (@expr1073753152 !@expr1073753153 cpp@var3108 ) {
2693: return false ; }
2694:
2695: if (@expr1073753154 !@expr1073753155 stream@var3109 ) {
2696: return false ; }
2697:
2698: if (@expr1073753156 !@expr1073753157 Token ::@expr1073753158 Match (@expr1073753159 stream@var3109 .@expr11336 astParent (@expr11337 ) , "&|<<|>>" ) ||@expr1073753162 !@expr1073753163 stream@var3109 .@expr11336 astParent (@expr11337 ) .@expr1073753166 isBinaryOp (@expr1073753167 ) ) {
2699: return false ; }
2700:
2701: if (@expr1073753168 stream@var3109 .@expr11336 astParent (@expr11337 ) .@expr1073753171 astOperand1 (@expr1073753172 ) !=@expr1073753173 stream@var3109 ) {
2702: return false ; }
2703:
2704: return !@expr1073753174 astIsIntegral (@expr1073753175 stream@var3109 , false ) ;
2705: }
2706:
2707: bool isLikelyStreamRead ( bool cpp@var3110 , const Token * op@var3111 )
2708: {
2709: if (@expr1073753176 !@expr1073753177 cpp@var3110 ) {
2710: return false ; }
2711:
2712: if (@expr1073753178 !@expr1073753179 Token ::@expr11356 Match (@expr1073753181 op@var3111 , "&|>>" ) ||@expr1073753182 !@expr1073753183 op@var3111 .@expr1073753184 isBinaryOp (@expr1073753185 ) ) {
2713: return false ; }
2714:
2715: if (@expr1073753186 !@expr1073753187 Token ::@expr11356 Match (@expr1073753189 op@var3111 .@expr11366 astOperand2 (@expr11367 ) , "%name%|.|*|[" ) &&@expr1073753192 op@var3111 .@expr11369 str (@expr11370 ) !=@expr1073753195 op@var3111 .@expr11366 astOperand2 (@expr11367 ) .@expr1073753198 str (@expr1073753199 ) ) {
2716: return false ; }
2717:
2718: const Token * parent@var3112 ; parent@var3112 =@expr1073753200 op@var3111 ;
2719: while (@expr1073753201 parent@var3112 .@expr11378 astParent (@expr11379 ) &&@expr1073753204 parent@var3112 .@expr11378 astParent (@expr11379 ) .@expr1073753207 str (@expr1073753208 ) ==@expr1073753209 op@var3111 .@expr11369 str (@expr11370 ) ) {
2720: parent@var3112 =@expr1073753212 parent@var3112 .@expr11378 astParent (@expr11379 ) ; }
2721: if (@expr1073753215 parent@var3112 .@expr11378 astParent (@expr11379 ) &&@expr1073753218 !@expr1073753219 Token ::@expr11356 Match (@expr1073753221 parent@var3112 .@expr11378 astParent (@expr11379 ) , "%oror%|&&|(|,|.|!|;" ) ) {
2722: return false ; }
2723: if (@expr1073753224 op@var3111 .@expr11369 str (@expr11370 ) ==@expr1073753227 "&" &&@expr1073753228 parent@var3112 .@expr11378 astParent (@expr11379 ) ) {
2724: return false ; }
2725: if (@expr1073753231 !@expr1073753232 parent@var3112 .@expr11409 astOperand1 (@expr11410 ) ||@expr1073753235 !@expr1073753236 parent@var3112 .@expr1073753237 astOperand2 (@expr1073753238 ) ) {
2726: return false ; }
2727: return (@expr1073753239 !@expr1073753240 parent@var3112 .@expr11409 astOperand1 (@expr11410 ) .@expr11419 valueType (@expr11420 ) ||@expr1073753245 !@expr1073753246 parent@var3112 .@expr11409 astOperand1 (@expr11410 ) .@expr11419 valueType (@expr11420 ) .@expr1073753251 isIntegral (@expr1073753252 ) ) ;
2728: }
2729:
2730: bool isCPPCast ( const Token * tok@var3113 )
2731: {
2732: return tok@var3113 &&@expr1073753253 Token ::@expr1073753254 simpleMatch (@expr1073753255 tok@var3113 .@expr1073753256 previous (@expr1073753257 ) , "> (" ) &&@expr1073753258 tok@var3113 .@expr1073753259 astOperand2 (@expr1073753260 ) &&@expr1073753261 tok@var3113 .@expr11438 astOperand1 (@expr11439 ) &&@expr1073753264 isCPPCastKeyword (@expr1073753265 tok@var3113 .@expr11438 astOperand1 (@expr11439 ) ) ;
2733: }
2734:
2735: bool isConstVarExpression ( const Token * tok@var3114 , const char * skipMatch@var3115 )
2736: {
2737: if (@expr1073753268 !@expr1073753269 tok@var3114 ) {
2738: return false ; }
2739: if (@expr1073753270 tok@var3114 .@expr11447 str (@expr11448 ) ==@expr1073753273 "?" &&@expr1073753274 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) &&@expr1073753277 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) .@expr1073753280 str (@expr1073753281 ) ==@expr1073753282 ":" ) {
2740: return isConstVarExpression (@expr1073753283 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) .@expr1073753286 astOperand1 (@expr1073753287 ) ) &&@expr1073753288 isConstVarExpression (@expr1073753289 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) .@expr1073753292 astOperand2 (@expr1073753293 ) ) ; }
2741: if (@expr1073753294 skipMatch@var3115 &&@expr1073753295 Token ::@expr11472 Match (@expr1073753297 tok@var3114 , skipMatch@var3115 ) ) {
2742: return false ; }
2743: if (@expr1073753298 Token ::@expr11475 simpleMatch (@expr1073753300 tok@var3114 .@expr11477 previous (@expr11478 ) , "sizeof (" ) ) {
2744: return true ; }
2745: if (@expr1073753303 Token ::@expr11472 Match (@expr1073753305 tok@var3114 .@expr11477 previous (@expr11478 ) , "%name% (" ) ) {
2746: if (@expr1073753308 Token ::@expr11475 simpleMatch (@expr1073753310 tok@var3114 .@expr11487 astOperand1 (@expr11488 ) , "." ) &&@expr1073753313 !@expr11490 isConstVarExpression (@expr11491 tok@var3114 .@expr11487 astOperand1 (@expr11488 ) , skipMatch@var3115 ) ) {
2747: return false ; }
2748: std ::@expr1073753318 vector < const Token *@expr11495 > args@var3116 ; args@var3116 =@expr1073753320 getArguments (@expr1073753321 tok@var3114 ) ;
2749: return std ::@expr1073753322 all_of (@expr1073753323 args@var3116 .@expr1073753324 begin (@expr1073753325 ) , args@var3116 .@expr1073753326 end (@expr1073753327 ) , [@expr1073753328 &@expr1073753329 ] (@expr1073753330 const Token *@expr11495 t@var3117 ) {
2750: return isConstVarExpression (@expr1073753332 t@var3117 , skipMatch@var3115 ) ;
2751: } ) ;
2752: }
2753: if (@expr1073753333 isCPPCast (@expr1073753334 tok@var3114 ) ) {
2754: return isConstVarExpression (@expr11511 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) , skipMatch@var3115 ) ;
2755: }
2756: if (@expr1073753338 Token ::@expr11472 Match (@expr1073753340 tok@var3114 , "( %type%" ) ) {
2757: return isConstVarExpression (@expr11491 tok@var3114 .@expr11487 astOperand1 (@expr11488 ) , skipMatch@var3115 ) ; }
2758: if (@expr1073753344 tok@var3114 .@expr11447 str (@expr11448 ) ==@expr1073753347 "::" &&@expr1073753348 tok@var3114 .@expr1073753349 hasKnownValue (@expr1073753350 ) ) {
2759: return isConstVarExpression (@expr11511 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) , skipMatch@var3115 ) ; }
2760: if (@expr1073753354 Token ::@expr11472 Match (@expr1073753356 tok@var3114 , "%cop%|[|." ) ) {
2761: if (@expr1073753357 tok@var3114 .@expr11487 astOperand1 (@expr11488 ) &&@expr1073753360 !@expr11490 isConstVarExpression (@expr11491 tok@var3114 .@expr11487 astOperand1 (@expr11488 ) , skipMatch@var3115 ) ) {
2762: return false ; }
2763: if (@expr1073753365 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) &&@expr1073753368 !@expr1073753369 isConstVarExpression (@expr11511 tok@var3114 .@expr11451 astOperand2 (@expr11452 ) , skipMatch@var3115 ) ) {
2764: return false ; }
2765: return true ;
2766: }
2767: if (@expr1073753373 Token ::@expr11472 Match (@expr1073753375 tok@var3114 , "%bool%|%num%|%str%|%char%|nullptr|NULL" ) ) {
2768: return true ; }
2769: if (@expr1073753376 tok@var3114 .@expr1073753377 isEnumerator (@expr1073753378 ) ) {
2770: return true ; }
2771: if (@expr1073753379 tok@var3114 .@expr11556 variable (@expr11557 ) ) {
2772: return tok@var3114 .@expr11556 variable (@expr11557 ) .@expr1073753384 isConst (@expr1073753385 ) &&@expr1073753386 tok@var3114 .@expr11556 variable (@expr11557 ) .@expr11565 nameToken (@expr11566 ) &&@expr1073753391 tok@var3114 .@expr11556 variable (@expr11557 ) .@expr11565 nameToken (@expr11566 ) .@expr1073753396 hasKnownValue (@expr1073753397 ) ; }
2773: return false ;
2774: }
2775:
2776: static void getLHSVariablesRecursive ( std :: vector < const Variable * > & vars@var3118 , const Token * tok@var3119 )
2777: {
2778: if (@expr1073753398 !@expr1073753399 tok@var3119 ) {
2779: return ; }
2780: if (@expr1073753400 vars@var3118 .@expr11577 empty (@expr11578 ) &&@expr1073753403 Token ::@expr11580 Match (@expr1073753405 tok@var3119 , "*|&|&&|[" ) ) {
2781: getLHSVariablesRecursive (@expr11582 vars@var3118 , tok@var3119 .@expr11583 astOperand1 (@expr11584 ) ) ;
2782: if (@expr1073753409 !@expr1073753410 vars@var3118 .@expr11577 empty (@expr11578 ) ||@expr1073753413 Token ::@expr11590 simpleMatch (@expr1073753415 tok@var3119 , "[" ) ) {
2783: return ; }
2784: getLHSVariablesRecursive (@expr11592 vars@var3118 , tok@var3119 .@expr11593 astOperand2 (@expr11594 ) ) ;
2785: } else { if (@expr1073753419 Token ::@expr11580 Match (@expr1073753421 tok@var3119 .@expr1073753422 previous (@expr1073753423 ) , "this . %var%" ) ) {
2786: getLHSVariablesRecursive (@expr1073753424 vars@var3118 , tok@var3119 .@expr1073753425 next (@expr1073753426 ) ) ;
2787: } else { if (@expr1073753427 Token ::@expr11590 simpleMatch (@expr1073753429 tok@var3119 , "." ) ) {
2788: getLHSVariablesRecursive (@expr11582 vars@var3118 , tok@var3119 .@expr11583 astOperand1 (@expr11584 ) ) ;
2789: getLHSVariablesRecursive (@expr11592 vars@var3118 , tok@var3119 .@expr11593 astOperand2 (@expr11594 ) ) ;
2790: } else { if (@expr1073753436 Token ::@expr11590 simpleMatch (@expr1073753438 tok@var3119 , "::" ) ) {
2791: getLHSVariablesRecursive (@expr11592 vars@var3118 , tok@var3119 .@expr11593 astOperand2 (@expr11594 ) ) ;
2792: } else { if (@expr1073753442 tok@var3119 .@expr11619 variable (@expr11620 ) ) {
2793: vars@var3118 .@expr1073753445 push_back (@expr1073753446 tok@var3119 .@expr11619 variable (@expr11620 ) ) ;
2794: } } } } }
2795: }
2796:
2797: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var3120 )
2798: {
2799: std ::@expr1073753449 vector < const Variable *@expr1073753450 > result@var3121 ;
2800: if (@expr1073753451 !@expr1073753452 Token ::@expr1073753453 Match (@expr1073753454 tok@var3120 , "%assign%|(|{" ) ) {
2801: return result@var3121 ; }
2802: if (@expr1073753455 !@expr1073753456 tok@var3120 .@expr11633 astOperand1 (@expr11634 ) ) {
2803: return result@var3121 ; }
2804: if (@expr1073753459 tok@var3120 .@expr11633 astOperand1 (@expr11634 ) .@expr1073753462 varId (@expr1073753463 ) >@expr1073753464 0 &&@expr1073753465 tok@var3120 .@expr11633 astOperand1 (@expr11634 ) .@expr11644 variable (@expr11645 ) ) {
2805: return {@expr1073753470 tok@var3120 .@expr11633 astOperand1 (@expr11634 ) .@expr11644 variable (@expr11645 ) } ; }
2806: getLHSVariablesRecursive (@expr1073753475 result@var3121 , tok@var3120 .@expr11633 astOperand1 (@expr11634 ) ) ;
2807: return result@var3121 ;
2808: }
2809:
2810: static const Token * getLHSVariableRecursive ( const Token * tok@var3122 )
2811: {
2812: if (@expr1073753478 !@expr1073753479 tok@var3122 ) {
2813: return nullptr ; }
2814: if (@expr1073753480 Token ::@expr11657 Match (@expr1073753482 tok@var3122 , "*|&|&&|[" ) ) {
2815: const Token * vartok@var3123 ; vartok@var3123 =@expr1073753483 getLHSVariableRecursive (@expr1073753484 tok@var3122 .@expr1073753485 astOperand1 (@expr1073753486 ) ) ;
2816: if (@expr1073753487 (@expr1073753488 vartok@var3123 &&@expr1073753489 vartok@var3123 .@expr1073753490 variable (@expr1073753491 ) ) ||@expr1073753492 Token ::@expr1073753493 simpleMatch (@expr1073753494 tok@var3122 , "[" ) ) {
2817: return vartok@var3123 ; }
2818: return getLHSVariableRecursive (@expr1073753495 tok@var3122 .@expr1073753496 astOperand2 (@expr1073753497 ) ) ;
2819: }
2820: if (@expr1073753498 Token ::@expr11657 Match (@expr1073753500 tok@var3122 .@expr1073753501 previous (@expr1073753502 ) , "this . %var%" ) ) {
2821: return tok@var3122 .@expr1073753503 next (@expr1073753504 ) ; }
2822: return tok@var3122 ;
2823: }
2824:
2825: const Variable * getLHSVariable ( const Token * tok@var3124 )
2826: {
2827: if (@expr1073753505 !@expr1073753506 Token ::@expr1073753507 Match (@expr1073753508 tok@var3124 , "%assign%" ) ) {
2828: return nullptr ; }
2829: if (@expr1073753509 !@expr1073753510 tok@var3124 .@expr11687 astOperand1 (@expr11688 ) ) {
2830: return nullptr ; }
2831: if (@expr1073753513 tok@var3124 .@expr11687 astOperand1 (@expr11688 ) .@expr1073753516 varId (@expr1073753517 ) >@expr1073753518 0 &&@expr1073753519 tok@var3124 .@expr11687 astOperand1 (@expr11688 ) .@expr11698 variable (@expr11699 ) ) {
2832: return tok@var3124 .@expr11687 astOperand1 (@expr11688 ) .@expr11698 variable (@expr11699 ) ; }
2833: const Token * vartok@var3125 ; vartok@var3125 =@expr1073753528 getLHSVariableRecursive (@expr1073753529 tok@var3124 .@expr11687 astOperand1 (@expr11688 ) ) ;
2834: if (@expr1073753532 !@expr1073753533 vartok@var3125 ) {
2835: return nullptr ; }
2836: return vartok@var3125 .@expr1073753534 variable (@expr1073753535 ) ;
2837: }
2838:
2839: const Token * getLHSVariableToken ( const Token * tok@var3126 )
2840: {
2841: if (@expr1073753536 !@expr1073753537 Token ::@expr1073753538 Match (@expr1073753539 tok@var3126 , "%assign%" ) ) {
2842: return nullptr ; }
2843: if (@expr1073753540 !@expr1073753541 tok@var3126 .@expr11718 astOperand1 (@expr11719 ) ) {
2844: return nullptr ; }
2845: if (@expr1073753544 tok@var3126 .@expr11718 astOperand1 (@expr11719 ) .@expr1073753547 varId (@expr1073753548 ) >@expr1073753549 0 ) {
2846: return tok@var3126 .@expr11718 astOperand1 (@expr11719 ) ; }
2847: const Token * vartok@var3127 ; vartok@var3127 =@expr1073753552 getLHSVariableRecursive (@expr1073753553 tok@var3126 .@expr11718 astOperand1 (@expr11719 ) ) ;
2848: if (@expr1073753556 vartok@var3127 &&@expr1073753557 vartok@var3127 .@expr11734 variable (@expr11735 ) &&@expr1073753560 vartok@var3127 .@expr11734 variable (@expr11735 ) .@expr1073753563 nameToken (@expr1073753564 ) ==@expr1073753565 vartok@var3127 ) {
2849: return vartok@var3127 ; }
2850: return tok@var3126 .@expr11718 astOperand1 (@expr11719 ) ;
2851: }
2852:
2853: const Token * findAllocFuncCallToken ( const Token * expr@var3128 , const Library & library@var3129 )
2854: {
2855: if (@expr1073753568 !@expr1073753569 expr@var3128 ) {
2856: return nullptr ; }
2857: if (@expr1073753570 Token ::@expr11747 Match (@expr1073753572 expr@var3128 , "[+-]" ) ) {
2858: const Token * tok1@var3130 ; tok1@var3130 =@expr1073753573 findAllocFuncCallToken (@expr1073753574 expr@var3128 .@expr11751 astOperand1 (@expr11752 ) , library@var3129 ) ;
2859: return tok1@var3130 ?@expr1073753577 tok1@var3130 :@expr1073753578 findAllocFuncCallToken (@expr1073753579 expr@var3128 .@expr11756 astOperand2 (@expr11757 ) , library@var3129 ) ;
2860: }
2861: if (@expr1073753582 expr@var3128 .@expr1073753583 isCast (@expr1073753584 ) ) {
2862: return findAllocFuncCallToken (@expr1073753585 expr@var3128 .@expr11756 astOperand2 (@expr11757 ) ?@expr1073753588 expr@var3128 .@expr11756 astOperand2 (@expr11757 ) :@expr1073753591 expr@var3128 .@expr11751 astOperand1 (@expr11752 ) , library@var3129 ) ; }
2863: if (@expr1073753594 Token ::@expr11747 Match (@expr1073753596 expr@var3128 .@expr1073753597 previous (@expr1073753598 ) , "%name% (" ) &&@expr1073753599 library@var3129 .@expr1073753600 getAllocFuncInfo (@expr1073753601 expr@var3128 .@expr11751 astOperand1 (@expr11752 ) ) ) {
2864: return expr@var3128 .@expr11751 astOperand1 (@expr11752 ) ; }
2865: return (@expr1073753606 Token ::@expr1073753607 simpleMatch (@expr1073753608 expr@var3128 , "new" ) &&@expr1073753609 expr@var3128 .@expr11751 astOperand1 (@expr11752 ) ) ?@expr1073753612 expr@var3128 :@expr1073753613 nullptr ;
2866: }
2867:
2868: static bool nonLocal ( const Variable * var@var3131 , bool deref@var3132 )
2869: {
2870: return !@expr1073753614 var@var3131 ||@expr1073753615 (@expr1073753616 !@expr1073753617 var@var3131 .@expr1073753618 isLocal (@expr1073753619 ) &&@expr1073753620 !@expr1073753621 var@var3131 .@expr11798 isArgument (@expr11799 ) ) ||@expr1073753624 (@expr1073753625 deref@var3132 &&@expr1073753626 var@var3131 .@expr11798 isArgument (@expr11799 ) &&@expr1073753629 var@var3131 .@expr1073753630 isPointer (@expr1073753631 ) ) ||@expr1073753632 var@var3131 .@expr1073753633 isStatic (@expr1073753634 ) ||@expr1073753635 var@var3131 .@expr1073753636 isReference (@expr1073753637 ) ||@expr1073753638 var@var3131 .@expr1073753639 isExtern (@expr1073753640 ) ;
2871: }
2872:
2873: static bool hasGccCompoundStatement ( const Token * tok@var3133 )
2874: {
2875: if (@expr1073753641 !@expr1073753642 tok@var3133 ) {
2876: return false ; }
2877: if (@expr1073753643 tok@var3133 .@expr1073753644 str (@expr1073753645 ) ==@expr1073753646 "{" &&@expr1073753647 Token ::@expr1073753648 simpleMatch (@expr1073753649 tok@var3133 .@expr1073753650 previous (@expr1073753651 ) , "( {" ) ) {
2878: return true ; }
2879: return hasGccCompoundStatement (@expr1073753652 tok@var3133 .@expr1073753653 astOperand1 (@expr1073753654 ) ) ||@expr1073753655 hasGccCompoundStatement (@expr1073753656 tok@var3133 .@expr1073753657 astOperand2 (@expr1073753658 ) ) ;
2880: }
2881:
2882: static bool hasFunctionCall ( const Token * tok@var3134 )
2883: {
2884: if (@expr1073753659 !@expr1073753660 tok@var3134 ) {
2885: return false ; }
2886: if (@expr1073753661 Token ::@expr1073753662 Match (@expr1073753663 tok@var3134 , "%name% (" ) ) {
2887:
2888: return true ; }
2889: return hasFunctionCall (@expr1073753664 tok@var3134 .@expr1073753665 astOperand1 (@expr1073753666 ) ) ||@expr1073753667 hasFunctionCall (@expr1073753668 tok@var3134 .@expr1073753669 astOperand2 (@expr1073753670 ) ) ;
2890: }
2891:
2892: static bool isUnchanged ( const Token * startToken@var3135 , const Token * endToken@var3136 , const std :: set < int > & exprVarIds@var3137 , bool local@var3138 )
2893: {
2894: for (@expr1073753671 const Token *@expr1073753672 tok@var3139 =@expr1073753673 startToken@var3135 ; tok@var3139 !=@expr1073753674 endToken@var3136 ; tok@var3139 =@expr1073753675 tok@var3139 .@expr1073753676 next (@expr1073753677 ) ) {
2895: if (@expr1073753678 !@expr1073753679 local@var3138 &&@expr1073753680 Token ::@expr1073753681 Match (@expr1073753682 tok@var3139 , "%name% (" ) &&@expr1073753683 !@expr1073753684 Token ::@expr1073753685 simpleMatch (@expr1073753686 tok@var3139 .@expr1073753687 linkAt (@expr1073753688 1 ) , ") {" ) ) {
2896:
2897: return false ; }
2898: if (@expr1073753689 tok@var3139 .@expr11866 varId (@expr11867 ) ==@expr1073753692 0 ||@expr1073753693 exprVarIds@var3137 .@expr1073753694 find (@expr1073753695 tok@var3139 .@expr11866 varId (@expr11867 ) ) ==@expr1073753698 exprVarIds@var3137 .@expr1073753699 end (@expr1073753700 ) ) {
2899: continue ; }
2900: const Token * parent@var3140 ; parent@var3140 =@expr1073753701 tok@var3139 ;
2901: while (@expr1073753702 parent@var3140 .@expr11879 astParent (@expr11880 ) &&@expr1073753705 !@expr1073753706 parent@var3140 .@expr11879 astParent (@expr11880 ) .@expr11885 isAssignmentOp (@expr11886 ) &&@expr1073753711 parent@var3140 .@expr11879 astParent (@expr11880 ) .@expr11890 tokType (@expr11891 ) !=@expr1073753716 Token ::@expr11893 Type ::@expr11894 eIncDecOp ) {
2902: if (@expr1073753719 parent@var3140 .@expr1073753720 str (@expr1073753721 ) ==@expr1073753722 "," ||@expr1073753723 parent@var3140 .@expr1073753724 isUnaryOp (@expr1073753725 "&" ) ) {
2903:
2904: return false ; }
2905: parent@var3140 =@expr1073753726 parent@var3140 .@expr11879 astParent (@expr11880 ) ;
2906: }
2907: if (@expr1073753729 parent@var3140 .@expr11879 astParent (@expr11880 ) ) {
2908: if (@expr1073753732 parent@var3140 .@expr11879 astParent (@expr11880 ) .@expr11890 tokType (@expr11891 ) ==@expr1073753737 Token ::@expr11893 Type ::@expr11894 eIncDecOp ) {
2909: return false ; }
2910: else { if (@expr1073753740 parent@var3140 .@expr11879 astParent (@expr11880 ) .@expr11885 isAssignmentOp (@expr11886 ) &&@expr1073753745 parent@var3140 ==@expr1073753746 parent@var3140 .@expr11879 astParent (@expr11880 ) .@expr1073753749 astOperand1 (@expr1073753750 ) ) {
2911: return false ; } }
2912: }
2913: }
2914: return true ;
2915: }
2916:
2917: bool isNullOperand ( const Token * expr@var3141 )
2918: {
2919: if (@expr1073753751 !@expr1073753752 expr@var3141 ) {
2920: return false ; }
2921: if (@expr1073753753 Token ::@expr11930 Match (@expr1073753755 expr@var3141 , "static_cast|const_cast|dynamic_cast|reinterpret_cast <" ) ) {
2922: expr@var3141 =@expr1073753756 expr@var3141 .@expr1073753757 astParent (@expr1073753758 ) ; }
2923: else { if (@expr1073753759 !@expr1073753760 expr@var3141 .@expr1073753761 isCast (@expr1073753762 ) ) {
2924: return Token ::@expr11930 Match (@expr1073753764 expr@var3141 , "NULL|nullptr" ) ; } }
2925: if (@expr1073753765 expr@var3141 .@expr11942 valueType (@expr11943 ) &&@expr1073753768 expr@var3141 .@expr11942 valueType (@expr11943 ) .@expr1073753771 pointer@var3315 ==@expr1073753772 0 ) {
2926: return false ; }
2927: const Token * castOp@var3142 ; castOp@var3142 =@expr1073753773 expr@var3141 .@expr11950 astOperand2 (@expr11951 ) ?@expr1073753776 expr@var3141 .@expr11950 astOperand2 (@expr11951 ) :@expr1073753779 expr@var3141 .@expr1073753780 astOperand1 (@expr1073753781 ) ;
2928: return Token ::@expr11930 Match (@expr1073753783 castOp@var3142 , "NULL|nullptr" ) ||@expr1073753784 (@expr1073753785 MathLib ::@expr1073753786 isInt (@expr1073753787 castOp@var3142 .@expr11964 str (@expr11965 ) ) &&@expr1073753790 MathLib ::@expr1073753791 isNullValue (@expr1073753792 castOp@var3142 .@expr11964 str (@expr11965 ) ) ) ;
2929: }
2930:
2931: bool isGlobalData ( const Token * expr@var3143 , bool cpp@var3144 )
2932: {
2933:
2934: if (@expr1073753795 expr@var3143 &&@expr1073753796 expr@var3143 .@expr1073753797 str (@expr1073753798 ) ==@expr1073753799 "(" &&@expr1073753800 expr@var3143 .@expr11977 valueType (@expr11978 ) &&@expr1073753803 expr@var3143 .@expr11977 valueType (@expr11978 ) .@expr1073753806 reference@var3319 !=@expr1073753807 Reference ::@expr1073753808 None ) {
2935: if (@expr1073753809 expr@var3143 .@expr1073753810 isBinaryOp (@expr1073753811 ) ) {
2936: return true ; }
2937: if (@expr1073753812 expr@var3143 .@expr11989 astOperand1 (@expr11990 ) &&@expr1073753815 precedes (@expr1073753816 expr@var3143 .@expr11989 astOperand1 (@expr11990 ) , expr@var3143 ) ) {
2938: return true ; }
2939: }
2940:
2941: bool globalData@var3145 ; globalData@var3145 =@expr1073753819 false ;
2942: bool var@var3146 ; var@var3146 =@expr1073753820 false ;
2943: visitAstNodes (@expr1073753821 expr@var3143 ,
2944: [@expr1073753822 expr@var3143 , cpp@var3144 , &@expr1073753823 globalData@var3145 , &@expr1073753824 var@var3146 ] (@expr1073753825 const Token *@expr1073753826 tok@var3147 ) {
2945: if (@expr1073753827 tok@var3147 .@expr12004 varId (@expr12005 ) ) {
2946: var@var3146 =@expr1073753830 true ; }
2947: if (@expr1073753831 tok@var3147 .@expr12004 varId (@expr12005 ) &&@expr1073753834 !@expr1073753835 tok@var3147 .@expr12012 variable (@expr12013 ) ) {
2948:
2949: globalData@var3145 =@expr1073753838 true ;
2950: return ChildrenToVisit ::@expr12015 none ;
2951: }
2952: if (@expr1073753840 tok@var3147 .@expr1073753841 originalName (@expr1073753842 ) ==@expr1073753843 "->" ) {
2953:
2954: globalData@var3145 =@expr1073753844 true ;
2955: return ChildrenToVisit ::@expr12015 none ;
2956: } else { if (@expr1073753846 Token ::@expr12023 Match (@expr1073753848 tok@var3147 , "[*[]" ) &&@expr1073753849 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) &&@expr1073753852 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) .@expr12031 variable (@expr12032 ) ) {
2957:
2958: const Variable * lhsvar@var3148 ; lhsvar@var3148 =@expr1073753857 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) .@expr12031 variable (@expr12032 ) ;
2959: const ValueType * lhstype@var3149 ; lhstype@var3149 =@expr1073753862 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) .@expr12041 valueType (@expr12042 ) ;
2960: if (@expr1073753867 lhsvar@var3148 .@expr1073753868 isPointer (@expr1073753869 ) ) {
2961: globalData@var3145 =@expr1073753870 true ;
2962: return ChildrenToVisit ::@expr12015 none ;
2963: } else { if (@expr1073753872 lhsvar@var3148 .@expr12049 isArgument (@expr12050 ) &&@expr1073753875 lhsvar@var3148 .@expr1073753876 isArray (@expr1073753877 ) ) {
2964: globalData@var3145 =@expr1073753878 true ;
2965: return ChildrenToVisit ::@expr12015 none ;
2966: } else { if (@expr1073753880 lhsvar@var3148 .@expr12049 isArgument (@expr12050 ) &&@expr1073753883 (@expr1073753884 !@expr1073753885 lhstype@var3149 ||@expr1073753886 (@expr1073753887 lhstype@var3149 .@expr1073753888 type@var3150 <=@expr1073753889 ValueType ::@expr1073753890 Type ::@expr1073753891 VOID &&@expr1073753892 !@expr1073753893 lhstype@var3149 .@expr1073753894 container@var3151 ) ) ) {
2967: globalData@var3145 =@expr1073753895 true ;
2968: return ChildrenToVisit ::@expr12015 none ;
2969: } } }
2970: } }
2971: if (@expr1073753897 tok@var3147 .@expr12004 varId (@expr12005 ) ==@expr1073753900 0 &&@expr1073753901 tok@var3147 .@expr1073753902 isName (@expr1073753903 ) &&@expr1073753904 tok@var3147 .@expr12081 previous (@expr12082 ) .@expr12083 str (@expr12084 ) !=@expr12085 "." ) {
2972: globalData@var3145 =@expr1073753910 true ;
2973: return ChildrenToVisit ::@expr12015 none ;
2974: }
2975: if (@expr1073753912 tok@var3147 .@expr12012 variable (@expr12013 ) ) {
2976:
2977: if (@expr1073753915 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753918 isReference (@expr1073753919 ) &&@expr1073753920 tok@var3147 !=@expr1073753921 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753924 nameToken (@expr1073753925 ) ) {
2978: globalData@var3145 =@expr1073753926 true ;
2979: return ChildrenToVisit ::@expr12015 none ;
2980: }
2981: if (@expr1073753928 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753931 isExtern (@expr1073753932 ) ) {
2982: globalData@var3145 =@expr1073753933 true ;
2983: return ChildrenToVisit ::@expr12015 none ;
2984: }
2985: if (@expr1073753935 tok@var3147 .@expr12081 previous (@expr12082 ) .@expr12083 str (@expr12084 ) !=@expr12085 "." &&@expr1073753941 !@expr1073753942 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753945 isLocal (@expr1073753946 ) &&@expr1073753947 !@expr1073753948 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr12127 isArgument (@expr12128 ) ) {
2986: globalData@var3145 =@expr1073753953 true ;
2987: return ChildrenToVisit ::@expr12015 none ;
2988: }
2989: if (@expr1073753955 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr12127 isArgument (@expr12128 ) &&@expr1073753960 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753963 isPointer (@expr1073753964 ) &&@expr1073753965 tok@var3147 !=@expr1073753966 expr@var3143 ) {
2990: globalData@var3145 =@expr1073753967 true ;
2991: return ChildrenToVisit ::@expr12015 none ;
2992: }
2993: if (@expr1073753969 tok@var3147 .@expr12012 variable (@expr12013 ) .@expr1073753972 isPointerArray (@expr1073753973 ) ) {
2994: globalData@var3145 =@expr1073753974 true ;
2995: return ChildrenToVisit ::@expr12015 none ;
2996: }
2997: }
2998:
2999: if (@expr1073753976 cpp@var3144 &&@expr1073753977 tok@var3147 .@expr1073753978 str (@expr1073753979 ) ==@expr1073753980 "." &&@expr1073753981 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) &&@expr1073753984 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) .@expr12031 variable (@expr12032 ) &&@expr1073753989 !@expr1073753990 tok@var3147 .@expr12026 astOperand1 (@expr12027 ) .@expr12041 valueType (@expr12042 ) ) {
3000: globalData@var3145 =@expr1073753995 true ;
3001: return ChildrenToVisit ::@expr12015 none ;
3002: }
3003: if (@expr1073753997 Token ::@expr12023 Match (@expr1073753999 tok@var3147 , ".|[" ) ) {
3004: return ChildrenToVisit ::@expr1073754000 op1 ; }
3005: return ChildrenToVisit ::@expr1073754001 op1_and_op2 ;
3006: } ) ;
3007: return globalData@var3145 ||@expr1073754002 !@expr1073754003 var@var3146 ;
3008: }
3009:
3010: struct FwdAnalysis :: Result FwdAnalysis :: checkRecursive ( const Token * expr@var3152 , const Token * startToken@var3153 , const Token * endToken@var3154 , const std :: set < int > & exprVarIds@var3155 , bool local@var3156 , bool inInnerClass@var3157 , int depth@var3158 )
3011: {
3012:
3013: if (@expr1073754015 ++@expr1073754016 depth@var3158 >@expr1073754017 1000 ) {
3014: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3015:
3016: for (@expr1073754021 const Token *@expr12198 tok@var3159 =@expr1073754023 startToken@var3153 ; precedes (@expr1073754024 tok@var3159 , endToken@var3154 ) ; tok@var3159 =@expr1073754025 tok@var3159 .@expr12202 next (@expr12203 ) ) {
3017: if (@expr1073754028 Token ::@expr12205 simpleMatch (@expr1073754030 tok@var3159 , "try {" ) ) {
3018:
3019: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ;
3020: }
3021:
3022: if (@expr1073754034 Token ::@expr12205 simpleMatch (@expr1073754036 tok@var3159 , "break ;" ) ) {
3023: return Result (@expr1073754037 Result ::@expr12195 Type ::@expr12215 BREAK@expr12181 , tok@var3159 ) ;
3024: }
3025:
3026: if (@expr1073754040 Token ::@expr12205 simpleMatch (@expr1073754042 tok@var3159 , "goto" ) ) {
3027: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3028:
3029: if (@expr1073754046 !@expr12223 inInnerClass@var3157 &&@expr1073754048 tok@var3159 .@expr12225 str (@expr12226 ) ==@expr1073754051 "{" &&@expr1073754052 tok@var3159 .@expr12229 scope (@expr12230 ) .@expr1073754055 isClassOrStruct (@expr1073754056 ) ) {
3030:
3031: FwdAnalysis ::@expr1073754057 Result result@var3160 ; result@var3160 =@expr1073754058 checkRecursive (@expr1073754059 expr@var3152 , tok@var3159 , tok@var3159 .@expr12236 link (@expr12237 ) , exprVarIds@var3155 , local@var3156 , true , depth@var3158 ) ;
3032: if (@expr1073754062 result@var3160 .@expr1073754063 type@var3161 !=@expr1073754064 Result ::@expr12195 Type ::@expr12242 NONE@expr12182 ) {
3033: return result@var3160 ; }
3034: tok@var3159 =@expr1073754067 tok@var3159 .@expr12236 link (@expr12237 ) ;
3035: }
3036:
3037: if (@expr1073754070 tok@var3159 .@expr12225 str (@expr12226 ) ==@expr1073754073 "continue" ) {
3038:
3039: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3040:
3041: if (@expr1073754077 const Token *@expr12198 lambdaEndToken@var3162 =@expr1073754079 findLambdaEndToken (@expr1073754080 tok@var3159 ) ) {
3042: tok@var3159 =@expr1073754081 lambdaEndToken@var3162 ;
3043: const Result lambdaResult@var3163 =@expr1073754082 checkRecursive (@expr1073754083 expr@var3152 , lambdaEndToken@var3162 .@expr1073754084 link (@expr1073754085 ) .@expr1073754086 next (@expr1073754087 ) , lambdaEndToken@var3162 , exprVarIds@var3155 , local@var3156 , inInnerClass@var3157 , depth@var3158 ) ;
3044: if (@expr1073754088 lambdaResult@var3163 .@expr12265 type@var3164 ==@expr1073754090 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ||@expr1073754093 lambdaResult@var3163 .@expr12265 type@var3164 ==@expr1073754095 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) {
3045: return lambdaResult@var3163 ; }
3046: }
3047:
3048: if (@expr1073754098 Token ::@expr12275 Match (@expr1073754100 tok@var3159 , "return|throw" ) ) {
3049:
3050:
3051:
3052: const Token * opTok@var3165 ; opTok@var3165 =@expr1073754101 tok@var3159 .@expr1073754102 astOperand1 (@expr1073754103 ) ;
3053: if (@expr1073754104 !@expr1073754105 opTok@var3165 ) {
3054: opTok@var3165 =@expr1073754106 tok@var3159 .@expr12202 next (@expr12203 ) ; }
3055: std ::@expr1073754109 pair < const Token *@expr12198 , const Token *@expr12198 > startEndTokens@var3166 ; startEndTokens@var3166 =@expr1073754112 opTok@var3165 .@expr1073754113 findExpressionStartEndTokens (@expr1073754114 ) ;
3056: FwdAnalysis ::@expr1073754115 Result result@var3167 ; result@var3167 =@expr1073754116
3057: checkRecursive (@expr1073754117 expr@var3152 , startEndTokens@var3166 .@expr1073754118 first@var3168 , startEndTokens@var3166 .@expr1073754119 second@var3169 .@expr1073754120 next (@expr1073754121 ) , exprVarIds@var3155 , local@var3156 , true , depth@var3158 ) ;
3058: if (@expr1073754122 result@var3167 .@expr1073754123 type@var3170 !=@expr1073754124 Result ::@expr12195 Type ::@expr12242 NONE@expr12182 ) {
3059: return result@var3167 ; }
3060:
3061:
3062: if (@expr1073754127 !@expr12223 inInnerClass@var3157 ) {
3063: if (@expr1073754129 !@expr12306 local@var3156 &&@expr1073754131 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign@expr12184 ) {
3064: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3065:
3066: return Result (@expr1073754137 Result ::@expr12195 Type ::@expr1073754139 RETURN@expr1073754009 ) ;
3067: }
3068: }
3069:
3070: if (@expr1073754140 tok@var3159 .@expr12225 str (@expr12226 ) ==@expr1073754143 "}" ) {
3071:
3072: if (@expr1073754144 tok@var3159 .@expr12229 scope (@expr12230 ) ==@expr1073754147 expr@var3152 .@expr1073754148 scope (@expr1073754149 ) ) {
3073: mValueFlowKnown@var1706 =@expr1073754150 false ; }
3074:
3075: if (@expr1073754151 tok@var3159 .@expr12229 scope (@expr12230 ) .@expr1073754154 isLoopScope (@expr1073754155 ) ) {
3076:
3077: const Token * conditionStart@var3171 ; conditionStart@var3171 =@expr1073754156 nullptr ;
3078: const Token * conditionEnd@var3172 ; conditionEnd@var3172 =@expr1073754157 nullptr ;
3079: if (@expr1073754158 Token ::@expr12205 simpleMatch (@expr1073754160 tok@var3159 .@expr12236 link (@expr12237 ) .@expr12339 previous (@expr12340 ) , ") {" ) ) {
3080: conditionEnd@var3172 =@expr1073754165 tok@var3159 .@expr12236 link (@expr12237 ) .@expr12339 previous (@expr12340 ) ;
3081: conditionStart@var3171 =@expr1073754170 conditionEnd@var3172 .@expr1073754171 link (@expr1073754172 ) ;
3082: } else { if (@expr1073754173 Token ::@expr12205 simpleMatch (@expr1073754175 tok@var3159 .@expr12236 link (@expr12237 ) .@expr12339 previous (@expr12340 ) , "do {" ) &&@expr1073754180 Token ::@expr12205 simpleMatch (@expr1073754182 tok@var3159 , "} while (" ) ) {
3083: conditionStart@var3171 =@expr1073754183 tok@var3159 .@expr12360 tokAt (@expr12361 2 ) ;
3084: conditionEnd@var3172 =@expr1073754186 conditionStart@var3171 .@expr1073754187 link (@expr1073754188 ) ;
3085: } }
3086: if (@expr1073754189 conditionStart@var3171 &&@expr1073754190 conditionEnd@var3172 ) {
3087: bool used@var3173 ; used@var3173 =@expr1073754191 false ;
3088: for (@expr1073754192 const Token *@expr12198 condTok@var3174 =@expr1073754194 conditionStart@var3171 ; condTok@var3174 !=@expr1073754195 conditionEnd@var3172 ; condTok@var3174 =@expr1073754196 condTok@var3174 .@expr1073754197 next (@expr1073754198 ) ) {
3089: if (@expr1073754199 exprVarIds@var3155 .@expr12376 find (@expr1073754201 condTok@var3174 .@expr1073754202 varId (@expr1073754203 ) ) !=@expr1073754204 exprVarIds@var3155 .@expr12381 end (@expr12382 ) ) {
3090: used@var3173 =@expr1073754207 true ;
3091: break ;
3092: }
3093: }
3094: if (@expr1073754208 used@var3173 ) {
3095: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3096: }
3097:
3098:
3099: const struct FwdAnalysis ::@expr1073754212 Result &@expr12389 result@var3175 =@expr1073754214 checkRecursive (@expr1073754215 expr@var3152 , tok@var3159 .@expr12236 link (@expr12237 ) , tok@var3159 , exprVarIds@var3155 , local@var3156 , inInnerClass@var3157 , depth@var3158 ) ;
3100: if (@expr1073754218 result@var3175 .@expr12395 type@var3176 ==@expr1073754220 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ||@expr1073754223 result@var3175 .@expr12395 type@var3176 ==@expr1073754225 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ) {
3101: return result@var3175 ; }
3102: }
3103: }
3104:
3105: if (@expr1073754228 Token ::@expr12205 simpleMatch (@expr1073754230 tok@var3159 , "else {" ) ) {
3106: tok@var3159 =@expr1073754231 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) ; }
3107:
3108: if (@expr1073754234 Token ::@expr12205 simpleMatch (@expr1073754236 tok@var3159 , "asm (" ) ) {
3109: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3110:
3111: if (@expr1073754240 mWhat@var1704 ==@expr12417 What ::@expr12418 ValueFlow@expr12186 &&@expr1073754243 (@expr1073754244 Token ::@expr12275 Match (@expr1073754246 tok@var3159 , "while|for (" ) ||@expr1073754247 Token ::@expr12205 simpleMatch (@expr12425 tok@var3159 , "do {" ) ) ) {
3112: const Token * bodyStart@var3177 ; bodyStart@var3177 =@expr1073754250 nullptr ;
3113: const Token * conditionStart@var3178 ; conditionStart@var3178 =@expr1073754251 nullptr ;
3114: if (@expr1073754252 Token ::@expr12205 simpleMatch (@expr12425 tok@var3159 , "do {" ) ) {
3115: bodyStart@var3177 =@expr1073754255 tok@var3159 .@expr12202 next (@expr12203 ) ;
3116: if (@expr1073754258 Token ::@expr12205 simpleMatch (@expr1073754260 bodyStart@var3177 .@expr12437 link (@expr12438 ) , "} while (" ) ) {
3117: conditionStart@var3178 =@expr1073754263 bodyStart@var3177 .@expr12437 link (@expr12438 ) .@expr1073754266 tokAt (@expr1073754267 2 ) ; }
3118: } else {
3119: conditionStart@var3178 =@expr1073754268 tok@var3159 .@expr12202 next (@expr12203 ) ;
3120: if (@expr1073754271 Token ::@expr12205 simpleMatch (@expr1073754273 conditionStart@var3178 .@expr12450 link (@expr12451 ) , ") {" ) ) {
3121: bodyStart@var3177 =@expr1073754276 conditionStart@var3178 .@expr12450 link (@expr12451 ) .@expr1073754279 next (@expr1073754280 ) ; }
3122: }
3123:
3124: if (@expr1073754281 !@expr1073754282 bodyStart@var3177 ||@expr1073754283 !@expr1073754284 conditionStart@var3178 ) {
3125: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3126:
3127:
3128: if (@expr1073754288 !@expr1073754289 isUnchanged (@expr1073754290 conditionStart@var3178 , conditionStart@var3178 .@expr12450 link (@expr12451 ) , exprVarIds@var3155 , local@var3156 ) ) {
3129: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3130:
3131:
3132: if (@expr1073754296 !@expr1073754297 isUnchanged (@expr1073754298 bodyStart@var3177 , bodyStart@var3177 .@expr12437 link (@expr12438 ) , exprVarIds@var3155 , local@var3156 ) ) {
3133: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3134: }
3135:
3136: if (@expr1073754304 mWhat@var1704 ==@expr12417 What ::@expr12418 ValueFlow@expr12186 &&@expr1073754307 Token ::@expr12205 simpleMatch (@expr1073754309 tok@var3159 , "if (" ) &&@expr1073754310 Token ::@expr12205 simpleMatch (@expr12488 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) , ") {" ) ) {
3137: const Token * bodyStart@var3179 ; bodyStart@var3179 =@expr1073754315 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) .@expr1073754318 next (@expr1073754319 ) ;
3138: const Token * conditionStart@var3180 ; conditionStart@var3180 =@expr1073754320 tok@var3159 .@expr12202 next (@expr12203 ) ;
3139: const Token * condTok@var3181 ; condTok@var3181 =@expr1073754323 conditionStart@var3180 .@expr1073754324 astOperand2 (@expr1073754325 ) ;
3140: if (@expr1073754326 condTok@var3181 .@expr1073754327 hasKnownIntValue (@expr1073754328 ) ) {
3141: bool cond@var3182 ; cond@var3182 =@expr1073754329 condTok@var3181 .@expr1073754330 values (@expr1073754331 ) .@expr1073754332 front (@expr1073754333 ) .@expr1073754334 intvalue@expr1073754011 ;
3142: if (@expr1073754335 cond@var3182 ) {
3143: FwdAnalysis ::@expr1073754336 Result result@var3183 ; result@var3183 =@expr1073754337 checkRecursive (@expr12514 expr@var3152 , bodyStart@var3179 , bodyStart@var3179 .@expr12515 link (@expr12516 ) , exprVarIds@var3155 , local@var3156 , true , depth@var3158 ) ;
3144: if (@expr1073754341 result@var3183 .@expr1073754342 type@var3184 !=@expr1073754343 Result ::@expr12195 Type ::@expr12242 NONE@expr12182 ) {
3145: return result@var3183 ; }
3146: } else { if (@expr1073754346 Token ::@expr12205 simpleMatch (@expr1073754348 bodyStart@var3179 .@expr12515 link (@expr12516 ) , "} else {" ) ) {
3147: bodyStart@var3179 =@expr1073754351 bodyStart@var3179 .@expr12515 link (@expr12516 ) .@expr1073754354 tokAt (@expr1073754355 2 ) ;
3148: FwdAnalysis ::@expr1073754356 Result result@var3185 ; result@var3185 =@expr1073754357 checkRecursive (@expr12514 expr@var3152 , bodyStart@var3179 , bodyStart@var3179 .@expr12515 link (@expr12516 ) , exprVarIds@var3155 , local@var3156 , true , depth@var3158 ) ;
3149: if (@expr1073754361 result@var3185 .@expr1073754362 type@var3186 !=@expr1073754363 Result ::@expr12195 Type ::@expr12242 NONE@expr12182 ) {
3150: return result@var3185 ; }
3151: } }
3152: }
3153: tok@var3159 =@expr1073754366 bodyStart@var3179 .@expr12515 link (@expr12516 ) ;
3154: if (@expr1073754369 isReturnScope (@expr1073754370 tok@var3159 , &@expr1073754371 mLibrary@var1703 ) ) {
3155: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3156: if (@expr1073754375 Token ::@expr12205 simpleMatch (@expr1073754377 tok@var3159 , "} else {" ) ) {
3157: tok@var3159 =@expr1073754378 tok@var3159 .@expr12408 linkAt (@expr1073754380 2 ) ; }
3158: if (@expr1073754381 !@expr1073754382 tok@var3159 ) {
3159: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3160:
3161:
3162: if (@expr1073754386 !@expr1073754387 isUnchanged (@expr1073754388 conditionStart@var3180 , conditionStart@var3180 .@expr1073754389 link (@expr1073754390 ) , exprVarIds@var3155 , local@var3156 ) ) {
3163: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3164:
3165:
3166: if (@expr1073754394 !@expr1073754395 isUnchanged (@expr1073754396 bodyStart@var3179 , bodyStart@var3179 .@expr12515 link (@expr12516 ) , exprVarIds@var3155 , local@var3156 ) ) {
3167: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3168: }
3169:
3170: if (@expr1073754402 !@expr12306 local@var3156 &&@expr1073754404 Token ::@expr12275 Match (@expr12582 tok@var3159 , "%name% (" ) &&@expr1073754407 !@expr1073754408 Token ::@expr12205 simpleMatch (@expr12488 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) , ") {" ) ) {
3171:
3172: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ;
3173: }
3174:
3175: if (@expr1073754416 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign@expr12184 &&@expr1073754419
3176: Token ::@expr12205 simpleMatch (@expr1073754421 tok@var3159 , ";" ) &&@expr1073754422
3177: Token ::@expr12205 simpleMatch (@expr1073754424 tok@var3159 .@expr12601 astParent (@expr12602 ) , ";" ) &&@expr1073754427
3178: Token ::@expr12205 simpleMatch (@expr1073754429 tok@var3159 .@expr12601 astParent (@expr12602 ) .@expr12608 astParent (@expr12609 ) , "(" ) &&@expr1073754434
3179: Token ::@expr12205 simpleMatch (@expr1073754436 tok@var3159 .@expr12601 astParent (@expr12602 ) .@expr12608 astParent (@expr12609 ) .@expr1073754441 previous (@expr1073754442 ) , "for (" ) &&@expr1073754443
3180: !@expr1073754444 isUnchanged (@expr1073754445 tok@var3159 , tok@var3159 .@expr12601 astParent (@expr12602 ) .@expr12608 astParent (@expr12609 ) .@expr1073754450 link (@expr1073754451 ) , exprVarIds@var3155 , local@var3156 ) ) {
3181:
3182: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3183:
3184: if (@expr1073754455 expr@var3152 .@expr1073754456 isName (@expr1073754457 ) &&@expr1073754458 Token ::@expr12275 Match (@expr12582 tok@var3159 , "%name% (" ) &&@expr1073754461 tok@var3159 .@expr12225 str (@expr12226 ) .@expr12640 find (@expr1073754465 "<" ) !=@expr1073754466 std ::@expr12643 string ::@expr12644 npos &&@expr1073754469 tok@var3159 .@expr12225 str (@expr12226 ) .@expr12640 find (@expr1073754473 expr@var3152 .@expr1073754474 str (@expr1073754475 ) ) !=@expr1073754476 std ::@expr12643 string ::@expr12644 npos@expr1073754012 ) {
3185: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3186:
3187: if (@expr1073754482 exprVarIds@var3155 .@expr12376 find (@expr1073754484 tok@var3159 .@expr1073754485 varId (@expr1073754486 ) ) !=@expr1073754487 exprVarIds@var3155 .@expr12381 end (@expr12382 ) ) {
3188: const Token * parent@var3187 ; parent@var3187 =@expr1073754490 tok@var3159 ;
3189: bool other@var3188 ; other@var3188 =@expr1073754491 false ;
3190: bool same@var3189 ; same@var3189 =@expr1073754492 tok@var3159 .@expr12601 astParent (@expr12602 ) &&@expr1073754495 isSameExpression (@expr1073754496 mCpp@var1702 , false , expr@var3152 , tok@var3159 , mLibrary@var1703 , true , false , nullptr ) ;
3191: while (@expr1073754497 !@expr1073754498 same@var3189 &&@expr1073754499 Token ::@expr12275 Match (@expr1073754501 parent@var3187 .@expr12678 astParent (@expr12679 ) , "*|.|::|[|(|%cop%" ) ) {
3192: parent@var3187 =@expr1073754504 parent@var3187 .@expr12678 astParent (@expr12679 ) ;
3193: if (@expr1073754507 parent@var3187 .@expr1073754508 str (@expr1073754509 ) ==@expr1073754510 "(" &&@expr1073754511 !@expr1073754512 parent@var3187 .@expr1073754513 isCast (@expr1073754514 ) ) {
3194: break ; }
3195: if (@expr1073754515 isSameExpression (@expr1073754516 mCpp@var1702 , false , expr@var3152 , parent@var3187 , mLibrary@var1703 , true , false , nullptr ) ) {
3196: same@var3189 =@expr1073754517 true ;
3197: if (@expr1073754518 mWhat@var1704 ==@expr12417 What ::@expr12418 ValueFlow@expr12186 ) {
3198: KnownAndToken v@var3190 ;
3199: v@var3190 .@expr1073754521 known@var3191 =@expr1073754522 mValueFlowKnown@var1706 ;
3200: v@var3190 .@expr1073754523 token@var3192 =@expr1073754524 parent@var3187 ;
3201: mValueFlow@var1705 .@expr1073754525 push_back (@expr1073754526 v@var3190 ) ;
3202: }
3203: }
3204: if (@expr1073754527 Token ::@expr12275 Match (@expr1073754529 parent@var3187 , ". %var%" ) &&@expr1073754530 parent@var3187 .@expr12707 next (@expr12708 ) .@expr12709 varId (@expr12710 ) &&@expr1073754535 exprVarIds@var3155 .@expr12376 find (@expr1073754537 parent@var3187 .@expr12707 next (@expr12708 ) .@expr12709 varId (@expr12710 ) ) ==@expr1073754542 exprVarIds@var3155 .@expr12381 end (@expr12382 ) &&@expr1073754545
3205: isSameExpression (@expr1073754546 mCpp@var1702 , false , expr@var3152 .@expr1073754547 astOperand1 (@expr1073754548 ) , parent@var3187 .@expr1073754549 astOperand1 (@expr1073754550 ) , mLibrary@var1703 , true , false , nullptr ) ) {
3206: other@var3188 =@expr1073754551 true ;
3207: break ;
3208: }
3209: }
3210: if (@expr1073754552 mWhat@var1704 !=@expr1073754553 What ::@expr12418 ValueFlow &&@expr1073754555 same@var3189 &&@expr1073754556 Token ::@expr12205 simpleMatch (@expr1073754558 parent@var3187 .@expr12678 astParent (@expr12679 ) , "[" ) &&@expr1073754561 parent@var3187 ==@expr1073754562 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12741 astOperand2 (@expr12742 ) ) {
3211: return Result (@expr12743 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ) ;
3212: }
3213: if (@expr1073754570 other@var3188 ) {
3214: continue ; }
3215: if (@expr1073754571 Token ::@expr12205 simpleMatch (@expr1073754573 parent@var3187 .@expr12678 astParent (@expr12679 ) , "=" ) &&@expr1073754576 parent@var3187 ==@expr12753 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12756 astOperand1 (@expr12757 ) ) {
3216: if (@expr1073754582 !@expr12306 local@var3156 &&@expr1073754584 hasFunctionCall (@expr1073754585 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12741 astOperand2 (@expr12742 ) ) ) {
3217:
3218: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ;
3219: }
3220: if (@expr1073754593 hasOperand (@expr1073754594 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12741 astOperand2 (@expr12742 ) , expr@var3152 ) ) {
3221: if (@expr12775 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign@expr12184 ) {
3222: return Result (@expr12743 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ) ; }
3223: continue ;
3224: }
3225: const auto startEnd@var3193 =@expr1073754605 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12741 astOperand2 (@expr12742 ) .@expr1073754610 findExpressionStartEndTokens (@expr1073754611 ) ;
3226: for (@expr1073754612 const Token *@expr12198 tok2@var3194 =@expr1073754614 startEnd@var3193 .@expr1073754615 first@var3195 ; tok2@var3194 !=@expr1073754616 startEnd@var3193 .@expr1073754617 second@var3196 ; tok2@var3194 =@expr1073754618 tok2@var3194 .@expr1073754619 next (@expr1073754620 ) ) {
3227: if (@expr1073754621 tok2@var3194 .@expr1073754622 tokType (@expr1073754623 ) ==@expr1073754624 Token ::@expr1073754625 eLambda ) {
3228: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3229:
3230: }
3231:
3232: if (@expr1073754629 hasGccCompoundStatement (@expr1073754630 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12741 astOperand2 (@expr12742 ) ) ) {
3233: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3234: const bool reassign@var3197 =@expr1073754638 isSameExpression (@expr1073754639 mCpp@var1702 , false , expr@var3152 , parent@var3187 , mLibrary@var1703 , false , false , nullptr ) ;
3235: if (@expr1073754640 reassign@var3197 ) {
3236: return Result (@expr1073754641 Result ::@expr12195 Type ::@expr12819 WRITE@expr12189 , parent@var3187 .@expr12678 astParent (@expr12679 ) ) ; }
3237: return Result (@expr12743 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ) ;
3238: } else { if (@expr1073754649 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign &&@expr1073754652 parent@var3187 .@expr12829 valueType (@expr12830 ) &&@expr1073754655 parent@var3187 .@expr12829 valueType (@expr12830 ) .@expr1073754658 pointer@var3315 &&@expr1073754659 Token ::@expr12275 Match (@expr12837 parent@var3187 .@expr12678 astParent (@expr12679 ) , "%assign%" ) &&@expr1073754664 parent@var3187 ==@expr12753 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12756 astOperand1 (@expr12757 ) ) {
3239: return Result (@expr12743 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ) ;
3240: } else { if (@expr1073754673 Token ::@expr12275 Match (@expr12837 parent@var3187 .@expr12678 astParent (@expr12679 ) , "%assign%" ) &&@expr1073754678 !@expr1073754679 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr1073754682 astParent (@expr1073754683 ) &&@expr1073754684 parent@var3187 ==@expr12753 parent@var3187 .@expr12678 astParent (@expr12679 ) .@expr12756 astOperand1 (@expr12757 ) ) {
3241: if (@expr12775 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign@expr12184 ) {
3242: return Result (@expr12869 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 , parent@var3187 .@expr12678 astParent (@expr12679 ) ) ; }
3243: if (@expr1073754698 mWhat@var1704 ==@expr12875 What ::@expr12876 UnusedValue@expr1073754014 &&@expr1073754701 (@expr1073754702 !@expr1073754703 parent@var3187 .@expr12829 valueType (@expr12830 ) ||@expr1073754706 parent@var3187 .@expr12829 valueType (@expr12830 ) .@expr1073754709 reference@var3319 !=@expr1073754710 Reference ::@expr1073754711 None ) ) {
3244: return Result (@expr12869 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 , parent@var3187 .@expr12678 astParent (@expr12679 ) ) ; }
3245: continue ;
3246: } else { if (@expr1073754717 mWhat@var1704 ==@expr12875 What ::@expr12876 UnusedValue &&@expr1073754720 parent@var3187 .@expr1073754721 isUnaryOp (@expr1073754722 "&" ) &&@expr1073754723 Token ::@expr12275 Match (@expr1073754725 parent@var3187 .@expr12678 astParent (@expr12679 ) , "[,(]" ) ) {
3247:
3248: const Token * ftok@var3198 ; ftok@var3198 =@expr1073754728 parent@var3187 .@expr12678 astParent (@expr12679 ) ;
3249: while (@expr1073754731 Token ::@expr12205 simpleMatch (@expr1073754733 ftok@var3198 , "," ) ) {
3250: ftok@var3198 =@expr1073754734 ftok@var3198 .@expr1073754735 astParent (@expr1073754736 ) ; }
3251: if (@expr1073754737 ftok@var3198 &&@expr1073754738 Token ::@expr12275 Match (@expr1073754740 ftok@var3198 .@expr1073754741 previous (@expr1073754742 ) , "%name% (" ) ) {
3252: const std ::@expr1073754743 vector < const Token *@expr12198 > args@var3199 =@expr1073754745 getArguments (@expr1073754746 ftok@var3198 ) ;
3253: int argnr@var3200 ; argnr@var3200 =@expr1073754747 0 ;
3254: while (@expr1073754748 argnr@var3200 <@expr12925 args@var3199 .@expr12926 size (@expr12927 ) &&@expr1073754752 args@var3199 [@expr1073754753 argnr@var3200 ] !=@expr1073754754 parent@var3187 ) {
3255: argnr@var3200 ++@expr1073754755 ; }
3256: if (@expr1073754756 argnr@var3200 <@expr12925 args@var3199 .@expr12926 size (@expr12927 ) ) {
3257: const Library ::@expr1073754760 Function * functionInfo@var3201 ; functionInfo@var3201 =@expr1073754761 mLibrary@var1703 .@expr1073754762 getFunction (@expr1073754763 ftok@var3198 .@expr1073754764 astOperand1 (@expr1073754765 ) ) ;
3258: if (@expr1073754766 functionInfo@var3201 ) {
3259: const auto it@var3202 =@expr1073754767 functionInfo@var3201 .@expr12944 argumentChecks@var3203 .@expr1073754769 find (@expr1073754770 argnr@var3200 +@expr1073754771 1 ) ;
3260: if (@expr1073754772 it@var3202 !=@expr1073754773 functionInfo@var3201 .@expr12944 argumentChecks@var3203 .@expr1073754775 end (@expr1073754776 ) &&@expr1073754777 it@var3202 .@expr1073754778 second@var3204 .@expr1073754779 direction@var3205 ==@expr1073754780 Library ::@expr1073754781 ArgumentChecks ::@expr1073754782 Direction ::@expr1073754783 DIR_OUT ) {
3261: continue ; }
3262: }
3263: }
3264: }
3265: return Result (@expr12869 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 , parent@var3187 .@expr12678 astParent (@expr12679 ) ) ;
3266: } else {
3267:
3268: return Result (@expr12869 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 , parent@var3187 .@expr12678 astParent (@expr12679 ) ) ;
3269: } } } }
3270: }
3271:
3272: if (@expr1073754794 Token ::@expr12275 Match (@expr1073754796 tok@var3159 , ")|do {" ) ) {
3273: if (@expr1073754797 tok@var3159 .@expr12225 str (@expr12226 ) ==@expr1073754800 ")" &&@expr1073754801 Token ::@expr12205 simpleMatch (@expr1073754803 tok@var3159 .@expr12236 link (@expr12237 ) .@expr12339 previous (@expr12340 ) , "switch (" ) ) {
3274:
3275: return Result (@expr12194 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) ; }
3276: const Result &@expr12389 result1@var3206 =@expr1073754812 checkRecursive (@expr1073754813 expr@var3152 , tok@var3159 .@expr12360 tokAt (@expr12361 2 ) , tok@var3159 .@expr12408 linkAt (@expr12409 1 ) , exprVarIds@var3155 , local@var3156 , inInnerClass@var3157 , depth@var3158 ) ;
3277: if (@expr1073754818 result1@var3206 .@expr12995 type@var3207 ==@expr1073754820 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ||@expr1073754823 result1@var3206 .@expr12995 type@var3207 ==@expr1073754825 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) {
3278: return result1@var3206 ; }
3279: if (@expr1073754828 mWhat@var1704 ==@expr12417 What ::@expr12418 ValueFlow &&@expr1073754831 result1@var3206 .@expr12995 type@var3207 ==@expr13009 Result ::@expr12195 Type ::@expr12819 WRITE@expr12189 ) {
3280: mValueFlowKnown@var1706 =@expr1073754836 false ; }
3281: if (@expr1073754837 mWhat@var1704 ==@expr12308 What ::@expr12309 Reassign &&@expr1073754840 result1@var3206 .@expr12995 type@var3207 ==@expr1073754842 Result ::@expr12195 Type ::@expr12215 BREAK@expr12181 ) {
3282: const Token * scopeEndToken@var3208 ; scopeEndToken@var3208 =@expr1073754845 findNextTokenFromBreak (@expr1073754846 result1@var3206 .@expr1073754847 token@var3209 ) ;
3283: if (@expr1073754848 scopeEndToken@var3208 ) {
3284: const Result &@expr12389 result2@var3210 =@expr1073754850 checkRecursive (@expr1073754851 expr@var3152 , scopeEndToken@var3208 .@expr1073754852 next (@expr1073754853 ) , endToken@var3154 , exprVarIds@var3155 , local@var3156 , inInnerClass@var3157 , depth@var3158 ) ;
3285: if (@expr1073754854 result2@var3210 .@expr1073754855 type@var3211 ==@expr1073754856 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) {
3286: return result2@var3210 ; }
3287: }
3288: }
3289: if (@expr1073754859 Token ::@expr12205 simpleMatch (@expr1073754861 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) , "} else {" ) ) {
3290: const Token * elseStart@var3212 ; elseStart@var3212 =@expr1073754864 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) .@expr1073754867 tokAt (@expr1073754868 2 ) ;
3291: const Result &@expr12389 result2@var3213 =@expr1073754870 checkRecursive (@expr1073754871 expr@var3152 , elseStart@var3212 , elseStart@var3212 .@expr13048 link (@expr13049 ) , exprVarIds@var3155 , local@var3156 , inInnerClass@var3157 , depth@var3158 ) ;
3292: if (@expr1073754874 mWhat@var1704 ==@expr12417 What ::@expr12418 ValueFlow &&@expr1073754877 result2@var3213 .@expr13054 type@var3214 ==@expr13055 Result ::@expr12195 Type ::@expr12819 WRITE@expr12189 ) {
3293: mValueFlowKnown@var1706 =@expr1073754882 false ; }
3294: if (@expr1073754883 result2@var3213 .@expr13054 type@var3214 ==@expr1073754885 Result ::@expr12195 Type ::@expr12268 READ@expr12183 ||@expr1073754888 result2@var3213 .@expr13054 type@var3214 ==@expr1073754890 Result ::@expr12195 Type ::@expr12196 BAILOUT@expr12180 ) {
3295: return result2@var3213 ; }
3296: if (@expr1073754893 result1@var3206 .@expr12995 type@var3207 ==@expr13009 Result ::@expr12195 Type ::@expr12819 WRITE &&@expr1073754898 result2@var3213 .@expr13054 type@var3214 ==@expr13055 Result ::@expr12195 Type ::@expr12819 WRITE@expr12189 ) {
3297: return result1@var3206 ; }
3298: tok@var3159 =@expr1073754903 elseStart@var3212 .@expr13048 link (@expr13049 ) ;
3299: } else {
3300: tok@var3159 =@expr1073754906 tok@var3159 .@expr12408 linkAt (@expr12409 1 ) ;
3301: }
3302: }
3303: }
3304:
3305: return Result (@expr1073754909 Result ::@expr12195 Type ::@expr12242 NONE@expr12182 ) ;
3306: }
3307:
3308: static bool hasVolatileCastOrVar ( const Token * expr@var3215 )
3309: {
3310: bool ret@var3216 ; ret@var3216 =@expr1073754912 false ;
3311: visitAstNodes (@expr1073754913 expr@var3215 ,
3312: [@expr1073754914 &@expr1073754915 ret@var3216 ] (@expr1073754916 const Token *@expr1073754917 tok@var3217 ) {
3313: if (@expr1073754918 Token ::@expr1073754919 simpleMatch (@expr1073754920 tok@var3217 , "( volatile" ) ) {
3314: ret@var3216 =@expr1073754921 true ; }
3315: else { if (@expr1073754922 tok@var3217 .@expr13099 variable (@expr13100 ) &&@expr1073754925 tok@var3217 .@expr13099 variable (@expr13100 ) .@expr1073754928 isVolatile (@expr1073754929 ) ) {
3316: ret@var3216 =@expr1073754930 true ; } }
3317: return ret@var3216 ?@expr1073754931 ChildrenToVisit ::@expr1073754932 none :@expr1073754933 ChildrenToVisit ::@expr1073754934 op1_and_op2 ;
3318: } ) ;
3319: return ret@var3216 ;
3320: }
3321:
3322: bool FwdAnalysis :: isGlobalData ( const Token * expr@var3218 ) const
3323: {
3324: return ::@expr1073754935 isGlobalData (@expr1073754936 expr@var3218 , mCpp@var1702 ) ;
3325: }
3326:
3327: std :: set < int > FwdAnalysis :: getExprVarIds ( const Token * expr@var3219 , bool * localOut@var3220 , bool * unknownVarIdOut@var3221 ) const
3328: {
3329:
3330: std ::@expr1073754938 set < int > exprVarIds@var3222 ;
3331: bool local@var3223 ; local@var3223 =@expr1073754939 true ;
3332: bool unknownVarId@var3224 ; unknownVarId@var3224 =@expr1073754940 false ;
3333: visitAstNodes (@expr1073754941 expr@var3219 ,
3334: [@expr1073754942 &@expr1073754943 ] (@expr1073754944 const Token *@expr1073754945 tok@var3225 ) {
3335: if (@expr1073754946 tok@var3225 .@expr1073754947 str (@expr1073754948 ) ==@expr1073754949 "[" &&@expr1073754950 mWhat@var1704 ==@expr1073754951 What ::@expr1073754952 UnusedValue@expr1073754937 ) {
3336: return ChildrenToVisit ::@expr1073754953 op1 ; }
3337: if (@expr1073754954 tok@var3225 .@expr13131 varId (@expr13132 ) ==@expr1073754957 0 &&@expr1073754958 tok@var3225 .@expr1073754959 isName (@expr1073754960 ) &&@expr1073754961 tok@var3225 .@expr13138 previous (@expr13139 ) .@expr1073754964 str (@expr1073754965 ) !=@expr1073754966 "." ) {
3338:
3339: unknownVarId@var3224 =@expr1073754967 true ;
3340: return ChildrenToVisit ::@expr13144 none ;
3341: }
3342: if (@expr1073754969 tok@var3225 .@expr13131 varId (@expr13132 ) >@expr1073754972 0 ) {
3343: exprVarIds@var3222 .@expr1073754973 insert (@expr1073754974 tok@var3225 .@expr13131 varId (@expr13132 ) ) ;
3344: if (@expr1073754977 !@expr1073754978 Token ::@expr1073754979 simpleMatch (@expr1073754980 tok@var3225 .@expr13138 previous (@expr13139 ) , "." ) ) {
3345: const Variable * var@var3226 ; var@var3226 =@expr1073754983 tok@var3225 .@expr13160 variable (@expr13161 ) ;
3346: if (@expr1073754986 var@var3226 &&@expr1073754987 var@var3226 .@expr1073754988 isReference (@expr1073754989 ) &&@expr1073754990 var@var3226 .@expr1073754991 isLocal (@expr1073754992 ) &&@expr1073754993 Token ::@expr1073754994 Match (@expr1073754995 var@var3226 .@expr13172 nameToken (@expr13173 ) , "%var% [=(]" ) &&@expr1073754998 !@expr1073754999 isGlobalData (@expr1073755000 var@var3226 .@expr13172 nameToken (@expr13173 ) .@expr1073755003 next (@expr1073755004 ) .@expr1073755005 astOperand2 (@expr1073755006 ) ) ) {
3347: return ChildrenToVisit ::@expr13144 none ; }
3348: const bool deref@var3227 =@expr1073755008 tok@var3225 .@expr13185 astParent (@expr13186 ) &&@expr1073755011 (@expr1073755012 tok@var3225 .@expr13185 astParent (@expr13186 ) .@expr1073755015 isUnaryOp (@expr1073755016 "*" ) ||@expr1073755017 (@expr1073755018 tok@var3225 .@expr13185 astParent (@expr13186 ) .@expr1073755021 str (@expr1073755022 ) ==@expr1073755023 "[" &&@expr1073755024 tok@var3225 ==@expr1073755025 tok@var3225 .@expr13185 astParent (@expr13186 ) .@expr1073755028 astOperand1 (@expr1073755029 ) ) ) ;
3349: local@var3223 &=@expr1073755030 !@expr1073755031 nonLocal (@expr1073755032 tok@var3225 .@expr13160 variable (@expr13161 ) , deref@var3227 ) ;
3350: }
3351: }
3352: return ChildrenToVisit ::@expr1073755035 op1_and_op2 ;
3353: } ) ;
3354: if (@expr1073755036 localOut@var3220 ) {
3355: *@expr1073755037 localOut@var3220 =@expr1073755038 local@var3223 ; }
3356: if (@expr1073755039 unknownVarIdOut@var3221 ) {
3357: *@expr1073755040 unknownVarIdOut@var3221 =@expr1073755041 unknownVarId@var3224 ; }
3358: return exprVarIds@var3222 ;
3359: }
3360:
3361: FwdAnalysis :: Result FwdAnalysis :: check ( const Token * expr@var3228 , const Token * startToken@var3229 , const Token * endToken@var3230 )
3362: {
3363:
3364: bool local@var3231 ; local@var3231 =@expr1073755046 true ;
3365: bool unknownVarId@var3232 ; unknownVarId@var3232 =@expr1073755047 false ;
3366: std ::@expr1073755048 set < int > exprVarIds@var3233 ; exprVarIds@var3233 =@expr1073755049 getExprVarIds (@expr1073755050 expr@var3228 , &@expr1073755051 local@var3231 , &@expr1073755052 unknownVarId@var3232 ) ;
3367:
3368: if (@expr1073755053 unknownVarId@var3232 ) {
3369: return Result (@expr13230 FwdAnalysis ::@expr13231 Result ::@expr13232 Type ::@expr13233 BAILOUT@expr13218 ) ; }
3370:
3371: if (@expr1073755058 mWhat@var1704 ==@expr1073755059 What ::@expr1073755060 Reassign@expr1073755043 &&@expr1073755061 isGlobalData (@expr13238 expr@var3228 ) ) {
3372: local@var3231 =@expr1073755063 false ; }
3373:
3374:
3375:
3376: if (@expr1073755064 mWhat@var1704 ==@expr1073755065 What ::@expr1073755066 UnusedValue@expr1073755044 &&@expr1073755067 isGlobalData (@expr13238 expr@var3228 ) ) {
3377: return Result (@expr13230 FwdAnalysis ::@expr13231 Result ::@expr13232 Type ::@expr13233 BAILOUT@expr13218 ) ; }
3378:
3379: Result result@var3234 ; result@var3234 =@expr1073755073 checkRecursive (@expr1073755074 expr@var3228 , startToken@var3229 , endToken@var3230 , exprVarIds@var3233 , local@var3231 , false ) ;
3380:
3381:
3382: while (@expr1073755075 mWhat@var1704 !=@expr1073755076 What ::@expr1073755077 ValueFlow &&@expr1073755078 result@var3234 .@expr1073755079 type@var3235 ==@expr1073755080 FwdAnalysis ::@expr13231 Result ::@expr13232 Type ::@expr1073755083 BREAK@expr1073755045 ) {
3383: const Token * scopeEndToken@var3236 ; scopeEndToken@var3236 =@expr1073755084 findNextTokenFromBreak (@expr1073755085 result@var3234 .@expr1073755086 token@var3237 ) ;
3384: if (@expr1073755087 !@expr1073755088 scopeEndToken@var3236 ) {
3385: break ; }
3386: result@var3234 =@expr1073755089 checkRecursive (@expr1073755090 expr@var3228 , scopeEndToken@var3236 .@expr1073755091 next (@expr1073755092 ) , endToken@var3230 , exprVarIds@var3233 , local@var3231 , false ) ;
3387: }
3388:
3389: return result@var3234 ;
3390: }
3391:
3392: bool FwdAnalysis :: hasOperand ( const Token * tok@var3238 , const Token * lhs@var3239 ) const
3393: {
3394: if (@expr1073755093 !@expr1073755094 tok@var3238 ) {
3395: return false ; }
3396: if (@expr1073755095 isSameExpression (@expr1073755096 mCpp@var1702 , false , tok@var3238 , lhs@var3239 , mLibrary@var1703 , false , false , nullptr ) ) {
3397: return true ; }
3398: return hasOperand (@expr1073755097 tok@var3238 .@expr1073755098 astOperand1 (@expr1073755099 ) , lhs@var3239 ) ||@expr1073755100 hasOperand (@expr1073755101 tok@var3238 .@expr1073755102 astOperand2 (@expr1073755103 ) , lhs@var3239 ) ;
3399: }
3400:
3401: const Token * FwdAnalysis :: reassign ( const Token * expr@var3240 , const Token * startToken@var3241 , const Token * endToken@var3242 )
3402: {
3403: if (@expr1073755106 hasVolatileCastOrVar (@expr1073755107 expr@var3240 ) ) {
3404: return nullptr ; }
3405: mWhat@var1704 =@expr1073755108 What ::@expr1073755109 Reassign@expr1073755104 ;
3406: Result result@var3243 ; result@var3243 =@expr1073755110 check (@expr1073755111 expr@var3240 , startToken@var3241 , endToken@var3242 ) ;
3407: return result@var3243 .@expr1073755112 type@var3244 ==@expr1073755113 FwdAnalysis ::@expr1073755114 Result ::@expr1073755115 Type ::@expr1073755116 WRITE@expr1073755105 ?@expr1073755117 result@var3243 .@expr1073755118 token@var3245 :@expr1073755119 nullptr ;
3408: }
3409:
3410: bool FwdAnalysis :: unusedValue ( const Token * expr@var3246 , const Token * startToken@var3247 , const Token * endToken@var3248 )
3411: {
3412: if (@expr1073755123 isEscapedAlias (@expr1073755124 expr@var3246 ) ) {
3413: return false ; }
3414: if (@expr1073755125 hasVolatileCastOrVar (@expr1073755126 expr@var3246 ) ) {
3415: return false ; }
3416: mWhat@var1704 =@expr1073755127 What ::@expr1073755128 UnusedValue@expr1073755120 ;
3417: Result result@var3249 ; result@var3249 =@expr1073755129 check (@expr1073755130 expr@var3246 , startToken@var3247 , endToken@var3248 ) ;
3418: return (@expr1073755131 result@var3249 .@expr13308 type@var3250 ==@expr1073755133 FwdAnalysis ::@expr13310 Result ::@expr13311 Type ::@expr1073755136 NONE@expr1073755121 ||@expr1073755137 result@var3249 .@expr13308 type@var3250 ==@expr1073755139 FwdAnalysis ::@expr13310 Result ::@expr13311 Type ::@expr1073755142 RETURN@expr1073755122 ) &&@expr1073755143 !@expr1073755144 possiblyAliased (@expr1073755145 expr@var3246 , startToken@var3247 ) ;
3419: }
3420:
3421: bool FwdAnalysis :: possiblyAliased ( const Token * expr@var3251 , const Token * startToken@var3252 ) const
3422: {
3423: if (@expr1073755146 expr@var3251 .@expr1073755147 isUnaryOp (@expr1073755148 "*" ) ) {
3424: return true ; }
3425:
3426: const bool macro@var3253 =@expr1073755149 false ;
3427: const bool pure@var3254 =@expr1073755150 false ;
3428: const bool followVar@var3255 =@expr1073755151 false ;
3429: for (@expr1073755152 const Token *@expr13329 tok@var3256 =@expr1073755154 startToken@var3252 ; tok@var3256 ; tok@var3256 =@expr1073755155 tok@var3256 .@expr1073755156 previous (@expr1073755157 ) ) {
3430: if (@expr1073755158 tok@var3256 .@expr1073755159 str (@expr1073755160 ) ==@expr1073755161 "{" &&@expr1073755162 tok@var3256 .@expr1073755163 scope (@expr1073755164 ) .@expr1073755165 type@var3326 ==@expr1073755166 Scope ::@expr1073755167 eFunction &&@expr1073755168 !@expr1073755169 (@expr1073755170 tok@var3256 .@expr13347 astParent (@expr13348 ) &&@expr1073755173 tok@var3256 .@expr13347 astParent (@expr13348 ) .@expr1073755176 str (@expr1073755177 ) ==@expr1073755178 "," ) ) {
3431: break ; }
3432:
3433: if (@expr1073755179 Token ::@expr13356 Match (@expr1073755181 tok@var3256 , "%name% (" ) &&@expr1073755182 !@expr1073755183 Token ::@expr13356 Match (@expr1073755185 tok@var3256 , "if|while|for" ) ) {
3434:
3435: const std ::@expr1073755186 vector < const Token *@expr13329 > args@var3257 =@expr1073755188 getArguments (@expr1073755189 tok@var3256 ) ;
3436: for (@expr1073755190 int argnr@var3258 =@expr1073755191 0 ; argnr@var3258 <@expr1073755192 args@var3257 .@expr1073755193 size (@expr1073755194 ) ; ++@expr1073755195 argnr@var3258 ) {
3437: if (@expr1073755196 !@expr1073755197 Token ::@expr13356 Match (@expr1073755199 args@var3257 [@expr13376 argnr@var3258 ] , "%name%|.|::" ) ) {
3438: continue ; }
3439: if (@expr1073755201 tok@var3256 .@expr13378 function (@expr13379 ) &&@expr1073755204 tok@var3256 .@expr13378 function (@expr13379 ) .@expr13383 getArgumentVar (@expr13384 argnr@var3258 ) &&@expr1073755209 !@expr1073755210 tok@var3256 .@expr13378 function (@expr13379 ) .@expr13383 getArgumentVar (@expr13384 argnr@var3258 ) .@expr1073755215 isReference (@expr1073755216 ) &&@expr1073755217 !@expr1073755218 tok@var3256 .@expr13378 function (@expr13379 ) .@expr1073755221 isConst (@expr1073755222 ) ) {
3440: continue ; }
3441: for (@expr1073755223 const Token *@expr13329 subexpr@var3259 =@expr1073755225 expr@var3251 ; subexpr@var3259 ; subexpr@var3259 =@expr1073755226 subexpr@var3259 .@expr1073755227 astOperand1 (@expr1073755228 ) ) {
3442: if (@expr1073755229 isSameExpression (@expr1073755230 mCpp@var1702 , macro@var3253 , subexpr@var3259 , args@var3257 [@expr13376 argnr@var3258 ] , mLibrary@var1703 , pure@var3254 , followVar@var3255 ) ) {
3443: const Scope * scope@var3260 ; scope@var3260 =@expr1073755232 expr@var3251 .@expr1073755233 scope (@expr1073755234 ) ;
3444: if (@expr1073755235 scope@var3260 .@expr1073755236 varlist@var3261 .@expr1073755237 size (@expr1073755238 ) >@expr1073755239 1 ) {
3445: return true ; }
3446: }
3447: }
3448: }
3449: continue ;
3450: }
3451:
3452: const Token * addrOf@var3262 ; addrOf@var3262 =@expr1073755240 nullptr ;
3453: if (@expr1073755241 Token ::@expr13356 Match (@expr1073755243 tok@var3256 , "& %name% =" ) ) {
3454: addrOf@var3262 =@expr1073755244 tok@var3256 .@expr13421 tokAt (@expr1073755246 2 ) .@expr1073755247 astOperand2 (@expr1073755248 ) ; }
3455: else { if (@expr1073755249 tok@var3256 .@expr1073755250 isUnaryOp (@expr1073755251 "&" ) ) {
3456: addrOf@var3262 =@expr1073755252 tok@var3256 .@expr1073755253 astOperand1 (@expr1073755254 ) ; }
3457: else { if (@expr1073755255 Token ::@expr1073755256 simpleMatch (@expr1073755257 tok@var3256 , "std :: ref (" ) ) {
3458: addrOf@var3262 =@expr1073755258 tok@var3256 .@expr13421 tokAt (@expr1073755260 3 ) .@expr1073755261 astOperand2 (@expr1073755262 ) ; }
3459: else {
3460: continue ; } } }
3461:
3462: for (@expr1073755263 const Token *@expr13329 subexpr@var3263 =@expr1073755265 expr@var3251 ; subexpr@var3263 ; subexpr@var3263 =@expr1073755266 subexpr@var3263 .@expr1073755267 astOperand1 (@expr1073755268 ) ) {
3463: if (@expr1073755269 isSameExpression (@expr1073755270 mCpp@var1702 , macro@var3253 , subexpr@var3263 , addrOf@var3262 , mLibrary@var1703 , pure@var3254 , followVar@var3255 ) ) {
3464: return true ; }
3465: }
3466: }
3467: return false ;
3468: }
3469:
3470: bool FwdAnalysis :: isEscapedAlias ( const Token * expr@var3264 )
3471: {
3472: for (@expr1073755271 const Token *@expr1073755272 subexpr@var3265 =@expr1073755273 expr@var3264 ; subexpr@var3265 ; subexpr@var3265 =@expr1073755274 subexpr@var3265 .@expr1073755275 astOperand1 (@expr1073755276 ) ) {
3473: for (@expr1073755277 const ValueFlow ::@expr1073755278 Value &@expr1073755279 val@var3266 :@expr1073755280 subexpr@var3265 .@expr1073755281 values (@expr1073755282 ) ) {
3474: if (@expr1073755283 !@expr1073755284 val@var3266 .@expr1073755285 isLocalLifetimeValue (@expr1073755286 ) ) {
3475: continue ; }
3476: const Variable * var@var3267 ; var@var3267 =@expr1073755287 val@var3266 .@expr1073755288 tokvalue@var3268 .@expr1073755289 variable (@expr1073755290 ) ;
3477: if (@expr1073755291 !@expr1073755292 var@var3267 ) {
3478: continue ; }
3479: if (@expr1073755293 !@expr1073755294 var@var3267 .@expr1073755295 isLocal (@expr1073755296 ) ) {
3480: return true ; }
3481: if (@expr1073755297 var@var3267 .@expr1073755298 isArgument (@expr1073755299 ) ) {
3482: return true ; }
3483:
3484: }
3485: }
3486: return false ;
3487: }
3488:
3489: bool isSizeOfEtc ( const Token * tok@var3269 )
3490: {
3491: return Token ::@expr1073755300 Match (@expr1073755301 tok@var3269 , "sizeof|typeof|offsetof|decltype|__typeof__ (" ) ;
3492: }

##file cppcheck-2.8/lib/valueptr.h

15:
|
28:
29: class ValuePtr<InferModel> {
30: struct cloner<InferModel> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<InferModel> :: apply ) ;
41:
42: ValuePtr<InferModel> ( ) : mPtr@var3280 ( nullptr ) , mClone@var3281 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<InferModel> ( const U & value@var3270 ) : mPtr@var3280 ( cloner < U > :: apply ( & value@var3270 ) ) , mClone@var3281 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<InferModel> ( const ValuePtr<InferModel> & rhs@var3271 ) : mPtr@var3280 ( nullptr ) , mClone@var3281 ( rhs@var3271 . mClone@var3272 ) {
50: if (@expr1073755302 rhs@var3271 ) {
51: mPtr@var3280 .@expr1073755303 reset (@expr1073755304 mClone@var3281 (@expr1073755305 rhs@var3271 .@expr1073755306 get (@expr1073755307 ) ) ) ;
52: }
53: }
54: ValuePtr<InferModel> ( ValuePtr<InferModel> && rhs@var3273 ) : mPtr@var3280 ( std :: move ( rhs@var3273 . mPtr@var3274 ) ) , mClone@var3281 ( std :: move ( rhs@var3273 . mClone@var3275 ) ) { }
55:
56: InferModel * release ( ) {
57: return mPtr@var3280 .@expr1073755308 release (@expr1073755309 ) ;
58: }
59:
60: InferModel * get ( ) {
61: return mPtr@var3280 .@expr1073755310 get (@expr1073755311 ) ;
62: }
63: const InferModel * get ( ) const {
64: return mPtr@var3280 .@expr1073755312 get (@expr1073755313 ) ;
65: }
66:
67: InferModel & operator* ( ) {
68: return *@expr1073755314 get (@expr1073755315 ) ;
69: }
70: const InferModel & operator* ( ) const {
71: return *@expr1073755316 get (@expr1073755317 ) ;
72: }
73:
74: InferModel * operator-> ( ) {
75: return get (@expr1073755318 ) ;
76: }
77: const InferModel * operator-> ( ) const {
78: return get (@expr1073755319 ) ;
79: }
80:
81: void swap ( ValuePtr<InferModel> & rhs@var3276 ) {
82:
83: std ::@expr13496 swap (@expr1073755321 mPtr@var3280 , rhs@var3276 .@expr1073755322 mPtr@var3277 ) ;
84: std ::@expr13496 swap (@expr1073755324 mClone@var3281 , rhs@var3276 .@expr1073755325 mClone@var3278 ) ;
85: }
86:
87: ValuePtr<InferModel> & operator= ( ValuePtr<InferModel> rhs@var3279 ) {
88: swap (@expr1073755326 rhs@var3279 ) ;
89: return *@expr1073755327 this@expr1073755328 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073755329 !@expr1073755330 mPtr@var3280 ;
94: }
95: ~ ValuePtr<InferModel> ( ) { }
96:
97: private:
98: std :: shared_ptr < InferModel > mPtr@var3280 ;
99: cloner_type mClone@var3281 ;
100: } ;

##file cppcheck-2.8/lib/settings.h

13:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3282 ; mFlags@var3282 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3282 ;
54: }
55: void clear ( ) {
56: mFlags@var3282 =@expr1073755331 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3282 =@expr1073755332 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3283 ) {
62: if (@expr1073755333 enabled@var3283 ) {
63: fill (@expr1073755334 ) ; }
64: else {
65: clear (@expr1073755335 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3284 ) const {
68: return (@expr13512 mFlags@var3282 &@expr1073755337 (@expr13512 1U <<@expr1073755339 (@expr1073755340 uint32_t ) flag@var3284 ) ) !=@expr1073755341 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3285 ) {
71: mFlags@var3282 |=@expr1073755342 (@expr1073755343 1U <<@expr1073755344 (@expr1073755345 uint32_t ) flag@var3285 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3286 ) {
74: mFlags@var3282 &=@expr1073755346 ~@expr1073755347 (@expr1073755348 1U <<@expr1073755349 (@expr1073755350 uint32_t ) flag@var3286 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3287 , bool enabled@var3288 ) {
77: if (@expr1073755351 enabled@var3288 ) {
78: enable (@expr1073755352 flag@var3287 ) ; }
79: else {
80: disable (@expr1073755353 flag@var3287 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3289 ; mFlags@var3289 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3289 ;
54: }
55: void clear ( ) {
56: mFlags@var3289 =@expr1073755354 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3289 =@expr1073755355 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3290 ) {
62: if (@expr1073755356 enabled@var3290 ) {
63: fill (@expr1073755357 ) ; }
64: else {
65: clear (@expr1073755358 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3291 ) const {
68: return (@expr13535 mFlags@var3289 &@expr1073755360 (@expr13535 1U <<@expr1073755362 (@expr1073755363 uint32_t ) flag@var3291 ) ) !=@expr1073755364 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3292 ) {
71: mFlags@var3289 |=@expr1073755365 (@expr1073755366 1U <<@expr1073755367 (@expr1073755368 uint32_t ) flag@var3292 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3293 ) {
74: mFlags@var3289 &=@expr1073755369 ~@expr1073755370 (@expr1073755371 1U <<@expr1073755372 (@expr1073755373 uint32_t ) flag@var3293 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3294 , bool enabled@var3295 ) {
77: if (@expr1073755374 enabled@var3295 ) {
78: enable (@expr1073755375 flag@var3294 ) ; }
79: else {
80: disable (@expr1073755376 flag@var3294 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3296 ; mFlags@var3296 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3296 ;
54: }
55: void clear ( ) {
56: mFlags@var3296 =@expr1073755377 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3296 =@expr1073755378 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3297 ) {
62: if (@expr1073755379 enabled@var3297 ) {
63: fill (@expr1073755380 ) ; }
64: else {
65: clear (@expr1073755381 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3298 ) const {
68: return (@expr13558 mFlags@var3296 &@expr1073755383 (@expr13558 1U <<@expr1073755385 (@expr1073755386 uint32_t ) flag@var3298 ) ) !=@expr1073755387 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3299 ) {
71: mFlags@var3296 |=@expr1073755388 (@expr1073755389 1U <<@expr1073755390 (@expr1073755391 uint32_t ) flag@var3299 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3300 ) {
74: mFlags@var3296 &=@expr1073755392 ~@expr1073755393 (@expr1073755394 1U <<@expr1073755395 (@expr1073755396 uint32_t ) flag@var3300 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3301 , bool enabled@var3302 ) {
77: if (@expr1073755397 enabled@var3302 ) {
78: enable (@expr1073755398 flag@var3301 ) ; }
79: else {
80: disable (@expr1073755399 flag@var3301 ) ; }
81: }
82: } ;

##file cppcheck-2.8/lib/valueptr.h

8:
|
30:
31: struct ValuePtr<InferModel> :: cloner<InferModel> {
32: static InferModel * apply ( const InferModel * x@var3303 ) {
33: return new InferModel (@expr1073755400 *@expr1073755401 static_cast < const InferModel *@expr1073755402 > (@expr1073755403 x@var3303 ) ) ;
34: }
35: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@49737,34@49993}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  end possible "_cast"@18762
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end possible "_cast"@73
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@194,34@195}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@194,""@195,""@196,"U"@197,"U"@198,"u"@199,"u"@200,"u8"@201,"u8"@202}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@70,34@71}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@67,34@69}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@28,128@29,64@30,32@31,16@32,8@33,4@34,2@35,1@36}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@37,128@38,64@39,32@40,16@41,8@42,4@43,2@44,1@45}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@37,4294967167@38,4294967231@39,4294967263@40,4294967279@41,4294967287@42,4294967291@43,4294967293@44,4294967294@45}
  flag {!<=-1,256@37,128@38,64@39,32@40,16@41,8@42,4@43,2@44,1@45}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {2@157,-2@122}
Line 246
  ( always !0
  this always !0
  index possible -1@132
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(bodyStart->link())@187,symbolic=(parent->astParent())@26,0@26,symbolic=(tok2->astParent()->previous()->link()->previous()),symbolic=(tok2->astParent())@27,symbolic=(parent->astParent()->astOperand1())@27,symbolic=(tok->next())@47,symbolic=(tok->str()=="("?tok->previous():nullptr)@166,symbolic=(varTok2)@201,symbolic=(tok->astParent())@76}
  pattern possible {"std :: ref ("@45,"."@77,"( volatile"@97,"try {"@104,"break ;"@106,"goto"@108,") {"@132,"do {"@138,"} while ("@141,"else {"@148}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@183,4@184,0@185}
  t possible {10@183,4@184,0@185}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@183,4@184,0@185}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@183,0@185}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@183,0@185}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@183}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@183}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@183}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@183}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@183}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"*"@25,"&"@43,"*"@89,"&"@23,"&"@119,"&"@157,"*"@172,"&"@178,"*"@197,"&"@198}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@191}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible "break"@134
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@193,17179869184@204,8589934592@206,34359738368@208,4294967296@210,2147483648@212,1073741824@214,536870912@216,268435456@218}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@24,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@25}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@192,17179869184@203,8589934592@205,34359738368@207,4294967296@209,2147483648@211,1073741824@213,536870912@215,268435456@217}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@192,17179869184@203,8589934592@205,34359738368@207,4294967296@209,2147483648@211,1073741824@213,536870912@215,268435456@217}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@126,4096@129,16384@132,2048@133,1024@134,65536@135,512@136,256@137,128@138}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@91,4194304@93,8388608@94,2097152@96,1048576@97,524288@98,262144@99,131072@100,65536@101}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@69,2097152@70,1048576@71,524288@72,262144@73,131072@74,65536@75,32768@76,16384@77}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@69,4292870143@70,4293918719@71,4294443007@72,4294705151@73,4294836223@74,4294901759@75,4294934527@76,4294950911@77}
  flag {!<=-1,8388608@69,2097152@70,1048576@71,524288@72,262144@73,131072@74,65536@75,32768@76,16384@77}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! {!<=-1,!>=2,1@56}
  ast possible {0@56,symbolic=(forToken->next()->astOperand2()->astOperand2()->astOperand1())@21}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible {lifetime[Lambda]=(unknownVarId)@69,lifetime[Lambda]=(ret)@96,lifetime[Lambda]=(result)@208,lifetime[Lambda]=(pred)@45}
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  false always 0
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  = always 1
  true always 1
Line 199
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  false always 0
  , always 1
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
Line 292
  , always 20
  = always 20
  20 always 20
Line 293
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 299
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 307
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 34
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 35
  = always 0
  0 always 0
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  certainty possible 0@53
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 56
  ( always "Class"
  nullptr always 0
Line 63
  ( always {!<=-1,!>=2}
Line 109
  , always {!<=-1,!>=2}
  allocation always {!<=-1,!>=2}
Line 164
  hash always !<=-1
Line 166
  ( always {!<=-1,!>=2}
Line 167
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 170
  ( always {!<=-1,!>=2}
Line 171
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 172
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 173
  == always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 197
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 198
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 201
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 202
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 203
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
Line 204
  , always {!<=-1,!>=2}
  isprivate always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  derived always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 207
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 214
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 218
  , always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 220
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 221
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 227
  , always {!<=-1,!>=2}
  derivedIsStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  baseIsStruct always {!<=-1,!>=2}
Line 228
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  hasCopyCtor always {!<=-1,!>=2}
Line 235
  nullptr always 0
Line 236
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 237
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 239
  nullptr always 0
  "var" always "var"
Line 240
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 241
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 242
  nullptr always 0
  false always 0
  nullptr always 0
Line 243
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  false always 0
  false always 0
Line 244
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  false always 0
  false always 0
Line 245
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  true always 1
  false always 0
Line 246
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  true always 1
  false always 0
Line 247
  nullptr always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
Line 248
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 249
  nullptr always 0
  "classname" always "classname"
  "funcname" always "funcname"
Line 250
  nullptr always 0
  "memfunc" always "memfunc"
  "classname" always "classname"
  "class" always "class"
Line 251
  nullptr always 0
  "memfunc" always "memfunc"
  "class" always "class"
Line 252
  nullptr always 0
  "class" always "class"
Line 253
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
Line 254
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
  "std::string" always "std::string"
Line 255
  nullptr always 0
  "Base" always "Base"
  "Derived" always "Derived"
  false always 0
Line 256
  nullptr always 0
Line 257
  nullptr always 0
Line 258
  nullptr always 0
  true always 1
Line 259
  nullptr always 0
Line 260
  nullptr always 0
Line 261
  nullptr always 0
  "class" always "class"
  "function" always "function"
  false always 0
Line 262
  nullptr always 0
  "class" always "class"
  "function" always "function"
  true always 1
Line 263
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "variable" always "variable"
Line 264
  nullptr always 0
  "variable" always "variable"
Line 265
  nullptr always 0
  "var" always "var"
Line 266
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "class" always "class"
  "variable" always "variable"
  false always 0
  false always 0
Line 267
  nullptr always 0
  "class" always "class"
  false always 0
  false always 0
Line 268
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 269
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 270
  nullptr always 0
  nullptr always 0
Line 271
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 272
  nullptr always 0
  "UnsafeClass::var" always "UnsafeClass::var"
Line 276
  "Class" always "Class"
Line 280
  "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n" always "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
Line 310
  ( always {!<=-1,!>=2}
Line 311
  ( always {!<=-1,!>=2}
Line 312
  ( always {!<=-1,!>=2}
Line 313
  ( always {!<=-1,!>=2}
Line 314
  TRUE always 0
  FALSE always 1
  BAILOUT always 2
Line 319
  ( always {!<=-1,!>=2}
Line 320
  ( always {!<=-1,!>=2}
Line 321
  ( always {!<=-1,!>=2}
Line 322
  ( always {!<=-1,!>=2}
  memberAccessed always {!<=-1,!>=2}
Line 327
  ( inconclusive lifetime[SubObject]=(var)
  assign always {!<=-1,!>=2}
  false always 0
  init always {!<=-1,!>=2}
  false always 0
Line 333
  assign always {!<=-1,!>=2}
Line 336
  init always {!<=-1,!>=2}
Line 339
  ( always {!<=-1,!>=2}
Line 404
  ( always {!<=-1,!>=2}
Line 406
  ( always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 48
  ( always {!<=-1,!>=2}
Line 50
  = always 0
  nullptr always 0
Line 51
  [ possible lifetime[Lambda]=(pred)
Line 52
  pred possible {lifetime[Lambda]=(start)@74,lifetime[Lambda]=(tok)@132,lifetime[Lambda]=(pointer)@132,lifetime[Lambda]=(childTok)@137}
Line 54
  :: always 4
  done always 4
Line 56
  :: always 3
  op1_and_op2 always 3
Line 64
  ( always {!<=-1,!>=2}
Line 66
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 67
  nullptr always 0
Line 68
  == always {!<=-1,!>=2}
  0 always 0
Line 69
  nullptr always 0
Line 70
  != always {!<=-1,!>=2}
Line 71
  != always {!<=-1,!>=2}
  exprid always !0
Line 76
  nullptr always 0
Line 79
  found always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 81
  ++ possible {>=100,<=99,1}
  depth possible {>=99,<=98,0}
Line 82
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tokToFind)
  || always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  100 always 100
Line 83
  -1 always -1
Line 84
  tok {symbolic=(tokToFind),!0}
  == always {!<=-1,!>=2}
  "," always ","
Line 85
  tok always !0
  found always {!<=-1,!>=2}
  depth always !>=100
Line 86
  == always {!<=-1,!>=2}
  -1 always -1
Line 87
  -1 always -1
Line 88
  found always {!<=-1,!>=2}
Line 89
  res always !-1
Line 90
  = always !-1
  res always !-1
Line 91
  found always 0
Line 92
  == always {!<=-1,!>=2}
  -1 always -1
Line 93
  -1 always -1
Line 94
  res always !-1
Line 96
  == always {!<=-1,!>=2}
  tok always !0
Line 97
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 98
  1 always 1
Line 103
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 104
  tok possible {symbolic=(tok->astOperand2())@35,symbolic=(tok->astOperand1())@35}
  found always 0
  0 always 0
Line 105
  found always {!<=-1,!>=2}
Line 106
  1 always 1
Line 107
  -1 always -1
Line 112
  ( always {!<=-1,!>=2}
  tok always symbolic=(ftok)
  "%name% (|{" always "%name% (|{"
Line 113
  ftok always symbolic=(tok)
Line 114
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(ftok),symbolic=(ftok->next())}
  "(|{|[" always "(|{|["
Line 115
  -1 always -1
Line 117
  ! always {!<=-1,!>=2}
  startTok always symbolic=(tok->astOperand2())
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 119
  startTok possible {symbolic=(tok->astOperand2()),symbolic=(tok->astOperand1())}
Line 123
  , always 0
  = always 0
  0 always 0
Line 125
  ++ possible {>=100,<=99,1}
  depth possible {>=99,<=98,0}
Line 126
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  100 always 100
Line 128
  tok always !0
  == always {!<=-1,!>=2}
Line 129
  tok always !0
  depth always !>=100
Line 130
  tok always !0
  depth always !>=100
Line 132
  result possible lifetime[Object]=(tok)
  tok always !0
Line 139
  tok possible symbolic=(tok)@95
  & {lifetime[Address]=(result),!0}
  result always size=0
  op possible {","@58,"."@95}
Line 146
  & {lifetime[Address]=(result),!0}
  result always size=0
Line 153
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 154
  0 always 0
Line 155
  tok always !0
  == always {!<=-1,!>=2}
  op possible ","@66
Line 156
  tok always !0
  op always symbolic=(tok->str())
  depth always !<=-1
  tok always !0
  op always symbolic=(tok->str())
  depth always !<=-1
Line 158
  1 always 1
Line 161
  ( always {!<=-1,!>=2}
Line 163
  ! always {!<=-1,!>=2}
  root possible symbolic=(tok)
Line 164
  return always {!<=-1,!>=2}
  false always 0
Line 165
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  root always !0
Line 166
  = always !0
  tok always !symbolic=(root)
  ( always !0
Line 167
  return always {!<=-1,!>=2}
  root {symbolic=(tok),!0}
  == {!<=-1,!>=2,1}
  tok possible symbolic=(root)
Line 170
  ( always {!<=-1,!>=2}
Line 172
  ! always {!<=-1,!>=2}
Line 173
  return always {!<=-1,!>=2}
  false always 0
Line 174
  tok always !0
  == always {!<=-1,!>=2}
Line 175
  return always {!<=-1,!>=2}
  true always 1
Line 176
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  varid always !symbolic=(tok->varId())
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  varid always !symbolic=(tok->varId())
Line 179
  ( always {!<=-1,!>=2}
Line 181
  ! always {!<=-1,!>=2}
Line 182
  return always {!<=-1,!>=2}
  false always 0
Line 183
  tok always !0
Line 184
  ! always {!<=-1,!>=2}
  valueType always symbolic=(tok->valueType())
Line 185
  return always {!<=-1,!>=2}
  false always 0
Line 186
  return always {!<=-1,!>=2}
  valueType {symbolic=(tok->valueType()),!0}
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  && always {!<=-1,!>=2}
  valueType {symbolic=(tok->valueType()),!0}
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  valueType {symbolic=(tok->valueType()),!0}
  == always {!<=-1,!>=2}
Line 189
  ( always {!<=-1,!>=2}
Line 191
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 194
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_SIGN always 0
Line 199
  ( always {!<=-1,!>=2}
Line 201
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  || always {!<=-1,!>=2}
  tok always !0
  ( always !0
  . always !9
  == always {!<=-1,!>=2}
  :: always 11
  WCHAR_T always 11
Line 204
  ( always {!<=-1,!>=2}
Line 206
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 207
  ! {!<=-1,!>=2,1}
  vt {symbolic=(tok?tok->valueType():nullptr),0}
Line 208
  return always {!<=-1,!>=2}
  false always 0
Line 209
  return always {!<=-1,!>=2}
  vt {symbolic=(tok?tok->valueType():nullptr),!0}
  ( always {!<=-1,!>=2}
Line 212
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 214
  = possible 0
  tok possible symbolic=(stream->astParent()->astOperand1())@32
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 215
  ! {!<=-1,!>=2,1}
  vt {symbolic=(tok?tok->valueType():nullptr),0}
Line 216
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 217
  return always {!<=-1,!>=2}
  vt {symbolic=(tok?tok->valueType():nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  vt {symbolic=(tok?tok->valueType():nullptr),!0}
  == always {!<=-1,!>=2}
  0U always 0
Line 220
  ( always {!<=-1,!>=2}
Line 222
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 225
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 227
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 228
  ! {!<=-1,!>=2,1}
  vt {symbolic=(tok?tok->valueType():nullptr),0}
Line 229
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 230
  return always {!<=-1,!>=2}
  vt {symbolic=(tok?tok->valueType():nullptr),!0}
  >= always {!<=-1,!>=2}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  vt {symbolic=(tok?tok->valueType():nullptr),!0}
  == always {!<=-1,!>=2}
  0U always 0
Line 233
  ( always {!<=-1,!>=2}
Line 235
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 238
  ( always {!<=-1,!>=2}
Line 240
  return always {!<=-1,!>=2}
  tok possible 0@7
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 243
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 248
  ( always {!<=-1,!>=2}
Line 250
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 251
  return always {!<=-1,!>=2}
  false always 0
Line 252
  ! always {!<=-1,!>=2}
Line 253
  return always {!<=-1,!>=2}
  false always 0
Line 254
  return always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
Line 257
  ( always {!<=-1,!>=2}
Line 259
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 262
  ( always {!<=-1,!>=2}
Line 263
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 266
  ( always {!<=-1,!>=2}
Line 269
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 273
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 278
  ! always {!<=-1,!>=2}
Line 279
  "" always ""
Line 280
  expr always !0
Line 281
  && always {!<=-1,!>=2}
Line 283
  = always !0
  . always !0
  ( always {!<=-1,!>=2}
  "%name%|::" always "%name%|::"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always !0
Line 284
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const|static" always "const|static"
Line 287
  ret possible size=0
Line 289
  "" always ""
Line 292
  ( always {!<=-1,!>=2}
Line 294
  == always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  true always 1
Line 296
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 297
  return always {!<=-1,!>=2}
  true always 1
Line 298
  return always {!<=-1,!>=2}
  false always 0
Line 303
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astOperand1())@221
Line 304
  nullptr always 0
Line 306
  = always 0
  nullptr always 0
Line 307
  tok {!0,symbolic=(tok->astOperand1())@221}
  ( always {!<=-1,!>=2}
Line 308
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 310
  tok always !0
Line 311
  s always symbolic=(tok->str())
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,0}
  '>' always 62
Line 312
  s always symbolic=(tok->str())
  0 always 0
  = always 60
  '<' always 60
Line 313
  s always symbolic=(tok->str())
  [ always !62
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 314
  s always symbolic=(tok->str())
  0 always 0
  = always 62
  '>' always 62
Line 315
  == always {!<=-1,!>=2}
Line 316
  tok always !0
Line 318
  tok always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 319
  tok always !0
Line 321
  comp possible size=2
  == always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "0" always "0"
Line 322
  tok always !0
  == always {!<=-1,!>=2}
  "!" always "!"
Line 323
  tok always !0
Line 325
  ret always symbolic=(tok->astOperand1())
  "==" always "=="
  "0" always "0"
  & {lifetime[Address]=(ret),!0}
  ret always symbolic=(tok->astOperand1())
Line 327
  = always !0
  tok always !0
Line 328
  == always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "0" always "0"
Line 329
  tok always !0
  == always {!<=-1,!>=2}
  "!" always "!"
Line 330
  tok always !0
Line 332
  ret always symbolic=(tok->astOperand1())
  "!=" always "!="
  "0" always "0"
  & {lifetime[Address]=(ret),!0}
  ret always symbolic=(tok->astOperand1())
Line 335
  ret possible {symbolic=(tok->astOperand2()),symbolic=(tok->astOperand1()),symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ret always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 336
  ret always !0
Line 337
  ret possible 0
  && always {!<=-1,!>=2}
  ret always !0
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ret always !0
  && always {!<=-1,!>=2}
  ( always !0
Line 338
  = always !0
  ret always !0
  ( always !0
Line 339
  ret possible 0
  && always {!<=-1,!>=2}
  ret always !0
  == always {!<=-1,!>=2}
  0U always 0
Line 340
  = always 0
  nullptr always 0
Line 342
  vartok always !0
Line 343
  ret possible symbolic=(*vartok)
Line 346
  ( always {!<=-1,!>=2}
Line 348
  ! always {!<=-1,!>=2}
Line 349
  return always {!<=-1,!>=2}
  false always 0
Line 350
  tok always !0
Line 351
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 352
  return always {!<=-1,!>=2}
  false always 0
Line 353
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  tok {symbolic=(var->declEndToken()->next()),!0}
Line 354
  return always {!<=-1,!>=2}
  true always 1
Line 355
  ( always {!<=-1,!>=2}
  var always !0
  "; %var%" always "; %var%"
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  tok always !symbolic=(var->nameToken())
Line 356
  return always {!<=-1,!>=2}
  true always 1
Line 357
  return always {!<=-1,!>=2}
  false always 0
Line 360
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 362
  ! always {!<=-1,!>=2}
  tok possible symbolic=(var->declEndToken()->astOperand2())@139
Line 363
  return always {!<=-1,!>=2}
  false always 0
Line 364
  ( always {!<=-1,!>=2}
  tok {!0,symbolic=(var->declEndToken()->astOperand2())@139}
  "." always "."
Line 365
  return always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
Line 366
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  tok always !0
Line 367
  ( always {!<=-1,!>=2}
  tok always !0
  ",|::" always ",|::"
Line 368
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  tok always !0
Line 369
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 371
  ( always {!<=-1,!>=2}
  "?|.|[|++|--|%name%|%assign%" always "?|.|[|++|--|%name%|%assign%"
Line 372
  return always {!<=-1,!>=2}
  false always 0
Line 373
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 374
  return always {!<=-1,!>=2}
  false always 0
Line 375
  ( always {!<=-1,!>=2}
  "&|<<|>>" always "&|<<|>>"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 376
  return always {!<=-1,!>=2}
  false always 0
Line 377
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 378
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")" always ")"
Line 380
  return always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 382
  = always 0
  nullptr always 0
Line 383
  ( always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
Line 384
  ( always !0
Line 387
  ! always {!<=-1,!>=2}
  ftok possible {symbolic=(tok->previous()->link()->previous()),symbolic=(tok->previous())}
Line 388
  return always {!<=-1,!>=2}
  false always 0
Line 389
  ftok always !0
Line 390
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  f always !0
  true always 1
Line 391
  ftok always !0
Line 392
  return always {!<=-1,!>=2}
  true always 1
Line 394
  library always !0
  ftok always !0
Line 395
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  returnType possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  returnType always !size=0
  != always {!<=-1,!>=2}
  '&' always 38
Line 397
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 400
  ( always {!<=-1,!>=2}
Line 401
  return always {!<=-1,!>=2}
  false always 0
Line 403
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 404
  return always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 405
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 406
  ! always {!<=-1,!>=2}
Line 407
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  ( always !0
Line 408
  return always {!<=-1,!>=2}
  true always 1
Line 411
  ( always {!<=-1,!>=2}
Line 413
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 414
  return always {!<=-1,!>=2}
  true always 1
Line 415
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> (" always "> ("
Line 416
  return always {!<=-1,!>=2}
  true always 1
Line 417
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
Line 419
  return always {!<=-1,!>=2}
  false always 0
Line 422
  ( always {!<=-1,!>=2}
Line 424
  tok2 possible symbolic=(tok)
  != always {!<=-1,!>=2}
Line 425
  == always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  true always 1
Line 428
  return always {!<=-1,!>=2}
  false always 0
Line 434
  ! always {!<=-1,!>=2}
Line 435
  nullptr always 0
Line 436
  = always !0
  tok always !0
Line 437
  leftmostLeaf possible symbolic=(tok)
Line 439
  leftmostLeaf possible symbolic=(tok)
Line 455
  ! always {!<=-1,!>=2}
  rightmostLeaf always symbolic=(tok)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  rightmostLeaf {symbolic=(tok),!0}
Line 456
  nullptr always 0
Line 458
  rightmostLeaf possible symbolic=(tok)
Line 459
  = always !0
  lam always !0
Line 462
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 463
  = always !0
  ( always !0
Line 464
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 465
  = always !0
  ( always !0
Line 468
  || always {!<=-1,!>=2}
Line 469
  ( always {!<=-1,!>=2}
  rightmostLeaf possible symbolic=(lam)
  "]|)" always "]|)"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rightmostLeaf possible symbolic=(lam)
  rightmostLeaf possible symbolic=(lam)
Line 471
  ( always {!<=-1,!>=2}
  rightmostLeaf possible symbolic=(lam)
  "{|(|[" always "{|(|["
  && always {!<=-1,!>=2}
Line 472
  = always !0
  ( always !0
Line 491
  ! always {!<=-1,!>=2}
Line 492
  nullptr always 0
Line 493
  tok always !0
Line 494
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "(" always "("
Line 495
  parent always symbolic=(tok->astParent())
Line 496
  parent always symbolic=(tok->astParent())
  != always {!<=-1,!>=2}
  tok always !0
Line 497
  parent always symbolic=(tok->astParent())
Line 498
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  || always {!<=-1,!>=2}
Line 499
  ( always {!<=-1,!>=2}
  "> (" always "> ("
  && always {!<=-1,!>=2}
Line 506
  ! always {!<=-1,!>=2}
Line 507
  tok always 0
Line 508
  tok always !0
Line 509
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "." always "."
Line 510
  tok always !0
Line 511
  ( always {!<=-1,!>=2}
  tok always !0
Line 512
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "." always "."
Line 513
  parent always symbolic=(tok->astParent())
Line 517
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  "." always "."
  || always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  != always {!<=-1,!>=2}
Line 519
  gparent always symbolic=(parent->astParent())
Line 520
  gparent always symbolic=(parent->astParent())
  ( always !0
Line 526
  ! always {!<=-1,!>=2}
Line 527
  tok always 0
Line 529
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ". *" always ". *"
Line 530
  tok always !0
Line 532
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 533
  tok always !0
Line 534
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 535
  tok always !0
Line 537
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always !0
Line 538
  parent inconclusive lifetime[Object]=(tok)
  != always {!<=-1,!>=2}
  tok always !0
Line 539
  ( inconclusive lifetime[Object]=(tok)
  parent {lifetime[Object]=(tok),!symbolic=(tok)}
Line 540
  tok {!0,symbolic=(parent)}
Line 545
  ! always {!<=-1,!>=2}
Line 546
  { always {size=0,{}
Line 547
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "." always "."
Line 548
  { always {size=1,{}
  tok always !0
Line 549
  = always !0
  tok always !0
Line 550
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  "." always "."
Line 553
  parent possible symbolic=(tok)
  "." always "."
Line 554
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 556
  ( possible lifetime[Iterator]=(result)
  ( {lifetime[Iterator]=(result),end=0}
  ( {lifetime[Iterator]=(sub),start=0}
  ( {lifetime[Iterator]=(sub),end=0}
Line 563
  cpp always {!<=-1,!>=2}
Line 566
  ( always !<=-1
  < always {!<=-1,!>=2}
  2 always 2
Line 569
  = {lifetime[Iterator]=(members),!<=size=1,>=size=2}
  ( {lifetime[Iterator]=(members),!<=size=1,>=size=2}
  members {!<=size=1,>=size=2}
  ( {lifetime[Iterator]=(members),!<=size=1,>=size=2,start=0}
  members {!<=size=1,>=size=2}
  ( {lifetime[Iterator]=(members),!<=size=1,>=size=2,end=0}
  [ possible lifetime[Lambda]=(cpp)
Line 571
  var always symbolic=(tok2->variable())
Line 572
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
Line 574
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 577
  it {lifetime[Iterator]=(members),!<=size=1,>=size=2}
  == always {!<=-1,!>=2}
  members {!<=size=1,>=size=2}
  ( {lifetime[Iterator]=(members),!<=size=1,>=size=2,end=0}
Line 580
  ( always {!<=-1,!>=2}
  it {lifetime[Iterator]=(members),!symbolic=(members.rend()),!end=0,!<=size=1}
  1 always 1
  members always !<=size=1
  ( {lifetime[Iterator]=(members),!<=size=1,end=0}
  - {lifetime[Iterator]=(members),!<=size=1,end=-1}
  1 always 1
Line 581
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 582
  true always 1
Line 583
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 584
  ( always {!<=-1,!>=2}
Line 585
  true always 1
Line 587
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 589
  ! always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
  endTok always !0
  "." always "."
Line 593
  ( always {!<=-1,!>=2}
  "." always "."
Line 597
  ( always {!<=-1,!>=2}
  dotTok possible symbolic=(endTok)
  "." always "."
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "->" always "->"
Line 598
  true always 1
Line 601
  && always {!<=-1,!>=2}
Line 603
  nullptr always 0
Line 607
  ( always {!<=-1,!>=2}
Line 609
  ! always {!<=-1,!>=2}
Line 610
  return always {!<=-1,!>=2}
  false always 0
Line 611
  tok always !0
Line 612
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 613
  return always {!<=-1,!>=2}
  false always 0
Line 614
  ! always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
Line 615
  return always {!<=-1,!>=2}
  false always 0
Line 616
  ! always {!<=-1,!>=2}
  parent always !0
Line 617
  return always {!<=-1,!>=2}
  false always 0
Line 618
  return always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 620
  ( always {!<=-1,!>=2}
Line 622
  ! always {!<=-1,!>=2}
Line 623
  return always {!<=-1,!>=2}
  false always 0
Line 624
  tok always !0
Line 625
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 626
  return always {!<=-1,!>=2}
  false always 0
Line 627
  ! always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
Line 628
  return always {!<=-1,!>=2}
  false always 0
Line 629
  ! always {!<=-1,!>=2}
  parent always !0
Line 630
  return always {!<=-1,!>=2}
  false always 0
Line 631
  return always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 637
  ! always {!<=-1,!>=2}
Line 638
  nullptr always 0
Line 639
  ( always {!<=-1,!>=2}
  tok always !0
  "(" always "("
Line 640
  tok always !0
Line 641
  ( always {!<=-1,!>=2}
  tok always !0
  "for" always "for"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";" always ";"
  && always {!<=-1,!>=2}
Line 642
  tok always !0
Line 643
  tok always !0
Line 644
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 652
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 653
  nullptr always 0
Line 655
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{" always "{"
Line 656
  nullptr always 0
Line 657
  ( always {!<=-1,!>=2}
  ")" always ")"
Line 659
  ( always {!<=-1,!>=2}
  -2 always -2
  "} else {" always "} else {"
Line 660
  -2 always -2
Line 662
  nullptr always 0
Line 668
  ! always {!<=-1,!>=2}
Line 669
  nullptr always 0
Line 670
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 671
  tok always !0
Line 672
  tok always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 673
  nullptr always 0
Line 674
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 675
  nullptr always 0
Line 676
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 677
  nullptr always 0
Line 684
  ! always {!<=-1,!>=2}
Line 685
  nullptr always 0
Line 686
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 687
  tok always !0
Line 688
  tok always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 689
  nullptr always 0
Line 690
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 691
  nullptr always 0
Line 692
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 693
  nullptr always 0
Line 732
  scope possible symbolic=(breakToken->scope())
Line 733
  scope {symbolic=(breakToken->scope()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  scope always !0
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 734
  scope always !0
  . possible 11
  == {!<=-1,!>=2,0}
  :: always 10
  eDo always 10
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  scope always !0
  "} while (" always "} while ("
Line 735
  scope always !0
  2 always 2
Line 736
  scope always !0
Line 738
  scope always !0
Line 740
  nullptr always 0
Line 743
  ( always {!<=-1,!>=2}
Line 751
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 752
  return always {!<=-1,!>=2}
  false always 0
Line 756
  ! always {!<=-1,!>=2}
  initExpr always symbolic=(forToken->next()->astOperand2()->astOperand1())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  initExpr {symbolic=(forToken->next()->astOperand2()->astOperand1()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  initExpr {symbolic=(forToken->next()->astOperand2()->astOperand1()),!0}
  != always {!<=-1,!>=2}
  "=" always "="
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  initExpr always symbolic=(forToken->next()->astOperand2()->astOperand1())
  "%var%" always "%var%"
Line 757
  return always {!<=-1,!>=2}
  false always 0
Line 758
  initExpr {symbolic=(forToken->next()->astOperand2()->astOperand1()),!0}
Line 759
  initExpr {symbolic=(forToken->next()->astOperand2()->astOperand1()),!0}
Line 760
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  initExpr {symbolic=(forToken->next()->astOperand2()->astOperand1()),!0}
  ( always {!<=-1,!>=2}
Line 761
  ( always {!<=-1,!>=2}
  0 always 0
  : always 0
  minInitValue always !size=0
Line 762
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condExpr always symbolic=(forToken->next()->astOperand2()->astOperand2()->astOperand1())
  "%oror%|&&" always "%oror%|&&"
Line 763
  condExpr always symbolic=(forToken->next()->astOperand2()->astOperand2()->astOperand1())
  [ possible {lifetime[Lambda]=(condExpr),lifetime[Lambda]=(varid)}
  , {lifetime[Address]=(condExpr),!0}
  & {lifetime[Address]=(condExpr),!0}
Line 764
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 765
  :: always 3
  op1_and_op2 always 3
Line 766
  ( always {!<=-1,!>=2}
  "<|<=" always "<|<="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 767
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 770
  :: always 0
  none always 0
Line 772
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|<=" always "<|<="
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 773
  return always {!<=-1,!>=2}
  false always 0
Line 774
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  incExpr always !0
  ( always {!<=-1,!>=2}
  "++" always "++"
  || always {!<=-1,!>=2}
  incExpr always !0
  != always {!<=-1,!>=2}
  * always symbolic=(condExpr->astOperand1()->varId())
Line 775
  return always {!<=-1,!>=2}
  false always 0
Line 776
  = always 1
  1 always 1
Line 777
  == always {!<=-1,!>=2}
  "<" always "<"
Line 778
  1 always 1
Line 781
  return always {!<=-1,!>=2}
  true always 1
Line 787
  ! always {!<=-1,!>=2}
  var possible symbolic=(tok->variable())@171
Line 788
  nullptr always 0
Line 789
  var {!0,symbolic=(tok->variable())@171}
Line 790
  ! always {!<=-1,!>=2}
  varDeclEndToken always symbolic=(var->declEndToken())
Line 791
  nullptr always 0
Line 792
  ( always {!<=-1,!>=2}
  varDeclEndToken {symbolic=(var->declEndToken()),!0}
  "; %varid% =" always "; %varid% ="
  var always !0
Line 793
  varDeclEndToken {symbolic=(var->declEndToken()),!0}
  2 always 2
Line 794
  varDeclEndToken always !0
Line 797
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for|while (" always "for|while ("
Line 803
  ( always {!<=-1,!>=2}
Line 805
  tok1 possible {0,symbolic=(var->declEndToken())@60141}
  == {!<=-1,!>=2,1}
  tok2 possible {0,symbolic=(tok)@30566}
Line 806
  return always {!<=-1,!>=2}
  false always 0
Line 807
  ! always {!<=-1,!>=2}
  tok1 always !symbolic=(tok2)
Line 808
  return always {!<=-1,!>=2}
  false always 0
Line 809
  ! always {!<=-1,!>=2}
  tok2 always !symbolic=(tok1)
Line 810
  return always {!<=-1,!>=2}
  true always 1
Line 811
  return always {!<=-1,!>=2}
  tok1 always !0
  < always {!<=-1,!>=2}
  tok2 always !0
Line 815
  ( always {!<=-1,!>=2}
Line 817
  tok1 possible 0
  == {!<=-1,!>=2,1}
  tok2 possible 0
Line 818
  return always {!<=-1,!>=2}
  false always 0
Line 819
  ! always {!<=-1,!>=2}
  tok1 always !symbolic=(tok2)
Line 820
  return always {!<=-1,!>=2}
  false always 0
Line 821
  ! always {!<=-1,!>=2}
  tok2 always !symbolic=(tok1)
Line 822
  return always {!<=-1,!>=2}
  true always 1
Line 823
  return always {!<=-1,!>=2}
  tok1 always !0
  > always {!<=-1,!>=2}
  tok2 always !0
Line 826
  ( always {!<=-1,!>=2}
Line 828
  == always {!<=-1,!>=2}
  varid possible symbolic=(val.tokvalue->varId())
Line 829
  return always {!<=-1,!>=2}
  false always 0
Line 831
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 833
  == always {!<=-1,!>=2}
Line 834
  ( always {!<=-1,!>=2}
Line 836
  * always {!<=-1,!>=2}
  inconclusive always !0
  = always 1
  true always 1
Line 840
  return always {!<=-1,!>=2}
  true always 1
Line 843
  return always {!<=-1,!>=2}
  false always 0
Line 846
  ( always {!<=-1,!>=2}
Line 848
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  startTok possible symbolic=(var->declEndToken())@234
Line 849
  return always {!<=-1,!>=2}
  false always 0
Line 850
  != always {!<=-1,!>=2}
Line 851
  ( always {!<=-1,!>=2}
  "= & %varid% ;" always "= & %varid% ;"
Line 852
  return always {!<=-1,!>=2}
  true always 1
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  true always 1
Line 856
  return always {!<=-1,!>=2}
  false always 0
Line 859
  ( always {!<=-1,!>=2}
Line 861
  ! always {!<=-1,!>=2}
Line 862
  return always {!<=-1,!>=2}
  false always 0
Line 863
  ! always {!<=-1,!>=2}
  var always !0
Line 864
  return always {!<=-1,!>=2}
  false always 0
Line 865
  var always !0
Line 866
  ! always {!<=-1,!>=2}
  start always symbolic=(var->declEndToken())
Line 867
  return always {!<=-1,!>=2}
  false always 0
Line 868
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(var->declEndToken()),!0}
  ( always !0
Line 871
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  onVar always {!<=-1,!>=2}
Line 873
  ! always {!<=-1,!>=2}
Line 874
  return always {!<=-1,!>=2}
  false always 0
Line 875
  expr always !0
  == always {!<=-1,!>=2}
  "this" always "this"
Line 876
  return always {!<=-1,!>=2}
  true always 1
Line 877
  >= always {!<=-1,!>=2}
  1000 always 1000
Line 879
  return always {!<=-1,!>=2}
  true always 1
Line 880
  ++ {!>=1001,<=1000}
  depth {!>=1000,<=999}
Line 882
  ( always {!<=-1,!>=2}
  "!!:: %name% (" always "!!:: %name% ("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 883
  ( always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 886
  ! {!<=-1,!>=2,1}
  fScope possible symbolic=(expr->scope())
  . possible 0
  && always {!<=-1,!>=2}
  fScope possible symbolic=(expr->scope())
Line 887
  = always !0
  . always !0
Line 889
  fScope possible symbolic=(expr->scope())
Line 890
  classScope {symbolic=(fScope->functionOf),0}
  && always {!<=-1,!>=2}
  classScope {symbolic=(fScope->functionOf),!0}
Line 891
  classScope {symbolic=(fScope->functionOf),!0}
  . always !0
Line 893
  classScope possible symbolic=(fScope->functionOf)
  && always {!<=-1,!>=2}
  classScope always !0
  ( always {!<=-1,!>=2}
Line 894
  return always {!<=-1,!>=2}
  classScope always !0
  ( always !0
  . always !0
Line 895
  return always {!<=-1,!>=2}
  false always 0
Line 896
  onVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
  && always {!<=-1,!>=2}
Line 897
  = always !0
  ( always !0
Line 898
  return always {!<=-1,!>=2}
  var {symbolic=(expr->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(expr->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(expr->variable()),!0}
  ( always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
  "." always "."
Line 901
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  onVar always {!<=-1,!>=2}
  depth always !>=1001
Line 902
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  onVar always {!<=-1,!>=2}
  depth always !>=1001
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  onVar always {!<=-1,!>=2}
  depth always !>=1001
Line 905
  ( always {!<=-1,!>=2}
Line 907
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  [ possible lifetime[Lambda]=(result)
Line 909
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 910
  result always {!<=-1,!>=2}
  = always 1
  true always 1
Line 911
  :: always 4
  done always 4
Line 913
  :: always 3
  op1_and_op2 always 3
Line 915
  return always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 920
  ! always {!<=-1,!>=2}
  var possible symbolic=(tok->variable())@132
Line 921
  return always {!<=-1,!>=2}
  false always 0
Line 922
  var {!0,symbolic=(tok->variable())@132}
Line 923
  ( always {!<=-1,!>=2}
  tok possible symbolic=(var->nameToken())
  "[|," always "[|,"
Line 925
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(var->nameToken())
  "[" always "["
Line 931
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 933
  ! always {!<=-1,!>=2}
Line 934
  tok always 0
Line 936
  && always {!<=-1,!>=2}
  end always !0
  != always {!<=-1,!>=2}
  tok always !0
Line 937
  tok always !0
Line 939
  ( always {!<=-1,!>=2}
  tok always !0
  "%var% [" always "%var% ["
Line 940
  tok always !0
Line 942
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 945
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 948
  var always symbolic=(tok->variable())
Line 949
  ! always {!<=-1,!>=2}
Line 951
  ( always {!<=-1,!>=2}
  varTok always !0
Line 953
  ( always {!<=-1,!>=2}
Line 955
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 957
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 959
  ( always {!<=-1,!>=2}
Line 961
  ( always {!<=-1,!>=2}
Line 964
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 966
  ( always {!<=-1,!>=2}
Line 968
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always !symbolic=(tok->scope())
Line 969
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  cpp always {!<=-1,!>=2}
Line 971
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 974
  ! always {!<=-1,!>=2}
Line 976
  varTok possible symbolic=(startToken)
  == always {!<=-1,!>=2}
  0 always 0
Line 977
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 979
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 981
  ( always {!<=-1,!>=2}
  nullptr always 0
  cpp always {!<=-1,!>=2}
Line 989
  ! always {!<=-1,!>=2}
Line 991
  ! always {!<=-1,!>=2}
Line 993
  ! always {!<=-1,!>=2}
Line 995
  = possible lifetime[Object]=(tok2)
  ( possible lifetime[Object]=(tok2)
  tok2 always !0
  "'" always "'"
  tok1 always !0
  "' is assigned value '" always "' is assigned value '"
  "' here." always "' here."
Line 996
  ( always start=0
  ( always end=0
  item possible lifetime[Object]=(tok2)
  != always {!<=-1,!>=2}
  ( always end=0
Line 998
  errors inconclusive lifetime[Object]=(tok2)
  item inconclusive lifetime[Object]=(tok2)
Line 1002
  temporary always {!<=-1,!>=2}
Line 1003
  inconclusive always {!<=-1,!>=2}
Line 1008
  ( always {!<=-1,!>=2}
Line 1009
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 1012
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(var->declEndToken()->astOperand2())@142,symbolic=(args[n])@163}
Line 1013
  { always {size=0,{}
Line 1014
  < always {!<=-1,!>=2}
  0 always 0
Line 1015
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always !0
  ( possible lifetime[Object]=(errors)
Line 1016
  tok always !0
Line 1017
  var always symbolic=(tok->variable())
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  tok always !0
Line 1018
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 1019
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok {symbolic=(var->nameToken()),!0}
  ( possible lifetime[Object]=(errors)
Line 1020
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1021
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 1022
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always {!symbolic=(var->nameToken()),!0}
  ( possible lifetime[Object]=(errors)
Line 1023
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1024
  var {symbolic=(tok->variable()),!0}
  ( always !0
  "Passed to reference." always "Passed to reference."
Line 1025
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always !symbolic=(var->nameToken())
  ( possible lifetime[Object]=(errors)
Line 1026
  ( always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always !0
  "=" always "="
Line 1027
  ( always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always !0
  tok always !symbolic=(var->nameToken())
Line 1028
  { always {size=0,{}
Line 1029
  ( always !0
  "Assigned to reference." always "Assigned to reference."
Line 1031
  vartok {symbolic=(var->declEndToken()->astOperand2()),0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  temporary always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  vartok {symbolic=(var->declEndToken()->astOperand2()),!symbolic=(tok)}
  nullptr always 0
  true always 1
  && always {!<=-1,!>=2}
Line 1032
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1033
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok possible symbolic=(vartok)
  ( possible lifetime[Object]=(errors)
Line 1034
  vartok {symbolic=(var->declEndToken()->astOperand2()),!symbolic=(tok)}
Line 1035
  ( inconclusive lifetime[Object]=(errors)
  vartok {symbolic=(var->declEndToken()->astOperand2()),!symbolic=(tok),!0}
  temporary always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errors)
  1 always 1
Line 1037
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always !symbolic=(var->nameToken())
  ( possible lifetime[Object]=(errors)
Line 1040
  ( always {!<=-1,!>=2}
  tok always !0
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ":" always ":"
Line 1042
  tok always !0
Line 1045
  = inconclusive lifetime[Object]=(errors)
  ( inconclusive lifetime[Object]=(errors)
  tok2 always symbolic=(tok->astOperand2())
  temporary always {!<=-1,!>=2}
  inconclusive {!<=-1,!>=2,0}
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 1046
  result always size=0
  refs inconclusive lifetime[Object]=(errors)
  ( {lifetime[Iterator]=(refs),start=0}
  ( {lifetime[Iterator]=(refs),end=0}
Line 1047
  = inconclusive lifetime[Object]=(errors)
  ( inconclusive lifetime[Object]=(errors)
  tok2 always symbolic=(tok->astOperand2())
  temporary always {!<=-1,!>=2}
  inconclusive {!<=-1,!>=2,0}
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 1048
  refs inconclusive lifetime[Object]=(errors)
  ( {lifetime[Iterator]=(refs),start=0}
  ( {lifetime[Iterator]=(refs),end=0}
Line 1050
  ! always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  != always {!<=-1,!>=2}
  1 always 1
Line 1051
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always !0
  ( possible lifetime[Object]=(errors)
Line 1053
  ! {!<=-1,!>=2,0,1}
  result possible {size=0,size=1}
  ( {!<=-1,!>=2,1,0}
Line 1054
  ( {size=1,!size=0}
  result {size=1,!size=0}
  ( {lifetime[Iterator]=(result),size=1,!size=0,start=0}
  result {size=1,!size=0}
  ( {lifetime[Iterator]=(result),size=1,!size=0,end=0}
Line 1056
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 1057
  tok always !0
Line 1058
  f always symbolic=(tok->previous()->function())
Line 1059
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  f {symbolic=(tok->previous()->function()),!0}
Line 1060
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  tok always !0
  ( possible lifetime[Object]=(errors)
Line 1062
  f {symbolic=(tok->previous()->function()),!0}
Line 1064
  == always {!<=-1,!>=2}
Line 1067
  ( inconclusive lifetime[Object]=(errors)
  returnTok always !symbolic=(tok)
  temporary always {!<=-1,!>=2}
  inconclusive {!<=-1,!>=2,0}
  - always !<=-1
  ( always !<=-1
Line 1069
  ! always {!<=-1,!>=2}
  argvar always symbolic=(rt.token->variable())
Line 1070
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  ( possible lifetime[Object]=(errors)
Line 1071
  argvar {symbolic=(rt.token->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvar {symbolic=(rt.token->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  argvar {symbolic=(rt.token->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1072
  argvar {symbolic=(rt.token->variable()),!0}
Line 1073
  < always {!<=-1,!>=2}
  0 always 0
Line 1074
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  ( possible lifetime[Object]=(errors)
Line 1076
  n {!<=-1,>=0}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 1077
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  ( possible lifetime[Object]=(errors)
Line 1078
  n {!>=symbolic=(args.size()),<=symbolic=(args.size()-1),!<=-1}
Line 1080
  er always symbolic=(errors)
  "Return reference." always "Return reference."
Line 1081
  "Called function passing '" always "Called function passing '"
  argTok always symbolic=(args[n])
  "'." always "'."
Line 1083
  argTok always symbolic=(args[n])
  temporary always {!<=-1,!>=2}
  inconclusive {!<=-1,!>=2,0}
  er always !size=0
  - always !<=-1
  ( always !<=-1
Line 1084
  ( {lifetime[Iterator]=(refs),start=0}
  ( {lifetime[Iterator]=(refs),end=0}
Line 1085
  ! always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 1086
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  ( possible lifetime[Object]=(errors)
Line 1090
  ! {!<=-1,!>=2,0}
  result possible size=0
  ( {!<=-1,!>=2,1}
Line 1091
  ( always !size=0
  result always !size=0
  ( {lifetime[Iterator]=(result),!size=0,start=0}
  result always !size=0
  ( {lifetime[Iterator]=(result),!size=0,end=0}
Line 1094
  { {lifetime[SubObject]=(tok),lifetime[SubObject]=(errors),size=2,{}
  ( possible lifetime[Object]=(errors)
Line 1099
  ! always {!<=-1,!>=2}
Line 1100
  nullptr always 0
Line 1101
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok always !0
  true always 1
  false always 0
Line 1102
  refs inconclusive lifetime[Object]=(tok)
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 1104
  errors always !0
  refs {lifetime[Object]=(tok),size=1}
Line 1105
  refs {lifetime[Object]=(tok),size=1}
Line 1107
  nullptr always 0
Line 1110
  ( always {!<=-1,!>=2}
Line 1114
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1115
  return always {!<=-1,!>=2}
  false always 0
Line 1116
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1119
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1121
  & {lifetime[Address]=(isKnown),!0}
Line 1123
  = possible lifetime[Iterator]=(tok1->values())
  ( possible lifetime[Iterator]=(tok1->values())
  ( {lifetime[Iterator]=(tok1->values()),start=0}
  ( {lifetime[Iterator]=(tok1->values()),end=0}
Line 1124
  v1 possible lifetime[Iterator]=(tok1->values())
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok1->values()),end=0}
Line 1125
  return always {!<=-1,!>=2}
  false always 0
Line 1127
  v1 {lifetime[Iterator]=(tok1->values()),!symbolic=(tok1->values().end()),!end=0}
  || always {!<=-1,!>=2}
  v1 {lifetime[Iterator]=(tok1->values()),!symbolic=(tok1->values().end()),!end=0}
  || always {!<=-1,!>=2}
  v1 {lifetime[Iterator]=(tok1->values()),!symbolic=(tok1->values().end()),!end=0}
Line 1128
  return always {!<=-1,!>=2}
  false always 0
Line 1129
  = possible lifetime[Iterator]=(tok2->values())
  ( possible lifetime[Iterator]=(tok2->values())
  ( {lifetime[Iterator]=(tok2->values()),start=0}
  ( {lifetime[Iterator]=(tok2->values()),end=0}
Line 1130
  v2 possible lifetime[Iterator]=(tok2->values())
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok2->values()),end=0}
Line 1131
  return always {!<=-1,!>=2}
  false always 0
Line 1133
  != always {!<=-1,!>=2}
  v2 {lifetime[Iterator]=(tok2->values()),!symbolic=(tok2->values().end()),!end=0}
Line 1134
  return always {!<=-1,!>=2}
  false always 0
Line 1136
  sameLifetime always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1137
  return always {!<=-1,!>=2}
  v2 always {!symbolic=(tok2->values().end()),!end=0}
  sameLifetime {symbolic=(isSameLifetime(tok1,tok2)),!<=-1,!>=2}
Line 1140
  ( always {!<=-1,!>=2}
Line 1142
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  sameLifetime always {!<=-1,!>=2}
Line 1143
  r always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1144
  ( always {!<=-1,!>=2}
Line 1145
  r always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  sameLifetime always {!<=-1,!>=2}
Line 1147
  r {symbolic=(v1.equalValue(v2)),!<=-1,!>=2}
Line 1151
  ( always {!<=-1,!>=2}
Line 1153
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  sameLifetime always {!<=-1,!>=2}
Line 1154
  r always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1155
  ( always {!<=-1,!>=2}
Line 1156
  r always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  sameLifetime always {!<=-1,!>=2}
Line 1158
  ! always {!<=-1,!>=2}
  r {symbolic=(v1.equalValue(v2)),!<=-1,!>=2}
Line 1162
  ( always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 1164
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1165
  return always {!<=-1,!>=2}
  false always 0
Line 1168
  ( always {!<=-1,!>=2}
  "%type% (|{" always "%type% (|{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1169
  ( always !0
Line 1172
  tok1 always !0
Line 1173
  tok2 always !0
Line 1175
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1176
  return always {!<=-1,!>=2}
  false always 0
Line 1178
  macro always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1179
  return always {!<=-1,!>=2}
  false always 0
Line 1184
  ! always {!<=-1,!>=2}
  v1 always symbolic=(tok1->valueType())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  v2 always symbolic=(tok2->valueType())
  || always {!<=-1,!>=2}
  v1 {symbolic=(tok1->valueType()),!0}
  != always {!<=-1,!>=2}
  v2 {symbolic=(tok2->valueType()),!0}
  || always {!<=-1,!>=2}
  v1 always symbolic=(tok1->valueType())
  != always {!<=-1,!>=2}
  v2 {symbolic=(tok2->valueType()),!0}
  || always {!<=-1,!>=2}
  v1 always symbolic=(tok1->valueType())
  != always {!<=-1,!>=2}
  v2 always symbolic=(tok2->valueType())
Line 1185
  return always {!<=-1,!>=2}
  false always 0
Line 1187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1191
  ( always {!<=-1,!>=2}
Line 1193
  ! always {!<=-1,!>=2}
Line 1194
  return always {!<=-1,!>=2}
  false always 0
Line 1195
  tok always !0
Line 1196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  ";" always ";"
  && always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
Line 1197
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  ";" always ";"
  && always {!<=-1,!>=2}
Line 1198
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "(" always "("
  && always {!<=-1,!>=2}
Line 1199
  parent always symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  "for" always "for"
Line 1202
  ( always {!<=-1,!>=2}
Line 1204
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 1205
  tok always !0
  tok always !0
  ( always !0
  : always 1
  tok always !0
Line 1206
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible 0
  "0" always "0"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1217
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  checkingParent always {!<=-1,!>=2}
Line 1219
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent())@78
Line 1220
  return always {!<=-1,!>=2}
  false always 0
Line 1221
  tok always !0
Line 1222
  type {symbolic=(tok->tokType()),16,11,12,14}
  == {!<=-1,!>=2,0}
  :: always 15
  eBitOp always 15
  || always {!<=-1,!>=2}
  type {symbolic=(tok->tokType()),11,12,14,!15}
  == {!<=-1,!>=2,0}
  :: always 16
  eIncDecOp always 16
  || always {!<=-1,!>=2}
  type {symbolic=(tok->tokType()),12,14,!15,!16}
  == {!<=-1,!>=2,0}
  :: always 11
  eArithmeticalOp always 11
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 1224
  return always {!<=-1,!>=2}
  false always 0
Line 1225
  type {symbolic=(tok->tokType()),14,!15,!16}
  == {!<=-1,!>=2,0}
  :: always 12
  eComparisonOp always 12
Line 1226
  ! always {!<=-1,!>=2}
  checkingParent always {!<=-1,!>=2}
Line 1228
  return always {!<=-1,!>=2}
  true always 1
Line 1229
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 1230
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1231
  return always {!<=-1,!>=2}
  false always 0
Line 1233
  type always {!15,!16,!12}
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
Line 1234
  return always {!<=-1,!>=2}
  true always 1
Line 1235
  ( always {!<=-1,!>=2}
Line 1236
  return always {!<=-1,!>=2}
  true always 1
Line 1239
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 1240
  return always {!<=-1,!>=2}
  false always 0
Line 1241
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
Line 1242
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "if|while" always "if|while"
Line 1243
  return always {!<=-1,!>=2}
  true always 1
Line 1245
  ! always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
Line 1248
  tok always symbolic=(parent->astOperand2())
  argnr always Uninit
Line 1249
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func always !0
Line 1250
  return always {!<=-1,!>=2}
  false always 0
Line 1251
  func always !0
  ( always !0
  argnr inconclusive Uninit
Line 1252
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  "bool" always "bool"
Line 1254
  ( always {!<=-1,!>=2}
Line 1255
  return always {!<=-1,!>=2}
  true always 1
Line 1256
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1257
  return always {!<=-1,!>=2}
  true always 1
Line 1259
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  true always 1
Line 1262
  ( always {!<=-1,!>=2}
Line 1264
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 1267
  ( always {!<=-1,!>=2}
Line 1269
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1272
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1274
  tok1 possible 0
  == {!<=-1,!>=2,1}
  nullptr always 0
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(parent)@219
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1275
  return always {!<=-1,!>=2}
  true always 1
Line 1276
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1277
  return always {!<=-1,!>=2}
  false always 0
Line 1278
  cpp always {!<=-1,!>=2}
Line 1279
  tok1 always !0
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  tok1 always !0
  && always {!<=-1,!>=2}
  tok1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "this" always "this"
Line 1280
  tok1 always !0
Line 1281
  tok2 always !0
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "this" always "this"
Line 1282
  tok2 always !0
Line 1285
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 1286
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1288
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 1289
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1291
  tok_str_eq always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1292
  ! {!<=-1,!>=2,1}
  tok_str_eq {symbolic=(tok1->str()==tok2->str()),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1293
  return always {!<=-1,!>=2}
  false always 0
Line 1294
  ( always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 1295
  return always {!<=-1,!>=2}
  true always 1
Line 1298
  followVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok_str_eq always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 1299
  = inconclusive lifetime[Object]=(tok1)
  ( inconclusive lifetime[Object]=(tok1)
  cpp always {!<=-1,!>=2}
Line 1300
  varTok1 inconclusive lifetime[Object]=(tok1)
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok1 inconclusive lifetime[Object]=(tok1)
Line 1301
  varTok1 inconclusive lifetime[Object]=(tok1)
Line 1302
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok1 inconclusive lifetime[Object]=(tok1)
  true always 1
  followVar always 1
Line 1304
  = inconclusive lifetime[Object]=(tok2)
  ( inconclusive lifetime[Object]=(tok2)
  cpp always {!<=-1,!>=2}
Line 1305
  == always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
  ( possible symbolic=(varTok1->str())
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
Line 1306
  varTok2 inconclusive lifetime[Object]=(tok2)
Line 1307
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
  true always 1
  followVar always 1
Line 1309
  ( always !symbolic=(tok2->str())
  == always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
  ( always !symbolic=(tok1->str())
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
Line 1311
  varTok2 inconclusive lifetime[Object]=(tok2)
Line 1312
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  varTok2 inconclusive lifetime[Object]=(tok2)
  true always 1
  followVar always {!<=-1,!>=2}
Line 1316
  ! {!<=-1,!>=2,1}
  tok_str_eq {!<=-1,!>=2,0}
Line 1319
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1320
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1322
  tok1 possible symbolic=(refTok1)
  != always {!<=-1,!>=2}
  tok2 possible symbolic=(refTok2)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok_str_eq always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1323
  ( always {!<=-1,!>=2}
  "<|>" always "<|>"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|>" always "<|>"
  || always {!<=-1,!>=2}
Line 1324
  ( always {!<=-1,!>=2}
  "<=|>=" always "<=|>="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<=|>=" always "<=|>="
Line 1325
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1326
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1328
  = always 0
  nullptr always 0
Line 1329
  = always 0
  nullptr always 0
Line 1330
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 1333
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 1337
  condTok possible {symbolic=(tok1),symbolic=(tok2)}
  && always {!<=-1,!>=2}
  condTok always !0
  && always {!<=-1,!>=2}
  condTok always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 1338
  = always 0
  nullptr always 0
Line 1340
  = always 0
  nullptr always 0
Line 1341
  condTok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1342
  = always !0
  & always !0
  condTok always !0
  ( always !0
Line 1343
  = always !0
  condTok always !0
  ( always !0
Line 1344
  condTok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1345
  = always !0
  & always !0
  condTok always !0
  ( always !0
Line 1346
  = always !0
  condTok always !0
  ( always !0
Line 1348
  ( always {!<=-1,!>=2}
  exprTok always symbolic=(varTok2)
  "!" always "!"
Line 1349
  exprTok always symbolic=(varTok2)
Line 1350
  compare {!<=-1,!>=2,0}
  compare always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1352
  value always !0
  . possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  "==" always "=="
Line 1353
  compare always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1354
  value always !0
  . possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  "!=" always "!="
Line 1355
  compare always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1356
  value always !0
  . possible 0
  != {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  "!=" always "!="
Line 1357
  compare always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1358
  value always !0
  . possible 0
  != {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!" always "!"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  "==" always "=="
Line 1359
  compare always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1363
  compare {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1364
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1367
  return always {!<=-1,!>=2}
  false always 0
Line 1369
  macro always {!<=-1,!>=2}
Line 1370
  macro always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1371
  true always 1
Line 1372
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1373
  true always 1
Line 1374
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1375
  true always 1
Line 1376
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1377
  true always 1
Line 1378
  ( always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1379
  true always 1
Line 1380
  false always 0
Line 1382
  tok1 possible symbolic=(tok1->variable()->nameToken())
  macro always {!<=-1,!>=2}
Line 1383
  return always {!<=-1,!>=2}
  false always 0
Line 1385
  pure {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "sizeof" always "sizeof"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 1386
  ! {!<=-1,!>=2,1}
  ( possible 0
Line 1387
  ( always {!<=-1,!>=2}
  "." always "."
Line 1389
  ( always {!<=-1,!>=2}
  lhs possible {symbolic=(tok1->previous()),0}
  "(|.|[" always "(|.|["
Line 1391
  ! always {!<=-1,!>=2}
  lhs possible symbolic=(tok1->previous())
Line 1392
  return always {!<=-1,!>=2}
  false always 0
Line 1393
  lhsIsConst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  lhs always !0
  && always {!<=-1,!>=2}
  lhs always !0
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1394
  lhs always !0
  && always {!<=-1,!>=2}
  lhs always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 1395
  ( always {!<=-1,!>=2}
  lhs always !0
  "%var% . %name% (" always "%var% . %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  lhs always !0
  2 always 2
Line 1396
  ! always {!<=-1,!>=2}
  lhsIsConst always {!<=-1,!>=2}
Line 1397
  return always {!<=-1,!>=2}
  false always 0
Line 1400
  ( always {!<=-1,!>=2}
  tok1 always symbolic=(ftok)
  "::" always "::"
Line 1401
  tok1 always symbolic=(ftok)
Line 1402
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok possible {symbolic=(tok1),symbolic=(tok1->previous())}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1403
  return always {!<=-1,!>=2}
  false always 0
Line 1406
  ( always 1
  && {!<=-1,!>=2,1}
  ! {!<=-1,!>=2,1}
  ( always !0
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1407
  return always {!<=-1,!>=2}
  false always 0
Line 1411
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1412
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
Line 1415
  pure always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> (" always "> ("
  && always {!<=-1,!>=2}
Line 1416
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1417
  != always {!<=-1,!>=2}
  "dynamic_cast" always "dynamic_cast"
Line 1418
  return always {!<=-1,!>=2}
  false always 0
Line 1423
  t1 always symbolic=(tok1->next())
Line 1424
  t2 always symbolic=(tok2->next())
Line 1425
  t1 {symbolic=(tok1->next()),symbolic=(end1)}
  && always {!<=-1,!>=2}
  t2 inconclusive symbolic=(tok2->next())
  && always {!<=-1,!>=2}
  t1 {symbolic=(tok1->next()),!0}
  != always {!<=-1,!>=2}
  end1 possible symbolic=(t1->link())
  && always {!<=-1,!>=2}
  t2 {symbolic=(tok2->next()),!0}
  != always {!<=-1,!>=2}
  end2 possible symbolic=(t2->link())
Line 1426
  t1 {symbolic=(tok1->next()),!symbolic=(end1),!0}
  != always {!<=-1,!>=2}
  t2 {symbolic=(tok2->next()),!symbolic=(end2),!0}
  || always {!<=-1,!>=2}
  t1 {symbolic=(tok1->next()),!symbolic=(end1),!0}
  t2 {symbolic=(tok2->next()),!symbolic=(end2),!0}
  macro always {!<=-1,!>=2}
Line 1427
  return always {!<=-1,!>=2}
  false always 0
Line 1428
  t1 inconclusive symbolic=(tok1->next())
Line 1429
  t2 inconclusive symbolic=(tok2->next())
Line 1431
  != {!<=-1,!>=2,0}
  end1 possible {symbolic=(t1->link()),symbolic=(t1)}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1432
  return always {!<=-1,!>=2}
  false always 0
Line 1434
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1435
  return always {!<=-1,!>=2}
  false always 0
Line 1437
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1438
  return always {!<=-1,!>=2}
  false always 0
Line 1440
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1441
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1442
  ! always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  ( always !0
Line 1445
  t1 {symbolic=(tok1->next()),0}
  && always {!<=-1,!>=2}
  t2 inconclusive symbolic=(tok2->next())
  && always {!<=-1,!>=2}
Line 1446
  t1 {symbolic=(tok1->next()),!0}
  == always {!<=-1,!>=2}
  t2 {symbolic=(tok2->next()),!0}
  && always {!<=-1,!>=2}
Line 1447
  ! always {!<=-1,!>=2}
  t1 inconclusive symbolic=(tok1->next())
  t2 {symbolic=(tok2->next()),!0}
  macro always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1448
  t1 inconclusive symbolic=(tok1->next())
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  t1 inconclusive symbolic=(tok1->next())
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1449
  t1 always !0
Line 1452
  ! {!<=-1,!>=2,1}
  t1 {symbolic=(tok1->next()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  t1 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  t2 always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1453
  return always {!<=-1,!>=2}
  false always 0
Line 1455
  noncommutativeEquals always {!<=-1,!>=2}
  noncommutativeEquals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 1456
  ( always {!<=-1,!>=2}
  cpp {!<=-1,!>=2,0}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1457
  noncommutativeEquals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  noncommutativeEquals {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 1458
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1460
  noncommutativeEquals always {!<=-1,!>=2}
Line 1461
  return always {!<=-1,!>=2}
  true always 1
Line 1464
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1467
  ! always {!<=-1,!>=2}
  vt1 always symbolic=(tok1->astOperand1()->valueType())
  && always {!<=-1,!>=2}
  vt1 {symbolic=(tok1->astOperand1()->valueType()),!0}
  >= always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  || always {!<=-1,!>=2}
  vt1 {symbolic=(tok1->astOperand1()->valueType()),!0}
  && always {!<=-1,!>=2}
  vt2 always symbolic=(tok1->astOperand2()->valueType())
  && always {!<=-1,!>=2}
  vt2 {symbolic=(tok1->astOperand2()->valueType()),!0}
  >= always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  || always {!<=-1,!>=2}
  vt2 {symbolic=(tok1->astOperand2()->valueType()),!0}
Line 1468
  return always {!<=-1,!>=2}
  false always 0
Line 1471
  commutative always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%or%|%oror%|+|*|&|&&|^|==|!=" always "%or%|%oror%|+|*|&|&&|^|==|!="
Line 1472
  commutativeEquals always {!<=-1,!>=2}
  commutativeEquals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  commutative always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1473
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1474
  commutativeEquals always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  commutativeEquals always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1475
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1478
  return always {!<=-1,!>=2}
  commutativeEquals always {!<=-1,!>=2}
Line 1481
  ( always {!<=-1,!>=2}
Line 1483
  == always {!<=-1,!>=2}
  nullptr always 0
Line 1484
  return always {!<=-1,!>=2}
  false always 0
Line 1487
  isZero always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  cond always !0
  0 always 0
Line 1488
  cond always !0
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "==" always "=="
  || always {!<=-1,!>=2}
  cond always !0
  == always {!<=-1,!>=2}
  ">=" always ">="
Line 1489
  return always {!<=-1,!>=2}
  isZero always {!<=-1,!>=2}
Line 1490
  cond always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 1491
  return always {!<=-1,!>=2}
  true always 1
Line 1492
  ( possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1493
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isZero always {!<=-1,!>=2}
Line 1494
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1495
  return always {!<=-1,!>=2}
  false always 0
Line 1496
  return always {!<=-1,!>=2}
  false always 0
Line 1499
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1501
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1502
  return always {!<=-1,!>=2}
  false always 0
Line 1504
  ! {!<=-1,!>=2,0@18}
  isNot {!<=-1,!>=2,1@18}
  && always {!<=-1,!>=2}
  cond1 always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  cond2 always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 1506
  cond1 always !0
  cond1 always !0
Line 1509
  cond2 always !0
  cond2 always !0
Line 1511
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1512
  ( always {!<=-1,!>=2}
  isNot always 0
  cpp always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1513
  return always {!<=-1,!>=2}
  true always 1
Line 1519
  cond1 always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "!" always "!"
Line 1520
  cond2 always !0
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 1521
  cond2 always !0
  && always {!<=-1,!>=2}
  cond2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "0" always "0"
Line 1522
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  cond1 always !0
  cond2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1523
  cond2 always !0
  && always {!<=-1,!>=2}
  cond2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "0" always "0"
Line 1524
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  cond1 always !0
  cond2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1526
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cond2 always !0
Line 1527
  return always {!<=-1,!>=2}
  false always 0
Line 1528
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  cond1 always !0
  cond2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1531
  cond2 always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "!" always "!"
Line 1532
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  cond2 always !0
  cond1 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1534
  ! {!<=-1,!>=2,1}
  isNot {!<=-1,!>=2,0}
Line 1535
  == always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
Line 1536
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1537
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1538
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1542
  ( always {!<=-1,!>=2}
  :: always 8
  EMPTY always 8
  "empty" always "empty"
  && always {!<=-1,!>=2}
Line 1543
  ( always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
  "size" always "size"
  && always {!<=-1,!>=2}
Line 1544
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1545
  true always 1
Line 1549
  pure always {!<=-1,!>=2}
Line 1550
  followVar always {!<=-1,!>=2}
Line 1552
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1555
  ( always {!<=-1,!>=2}
  :: always 8
  EMPTY always 8
  "empty" always "empty"
  && always {!<=-1,!>=2}
Line 1556
  ( always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
  "size" always "size"
  && always {!<=-1,!>=2}
Line 1557
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1558
  true always 1
Line 1562
  pure always {!<=-1,!>=2}
Line 1563
  followVar always {!<=-1,!>=2}
Line 1565
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1570
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1571
  return always {!<=-1,!>=2}
  false always 0
Line 1577
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1578
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1580
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1581
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1583
  comp2 always symbolic=(cond2->str())
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,0}
  '>' always 62
Line 1584
  comp2 always symbolic=(cond2->str())
  0 always 0
  = always 60
  '<' always 60
Line 1585
  comp2 always symbolic=(cond2->str())
  [ always !62
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 1586
  comp2 always symbolic=(cond2->str())
  0 always 0
  = always 62
  '>' always 62
Line 1589
  ! always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1590
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 1592
  ( always {!<=-1,!>=2}
Line 1595
  ( always {!<=-1,!>=2}
Line 1598
  op1 always symbolic=(cond1->str())
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,0}
  '>' always 62
Line 1599
  op1 always symbolic=(cond1->str())
  0 always 0
  = always 60
  '<' always 60
Line 1600
  op1 always symbolic=(cond1->str())
  [ always !62
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 1601
  op1 always symbolic=(cond1->str())
  0 always 0
  = always 62
  '>' always 62
Line 1603
  ( always {!<=-1,!>=2}
Line 1606
  ( always {!<=-1,!>=2}
Line 1609
  op2 always symbolic=(cond2->str())
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,0}
  '>' always 62
Line 1610
  op2 always symbolic=(cond2->str())
  0 always 0
  = always 60
  '<' always 60
Line 1611
  op2 always symbolic=(cond2->str())
  [ always !62
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
Line 1612
  op2 always symbolic=(cond2->str())
  0 always 0
  = always 62
  '>' always 62
Line 1614
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1615
  return always {!<=-1,!>=2}
  false always 0
Line 1617
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  expr1 always !0
  expr2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1618
  return always {!<=-1,!>=2}
  false always 0
Line 1620
  value1 always !0
Line 1621
  value2 always !0
Line 1623
  op1 possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<=" always "<="
Line 1624
  return always {!<=-1,!>=2}
  op2 possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "==" always "=="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">=" always ">="
  && always {!<=-1,!>=2}
  rhsValue1 always symbolic=(value1->values().front())
  < always {!<=-1,!>=2}
  rhsValue2 always symbolic=(value2->values().front())
Line 1625
  op1 possible size=1
  == {!<=-1,!>=2,0}
  ">=" always ">="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1626
  return always {!<=-1,!>=2}
  op2 possible {size=1,size=2}
  == {!<=-1,!>=2,0}
  "==" always "=="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  rhsValue1 always symbolic=(value1->values().front())
  > always {!<=-1,!>=2}
  rhsValue2 always symbolic=(value2->values().front())
Line 1628
  return always {!<=-1,!>=2}
  false always 0
Line 1632
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
Line 1633
  == always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
  || always {!<=-1,!>=2}
Line 1634
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">=" always ">="
  || always {!<=-1,!>=2}
Line 1635
  == always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
Line 1636
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<=" always "<="
  || always {!<=-1,!>=2}
Line 1637
  == always {!<=-1,!>=2}
  ">=" always ">="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
Line 1638
  ! always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
Line 1639
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
Line 1640
  == always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
Line 1641
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
Line 1645
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1647
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1648
  return always {!<=-1,!>=2}
  false always 0
Line 1649
  ( always {!<=-1,!>=2}
  true always 1
  cpp always {!<=-1,!>=2}
  tok1 always !0
  tok2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1650
  return always {!<=-1,!>=2}
  true always 1
Line 1651
  tok1 always !0
  ( always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
Line 1652
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  tok1 always !0
  tok2 always !0
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1653
  ( always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
Line 1654
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  pure always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
Line 1655
  return always {!<=-1,!>=2}
  false always 0
Line 1658
  ( always {!<=-1,!>=2}
Line 1660
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(f->argumentList),start=0}
  ( {lifetime[Iterator]=(f->argumentList),end=0}
Line 1661
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1662
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1663
  true always 1
Line 1667
  ( always {!<=-1,!>=2}
Line 1669
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1670
  return always {!<=-1,!>=2}
  false always 0
Line 1672
  f always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  f always !0
  ( always {!<=-1,!>=2}
Line 1673
  return always {!<=-1,!>=2}
  true always 1
Line 1675
  ( always {!<=-1,!>=2}
  f always !0
Line 1676
  return always {!<=-1,!>=2}
  false always 0
Line 1677
  ( always {!<=-1,!>=2}
Line 1678
  return always {!<=-1,!>=2}
  false always 0
Line 1680
  ( always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1681
  ( always {!<=-1,!>=2}
Line 1682
  return always {!<=-1,!>=2}
  true always 1
Line 1684
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  f possible symbolic=(g)
Line 1685
  f possible symbolic=(g)
Line 1686
  ( always {!<=-1,!>=2}
  fs always symbolic=(f->getOverloadedFunctions())
  ( {lifetime[Iterator]=(fs),start=0}
  ( {lifetime[Iterator]=(fs),end=0}
  [ possible lifetime[Lambda]=(f)
Line 1687
  == always {!<=-1,!>=2}
Line 1688
  return always {!<=-1,!>=2}
  false always 0
Line 1689
  f always !symbolic=(g)
  ( always !<=-1
  != always {!<=-1,!>=2}
  g always !symbolic=(f)
Line 1690
  return always {!<=-1,!>=2}
  false always 0
Line 1691
  ( always {!<=-1,!>=2}
Line 1692
  return always {!<=-1,!>=2}
  false always 0
Line 1693
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1694
  return always {!<=-1,!>=2}
  true always 1
Line 1695
  return always {!<=-1,!>=2}
  false always 0
Line 1697
  return always {!<=-1,!>=2}
  true always 1
Line 1699
  return always {!<=-1,!>=2}
  false always 0
Line 1700
  ( always {!<=-1,!>=2}
Line 1701
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1703
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "->" always "->"
  && always {!<=-1,!>=2}
Line 1704
  ( always {!<=-1,!>=2}
Line 1705
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "get|get_deleter ( )" always "get|get_deleter ( )"
Line 1706
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1708
  ! always {!<=-1,!>=2}
  container always symbolic=(ftok->previous()->astOperand1()->valueType()->container)
Line 1709
  return always {!<=-1,!>=2}
  false always 0
Line 1710
  container {symbolic=(ftok->previous()->astOperand1()->valueType()->container),!0}
  != always {!<=-1,!>=2}
  :: always 9
  NO_YIELD always 9
Line 1711
  return always {!<=-1,!>=2}
  true always 1
Line 1712
  container always !0
  == always {!<=-1,!>=2}
  :: always 4
  FIND always 4
Line 1713
  return always {!<=-1,!>=2}
  true always 1
Line 1714
  return always {!<=-1,!>=2}
  false always 0
Line 1716
  lf always !0
  . always {!<=-1,!>=2}
  ispure always {!<=-1,!>=2}
Line 1717
  return always {!<=-1,!>=2}
  true always 1
Line 1718
  lf always !0
  != always {!<=-1,!>=2}
  :: always 9
  NO_YIELD always 9
Line 1719
  return always {!<=-1,!>=2}
  true always 1
Line 1720
  == always {!<=-1,!>=2}
  :: always 4
  FIND always 4
Line 1721
  return always {!<=-1,!>=2}
  true always 1
Line 1722
  return always {!<=-1,!>=2}
  false always 0
Line 1724
  memberFunction always {!<=-1,!>=2}
  memberFunction always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 1725
  constMember always {!<=-1,!>=2}
  constMember always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  memberFunction always {!<=-1,!>=2}
Line 1726
  ( always {!<=-1,!>=2}
  -2 always -2
  "%var% . %name% (" always "%var% . %name% ("
Line 1727
  -2 always -2
Line 1729
  constMember always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1733
  ( always {!<=-1,!>=2}
Line 1734
  return always {!<=-1,!>=2}
  false always 0
Line 1735
  return always {!<=-1,!>=2}
  constMember always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always !size=0
  ( {lifetime[Iterator]=(args),!size=0,start=0}
  args always !size=0
  ( {lifetime[Iterator]=(args),!size=0,end=0}
Line 1737
  var always symbolic=(tok->variable())
Line 1738
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1739
  false always 0
Line 1742
  return always {!<=-1,!>=2}
  true always 1
Line 1745
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1747
  ! always {!<=-1,!>=2}
Line 1748
  return always {!<=-1,!>=2}
  true always 1
Line 1749
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1750
  return always {!<=-1,!>=2}
  false always 0
Line 1751
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 1752
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1753
  return always {!<=-1,!>=2}
  false always 0
Line 1755
  tok always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 1756
  return always {!<=-1,!>=2}
  false always 0
Line 1757
  ( always {!<=-1,!>=2}
Line 1758
  return always {!<=-1,!>=2}
  false always 0
Line 1759
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1760
  return always {!<=-1,!>=2}
  false always 0
Line 1762
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1763
  return always {!<=-1,!>=2}
  false always 0
Line 1764
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1767
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  checkArrayAccess always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  checkReference always {!<=-1,!>=2}
Line 1769
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1770
  return always {!<=-1,!>=2}
  true always 1
Line 1772
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 1773
  = always !0
  tok always !0
  ( always !0
Line 1774
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
Line 1775
  tok always !0
Line 1776
  return always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  checkReference always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  checkArrayAccess always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1778
  return always {!<=-1,!>=2}
  true always 1
Line 1781
  ( always {!<=-1,!>=2}
Line 1783
  ! always {!<=-1,!>=2}
Line 1784
  return always {!<=-1,!>=2}
  true always 1
Line 1785
  tok always !0
Line 1786
  = always !0
  tok always !0
  ( always !0
Line 1787
  fun {symbolic=(tok->function()),!0}
Line 1788
  ! always {!<=-1,!>=2}
  scope always symbolic=(fun->nestedIn)
Line 1789
  return always {!<=-1,!>=2}
  true always 1
Line 1790
  fun {symbolic=(tok->function()),!0}
  fun {symbolic=(tok->function()),!0}
  . always !0
  fun {symbolic=(tok->function()),!0}
  fun {symbolic=(tok->function()),!0}
Line 1791
  scope {symbolic=(fun->nestedIn),!0}
Line 1792
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1795
  . always !0
Line 1796
  ( always !<=-1
  == always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
Line 1797
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1798
  != always {!<=-1,!>=2}
Line 1799
  return always {!<=-1,!>=2}
  false always 0
Line 1802
  tok always !0
Line 1803
  = always !0
  tok always !0
  ( always !0
Line 1804
  var {symbolic=(tok->variable()),!0}
Line 1805
  ! always {!<=-1,!>=2}
  scope always symbolic=(var->scope())
Line 1806
  return always {!<=-1,!>=2}
  true always 1
Line 1807
  var {symbolic=(tok->variable()),!0}
Line 1809
  scope {symbolic=(var->scope()),!0}
Line 1810
  2 always 2
  = possible lifetime[SubObject]=(scope->varlist)
  { possible lifetime[SubObject]=(scope->varlist)
  & {lifetime[Address]=(scope->varlist),!0}
  scope {symbolic=(var->scope()),!0}
  ? possible 0
  & {lifetime[Address]=(fun->argumentList),!0}
  fun always !0
  nullptr always 0
Line 1813
  ! always {!<=-1,!>=2}
Line 1815
  other always {!<=-1,!>=2}
  other always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  vars always !0
  ( always start=0
  vars always !0
  ( always end=0
  [ possible {lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v),lifetime[Lambda]=(v)}
Line 1817
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  varType always !0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1818
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1819
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1820
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1821
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1822
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1823
  != always {!<=-1,!>=2}
Line 1825
  other always {!<=-1,!>=2}
Line 1826
  return always {!<=-1,!>=2}
  false always 0
Line 1828
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1829
  return always {!<=-1,!>=2}
  false always 0
Line 1832
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1835
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  functionsScope always {!<=-1,!>=2}
Line 1837
  && always {!<=-1,!>=2}
  library always !0
  ( always {!<=-1,!>=2}
Line 1838
  return always {!<=-1,!>=2}
  true always 1
Line 1839
  functionsScope always {!<=-1,!>=2}
Line 1840
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw" always "throw"
Line 1842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|throw" always "return|throw"
Line 1845
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  functionsScope always {!<=-1,!>=2}
Line 1847
  && always {!<=-1,!>=2}
  library always !0
  ( always {!<=-1,!>=2}
Line 1848
  return always {!<=-1,!>=2}
  true always 1
Line 1849
  functionsScope always {!<=-1,!>=2}
Line 1850
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "throw" always "throw"
Line 1852
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|goto|throw|continue|break" always "return|goto|throw|continue|break"
Line 1855
  ( always {!<=-1,!>=2}
Line 1857
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1858
  return always {!<=-1,!>=2}
  false always 0
Line 1860
  function always symbolic=(ftok->function())
Line 1861
  function {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 1862
  return always {!<=-1,!>=2}
  true always 1
Line 1863
  function {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 1864
  return always {!<=-1,!>=2}
  true always 1
Line 1866
  library always !0
  ( always {!<=-1,!>=2}
Line 1867
  return always {!<=-1,!>=2}
  true always 1
Line 1869
  return always {!<=-1,!>=2}
  false always 0
Line 1872
  ( always {!<=-1,!>=2}
Line 1874
  ! always {!<=-1,!>=2}
Line 1875
  return always {!<=-1,!>=2}
  false always 0
Line 1876
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
  tok always !0
  : always 0
  nullptr always 0
Line 1877
  ( always {!<=-1,!>=2}
  ftok possible {symbolic=(tok->str()=="("?tok->previous():nullptr),0}
  "(" always "("
Line 1879
  ftok possible symbolic=(tok->str()=="("?tok->previous():nullptr)
Line 1880
  ftok always !0
Line 1881
  function always symbolic=(ftok->function())
Line 1882
  function {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 1883
  return always {!<=-1,!>=2}
  true always 1
Line 1884
  function {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 1885
  return always {!<=-1,!>=2}
  true always 1
Line 1886
  && always {!<=-1,!>=2}
  library always !0
  ( always {!<=-1,!>=2}
  ftok always !0
Line 1887
  return always {!<=-1,!>=2}
  true always 1
Line 1888
  ( always {!<=-1,!>=2}
  ftok always !0
  "exit|abort" always "exit|abort"
Line 1889
  return always {!<=-1,!>=2}
  true always 1
Line 1891
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  function always symbolic=(ftok->function())
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  library always !0
  ( always !<=-1
  library always !0
  ftok always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1892
  unknownFunc always !0
  = always !0
  ftok always !0
Line 1893
  return always {!<=-1,!>=2}
  false always 0
Line 1894
  tok always !0
  ( always {!<=-1,!>=2}
Line 1895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1898
  return always {!<=-1,!>=2}
  false always 0
Line 1901
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
Line 1903
  ! always {!<=-1,!>=2}
  endToken possible symbolic=(bodyStart->link())@185
  || always {!<=-1,!>=2}
  endToken {!0,symbolic=(bodyStart->link())@185}
  != always {!<=-1,!>=2}
  "}" always "}"
Line 1904
  return always {!<=-1,!>=2}
  false always 0
Line 1906
  endToken {!0,symbolic=(bodyStart->link())@185}
Line 1907
  prev possible {symbolic=(endToken->previous()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev {symbolic=(endToken->previous()),!0}
  "; ;" always "; ;"
Line 1908
  prev always !0
Line 1909
  prev possible {symbolic=(endToken->previous()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  "} ;" always "} ;"
Line 1910
  prev always !0
Line 1912
  ( always {!<=-1,!>=2}
  prev possible 0
  "}" always "}"
Line 1913
  ( always {!<=-1,!>=2}
  -2 always -2
  "} else {" always "} else {"
Line 1914
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1915
  ( always {!<=-1,!>=2}
  -2 always -2
  functionScope always {!<=-1,!>=2}
Line 1917
  ! always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
Line 1918
  ( always {!<=-1,!>=2}
  -1 always -1
  "switch (" always "switch ("
  && always {!<=-1,!>=2}
Line 1919
  ! always {!<=-1,!>=2}
  "break" always "break"
Line 1920
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  functionScope always 0
Line 1922
  ( always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
Line 1923
  return always {!<=-1,!>=2}
  true always 1
Line 1924
  ( always {!<=-1,!>=2}
  "[;{}] {" always "[;{}] {"
Line 1925
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
Line 1926
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 1927
  -2 always -2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
Line 1928
  return always {!<=-1,!>=2}
  true always 1
Line 1930
  ( always {!<=-1,!>=2}
  -2 always -2
  ";|}|{ %name% ;" always ";|}|{ %name% ;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1932
  unknownFunc always !0
Line 1933
  return always {!<=-1,!>=2}
  false always 0
Line 1935
  ( always {!<=-1,!>=2}
  ") ;" always ") ;"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1936
  ( always {!<=-1,!>=2}
  ( always !0
  functionScope always {!<=-1,!>=2}
Line 1937
  return always {!<=-1,!>=2}
  true always 1
Line 1938
  ( always {!<=-1,!>=2}
  functionScope always {!<=-1,!>=2}
Line 1939
  return always {!<=-1,!>=2}
  true always 1
Line 1942
  prev possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  ";|{|}" always ";|{|}"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev always !0
  functionScope always {!<=-1,!>=2}
Line 1943
  prev always !0
Line 1944
  return always {!<=-1,!>=2}
  prev possible 0
  && always {!<=-1,!>=2}
  prev always !0
  ( always {!<=-1,!>=2}
Line 1946
  return always {!<=-1,!>=2}
  false always 0
Line 1949
  ( always {!<=-1,!>=2}
Line 1951
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1952
  return always {!<=-1,!>=2}
  false always 0
Line 1953
  tok always !0
Line 1954
  scope possible symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  != always {!<=-1,!>=2}
  var always !0
Line 1955
  scope always {!symbolic=(var->scope()),!0}
  == always {!<=-1,!>=2}
Line 1956
  return always {!<=-1,!>=2}
  true always 1
Line 1957
  scope always {!symbolic=(var->scope()),!0}
Line 1959
  return always {!<=-1,!>=2}
  false always 0
Line 1962
  ( always {!<=-1,!>=2}
Line 1964
  ! always {!<=-1,!>=2}
Line 1965
  return always {!<=-1,!>=2}
  false always 0
Line 1966
  tok always !0
  == always {!<=-1,!>=2}
Line 1967
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1968
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  varid always !symbolic=(tok->varId())
  || always {!<=-1,!>=2}
Line 1969
  ( always {!<=-1,!>=2}
  tok always !0
  varid always !symbolic=(tok->varId())
Line 1972
  ( always {!<=-1,!>=2}
Line 1974
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|}" always "{|}"
Line 1975
  return always {!<=-1,!>=2}
  false always 0
Line 1976
  ! always {!<=-1,!>=2}
Line 1977
  return always {!<=-1,!>=2}
  false always 0
Line 1978
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1979
  return always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 1980
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1981
  return always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 1982
  return always {!<=-1,!>=2}
  false always 0
Line 1988
  = always -1
  -1 always -1
Line 1990
  tok possible symbolic=(tok1)@9562
Line 1991
  && always {!<=-1,!>=2}
  parent always !0
  "&" always "&"
Line 1992
  parent always !0
Line 1993
  && always {!<=-1,!>=2}
  parent always !0
Line 1994
  parent always !0
Line 1995
  ( always {!<=-1,!>=2}
  parent possible 0
  "[+-]" always "[+-]"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1999
  ( always {!<=-1,!>=2}
  "[(,{]" always "[(,{]"
Line 2001
  ( always {!<=-1,!>=2}
  ":" always ":"
Line 2002
  ( always {!<=-1,!>=2}
  "[?:]" always "[?:]"
Line 2004
  ( always {!<=-1,!>=2}
  parent possible 0
  "," always ","
Line 2006
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  parent always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 2007
  nullptr always 0
Line 2009
  nullptr always 0
Line 2012
  = possible symbolic=(tok1)@9562
  tok possible symbolic=(tok1)@9562
Line 2013
  argtok possible {symbolic=(tok),0,symbolic=(tok1)@9562}
  && always {!<=-1,!>=2}
  argtok {symbolic=(tok),!0,symbolic=(tok1)@9562}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argtok {symbolic=(tok),!0,symbolic=(tok1)@9562}
  ",|(|{" always ",|(|{"
  || always {!<=-1,!>=2}
  argtok {symbolic=(tok),!0,symbolic=(tok1)@9562}
Line 2014
  argtok always !0
Line 2016
  ! {!<=-1,!>=2,1}
  argtok possible {symbolic=(tok),0,symbolic=(tok1)@9562}
Line 2017
  nullptr always 0
Line 2018
  ( always {!<=-1,!>=2}
  argtok always !0
  "," always ","
Line 2019
  argtok always !0
Line 2020
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 2023
  ( always {!<=-1,!>=2}
  tok possible symbolic=(argtok)
  ",|(|{" always ",|(|{"
Line 2025
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
Line 2028
  tok possible symbolic=(argtok)
Line 2029
  == always {!<=-1,!>=2}
  -1 always -1
Line 2030
  nullptr always 0
Line 2031
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "{|(" always "{|("
Line 2032
  nullptr always 0
Line 2035
  && always {!<=-1,!>=2}
  tok always !0
  "*" always "*"
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 2036
  tok always !0
Line 2037
  ( always {!<=-1,!>=2}
  tok possible 0
  "." always "."
Line 2039
  ( always {!<=-1,!>=2}
  "::" always "::"
Line 2041
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2046
  ( always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 2049
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  ">" always ">"
Line 2050
  tok always !0
Line 2051
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|(|{" always "%name%|(|{"
Line 2052
  nullptr always 0
Line 2054
  ( always {!<=-1,!>=2}
  "%name% :" always "%name% :"
Line 2055
  nullptr always 0
Line 2060
  tok possible symbolic=(tok1)@37
  argn possible Uninit@37
Line 2070
  ! always {!<=-1,!>=2}
Line 2072
  tok always !0
Line 2073
  tok always !0
  ( always !0
Line 2075
  { always {size=1,{}
  argvar always !0
Line 2079
  ( always {!<=-1,!>=2}
  tok always !0
  "%type% (|{" always "%type% (|{"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
  || always {!<=-1,!>=2}
  tok always !0
Line 2080
  constructor always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
  || always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  tok always !0
Line 2081
  tok always !0
Line 2082
  ! always {!<=-1,!>=2}
Line 2084
  type always !0
Line 2085
  ! always {!<=-1,!>=2}
  typeScope always symbolic=(type->classScope)
Line 2088
  ( always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  typeScope {symbolic=(type->classScope),!0}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  typeScope {symbolic=(type->classScope),!0}
  ( always !<=-1
Line 2089
  = possible {lifetime[Object]=(argnr),lifetime[Object]=(typeScope->varlist)}
  ( possible {lifetime[Object]=(argnr),lifetime[Object]=(typeScope->varlist)}
  typeScope {symbolic=(type->classScope),!0}
  ( {lifetime[Iterator]=(typeScope->varlist),start=0}
  argnr {<=symbolic=(typeScope->varlist.size()-1),!>=symbolic=(typeScope->varlist.size())}
Line 2090
  { {lifetime[SubObject]=(typeScope->varlist),size=1,{}
  & {lifetime[Object]=(typeScope->varlist),!0}
  it possible {lifetime[Object]=(argnr),lifetime[Object]=(typeScope->varlist)}
Line 2093
  typeScope always !0
Line 2094
  ( always !<=-1
  < always {!<=-1,!>=2}
Line 2096
  constructor {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2098
  ! {!<=-1,!>=2,1}
  constructor {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "operator()" always "operator()"
Line 2102
  argvar always !0
Line 2108
  ( always {!<=-1,!>=2}
Line 2110
  ! always {!<=-1,!>=2}
Line 2111
  return always {!<=-1,!>=2}
  false always 0
Line 2112
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "_cast" always "_cast"
Line 2115
  ( always {!<=-1,!>=2}
Line 2117
  = always 0
  nullptr always 0
Line 2118
  & {lifetime[Address]=(typeTok),!0}
  typeTok always 0
Line 2120
  return always {!<=-1,!>=2}
  false always 0
Line 2121
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2122
  return always {!<=-1,!>=2}
  true always 1
Line 2123
  return always {!<=-1,!>=2}
  false always 0
Line 2126
  ( always {!<=-1,!>=2}
Line 2128
  ! always {!<=-1,!>=2}
Line 2129
  return always {!<=-1,!>=2}
  false always 0
Line 2130
  tok always !0
Line 2131
  return always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 2132
  ( always {!<=-1,!>=2}
  tok always !0
  "." always "."
Line 2133
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2134
  return always {!<=-1,!>=2}
  false always 0
Line 2137
  ( always {!<=-1,!>=2}
Line 2139
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok2)@242
Line 2140
  return always {!<=-1,!>=2}
  false always 0
Line 2142
  ( always {!<=-1,!>=2}
  tok always !0
  "," always ","
Line 2143
  return always {!<=-1,!>=2}
  false always 0
Line 2145
  = always !0
  tok always !0
Line 2148
  tok {symbolic=(tok1),!0}
  && always {!<=-1,!>=2}
  tok {symbolic=(tok1),!0}
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 2152
  tok {symbolic=(tok1),!0}
  argnr always Uninit
Line 2153
  ! always {!<=-1,!>=2}
Line 2154
  return always {!<=-1,!>=2}
  false always 0
Line 2155
  ( always {!<=-1,!>=2}
  tok always !0
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2156
  return always {!<=-1,!>=2}
  false always 0
Line 2157
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  0 always 0
  8 always 8
  "operator" always "operator"
  != always {!<=-1,!>=2}
  0 always 0
Line 2158
  return always {!<=-1,!>=2}
  false always 0
Line 2160
  ( always {!<=-1,!>=2}
  "%type% (|{" always "%type% (|{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  eType always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2161
  return always {!<=-1,!>=2}
  false always 0
Line 2163
  ( always {!<=-1,!>=2}
  parenTok always symbolic=(tok->next())
  "<" always "<"
  && always {!<=-1,!>=2}
  parenTok always symbolic=(tok->next())
Line 2164
  parenTok always symbolic=(tok->next())
  ( always !0
Line 2165
  possiblyPassedByReference always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  parenTok possible symbolic=(tok->next())
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always !symbolic=(parenTok->next())
  ", %name% [,)}]" always ", %name% [,)}]"
Line 2167
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 2169
  requireInit always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
  1 always 1
Line 2170
  requireNonNull always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
  1 always 1
Line 2172
  settings always !0
  1 always 1
Line 2173
  argDirection possible {1,2}
  == {!<=-1,!>=2,0}
  :: always 0
  DIR_IN always 0
Line 2174
  return always {!<=-1,!>=2}
  false always 0
Line 2175
  argDirection {2,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  DIR_OUT always 1
  || always {!<=-1,!>=2}
Line 2176
  argDirection always {!0,!1}
  == always {!<=-1,!>=2}
  :: always 2
  DIR_INOUT always 2
Line 2177
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2178
  return always {!<=-1,!>=2}
  true always 1
Line 2180
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  requireInit always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  requireNonNull always {!<=-1,!>=2}
Line 2181
  return always {!<=-1,!>=2}
  true always 1
Line 2186
  indirect possible <=0
  == {!<=-1,!>=2,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  requireNonNull always {!<=-1,!>=2}
Line 2187
  return always {!<=-1,!>=2}
  false always 0
Line 2190
  possiblyPassedByReference always {!<=-1,!>=2}
Line 2191
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2192
  * always {!<=-1,!>=2}
  inconclusive always !0
  = always 1
  true always 1
Line 2193
  return always {!<=-1,!>=2}
  false always 0
Line 2196
  return always {!<=-1,!>=2}
  true always 1
Line 2200
  conclusive always {!<=-1,!>=2}
  conclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2202
  ! always {!<=-1,!>=2}
Line 2204
  conclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2205
  > always {!<=-1,!>=2}
  0 always 0
Line 2206
  ! always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
Line 2207
  return always {!<=-1,!>=2}
  true always 1
Line 2209
  ( always {!<=-1,!>=2}
  arg always !0
  "* const" always "* const"
Line 2210
  return always {!<=-1,!>=2}
  true always 1
Line 2211
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2212
  return always {!<=-1,!>=2}
  true always 1
Line 2214
  ! always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
Line 2215
  return always {!<=-1,!>=2}
  true always 1
Line 2217
  ! always {!<=-1,!>=2}
  conclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2218
  * always {!<=-1,!>=2}
  inconclusive always !0
  = always 1
  true always 1
Line 2220
  return always {!<=-1,!>=2}
  false always 0
Line 2223
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2225
  ! always {!<=-1,!>=2}
Line 2226
  return always {!<=-1,!>=2}
  false always 0
Line 2228
  indirect possible 1@139
  == {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2229
  return always {!<=-1,!>=2}
  false always 0
Line 2231
  = always !0
  tok always !0
Line 2232
  = always 0
  0 always 0
Line 2233
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "*" always "*"
  || always {!<=-1,!>=2}
Line 2234
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "." always "."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "(" always "("
  || always {!<=-1,!>=2}
Line 2235
  tok2 possible symbolic=(tok)
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "." always "."
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  == always {!<=-1,!>=2}
  "->" always "->"
  || always {!<=-1,!>=2}
Line 2236
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "[" always "["
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  == always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
Line 2237
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "->" always "->"
Line 2239
  > always {!<=-1,!>=2}
Line 2241
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "." always "."
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "->" always "->"
Line 2242
  = always !0
  ( always !0
Line 2246
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  "?" always "?"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?" always "?"
Line 2249
  ( always {!<=-1,!>=2}
  "++|--" always "++|--"
Line 2250
  return always {!<=-1,!>=2}
  true always 1
Line 2253
  = possible 0
  ? possible 0
  parent always !0
  : always 0
  nullptr always 0
Line 2254
  parent possible symbolic=(gparent->astParent())
  && always {!<=-1,!>=2}
  gparent possible {symbolic=(parent?parent->astParent():nullptr),symbolic=(parent->astParent())}
  && always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  gparent {symbolic=(parent?parent->astParent():nullptr),!0}
  ( always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  gparent {symbolic=(parent?parent->astParent():nullptr),!0}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 2255
  = always !0
  gparent always !0
Line 2256
  gparent {symbolic=(tok),!0}
Line 2257
  parent always symbolic=(gparent->astParent())
Line 2258
  parent {symbolic=(gparent->astParent()),!0}
Line 2260
  tok possible symbolic=(gparent)
Line 2264
  tok2 possible symbolic=(tok2->astParent()->astOperand1())
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2265
  == always {!<=-1,!>=2}
  ( always !0
Line 2266
  return always {!<=-1,!>=2}
  true always 1
Line 2268
  tok2 always !symbolic=(tok2->astParent()->astOperand1())
  ( always !0
Line 2269
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  tok2 always !symbolic=(tok2->astParent()->astOperand1())
  ( always !0
Line 2270
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
  cpp always {!<=-1,!>=2}
  1 always 1
Line 2271
  return always {!<=-1,!>=2}
  true always 1
Line 2275
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">>|&" always ">>|&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2276
  return always {!<=-1,!>=2}
  true always 1
Line 2278
  ( always {!<=-1,!>=2}
  cpp {!<=-1,!>=2,0}
  tok2 possible symbolic=(tok2->astParent()->astOperand1())
Line 2279
  return always {!<=-1,!>=2}
  true always 1
Line 2282
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name%" always ". %name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2283
  = always !0
  ( always !0
Line 2285
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2286
  return always {!<=-1,!>=2}
  false always 0
Line 2287
  isConst always {!<=-1,!>=2}
  isConst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var always {1,symbolic=(tok->variable())}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2288
  ! always {!<=-1,!>=2}
  isConst {symbolic=(var&&var->isConst()),!<=-1,!>=2}
Line 2289
  var {symbolic=(tok->variable()),!0}
Line 2290
  isConst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  valueType always symbolic=(var->valueType())
  && always {!<=-1,!>=2}
  valueType {symbolic=(var->valueType()),!0}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  valueType {symbolic=(var->valueType()),!0}
  == always {!<=-1,!>=2}
  1 always 1
Line 2292
  isConst {symbolic=(var&&var->isConst()),symbolic=(valueType&&valueType->pointer==1&&valueType->constness==1),!<=-1,!>=2}
Line 2293
  return always {!<=-1,!>=2}
  false always 0
Line 2295
  2 always 2
Line 2297
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  settings always !0
  ( always {!<=-1,!>=2}
Line 2300
  ! always {!<=-1,!>=2}
  fun always symbolic=(ftok->function())
Line 2301
  return always {!<=-1,!>=2}
  true always 1
Line 2302
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  fun {symbolic=(ftok->function()),!0}
  ( always {!<=-1,!>=2}
Line 2306
  ftok possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok {symbolic=(tok2),!0}
  "[({]" always "[({]"
  || always {!<=-1,!>=2}
  ftok {symbolic=(tok2),!0}
  ( always {!<=-1,!>=2}
Line 2307
  ftok always !0
Line 2309
  ftok possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  ")|} !!{" always ")|} !!{"
Line 2311
  ( always {!<=-1,!>=2}
  ptok possible symbolic=(tok2)
  ".|::|[" always ".|::|["
Line 2313
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2314
  isChanged always {!<=-1,!>=2}
  isChanged always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ptok possible symbolic=(tok2)
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
Line 2315
  isChanged always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2316
  isChanged always {!<=-1,!>=2}
Line 2317
  return always {!<=-1,!>=2}
  true always 1
Line 2320
  tok2 possible symbolic=(tok2->astParent()->astOperand2())
Line 2321
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok2->astParent()),0}
  ".|::" always ".|::"
Line 2323
  parent possible symbolic=(tok2->astParent())
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2324
  return always {!<=-1,!>=2}
  true always 1
Line 2327
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok2->astParent()->astOperand2())
  ":|=" always ":|="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok2->astParent()->astOperand2())
  "]" always "]"
Line 2328
  tok2 always symbolic=(tok2->astParent()->astOperand2())
Line 2329
  ( always {!<=-1,!>=2}
  typeStart always symbolic=(tok2->astParent()->previous()->link()->previous())
  "&" always "&"
Line 2330
  typeStart always symbolic=(tok2->astParent()->previous()->link()->previous())
Line 2331
  typeStart possible symbolic=(tok2->astParent()->previous()->link()->previous())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  typeStart always !0
  "[;{}(] auto &| [" always "[;{}(] auto &| ["
Line 2332
  typeStart always !0
  2 always 2
  != always {!<=-1,!>=2}
  tok2 always symbolic=(tok2->astParent()->astOperand2())
Line 2335
  ! always {!<=-1,!>=2}
  refvar always symbolic=(vartok->variable())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  refvar {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  refvar {symbolic=(vartok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2336
  return always {!<=-1,!>=2}
  true always 1
Line 2342
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok2->astParent()->astOperand2())
  ":" always ":"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "for (" always "for ("
Line 2344
  ( always {!<=-1,!>=2}
Line 2345
  return always {!<=-1,!>=2}
  true always 1
Line 2347
  ! {!<=-1,!>=2,1}
  varTok {symbolic=(tok2->astParent()->previous()),0}
Line 2348
  return always {!<=-1,!>=2}
  false always 0
Line 2349
  varTok {symbolic=(tok2->astParent()->previous()),!0}
Line 2350
  ! always {!<=-1,!>=2}
  loopVar always symbolic=(varTok->variable())
Line 2351
  return always {!<=-1,!>=2}
  false always 0
Line 2352
  ! always {!<=-1,!>=2}
  loopVar {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  loopVar {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  loopVar {symbolic=(varTok->variable()),!0}
  cpp always {!<=-1,!>=2}
  1 always 1
Line 2353
  return always {!<=-1,!>=2}
  true always 1
Line 2354
  return always {!<=-1,!>=2}
  false always 0
Line 2357
  > always {!<=-1,!>=2}
  0 always 0
Line 2360
  parent possible {symbolic=(tok2->astParent()),symbolic=(parent->astParent()->astOperand1())}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  ( always {!<=-1,!>=2}
Line 2361
  parent always !0
Line 2363
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok2->astParent()),symbolic=(parent->astParent()->astOperand1()),0}
  "*" always "*"
Line 2364
  parent possible symbolic=(parent->astParent()->astOperand1())
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2365
  ( always !0
  == always {!<=-1,!>=2}
Line 2366
  return always {!<=-1,!>=2}
  true always 1
Line 2371
  return always {!<=-1,!>=2}
  false always 0
Line 2374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2376
  return always {!<=-1,!>=2}
  0 always 0
  globalvar {!<=-1,!>=2,0@194}
  settings possible 0@194
  cpp always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2379
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2381
  return always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2387
  ! always {!<=-1,!>=2}
Line 2388
  nullptr always 0
Line 2389
  f always !0
Line 2390
  ! always {!<=-1,!>=2}
  scope always symbolic=(f->functionScope)
Line 2391
  nullptr always 0
Line 2392
  scope {symbolic=(f->functionScope),!0}
  != always {!<=-1,!>=2}
  scope {symbolic=(f->functionScope),!0}
Line 2393
  != always {!<=-1,!>=2}
Line 2397
  nullptr always 0
Line 2404
  init always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2407
  init always {!<=-1,!>=2}
Line 2409
  f possible lifetime[Lambda]=(start)@120
Line 2410
  init always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2418
  ( always {!<=-1,!>=2}
Line 2421
  , always {!<=-1,!>=2}
Line 2422
  globalvar always {!<=-1,!>=2}
Line 2423
  , always {!<=-1,!>=2}
Line 2424
  cpp always {!<=-1,!>=2}
Line 2427
  < always {!<=-1,!>=2}
  0 always 0
Line 2428
  return always {!<=-1,!>=2}
  true always 1
Line 2429
  != always {!<=-1,!>=2}
Line 2430
  globalvar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2432
  return always {!<=-1,!>=2}
  true always 1
Line 2433
  pointer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2434
  aliased {!<=-1,!>=2,0}
  aliased always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2436
  ! always {!<=-1,!>=2}
Line 2437
  aliased always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2438
  ! {!<=-1,!>=2,0}
  aliased {!<=-1,!>=2,1}
Line 2439
  aliased always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  [ possible {lifetime[Lambda]=(tok),lifetime[Lambda]=(pointer)}
Line 2441
  ( always {!<=-1,!>=2}
Line 2443
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 2445
  [ possible lifetime[Lambda]=(childTok)
Line 2446
  == always {!<=-1,!>=2}
Line 2448
  true always 1
Line 2451
  false always 0
Line 2454
  ! {!<=-1,!>=2,0}
  aliased {!<=-1,!>=2,1}
Line 2455
  return always {!<=-1,!>=2}
  false always 0
Line 2456
  ( always {!<=-1,!>=2}
  1 always 1
  cpp always {!<=-1,!>=2}
Line 2457
  return always {!<=-1,!>=2}
  true always 1
Line 2459
  ( always {!<=-1,!>=2}
  "%var% (" always "%var% ("
Line 2460
  return always {!<=-1,!>=2}
  true always 1
Line 2461
  return always {!<=-1,!>=2}
  false always 0
Line 2463
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  depth always !<=-1
Line 2466
  ( always {!<=-1,!>=2}
Line 2468
  , always {!<=-1,!>=2}
Line 2469
  globalvar always {!<=-1,!>=2}
Line 2470
  , always {!<=-1,!>=2}
Line 2471
  cpp always {!<=-1,!>=2}
Line 2474
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(expr)
Line 2476
  globalvar always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2479
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2481
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2482
  nullptr always 0
Line 2483
  < always {!<=-1,!>=2}
  0 always 0
Line 2485
  [ possible lifetime[Lambda]=(start)
Line 2488
  != always {!<=-1,!>=2}
Line 2489
  ( always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  depth always !<=-1
Line 2492
  nullptr always 0
Line 2495
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2497
  indirect possible 0@146
  globalvar always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2500
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2502
  ! always {!<=-1,!>=2}
  var possible symbolic=(varTok->variable())@22
Line 2503
  return always {!<=-1,!>=2}
  false always 0
Line 2504
  ! always {!<=-1,!>=2}
  var always !0
Line 2505
  return always {!<=-1,!>=2}
  false always 0
Line 2506
  var always !0
Line 2507
  ! always {!<=-1,!>=2}
  start always symbolic=(var->declEndToken())
Line 2508
  return always {!<=-1,!>=2}
  false always 0
Line 2509
  ( always {!<=-1,!>=2}
  start {symbolic=(var->declEndToken()),!0}
  "; %varid% =" always "; %varid% ="
Line 2510
  start {symbolic=(var->declEndToken()),!0}
  2 always 2
Line 2511
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  cpp always {!<=-1,!>=2}
Line 2514
  ( always {!<=-1,!>=2}
Line 2518
  , always {!<=-1,!>=2}
Line 2519
  cpp always {!<=-1,!>=2}
Line 2522
  ( {lifetime[Iterator]=(vars),start=0}
  ( {lifetime[Iterator]=(vars),end=0}
  varids always size=0
  ( {lifetime[Iterator]=(varids),start=0}
Line 2525
  globalvar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),start=0}
  ( {lifetime[Iterator]=(vars),end=0}
Line 2526
  ( always {!<=-1,!>=2}
Line 2528
  != always {!<=-1,!>=2}
Line 2529
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always !<=-1
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2530
  globalvar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 2532
  return always {!<=-1,!>=2}
  true always 1
Line 2535
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2536
  return always {!<=-1,!>=2}
  true always 1
Line 2538
  return always {!<=-1,!>=2}
  false always 0
Line 2541
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2543
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
Line 2544
  ( always {!<=-1,!>=2}
  -3 always -3
  "this . %name% (" always "this . %name% ("
Line 2546
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2547
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2548
  return always {!<=-1,!>=2}
  true always 1
Line 2551
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2552
  return always {!<=-1,!>=2}
  true always 1
Line 2553
  return always {!<=-1,!>=2}
  false always 0
Line 2556
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2558
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2559
  return always {!<=-1,!>=2}
  false always 0
Line 2560
  != always {!<=-1,!>=2}
Line 2561
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2563
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2564
  return always {!<=-1,!>=2}
  true always 1
Line 2566
  return always {!<=-1,!>=2}
  false always 0
Line 2569
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2571
  < always {!<=-1,!>=2}
  0 always 0
Line 2572
  return always {!<=-1,!>=2}
  true always 1
Line 2573
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2574
  return always {!<=-1,!>=2}
  false always 0
Line 2575
  [ possible lifetime[Lambda]=(start)
Line 2576
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  cpp always {!<=-1,!>=2}
Line 2577
  true always 1
Line 2579
  global always {!<=-1,!>=2}
  global always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2581
  ( always !0
  ( always {!<=-1,!>=2}
Line 2582
  false always 0
Line 2583
  global always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2584
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2585
  global always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2588
  > always {!<=-1,!>=2}
  0 always 0
Line 2589
  != always {!<=-1,!>=2}
Line 2590
  ( always {!<=-1,!>=2}
Line 2591
  : always 0
  0 always 0
  global always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2592
  true always 1
Line 2595
  false always 0
Line 2597
  return always {!<=-1,!>=2}
Line 2603
  ( always {!<=-1,!>=2}
  tok always symbolic=(ftok)
  "%name% (|{" always "%name% (|{"
Line 2604
  ftok always symbolic=(tok)
Line 2605
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(ftok),symbolic=(ftok->next())}
  "(|{|[" always "(|{|["
Line 2606
  nullptr always 0
Line 2608
  ! always {!<=-1,!>=2}
  startTok always symbolic=(tok->astOperand2())
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2610
  startTok possible {symbolic=(tok->astOperand2()),symbolic=(tok->astOperand1())}
Line 2614
  "," always ","
Line 2619
  = always 0
  0 always 0
Line 2621
  openBracket always symbolic=(start->next())
  && always {!<=-1,!>=2}
  openBracket {symbolic=(start->next()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  openBracket {symbolic=(start->next()),!0}
  && always {!<=-1,!>=2}
  openBracket always symbolic=(start->next())
  ( always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 2622
  = always !0
  openBracket {symbolic=(start->next()),!0}
  ( always !0
Line 2623
  argument possible symbolic=(openBracket->next())
Line 2624
  ++ possible 1
  arguments possible 0
Line 2625
  argument {symbolic=(openBracket->next()),!0}
Line 2628
  arguments possible 0
Line 2632
  "," always ","
Line 2637
  = possible lifetime[Iterator]=(f->argumentList)
  ( possible lifetime[Iterator]=(f->argumentList)
  ( {lifetime[Iterator]=(f->argumentList),start=0}
  ( {lifetime[Iterator]=(f->argumentList),end=0}
  [ possible lifetime[Lambda]=(var)
Line 2638
  == always {!<=-1,!>=2}
Line 2640
  arg_it possible lifetime[Iterator]=(f->argumentList)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(f->argumentList),end=0}
Line 2641
  -1 always -1
Line 2642
  ( {lifetime[Iterator]=(f->argumentList),start=0}
  arg_it {lifetime[Iterator]=(f->argumentList),!symbolic=(f->argumentList.end()),!end=0}
Line 2645
  ( always {!<=-1,!>=2}
Line 2647
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 2648
  ( always {!<=-1,!>=2}
  args always size=2
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  1 always 1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  args always size=2
  1 always 1
Line 2653
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  last always !0
  != always {!<=-1,!>=2}
  "}" always "}"
Line 2654
  nullptr always 0
Line 2655
  last always !0
Line 2656
  ( always {!<=-1,!>=2}
  tok always symbolic=(last->link())
  "(" always "("
Line 2657
  tok always symbolic=(last->link())
Line 2658
  ( always {!<=-1,!>=2}
  tok possible symbolic=(last->link())
  "[" always "["
Line 2660
  nullptr always 0
Line 2666
  ! always {!<=-1,!>=2}
  first possible symbolic=(tok)@34594
  || always {!<=-1,!>=2}
  first always !0
  != always {!<=-1,!>=2}
  "[" always "["
Line 2667
  nullptr always 0
Line 2668
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  first always !0
  "] (|{" always "] (|{"
Line 2669
  nullptr always 0
Line 2670
  first always !0
  != always {!<=-1,!>=2}
  first always !0
Line 2671
  nullptr always 0
Line 2674
  tok always symbolic=(first)
  && always {!<=-1,!>=2}
  tok always symbolic=(first)
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 2675
  = always !0
  tok always symbolic=(first)
  ( always !0
Line 2676
  tok possible symbolic=(first)
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "{" always "{"
Line 2677
  ( always !0
Line 2678
  nullptr always 0
Line 2683
  first possible symbolic=(tok)@135
Line 2690
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2692
  ! {!<=-1,!>=2,1@223}
  cpp {!<=-1,!>=2,0@223}
Line 2693
  return always {!<=-1,!>=2}
  false always 0
Line 2695
  ! always {!<=-1,!>=2}
  stream possible symbolic=(stream->astParent()->astOperand1())
Line 2696
  return always {!<=-1,!>=2}
  false always 0
Line 2698
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  stream {symbolic=(stream->astParent()->astOperand1()),!0}
  "&|<<|>>" always "&|<<|>>"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  stream always !0
  ( always {!<=-1,!>=2}
Line 2699
  return always {!<=-1,!>=2}
  false always 0
Line 2701
  stream always !0
  != always {!<=-1,!>=2}
  stream always !0
Line 2702
  return always {!<=-1,!>=2}
  false always 0
Line 2704
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  stream always symbolic=(stream->astParent()->astOperand1())
  false always 0
Line 2707
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2709
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2710
  return always {!<=-1,!>=2}
  false always 0
Line 2712
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&|>>" always "&|>>"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2713
  return always {!<=-1,!>=2}
  false always 0
Line 2715
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|.|*|[" always "%name%|.|*|["
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2716
  return always {!<=-1,!>=2}
  false always 0
Line 2719
  parent possible symbolic=(op)
  ( possible 0
  && always {!<=-1,!>=2}
  parent possible symbolic=(op)
  ( always !0
  == always {!<=-1,!>=2}
  op possible symbolic=(parent)
Line 2720
  = always !0
  ( always !0
Line 2721
  parent possible symbolic=(op)
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%oror%|&&|(|,|.|!|;" always "%oror%|&&|(|,|.|!|;"
Line 2722
  return always {!<=-1,!>=2}
  false always 0
Line 2723
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 2724
  return always {!<=-1,!>=2}
  false always 0
Line 2725
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2726
  return always {!<=-1,!>=2}
  false always 0
Line 2727
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 2730
  ( always {!<=-1,!>=2}
Line 2732
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "> (" always "> ("
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 2735
  ( always {!<=-1,!>=2}
Line 2737
  ! always {!<=-1,!>=2}
Line 2738
  return always {!<=-1,!>=2}
  false always 0
Line 2739
  tok always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "?" always "?"
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2740
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 2741
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  skipMatch always !0
Line 2742
  return always {!<=-1,!>=2}
  false always 0
Line 2743
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 2744
  return always {!<=-1,!>=2}
  true always 1
Line 2745
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 2746
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2747
  return always {!<=-1,!>=2}
  false always 0
Line 2749
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(args),start=0}
  ( {lifetime[Iterator]=(args),end=0}
  [ possible lifetime[Lambda]=(skipMatch)
Line 2750
  ( always {!<=-1,!>=2}
Line 2753
  ( always {!<=-1,!>=2}
Line 2754
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2756
  ( always {!<=-1,!>=2}
  "( %type%" always "( %type%"
Line 2757
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2758
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2759
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2760
  ( always {!<=-1,!>=2}
  "%cop%|[|." always "%cop%|[|."
Line 2761
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 2762
  return always {!<=-1,!>=2}
  false always 0
Line 2763
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 2764
  return always {!<=-1,!>=2}
  false always 0
Line 2765
  return always {!<=-1,!>=2}
  true always 1
Line 2767
  ( always {!<=-1,!>=2}
  "%bool%|%num%|%str%|%char%|nullptr|NULL" always "%bool%|%num%|%str%|%char%|nullptr|NULL"
Line 2768
  return always {!<=-1,!>=2}
  true always 1
Line 2769
  ( always {!<=-1,!>=2}
Line 2770
  return always {!<=-1,!>=2}
  true always 1
Line 2772
  return always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 2773
  return always {!<=-1,!>=2}
  false always 0
Line 2778
  ! always {!<=-1,!>=2}
Line 2780
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "*|&|&&|[" always "*|&|&&|["
Line 2781
  tok always !0
Line 2782
  ! {!<=-1,!>=2,0}
  vars possible size=0
  ( {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[" always "["
Line 2784
  tok always !0
Line 2785
  ( always {!<=-1,!>=2}
  tok always !0
  "this . %var%" always "this . %var%"
Line 2786
  tok always !0
Line 2787
  ( always {!<=-1,!>=2}
  tok always !0
  "." always "."
Line 2788
  tok always !0
Line 2789
  tok always !0
Line 2790
  ( always {!<=-1,!>=2}
  tok always !0
  "::" always "::"
Line 2791
  tok always !0
Line 2792
  tok always !0
Line 2793
  tok always !0
  ( always !0
Line 2800
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%|(|{" always "%assign%|(|{"
Line 2802
  ! always {!<=-1,!>=2}
Line 2804
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always !0
Line 2805
  { always {size=1,{}
  ( always !0
  ( always !0
Line 2806
  ( always !0
Line 2812
  ! always {!<=-1,!>=2}
Line 2813
  nullptr always 0
Line 2814
  ( always {!<=-1,!>=2}
  tok always !0
  "*|&|&&|[" always "*|&|&&|["
Line 2815
  tok always !0
Line 2816
  && always {!<=-1,!>=2}
  vartok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[" always "["
Line 2818
  tok always !0
Line 2820
  ( always {!<=-1,!>=2}
  tok always !0
  "this . %var%" always "this . %var%"
Line 2821
  tok always !0
Line 2827
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 2828
  nullptr always 0
Line 2829
  ! always {!<=-1,!>=2}
Line 2830
  nullptr always 0
Line 2831
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always !0
Line 2832
  ( always !0
  ( always !0
Line 2833
  ( always !0
Line 2834
  ! always {!<=-1,!>=2}
Line 2835
  nullptr always 0
Line 2836
  vartok always !0
Line 2841
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 2842
  nullptr always 0
Line 2843
  ! always {!<=-1,!>=2}
Line 2844
  nullptr always 0
Line 2845
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 2846
  ( always !0
Line 2847
  ( always !0
Line 2848
  vartok possible symbolic=(vartok->variable()->nameToken())
  && always {!<=-1,!>=2}
  vartok always !0
  && always {!<=-1,!>=2}
  vartok always !0
  ( always !0
  == always {!<=-1,!>=2}
  vartok always !0
Line 2849
  vartok {!0,symbolic=(vartok->variable()->nameToken())}
Line 2855
  ! always {!<=-1,!>=2}
Line 2856
  nullptr always 0
Line 2857
  ( always {!<=-1,!>=2}
  expr always !0
  "[+-]" always "[+-]"
Line 2858
  expr always !0
Line 2859
  ? possible 1
  tok1 always !0
  : always 1
  expr always !0
Line 2861
  expr always !0
  ( always {!<=-1,!>=2}
Line 2862
  expr always !0
  expr always !0
  ( always !0
  : always 1
  expr always !0
Line 2863
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 2865
  ( always {!<=-1,!>=2}
  "new" always "new"
  && always {!<=-1,!>=2}
  : always 0
  nullptr always 0
Line 2868
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
Line 2870
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var possible symbolic=(var)@94
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2873
  ( always {!<=-1,!>=2}
Line 2875
  ! always {!<=-1,!>=2}
Line 2876
  return always {!<=-1,!>=2}
  false always 0
Line 2877
  tok always !0
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "( {" always "( {"
Line 2878
  return always {!<=-1,!>=2}
  true always 1
Line 2879
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2882
  ( always {!<=-1,!>=2}
Line 2884
  ! always {!<=-1,!>=2}
Line 2885
  return always {!<=-1,!>=2}
  false always 0
Line 2886
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 2888
  return always {!<=-1,!>=2}
  true always 1
Line 2889
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 2892
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 2894
  != always {!<=-1,!>=2}
Line 2895
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 2897
  return always {!<=-1,!>=2}
  false always 0
Line 2898
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(exprVarIds)
  ( always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(exprVarIds),end=0}
Line 2901
  parent possible {symbolic=(tok),symbolic=(parent->astParent()->astOperand1())}
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  ( always !0
  != always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2902
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 2904
  return always {!<=-1,!>=2}
  false always 0
Line 2905
  = always !0
  ( always !0
Line 2907
  parent possible {symbolic=(tok),symbolic=(parent->astParent()->astOperand1())}
  ( possible 0
Line 2908
  parent possible symbolic=(parent->astParent()->astOperand1())
  ( always !0
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2909
  return always {!<=-1,!>=2}
  false always 0
Line 2910
  parent possible symbolic=(parent->astParent()->astOperand1())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 2911
  return always {!<=-1,!>=2}
  false always 0
Line 2914
  return always {!<=-1,!>=2}
  true always 1
Line 2917
  ( always {!<=-1,!>=2}
Line 2919
  ! always {!<=-1,!>=2}
Line 2920
  return always {!<=-1,!>=2}
  false always 0
Line 2921
  ( always {!<=-1,!>=2}
  expr always !0
  "static_cast|const_cast|dynamic_cast|reinterpret_cast <" always "static_cast|const_cast|dynamic_cast|reinterpret_cast <"
Line 2922
  expr always !0
Line 2923
  ! always {!<=-1,!>=2}
  expr always !0
  ( always {!<=-1,!>=2}
Line 2924
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  expr always !0
  "NULL|nullptr" always "NULL|nullptr"
Line 2925
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2926
  return always {!<=-1,!>=2}
  false always 0
Line 2927
  ( always !0
  : always 1
Line 2928
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  castOp always symbolic=(expr->astOperand2()?expr->astOperand2():expr->astOperand1())
  "NULL|nullptr" always "NULL|nullptr"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  castOp always symbolic=(expr->astOperand2()?expr->astOperand2():expr->astOperand1())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  castOp always symbolic=(expr->astOperand2()?expr->astOperand2():expr->astOperand1())
Line 2931
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 2934
  && always {!<=-1,!>=2}
  expr always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  expr always !0
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 2935
  expr always !0
  ( always {!<=-1,!>=2}
Line 2936
  return always {!<=-1,!>=2}
  true always 1
Line 2937
  expr always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  expr always !0
  ( always !0
  expr always !0
Line 2938
  return always {!<=-1,!>=2}
  true always 1
Line 2941
  globalData {!<=-1,!>=2,0}
  globalData always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2942
  var always {!<=-1,!>=2}
  var always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2943
  expr possible 0
Line 2944
  [ possible {lifetime[Lambda]=(var),lifetime[Lambda]=(globalData),lifetime[Lambda]=(cpp),lifetime[Lambda]=(expr)}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , {lifetime[Address]=(globalData),!0}
  & {lifetime[Address]=(globalData),!0}
  globalData {!<=-1,!>=2,0}
  , {lifetime[Address]=(var),!0}
  & {lifetime[Address]=(var),!0}
  var always {!<=-1,!>=2}
Line 2945
  ( possible 0
Line 2946
  var always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2947
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2949
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2950
  :: always 0
  none always 0
Line 2952
  == always {!<=-1,!>=2}
  "->" always "->"
Line 2954
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2955
  :: always 0
  none always 0
Line 2956
  ( always {!<=-1,!>=2}
  "[*[]" always "[*[]"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 2958
  = always !0
  ( always !0
  ( always !0
Line 2959
  ( always !0
Line 2960
  lhsvar {symbolic=(tok->astOperand1()->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2961
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2962
  :: always 0
  none always 0
Line 2963
  lhsvar {symbolic=(tok->astOperand1()->variable()),!0}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  lhsvar {symbolic=(tok->astOperand1()->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2964
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2965
  :: always 0
  none always 0
Line 2966
  lhsvar {symbolic=(tok->astOperand1()->variable()),!0}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhstype always symbolic=(tok->astOperand1()->valueType())
  || always {!<=-1,!>=2}
  lhstype {symbolic=(tok->astOperand1()->valueType()),!0}
  <= always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhstype {symbolic=(tok->astOperand1()->valueType()),!0}
Line 2967
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2968
  :: always 0
  none always 0
Line 2971
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(expr)}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "." always "."
Line 2972
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2973
  :: always 0
  none always 0
Line 2975
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(expr)}
Line 2977
  tok possible {symbolic=(tok->variable()->nameToken()),symbolic=(expr)}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( always !0
Line 2978
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2979
  :: always 0
  none always 0
Line 2981
  tok possible {symbolic=(expr),symbolic=(tok->variable()->nameToken())}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2982
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2983
  :: always 0
  none always 0
Line 2985
  tok possible symbolic=(expr)
  != always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2986
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2987
  :: always 0
  none always 0
Line 2989
  tok possible symbolic=(expr)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 2990
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2991
  :: always 0
  none always 0
Line 2993
  tok possible symbolic=(expr)
  ( always {!<=-1,!>=2}
Line 2994
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2995
  :: always 0
  none always 0
Line 2999
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 3000
  globalData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3001
  :: always 0
  none always 0
Line 3003
  ( always {!<=-1,!>=2}
  ".|[" always ".|["
Line 3004
  :: always 1
  op1 always 1
Line 3005
  :: always 3
  op1_and_op2 always 3
Line 3007
  return always {!<=-1,!>=2}
  globalData always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always {!<=-1,!>=2}
Line 3010
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3013
  > always {!<=-1,!>=2}
  1000 always 1000
Line 3016
  ( always {!<=-1,!>=2}
  endToken possible symbolic=(tok)@119
  tok possible symbolic=(elseStart->link())
Line 3017
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 3022
  ( always {!<=-1,!>=2}
  "break ;" always "break ;"
Line 3026
  ( always {!<=-1,!>=2}
  "goto" always "goto"
Line 3029
  ! always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3031
  local always {!<=-1,!>=2}
  true always 1
Line 3032
  != always {!<=-1,!>=2}
Line 3037
  == always {!<=-1,!>=2}
  "continue" always "continue"
Line 3042
  = always !0
  lambdaEndToken always !0
Line 3043
  lambdaEndToken {symbolic=(tok),!0}
  lambdaEndToken {symbolic=(tok),!0}
  local always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3044
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3048
  ( always {!<=-1,!>=2}
  tok possible symbolic=(lambdaEndToken)
  "return|throw" always "return|throw"
Line 3053
  ! always {!<=-1,!>=2}
  opTok always symbolic=(tok->astOperand1())
Line 3055
  opTok possible {symbolic=(tok->astOperand1()),symbolic=(tok->next())}
Line 3057
  startEndTokens always symbolic=(opTok->findExpressionStartEndTokens())
  startEndTokens always symbolic=(opTok->findExpressionStartEndTokens())
  local {!<=-1,!>=2,0}
  true always 1
Line 3058
  != always {!<=-1,!>=2}
Line 3062
  ! always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3063
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3070
  == always {!<=-1,!>=2}
  "}" always "}"
Line 3072
  == always {!<=-1,!>=2}
Line 3073
  mValueFlowKnown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3075
  ( possible symbolic=(expr->scope())
  ( always {!<=-1,!>=2}
Line 3077
  = always 0
  nullptr always 0
Line 3078
  = always 0
  nullptr always 0
Line 3079
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 3081
  conditionEnd always symbolic=(tok->link()->previous())
Line 3082
  ( always {!<=-1,!>=2}
  "do {" always "do {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} while (" always "} while ("
Line 3083
  2 always 2
Line 3086
  conditionStart possible symbolic=(conditionEnd->link())
  && always {!<=-1,!>=2}
Line 3087
  used always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3088
  = always !0
  conditionStart always !0
  != always {!<=-1,!>=2}
  conditionEnd always !0
Line 3089
  ( possible lifetime[Iterator]=(exprVarIds)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(exprVarIds),end=0}
Line 3090
  used always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3094
  used {!<=-1,!>=2,0,1}
Line 3099
  local always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3100
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3105
  ( always {!<=-1,!>=2}
  "else {" always "else {"
Line 3106
  1 always 1
Line 3108
  ( always {!<=-1,!>=2}
  "asm (" always "asm ("
Line 3111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "while|for (" always "while|for ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 3112
  = always 0
  nullptr always 0
Line 3113
  = always 0
  nullptr always 0
Line 3114
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 3116
  ( always {!<=-1,!>=2}
  bodyStart always symbolic=(tok->next())
  "} while (" always "} while ("
Line 3117
  bodyStart always symbolic=(tok->next())
  2 always 2
Line 3120
  ( always {!<=-1,!>=2}
  conditionStart always symbolic=(tok->next())
  ") {" always ") {"
Line 3121
  conditionStart always symbolic=(tok->next())
Line 3124
  ! always {!<=-1,!>=2}
  bodyStart possible {symbolic=(tok->next()),symbolic=(conditionStart->link()->next())}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 3128
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  conditionStart always !0
  conditionStart always !0
  local always {!<=-1,!>=2}
Line 3132
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bodyStart always !0
  bodyStart always !0
  local always {!<=-1,!>=2}
Line 3136
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 3137
  1 always 1
Line 3139
  conditionStart always symbolic=(tok->next())
Line 3140
  condTok always symbolic=(conditionStart->astOperand2())
  ( always {!<=-1,!>=2}
Line 3141
  cond always {!<=-1,!>=2}
  cond always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  condTok always symbolic=(conditionStart->astOperand2())
Line 3142
  cond always {!<=-1,!>=2}
Line 3143
  local always {!<=-1,!>=2}
  true always 1
Line 3144
  != always {!<=-1,!>=2}
Line 3146
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 3147
  2 always 2
Line 3148
  local always {!<=-1,!>=2}
  true always 1
Line 3149
  != always {!<=-1,!>=2}
Line 3154
  ( always {!<=-1,!>=2}
  tok always symbolic=(bodyStart->link())
  & always !0
Line 3156
  ( always {!<=-1,!>=2}
  tok always symbolic=(bodyStart->link())
  "} else {" always "} else {"
Line 3157
  tok always symbolic=(bodyStart->link())
  2 always 2
Line 3158
  ! always {!<=-1,!>=2}
Line 3162
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 3166
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 3170
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 3175
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3176
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 3177
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 3178
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 3179
  ( always {!<=-1,!>=2}
  "for (" always "for ("
  && always {!<=-1,!>=2}
Line 3180
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 3184
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always !<=-1
  "<" always "<"
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  != always {!<=-1,!>=2}
  :: always !symbolic=(tok->str().find("<"))
Line 3187
  ( possible lifetime[Iterator]=(exprVarIds)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(exprVarIds),end=0}
Line 3189
  other always {!<=-1,!>=2}
  other always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3190
  same always {!<=-1,!>=2}
  same always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok always symbolic=(parent)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  false always 0
  tok always symbolic=(parent)
  true always 1
  false always 0
  nullptr always 0
Line 3191
  ! always {!<=-1,!>=2}
  same always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  "*|.|::|[|(|%cop%" always "*|.|::|[|(|%cop%"
Line 3193
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3195
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  false always 0
  true always 1
  false always 0
  nullptr always 0
Line 3196
  same always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3197
  == always {!<=-1,!>=2}
Line 3199
  v always Uninit
  . always {!<=-1,!>=2}
  known {!<=-1,!>=2,Uninit}
  = always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
Line 3204
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(exprVarIds)
  ( always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(exprVarIds),end=0}
  && always {!<=-1,!>=2}
Line 3205
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  false always 0
  true always 1
  false always 0
  nullptr always 0
Line 3206
  other always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3210
  mWhat possible {symbolic=(What::Reassign),symbolic=(What::UnusedValue)}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  same always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3213
  other {!<=-1,!>=2,1}
Line 3215
  ( always {!<=-1,!>=2}
  parent possible symbolic=(parent->astParent()->astOperand1())
  "=" always "="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3216
  ! always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(parent->astParent()->astOperand1())
Line 3220
  ( always {!<=-1,!>=2}
  parent always symbolic=(parent->astParent()->astOperand1())
Line 3221
  == always {!<=-1,!>=2}
Line 3226
  != always {!<=-1,!>=2}
Line 3227
  == always {!<=-1,!>=2}
  :: always 19
  eLambda always 19
Line 3232
  ( always {!<=-1,!>=2}
Line 3234
  reassign always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  false always 0
  false always 0
  false always 0
  nullptr always 0
Line 3235
  reassign always {!<=-1,!>=2}
Line 3238
  mWhat possible symbolic=(What::UnusedValue)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3240
  ( always {!<=-1,!>=2}
  parent possible symbolic=(parent->astParent()->astOperand1())
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent possible symbolic=(parent->astParent()->astOperand1())
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3241
  == always {!<=-1,!>=2}
Line 3242
  parent always symbolic=(parent->astParent()->astOperand1())
Line 3243
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent always symbolic=(parent->astParent()->astOperand1())
  || always {!<=-1,!>=2}
  parent always symbolic=(parent->astParent()->astOperand1())
  ( always !0
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 3244
  parent always symbolic=(parent->astParent()->astOperand1())
Line 3246
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[,(]" always "[,(]"
Line 3249
  ( always {!<=-1,!>=2}
  ftok possible {symbolic=(parent->astParent()),0}
  "," always ","
Line 3251
  ftok possible symbolic=(parent->astParent())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  "%name% (" always "%name% ("
Line 3252
  ftok always !0
Line 3253
  = always 0
  0 always 0
Line 3254
  argnr possible 0
  < always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(argnr+1),<=symbolic=(argnr)}
  && always {!<=-1,!>=2}
  argnr {<=symbolic=(args.size()-1),!>=symbolic=(args.size()),0}
  != always {!<=-1,!>=2}
Line 3255
  argnr {<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
  ++ {<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
Line 3256
  argnr possible >=symbolic=(args.size())
  < {!<=-1,!>=2,0}
  ( {!<=-1,<=symbolic=(argnr)}
Line 3257
  ftok always !0
Line 3259
  = possible lifetime[Iterator]=(functionInfo->argumentChecks)
  functionInfo always !0
  ( possible lifetime[Iterator]=(functionInfo->argumentChecks)
  argnr always !>=symbolic=(args.size())
  1 always 1
Line 3260
  it always symbolic=(functionInfo->argumentChecks.find(argnr+1))
  != always {!<=-1,!>=2}
  functionInfo always !0
  ( {lifetime[Iterator]=(functionInfo->argumentChecks),end=0}
  && always {!<=-1,!>=2}
  it {symbolic=(functionInfo->argumentChecks.find(argnr+1)),!symbolic=(functionInfo->argumentChecks.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always 1
  DIR_OUT always 1
Line 3272
  ( always {!<=-1,!>=2}
  ")|do {" always ")|do {"
Line 3273
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "switch (" always "switch ("
Line 3276
  2 always 2
  1 always 1
  local always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3277
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3279
  mWhat possible symbolic=(What::Reassign)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3280
  mValueFlowKnown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3281
  mWhat possible symbolic=(What::ValueFlow)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3284
  scopeEndToken always !0
  local always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3285
  == always {!<=-1,!>=2}
Line 3289
  ( always {!<=-1,!>=2}
  1 always 1
  "} else {" always "} else {"
Line 3290
  1 always 1
  2 always 2
Line 3291
  local always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
Line 3292
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3293
  mValueFlowKnown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3294
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3296
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always {symbolic=(Result::Type::WRITE),symbolic=(result1.type)}
Line 3300
  1 always 1
Line 3308
  ( always {!<=-1,!>=2}
Line 3310
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3312
  [ possible lifetime[Lambda]=(ret)
  & {lifetime[Address]=(ret),!0}
  ret always {!<=-1,!>=2}
Line 3313
  ( always {!<=-1,!>=2}
  "( volatile" always "( volatile"
Line 3314
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3315
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 3316
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3317
  ret {!<=-1,!>=2,1}
  ? possible {0,3}
  :: always 0
  none always 0
  : always 3
  :: always 3
  op1_and_op2 always 3
Line 3319
  return always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
Line 3322
  ( always {!<=-1,!>=2}
Line 3324
  return always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
Line 3331
  local always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3332
  unknownVarId always {!<=-1,!>=2}
  unknownVarId always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3334
  [ possible {lifetime[Lambda]=(if(tok->str()=="["&&mWhat==What::UnusedValue)),lifetime[Lambda]=(unknownVarId)}
Line 3335
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3336
  :: always 1
  op1 always 1
Line 3337
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "." always "."
Line 3339
  unknownVarId always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3340
  :: always 0
  none always 0
Line 3342
  > always {!<=-1,!>=2}
  0 always 0
Line 3343
  ( {>=1,!<=0}
Line 3344
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 3346
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  "%var% [=(]" always "%var% [=(]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 3347
  :: always 0
  none always 0
Line 3348
  deref always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 3349
  local always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always symbolic=(var)
  deref {symbolic=(tok->astParent()&&(tok->astParent()->isUnaryOp("*")||(tok->astParent()->str()=="["&&tok==tok->astParent()->astOperand1()))),!<=-1,!>=2}
Line 3352
  :: always 3
  op1_and_op2 always 3
Line 3354
  localOut possible lifetime[Address]=(local)@60
Line 3355
  * always {!<=-1,!>=2}
  localOut {!0,lifetime[Address]=(local)@60}
  = always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
Line 3356
  unknownVarIdOut possible lifetime[Address]=(unknownVarId)@60
Line 3357
  * always {!<=-1,!>=2}
  unknownVarIdOut {!0,lifetime[Address]=(unknownVarId)@60}
  = always {!<=-1,!>=2}
  unknownVarId always {!<=-1,!>=2}
Line 3364
  local always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3365
  unknownVarId always {!<=-1,!>=2}
  unknownVarId always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3366
  & {lifetime[Address]=(local),!0}
  local always 1
  & {lifetime[Address]=(unknownVarId),!0}
  unknownVarId always 0
Line 3368
  unknownVarId always {!<=-1,!>=2}
Line 3371
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3372
  local always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3376
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3379
  local always {!<=-1,!>=2}
  false always 0
Line 3382
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3384
  ! always {!<=-1,!>=2}
Line 3386
  scopeEndToken always !0
  local always {!<=-1,!>=2}
  false always 0
Line 3392
  ( always {!<=-1,!>=2}
Line 3394
  ! always {!<=-1,!>=2}
Line 3395
  return always {!<=-1,!>=2}
  false always 0
Line 3396
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  false always 0
  tok always !0
  false always 0
  false always 0
  nullptr always 0
Line 3397
  return always {!<=-1,!>=2}
  true always 1
Line 3398
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 3403
  ( always {!<=-1,!>=2}
Line 3404
  nullptr always 0
Line 3407
  == always {!<=-1,!>=2}
  : always 0
  nullptr always 0
Line 3410
  ( always {!<=-1,!>=2}
Line 3412
  ( always {!<=-1,!>=2}
Line 3413
  return always {!<=-1,!>=2}
  false always 0
Line 3414
  ( always {!<=-1,!>=2}
Line 3415
  return always {!<=-1,!>=2}
  false always 0
Line 3418
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3421
  ( always {!<=-1,!>=2}
Line 3423
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 3424
  return always {!<=-1,!>=2}
  true always 1
Line 3426
  macro always 0
  = always 0
  false always 0
Line 3427
  pure always 0
  = always 0
  false always 0
Line 3428
  followVar always 0
  = always 0
  false always 0
Line 3430
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 3433
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while|for" always "if|while|for"
Line 3436
  = always 0
  0 always 0
  argnr possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 3437
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argnr {<=symbolic=(args.size()-1),!>=symbolic=(args.size())}
  "%name%|.|::" always "%name%|.|::"
Line 3439
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3442
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  macro always 0
  pure always 0
  followVar always 0
Line 3444
  scope always symbolic=(expr->scope())
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 3445
  return always {!<=-1,!>=2}
  true always 1
Line 3452
  = always 0
  nullptr always 0
Line 3453
  ( always {!<=-1,!>=2}
  "& %name% =" always "& %name% ="
Line 3454
  2 always 2
Line 3455
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 3457
  ( always {!<=-1,!>=2}
  "std :: ref (" always "std :: ref ("
Line 3458
  3 always 3
Line 3463
  ( always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  macro always 0
  pure always 0
  followVar always 0
Line 3464
  return always {!<=-1,!>=2}
  true always 1
Line 3467
  return always {!<=-1,!>=2}
  false always 0
Line 3470
  ( always {!<=-1,!>=2}
Line 3474
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3477
  ! always {!<=-1,!>=2}
  var always symbolic=(val.tokvalue->variable())
Line 3479
  ! always {!<=-1,!>=2}
  var {symbolic=(val.tokvalue->variable()),!0}
  ( always {!<=-1,!>=2}
Line 3480
  return always {!<=-1,!>=2}
  true always 1
Line 3481
  var always !0
  ( always {!<=-1,!>=2}
Line 3482
  return always {!<=-1,!>=2}
  true always 1
Line 3486
  return always {!<=-1,!>=2}
  false always 0
Line 3489
  ( always {!<=-1,!>=2}
Line 3491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "sizeof|typeof|offsetof|decltype|__typeof__ (" always "sizeof|typeof|offsetof|decltype|__typeof__ ("
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
