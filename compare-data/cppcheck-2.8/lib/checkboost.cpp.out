

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073743482 !@expr1073743483 mTokenizer@var28 ) {
69: instances (@expr1073743484 ) .@expr1073743485 remove (@expr1073743486 this@expr1073743487 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073743488 string (@expr1073743489 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073743490 void ) tokenizer@var21 ;
108: (@expr1073743491 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073743492 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073743493 void ) ctu@var24 ;
120: (@expr1073743494 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073743495 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073743496 0U ) , Certainty ::@expr1073743497 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073743498 list < const Token *@expr1073743499 > callstack@var41 (@expr1073743500 1 , tok@var35 ) ;
141: reportError (@expr1073743501 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073743502 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073743503 0U ) , Certainty ::@expr1073743504 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var64 ;
42: double mDoubleValue@var65 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var66 ;
44: bool mIsUnsigned@var67 ;
45:
46: void promote ( const value & v@var68 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var69 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var66 !=@expr1073743505 Type ::@expr1073743506 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var66 ==@expr1073743507 Type ::@expr1073743508 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073743509 ) ?@expr1073743510 mDoubleValue@var65 :@expr1073743511 (@expr1073743512 double ) mIntValue@var64 ;
60: }
61:
62: static value calc ( char op@var70 , const value & v1@var71 , const value & v2@var72 ) ;
63: int compare ( const value & v@var73 ) const ;
64: value add ( int v@var74 ) const ;
65: value shiftLeft ( const value & v@var75 ) const ;
66: value shiftRight ( const value & v@var76 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var77 ;
72:
73: static long long toLongNumber ( const std :: string & str@var78 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var79 ) ;
75:
76: template < class T > static std :: string toString ( T value@var80 ) {
77: std ::@expr1073743513 ostringstream result@var81 ;
78: result@var81 <<@expr1073743514 value@var80 ;
79: return result@var81 .@expr1073743515 str (@expr1073743516 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var82 ) ;
82:
83: static bool isInt ( const std :: string & str@var83 ) ;
84: static bool isFloat ( const std :: string & str@var84 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var85 ) ;
86: static bool isNegative ( const std :: string & str@var86 ) ;
87: static bool isPositive ( const std :: string & str@var87 ) ;
88: static bool isDec ( const std :: string & str@var88 ) ;
89: static bool isFloatHex ( const std :: string & str@var89 ) ;
90: static bool isIntHex ( const std :: string & str@var90 ) ;
91: static bool isOct ( const std :: string & str@var91 ) ;
92: static bool isBin ( const std :: string & str@var92 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var93 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var94 , bool supportMicrosoftExtensions@var95 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var96 , const std :: string & second@var97 ) ;
105: static std :: string subtract ( const std :: string & first@var98 , const std :: string & second@var99 ) ;
106: static std :: string multiply ( const std :: string & first@var100 , const std :: string & second@var101 ) ;
107: static std :: string divide ( const std :: string & first@var102 , const std :: string & second@var103 ) ;
108: static std :: string mod ( const std :: string & first@var104 , const std :: string & second@var105 ) ;
109: static std :: string incdec ( const std :: string & var@var106 , const std :: string & op@var107 ) ;
110: static std :: string calculate ( const std :: string & first@var108 , const std :: string & second@var109 , char action@var110 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var111 ) ;
113: static std :: string cos ( const std :: string & tok@var112 ) ;
114: static std :: string tan ( const std :: string & tok@var113 ) ;
115: static std :: string abs ( const std :: string & tok@var114 ) ;
116: static bool isEqual ( const std :: string & first@var115 , const std :: string & second@var116 ) ;
117: static bool isNotEqual ( const std :: string & first@var117 , const std :: string & second@var118 ) ;
118: static bool isGreater ( const std :: string & first@var119 , const std :: string & second@var120 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var121 , const std :: string & second@var122 ) ;
120: static bool isLess ( const std :: string & first@var123 , const std :: string & second@var124 ) ;
121: static bool isLessEqual ( const std :: string & first@var125 , const std :: string & second@var126 ) ;
122: static bool isNullValue ( const std :: string & str@var127 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var128 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var129 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var130 , std :: string :: size_type iPos@var131 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var132 , const MathLib :: value & v2@var133 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var134 , const MathLib :: value & v2@var135 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var136 , const MathLib :: value & v2@var137 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var138 , const MathLib :: value & v2@var139 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var140 , const MathLib :: value & v2@var141 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var142 , const MathLib :: value & v2@var143 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var144 , const MathLib :: value & v2@var145 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var146 , const MathLib :: value & v2@var147 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var148 , const MathLib :: value & v2@var149 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var150 , const MathLib :: value & v2@var151 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var152 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var153 ) const {
54: x@var153 ++@expr1073743517 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var154 ) const {
60: x@var154 --@expr1073743518 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var155 , const U & y@var156 ) const {
67: return x@var155 <@expr1073743519 y@var156 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var157 , const U & y@var158 ) const {
74: return std ::@expr1073743520 abs (@expr1073743521 x@var157 -@expr1073743522 y@var158 ) ==@expr1073743523 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var159 , T x@var160 , U y@var161 ) const {
81: result@var159 =@expr1073743524 !@expr1073743525 (@expr1073743526 x@var160 >@expr1073743527 y@var161 ||@expr1073743528 x@var160 <@expr1073743529 y@var161 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var162 = 0 , Bound b@var163 = Bound :: Point )
91: : valueType@var203 ( ValueType :: INT ) ,
92: bound@var204 ( b@var163 ) ,
93: intvalue@var205 ( val@var162 ) ,
94: tokvalue@var206 ( nullptr ) ,
95: floatValue@var207 ( 0.0 ) ,
96: moveKind@var208 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var209 ( val@var162 ) ,
98: condition@var210 ( nullptr ) ,
99: varId@var212 ( 0U ) ,
100: safe@var213 ( false ) ,
101: conditional@var214 ( false ) ,
102: macro@var215 ( false ) ,
103: defaultArg@var216 ( false ) ,
104: indirect@var217 ( 0 ) ,
105: path@var218 ( 0 ) ,
106: wideintvalue@var219 ( val@var162 ) ,
107: subexpressions@var220 ( ) ,
108: capturetok@var221 ( nullptr ) ,
109: lifetimeKind@var222 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var223 ( LifetimeScope :: Local ) ,
111: valueKind@var228 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var164 , long long val@var165 , Bound b@var166 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var167 ) const {
118: if (@expr1073743530 valueType@var203 !=@expr1073743531 rhs@var167 .@expr1073743532 valueType@var168 ) {
119: return false ; }
120: switch (@expr1073743533 valueType@var203 ) {
121: case ValueType ::@expr1073743534 INT :@expr1711
122: case ValueType ::@expr1073743536 CONTAINER_SIZE :@expr1711
123: case ValueType ::@expr1073743538 BUFFER_SIZE :@expr1711
124: case ValueType ::@expr1073743540 ITERATOR_START :@expr1711
125: case ValueType ::@expr1073743542 ITERATOR_END :@expr1711 ;
126: if (@expr1720 intvalue@var205 !=@expr1721 rhs@var167 .@expr1722 intvalue@var169 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073743547 TOK :@expr1711 ;
130: if (@expr1725 tokvalue@var206 !=@expr1726 rhs@var167 .@expr1727 tokvalue@var170 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073743552 FLOAT :@expr1711 ;
134:
135: if (@expr1073743554 floatValue@var207 >@expr1073743555 rhs@var167 .@expr1732 floatValue@var171 ||@expr1073743557 floatValue@var207 <@expr1073743558 rhs@var167 .@expr1732 floatValue@var171 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073743560 MOVED :@expr1711 ;
139: if (@expr1073743562 moveKind@var208 !=@expr1073743563 rhs@var167 .@expr1073743564 moveKind@var172 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073743565 UNINIT :@expr1711 ;
143: break ;
144: case ValueType ::@expr1073743567 LIFETIME :@expr1711 ;
145: if (@expr1725 tokvalue@var206 !=@expr1726 rhs@var167 .@expr1727 tokvalue@var170 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073743572 SYMBOLIC :@expr1711 ;
149: if (@expr1073743574 !@expr1073743575 sameToken (@expr1073743576 tokvalue@var206 , rhs@var167 .@expr1727 tokvalue@var170 ) ) {
150: return false ; }
151: if (@expr1720 intvalue@var205 !=@expr1721 rhs@var167 .@expr1722 intvalue@var169 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var173 , F f@var174 ) {
160: switch (@expr1073743581 self@var173 .@expr1073743582 valueType@var175 ) {
161: case ValueType ::@expr1073743583 INT :@expr1760
162: case ValueType ::@expr1073743585 SYMBOLIC :@expr1760
163: case ValueType ::@expr1073743587 BUFFER_SIZE :@expr1760
164: case ValueType ::@expr1073743589 CONTAINER_SIZE :@expr1760
165: case ValueType ::@expr1073743591 ITERATOR_START :@expr1760
166: case ValueType ::@expr1073743593 ITERATOR_END :@expr1760 ; {
167: f@var174 (@expr1073743595 self@var173 .@expr1073743596 intvalue@var176 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073743597 FLOAT :@expr1760 ; {
171: f@var174 (@expr1073743599 self@var173 .@expr1073743600 floatValue@var177 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073743601 UNINIT :@expr1760
175: case ValueType ::@expr1073743603 TOK :@expr1760
176: case ValueType ::@expr1073743605 LIFETIME :@expr1760
177: case ValueType ::@expr1073743607 MOVED :@expr1760 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var178 , Compare compare@var179 , T x@var180 , U y@var181 ) const {
186: result@var178 =@expr1073743609 compare@var179 (@expr1073743610 x@var180 , y@var181 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var182 , const Value & rhs@var183 , Compare compare@var184 , T x@var185 ) const {
191: visitValue (@expr1073743612 rhs@var183 ,
192: std ::@expr1073743613 bind (@expr1073743614 innerVisitor {@expr1073743615 } , std ::@expr1073743616 ref (@expr1073743617 result@var182 ) , std ::@expr1073743618 move (@expr1073743619 compare@var184 ) , x@var185 , std ::@expr1073743620 placeholders ::@expr1073743621 _1@expr1073743611 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var186 , Compare compare@var187 ) const {
198: assert (@expr1073743623 (@expr1073743624 !@expr1073743625 this@expr1802 .@expr1073743627 isSymbolicValue (@expr1073743628 ) &&@expr1073743629 !@expr1073743630 rhs@var186 .@expr1073743631 isSymbolicValue (@expr1073743632 ) ) ||@expr1073743633
199: (@expr1073743634 this@expr1802 .@expr1073743635 valueType@var203 ==@expr1073743636 rhs@var186 .@expr1073743637 valueType@var188 &&@expr1073743638 sameToken (@expr1073743639 this@expr1802 .@expr1073743640 tokvalue@var206 , rhs@var186 .@expr1073743641 tokvalue@var189 ) ) ) ;
200: bool result@var190 ; result@var190 =@expr1073743642 false ;
201: visitValue (@expr1073743643
202: *@expr1073743644 this@expr1802 ,
203: std ::@expr1073743645 bind (@expr1073743646 compareVisitor {@expr1073743647 } , std ::@expr1824 ref (@expr1073743649 result@var190 ) , std ::@expr1824 ref (@expr1073743651 rhs@var186 ) , std ::@expr1073743652 move (@expr1073743653 compare@var187 ) , std ::@expr1073743654 placeholders ::@expr1073743655 _1@expr1073743622 ) ) ;
204: return result@var190 ;
205: }
206:
207: bool operator== ( const Value & rhs@var191 ) const {
208: if (@expr1073743656 !@expr1073743657 equalValue (@expr1073743658 rhs@var191 ) ) {
209: return false ; }
210:
211: return varvalue@var209 ==@expr1073743659 rhs@var191 .@expr1073743660 varvalue@var192 &&@expr1073743661
212: condition@var210 ==@expr1073743662 rhs@var191 .@expr1073743663 condition@var193 &&@expr1073743664
213: varId@var212 ==@expr1073743665 rhs@var191 .@expr1073743666 varId@var194 &&@expr1073743667
214: conditional@var214 ==@expr1073743668 rhs@var191 .@expr1073743669 conditional@var195 &&@expr1073743670
215: defaultArg@var216 ==@expr1073743671 rhs@var191 .@expr1073743672 defaultArg@var196 &&@expr1073743673
216: indirect@var217 ==@expr1073743674 rhs@var191 .@expr1073743675 indirect@var197 &&@expr1073743676
217: valueKind@var228 ==@expr1073743677 rhs@var191 .@expr1073743678 valueKind@var198 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var199 ) const {
221: return !@expr1073743679 (@expr1073743680 *@expr1073743681 this@expr1073743682 ==@expr1073743683 rhs@var199 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var200 ) const {
226: bool result@var201 ; result@var201 =@expr1073743685 false ;
227: visitValue (@expr1073743686 *@expr1073743687 this@expr1073743688 , std ::@expr1073743689 bind (@expr1073743690 equalVisitor {@expr1073743691 } , std ::@expr1073743692 ref (@expr1073743693 result@var201 ) , x@var200 , std ::@expr1073743694 placeholders ::@expr1073743695 _1@expr1073743684 ) ) ;
228: return result@var201 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073743696 bound@var204 ==@expr1073743697 Bound ::@expr1073743698 Lower ) {
233: visitValue (@expr1073743699 *@expr1876 this@expr1877 , increment {@expr1073743702 } ) ; }
234: else { if (@expr1073743703 bound@var204 ==@expr1073743704 Bound ::@expr1073743705 Upper ) {
235: visitValue (@expr1073743706 *@expr1876 this@expr1877 , decrement {@expr1073743708 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073743709 bound@var204 ==@expr1073743710 Bound ::@expr1887 Lower ) {
240: bound@var204 =@expr1073743712 Bound ::@expr1889 Upper ; }
241: else { if (@expr1073743714 bound@var204 ==@expr1073743715 Bound ::@expr1889 Upper ) {
242: bound@var204 =@expr1073743717 Bound ::@expr1887 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073743719 ) ;
247: decreaseRange (@expr1073743720 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var202 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var203 ;
267: bool isIntValue ( ) const {
268: return valueType@var203 ==@expr1073743721 ValueType ::@expr1073743722 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var203 ==@expr1073743723 ValueType ::@expr1073743724 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var203 ==@expr1073743725 ValueType ::@expr1073743726 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var203 ==@expr1073743727 ValueType ::@expr1073743728 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var203 ==@expr1073743729 ValueType ::@expr1073743730 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var203 ==@expr1073743731 ValueType ::@expr1073743732 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var203 ==@expr1073743733 ValueType ::@expr1073743734 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var203 ==@expr1073743735 ValueType ::@expr1073743736 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var203 ==@expr1073743737 ValueType ::@expr1073743738 ITERATOR_START ||@expr1073743739 valueType@var203 ==@expr1073743740 ValueType ::@expr1073743741 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var203 ==@expr1073743742 ValueType ::@expr1073743743 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var203 ==@expr1073743744 ValueType ::@expr1073743745 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var203 ==@expr1073743746 ValueType ::@expr1073743747 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var203 ==@expr1073743749 ValueType ::@expr1073743750 LIFETIME &&@expr1073743751 lifetimeScope@var223 ==@expr1073743752 LifetimeScope ::@expr1073743753 Local@expr1073743748 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var203 ==@expr1073743754 ValueType ::@expr1073743755 LIFETIME &&@expr1073743756 lifetimeScope@var223 ==@expr1073743757 LifetimeScope ::@expr1073743758 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var203 ==@expr1073743759 ValueType ::@expr1073743760 LIFETIME &&@expr1073743761 lifetimeScope@var223 ==@expr1073743762 LifetimeScope ::@expr1073743763 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073743764 ) ||@expr1073743765 isUninitValue (@expr1073743766 ) ||@expr1073743767 isLifetimeValue (@expr1073743768 ) ;
318: }
319:
320:
321: Bound bound@var204 ;
322:
323:
324: long long intvalue@var205 ;
325:
326:
327: const Token * tokvalue@var206 ;
328:
329:
330: double floatValue@var207 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var208 ;
334:
335:
336: long long varvalue@var209 ;
337:
338:
339: const Token * condition@var210 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var211 ;
342:
343:
344: int varId@var212 ;
345:
346:
347: bool safe@var213 ;
348:
349:
350: bool conditional@var214 ;
351:
352:
353: bool macro@var215 ;
354:
355:
356: bool defaultArg@var216 ;
357:
358: int indirect@var217 ;
359:
360:
361: long long path@var218 ;
362:
363:
364: long long wideintvalue@var219 ;
365:
366: std :: vector < std :: string > subexpressions@var220 ;
367:
368:
369: const Token * capturetok@var221 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var222 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var223 ;
385:
386: static const char * toString ( MoveKind moveKind@var224 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var225 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var226 ) ;
389: static const char * toString ( Bound bound@var227 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var228 ;
402:
403: void setKnown ( ) {
404: valueKind@var228 =@expr1073743769 ValueKind ::@expr1073743770 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var228 ==@expr1073743771 ValueKind ::@expr1073743772 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var228 =@expr1073743774 ValueKind ::@expr1073743775 Possible@expr1073743773 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var228 ==@expr1073743777 ValueKind ::@expr1073743778 Possible@expr1073743776 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var228 ==@expr1073743779 ValueKind ::@expr1073743780 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var228 =@expr1073743781 ValueKind ::@expr1073743782 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var229 = true ) {
428: if (@expr1073743783 inconclusive@var229 ) {
429: valueKind@var228 =@expr1073743784 ValueKind ::@expr1073743785 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var228 ==@expr1073743786 ValueKind ::@expr1073743787 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073743789 isKnown (@expr1073743790 ) ) {
438: valueKind@var228 =@expr1073743791 ValueKind ::@expr1073743792 Possible@expr1073743788 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073743793 condition@var210 &&@expr1073743794 !@expr1073743795 defaultArg@var216 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var230 , const Token * tok2@var231 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var232 , const Settings * settings@var233 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var234 , SymbolDatabase * symboldatabase@var235 , ErrorLogger * errorLogger@var236 , const Settings * settings@var237 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var238 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var239 , const Settings * settings@var240 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var241 ,
459: const Settings * settings@var242 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var243 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var244 , const Token * indexTok@var245 , bool possible@var246 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var247 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var248 , const Settings * settings@var249 = nullptr , int depth@var250 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var251 ;
471: bool addressOf@var252 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var253 ;
473: bool inconclusive@var254 ;
474:
475: LifetimeToken ( ) : token@var251 ( nullptr ) , addressOf@var252 ( false ) , errorPath@var253 ( ) , inconclusive@var254 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var255 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var256 )
478: : token@var251 ( token@var255 ) , addressOf@var252 ( false ) , errorPath@var253 ( std :: move ( errorPath@var256 ) ) , inconclusive@var254 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var257 , bool addressOf@var258 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var259 )
482: : token@var251 ( token@var257 ) , addressOf@var252 ( addressOf@var258 ) , errorPath@var253 ( std :: move ( errorPath@var259 ) ) , inconclusive@var254 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var260 , bool b@var261 ) {
486: for (@expr1073743796 LifetimeToken &@expr1073743797 x@var262 :@expr1073743798 v@var260 ) {
487: x@var262 .@expr1073743799 addressOf@var263 =@expr1073743800 b@var261 ; }
488: return v@var260 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var264 , bool b@var265 ) {
492: for (@expr1073743801 LifetimeToken &@expr1073743802 x@var266 :@expr1073743803 v@var264 ) {
493: x@var266 .@expr1073743804 inconclusive@var267 =@expr1073743805 b@var265 ; }
494: return v@var264 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var268 , ValueFlow :: Value & true_value@var269 , ValueFlow :: Value & false_value@var270 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var271 ) ;
499: const Token * parseCompareInt ( const Token * tok@var272 , ValueFlow :: Value & true_value@var273 , ValueFlow :: Value & false_value@var274 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var275 , long long val@var276 , const Token * varTok@var277 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var278 , const Token * varTok@var279 , long long val@var280 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var281 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var282 ,
508: ValueFlow :: Value & value@var283 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var284 ,
511: bool escape@var285 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var286 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var287 , const Token * lifetime@var288 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var289 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var290 , bool * addressOf@var291 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var292 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var293 , const Settings * settings@var294 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var295 , const ValueFlow :: Value * val@var296 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var297 , const ValueFlow :: Value * val@var298 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var299 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var300 , bool inconclusive@var301 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var302 ,
529: bool inconclusive@var303 = false ,
530: long long path@var304 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var305 , const Scope * defaultScope@var306 = nullptr , bool smallest@var307 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var308 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var309 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var310 ;
69: std :: string mScope@var311 ;
70: std :: string mName@var312 ;
71: std :: string mFullName@var313 ;
72: const Token * mNameToken@var314 ;
73: const Token * mParamEnd@var315 ;
74: unsigned int mFlags@var316 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var317 ) {
90: setFlag (@expr1073743806 fIsClass , state@var317 ) ;
91: }
92: void isFunction ( bool state@var318 ) {
93: setFlag (@expr1073743807 fIsFunction , state@var318 ) ;
94: }
95: void isVariable ( bool state@var319 ) {
96: setFlag (@expr1073743808 fIsVariable , state@var319 ) ;
97: }
98: void isAlias ( bool state@var320 ) {
99: setFlag (@expr1073743809 fIsAlias , state@var320 ) ;
100: }
101: void isSpecialization ( bool state@var321 ) {
102: setFlag (@expr1073743810 fIsSpecialization , state@var321 ) ;
103: }
104: void isPartialSpecialization ( bool state@var322 ) {
105: setFlag (@expr1073743811 fIsPartialSpecialization , state@var322 ) ;
106: }
107: void isForwardDeclaration ( bool state@var323 ) {
108: setFlag (@expr1073743812 fIsForwardDeclaration , state@var323 ) ;
109: }
110: void isVariadic ( bool state@var324 ) {
111: setFlag (@expr1073743813 fIsVariadic , state@var324 ) ;
112: }
113: void isFriend ( bool state@var325 ) {
114: setFlag (@expr1073743814 fIsFriend , state@var325 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var326 ) const {
123: return (@expr1991 (@expr1991 mFlags@var316 &@expr1073743817 flag@var326 ) !=@expr1073743818 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var327 , bool state@var328 ) {
132: mFlags@var316 =@expr1073743819 state@var328 ?@expr1073743820 mFlags@var316 |@expr1073743821 flag@var327 :@expr1073743822 mFlags@var316 &@expr1073743823 ~@expr1073743824 flag@var327 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var329 , const std :: string & scope@var330 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var331 , const std :: string & scope@var332 , const Token * nameToken@var333 , const Token * paramEnd@var334 ) ;
150: TokenAndName ( const TokenAndName & other@var335 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var336 ) const {
154: return mToken@var310 ==@expr1073743825 rhs@var336 .@expr1073743826 mToken@var337 &&@expr1073743827 mScope@var311 ==@expr1073743828 rhs@var336 .@expr1073743829 mScope@var338 &&@expr1073743830 mName@var312 ==@expr1073743831 rhs@var336 .@expr1073743832 mName@var339 &&@expr1073743833 mFullName@var313 ==@expr1073743834 rhs@var336 .@expr1073743835 mFullName@var340 &&@expr1073743836
155: mNameToken@var314 ==@expr1073743837 rhs@var336 .@expr1073743838 mNameToken@var341 &&@expr1073743839 mParamEnd@var315 ==@expr1073743840 rhs@var336 .@expr1073743841 mParamEnd@var342 &&@expr1073743842 mFlags@var316 ==@expr1073743843 rhs@var336 .@expr1073743844 mFlags@var343 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var310 ;
160: }
161: void token ( Token * token@var344 ) {
162: mToken@var310 =@expr1073743845 token@var344 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var311 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var312 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var313 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var314 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var315 ;
178: }
179: void paramEnd ( const Token * end@var345 ) {
180: mParamEnd@var315 =@expr1073743846 end@var345 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073743847 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073743848 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073743849 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073743850 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073743851 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073743852 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073743853 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073743854 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073743855 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var346 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var347 ) const {
243:
244:
245: return (@expr2032 (@expr2032 mFlags@var316 &@expr1073743858 fFamilyMask ) &@expr1073743859 (@expr2032 decl@var347 .@expr1073743861 mFlags@var348 &@expr1073743862 fFamilyMask ) ) !=@expr1073743863 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var349 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var350 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var351 , const unsigned long numberOfArguments@var352 , bool variadic@var353 , const char patternAfter@var354 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var355 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var356 , int & namepos@var357 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var358 , int & namepos@var359 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var360 , int & namepos@var361 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var362 ,
306: bool & codeWithTemplates@var363 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var364 , bool isTemplate@var365 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var366 = nullptr , Token * backToken@var367 = nullptr , bool isTemplate@var368 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var369 , Token * end@var370 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var371 , const std :: string & scope@var372 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var373 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var374 ,
393: const std :: list < const Token * > & specializations@var375 ,
394: const std :: time_t maxtime@var376 ,
395: std :: set < std :: string > & expandedtemplates@var377 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var378 , const Token * tok@var379 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var380 , const Token * tok@var381 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var382 ,
422: const TokenAndName & templateInstantiation@var383 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var384 ,
424: const std :: string & newName@var385 ,
425: bool copy@var386 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var387 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var388 ,
435: const std :: string & newName@var389 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var390 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var391 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var392 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var393 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var394 ,
458: const Token * templateInstantiationNameToken@var395 ,
459: const std :: list < const Token * > & specializations@var396 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var397 , const Token * end@var398 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var399 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var400 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var401 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var402 ,
487: const std :: string & indent@var403 = "    " ) const ;
488: void printOut ( const std :: string & text@var404 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var405 ;
491: TokenList & mTokenList@var406 ;
492: const Settings * mSettings@var407 ;
493: ErrorLogger * mErrorLogger@var408 ;
494: bool mChanged@var409 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var410 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var411 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var412 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var413 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var414 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var415 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var416 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var417 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var418 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var419 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var420 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var421 ) const {
35: return p@var421 .@expr1073743864 first@var422 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var423 ) const {
42: return p@var423 .@expr1073743865 second@var424 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var425 , const T & x@var426 )
48: {
49: return std ::@expr1073743866 find (@expr1073743867 r@var425 .@expr1073743868 begin (@expr1073743869 ) , r@var425 .@expr2046 end (@expr2047 ) , x@var426 ) !=@expr1073743872 r@var425 .@expr2046 end (@expr2047 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var427 , const T & x@var428 )
54: {
55: return std ::@expr1073743875 find (@expr1073743876 r@var427 .@expr1073743877 begin (@expr1073743878 ) , r@var427 .@expr2055 end (@expr2056 ) , x@var428 ) !=@expr1073743881 r@var427 .@expr2055 end (@expr2056 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var429 , const U & x@var430 )
60: {
61: return std ::@expr1073743884 find (@expr1073743885 r@var429 .@expr1073743886 begin (@expr1073743887 ) , r@var429 .@expr2064 end (@expr2065 ) , x@var430 ) !=@expr1073743890 r@var429 .@expr2064 end (@expr2065 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var431 ) const
68: {
69: return static_cast < unsigned long > (@expr1073743893 t@var431 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var432 , char c@var433 )
74: {
75: return !@expr1073743894 str@var432 .@expr1073743895 empty (@expr1073743896 ) &&@expr1073743897 str@var432 .@expr1073743898 back (@expr1073743899 ) ==@expr1073743900 c@var433 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var434 , const char end@var435 [ ] , unsigned long endlen@var436 )
79: {
80: return (@expr2077 str@var434 .@expr2078 size (@expr2079 ) >=@expr1073743904 endlen@var436 ) &&@expr1073743905 (@expr2077 str@var434 .@expr1073743907 compare (@expr1073743908 str@var434 .@expr2078 size (@expr2079 ) -@expr1073743911 endlen@var436 , endlen@var436 , end@var435 ) ==@expr1073743912 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var437 , const char ( & end@var438 ) [ N ] )
85: {
86: return endsWith (@expr1073743914 str@var437 , end@var438 , N@expr1073743913 -@expr1073743915 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var439 , char q@var440 , const std :: string & p@var441 )
90: {
91: if (@expr1073743916 !@expr1073743917 endsWith (@expr1073743918 str@var439 , q@var440 ) ) {
92: return false ; }
93: if (@expr1073743919 (@expr1073743920 str@var439 .@expr1073743921 length (@expr1073743922 ) +@expr1073743923 1 ) >@expr1073743924 p@var441 .@expr1073743925 length (@expr1073743926 ) &&@expr1073743927 (@expr1073743928 str@var439 .@expr1073743929 compare (@expr1073743930 0 , p@var441 .@expr1073743931 size (@expr1073743932 ) +@expr1073743933 1 , p@var441 +@expr1073743934 q@var440 ) ==@expr1073743935 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var442 , char q@var443 )
99: {
100: static const std ::@expr2112 vector < std ::@expr2112 string > suffixes@var444 {@expr1073743938 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073743939 const std ::@expr2112 string &@expr1073743941 p@var445 :@expr1073743942 suffixes@var444 ) {
102: if (@expr1073743943 isPrefixStringCharLiteral (@expr1073743944 str@var442 , q@var443 , p@var445 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var446 )
109: {
110: return isStringCharLiteral (@expr1073743945 str@var446 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var447 )
114: {
115: return isStringCharLiteral (@expr1073743946 str@var447 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var448 , char q@var449 )
119: {
120: const unsigned long quotePos@var450 =@expr1073743947 str@var448 .@expr1073743948 find (@expr1073743949 q@var449 ) ;
121: return str@var448 .@expr1073743950 substr (@expr1073743951 quotePos@var450 +@expr1073743952 1U , str@var448 .@expr1073743953 size (@expr1073743954 ) -@expr1073743955 quotePos@var450 -@expr1073743956 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var451 )
125: {
126: if (@expr1073743957 isStringLiteral (@expr1073743958 str@var451 ) ) {
127: return getStringCharLiteral (@expr1073743959 str@var451 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var452 )
132: {
133: if (@expr1073743960 isCharLiteral (@expr1073743961 str@var452 ) ) {
134: return getStringCharLiteral (@expr1073743962 str@var452 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var453 )
139: {
140: if (@expr1073743963 i@var453 ==@expr1073743964 1 ) {
141: return "st" ; }
142: if (@expr1073743965 i@var453 ==@expr1073743966 2 ) {
143: return "nd" ; }
144: if (@expr1073743967 i@var453 ==@expr1073743968 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var454 , const std :: string & rhs@var455 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var456 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var457 , const std :: string & name@var458 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var459 , const std :: string & name@var460 ) ;
156:
157: void strTolower ( std :: string & str@var461 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var462 ;
57: Token * back@var463 ;
58: const TokenList * list@var464 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var465 , const Token * bodyEnd_@var466 , const std :: set < std :: string > & usingNamespaces_@var467 = std :: set < std :: string > ( ) ) : name@var468 ( name_@var465 ) , bodyEnd@var469 ( bodyEnd_@var466 ) , usingNamespaces@var470 ( usingNamespaces_@var467 ) { }
63: std :: string name@var468 ;
64: const Token * const bodyEnd@var469 ;
65: std :: set < std :: string > usingNamespaces@var470 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var471 ;
70: int mFileIndex@var472 ;
71: int mLineNumber@var473 ;
72: int mColumn@var474 ;
73: int mExprId@var475 ;
74:
75:
76: Token * mAstOperand1@var476 ;
77: Token * mAstOperand2@var477 ;
78: Token * mAstParent@var478 ;
79:
80:
81: const Scope * mScope@var479 ;
82: union {
83: const Function * mFunction@var480 ;
84: const Variable * mVariable@var481 ;
85: const :: Type * mType@var482 ;
86: const Enumerator * mEnumerator@var483 ;
87: } ;
88:
|
92:
93: int mProgressValue@var484 ;
94:
|
97:
98: int mIndex@var485 ;
99:
100:
101: std :: string * mOriginalName@var486 ;
102:
103:
104: ValueType * mValueType@var487 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var488 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var489 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var490 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var491 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var492 ;
119: long long value@var493 ;
120: struct CppcheckAttributes * next@var494 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var495 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var496 ;
126:
127:
128: unsigned char mBits@var497 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var498 , long long value@var499 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var500 , long long * value@var501 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var471 ( 0 )
135: , mFileIndex@var472 ( 0 )
136: , mLineNumber@var473 ( 0 )
137: , mColumn@var474 ( 0 )
138: , mExprId@var475 ( 0 )
139: , mAstOperand1@var476 ( nullptr )
140: , mAstOperand2@var477 ( nullptr )
141: , mAstParent@var478 ( nullptr )
142: , mScope@var479 ( nullptr )
143: , mFunction@var480 ( nullptr )
144: , mProgressValue@var484 ( 0 )
145: , mIndex@var485 ( 0 )
146: , mOriginalName@var486 ( nullptr )
147: , mValueType@var487 ( nullptr )
148: , mValues@var488 ( nullptr )
149: , mTemplateSimplifierPointers@var490 ( nullptr )
150: , mScopeInfo@var491 ( nullptr )
151: , mCppcheckAttributes@var495 ( nullptr )
152: , mCpp11init@var496 ( Cpp11init :: UNKNOWN )
153: , mBits@var497 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var502 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var503 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var504 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var505 ) {
199: mStr@var717 =@expr1073743969 s@var505 ;
200: mImpl@var723 .@expr1073743970 mVarId@var754 =@expr1073743971 0 ;
201:
202: update_property_info (@expr1073743972 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var506 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var717 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var507 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var508 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var509 ) const ;
236: Token * tokAt ( int index@var510 ) {
237: return const_cast < Token *@expr2149 > (@expr1073743974 const_cast < const Token *@expr2149 > (@expr1073743976 this@expr1073743977 ) .@expr1073743978 tokAt (@expr1073743979 index@var510 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var511 ) const ;
245: Token * linkAt ( int index@var512 ) {
246: return const_cast < Token *@expr2156 > (@expr1073743981 const_cast < const Token *@expr2156 > (@expr1073743983 this@expr1073743984 ) .@expr1073743985 linkAt (@expr1073743986 index@var512 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var513 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var514 , const char ( & pattern@var515 ) [ count ] ) {
276: return simpleMatch (@expr1073743988 tok@var514 , pattern@var515 , count@expr1073743987 -@expr1073743989 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var516 , const char pattern@var517 [ ] , unsigned long pattern_len@var518 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var519 , const char pattern@var520 [ ] , int varid@var521 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var522 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var523 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var524 , const Settings * const settings@var525 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var526 , long long index@var527 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var723 .@expr1073743990 mValueType@var755 ;
366: }
367: void setValueType ( ValueType * vt@var528 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var529 ; top@var529 =@expr1073743991 this@expr1073743992 ;
371: while (@expr1073743993 top@var529 &&@expr1073743994 !@expr1073743995 Token ::@expr1073743996 Match (@expr1073743997 top@var529 .@expr2174 astParent (@expr2175 ) , ",|(" ) ) {
372: top@var529 =@expr1073744000 top@var529 .@expr2174 astParent (@expr2175 ) ; }
373: return top@var529 ?@expr1073744003 top@var529 .@expr1073744004 mImpl@var530 .@expr1073744005 mValueType@var531 :@expr1073744006 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var721 ;
378: }
379: void tokType ( Token :: Type t@var532 ) {
380: mTokType@var721 =@expr1073744007 t@var532 ;
381:
382: const bool memoizedIsName@var533 =@expr1073744008 mTokType@var721 ==@expr1073744009 eName ||@expr1073744010 mTokType@var721 ==@expr1073744011 eType ||@expr1073744012 mTokType@var721 ==@expr1073744013 eVariable ||@expr1073744014
383: mTokType@var721 ==@expr1073744015 eFunction ||@expr1073744016 mTokType@var721 ==@expr1073744017 eKeyword ||@expr1073744018 mTokType@var721 ==@expr2195 eBoolean ||@expr1073744020
384: mTokType@var721 ==@expr2197 eEnumerator ;
385: setFlag (@expr1073744022 fIsName , memoizedIsName@var533 ) ;
386:
387: const bool memoizedIsLiteral@var534 =@expr1073744023 mTokType@var721 ==@expr1073744024 eNumber ||@expr1073744025 mTokType@var721 ==@expr1073744026 eString ||@expr1073744027 mTokType@var721 ==@expr1073744028 eChar ||@expr1073744029
388: mTokType@var721 ==@expr2195 eBoolean ||@expr1073744031 mTokType@var721 ==@expr1073744032 eLiteral ||@expr1073744033 mTokType@var721 ==@expr2197 eEnumerator ;
389: setFlag (@expr1073744035 fIsLiteral , memoizedIsLiteral@var534 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var721 ==@expr1073744036 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073744037 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var722 ==@expr1073744038 fIsName &&@expr1073744039 mTokType@var721 ==@expr1073744040 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073744041 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var721 ==@expr1073744042 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var721 ==@expr1073744043 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073744044 isConstOp (@expr1073744045 ) ||@expr1073744046
412: isAssignmentOp (@expr1073744047 ) ||@expr1073744048
413: mTokType@var721 ==@expr1073744049 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073744050 isArithmeticalOp (@expr1073744051 ) ||@expr1073744052
417: mTokType@var721 ==@expr1073744053 eLogicalOp ||@expr1073744054
418: mTokType@var721 ==@expr1073744055 eComparisonOp ||@expr1073744056
419: mTokType@var721 ==@expr1073744057 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073744058 ) ||@expr1073744059
423: mTokType@var721 ==@expr1073744060 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var721 ==@expr1073744061 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var721 ==@expr1073744062 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var721 ==@expr1073744063 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var721 ==@expr1073744064 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var721 ==@expr1073744065 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073744066 ) !=@expr1073744067 nullptr &&@expr1073744068 astOperand2 (@expr1073744069 ) !=@expr1073744070 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var535 ) const {
444: return s@var535 ==@expr1073744071 mStr@var717 &&@expr1073744072 astOperand1 (@expr1073744073 ) !=@expr1073744074 nullptr &&@expr1073744075 astOperand2 (@expr1073744076 ) ==@expr1073744077 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var722 ;
450: }
451: void flags ( const unsigned int flags_@var536 ) {
452: mFlags@var722 =@expr1073744078 flags_@var536 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073744079 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var537 ) {
458: setFlag (@expr1073744080 fIsUnsigned , sign@var537 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073744081 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var538 ) {
464: setFlag (@expr1073744082 fIsSigned , sign@var538 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073744083 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var539 ) {
470: setFlag (@expr1073744084 fIsPointerCompare , b@var539 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073744085 fIsLong ) ;
474: }
475: void isLong ( bool size@var540 ) {
476: setFlag (@expr1073744086 fIsLong , size@var540 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073744087 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var541 ) {
482: setFlag (@expr1073744088 fIsStandardType , b@var541 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073744089 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var542 ) {
488: setFlag (@expr1073744090 fIsExpandedMacro , m@var542 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073744091 fIsCast ) ;
492: }
493: void isCast ( bool c@var543 ) {
494: setFlag (@expr1073744092 fIsCast , c@var543 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073744093 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var544 ) {
500: setFlag (@expr1073744094 fIsAttributeConstructor , ac@var544 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073744095 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var545 ) {
506: setFlag (@expr1073744096 fIsAttributeDestructor , value@var545 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073744097 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var546 ) {
512: setFlag (@expr1073744098 fIsAttributeUnused , unused@var546 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073744099 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var547 ) {
518: setFlag (@expr1073744100 fIsAttributeUsed , unused@var547 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073744101 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var548 ) {
524: setFlag (@expr1073744102 fIsAttributePure , value@var548 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073744103 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var549 ) {
530: setFlag (@expr1073744104 fIsAttributeConst , value@var549 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073744105 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var550 ) {
536: setFlag (@expr1073744106 fIsAttributeNoreturn , value@var550 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073744107 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var551 ) {
542: setFlag (@expr1073744108 fIsAttributeNothrow , value@var551 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073744109 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var552 ) {
548: setFlag (@expr1073744110 fIsAttributePacked , value@var552 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073744111 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var553 ) {
554: setFlag (@expr1073744112 fIsAttributeNodiscard , value@var553 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073744113 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var554 ) {
560: setFlag (@expr1073744114 fIsAttributeMaybeUnused , value@var554 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var555 , long long value@var556 ) {
563: mImpl@var723 .@expr1073744115 setCppcheckAttribute (@expr1073744116 type@var555 , value@var556 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var557 , long long * value@var558 ) const {
566: return mImpl@var723 .@expr1073744117 getCppcheckAttribute (@expr1073744118 type@var557 , value@var558 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073744119 mImpl@var723 .@expr1073744120 mCppcheckAttributes@var756 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073744121 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073744122 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var559 ) {
578: setFlag (@expr1073744123 fIsOperatorKeyword , value@var559 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073744124 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var560 ) {
584: setFlag (@expr1073744125 fIsComplex , value@var560 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073744126 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var561 ) {
590: setFlag (@expr1073744127 fIsEnumType , value@var561 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073744128 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var562 ) {
596: setFlag (@expr1073744129 fAtAddress , b@var562 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073744130 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var563 ) {
602: setFlag (@expr1073744131 fIncompleteVar , b@var563 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073744132 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var564 ) {
609: setFlag (@expr1073744133 fIsIncompleteConstant , b@var564 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073744134 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var565 ) {
616: setFlag (@expr1073744135 fConstexpr , b@var565 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073744136 fExternC ) ;
621: }
622: void isExternC ( bool b@var566 ) {
623: setFlag (@expr1073744137 fExternC , b@var566 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073744138 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var567 ) {
630: setFlag (@expr1073744139 fIsSplitVarDeclComma , b@var567 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073744140 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var568 ) {
637: setFlag (@expr1073744141 fIsSplitVarDeclEq , b@var568 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073744142 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var569 ) {
644: setFlag (@expr1073744143 fIsImplicitInt , b@var569 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073744144 fIsInline ) ;
649: }
650: void isInline ( bool b@var570 ) {
651: setFlag (@expr1073744145 fIsInline , b@var570 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073744146 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var571 ) {
658: setFlag (@expr1073744147 fIsRemovedVoidParameter , b@var571 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073744148 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var572 ) {
665: setFlag (@expr1073744149 fIsTemplate , b@var572 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073744150 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var573 ) {
672: setFlag (@expr1073744151 fIsSimplifedScope , b@var573 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var723 .@expr1073744152 mBits@var757 >@expr1073744153 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var723 .@expr1073744154 mBits@var757 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var723 .@expr1073744155 mTemplateSimplifierPointers@var758 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var574 ) {
685: if (@expr1073744156 !@expr1073744157 mImpl@var723 .@expr2334 mTemplateSimplifierPointers@var758 ) {
686: mImpl@var723 .@expr2334 mTemplateSimplifierPointers@var758 =@expr1073744160 new std ::@expr1073744161 set < TemplateSimplifier ::@expr1073744162 TokenAndName *@expr1073744163 > ; }
687: mImpl@var723 .@expr2334 mTemplateSimplifierPointers@var758 .@expr1073744165 insert (@expr1073744166 tokenAndName@var574 ) ;
688: }
689: void setBits ( const unsigned char b@var575 ) {
690: mImpl@var723 .@expr1073744167 mBits@var757 =@expr1073744168 b@var575 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr2345 (@expr2345 (@expr2345 mTokType@var721 ==@expr1073744172 eString ) &&@expr1073744173 isPrefixStringCharLiteral (@expr1073744174 mStr@var717 , '"' , "u8" ) ) ||@expr1073744175
695: (@expr2345 (@expr2345 mTokType@var721 ==@expr1073744178 eChar ) &&@expr1073744179 isPrefixStringCharLiteral (@expr1073744180 mStr@var717 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr2357 (@expr2357 (@expr2357 mTokType@var721 ==@expr1073744184 eString ) &&@expr1073744185 isPrefixStringCharLiteral (@expr1073744186 mStr@var717 , '"' , "u" ) ) ||@expr1073744187
700: (@expr2357 (@expr2357 mTokType@var721 ==@expr1073744190 eChar ) &&@expr1073744191 isPrefixStringCharLiteral (@expr1073744192 mStr@var717 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr2369 (@expr2369 (@expr2369 mTokType@var721 ==@expr1073744196 eString ) &&@expr1073744197 isPrefixStringCharLiteral (@expr1073744198 mStr@var717 , '"' , "U" ) ) ||@expr1073744199
705: (@expr2369 (@expr2369 mTokType@var721 ==@expr1073744202 eChar ) &&@expr1073744203 isPrefixStringCharLiteral (@expr1073744204 mStr@var717 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr2381 (@expr2381 (@expr2381 mTokType@var721 ==@expr1073744208 eString ) &&@expr1073744209 isPrefixStringCharLiteral (@expr1073744210 mStr@var717 , '"' , "" ) ) ||@expr1073744211
710: (@expr2381 (@expr2381 mTokType@var721 ==@expr1073744214 eChar ) &&@expr1073744215 isPrefixStringCharLiteral (@expr1073744216 mStr@var717 , '\'' , "" ) &&@expr1073744217 mStr@var717 .@expr1073744218 length (@expr1073744219 ) ==@expr1073744220 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr2397 (@expr2397 (@expr2397 mTokType@var721 ==@expr1073744224 eChar ) &&@expr1073744225 isPrefixStringCharLiteral (@expr1073744226 mStr@var717 , '\'' , "" ) ) &&@expr1073744227
715: (@expr2397 mStr@var717 .@expr1073744229 length (@expr1073744230 ) >@expr1073744231 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073744232 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var576 ) {
738: setFlag (@expr1073744233 fIsTemplateArg , value@var576 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var577 , const char ( & pattern@var578 ) [ count ] ) {
743: return findsimplematch (@expr1073744235 startTok@var577 , pattern@var578 , count@expr1073744234 -@expr1073744236 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var579 , const char pattern@var580 [ ] , unsigned long pattern_len@var581 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var582 , const char ( & pattern@var583 ) [ count ] , const Token * const end@var584 ) {
749: return findsimplematch (@expr1073744238 startTok@var582 , pattern@var583 , count@expr1073744237 -@expr1073744239 1 , end@var584 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var585 , const char pattern@var586 [ ] , unsigned long pattern_len@var587 , const Token * const end@var588 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var589 , const char pattern@var590 [ ] , const int varId@var591 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var592 , const char pattern@var593 [ ] , const Token * const end@var594 , const int varId@var595 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var596 , const char ( & pattern@var597 ) [ count ] ) {
758: return findsimplematch (@expr1073744241 startTok@var596 , pattern@var597 , count@expr1073744240 -@expr1073744242 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var598 , const char pattern@var599 [ ] , unsigned long pattern_len@var600 ) {
761: return const_cast < Token *@expr2419 > (@expr1073744244 findsimplematch (@expr1073744245 const_cast < const Token *@expr2419 > (@expr1073744247 startTok@var598 ) , pattern@var599 , pattern_len@var600 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var601 , const char ( & pattern@var602 ) [ count ] , const Token * const end@var603 ) {
765: return findsimplematch (@expr1073744249 startTok@var601 , pattern@var602 , count@expr1073744248 -@expr1073744250 1 , end@var603 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var604 , const char pattern@var605 [ ] , unsigned long pattern_len@var606 , const Token * const end@var607 ) {
768: return const_cast < Token *@expr2427 > (@expr1073744252 findsimplematch (@expr1073744253 const_cast < const Token *@expr2427 > (@expr1073744255 startTok@var604 ) , pattern@var605 , pattern_len@var606 , end@var607 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var608 , const char pattern@var609 [ ] , const int varId@var610 = 0 ) {
772: return const_cast < Token *@expr2432 > (@expr1073744257 findmatch (@expr1073744258 const_cast < const Token *@expr2432 > (@expr1073744260 startTok@var608 ) , pattern@var609 , varId@var610 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var611 , const char pattern@var612 [ ] , const Token * const end@var613 , const int varId@var614 = 0 ) {
775: return const_cast < Token *@expr2437 > (@expr1073744262 findmatch (@expr1073744263 const_cast < const Token *@expr2437 > (@expr1073744265 startTok@var611 ) , pattern@var612 , end@var613 , varId@var614 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var615 , const char * haystack@var616 , int varid@var617 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var723 .@expr1073744266 mFileIndex@var759 ;
796: }
797: void fileIndex ( int indexOfFile@var618 ) {
798: mImpl@var723 .@expr1073744267 mFileIndex@var759 =@expr1073744268 indexOfFile@var618 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var723 .@expr1073744269 mLineNumber@var760 ;
803: }
804: void linenr ( int lineNumber@var619 ) {
805: mImpl@var723 .@expr1073744270 mLineNumber@var760 =@expr1073744271 lineNumber@var619 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var723 .@expr1073744272 mColumn@var761 ;
810: }
811: void column ( int c@var620 ) {
812: mImpl@var723 .@expr1073744273 mColumn@var761 =@expr1073744274 c@var620 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var718 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var621 , const Token * end@var622 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var623 , const std :: string & originalNameStr@var624 = emptyString@var1 , bool prepend@var625 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var626 , const std :: string & originalNameStr@var627 = emptyString@var1 )
840: {
841: return insertToken (@expr1073744275 tokenStr@var626 , originalNameStr@var627 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var719 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var723 .@expr1073744276 mVarId@var754 ;
851: }
852: void varId ( int id@var628 ) {
853: mImpl@var723 .@expr1073744277 mVarId@var754 =@expr1073744278 id@var628 ;
854: if (@expr1073744279 id@var628 !=@expr1073744280 0 ) {
855: tokType (@expr1073744281 eVariable ) ;
856: isStandardType (@expr1073744282 false ) ;
857: } else {
858: update_property_info (@expr1073744283 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073744284 mImpl@var723 .@expr2461 mExprId@var762 ) {
864: return mImpl@var723 .@expr2461 mExprId@var762 ; }
865: return mImpl@var723 .@expr1073744287 mVarId@var754 ;
866: }
867: void exprId ( int id@var629 ) {
868: mImpl@var723 .@expr1073744288 mExprId@var762 =@expr1073744289 id@var629 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var630 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var631 , const std :: vector < std :: string > & fileNames@var632 ) const ;
888:
|
891:
892: void printLines ( int lines@var633 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var634 , Token * start@var635 , Token * end@var636 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var637 ; varid@var637 = false ;
905: bool exprid@var638 ; exprid@var638 = false ;
906: bool idtype@var639 ; idtype@var639 = false ;
907: bool attributes@var640 ; attributes@var640 = false ;
908: bool macro@var641 ; macro@var641 = false ;
909: bool linenumbers@var642 ; linenumbers@var642 = false ;
910: bool linebreaks@var643 ; linebreaks@var643 = false ;
911: bool files@var644 ; files@var644 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var645 ;
914: options@var645 .@expr1073744290 attributes@var646 =@expr1073744291 true ;
915: options@var645 .@expr1073744292 macro@var647 =@expr1073744293 true ;
916: options@var645 .@expr1073744294 linenumbers@var648 =@expr1073744295 true ;
917: options@var645 .@expr1073744296 linebreaks@var649 =@expr1073744297 true ;
918: options@var645 .@expr1073744298 files@var650 =@expr1073744299 true ;
919: return options@var645 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var651 ; options@var651 =@expr1073744300 forDebug (@expr1073744301 ) ;
923: options@var651 .@expr1073744302 varid@var652 =@expr1073744303 true ;
924: return options@var651 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var653 ; options@var653 =@expr1073744304 forDebug (@expr1073744305 ) ;
928: options@var653 .@expr1073744306 exprid@var654 =@expr1073744307 true ;
929: return options@var653 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var655 ; options@var655 =@expr1073744308 forDebug (@expr1073744309 ) ;
933: options@var655 .@expr1073744310 exprid@var656 =@expr1073744311 true ;
934: options@var655 .@expr1073744312 varid@var657 =@expr1073744313 true ;
935: options@var655 .@expr1073744314 idtype@var658 =@expr1073744315 true ;
936: return options@var655 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var659 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var660 , bool attributes@var661 , bool macro@var662 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var663 , const std :: vector < std :: string > * fileNames@var664 = nullptr , const Token * end@var665 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var666 , bool attributes@var667 = true ) const ;
952: std :: string stringifyList ( bool varid@var668 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var669 , bool attributes@var670 , bool linenumbers@var671 , bool linebreaks@var672 , bool files@var673 , const std :: vector < std :: string > * fileNames@var674 = nullptr , const Token * end@var675 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var676 ) {
983: mLink@var720 =@expr1073744316 linkToToken@var676 ;
984: if (@expr1073744317 mStr@var717 ==@expr1073744318 "<" ||@expr1073744319 mStr@var717 ==@expr1073744320 ">" ) {
985: update_property_info (@expr1073744321 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var720 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var677 ) {
1006: mImpl@var723 .@expr1073744322 mScope@var763 =@expr1073744323 s@var677 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var723 .@expr1073744324 mScope@var763 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var678 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var721 ==@expr1073744325 eFunction ||@expr1073744326 mTokType@var721 ==@expr1073744327 eLambda ?@expr1073744328 mImpl@var723 .@expr1073744329 mFunction@var764 :@expr1073744330 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var679 ) {
1034: mImpl@var723 .@expr1073744331 mVariable@var765 =@expr1073744332 v@var679 ;
1035: if (@expr1073744333 v@var679 ||@expr1073744334 mImpl@var723 .@expr1073744335 mVarId@var754 ) {
1036: tokType (@expr1073744336 eVariable ) ; }
1037: else { if (@expr1073744337 mTokType@var721 ==@expr1073744338 eVariable ) {
1038: tokType (@expr1073744339 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var721 ==@expr1073744340 eVariable ?@expr1073744341 mImpl@var723 .@expr1073744342 mVariable@var765 :@expr1073744343 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var680 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var721 ==@expr1073744344 eType ?@expr1073744345 mImpl@var723 .@expr1073744346 mType@var766 :@expr1073744347 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var681 , const Token * * typeTok@var682 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var683 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var684 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var721 ==@expr1073744348 eEnumerator ?@expr1073744349 mImpl@var723 .@expr1073744350 mEnumerator@var767 :@expr1073744351 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var685 ) {
1079: mImpl@var723 .@expr1073744352 mEnumerator@var767 =@expr1073744353 e@var685 ;
1080: if (@expr1073744354 e@var685 ) {
1081: tokType (@expr1073744355 eEnumerator ) ; }
1082: else { if (@expr1073744356 mTokType@var721 ==@expr1073744357 eEnumerator ) {
1083: tokType (@expr1073744358 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var686 , Token * end@var687 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var688 , Token * srcEnd@var689 , Token * newLocation@var690 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var723 .@expr1073744359 mProgressValue@var768 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var691 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var723 .@expr2536 mOriginalName@var769 ?@expr1073744361 *@expr1073744362 mImpl@var723 .@expr2536 mOriginalName@var769 :@expr1073744364 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var723 .@expr2541 mValues@var742 ?@expr1073744366 *@expr1073744367 mImpl@var723 .@expr2541 mValues@var742 :@expr1073744369 TokenImpl ::@expr1073744370 mEmptyValueList@var489 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var692 ) {
1164: if (@expr1073744371 !@expr1073744372 mImpl@var723 .@expr2549 mOriginalName@var769 ) {
1165: mImpl@var723 .@expr2549 mOriginalName@var769 =@expr1073744375 new std ::@expr1073744376 string (@expr1073744377 name@var692 ) ; }
1166: else {
1167: *@expr1073744378 mImpl@var723 .@expr2549 mOriginalName@var769 =@expr1073744380 name@var692 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var693 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var694 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var695 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var723 .@expr1073744382 mValues@var742 .@expr1073744383 front (@expr1073744384 ) .@expr1073744385 intvalue@expr1073744381 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var696 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var697 , long long path@var698 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var699 , const Settings * settings@var700 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var701 , const Settings * settings@var702 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var703 , int argnr@var704 , const Settings * settings@var705 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var706 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var707 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var708 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var709 ) {
1200: if (@expr1073744386 mImpl@var723 .@expr2563 mValues@var742 ) {
1201: mImpl@var723 .@expr2563 mValues@var742 .@expr1073744389 remove_if (@expr1073744390 pred@var709 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var723 .@expr1073744391 mIndex@var770 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var710 ) {
1213: mNext@var718 =@expr1073744392 nextToken@var710 ;
1214: }
1215: void previous ( Token * previousToken@var711 ) {
1216: mPrevious@var719 =@expr1073744393 previousToken@var711 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var712 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var713 , const char * word@var714 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var715 , char c@var716 ) ;
1235:
1236: std :: string mStr@var717 ;
1237:
1238: Token * mNext@var718 ;
1239: Token * mPrevious@var719 ;
1240: Token * mLink@var720 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var721 ;
1283:
1284: uint64_t mFlags@var722 ;
1285:
1286: TokenImpl * mImpl@var723 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var724 ) const {
1294: return (@expr2570 (@expr2570 mFlags@var722 &@expr1073744396 flag_@var724 ) !=@expr1073744397 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var725 , bool state_@var726 ) {
1303: mFlags@var722 =@expr1073744398 state_@var726 ?@expr1073744399 mFlags@var722 |@expr1073744400 flag_@var725 :@expr1073744401 mFlags@var722 &@expr1073744402 ~@expr1073744403 flag_@var725 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var727 , const int indent1@var728 = 0 , const int indent2@var729 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var730 ) ;
1321: void astOperand2 ( Token * tok@var731 ) ;
1322: void astParent ( Token * tok@var732 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var723 .@expr1073744404 mAstOperand1@var733 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var723 .@expr1073744405 mAstOperand1@var733 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var723 .@expr1073744406 mAstOperand2@var734 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var723 .@expr1073744407 mAstOperand2@var734 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var723 .@expr1073744408 mAstParent@var735 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var723 .@expr1073744409 mAstParent@var735 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073744410 !@expr1073744411 astParent (@expr2588 ) ) {
1344: return nullptr ; }
1345: if (@expr1073744413 this@expr2590 ==@expr1073744415 astParent (@expr2588 ) .@expr2593 astOperand1 (@expr2594 ) ) {
1346: return astParent (@expr2588 ) .@expr2596 astOperand2 (@expr2597 ) ; }
1347: else { if (@expr1073744422 this@expr2590 ==@expr1073744423 astParent (@expr2588 ) .@expr2596 astOperand2 (@expr2597 ) ) {
1348: return astParent (@expr2588 ) .@expr2593 astOperand1 (@expr2594 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073744430 !@expr1073744431 astParent (@expr2608 ) ) {
1354: return nullptr ; }
1355: if (@expr1073744433 this@expr2610 ==@expr1073744435 astParent (@expr2608 ) .@expr2613 astOperand1 (@expr2614 ) ) {
1356: return astParent (@expr2608 ) .@expr2616 astOperand2 (@expr2617 ) ; }
1357: else { if (@expr1073744442 this@expr2610 ==@expr1073744443 astParent (@expr2608 ) .@expr2616 astOperand2 (@expr2617 ) ) {
1358: return astParent (@expr2608 ) .@expr2613 astOperand1 (@expr2614 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var736 ; ret@var736 =@expr1073744450 this@expr1073744451 ;
1364: while (@expr1073744452 ret@var736 .@expr2629 mImpl@var737 .@expr2630 mAstParent@var738 ) {
1365: ret@var736 =@expr1073744455 ret@var736 .@expr2629 mImpl@var737 .@expr2630 mAstParent@var738 ; }
1366: return ret@var736 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var739 ; ret@var739 =@expr1073744458 this@expr1073744459 ;
1371: while (@expr1073744460 ret@var739 .@expr2637 mImpl@var740 .@expr2638 mAstParent@var741 ) {
1372: ret@var739 =@expr1073744463 ret@var739 .@expr2637 mImpl@var740 .@expr2638 mAstParent@var741 ; }
1373: return ret@var739 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var723 .@expr1073744466 mAstOperand1@var733 =@expr1073744467 mImpl@var723 .@expr1073744468 mAstOperand2@var734 =@expr1073744469 mImpl@var723 .@expr1073744470 mAstParent@var735 =@expr1073744471 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var723 .@expr2648 mValues@var742 ;
1393: mImpl@var723 .@expr2648 mValues@var742 =@expr1073744474 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var743 = "" ) const {
1397: std ::@expr1073744475 string ret@var744 ;
1398: if (@expr1073744476 mImpl@var723 .@expr2653 mAstOperand1@var733 ) {
1399: ret@var744 =@expr1073744478 mImpl@var723 .@expr2653 mAstOperand1@var733 .@expr1073744480 astString (@expr1073744481 sep@var743 ) ; }
1400: if (@expr1073744482 mImpl@var723 .@expr2659 mAstOperand2@var734 ) {
1401: ret@var744 +=@expr1073744484 mImpl@var723 .@expr2659 mAstOperand2@var734 .@expr1073744486 astString (@expr1073744487 sep@var743 ) ; }
1402: return ret@var744 +@expr1073744488 sep@var743 +@expr1073744489 mStr@var717 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var745 , bool xml@var746 , const std :: vector < std :: string > & fileNames@var747 , std :: ostream & out@var748 ) const ;
1412:
1413: void printValueFlow ( bool xml@var749 , std :: ostream & out@var750 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var751 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var752 ) const {
1419: mImpl@var723 .@expr1073744490 mCpp11init@var753 =@expr1073744491 cpp11init@var752 ?@expr1073744492 TokenImpl ::@expr2669 Cpp11init ::@expr1073744494 CPP11INIT :@expr1073744495 TokenImpl ::@expr2669 Cpp11init ::@expr1073744497 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var723 .@expr1073744498 mCpp11init@var753 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var771 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var772 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var773 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var774 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var775 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var776 ) {
47: mSettings@var811 =@expr1073744499 settings@var776 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var811 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var813 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var814 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var777 ) ;
72:
73: void addtoken ( const std :: string & str@var778 , const int lineno@var779 , const int column@var780 , const int fileno@var781 , bool split@var782 = false ) ;
74: void addtoken ( const std :: string & str@var783 , const Token * locationTok@var784 ) ;
75:
76: void addtoken ( const Token * tok@var785 , const int lineno@var786 , const int column@var787 , const int fileno@var788 ) ;
77: void addtoken ( const Token * tok@var789 , const Token * locationTok@var790 ) ;
78: void addtoken ( const Token * tok@var791 ) ;
79:
80: static void insertTokens ( Token * dest@var792 , const Token * src@var793 , int n@var794 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var795 , const Token * first@var796 , const Token * last@var797 , bool one_line@var798 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var799 , const std :: string & file0@var800 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var801 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var802 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var808 .@expr1073744500 front@var815 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var808 .@expr1073744501 front@var815 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var808 .@expr1073744502 back@var816 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var808 .@expr1073744503 back@var816 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var809 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var803 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var804 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var805 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var806 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var807 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var808 ;
206:
207:
208: std :: vector < std :: string > mFiles@var809 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var810 ;
212:
213:
214: const Settings * mSettings@var811 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var812 ;
217:
218:
219: bool mIsC@var813 ;
220: bool mIsCpp@var814 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var817 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var818 ;
67: mutable int mVarId@var819 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var820 ) ;
73: bool hasVariable ( const std :: string & varname@var821 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var822 ) const {
75: return mVariableId@var817 .@expr1073744504 find (@expr1073744505 varname@var822 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var817 .@expr1073744506 end (@expr1073744507 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var817 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073744508 mVarId@var819 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var823 , ErrorLogger * errorLogger@var824 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var825 ) {
95: mTimerResults@var945 =@expr1073744509 tr@var825 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var923 .@expr1073744510 isC (@expr1073744511 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var923 .@expr1073744512 isCPP (@expr1073744513 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var826 , bool * unknown@var827 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var828 , const std :: string & FileName@var829 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var830 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var831 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var832 ,
142: const char FileName@var833 [ ] ,
143: const std :: string & configuration@var834 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var835 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var836 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var837 , const Token * end@var838 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var839 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var840 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var841 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var842 , const Token * const tokEnd@var843 , const bool only_k_r_fpar@var844 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var845 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var846 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var847 , bool commandWithCondition@var848 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var849 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var850 , Token * * _tok2@var851 , Token * * _tok3@var852 , std :: string & value@var853 , int & valueVarId@var854 , bool & valueIsPointer@var855 , bool floatvar@var856 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var857 , Token * tok3@var858 , int varid@var859 , const std :: string & structname@var860 , std :: string & value@var861 , int valueVarId@var862 , bool valueIsPointer@var863 , const Token * const valueToken@var864 , int indentlevel@var865 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var866 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var867 , const std :: string & endsWith@var868 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var869 , const std :: string & endsWith@var870 , bool cpp@var871 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var872 ) {
585: mPreprocessor@var946 =@expr1073744514 preprocessor@var872 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var946 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var873 , const Token * end@var874 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var875 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var876 , const std :: string & code@var877 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var878 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var879 , const std :: string & what@var880 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var881 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var882 , const std :: string & msg@var883 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var884 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var885 , const std :: string & macroName@var886 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var887 , const Token * end@var888 , bool allowSemicolon@var889 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var890 , const Severity :: SeverityType severity@var891 , const std :: string & id@var892 , const std :: string & msg@var893 , bool inconclusive@var894 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var895 , Severity :: SeverityType severity@var896 , const std :: string & id@var897 , const std :: string & msg@var898 , bool inconclusive@var899 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var900 , const Token * name@var901 , const Token * typeDef@var902 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var903 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var904 ,
821: const VariableMap & variableMap@var905 ,
822: const int scopeStartVarId@var906 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var907 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var908 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var909 ,
827: int * varId@var910 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var911 ,
830: Token * const startToken@var912 ,
831: const Token * const endToken@var913 ,
832: const std :: map < std :: string , int > & varlist@var914 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var915 ,
834: int * varId_@var916 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var917 ) ;
849:
850: bool operatorEnd ( const Token * tok@var918 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var944 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var919 ) {
861: mSettings@var930 =@expr1073744515 settings@var919 ;
862: list@var923 .@expr1073744516 setSettings (@expr1073744517 settings@var919 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var932 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var920 ) const ;
877:
878: void dump ( std :: ostream & out@var921 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var922 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var942 ;
888: }
889:
|
892:
893: TokenList list@var923 ;
894:
895: const Token * tokens ( ) const {
896: return list@var923 .@expr1073744518 front (@expr1073744519 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var924 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var925 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var926 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var927 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var930 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var928 , bool inOperator@var929 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073744520 mVarId@var942 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var930 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var931 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var932 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var933 ;
973:
974:
975:
976: std :: string mConfiguration@var934 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var935 ;
980:
981: struct TypedefInfo {
982: std :: string name@var936 ;
983: std :: string filename@var937 ;
984: int lineNumber@var938 ;
985: int column@var939 ;
986: bool used@var940 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var941 ;
989:
990:
991: int mVarId@var942 ;
992:
993:
994: int mUnnamedCount@var943 ;
995:
|
999:
1000: bool mCodeWithTemplates@var944 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var945 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var946 ;
1013: } ;

##file cppcheck-2.8/lib/checkboost.h

1:
|
30:
31: class ErrorLogger ;
32: class Settings ;
33: class Token ;
34:
|
39:
40: class CheckBoost : public Check {
41: public:
42:
43: CheckBoost ( ) : Check ( myName ( ) ) { }
44:
45:
46: CheckBoost ( const Tokenizer * tokenizer@var947 , const Settings * settings@var948 , ErrorLogger * errorLogger@var949 )
47: : Check ( myName ( ) , tokenizer@var947 , settings@var948 , errorLogger@var949 ) { }
48:
49:
50: void runChecks ( const Tokenizer * tokenizer@var950 , const Settings * settings@var951 , ErrorLogger * errorLogger@var952 ) override {
51: if (@expr1073744521 !@expr1073744522 tokenizer@var950 .@expr1073744523 isCPP (@expr1073744524 ) ) {
52: return ; }
53:
54: CheckBoost checkBoost@var953 (@expr1073744525 tokenizer@var950 , settings@var951 , errorLogger@var952 ) ;
55: checkBoost@var953 .@expr1073744526 checkBoostForeachModification (@expr1073744527 ) ;
56: }
57:
58:
59: void checkBoostForeachModification ( ) ;
60:
61: private:
62: void boostForeachError ( const Token * tok@var954 ) ;
63:
64: void getErrorMessages ( ErrorLogger * errorLogger@var955 , const Settings * settings@var956 ) const override {
65: CheckBoost c@var957 (@expr1073744528 nullptr , settings@var956 , errorLogger@var955 ) ;
66: c@var957 .@expr1073744529 boostForeachError (@expr1073744530 nullptr ) ;
67: }
68:
69: static std :: string myName ( ) {
70: return "Boost usage" ;
71: }
72:
73: std :: string classInfo ( ) const override {
74: return "Check for invalid usage of Boost:\n- container modification during BOOST_FOREACH\n"
75: ;
76: }
77: } ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var958 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var959 ;
42:
43:
44: std :: string stdValue@var960 ;
45:
46:
47: Standards ( ) : c@var958 ( CLatest ) , cpp@var959 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var961 ) {
50: stdValue@var960 =@expr1073744531 str@var961 ;
51: if (@expr1073744532 str@var961 ==@expr1073744533 "c89" ||@expr1073744534 str@var961 ==@expr1073744535 "C89" ) {
52: c@var958 =@expr1073744536 C89 ;
53: return true ;
54: }
55: if (@expr1073744537 str@var961 ==@expr1073744538 "c99" ||@expr1073744539 str@var961 ==@expr1073744540 "C99" ) {
56: c@var958 =@expr1073744541 C99 ;
57: return true ;
58: }
59: if (@expr1073744542 str@var961 ==@expr1073744543 "c11" ||@expr1073744544 str@var961 ==@expr1073744545 "C11" ) {
60: c@var958 =@expr1073744546 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744547 c@var958 ) {
67: case C89 :@expr2724 ;
68: return "c89" ;
69: case C99 :@expr2724 ;
70: return "c99" ;
71: case C11 :@expr2724 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var962 ) {
77: if (@expr1073744551 std@var962 ==@expr1073744552 "c89" ) {
78: return Standards ::@expr1073744553 C89 ;
79: }
80: if (@expr1073744554 std@var962 ==@expr1073744555 "c99" ) {
81: return Standards ::@expr1073744556 C99 ;
82: }
83: if (@expr1073744557 std@var962 ==@expr1073744558 "c11" ) {
84: return Standards ::@expr1073744559 C11 ;
85: }
86: return Standards ::@expr1073744560 CLatest ;
87: }
88: bool setCPP ( std :: string str@var963 ) {
89: stdValue@var960 =@expr1073744561 str@var963 ;
90: strTolower (@expr1073744562 str@var963 ) ;
91: cpp@var959 =@expr1073744563 getCPP (@expr1073744564 str@var963 ) ;
92: return !@expr1073744565 stdValue@var960 .@expr1073744566 empty (@expr1073744567 ) &&@expr1073744568 str@var963 ==@expr1073744569 getCPP (@expr1073744570 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744571 cpp@var959 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var964 ) {
98: switch (@expr1073744572 std@var964 ) {
99: case CPP03 :@expr2749 ;
100: return "c++03" ;
101: case CPP11 :@expr2749 ;
102: return "c++11" ;
103: case CPP14 :@expr2749 ;
104: return "c++14" ;
105: case CPP17 :@expr2749 ;
106: return "c++17" ;
107: case CPP20 :@expr2749 ;
108: return "c++20" ;
109: case CPP23 :@expr2749 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var965 ) {
115: if (@expr1073744579 std@var965 ==@expr1073744580 "c++03" ) {
116: return Standards ::@expr1073744581 CPP03 ;
117: }
118: if (@expr1073744582 std@var965 ==@expr1073744583 "c++11" ) {
119: return Standards ::@expr1073744584 CPP11 ;
120: }
121: if (@expr1073744585 std@var965 ==@expr1073744586 "c++14" ) {
122: return Standards ::@expr1073744587 CPP14 ;
123: }
124: if (@expr1073744588 std@var965 ==@expr1073744589 "c++17" ) {
125: return Standards ::@expr1073744590 CPP17 ;
126: }
127: if (@expr1073744591 std@var965 ==@expr1073744592 "c++20" ) {
128: return Standards ::@expr1073744593 CPP20 ;
129: }
130: if (@expr1073744594 std@var965 ==@expr1073744595 "c++23" ) {
131: return Standards ::@expr1073744596 CPP23 ;
132: }
133: return Standards ::@expr1073744597 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var969 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var966 ) : errorcode@var969 ( e@var966 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var967 , T && r@var968 ) : errorcode@var969 ( e@var967 ) , reason@var970 ( r@var968 ) { }
66: ErrorCode errorcode@var969 ;
67: std :: string reason@var970 ;
68: } ;
69:
70: Error load ( const char exename@var971 [ ] , const char path@var972 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var973 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var974 [ ] , unsigned long len@var975 ) ;
75:
76: struct AllocFunc {
77: int groupId@var976 ;
78: int arg@var977 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var978 ;
81: int bufferSizeArg1@var979 ;
82: int bufferSizeArg2@var980 ;
83: int reallocArg@var981 ;
84: bool initData@var982 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var983 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var984 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var985 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var986 , int arg@var987 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var988 , int arg@var989 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var990 , int arg@var991 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var992 [ ] ) const {
107: return getAllocDealloc (@expr1073744598 mAlloc@var1258 , name@var992 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var993 [ ] ) const {
112: return getAllocDealloc (@expr1073744599 mDealloc@var1259 , name@var993 ) ;
113: }
114:
115:
116: int allocId ( const char name@var994 [ ] ) const {
117: const AllocFunc * af@var995 ; af@var995 =@expr1073744600 getAllocDealloc (@expr1073744601 mAlloc@var1258 , name@var994 ) ;
118: return af@var995 ?@expr1073744602 af@var995 .@expr1073744603 groupId@var996 :@expr1073744604 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var997 [ ] ) const {
123: const AllocFunc * af@var998 ; af@var998 =@expr1073744605 getAllocDealloc (@expr1073744606 mDealloc@var1259 , name@var997 ) ;
124: return af@var998 ?@expr1073744607 af@var998 .@expr1073744608 groupId@var999 :@expr1073744609 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var1000 , int id@var1001 , int arg@var1002 ) {
129: mAlloc@var1258 [@expr2786 functionname@var1000 ] .@expr1073744611 groupId@var1658 =@expr1073744612 id@var1001 ;
130: mAlloc@var1258 [@expr2786 functionname@var1000 ] .@expr1073744614 arg@var1659 =@expr1073744615 arg@var1002 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var1003 , int id@var1004 , int arg@var1005 ) {
134: mDealloc@var1259 [@expr2792 functionname@var1003 ] .@expr1073744617 groupId@var1660 =@expr1073744618 id@var1004 ;
135: mDealloc@var1259 [@expr2792 functionname@var1003 ] .@expr1073744620 arg@var1661 =@expr1073744621 arg@var1005 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var1006 , int id@var1007 , int arg@var1008 , int reallocArg@var1009 = 1 ) {
139: mRealloc@var1260 [@expr2798 functionname@var1006 ] .@expr1073744623 groupId@var1662 =@expr1073744624 id@var1007 ;
140: mRealloc@var1260 [@expr2798 functionname@var1006 ] .@expr1073744626 arg@var1663 =@expr1073744627 arg@var1008 ;
141: mRealloc@var1260 [@expr2798 functionname@var1006 ] .@expr1073744629 reallocArg@var1664 =@expr1073744630 reallocArg@var1009 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var1010 , bool noreturn@var1011 ) {
146: mNoReturn@var1261 [@expr1073744631 funcname@var1010 ] =@expr1073744632 noreturn@var1011 ?@expr1073744633 FalseTrueMaybe ::@expr1073744634 True :@expr1073744635 FalseTrueMaybe ::@expr1073744636 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var1012 ) ;
150:
151:
152: static bool ismemory ( const int id@var1013 ) {
153: return (@expr2813 (@expr2813 id@var1013 >@expr1073744639 0 ) &&@expr1073744640 (@expr2813 (@expr2813 id@var1013 &@expr1073744643 1 ) ==@expr1073744644 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var1014 ) {
156: return (@expr2821 (@expr2821 func@var1014 .@expr2823 groupId@var1015 >@expr1073744648 0 ) &&@expr1073744649 (@expr2821 (@expr2821 func@var1014 .@expr2823 groupId@var1015 &@expr1073744653 1 ) ==@expr1073744654 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var1016 ) {
161: return (@expr2831 (@expr2831 id@var1016 >@expr1073744657 0 ) &&@expr1073744658 (@expr2831 (@expr2831 id@var1016 &@expr1073744661 1 ) ==@expr1073744662 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var1017 ) {
164: return (@expr2839 (@expr2839 func@var1017 .@expr2841 groupId@var1018 >@expr1073744666 0 ) &&@expr1073744667 (@expr2839 (@expr2839 func@var1017 .@expr2841 groupId@var1018 &@expr1073744671 1 ) ==@expr1073744672 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var1019 ) const ;
168: int formatstr_argno ( const Token * ftok@var1020 ) const ;
169: bool formatstr_scan ( const Token * ftok@var1021 ) const ;
170: bool formatstr_secure ( const Token * ftok@var1022 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var1023 ;
174: int ptr2Arg@var1024 ;
175: int sizeArg@var1025 ;
176: int strlenArg@var1026 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var1027 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var1028 ;
182: Standards standards@var1029 ;
183: Severity :: SeverityType severity@var1030 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var1031 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var1032 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var1033 ) const ;
191: bool matchArguments ( const Token * ftok@var1034 , const std :: string & functionName@var1035 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var1036 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var1037 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var1038 ) const ;
198: int returnValueContainer ( const Token * ftok@var1039 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var1040 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var1041 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var1042 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var1043 , std :: string * unknownFunc@var1044 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var1054 ( -1 ) ,
210: size_templateArgNo@var1056 ( -1 ) ,
211: arrayLike_indexOp@var1057 ( false ) ,
212: stdStringLike@var1058 ( false ) ,
213: stdAssociativeLike@var1059 ( false ) ,
214: opLessAllowed@var1060 ( true ) ,
215: hasInitializerListConstructor@var1061 ( false ) ,
216: unstableErase@var1062 ( false ) ,
217: unstableInsert@var1063 ( false ) ,
218: view@var1064 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var1045 ;
248: Yield yield@var1046 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var1047 ;
252: int templateParameter@var1048 ;
253: } ;
254: std :: string startPattern@var1049 ; std :: string startPattern2@var1050 ; std :: string endPattern@var1051 ; std :: string itEndPattern@var1052 ;
255: std :: map < std :: string , Function > functions@var1053 ;
256: int type_templateArgNo@var1054 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var1055 ;
258: int size_templateArgNo@var1056 ;
259: bool arrayLike_indexOp@var1057 ;
260: bool stdStringLike@var1058 ;
261: bool stdAssociativeLike@var1059 ;
262: bool opLessAllowed@var1060 ;
263: bool hasInitializerListConstructor@var1061 ;
264: bool unstableErase@var1062 ;
265: bool unstableInsert@var1063 ;
266: bool view@var1064 ;
267:
268: Action getAction ( const std :: string & function@var1065 ) const {
269: const std ::@expr1073744673 map < std ::@expr1073744674 string , Function > ::@expr1073744675 const_iterator i@var1066 =@expr1073744676 functions@var1053 .@expr1073744677 find (@expr1073744678 function@var1065 ) ;
270: if (@expr1073744679 i@var1066 !=@expr1073744680 functions@var1053 .@expr1073744681 end (@expr1073744682 ) ) {
271: return i@var1066 .@expr1073744683 second@var1067 .@expr1073744684 action@var1068 ; }
272: return Action ::@expr1073744685 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var1069 ) const {
276: const std ::@expr1073744686 map < std ::@expr1073744687 string , Function > ::@expr1073744688 const_iterator i@var1070 =@expr1073744689 functions@var1053 .@expr1073744690 find (@expr1073744691 function@var1069 ) ;
277: if (@expr1073744692 i@var1070 !=@expr1073744693 functions@var1053 .@expr1073744694 end (@expr1073744695 ) ) {
278: return i@var1070 .@expr1073744696 second@var1071 .@expr1073744697 yield@var1072 ; }
279: return Yield ::@expr1073744698 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var1073 ) ;
283: static Action actionFrom ( const std :: string & actionName@var1074 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var1075 ;
286: const Container * detectContainer ( const Token * typeStart@var1076 , bool iterator@var1077 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var1078 , bool * isIterator@var1079 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var1080 ( false ) ,
293: notnull@var1081 ( false ) ,
294: notuninit@var1082 ( -1 ) ,
295: formatstr@var1083 ( false ) ,
296: strz@var1084 ( false ) ,
297: optional@var1085 ( false ) ,
298: variadic@var1086 ( false ) ,
299: iteratorInfo@var1092 ( ) ,
300: direction@var1100 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var1080 ;
303: bool notnull@var1081 ;
304: int notuninit@var1082 ;
305: bool formatstr@var1083 ;
306: bool strz@var1084 ;
307: bool optional@var1085 ;
308: bool variadic@var1086 ;
309: std :: string valid@var1087 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var1088 ( 0 ) , it@var1089 ( false ) , first@var1090 ( false ) , last@var1091 ( false ) { }
314:
315: int container@var1088 ;
316: bool it@var1089 ;
317: bool first@var1090 ;
318: bool last@var1091 ;
319: } ;
320: IteratorInfo iteratorInfo@var1092 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var1093 , int a@var1094 ) : type@var1095 ( t@var1093 ) , arg@var1096 ( a@var1094 ) , arg2@var1097 ( 0 ) , value@var1098 ( 0 ) { }
326: Type type@var1095 ;
327: int arg@var1096 ;
328: int arg2@var1097 ;
329: long long value@var1098 ;
330: } ;
331: std :: vector < MinSize > minsizes@var1099 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var1100 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var1101 ;
344: bool use@var1102 ;
345: bool leakignore@var1103 ;
346: bool isconst@var1104 ;
347: bool ispure@var1105 ;
348: UseRetValType useretval@var1106 ;
349: bool ignore@var1107 ;
350: bool formatstr@var1108 ;
351: bool formatstr_scan@var1109 ;
352: bool formatstr_secure@var1110 ;
353: Container :: Action containerAction@var1111 ;
354: Container :: Yield containerYield@var1112 ;
355: Function ( )
356: : use@var1102 ( false ) ,
357: leakignore@var1103 ( false ) ,
358: isconst@var1104 ( false ) ,
359: ispure@var1105 ( false ) ,
360: useretval@var1106 ( UseRetValType :: NONE ) ,
361: ignore@var1107 ( false ) ,
362: formatstr@var1108 ( false ) ,
363: formatstr_scan@var1109 ( false ) ,
364: formatstr_secure@var1110 ( false ) ,
365: containerAction@var1111 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var1112 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var1113 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var1114 ;
372: bool isUse ( const std :: string & functionName@var1115 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var1116 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var1117 , bool pure@var1118 ) const ;
375: bool isFunctionConst ( const Token * ftok@var1119 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var1120 , int argnr@var1121 ) const {
378: const ArgumentChecks * arg@var1122 ; arg@var1122 =@expr1073744699 getarg (@expr1073744700 ftok@var1120 , argnr@var1121 ) ;
379: return arg@var1122 &&@expr1073744701 arg@var1122 .@expr1073744702 notbool@var1123 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var1124 , int argnr@var1125 ) const ;
383: bool isuninitargbad ( const Token * ftok@var1126 , int argnr@var1127 , int indirect@var1128 = 0 , bool * hasIndirect@var1129 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var1130 , int argnr@var1131 ) const {
386: const ArgumentChecks * arg@var1132 ; arg@var1132 =@expr1073744703 getarg (@expr1073744704 ftok@var1130 , argnr@var1131 ) ;
387: return arg@var1132 &&@expr1073744705 arg@var1132 .@expr1073744706 formatstr@var1133 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var1134 , int argnr@var1135 ) const {
391: const ArgumentChecks * arg@var1136 ; arg@var1136 =@expr1073744707 getarg (@expr1073744708 ftok@var1134 , argnr@var1135 ) ;
392: return arg@var1136 &&@expr1073744709 arg@var1136 .@expr1073744710 strz@var1137 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var1138 , int argnr@var1139 , const long long argvalue@var1140 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var1141 , int argnr@var1142 , double argvalue@var1143 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var1144 , int argnr@var1145 ) const {
399: const ArgumentChecks * arg@var1146 ; arg@var1146 =@expr1073744711 getarg (@expr1073744712 ftok@var1144 , argnr@var1145 ) ;
400: return arg@var1146 ?@expr1073744713 arg@var1146 .@expr1073744714 valid@var1147 :@expr1073744715 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var1148 ;
405: std :: string op1@var1149 ;
406: std :: string op2@var1150 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744716 isInt (@expr1073744717 op1@var1149 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var1151 , int argnr@var1152 ) const {
413: const ArgumentChecks * arg@var1153 ; arg@var1153 =@expr1073744718 getarg (@expr1073744719 ftok@var1151 , argnr@var1152 ) ;
414: return arg@var1153 &&@expr1073744720 arg@var1153 .@expr2897 iteratorInfo@var1154 .@expr1073744722 it@var1155 ?@expr1073744723 &@expr1073744724 arg@var1153 .@expr2897 iteratorInfo@var1154 :@expr1073744726 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var1156 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var1157 , int argnr@var1158 ) const {
420: const ArgumentChecks * arg@var1159 ; arg@var1159 =@expr1073744727 getarg (@expr1073744728 ftok@var1157 , argnr@var1158 ) ;
421: return arg@var1159 ?@expr1073744729 &@expr1073744730 arg@var1159 .@expr1073744731 minsizes@var1160 :@expr1073744732 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var1161 , int argnr@var1162 ) const ;
425:
426: bool markupFile ( const std :: string & path@var1163 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var1164 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1268 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var1165 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var1166 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var1167 , const std :: string & token@var1168 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var1169 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var1170 ) const ;
443: const std :: string & blockend ( const std :: string & file@var1171 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var1172 , const std :: string & keyword@var1173 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var1174 ) const {
448: return mExporters@var1271 .@expr1073744733 find (@expr1073744734 prefix@var1174 ) !=@expr1073744735 mExporters@var1271 .@expr1073744736 end (@expr1073744737 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var1175 , const std :: string & token@var1176 ) const {
452: const std ::@expr1073744738 map < std ::@expr1073744739 string , ExportedFunctions > ::@expr1073744740 const_iterator it@var1177 =@expr1073744741 mExporters@var1271 .@expr1073744742 find (@expr1073744743 prefix@var1175 ) ;
453: return (@expr1073744744 it@var1177 !=@expr1073744745 mExporters@var1271 .@expr1073744746 end (@expr1073744747 ) &&@expr1073744748 it@var1177 .@expr1073744749 second@var1178 .@expr1073744750 isPrefix (@expr1073744751 token@var1176 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var1179 , const std :: string & token@var1180 ) const {
457: const std ::@expr1073744752 map < std ::@expr1073744753 string , ExportedFunctions > ::@expr1073744754 const_iterator it@var1181 =@expr1073744755 mExporters@var1271 .@expr1073744756 find (@expr1073744757 prefix@var1179 ) ;
458: return (@expr1073744758 it@var1181 !=@expr1073744759 mExporters@var1271 .@expr1073744760 end (@expr1073744761 ) &&@expr1073744762 it@var1181 .@expr1073744763 second@var1182 .@expr1073744764 isSuffix (@expr1073744765 token@var1180 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var1183 , const std :: string & importer@var1184 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var1185 , Container :: Yield yield@var1186 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var1187 , Container :: Action action@var1188 ) const ;
465:
466: bool isreflection ( const std :: string & token@var1189 ) const {
467: return mReflection@var1273 .@expr1073744766 find (@expr1073744767 token@var1189 ) !=@expr1073744768 mReflection@var1273 .@expr1073744769 end (@expr1073744770 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var1190 ) const {
471: const std ::@expr1073744771 map < std ::@expr1073744772 string , int > ::@expr1073744773 const_iterator it@var1191 =@expr1073744774 mReflection@var1273 .@expr1073744775 find (@expr1073744776 token@var1190 ) ;
472: if (@expr1073744777 it@var1191 !=@expr1073744778 mReflection@var1273 .@expr1073744779 end (@expr1073744780 ) ) {
473: return it@var1191 .@expr1073744781 second@var1192 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var1193 ;
478:
479: struct SmartPointer {
480: std :: string name@var1194 ; name@var1194 = "" ;
481: bool unique@var1195 ; unique@var1195 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var1196 ;
485: bool isSmartPointer ( const Token * tok@var1197 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var1198 ) const ;
487:
488: struct PodType {
489: unsigned int size@var1199 ;
490: char sign@var1200 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var1201 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var1202 ) const {
494: const std ::@expr1073744782 unordered_map < std ::@expr1073744783 string , PodType > ::@expr1073744784 const_iterator it@var1203 =@expr1073744785 mPodTypes@var1274 .@expr1073744786 find (@expr1073744787 name@var1202 ) ;
495: return (@expr2964 it@var1203 !=@expr1073744789 mPodTypes@var1274 .@expr1073744790 end (@expr1073744791 ) ) ?@expr1073744792 &@expr1073744793 (@expr2964 it@var1203 .@expr1073744795 second@var1204 ) :@expr1073744796 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var1215 ( false )
501: , mUnsigned@var1216 ( false )
502: , mLong@var1217 ( false )
503: , mPointer@var1218 ( false )
504: , mPtrPtr@var1219 ( false )
505: , mConstPtr@var1220 ( false ) { }
506: bool operator== ( const PlatformType & type@var1205 ) const {
507: return (@expr1073744797 mSigned@var1215 ==@expr1073744798 type@var1205 .@expr1073744799 mSigned@var1206 &&@expr1073744800
508: mUnsigned@var1216 ==@expr1073744801 type@var1205 .@expr1073744802 mUnsigned@var1207 &&@expr1073744803
509: mLong@var1217 ==@expr1073744804 type@var1205 .@expr1073744805 mLong@var1208 &&@expr1073744806
510: mPointer@var1218 ==@expr1073744807 type@var1205 .@expr1073744808 mPointer@var1209 &&@expr1073744809
511: mPtrPtr@var1219 ==@expr1073744810 type@var1205 .@expr1073744811 mPtrPtr@var1210 &&@expr1073744812
512: mConstPtr@var1220 ==@expr1073744813 type@var1205 .@expr1073744814 mConstPtr@var1211 &&@expr1073744815
513: mType@var1214 ==@expr1073744816 type@var1205 .@expr1073744817 mType@var1212 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var1213 ) const {
516: return !@expr1073744818 (@expr1073744819 *@expr1073744820 this@expr1073744821 ==@expr1073744822 type@var1213 ) ;
517: }
518: std :: string mType@var1214 ;
519: bool mSigned@var1215 ;
520: bool mUnsigned@var1216 ;
521: bool mLong@var1217 ;
522: bool mPointer@var1218 ;
523: bool mPtrPtr@var1219 ;
524: bool mConstPtr@var1220 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var1221 ) const {
529: const std ::@expr1073744823 map < std ::@expr1073744824 string , PlatformType > ::@expr1073744825 const_iterator it@var1222 =@expr1073744826 mPlatformTypes@var1224 .@expr1073744827 find (@expr1073744828 name@var1221 ) ;
530: return (@expr3005 it@var1222 !=@expr1073744830 mPlatformTypes@var1224 .@expr1073744831 end (@expr1073744832 ) ) ?@expr1073744833 &@expr1073744834 (@expr3005 it@var1222 .@expr1073744836 second@var1223 ) :@expr1073744837 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var1224 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var1225 , const std :: string & platform@var1226 ) const {
536: const std ::@expr1073744838 map < std ::@expr3015 string , Platform > ::@expr1073744840 const_iterator it@var1227 =@expr1073744841 mPlatforms@var1276 .@expr1073744842 find (@expr1073744843 platform@var1226 ) ;
537: if (@expr1073744844 it@var1227 !=@expr1073744845 mPlatforms@var1276 .@expr1073744846 end (@expr1073744847 ) ) {
538: const PlatformType * const type@var1228 ; type@var1228 =@expr1073744848 it@var1227 .@expr1073744849 second@var1229 .@expr1073744850 platform_type (@expr1073744851 name@var1225 ) ;
539: if (@expr1073744852 type@var1228 ) {
540: return type@var1228 ; }
541: }
542:
543: const std ::@expr1073744853 map < std ::@expr3015 string , PlatformType > ::@expr1073744855 const_iterator it2@var1230 =@expr1073744856 mPlatformTypes@var1275 .@expr1073744857 find (@expr1073744858 name@var1225 ) ;
544: return (@expr3035 it2@var1230 !=@expr1073744860 mPlatformTypes@var1275 .@expr1073744861 end (@expr1073744862 ) ) ?@expr1073744863 &@expr1073744864 (@expr3035 it2@var1230 .@expr1073744866 second@var1231 ) :@expr1073744867 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var1232 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var1233 , Library :: Container :: Yield y@var1234 , const std :: string & fallback@var1235 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1236 , const std :: string & typeName@var1237 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1238 , const std :: string & name@var1239 , std :: set < std :: string > & unknown_elements@var1240 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1241 ) {
565: mPrefixes@var1245 .@expr1073744868 insert (@expr1073744869 prefix@var1241 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1242 ) {
568: mSuffixes@var1246 .@expr1073744870 insert (@expr1073744871 suffix@var1242 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1243 ) const {
571: return (@expr1073744872 mPrefixes@var1245 .@expr1073744873 find (@expr1073744874 prefix@var1243 ) !=@expr1073744875 mPrefixes@var1245 .@expr1073744876 end (@expr1073744877 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1244 ) const {
574: return (@expr1073744878 mSuffixes@var1246 .@expr1073744879 find (@expr1073744880 suffix@var1244 ) !=@expr1073744881 mSuffixes@var1246 .@expr1073744882 end (@expr1073744883 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1245 ;
579: std :: set < std :: string > mSuffixes@var1246 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1254 ( 0 ) { }
584:
585: void setStart ( const char * s@var1247 ) {
586: mStart@var1252 =@expr1073744884 s@var1247 ;
587: }
588: void setEnd ( const char * e@var1248 ) {
589: mEnd@var1253 =@expr1073744885 e@var1248 ;
590: }
591: void setOffset ( const int o@var1249 ) {
592: mOffset@var1254 =@expr1073744886 o@var1249 ;
593: }
594: void addBlock ( const char * blockName@var1250 ) {
595: mBlocks@var1255 .@expr1073744887 insert (@expr1073744888 blockName@var1250 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1252 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1253 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1254 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1251 ) const {
607: return mBlocks@var1255 .@expr1073744889 find (@expr1073744890 blockName@var1251 ) !=@expr1073744891 mBlocks@var1255 .@expr1073744892 end (@expr1073744893 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1252 ;
612: std :: string mEnd@var1253 ;
613: int mOffset@var1254 ;
614: std :: set < std :: string > mBlocks@var1255 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1256 ;
618: std :: set < std :: string > mFiles@var1257 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1258 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1259 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1260 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1261 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1262 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1263 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1264 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1265 ;
627: std :: map < std :: string , bool > mReportErrors@var1266 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1267 ;
629: std :: set < std :: string > mMarkupExtensions@var1268 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1269 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1270 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1271 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1272 ;
634: std :: map < std :: string , int > mReflection@var1273 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1274 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1275 ;
637: std :: map < std :: string , Platform > mPlatforms@var1276 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1277 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1278 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1279 , int argnr@var1280 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1281 , bool * error@var1282 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1283 , const std :: string & name@var1284 ) {
646: const std ::@expr1073744894 map < std ::@expr1073744895 string , AllocFunc > ::@expr1073744896 const_iterator it@var1285 =@expr1073744897 data@var1283 .@expr1073744898 find (@expr1073744899 name@var1284 ) ;
647: return (@expr1073744900 it@var1285 ==@expr1073744901 data@var1283 .@expr1073744902 end (@expr1073744903 ) ) ?@expr1073744904 nullptr :@expr1073744905 &@expr1073744906 it@var1285 .@expr1073744907 second@var1286 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1287 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1288 ,
654: const Settings * settings@var1289 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1290 = nullptr ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1291 ( nullptr ) , num@var1292 ( 0 ) , known@var1293 ( true ) { }
62:
63: const Token * tok@var1291 ;
64: long long num@var1292 ;
65: bool known@var1293 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1294 ;
72: const Scope * classScope@var1295 ;
73: const Scope * enclosingScope@var1296 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1297 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1299 ( nullptr ) , nameTok@var1300 ( nullptr ) , access@var1301 ( AccessControl :: Public ) , isVirtual@var1302 ( false ) { }
82:
83: std :: string name@var1298 ;
84: const Type * type@var1299 ;
85: const Token * nameTok@var1300 ;
86: AccessControl access@var1301 ;
87: bool isVirtual@var1302 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1303 ) const {
90: return this@expr1073744908 .@expr1073744909 type@var1299 <@expr1073744910 rhs@var1303 .@expr1073744911 type@var1304 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1305 ( nullptr ) , nameEnd@var1306 ( nullptr ) , type@var1307 ( nullptr ) { }
97:
98: const Token * nameStart@var1305 ;
99: const Token * nameEnd@var1306 ;
100: const Type * type@var1307 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1308 ;
104: std :: vector < FriendInfo > friendList@var1309 ;
105:
106: const Token * typeStart@var1310 ;
107: const Token * typeEnd@var1311 ;
108: long long sizeOf@var1312 ;
109:
110: Type ( const Token * classDef_@var1313 = nullptr , const Scope * classScope_@var1314 = nullptr , const Scope * enclosingScope_@var1315 = nullptr ) :
111: classDef@var1294 ( classDef_@var1313 ) ,
112: classScope@var1295 ( classScope_@var1314 ) ,
113: enclosingScope@var1296 ( enclosingScope_@var1315 ) ,
114: needInitialization@var1297 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1310 ( nullptr ) ,
116: typeEnd@var1311 ( nullptr ) ,
117: sizeOf@var1312 ( 0 ) {
118: if (@expr1073744912 classDef_@var1313 &&@expr1073744913 classDef_@var1313 .@expr3090 str (@expr3091 ) ==@expr1073744916 "enum" ) {
119: needInitialization@var1297 =@expr1073744917 NeedInitialization ::@expr1073744918 True ; }
120: else { if (@expr1073744919 classDef_@var1313 &&@expr1073744920 classDef_@var1313 .@expr3090 str (@expr3091 ) ==@expr1073744923 "using" ) {
121: typeStart@var1310 =@expr1073744924 classDef@var1294 .@expr1073744925 tokAt (@expr1073744926 3 ) ;
122: typeEnd@var1311 =@expr1073744927 typeStart@var1310 ;
123: while (@expr1073744928 typeEnd@var1311 .@expr3105 next (@expr3106 ) &&@expr1073744931 typeEnd@var1311 .@expr3105 next (@expr3106 ) .@expr1073744934 str (@expr1073744935 ) !=@expr1073744936 ";" ) {
124: typeEnd@var1311 =@expr1073744937 typeEnd@var1311 .@expr3105 next (@expr3106 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1294 ?@expr1073744940 classDef@var1294 .@expr1073744941 str (@expr1073744942 ) :@expr1073744943 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1294 &&@expr1073744944 classDef@var1294 .@expr1073744945 str (@expr1073744946 ) ==@expr1073744947 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1316 , const Token * tok1@var1317 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1318 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1319 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1320 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1321 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1322 ) : scope@var1323 ( scope_@var1322 ) , name@var1324 ( nullptr ) , value@var1325 ( 0 ) , start@var1326 ( nullptr ) , end@var1327 ( nullptr ) , value_known@var1328 ( false ) { }
167: const Scope * scope@var1323 ;
168: const Token * name@var1324 ;
169: long long value@var1325 ;
170: const Token * start@var1326 ;
171: const Token * end@var1327 ;
172: bool value_known@var1328 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1329 ) const {
204: return (@expr3124 (@expr3124 mFlags@var1365 &@expr1073744950 flag_@var1329 ) !=@expr1073744951 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1330 , bool state_@var1331 ) {
213: mFlags@var1365 =@expr1073744952 state_@var1331 ?@expr1073744953 mFlags@var1365 |@expr1073744954 flag_@var1330 :@expr1073744955 mFlags@var1365 &@expr1073744956 ~@expr1073744957 flag_@var1330 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1332 , bool * isContainer@var1333 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1334 , const Token * start_@var1335 , const Token * end_@var1336 ,
226: int index_@var1337 , AccessControl access_@var1338 , const Type * type_@var1339 ,
227: const Scope * scope_@var1340 , const Settings * settings@var1341 )
228: : mNameToken@var1360 ( name_@var1334 ) ,
229: mTypeStartToken@var1361 ( start_@var1335 ) ,
230: mTypeEndToken@var1362 ( end_@var1336 ) ,
231: mIndex@var1363 ( index_@var1337 ) ,
232: mAccess@var1364 ( access_@var1338 ) ,
233: mFlags@var1365 ( 0 ) ,
234: mType@var1366 ( type_@var1339 ) ,
235: mScope@var1367 ( scope_@var1340 ) ,
236: mValueType@var1368 ( nullptr ) {
237: evaluate (@expr1073744958 settings@var1341 ) ;
238: }
239:
240: Variable ( const Token * name_@var1342 , const std :: string & clangType@var1343 , const Token * typeStart@var1344 ,
241: const Token * typeEnd@var1345 , int index_@var1346 , AccessControl access_@var1347 ,
242: const Type * type_@var1348 , const Scope * scope_@var1349 ) ;
243:
244: Variable ( const Variable & var@var1350 , const Scope * scope@var1351 ) ;
245:
246: Variable ( const Variable & var@var1352 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1353 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1360 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1361 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1362 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073744959 mNameToken@var1360 ) {
300: return mNameToken@var1360 .@expr1073744960 str (@expr1073744961 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073744962 mNameToken@var1360 ) {
312: return mNameToken@var1360 .@expr1073744963 varId (@expr1073744964 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1363 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1364 ==@expr1073744965 AccessControl ::@expr1073744966 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1364 ==@expr1073744967 AccessControl ::@expr1073744968 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1364 ==@expr1073744969 AccessControl ::@expr1073744970 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1364 ==@expr1073744971 AccessControl ::@expr1073744972 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1364 ==@expr1073744973 AccessControl ::@expr1073744974 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1364 ==@expr1073744975 AccessControl ::@expr1073744976 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073744978 mAccess@var1364 ==@expr1073744979 AccessControl ::@expr1073744980 Local@expr1073744977 ) &&@expr1073744981 !@expr1073744982 isExtern (@expr1073744983 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073744984 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073744985 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073744986 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073744987 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073744988 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1364 ==@expr1073744989 AccessControl ::@expr1073744990 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073744991 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073744992 fIsArray ) &&@expr1073744993 !@expr1073744994 getFlag (@expr1073744995 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073744996 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073744997 ) &&@expr1073744998 getFlag (@expr1073744999 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745000 fIsArray ) ||@expr1073745001 getFlag (@expr1073745002 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745003 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745004 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745005 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745006 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1366 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1366 ?@expr1073745007 mType@var1366 .@expr1073745008 classScope@var1371 :@expr1073745009 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1367 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1369 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1354 ) const {
550: return mDimensions@var1369 [@expr1073745010 index_@var1354 ] .@expr1073745011 num@var1665 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1355 ) const {
558: return mDimensions@var1369 [@expr1073745012 index_@var1355 ] .@expr1073745013 known@var1666 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745014 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745015 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745016 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1356 ) const {
602: return isStlType (@expr1073745017 ) &&@expr1073745018 stlType@var1356 ==@expr1073745019 mTypeStartToken@var1361 .@expr1073745020 strAt (@expr1073745021 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1357 ) const {
616: return isStlType (@expr1073745022 ) &&@expr1073745023 stlTypes@var1357 .@expr1073745024 find (@expr1073745025 mTypeStartToken@var1361 .@expr1073745026 strAt (@expr1073745027 2 ) ) !=@expr1073745028 stlTypes@var1357 .@expr1073745029 end (@expr1073745030 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745031 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr3208 ) &&@expr1073745033 type (@expr3208 ) .@expr1073745035 isEnumType (@expr1073745036 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745037 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1368 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1358 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1364 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1359 ) {
660: mType@var1366 =@expr1073745038 t@var1359 ;
661: }
662:
663:
664: const Token * mNameToken@var1360 ;
665:
666:
667: const Token * mTypeStartToken@var1361 ;
668:
669:
670: const Token * mTypeEndToken@var1362 ;
671:
672:
673: int mIndex@var1363 ;
674:
675:
676: AccessControl mAccess@var1364 ;
677:
678:
679: unsigned int mFlags@var1365 ;
680:
681:
682: const Type * mType@var1366 ;
683:
684:
685: const Scope * mScope@var1367 ;
686:
687: ValueType * mValueType@var1368 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1369 ;
691:
692:
693: void evaluate ( const Settings * settings@var1370 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1372 ) const {
735: return (@expr3215 (@expr3215 mFlags@var1421 &@expr1073745041 flag@var1372 ) !=@expr1073745042 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1373 , bool state@var1374 ) {
744: mFlags@var1421 =@expr1073745043 state@var1374 ?@expr1073745044 mFlags@var1421 |@expr1073745045 flag@var1373 :@expr1073745046 mFlags@var1421 &@expr1073745047 ~@expr1073745048 flag@var1373 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1375 , const Token * tok@var1376 , const Scope * scope@var1377 , const Token * tokDef@var1378 , const Token * tokArgDef@var1379 ) ;
751: Function ( const Token * tokenDef@var1380 , const std :: string & clangType@var1381 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1391 .@expr1073745049 str (@expr1073745050 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1399 .@expr1073745051 size (@expr1073745052 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1399 .@expr1073745053 size (@expr1073745054 ) -@expr1073745055 initArgCount@var1400 ;
764: }
765: const Variable * getArgumentVar ( int num@var1382 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1400 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1383 , const Scope * scope@var1384 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1385 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1386 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1401 ==@expr1073745056 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1401 ==@expr1073745057 eConstructor ||@expr1073745058
785: type@var1401 ==@expr1073745059 eCopyConstructor ||@expr1073745060
786: type@var1401 ==@expr1073745061 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1401 ==@expr1073745062 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1391 .@expr1073745063 isAttributeConstructor (@expr1073745064 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1391 .@expr1073745065 isAttributeDestructor (@expr1073745066 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1391 .@expr1073745067 isAttributePure (@expr1073745068 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1391 .@expr1073745069 isAttributeConst (@expr1073745070 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1391 .@expr1073745071 isAttributeNoreturn (@expr1073745072 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1391 .@expr1073745073 isAttributeNothrow (@expr1073745074 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1391 .@expr1073745075 isAttributeNodiscard (@expr1073745076 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745077 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745078 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745079 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745080 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745081 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745082 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745083 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745084 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745085 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745086 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745087 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745088 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745089 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745090 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745091 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745092 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745093 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745094 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745095 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745096 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745097 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745098 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1387 ) {
881: setFlag (@expr1073745099 fHasBody , state@var1387 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745100 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745101 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1388 ) {
891: setFlag (@expr1073745102 fIsEscapeFunction , state@var1388 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745103 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1389 ) {
898: setFlag (@expr1073745104 fIsConstexpr , state@var1389 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1390 ) const ;
901:
902: const Token * tokenDef@var1391 ;
903: const Token * argDef@var1392 ;
904: const Token * token@var1393 ;
905: const Token * arg@var1394 ;
906: const Token * retDef@var1395 ;
907: const :: Type * retType@var1396 ;
908: const Scope * functionScope@var1397 ;
909: const Scope * nestedIn@var1398 ;
910: std :: list < Variable > argumentList@var1399 ;
911: int initArgCount@var1400 ;
912: Type type@var1401 ;
913: AccessControl access@var1402 ;
914: const Token * noexceptArg@var1403 ;
915: const Token * throwArg@var1404 ;
916: const Token * templateDef@var1405 ;
917: const Token * functionPointerUsage@var1406 ;
918:
919: bool argsMatch ( const Scope * scope@var1407 , const Token * first@var1408 , const Token * second@var1409 , const std :: string & path@var1410 , int path_length@var1411 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1412 , bool unknown@var1413 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1414 , bool unknown@var1415 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1416 , bool unknown@var1417 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1418 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745105 this@expr1073745106 .@expr1073745107 hasTrailingReturnType (@expr1073745108 ) ) {
931: return Token ::@expr1073745109 findmatch (@expr1073745110 retDef@var1395 , "{|;" ) ;
932: } else {
933: return tokenDef@var1391 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1419 , bool * foundAllBaseClasses@var1420 ) const ;
946:
947: unsigned int mFlags@var1421 ;
948:
949: void isInline ( bool state@var1422 ) {
950: setFlag (@expr1073745111 fIsInline , state@var1422 ) ;
951: }
952: void isConst ( bool state@var1423 ) {
953: setFlag (@expr1073745112 fIsConst , state@var1423 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1424 ) {
956: setFlag (@expr1073745113 fHasVirtualSpecifier , state@var1424 ) ;
957: }
958: void isPure ( bool state@var1425 ) {
959: setFlag (@expr1073745114 fIsPure , state@var1425 ) ;
960: }
961: void isStatic ( bool state@var1426 ) {
962: setFlag (@expr1073745115 fIsStatic , state@var1426 ) ;
963: }
964: void isStaticLocal ( bool state@var1427 ) {
965: setFlag (@expr1073745116 fIsStaticLocal , state@var1427 ) ;
966: }
967: void isExtern ( bool state@var1428 ) {
968: setFlag (@expr1073745117 fIsExtern , state@var1428 ) ;
969: }
970: void isFriend ( bool state@var1429 ) {
971: setFlag (@expr1073745118 fIsFriend , state@var1429 ) ;
972: }
973: void isExplicit ( bool state@var1430 ) {
974: setFlag (@expr1073745119 fIsExplicit , state@var1430 ) ;
975: }
976: void isDefault ( bool state@var1431 ) {
977: setFlag (@expr1073745120 fIsDefault , state@var1431 ) ;
978: }
979: void isDelete ( bool state@var1432 ) {
980: setFlag (@expr1073745121 fIsDelete , state@var1432 ) ;
981: }
982: void isNoExcept ( bool state@var1433 ) {
983: setFlag (@expr1073745122 fIsNoExcept , state@var1433 ) ;
984: }
985: void isThrow ( bool state@var1434 ) {
986: setFlag (@expr1073745123 fIsThrow , state@var1434 ) ;
987: }
988: void isOperator ( bool state@var1435 ) {
989: setFlag (@expr1073745124 fIsOperator , state@var1435 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1436 ) {
992: setFlag (@expr1073745125 fHasLvalRefQual , state@var1436 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1437 ) {
995: setFlag (@expr1073745126 fHasRvalRefQual , state@var1437 ) ;
996: }
997: void isVariadic ( bool state@var1438 ) {
998: setFlag (@expr1073745127 fIsVariadic , state@var1438 ) ;
999: }
1000: void isVolatile ( bool state@var1439 ) {
1001: setFlag (@expr1073745128 fIsVolatile , state@var1439 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1440 ) {
1004: return setFlag (@expr1073745129 fHasTrailingReturnType , state@var1440 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1441 ) {
1007: setFlag (@expr1073745130 fIsInlineKeyword , state@var1441 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1442 , const Scope * scope@var1443 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1444 ;
1019: const Scope * scope@var1445 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1446 , const Token * classDef_@var1447 , const Scope * nestedIn_@var1448 ) ;
1025: Scope ( const SymbolDatabase * check_@var1449 , const Token * classDef_@var1450 , const Scope * nestedIn_@var1451 , ScopeType type_@var1452 , const Token * start_@var1453 ) ;
1026:
1027: const SymbolDatabase * check@var1454 ;
1028: std :: string className@var1455 ;
1029: const Token * classDef@var1456 ;
1030: const Token * bodyStart@var1457 ;
1031: const Token * bodyEnd@var1458 ;
1032: std :: list < Function > functionList@var1459 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1460 ;
1034: std :: list < Variable > varlist@var1461 ;
1035: const Scope * nestedIn@var1462 ;
1036: std :: list < Scope * > nestedList@var1463 ;
1037: int numConstructors@var1464 ;
1038: int numCopyOrMoveConstructors@var1465 ;
1039: std :: list < UsingInfo > usingList@var1466 ;
1040: ScopeType type@var1467 ;
1041: Type * definedType@var1468 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1469 ;
1043: std :: vector < const Token * > bodyStartList@var1470 ;
1044:
1045:
1046: const Scope * functionOf@var1471 ;
1047: Function * function@var1472 ;
1048:
1049:
1050: const Token * enumType@var1473 ;
1051: bool enumClass@var1474 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1475 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1476 ) {
1056: bodyStart@var1457 =@expr1073745131 start@var1476 ;
1057: bodyEnd@var1458 =@expr1073745132 start@var1476 ?@expr1073745133 start@var1476 .@expr1073745134 link (@expr1073745135 ) :@expr1073745136 nullptr ;
1058: if (@expr1073745137 start@var1476 ) {
1059: bodyStartList@var1470 .@expr1073745138 push_back (@expr1073745139 start@var1476 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1455 .@expr1073745140 size (@expr1073745141 ) >@expr1073745142 9 &&@expr1073745143 className@var1455 .@expr1073745144 compare (@expr1073745145 0 , 9 , "Anonymous" ) ==@expr1073745146 0 &&@expr1073745147 std ::@expr1073745148 isdigit (@expr1073745149 className@var1455 [@expr1073745150 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1477 ) const {
1068: for (@expr1073745151 const Enumerator &@expr1073745152 i@var1478 :@expr1073745153 enumeratorList@var1475 ) {
1069: if (@expr1073745154 i@var1478 .@expr1073745155 name@var1479 .@expr1073745156 str (@expr1073745157 ) ==@expr1073745158 name@var1477 ) {
1070: return &@expr1073745159 i@var1478 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1480 ) const {
1076: if (@expr1073745160 !@expr1073745161 outer@var1480 ) {
1077: return false ; }
1078: if (@expr1073745162 outer@var1480 ==@expr1073745163 this@expr1073745164 ) {
1079: return true ; }
1080: const Scope * parent@var1481 ; parent@var1481 =@expr1073745165 nestedIn@var1462 ;
1081: while (@expr1073745166 outer@var1480 !=@expr1073745167 parent@var1481 &&@expr1073745168 parent@var1481 ) {
1082: parent@var1481 =@expr1073745169 parent@var1481 .@expr1073745170 nestedIn@var1482 ; }
1083: if (@expr1073745171 parent@var1481 &&@expr1073745172 parent@var1481 ==@expr1073745173 outer@var1480 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1483 ) {
1089: while (@expr1073745174 scope@var1483 ) {
1090: if (@expr1073745175 scope@var1483 .@expr1073745176 type@var1484 ==@expr1073745177 Scope ::@expr1073745178 eFunction ) {
1091: break ; }
1092: scope@var1483 =@expr1073745179 scope@var1483 .@expr1073745180 nestedIn@var1485 ;
1093: }
1094: if (@expr1073745181 !@expr1073745182 scope@var1483 ) {
1095: return nullptr ; }
1096: return scope@var1483 .@expr1073745183 function@var1486 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073745184 type@var1467 ==@expr1073745185 eClass ||@expr1073745186 type@var1467 ==@expr1073745187 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073745188 type@var1467 ==@expr1073745189 eClass ||@expr1073745190 type@var1467 ==@expr1073745191 eStruct ||@expr1073745192 type@var1467 ==@expr1073745193 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1467 !=@expr1073745194 eClass &&@expr1073745195 type@var1467 !=@expr1073745196 eStruct &&@expr1073745197 type@var1467 !=@expr1073745198 eUnion &&@expr1073745199 type@var1467 !=@expr1073745200 eGlobal &&@expr1073745201 type@var1467 !=@expr1073745202 eNamespace &&@expr1073745203 type@var1467 !=@expr1073745204 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1467 ==@expr1073745205 Scope ::@expr3382 ScopeType ::@expr1073745207 eFor ||@expr1073745208 type@var1467 ==@expr1073745209 Scope ::@expr3382 ScopeType ::@expr1073745211 eWhile ||@expr1073745212 type@var1467 ==@expr1073745213 Scope ::@expr3382 ScopeType ::@expr1073745215 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073745216 type@var1467 ==@expr1073745217 eIf ||@expr1073745218 type@var1467 ==@expr1073745219 eElse ||@expr1073745220
1117: type@var1467 ==@expr1073745221 eFor ||@expr1073745222 type@var1467 ==@expr1073745223 eWhile ||@expr1073745224 type@var1467 ==@expr1073745225 eDo ||@expr1073745226
1118: type@var1467 ==@expr1073745227 eSwitch ||@expr1073745228 type@var1467 ==@expr1073745229 eUnconditional ||@expr1073745230
1119: type@var1467 ==@expr1073745231 eTry ||@expr1073745232 type@var1467 ==@expr1073745233 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1487 , bool requireConst@var1488 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1489 , bool isC@var1490 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1491 ) {
1135: return const_cast < Scope *@expr3410 > (@expr1073745235 const_cast < const Scope *@expr3410 > (@expr1073745237 this@expr1073745238 ) .@expr1073745239 findRecordInNestedList (@expr1073745240 name@var1491 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1492 ) const ;
1139: Type * findType ( const std :: string & name@var1493 ) {
1140: return const_cast < Type *@expr3417 > (@expr1073745242 const_cast < const Scope *@expr3417 > (@expr1073745244 this@expr1073745245 ) .@expr1073745246 findType (@expr1073745247 name@var1493 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1494 ) ;
1148:
1149: void addVariable ( const Token * token_@var1495 , const Token * start_@var1496 ,
1150: const Token * end_@var1497 , AccessControl access_@var1498 , const Type * type_@var1499 ,
1151: const Scope * scope_@var1500 , const Settings * settings@var1501 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1502 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1503 ) {
1159: functionList@var1459 .@expr1073745248 push_back (@expr1073745249 func@var1503 ) ;
1160:
1161: const Function * back@var1504 ; back@var1504 =@expr1073745250 &@expr1073745251 functionList@var1459 .@expr1073745252 back (@expr1073745253 ) ;
1162:
1163: functionMap@var1460 .@expr1073745254 insert (@expr1073745255 make_pair (@expr1073745256 back@var1504 .@expr1073745257 tokenDef@var1505 .@expr1073745258 str (@expr1073745259 ) , back@var1504 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1506 , AccessControl varaccess@var1507 , const Settings * settings@var1508 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1509 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1510 , bool isCpp@var1511 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1512 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1513 , const Token * & vartok@var1514 , const Token * & typetok@var1515 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1516 , int args@var1517 , std :: vector < const Function * > & matches@var1518 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1519 , const Token * start@var1520 , const Token * end@var1521 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1522 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1523 ;
1239: int bits@var1524 ;
1240: int pointer@var1525 ;
1241: int constness@var1526 ;
1242: Reference reference@var1527 ; reference@var1527 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1528 ;
1245: const :: Type * smartPointerType@var1529 ;
1246: const Token * smartPointerTypeToken@var1530 ;
1247: const Library :: SmartPointer * smartPointer@var1531 ;
1248: const Library :: Container * container@var1532 ;
1249:
1250: const Token * containerTypeToken@var1533 ;
1251:
1252: std :: string originalTypeName@var1534 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1522 ( UNKNOWN_SIGN ) ,
1257: type@var1523 ( UNKNOWN_TYPE ) ,
1258: bits@var1524 ( 0 ) ,
1259: pointer@var1525 ( 0U ) ,
1260: constness@var1526 ( 0U ) ,
1261: typeScope@var1528 ( nullptr ) ,
1262: smartPointerType@var1529 ( nullptr ) ,
1263: smartPointerTypeToken@var1530 ( nullptr ) ,
1264: smartPointer@var1531 ( nullptr ) ,
1265: container@var1532 ( nullptr ) ,
1266: containerTypeToken@var1533 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1535 , enum Type t@var1536 , int p@var1537 )
1269: : sign@var1522 ( s@var1535 ) ,
1270: type@var1523 ( t@var1536 ) ,
1271: bits@var1524 ( 0 ) ,
1272: pointer@var1525 ( p@var1537 ) ,
1273: constness@var1526 ( 0U ) ,
1274: typeScope@var1528 ( nullptr ) ,
1275: smartPointerType@var1529 ( nullptr ) ,
1276: smartPointerTypeToken@var1530 ( nullptr ) ,
1277: smartPointer@var1531 ( nullptr ) ,
1278: container@var1532 ( nullptr ) ,
1279: containerTypeToken@var1533 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1538 , enum Type t@var1539 , int p@var1540 , int c@var1541 )
1282: : sign@var1522 ( s@var1538 ) ,
1283: type@var1523 ( t@var1539 ) ,
1284: bits@var1524 ( 0 ) ,
1285: pointer@var1525 ( p@var1540 ) ,
1286: constness@var1526 ( c@var1541 ) ,
1287: typeScope@var1528 ( nullptr ) ,
1288: smartPointerType@var1529 ( nullptr ) ,
1289: smartPointerTypeToken@var1530 ( nullptr ) ,
1290: smartPointer@var1531 ( nullptr ) ,
1291: container@var1532 ( nullptr ) ,
1292: containerTypeToken@var1533 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1542 , enum Type t@var1543 , int p@var1544 , int c@var1545 , const std :: string & otn@var1546 )
1295: : sign@var1522 ( s@var1542 ) ,
1296: type@var1523 ( t@var1543 ) ,
1297: bits@var1524 ( 0 ) ,
1298: pointer@var1525 ( p@var1544 ) ,
1299: constness@var1526 ( c@var1545 ) ,
1300: typeScope@var1528 ( nullptr ) ,
1301: smartPointerType@var1529 ( nullptr ) ,
1302: smartPointerTypeToken@var1530 ( nullptr ) ,
1303: smartPointer@var1531 ( nullptr ) ,
1304: container@var1532 ( nullptr ) ,
1305: containerTypeToken@var1533 ( nullptr ) ,
1306: originalTypeName@var1534 ( otn@var1546 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1547 , const Settings * settings@var1548 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1549 , bool longType@var1550 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1551 , const ValueType * func@var1552 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1553 , const Variable * callVar@var1554 , const Variable * funcVar@var1555 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073745260 type@var1523 >=@expr1073745261 ValueType ::@expr1073745262 Type ::@expr1073745263 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073745264 type@var1523 >=@expr1073745265 ValueType ::@expr3442 Type ::@expr1073745267 BOOL &&@expr1073745268 type@var1523 <=@expr1073745269 ValueType ::@expr3442 Type ::@expr1073745271 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073745272 type@var1523 >=@expr1073745273 ValueType ::@expr3450 Type ::@expr1073745275 FLOAT &&@expr1073745276 type@var1523 <=@expr1073745277 ValueType ::@expr3450 Type ::@expr1073745279 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1556 , const Settings * settings@var1557 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1528 &&@expr1073745280 typeScope@var1528 .@expr1073745281 type@var1558 ==@expr1073745282 Scope ::@expr1073745283 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1559 , bool p@var1560 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1561 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1562 , const Settings * settings@var1563 , ErrorLogger * errorLogger@var1564 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1565 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1566 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1567 ;
1359:
1360:
1361: std :: list < Type > typeList@var1568 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1569 , const Token * typeTok@var1570 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1571 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1572 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1573 , const Scope * startScope@var1574 , bool lookOutside@var1575 = false ) const ;
1382: Type * findType ( const Token * startTok@var1576 , Scope * startScope@var1577 , bool lookOutside@var1578 = false ) const {
1383: return const_cast < Type *@expr3460 > (@expr1073745285 this@expr1073745286 .@expr1073745287 findType (@expr1073745288 startTok@var1576 , const_cast < const Scope *@expr3460 > (@expr1073745290 startScope@var1577 ) , lookOutside@var1578 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1579 , const Scope * startScope@var1580 ) const ;
1387: Scope * findScope ( const Token * tok@var1581 , Scope * startScope@var1582 ) const {
1388: return const_cast < Scope *@expr3467 > (@expr1073745292 this@expr1073745293 .@expr1073745294 findScope (@expr1073745295 tok@var1581 , const_cast < const Scope *@expr3467 > (@expr1073745297 startScope@var1582 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1583 ) const {
1392: return varid@var1583 <@expr1073745298 mVariableList@var1640 .@expr1073745299 size (@expr1073745300 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1584 ) const {
1396: return mVariableList@var1640 .@expr1073745301 at (@expr1073745302 varId@var1584 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1640 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1585 , const std :: string & type@var1586 , const std :: string & msg@var1587 ) const ;
1407:
1408: void printOut ( const char * title@var1588 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1589 , const char * indent@var1590 ) const ;
1410: void printXml ( std :: ostream & out@var1591 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1592 , Token * tokens@var1593 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1594 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1595 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1596 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1597 , const Token * * tok@var1598 , const Token * argStart@var1599 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1600 , const Token * tok@var1601 , const Token * argStart@var1602 , const Token * funcStart@var1603 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1604 , const Token * & tok@var1605 , const Token * argStart@var1606 , const Token * funcStart@var1607 ) ;
1469: void addNewFunction ( Scope * * scope@var1608 , const Token * * tok@var1609 ) ;
1470: bool isFunction ( const Token * tok@var1610 , const Scope * outerScope@var1611 , const Token * * funcStart@var1612 , const Token * * argStart@var1613 , const Token * * declEnd@var1614 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1615 , const Scope * startScope@var1616 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1617 , const Scope * scope@var1618 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1619 , const Scope * ns@var1620 , const std :: string & path@var1621 , int path_length@var1622 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1623 , const Token * typeTok@var1624 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1625 , const Token * vartok@var1626 , Token * membertok@var1627 , const Variable * membervar@var1628 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1629 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1630 ) const ;
1485:
1486: void setValueType ( Token * tok@var1631 , const ValueType & valuetype@var1632 ) ;
1487: void setValueType ( Token * tok@var1633 , const Variable & var@var1634 ) ;
1488: void setValueType ( Token * tok@var1635 , const Enumerator & enumerator@var1636 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1637 ;
1491: const Settings * mSettings@var1638 ;
1492: ErrorLogger * mErrorLogger@var1639 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1640 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1641 ;
1499:
1500: bool mIsCpp@var1642 ;
1501: ValueType :: Sign mDefaultSignedness@var1643 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1644 ;
1505: } ;

##file cppcheck-2.8/lib/checkboost.cpp

1:
|
27:
28: namespace {
29: CheckBoost instance@var1645 ;
30: }
31:
32: static const CWE CWE664@var1646 ( 664 ) ;
33:
34: void CheckBoost :: checkBoostForeachModification ( )
35: {
36: const SymbolDatabase * symbolDatabase@var1647 ; symbolDatabase@var1647 =@expr1073745303 mTokenizer@var28 .@expr1073745304 getSymbolDatabase (@expr1073745305 ) ;
37: for (@expr1073745306 const Scope *@expr3483 scope@var1648 :@expr1073745308 symbolDatabase@var1647 .@expr1073745309 functionScopes@var1649 ) {
38: for (@expr1073745310 const Token *@expr3483 tok@var1650 =@expr1073745312 scope@var1648 .@expr1073745313 bodyStart@var1651 .@expr1073745314 next (@expr1073745315 ) ; tok@var1650 &&@expr1073745316 tok@var1650 !=@expr1073745317 scope@var1648 .@expr1073745318 bodyEnd@var1652 ; tok@var1650 =@expr1073745319 tok@var1650 .@expr3496 next (@expr3497 ) ) {
39: if (@expr1073745322 !@expr1073745323 Token ::@expr1073745324 simpleMatch (@expr1073745325 tok@var1650 , "BOOST_FOREACH (" ) ) {
40: continue ; }
41:
42: const Token * containerTok@var1653 ; containerTok@var1653 =@expr1073745326 tok@var1650 .@expr3496 next (@expr3497 ) .@expr1073745329 link (@expr1073745330 ) .@expr1073745331 previous (@expr1073745332 ) ;
43: if (@expr1073745333 !@expr1073745334 Token ::@expr3511 Match (@expr1073745336 containerTok@var1653 , "%var% ) {" ) ) {
44: continue ; }
45:
46: const Token * tok2@var1654 ; tok2@var1654 =@expr1073745337 containerTok@var1653 .@expr1073745338 tokAt (@expr1073745339 2 ) ;
47: const Token * end@var1655 ; end@var1655 =@expr1073745340 tok2@var1654 .@expr1073745341 link (@expr1073745342 ) ;
48: for (@expr1073745343 ; tok2@var1654 !=@expr1073745344 end@var1655 ; tok2@var1654 =@expr1073745345 tok2@var1654 .@expr1073745346 next (@expr1073745347 ) ) {
49: if (@expr1073745348 Token ::@expr3511 Match (@expr1073745350 tok2@var1654 , "%varid% . insert|erase|push_back|push_front|pop_front|pop_back|clear|swap|resize|assign|merge|remove|remove_if|reverse|sort|splice|unique|pop|push" , containerTok@var1653 .@expr1073745351 varId (@expr1073745352 ) ) ) {
50: const Token * nextStatement@var1656 ; nextStatement@var1656 =@expr1073745353 Token ::@expr1073745354 findsimplematch (@expr1073745355 tok2@var1654 .@expr1073745356 linkAt (@expr1073745357 3 ) , ";" , end@var1655 ) ;
51: if (@expr1073745358 !@expr1073745359 Token ::@expr3511 Match (@expr1073745361 nextStatement@var1656 , "; break|return|throw" ) ) {
52: boostForeachError (@expr1073745362 tok2@var1654 ) ; }
53: break ;
54: }
55: }
56: }
57: }
58: }
59:
60: void CheckBoost :: boostForeachError ( const Token * tok@var1657 )
61: {
62: reportError (@expr1073745363 tok@var1657 , Severity ::@expr1073745364 error , "boostForeachError" ,
63: "BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside." , CWE664@var1646 , Certainty ::@expr1073745365 normal
64: ) ;
65: }



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  severity possible 1@1
  id possible "boostForeachError"@1
  msg possible "BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside."@1
  certainty possible 0@1
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@254,128@255,64,32@1,16@2,8@3,4@4,2@5,1@6}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@7,128@8,64@9,32@10,16@11,8@12,4@13,2@14,1@15}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@7,4294967167@8,4294967231@9,4294967263@10,4294967279@11,4294967287@12,4294967291@13,4294967293@14,4294967294@15}
  flag {!<=-1,256@7,128@8,64@9,32@10,16@11,8@12,4@13,2@14,1@15}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@39932,34@40188}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@155,34@156}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@155,""@156,""@157,"U"@158,"U"@159,"u"@160,"u"@161,"u8"@162,"u8"@163}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@249,34@250}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@246,34@248}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pattern possible "BOOST_FOREACH ("@5
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@144,4@145,0@146}
  t possible {10@144,4@145,0@146}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@144,4@145,0@146}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@144,0@146}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@144,0@146}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@144}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@144}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@144}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@144}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@144}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@152}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible ";"@12
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@154,17179869184@165,8589934592@167,34359738368@169,4294967296@171,2147483648@173,1073741824@175,536870912@177,268435456@179}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@241,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@242}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@153,17179869184@164,8589934592@166,34359738368@168,4294967296@170,2147483648@172,1073741824@174,536870912@176,268435456@178}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@153,17179869184@164,8589934592@166,34359738368@168,4294967296@170,2147483648@172,1073741824@174,536870912@176,268435456@178}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 43
  ( always "Boost usage"
Line 47
  ( always "Boost usage"
Line 51
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 65
  nullptr always 0
Line 66
  nullptr always 0
Line 70
  "Boost usage" always "Boost usage"
Line 74
  "Check for invalid usage of Boost:\n- container modification during BOOST_FOREACH\n" always "Check for invalid usage of Boost:\n- container modification during BOOST_FOREACH\n"
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@74,4096@77,16384@80,2048@81,1024@82,65536@83,512@84,256@85,128@86}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@39,4194304@41,8388608@42,2097152@44,1048576@45,524288@46,262144@47,131072@48,65536@49}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@17,4292870143@18,4293918719@19,4294443007@20,4294705151@21,4294836223@22,4294901759@23,4294934527@24,4294950911@25}
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 32
  664 always 664
Line 37
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 38
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 39
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "BOOST_FOREACH (" always "BOOST_FOREACH ("
Line 43
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  containerTok always symbolic=(tok->next()->link()->previous())
  "%var% ) {" always "%var% ) {"
Line 46
  containerTok always symbolic=(tok->next()->link()->previous())
  2 always 2
Line 48
  != always {!<=-1,!>=2}
  end possible symbolic=(tok2->link())
Line 49
  ( always {!<=-1,!>=2}
  "%varid% . insert|erase|push_back|push_front|pop_front|pop_back|clear|swap|resize|assign|merge|remove|remove_if|reverse|sort|splice|unique|pop|push" always "%varid% . insert|erase|push_back|push_front|pop_front|pop_back|clear|swap|resize|assign|merge|remove|remove_if|reverse|sort|splice|unique|pop|push"
  containerTok always symbolic=(tok->next()->link()->previous())
Line 50
  3 always 3
  ";" always ";"
Line 51
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "; break|return|throw" always "; break|return|throw"
Line 62
  tok possible 0@117
  :: always 1
  error always 1
  "boostForeachError" always "boostForeachError"
Line 63
  "BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside." always "BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside."
  :: always 0
  normal always 0
