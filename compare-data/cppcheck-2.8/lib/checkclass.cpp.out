

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073745265 !@expr1073745266 mTokenizer@var28 ) {
69: instances (@expr1073745267 ) .@expr1073745268 remove (@expr1073745269 this@expr1073745270 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073745271 string (@expr1073745272 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073745273 void ) tokenizer@var21 ;
108: (@expr1073745274 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073745275 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073745276 void ) ctu@var24 ;
120: (@expr1073745277 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073745278 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073745279 0U ) , Certainty ::@expr1073745280 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073745281 list < const Token *@expr1073745282 > callstack@var41 (@expr1073745283 1 , tok@var35 ) ;
141: reportError (@expr1073745284 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073745285 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073745286 0U ) , Certainty ::@expr1073745287 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var64 ;
42: double mDoubleValue@var65 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var66 ;
44: bool mIsUnsigned@var67 ;
45:
46: void promote ( const value & v@var68 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var69 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var66 !=@expr1073745288 Type ::@expr1073745289 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var66 ==@expr1073745290 Type ::@expr1073745291 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745292 ) ?@expr1073745293 mDoubleValue@var65 :@expr1073745294 (@expr1073745295 double ) mIntValue@var64 ;
60: }
61:
62: static value calc ( char op@var70 , const value & v1@var71 , const value & v2@var72 ) ;
63: int compare ( const value & v@var73 ) const ;
64: value add ( int v@var74 ) const ;
65: value shiftLeft ( const value & v@var75 ) const ;
66: value shiftRight ( const value & v@var76 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var77 ;
72:
73: static long long toLongNumber ( const std :: string & str@var78 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var79 ) ;
75:
76: template < class T > static std :: string toString ( T value@var80 ) {
77: std ::@expr1073745296 ostringstream result@var81 ;
78: result@var81 <<@expr1073745297 value@var80 ;
79: return result@var81 .@expr1073745298 str (@expr1073745299 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var82 ) ;
82:
83: static bool isInt ( const std :: string & str@var83 ) ;
84: static bool isFloat ( const std :: string & str@var84 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var85 ) ;
86: static bool isNegative ( const std :: string & str@var86 ) ;
87: static bool isPositive ( const std :: string & str@var87 ) ;
88: static bool isDec ( const std :: string & str@var88 ) ;
89: static bool isFloatHex ( const std :: string & str@var89 ) ;
90: static bool isIntHex ( const std :: string & str@var90 ) ;
91: static bool isOct ( const std :: string & str@var91 ) ;
92: static bool isBin ( const std :: string & str@var92 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var93 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var94 , bool supportMicrosoftExtensions@var95 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var96 , const std :: string & second@var97 ) ;
105: static std :: string subtract ( const std :: string & first@var98 , const std :: string & second@var99 ) ;
106: static std :: string multiply ( const std :: string & first@var100 , const std :: string & second@var101 ) ;
107: static std :: string divide ( const std :: string & first@var102 , const std :: string & second@var103 ) ;
108: static std :: string mod ( const std :: string & first@var104 , const std :: string & second@var105 ) ;
109: static std :: string incdec ( const std :: string & var@var106 , const std :: string & op@var107 ) ;
110: static std :: string calculate ( const std :: string & first@var108 , const std :: string & second@var109 , char action@var110 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var111 ) ;
113: static std :: string cos ( const std :: string & tok@var112 ) ;
114: static std :: string tan ( const std :: string & tok@var113 ) ;
115: static std :: string abs ( const std :: string & tok@var114 ) ;
116: static bool isEqual ( const std :: string & first@var115 , const std :: string & second@var116 ) ;
117: static bool isNotEqual ( const std :: string & first@var117 , const std :: string & second@var118 ) ;
118: static bool isGreater ( const std :: string & first@var119 , const std :: string & second@var120 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var121 , const std :: string & second@var122 ) ;
120: static bool isLess ( const std :: string & first@var123 , const std :: string & second@var124 ) ;
121: static bool isLessEqual ( const std :: string & first@var125 , const std :: string & second@var126 ) ;
122: static bool isNullValue ( const std :: string & str@var127 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var128 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var129 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var130 , std :: string :: size_type iPos@var131 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var132 , const MathLib :: value & v2@var133 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var134 , const MathLib :: value & v2@var135 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var136 , const MathLib :: value & v2@var137 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var138 , const MathLib :: value & v2@var139 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var140 , const MathLib :: value & v2@var141 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var142 , const MathLib :: value & v2@var143 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var144 , const MathLib :: value & v2@var145 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var146 , const MathLib :: value & v2@var147 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var148 , const MathLib :: value & v2@var149 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var150 , const MathLib :: value & v2@var151 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var152 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var153 ) const {
54: x@var153 ++@expr1073745300 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var154 ) const {
60: x@var154 --@expr1073745301 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var155 , const U & y@var156 ) const {
67: return x@var155 <@expr1073745302 y@var156 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var157 , const U & y@var158 ) const {
74: return std ::@expr1073745303 abs (@expr1073745304 x@var157 -@expr1073745305 y@var158 ) ==@expr1073745306 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var159 , T x@var160 , U y@var161 ) const {
81: result@var159 =@expr1073745307 !@expr1073745308 (@expr1073745309 x@var160 >@expr1073745310 y@var161 ||@expr1073745311 x@var160 <@expr1073745312 y@var161 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var162 = 0 , Bound b@var163 = Bound :: Point )
91: : valueType@var203 ( ValueType :: INT ) ,
92: bound@var204 ( b@var163 ) ,
93: intvalue@var205 ( val@var162 ) ,
94: tokvalue@var206 ( nullptr ) ,
95: floatValue@var207 ( 0.0 ) ,
96: moveKind@var208 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var209 ( val@var162 ) ,
98: condition@var210 ( nullptr ) ,
99: varId@var212 ( 0U ) ,
100: safe@var213 ( false ) ,
101: conditional@var214 ( false ) ,
102: macro@var215 ( false ) ,
103: defaultArg@var216 ( false ) ,
104: indirect@var217 ( 0 ) ,
105: path@var218 ( 0 ) ,
106: wideintvalue@var219 ( val@var162 ) ,
107: subexpressions@var220 ( ) ,
108: capturetok@var221 ( nullptr ) ,
109: lifetimeKind@var222 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var223 ( LifetimeScope :: Local ) ,
111: valueKind@var228 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var164 , long long val@var165 , Bound b@var166 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var167 ) const {
118: if (@expr1073745313 valueType@var203 !=@expr1073745314 rhs@var167 .@expr1073745315 valueType@var168 ) {
119: return false ; }
120: switch (@expr1073745316 valueType@var203 ) {
121: case ValueType ::@expr1073745317 INT :@expr3494
122: case ValueType ::@expr1073745319 CONTAINER_SIZE :@expr3494
123: case ValueType ::@expr1073745321 BUFFER_SIZE :@expr3494
124: case ValueType ::@expr1073745323 ITERATOR_START :@expr3494
125: case ValueType ::@expr1073745325 ITERATOR_END :@expr3494 ;
126: if (@expr3503 intvalue@var205 !=@expr3504 rhs@var167 .@expr3505 intvalue@var169 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745330 TOK :@expr3494 ;
130: if (@expr3508 tokvalue@var206 !=@expr3509 rhs@var167 .@expr3510 tokvalue@var170 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745335 FLOAT :@expr3494 ;
134:
135: if (@expr1073745337 floatValue@var207 >@expr1073745338 rhs@var167 .@expr3515 floatValue@var171 ||@expr1073745340 floatValue@var207 <@expr1073745341 rhs@var167 .@expr3515 floatValue@var171 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745343 MOVED :@expr3494 ;
139: if (@expr1073745345 moveKind@var208 !=@expr1073745346 rhs@var167 .@expr1073745347 moveKind@var172 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745348 UNINIT :@expr3494 ;
143: break ;
144: case ValueType ::@expr1073745350 LIFETIME :@expr3494 ;
145: if (@expr3508 tokvalue@var206 !=@expr3509 rhs@var167 .@expr3510 tokvalue@var170 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745355 SYMBOLIC :@expr3494 ;
149: if (@expr1073745357 !@expr1073745358 sameToken (@expr1073745359 tokvalue@var206 , rhs@var167 .@expr3510 tokvalue@var170 ) ) {
150: return false ; }
151: if (@expr3503 intvalue@var205 !=@expr3504 rhs@var167 .@expr3505 intvalue@var169 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var173 , F f@var174 ) {
160: switch (@expr1073745364 self@var173 .@expr1073745365 valueType@var175 ) {
161: case ValueType ::@expr1073745366 INT :@expr3543
162: case ValueType ::@expr1073745368 SYMBOLIC :@expr3543
163: case ValueType ::@expr1073745370 BUFFER_SIZE :@expr3543
164: case ValueType ::@expr1073745372 CONTAINER_SIZE :@expr3543
165: case ValueType ::@expr1073745374 ITERATOR_START :@expr3543
166: case ValueType ::@expr1073745376 ITERATOR_END :@expr3543 ; {
167: f@var174 (@expr1073745378 self@var173 .@expr1073745379 intvalue@var176 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745380 FLOAT :@expr3543 ; {
171: f@var174 (@expr1073745382 self@var173 .@expr1073745383 floatValue@var177 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745384 UNINIT :@expr3543
175: case ValueType ::@expr1073745386 TOK :@expr3543
176: case ValueType ::@expr1073745388 LIFETIME :@expr3543
177: case ValueType ::@expr1073745390 MOVED :@expr3543 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var178 , Compare compare@var179 , T x@var180 , U y@var181 ) const {
186: result@var178 =@expr1073745392 compare@var179 (@expr1073745393 x@var180 , y@var181 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var182 , const Value & rhs@var183 , Compare compare@var184 , T x@var185 ) const {
191: visitValue (@expr1073745395 rhs@var183 ,
192: std ::@expr1073745396 bind (@expr1073745397 innerVisitor {@expr1073745398 } , std ::@expr1073745399 ref (@expr1073745400 result@var182 ) , std ::@expr1073745401 move (@expr1073745402 compare@var184 ) , x@var185 , std ::@expr1073745403 placeholders ::@expr1073745404 _1@expr1073745394 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var186 , Compare compare@var187 ) const {
198: assert (@expr1073745406 (@expr1073745407 !@expr1073745408 this@expr3585 .@expr1073745410 isSymbolicValue (@expr1073745411 ) &&@expr1073745412 !@expr1073745413 rhs@var186 .@expr1073745414 isSymbolicValue (@expr1073745415 ) ) ||@expr1073745416
199: (@expr1073745417 this@expr3585 .@expr1073745418 valueType@var203 ==@expr1073745419 rhs@var186 .@expr1073745420 valueType@var188 &&@expr1073745421 sameToken (@expr1073745422 this@expr3585 .@expr1073745423 tokvalue@var206 , rhs@var186 .@expr1073745424 tokvalue@var189 ) ) ) ;
200: bool result@var190 ; result@var190 =@expr1073745425 false ;
201: visitValue (@expr1073745426
202: *@expr1073745427 this@expr3585 ,
203: std ::@expr1073745428 bind (@expr1073745429 compareVisitor {@expr1073745430 } , std ::@expr3607 ref (@expr1073745432 result@var190 ) , std ::@expr3607 ref (@expr1073745434 rhs@var186 ) , std ::@expr1073745435 move (@expr1073745436 compare@var187 ) , std ::@expr1073745437 placeholders ::@expr1073745438 _1@expr1073745405 ) ) ;
204: return result@var190 ;
205: }
206:
207: bool operator== ( const Value & rhs@var191 ) const {
208: if (@expr1073745439 !@expr1073745440 equalValue (@expr1073745441 rhs@var191 ) ) {
209: return false ; }
210:
211: return varvalue@var209 ==@expr1073745442 rhs@var191 .@expr1073745443 varvalue@var192 &&@expr1073745444
212: condition@var210 ==@expr1073745445 rhs@var191 .@expr1073745446 condition@var193 &&@expr1073745447
213: varId@var212 ==@expr1073745448 rhs@var191 .@expr1073745449 varId@var194 &&@expr1073745450
214: conditional@var214 ==@expr1073745451 rhs@var191 .@expr1073745452 conditional@var195 &&@expr1073745453
215: defaultArg@var216 ==@expr1073745454 rhs@var191 .@expr1073745455 defaultArg@var196 &&@expr1073745456
216: indirect@var217 ==@expr1073745457 rhs@var191 .@expr1073745458 indirect@var197 &&@expr1073745459
217: valueKind@var228 ==@expr1073745460 rhs@var191 .@expr1073745461 valueKind@var198 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var199 ) const {
221: return !@expr1073745462 (@expr1073745463 *@expr1073745464 this@expr1073745465 ==@expr1073745466 rhs@var199 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var200 ) const {
226: bool result@var201 ; result@var201 =@expr1073745468 false ;
227: visitValue (@expr1073745469 *@expr1073745470 this@expr1073745471 , std ::@expr1073745472 bind (@expr1073745473 equalVisitor {@expr1073745474 } , std ::@expr1073745475 ref (@expr1073745476 result@var201 ) , x@var200 , std ::@expr1073745477 placeholders ::@expr1073745478 _1@expr1073745467 ) ) ;
228: return result@var201 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745479 bound@var204 ==@expr1073745480 Bound ::@expr1073745481 Lower ) {
233: visitValue (@expr1073745482 *@expr3659 this@expr3660 , increment {@expr1073745485 } ) ; }
234: else { if (@expr1073745486 bound@var204 ==@expr1073745487 Bound ::@expr1073745488 Upper ) {
235: visitValue (@expr1073745489 *@expr3659 this@expr3660 , decrement {@expr1073745491 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745492 bound@var204 ==@expr1073745493 Bound ::@expr3670 Lower ) {
240: bound@var204 =@expr1073745495 Bound ::@expr3672 Upper ; }
241: else { if (@expr1073745497 bound@var204 ==@expr1073745498 Bound ::@expr3672 Upper ) {
242: bound@var204 =@expr1073745500 Bound ::@expr3670 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745502 ) ;
247: decreaseRange (@expr1073745503 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var202 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var203 ;
267: bool isIntValue ( ) const {
268: return valueType@var203 ==@expr1073745504 ValueType ::@expr1073745505 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var203 ==@expr1073745506 ValueType ::@expr1073745507 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var203 ==@expr1073745508 ValueType ::@expr1073745509 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var203 ==@expr1073745510 ValueType ::@expr1073745511 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var203 ==@expr1073745512 ValueType ::@expr1073745513 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var203 ==@expr1073745514 ValueType ::@expr1073745515 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var203 ==@expr1073745516 ValueType ::@expr1073745517 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var203 ==@expr1073745518 ValueType ::@expr1073745519 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var203 ==@expr1073745520 ValueType ::@expr1073745521 ITERATOR_START ||@expr1073745522 valueType@var203 ==@expr1073745523 ValueType ::@expr1073745524 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var203 ==@expr1073745525 ValueType ::@expr1073745526 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var203 ==@expr1073745527 ValueType ::@expr1073745528 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var203 ==@expr1073745529 ValueType ::@expr1073745530 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var203 ==@expr1073745532 ValueType ::@expr1073745533 LIFETIME &&@expr1073745534 lifetimeScope@var223 ==@expr1073745535 LifetimeScope ::@expr1073745536 Local@expr1073745531 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var203 ==@expr1073745537 ValueType ::@expr1073745538 LIFETIME &&@expr1073745539 lifetimeScope@var223 ==@expr1073745540 LifetimeScope ::@expr1073745541 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var203 ==@expr1073745542 ValueType ::@expr1073745543 LIFETIME &&@expr1073745544 lifetimeScope@var223 ==@expr1073745545 LifetimeScope ::@expr1073745546 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745547 ) ||@expr1073745548 isUninitValue (@expr1073745549 ) ||@expr1073745550 isLifetimeValue (@expr1073745551 ) ;
318: }
319:
320:
321: Bound bound@var204 ;
322:
323:
324: long long intvalue@var205 ;
325:
326:
327: const Token * tokvalue@var206 ;
328:
329:
330: double floatValue@var207 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var208 ;
334:
335:
336: long long varvalue@var209 ;
337:
338:
339: const Token * condition@var210 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var211 ;
342:
343:
344: int varId@var212 ;
345:
346:
347: bool safe@var213 ;
348:
349:
350: bool conditional@var214 ;
351:
352:
353: bool macro@var215 ;
354:
355:
356: bool defaultArg@var216 ;
357:
358: int indirect@var217 ;
359:
360:
361: long long path@var218 ;
362:
363:
364: long long wideintvalue@var219 ;
365:
366: std :: vector < std :: string > subexpressions@var220 ;
367:
368:
369: const Token * capturetok@var221 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var222 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var223 ;
385:
386: static const char * toString ( MoveKind moveKind@var224 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var225 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var226 ) ;
389: static const char * toString ( Bound bound@var227 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var228 ;
402:
403: void setKnown ( ) {
404: valueKind@var228 =@expr1073745552 ValueKind ::@expr1073745553 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var228 ==@expr1073745554 ValueKind ::@expr1073745555 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var228 =@expr1073745557 ValueKind ::@expr1073745558 Possible@expr1073745556 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var228 ==@expr1073745560 ValueKind ::@expr1073745561 Possible@expr1073745559 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var228 ==@expr1073745562 ValueKind ::@expr1073745563 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var228 =@expr1073745564 ValueKind ::@expr1073745565 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var229 = true ) {
428: if (@expr1073745566 inconclusive@var229 ) {
429: valueKind@var228 =@expr1073745567 ValueKind ::@expr1073745568 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var228 ==@expr1073745569 ValueKind ::@expr1073745570 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745572 isKnown (@expr1073745573 ) ) {
438: valueKind@var228 =@expr1073745574 ValueKind ::@expr1073745575 Possible@expr1073745571 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745576 condition@var210 &&@expr1073745577 !@expr1073745578 defaultArg@var216 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var230 , const Token * tok2@var231 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var232 , const Settings * settings@var233 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var234 , SymbolDatabase * symboldatabase@var235 , ErrorLogger * errorLogger@var236 , const Settings * settings@var237 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var238 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var239 , const Settings * settings@var240 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var241 ,
459: const Settings * settings@var242 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var243 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var244 , const Token * indexTok@var245 , bool possible@var246 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var247 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var248 , const Settings * settings@var249 = nullptr , int depth@var250 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var251 ;
471: bool addressOf@var252 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var253 ;
473: bool inconclusive@var254 ;
474:
475: LifetimeToken ( ) : token@var251 ( nullptr ) , addressOf@var252 ( false ) , errorPath@var253 ( ) , inconclusive@var254 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var255 , ValueFlow :: Value :: ErrorPath errorPath@var256 )
478: : token@var251 ( token@var255 ) , addressOf@var252 ( false ) , errorPath@var253 ( std :: move ( errorPath@var256 ) ) , inconclusive@var254 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var257 , bool addressOf@var258 , ValueFlow :: Value :: ErrorPath errorPath@var259 )
482: : token@var251 ( token@var257 ) , addressOf@var252 ( addressOf@var258 ) , errorPath@var253 ( std :: move ( errorPath@var259 ) ) , inconclusive@var254 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var260 , bool b@var261 ) {
486: for (@expr1073745579 LifetimeToken &@expr1073745580 x@var262 :@expr1073745581 v@var260 ) {
487: x@var262 .@expr1073745582 addressOf@var263 =@expr1073745583 b@var261 ; }
488: return v@var260 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var264 , bool b@var265 ) {
492: for (@expr1073745584 LifetimeToken &@expr1073745585 x@var266 :@expr1073745586 v@var264 ) {
493: x@var266 .@expr1073745587 inconclusive@var267 =@expr1073745588 b@var265 ; }
494: return v@var264 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var268 , ValueFlow :: Value & true_value@var269 , ValueFlow :: Value & false_value@var270 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var271 ) ;
499: const Token * parseCompareInt ( const Token * tok@var272 , ValueFlow :: Value & true_value@var273 , ValueFlow :: Value & false_value@var274 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var275 , long long val@var276 , const Token * varTok@var277 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var278 , const Token * varTok@var279 , long long val@var280 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var281 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var282 ,
508: ValueFlow :: Value & value@var283 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var284 ,
511: bool escape@var285 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var286 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var287 , const Token * lifetime@var288 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var289 , ValueFlow :: Value :: ErrorPath & errorPath@var290 , bool * addressOf@var291 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var292 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var293 , const Settings * settings@var294 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var295 , const ValueFlow :: Value * val@var296 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var297 , const ValueFlow :: Value * val@var298 , ValueFlow :: Value :: ErrorPath & errorPath@var299 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var300 , bool inconclusive@var301 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var302 ,
529: bool inconclusive@var303 = false ,
530: long long path@var304 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var305 , const Scope * defaultScope@var306 = nullptr , bool smallest@var307 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var308 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var309 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var310 ;
69: std :: string mScope@var311 ;
70: std :: string mName@var312 ;
71: std :: string mFullName@var313 ;
72: const Token * mNameToken@var314 ;
73: const Token * mParamEnd@var315 ;
74: unsigned int mFlags@var316 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var317 ) {
90: setFlag (@expr1073745589 fIsClass , state@var317 ) ;
91: }
92: void isFunction ( bool state@var318 ) {
93: setFlag (@expr1073745590 fIsFunction , state@var318 ) ;
94: }
95: void isVariable ( bool state@var319 ) {
96: setFlag (@expr1073745591 fIsVariable , state@var319 ) ;
97: }
98: void isAlias ( bool state@var320 ) {
99: setFlag (@expr1073745592 fIsAlias , state@var320 ) ;
100: }
101: void isSpecialization ( bool state@var321 ) {
102: setFlag (@expr1073745593 fIsSpecialization , state@var321 ) ;
103: }
104: void isPartialSpecialization ( bool state@var322 ) {
105: setFlag (@expr1073745594 fIsPartialSpecialization , state@var322 ) ;
106: }
107: void isForwardDeclaration ( bool state@var323 ) {
108: setFlag (@expr1073745595 fIsForwardDeclaration , state@var323 ) ;
109: }
110: void isVariadic ( bool state@var324 ) {
111: setFlag (@expr1073745596 fIsVariadic , state@var324 ) ;
112: }
113: void isFriend ( bool state@var325 ) {
114: setFlag (@expr1073745597 fIsFriend , state@var325 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var326 ) const {
123: return (@expr3774 (@expr3774 mFlags@var316 &@expr1073745600 flag@var326 ) !=@expr1073745601 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var327 , bool state@var328 ) {
132: mFlags@var316 =@expr1073745602 state@var328 ?@expr1073745603 mFlags@var316 |@expr1073745604 flag@var327 :@expr1073745605 mFlags@var316 &@expr1073745606 ~@expr1073745607 flag@var327 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var329 , const std :: string & scope@var330 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var331 , const std :: string & scope@var332 , const Token * nameToken@var333 , const Token * paramEnd@var334 ) ;
150: TokenAndName ( const TokenAndName & other@var335 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var336 ) const {
154: return mToken@var310 ==@expr1073745608 rhs@var336 .@expr1073745609 mToken@var337 &&@expr1073745610 mScope@var311 ==@expr1073745611 rhs@var336 .@expr1073745612 mScope@var338 &&@expr1073745613 mName@var312 ==@expr1073745614 rhs@var336 .@expr1073745615 mName@var339 &&@expr1073745616 mFullName@var313 ==@expr1073745617 rhs@var336 .@expr1073745618 mFullName@var340 &&@expr1073745619
155: mNameToken@var314 ==@expr1073745620 rhs@var336 .@expr1073745621 mNameToken@var341 &&@expr1073745622 mParamEnd@var315 ==@expr1073745623 rhs@var336 .@expr1073745624 mParamEnd@var342 &&@expr1073745625 mFlags@var316 ==@expr1073745626 rhs@var336 .@expr1073745627 mFlags@var343 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var310 ;
160: }
161: void token ( Token * token@var344 ) {
162: mToken@var310 =@expr1073745628 token@var344 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var311 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var312 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var313 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var314 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var315 ;
178: }
179: void paramEnd ( const Token * end@var345 ) {
180: mParamEnd@var315 =@expr1073745629 end@var345 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745630 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745631 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745632 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745633 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745634 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745635 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745636 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745637 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745638 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var346 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var347 ) const {
243:
244:
245: return (@expr3815 (@expr3815 mFlags@var316 &@expr1073745641 fFamilyMask ) &@expr1073745642 (@expr3815 decl@var347 .@expr1073745644 mFlags@var348 &@expr1073745645 fFamilyMask ) ) !=@expr1073745646 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var349 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var350 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var351 , const unsigned long numberOfArguments@var352 , bool variadic@var353 , const char patternAfter@var354 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var355 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var356 , int & namepos@var357 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var358 , int & namepos@var359 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var360 , int & namepos@var361 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var362 ,
306: bool & codeWithTemplates@var363 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var364 , bool isTemplate@var365 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var366 = nullptr , Token * backToken@var367 = nullptr , bool isTemplate@var368 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var369 , Token * end@var370 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var371 , const std :: string & scope@var372 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var373 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var374 ,
393: const std :: list < const Token * > & specializations@var375 ,
394: const std :: time_t maxtime@var376 ,
395: std :: set < std :: string > & expandedtemplates@var377 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var378 , const Token * tok@var379 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var380 , const Token * tok@var381 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var382 ,
422: const TokenAndName & templateInstantiation@var383 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var384 ,
424: const std :: string & newName@var385 ,
425: bool copy@var386 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var387 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var388 ,
435: const std :: string & newName@var389 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var390 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var391 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var392 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var393 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var394 ,
458: const Token * templateInstantiationNameToken@var395 ,
459: const std :: list < const Token * > & specializations@var396 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var397 , const Token * end@var398 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var399 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var400 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var401 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var402 ,
487: const std :: string & indent@var403 = "    " ) const ;
488: void printOut ( const std :: string & text@var404 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var405 ;
491: TokenList & mTokenList@var406 ;
492: const Settings * mSettings@var407 ;
493: ErrorLogger * mErrorLogger@var408 ;
494: bool mChanged@var409 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var410 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var411 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var412 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var413 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var414 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var415 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var416 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var417 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var418 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var419 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var420 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var421 ) const {
35: return p@var421 .@expr1073745647 first@var422 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var423 ) const {
42: return p@var423 .@expr1073745648 second@var424 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var425 , const T & x@var426 )
48: {
49: return std ::@expr1073745649 find (@expr1073745650 r@var425 .@expr1073745651 begin (@expr1073745652 ) , r@var425 .@expr3829 end (@expr3830 ) , x@var426 ) !=@expr1073745655 r@var425 .@expr3829 end (@expr3830 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var427 , const T & x@var428 )
54: {
55: return std ::@expr1073745658 find (@expr1073745659 r@var427 .@expr1073745660 begin (@expr1073745661 ) , r@var427 .@expr3838 end (@expr3839 ) , x@var428 ) !=@expr1073745664 r@var427 .@expr3838 end (@expr3839 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var429 , const U & x@var430 )
60: {
61: return std ::@expr1073745667 find (@expr1073745668 r@var429 .@expr1073745669 begin (@expr1073745670 ) , r@var429 .@expr3847 end (@expr3848 ) , x@var430 ) !=@expr1073745673 r@var429 .@expr3847 end (@expr3848 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var431 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745676 t@var431 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var432 , char c@var433 )
74: {
75: return !@expr1073745677 str@var432 .@expr1073745678 empty (@expr1073745679 ) &&@expr1073745680 str@var432 .@expr1073745681 back (@expr1073745682 ) ==@expr1073745683 c@var433 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var434 , const char end@var435 [ ] , unsigned long endlen@var436 )
79: {
80: return (@expr3860 str@var434 .@expr3861 size (@expr3862 ) >=@expr1073745687 endlen@var436 ) &&@expr1073745688 (@expr3860 str@var434 .@expr1073745690 compare (@expr1073745691 str@var434 .@expr3861 size (@expr3862 ) -@expr1073745694 endlen@var436 , endlen@var436 , end@var435 ) ==@expr1073745695 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var437 , const char ( & end@var438 ) [ N ] )
85: {
86: return endsWith (@expr1073745697 str@var437 , end@var438 , N@expr1073745696 -@expr1073745698 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var439 , char q@var440 , const std :: string & p@var441 )
90: {
91: if (@expr1073745699 !@expr1073745700 endsWith (@expr1073745701 str@var439 , q@var440 ) ) {
92: return false ; }
93: if (@expr1073745702 (@expr1073745703 str@var439 .@expr1073745704 length (@expr1073745705 ) +@expr1073745706 1 ) >@expr1073745707 p@var441 .@expr1073745708 length (@expr1073745709 ) &&@expr1073745710 (@expr1073745711 str@var439 .@expr1073745712 compare (@expr1073745713 0 , p@var441 .@expr1073745714 size (@expr1073745715 ) +@expr1073745716 1 , p@var441 +@expr1073745717 q@var440 ) ==@expr1073745718 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var442 , char q@var443 )
99: {
100: static const std ::@expr3895 vector < std ::@expr3895 string > suffixes@var444 {@expr1073745721 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745722 const std ::@expr3895 string &@expr1073745724 p@var445 :@expr1073745725 suffixes@var444 ) {
102: if (@expr1073745726 isPrefixStringCharLiteral (@expr1073745727 str@var442 , q@var443 , p@var445 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var446 )
109: {
110: return isStringCharLiteral (@expr1073745728 str@var446 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var447 )
114: {
115: return isStringCharLiteral (@expr1073745729 str@var447 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var448 , char q@var449 )
119: {
120: const unsigned long quotePos@var450 =@expr1073745730 str@var448 .@expr1073745731 find (@expr1073745732 q@var449 ) ;
121: return str@var448 .@expr1073745733 substr (@expr1073745734 quotePos@var450 +@expr1073745735 1U , str@var448 .@expr1073745736 size (@expr1073745737 ) -@expr1073745738 quotePos@var450 -@expr1073745739 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var451 )
125: {
126: if (@expr1073745740 isStringLiteral (@expr1073745741 str@var451 ) ) {
127: return getStringCharLiteral (@expr1073745742 str@var451 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var452 )
132: {
133: if (@expr1073745743 isCharLiteral (@expr1073745744 str@var452 ) ) {
134: return getStringCharLiteral (@expr1073745745 str@var452 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var453 )
139: {
140: if (@expr1073745746 i@var453 ==@expr1073745747 1 ) {
141: return "st" ; }
142: if (@expr1073745748 i@var453 ==@expr1073745749 2 ) {
143: return "nd" ; }
144: if (@expr1073745750 i@var453 ==@expr1073745751 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var454 , const std :: string & rhs@var455 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var456 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var457 , const std :: string & name@var458 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var459 , const std :: string & name@var460 ) ;
156:
157: void strTolower ( std :: string & str@var461 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var462 ;
57: Token * back@var463 ;
58: const TokenList * list@var464 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var465 , const Token * bodyEnd_@var466 , const std :: set < std :: string > & usingNamespaces_@var467 = std :: set < std :: string > ( ) ) : name@var468 ( name_@var465 ) , bodyEnd@var469 ( bodyEnd_@var466 ) , usingNamespaces@var470 ( usingNamespaces_@var467 ) { }
63: std :: string name@var468 ;
64: const Token * const bodyEnd@var469 ;
65: std :: set < std :: string > usingNamespaces@var470 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var471 ;
70: int mFileIndex@var472 ;
71: int mLineNumber@var473 ;
72: int mColumn@var474 ;
73: int mExprId@var475 ;
74:
75:
76: Token * mAstOperand1@var476 ;
77: Token * mAstOperand2@var477 ;
78: Token * mAstParent@var478 ;
79:
80:
81: const Scope * mScope@var479 ;
82: union {
83: const Function * mFunction@var480 ;
84: const Variable * mVariable@var481 ;
85: const :: Type * mType@var482 ;
86: const Enumerator * mEnumerator@var483 ;
87: } ;
88:
|
92:
93: int mProgressValue@var484 ;
94:
|
97:
98: int mIndex@var485 ;
99:
100:
101: std :: string * mOriginalName@var486 ;
102:
103:
104: ValueType * mValueType@var487 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var488 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var489 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var490 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var491 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var492 ;
119: long long value@var493 ;
120: struct CppcheckAttributes * next@var494 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var495 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var496 ;
126:
127:
128: unsigned char mBits@var497 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var498 , long long value@var499 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var500 , long long * value@var501 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var471 ( 0 )
135: , mFileIndex@var472 ( 0 )
136: , mLineNumber@var473 ( 0 )
137: , mColumn@var474 ( 0 )
138: , mExprId@var475 ( 0 )
139: , mAstOperand1@var476 ( nullptr )
140: , mAstOperand2@var477 ( nullptr )
141: , mAstParent@var478 ( nullptr )
142: , mScope@var479 ( nullptr )
143: , mFunction@var480 ( nullptr )
144: , mProgressValue@var484 ( 0 )
145: , mIndex@var485 ( 0 )
146: , mOriginalName@var486 ( nullptr )
147: , mValueType@var487 ( nullptr )
148: , mValues@var488 ( nullptr )
149: , mTemplateSimplifierPointers@var490 ( nullptr )
150: , mScopeInfo@var491 ( nullptr )
151: , mCppcheckAttributes@var495 ( nullptr )
152: , mCpp11init@var496 ( Cpp11init :: UNKNOWN )
153: , mBits@var497 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var502 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var503 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var504 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var505 ) {
199: mStr@var717 =@expr1073745752 s@var505 ;
200: mImpl@var723 .@expr1073745753 mVarId@var754 =@expr1073745754 0 ;
201:
202: update_property_info (@expr1073745755 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var506 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var717 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var507 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var508 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var509 ) const ;
236: Token * tokAt ( int index@var510 ) {
237: return const_cast < Token *@expr3932 > (@expr1073745757 const_cast < const Token *@expr3932 > (@expr1073745759 this@expr1073745760 ) .@expr1073745761 tokAt (@expr1073745762 index@var510 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var511 ) const ;
245: Token * linkAt ( int index@var512 ) {
246: return const_cast < Token *@expr3939 > (@expr1073745764 const_cast < const Token *@expr3939 > (@expr1073745766 this@expr1073745767 ) .@expr1073745768 linkAt (@expr1073745769 index@var512 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var513 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var514 , const char ( & pattern@var515 ) [ count ] ) {
276: return simpleMatch (@expr1073745771 tok@var514 , pattern@var515 , count@expr1073745770 -@expr1073745772 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var516 , const char pattern@var517 [ ] , unsigned long pattern_len@var518 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var519 , const char pattern@var520 [ ] , int varid@var521 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var522 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var523 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var524 , const Settings * const settings@var525 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var526 , long long index@var527 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var723 .@expr1073745773 mValueType@var755 ;
366: }
367: void setValueType ( ValueType * vt@var528 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var529 ; top@var529 =@expr1073745774 this@expr1073745775 ;
371: while (@expr1073745776 top@var529 &&@expr1073745777 !@expr1073745778 Token ::@expr1073745779 Match (@expr1073745780 top@var529 .@expr3957 astParent (@expr3958 ) , ",|(" ) ) {
372: top@var529 =@expr1073745783 top@var529 .@expr3957 astParent (@expr3958 ) ; }
373: return top@var529 ?@expr1073745786 top@var529 .@expr1073745787 mImpl@var530 .@expr1073745788 mValueType@var531 :@expr1073745789 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var721 ;
378: }
379: void tokType ( Token :: Type t@var532 ) {
380: mTokType@var721 =@expr1073745790 t@var532 ;
381:
382: const bool memoizedIsName@var533 =@expr1073745791 mTokType@var721 ==@expr1073745792 eName ||@expr1073745793 mTokType@var721 ==@expr1073745794 eType ||@expr1073745795 mTokType@var721 ==@expr1073745796 eVariable ||@expr1073745797
383: mTokType@var721 ==@expr1073745798 eFunction ||@expr1073745799 mTokType@var721 ==@expr1073745800 eKeyword ||@expr1073745801 mTokType@var721 ==@expr3978 eBoolean ||@expr1073745803
384: mTokType@var721 ==@expr3980 eEnumerator ;
385: setFlag (@expr1073745805 fIsName , memoizedIsName@var533 ) ;
386:
387: const bool memoizedIsLiteral@var534 =@expr1073745806 mTokType@var721 ==@expr1073745807 eNumber ||@expr1073745808 mTokType@var721 ==@expr1073745809 eString ||@expr1073745810 mTokType@var721 ==@expr1073745811 eChar ||@expr1073745812
388: mTokType@var721 ==@expr3978 eBoolean ||@expr1073745814 mTokType@var721 ==@expr1073745815 eLiteral ||@expr1073745816 mTokType@var721 ==@expr3980 eEnumerator ;
389: setFlag (@expr1073745818 fIsLiteral , memoizedIsLiteral@var534 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var721 ==@expr1073745819 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745820 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var722 ==@expr1073745821 fIsName &&@expr1073745822 mTokType@var721 ==@expr1073745823 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745824 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var721 ==@expr1073745825 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var721 ==@expr1073745826 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745827 isConstOp (@expr1073745828 ) ||@expr1073745829
412: isAssignmentOp (@expr1073745830 ) ||@expr1073745831
413: mTokType@var721 ==@expr1073745832 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745833 isArithmeticalOp (@expr1073745834 ) ||@expr1073745835
417: mTokType@var721 ==@expr1073745836 eLogicalOp ||@expr1073745837
418: mTokType@var721 ==@expr1073745838 eComparisonOp ||@expr1073745839
419: mTokType@var721 ==@expr1073745840 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745841 ) ||@expr1073745842
423: mTokType@var721 ==@expr1073745843 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var721 ==@expr1073745844 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var721 ==@expr1073745845 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var721 ==@expr1073745846 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var721 ==@expr1073745847 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var721 ==@expr1073745848 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745849 ) !=@expr1073745850 nullptr &&@expr1073745851 astOperand2 (@expr1073745852 ) !=@expr1073745853 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var535 ) const {
444: return s@var535 ==@expr1073745854 mStr@var717 &&@expr1073745855 astOperand1 (@expr1073745856 ) !=@expr1073745857 nullptr &&@expr1073745858 astOperand2 (@expr1073745859 ) ==@expr1073745860 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var722 ;
450: }
451: void flags ( const unsigned int flags_@var536 ) {
452: mFlags@var722 =@expr1073745861 flags_@var536 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745862 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var537 ) {
458: setFlag (@expr1073745863 fIsUnsigned , sign@var537 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745864 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var538 ) {
464: setFlag (@expr1073745865 fIsSigned , sign@var538 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745866 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var539 ) {
470: setFlag (@expr1073745867 fIsPointerCompare , b@var539 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745868 fIsLong ) ;
474: }
475: void isLong ( bool size@var540 ) {
476: setFlag (@expr1073745869 fIsLong , size@var540 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745870 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var541 ) {
482: setFlag (@expr1073745871 fIsStandardType , b@var541 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745872 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var542 ) {
488: setFlag (@expr1073745873 fIsExpandedMacro , m@var542 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745874 fIsCast ) ;
492: }
493: void isCast ( bool c@var543 ) {
494: setFlag (@expr1073745875 fIsCast , c@var543 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745876 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var544 ) {
500: setFlag (@expr1073745877 fIsAttributeConstructor , ac@var544 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745878 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var545 ) {
506: setFlag (@expr1073745879 fIsAttributeDestructor , value@var545 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745880 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var546 ) {
512: setFlag (@expr1073745881 fIsAttributeUnused , unused@var546 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745882 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var547 ) {
518: setFlag (@expr1073745883 fIsAttributeUsed , unused@var547 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745884 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var548 ) {
524: setFlag (@expr1073745885 fIsAttributePure , value@var548 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745886 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var549 ) {
530: setFlag (@expr1073745887 fIsAttributeConst , value@var549 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745888 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var550 ) {
536: setFlag (@expr1073745889 fIsAttributeNoreturn , value@var550 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745890 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var551 ) {
542: setFlag (@expr1073745891 fIsAttributeNothrow , value@var551 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745892 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var552 ) {
548: setFlag (@expr1073745893 fIsAttributePacked , value@var552 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745894 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var553 ) {
554: setFlag (@expr1073745895 fIsAttributeNodiscard , value@var553 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745896 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var554 ) {
560: setFlag (@expr1073745897 fIsAttributeMaybeUnused , value@var554 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var555 , long long value@var556 ) {
563: mImpl@var723 .@expr1073745898 setCppcheckAttribute (@expr1073745899 type@var555 , value@var556 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var557 , long long * value@var558 ) const {
566: return mImpl@var723 .@expr1073745900 getCppcheckAttribute (@expr1073745901 type@var557 , value@var558 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745902 mImpl@var723 .@expr1073745903 mCppcheckAttributes@var756 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745904 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745905 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var559 ) {
578: setFlag (@expr1073745906 fIsOperatorKeyword , value@var559 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745907 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var560 ) {
584: setFlag (@expr1073745908 fIsComplex , value@var560 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745909 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var561 ) {
590: setFlag (@expr1073745910 fIsEnumType , value@var561 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745911 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var562 ) {
596: setFlag (@expr1073745912 fAtAddress , b@var562 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745913 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var563 ) {
602: setFlag (@expr1073745914 fIncompleteVar , b@var563 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745915 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var564 ) {
609: setFlag (@expr1073745916 fIsIncompleteConstant , b@var564 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745917 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var565 ) {
616: setFlag (@expr1073745918 fConstexpr , b@var565 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745919 fExternC ) ;
621: }
622: void isExternC ( bool b@var566 ) {
623: setFlag (@expr1073745920 fExternC , b@var566 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745921 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var567 ) {
630: setFlag (@expr1073745922 fIsSplitVarDeclComma , b@var567 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745923 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var568 ) {
637: setFlag (@expr1073745924 fIsSplitVarDeclEq , b@var568 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745925 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var569 ) {
644: setFlag (@expr1073745926 fIsImplicitInt , b@var569 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745927 fIsInline ) ;
649: }
650: void isInline ( bool b@var570 ) {
651: setFlag (@expr1073745928 fIsInline , b@var570 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745929 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var571 ) {
658: setFlag (@expr1073745930 fIsRemovedVoidParameter , b@var571 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745931 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var572 ) {
665: setFlag (@expr1073745932 fIsTemplate , b@var572 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745933 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var573 ) {
672: setFlag (@expr1073745934 fIsSimplifedScope , b@var573 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var723 .@expr1073745935 mBits@var757 >@expr1073745936 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var723 .@expr1073745937 mBits@var757 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var723 .@expr1073745938 mTemplateSimplifierPointers@var758 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var574 ) {
685: if (@expr1073745939 !@expr1073745940 mImpl@var723 .@expr4117 mTemplateSimplifierPointers@var758 ) {
686: mImpl@var723 .@expr4117 mTemplateSimplifierPointers@var758 =@expr1073745943 new std ::@expr1073745944 set < TemplateSimplifier ::@expr1073745945 TokenAndName *@expr1073745946 > ; }
687: mImpl@var723 .@expr4117 mTemplateSimplifierPointers@var758 .@expr1073745948 insert (@expr1073745949 tokenAndName@var574 ) ;
688: }
689: void setBits ( const unsigned char b@var575 ) {
690: mImpl@var723 .@expr1073745950 mBits@var757 =@expr1073745951 b@var575 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4128 (@expr4128 (@expr4128 mTokType@var721 ==@expr1073745955 eString ) &&@expr1073745956 isPrefixStringCharLiteral (@expr1073745957 mStr@var717 , '"' , "u8" ) ) ||@expr1073745958
695: (@expr4128 (@expr4128 mTokType@var721 ==@expr1073745961 eChar ) &&@expr1073745962 isPrefixStringCharLiteral (@expr1073745963 mStr@var717 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4140 (@expr4140 (@expr4140 mTokType@var721 ==@expr1073745967 eString ) &&@expr1073745968 isPrefixStringCharLiteral (@expr1073745969 mStr@var717 , '"' , "u" ) ) ||@expr1073745970
700: (@expr4140 (@expr4140 mTokType@var721 ==@expr1073745973 eChar ) &&@expr1073745974 isPrefixStringCharLiteral (@expr1073745975 mStr@var717 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4152 (@expr4152 (@expr4152 mTokType@var721 ==@expr1073745979 eString ) &&@expr1073745980 isPrefixStringCharLiteral (@expr1073745981 mStr@var717 , '"' , "U" ) ) ||@expr1073745982
705: (@expr4152 (@expr4152 mTokType@var721 ==@expr1073745985 eChar ) &&@expr1073745986 isPrefixStringCharLiteral (@expr1073745987 mStr@var717 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4164 (@expr4164 (@expr4164 mTokType@var721 ==@expr1073745991 eString ) &&@expr1073745992 isPrefixStringCharLiteral (@expr1073745993 mStr@var717 , '"' , "" ) ) ||@expr1073745994
710: (@expr4164 (@expr4164 mTokType@var721 ==@expr1073745997 eChar ) &&@expr1073745998 isPrefixStringCharLiteral (@expr1073745999 mStr@var717 , '\'' , "" ) &&@expr1073746000 mStr@var717 .@expr1073746001 length (@expr1073746002 ) ==@expr1073746003 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4180 (@expr4180 (@expr4180 mTokType@var721 ==@expr1073746007 eChar ) &&@expr1073746008 isPrefixStringCharLiteral (@expr1073746009 mStr@var717 , '\'' , "" ) ) &&@expr1073746010
715: (@expr4180 mStr@var717 .@expr1073746012 length (@expr1073746013 ) >@expr1073746014 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073746015 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var576 ) {
738: setFlag (@expr1073746016 fIsTemplateArg , value@var576 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var577 , const char ( & pattern@var578 ) [ count ] ) {
743: return findsimplematch (@expr1073746018 startTok@var577 , pattern@var578 , count@expr1073746017 -@expr1073746019 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var579 , const char pattern@var580 [ ] , unsigned long pattern_len@var581 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var582 , const char ( & pattern@var583 ) [ count ] , const Token * const end@var584 ) {
749: return findsimplematch (@expr1073746021 startTok@var582 , pattern@var583 , count@expr1073746020 -@expr1073746022 1 , end@var584 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var585 , const char pattern@var586 [ ] , unsigned long pattern_len@var587 , const Token * const end@var588 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var589 , const char pattern@var590 [ ] , const int varId@var591 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var592 , const char pattern@var593 [ ] , const Token * const end@var594 , const int varId@var595 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var596 , const char ( & pattern@var597 ) [ count ] ) {
758: return findsimplematch (@expr1073746024 startTok@var596 , pattern@var597 , count@expr1073746023 -@expr1073746025 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var598 , const char pattern@var599 [ ] , unsigned long pattern_len@var600 ) {
761: return const_cast < Token *@expr4202 > (@expr1073746027 findsimplematch (@expr1073746028 const_cast < const Token *@expr4202 > (@expr1073746030 startTok@var598 ) , pattern@var599 , pattern_len@var600 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var601 , const char ( & pattern@var602 ) [ count ] , const Token * const end@var603 ) {
765: return findsimplematch (@expr1073746032 startTok@var601 , pattern@var602 , count@expr1073746031 -@expr1073746033 1 , end@var603 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var604 , const char pattern@var605 [ ] , unsigned long pattern_len@var606 , const Token * const end@var607 ) {
768: return const_cast < Token *@expr4210 > (@expr1073746035 findsimplematch (@expr1073746036 const_cast < const Token *@expr4210 > (@expr1073746038 startTok@var604 ) , pattern@var605 , pattern_len@var606 , end@var607 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var608 , const char pattern@var609 [ ] , const int varId@var610 = 0 ) {
772: return const_cast < Token *@expr4215 > (@expr1073746040 findmatch (@expr1073746041 const_cast < const Token *@expr4215 > (@expr1073746043 startTok@var608 ) , pattern@var609 , varId@var610 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var611 , const char pattern@var612 [ ] , const Token * const end@var613 , const int varId@var614 = 0 ) {
775: return const_cast < Token *@expr4220 > (@expr1073746045 findmatch (@expr1073746046 const_cast < const Token *@expr4220 > (@expr1073746048 startTok@var611 ) , pattern@var612 , end@var613 , varId@var614 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var615 , const char * haystack@var616 , int varid@var617 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var723 .@expr1073746049 mFileIndex@var759 ;
796: }
797: void fileIndex ( int indexOfFile@var618 ) {
798: mImpl@var723 .@expr1073746050 mFileIndex@var759 =@expr1073746051 indexOfFile@var618 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var723 .@expr1073746052 mLineNumber@var760 ;
803: }
804: void linenr ( int lineNumber@var619 ) {
805: mImpl@var723 .@expr1073746053 mLineNumber@var760 =@expr1073746054 lineNumber@var619 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var723 .@expr1073746055 mColumn@var761 ;
810: }
811: void column ( int c@var620 ) {
812: mImpl@var723 .@expr1073746056 mColumn@var761 =@expr1073746057 c@var620 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var718 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var621 , const Token * end@var622 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var623 , const std :: string & originalNameStr@var624 = emptyString@var1 , bool prepend@var625 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var626 , const std :: string & originalNameStr@var627 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746058 tokenStr@var626 , originalNameStr@var627 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var719 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var723 .@expr1073746059 mVarId@var754 ;
851: }
852: void varId ( int id@var628 ) {
853: mImpl@var723 .@expr1073746060 mVarId@var754 =@expr1073746061 id@var628 ;
854: if (@expr1073746062 id@var628 !=@expr1073746063 0 ) {
855: tokType (@expr1073746064 eVariable ) ;
856: isStandardType (@expr1073746065 false ) ;
857: } else {
858: update_property_info (@expr1073746066 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746067 mImpl@var723 .@expr4244 mExprId@var762 ) {
864: return mImpl@var723 .@expr4244 mExprId@var762 ; }
865: return mImpl@var723 .@expr1073746070 mVarId@var754 ;
866: }
867: void exprId ( int id@var629 ) {
868: mImpl@var723 .@expr1073746071 mExprId@var762 =@expr1073746072 id@var629 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var630 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var631 , const std :: vector < std :: string > & fileNames@var632 ) const ;
888:
|
891:
892: void printLines ( int lines@var633 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var634 , Token * start@var635 , Token * end@var636 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var637 ; varid@var637 = false ;
905: bool exprid@var638 ; exprid@var638 = false ;
906: bool idtype@var639 ; idtype@var639 = false ;
907: bool attributes@var640 ; attributes@var640 = false ;
908: bool macro@var641 ; macro@var641 = false ;
909: bool linenumbers@var642 ; linenumbers@var642 = false ;
910: bool linebreaks@var643 ; linebreaks@var643 = false ;
911: bool files@var644 ; files@var644 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var645 ;
914: options@var645 .@expr1073746073 attributes@var646 =@expr1073746074 true ;
915: options@var645 .@expr1073746075 macro@var647 =@expr1073746076 true ;
916: options@var645 .@expr1073746077 linenumbers@var648 =@expr1073746078 true ;
917: options@var645 .@expr1073746079 linebreaks@var649 =@expr1073746080 true ;
918: options@var645 .@expr1073746081 files@var650 =@expr1073746082 true ;
919: return options@var645 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var651 ; options@var651 =@expr1073746083 forDebug (@expr1073746084 ) ;
923: options@var651 .@expr1073746085 varid@var652 =@expr1073746086 true ;
924: return options@var651 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var653 ; options@var653 =@expr1073746087 forDebug (@expr1073746088 ) ;
928: options@var653 .@expr1073746089 exprid@var654 =@expr1073746090 true ;
929: return options@var653 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var655 ; options@var655 =@expr1073746091 forDebug (@expr1073746092 ) ;
933: options@var655 .@expr1073746093 exprid@var656 =@expr1073746094 true ;
934: options@var655 .@expr1073746095 varid@var657 =@expr1073746096 true ;
935: options@var655 .@expr1073746097 idtype@var658 =@expr1073746098 true ;
936: return options@var655 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var659 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var660 , bool attributes@var661 , bool macro@var662 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var663 , const std :: vector < std :: string > * fileNames@var664 = nullptr , const Token * end@var665 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var666 , bool attributes@var667 = true ) const ;
952: std :: string stringifyList ( bool varid@var668 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var669 , bool attributes@var670 , bool linenumbers@var671 , bool linebreaks@var672 , bool files@var673 , const std :: vector < std :: string > * fileNames@var674 = nullptr , const Token * end@var675 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var676 ) {
983: mLink@var720 =@expr1073746099 linkToToken@var676 ;
984: if (@expr1073746100 mStr@var717 ==@expr1073746101 "<" ||@expr1073746102 mStr@var717 ==@expr1073746103 ">" ) {
985: update_property_info (@expr1073746104 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var720 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var677 ) {
1006: mImpl@var723 .@expr1073746105 mScope@var763 =@expr1073746106 s@var677 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var723 .@expr1073746107 mScope@var763 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var678 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var721 ==@expr1073746108 eFunction ||@expr1073746109 mTokType@var721 ==@expr1073746110 eLambda ?@expr1073746111 mImpl@var723 .@expr1073746112 mFunction@var764 :@expr1073746113 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var679 ) {
1034: mImpl@var723 .@expr1073746114 mVariable@var765 =@expr1073746115 v@var679 ;
1035: if (@expr1073746116 v@var679 ||@expr1073746117 mImpl@var723 .@expr1073746118 mVarId@var754 ) {
1036: tokType (@expr1073746119 eVariable ) ; }
1037: else { if (@expr1073746120 mTokType@var721 ==@expr1073746121 eVariable ) {
1038: tokType (@expr1073746122 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var721 ==@expr1073746123 eVariable ?@expr1073746124 mImpl@var723 .@expr1073746125 mVariable@var765 :@expr1073746126 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var680 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var721 ==@expr1073746127 eType ?@expr1073746128 mImpl@var723 .@expr1073746129 mType@var766 :@expr1073746130 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var681 , const Token * * typeTok@var682 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var683 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var684 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var721 ==@expr1073746131 eEnumerator ?@expr1073746132 mImpl@var723 .@expr1073746133 mEnumerator@var767 :@expr1073746134 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var685 ) {
1079: mImpl@var723 .@expr1073746135 mEnumerator@var767 =@expr1073746136 e@var685 ;
1080: if (@expr1073746137 e@var685 ) {
1081: tokType (@expr1073746138 eEnumerator ) ; }
1082: else { if (@expr1073746139 mTokType@var721 ==@expr1073746140 eEnumerator ) {
1083: tokType (@expr1073746141 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var686 , Token * end@var687 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var688 , Token * srcEnd@var689 , Token * newLocation@var690 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var723 .@expr1073746142 mProgressValue@var768 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var691 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var723 .@expr4319 mOriginalName@var769 ?@expr1073746144 *@expr1073746145 mImpl@var723 .@expr4319 mOriginalName@var769 :@expr1073746147 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var723 .@expr4324 mValues@var742 ?@expr1073746149 *@expr1073746150 mImpl@var723 .@expr4324 mValues@var742 :@expr1073746152 TokenImpl ::@expr1073746153 mEmptyValueList@var489 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var692 ) {
1164: if (@expr1073746154 !@expr1073746155 mImpl@var723 .@expr4332 mOriginalName@var769 ) {
1165: mImpl@var723 .@expr4332 mOriginalName@var769 =@expr1073746158 new std ::@expr1073746159 string (@expr1073746160 name@var692 ) ; }
1166: else {
1167: *@expr1073746161 mImpl@var723 .@expr4332 mOriginalName@var769 =@expr1073746163 name@var692 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var693 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var694 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var695 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var723 .@expr1073746165 mValues@var742 .@expr1073746166 front (@expr1073746167 ) .@expr1073746168 intvalue@expr1073746164 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var696 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var697 , long long path@var698 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var699 , const Settings * settings@var700 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var701 , const Settings * settings@var702 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var703 , int argnr@var704 , const Settings * settings@var705 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var706 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var707 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var708 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var709 ) {
1200: if (@expr1073746169 mImpl@var723 .@expr4346 mValues@var742 ) {
1201: mImpl@var723 .@expr4346 mValues@var742 .@expr1073746172 remove_if (@expr1073746173 pred@var709 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var723 .@expr1073746174 mIndex@var770 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var710 ) {
1213: mNext@var718 =@expr1073746175 nextToken@var710 ;
1214: }
1215: void previous ( Token * previousToken@var711 ) {
1216: mPrevious@var719 =@expr1073746176 previousToken@var711 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var712 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var713 , const char * word@var714 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var715 , char c@var716 ) ;
1235:
1236: std :: string mStr@var717 ;
1237:
1238: Token * mNext@var718 ;
1239: Token * mPrevious@var719 ;
1240: Token * mLink@var720 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var721 ;
1283:
1284: uint64_t mFlags@var722 ;
1285:
1286: TokenImpl * mImpl@var723 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var724 ) const {
1294: return (@expr4353 (@expr4353 mFlags@var722 &@expr1073746179 flag_@var724 ) !=@expr1073746180 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var725 , bool state_@var726 ) {
1303: mFlags@var722 =@expr1073746181 state_@var726 ?@expr1073746182 mFlags@var722 |@expr1073746183 flag_@var725 :@expr1073746184 mFlags@var722 &@expr1073746185 ~@expr1073746186 flag_@var725 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var727 , const int indent1@var728 = 0 , const int indent2@var729 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var730 ) ;
1321: void astOperand2 ( Token * tok@var731 ) ;
1322: void astParent ( Token * tok@var732 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var723 .@expr1073746187 mAstOperand1@var733 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var723 .@expr1073746188 mAstOperand1@var733 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var723 .@expr1073746189 mAstOperand2@var734 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var723 .@expr1073746190 mAstOperand2@var734 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var723 .@expr1073746191 mAstParent@var735 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var723 .@expr1073746192 mAstParent@var735 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746193 !@expr1073746194 astParent (@expr4371 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746196 this@expr4373 ==@expr1073746198 astParent (@expr4371 ) .@expr4376 astOperand1 (@expr4377 ) ) {
1346: return astParent (@expr4371 ) .@expr4379 astOperand2 (@expr4380 ) ; }
1347: else { if (@expr1073746205 this@expr4373 ==@expr1073746206 astParent (@expr4371 ) .@expr4379 astOperand2 (@expr4380 ) ) {
1348: return astParent (@expr4371 ) .@expr4376 astOperand1 (@expr4377 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746213 !@expr1073746214 astParent (@expr4391 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746216 this@expr4393 ==@expr1073746218 astParent (@expr4391 ) .@expr4396 astOperand1 (@expr4397 ) ) {
1356: return astParent (@expr4391 ) .@expr4399 astOperand2 (@expr4400 ) ; }
1357: else { if (@expr1073746225 this@expr4393 ==@expr1073746226 astParent (@expr4391 ) .@expr4399 astOperand2 (@expr4400 ) ) {
1358: return astParent (@expr4391 ) .@expr4396 astOperand1 (@expr4397 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var736 ; ret@var736 =@expr1073746233 this@expr1073746234 ;
1364: while (@expr1073746235 ret@var736 .@expr4412 mImpl@var737 .@expr4413 mAstParent@var738 ) {
1365: ret@var736 =@expr1073746238 ret@var736 .@expr4412 mImpl@var737 .@expr4413 mAstParent@var738 ; }
1366: return ret@var736 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var739 ; ret@var739 =@expr1073746241 this@expr1073746242 ;
1371: while (@expr1073746243 ret@var739 .@expr4420 mImpl@var740 .@expr4421 mAstParent@var741 ) {
1372: ret@var739 =@expr1073746246 ret@var739 .@expr4420 mImpl@var740 .@expr4421 mAstParent@var741 ; }
1373: return ret@var739 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var723 .@expr1073746249 mAstOperand1@var733 =@expr1073746250 mImpl@var723 .@expr1073746251 mAstOperand2@var734 =@expr1073746252 mImpl@var723 .@expr1073746253 mAstParent@var735 =@expr1073746254 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var723 .@expr4431 mValues@var742 ;
1393: mImpl@var723 .@expr4431 mValues@var742 =@expr1073746257 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var743 = "" ) const {
1397: std ::@expr1073746258 string ret@var744 ;
1398: if (@expr1073746259 mImpl@var723 .@expr4436 mAstOperand1@var733 ) {
1399: ret@var744 =@expr1073746261 mImpl@var723 .@expr4436 mAstOperand1@var733 .@expr1073746263 astString (@expr1073746264 sep@var743 ) ; }
1400: if (@expr1073746265 mImpl@var723 .@expr4442 mAstOperand2@var734 ) {
1401: ret@var744 +=@expr1073746267 mImpl@var723 .@expr4442 mAstOperand2@var734 .@expr1073746269 astString (@expr1073746270 sep@var743 ) ; }
1402: return ret@var744 +@expr1073746271 sep@var743 +@expr1073746272 mStr@var717 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var745 , bool xml@var746 , const std :: vector < std :: string > & fileNames@var747 , std :: ostream & out@var748 ) const ;
1412:
1413: void printValueFlow ( bool xml@var749 , std :: ostream & out@var750 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var751 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var752 ) const {
1419: mImpl@var723 .@expr1073746273 mCpp11init@var753 =@expr1073746274 cpp11init@var752 ?@expr1073746275 TokenImpl ::@expr4452 Cpp11init ::@expr1073746277 CPP11INIT :@expr1073746278 TokenImpl ::@expr4452 Cpp11init ::@expr1073746280 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var723 .@expr1073746281 mCpp11init@var753 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var771 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var772 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var773 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var774 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var775 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var776 ) {
47: mSettings@var811 =@expr1073746282 settings@var776 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var811 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var813 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var814 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var777 ) ;
72:
73: void addtoken ( const std :: string & str@var778 , const int lineno@var779 , const int column@var780 , const int fileno@var781 , bool split@var782 = false ) ;
74: void addtoken ( const std :: string & str@var783 , const Token * locationTok@var784 ) ;
75:
76: void addtoken ( const Token * tok@var785 , const int lineno@var786 , const int column@var787 , const int fileno@var788 ) ;
77: void addtoken ( const Token * tok@var789 , const Token * locationTok@var790 ) ;
78: void addtoken ( const Token * tok@var791 ) ;
79:
80: static void insertTokens ( Token * dest@var792 , const Token * src@var793 , int n@var794 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var795 , const Token * first@var796 , const Token * last@var797 , bool one_line@var798 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var799 , const std :: string & file0@var800 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var801 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var802 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var808 .@expr1073746283 front@var815 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var808 .@expr1073746284 front@var815 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var808 .@expr1073746285 back@var816 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var808 .@expr1073746286 back@var816 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var809 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var803 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var804 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var805 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var806 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var807 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var808 ;
206:
207:
208: std :: vector < std :: string > mFiles@var809 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var810 ;
212:
213:
214: const Settings * mSettings@var811 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var812 ;
217:
218:
219: bool mIsC@var813 ;
220: bool mIsCpp@var814 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var817 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var818 ;
67: mutable int mVarId@var819 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var820 ) ;
73: bool hasVariable ( const std :: string & varname@var821 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var822 ) const {
75: return mVariableId@var817 .@expr1073746287 find (@expr1073746288 varname@var822 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var817 .@expr1073746289 end (@expr1073746290 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var817 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746291 mVarId@var819 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var823 , ErrorLogger * errorLogger@var824 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var825 ) {
95: mTimerResults@var945 =@expr1073746292 tr@var825 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var923 .@expr1073746293 isC (@expr1073746294 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var923 .@expr1073746295 isCPP (@expr1073746296 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var826 , bool * unknown@var827 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var828 , const std :: string & FileName@var829 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var830 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var831 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var832 ,
142: const char FileName@var833 [ ] ,
143: const std :: string & configuration@var834 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var835 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var836 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var837 , const Token * end@var838 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var839 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var840 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var841 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var842 , const Token * const tokEnd@var843 , const bool only_k_r_fpar@var844 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var845 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var846 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var847 , bool commandWithCondition@var848 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var849 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var850 , Token * * _tok2@var851 , Token * * _tok3@var852 , std :: string & value@var853 , int & valueVarId@var854 , bool & valueIsPointer@var855 , bool floatvar@var856 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var857 , Token * tok3@var858 , int varid@var859 , const std :: string & structname@var860 , std :: string & value@var861 , int valueVarId@var862 , bool valueIsPointer@var863 , const Token * const valueToken@var864 , int indentlevel@var865 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var866 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var867 , const std :: string & endsWith@var868 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var869 , const std :: string & endsWith@var870 , bool cpp@var871 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var872 ) {
585: mPreprocessor@var946 =@expr1073746297 preprocessor@var872 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var946 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var873 , const Token * end@var874 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var875 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var876 , const std :: string & code@var877 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var878 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var879 , const std :: string & what@var880 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var881 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var882 , const std :: string & msg@var883 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var884 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var885 , const std :: string & macroName@var886 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var887 , const Token * end@var888 , bool allowSemicolon@var889 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var890 , const Severity :: SeverityType severity@var891 , const std :: string & id@var892 , const std :: string & msg@var893 , bool inconclusive@var894 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var895 , Severity :: SeverityType severity@var896 , const std :: string & id@var897 , const std :: string & msg@var898 , bool inconclusive@var899 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var900 , const Token * name@var901 , const Token * typeDef@var902 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var903 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var904 ,
821: const VariableMap & variableMap@var905 ,
822: const int scopeStartVarId@var906 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var907 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var908 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var909 ,
827: int * varId@var910 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var911 ,
830: Token * const startToken@var912 ,
831: const Token * const endToken@var913 ,
832: const std :: map < std :: string , int > & varlist@var914 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var915 ,
834: int * varId_@var916 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var917 ) ;
849:
850: bool operatorEnd ( const Token * tok@var918 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var944 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var919 ) {
861: mSettings@var930 =@expr1073746298 settings@var919 ;
862: list@var923 .@expr1073746299 setSettings (@expr1073746300 settings@var919 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var932 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var920 ) const ;
877:
878: void dump ( std :: ostream & out@var921 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var922 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var942 ;
888: }
889:
|
892:
893: TokenList list@var923 ;
894:
895: const Token * tokens ( ) const {
896: return list@var923 .@expr1073746301 front (@expr1073746302 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var924 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var925 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var926 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var927 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var930 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var928 , bool inOperator@var929 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746303 mVarId@var942 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var930 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var931 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var932 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var933 ;
973:
974:
975:
976: std :: string mConfiguration@var934 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var935 ;
980:
981: struct TypedefInfo {
982: std :: string name@var936 ;
983: std :: string filename@var937 ;
984: int lineNumber@var938 ;
985: int column@var939 ;
986: bool used@var940 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var941 ;
989:
990:
991: int mVarId@var942 ;
992:
993:
994: int mUnnamedCount@var943 ;
995:
|
999:
1000: bool mCodeWithTemplates@var944 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var945 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var946 ;
1013: } ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var947 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var948 ;
42:
43:
44: std :: string stdValue@var949 ;
45:
46:
47: Standards ( ) : c@var947 ( CLatest ) , cpp@var948 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var950 ) {
50: stdValue@var949 =@expr1073746304 str@var950 ;
51: if (@expr1073746305 str@var950 ==@expr1073746306 "c89" ||@expr1073746307 str@var950 ==@expr1073746308 "C89" ) {
52: c@var947 =@expr1073746309 C89 ;
53: return true ;
54: }
55: if (@expr1073746310 str@var950 ==@expr1073746311 "c99" ||@expr1073746312 str@var950 ==@expr1073746313 "C99" ) {
56: c@var947 =@expr1073746314 C99 ;
57: return true ;
58: }
59: if (@expr1073746315 str@var950 ==@expr1073746316 "c11" ||@expr1073746317 str@var950 ==@expr1073746318 "C11" ) {
60: c@var947 =@expr1073746319 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073746320 c@var947 ) {
67: case C89 :@expr4497 ;
68: return "c89" ;
69: case C99 :@expr4497 ;
70: return "c99" ;
71: case C11 :@expr4497 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var951 ) {
77: if (@expr1073746324 std@var951 ==@expr1073746325 "c89" ) {
78: return Standards ::@expr1073746326 C89 ;
79: }
80: if (@expr1073746327 std@var951 ==@expr1073746328 "c99" ) {
81: return Standards ::@expr1073746329 C99 ;
82: }
83: if (@expr1073746330 std@var951 ==@expr1073746331 "c11" ) {
84: return Standards ::@expr1073746332 C11 ;
85: }
86: return Standards ::@expr1073746333 CLatest ;
87: }
88: bool setCPP ( std :: string str@var952 ) {
89: stdValue@var949 =@expr1073746334 str@var952 ;
90: strTolower (@expr1073746335 str@var952 ) ;
91: cpp@var948 =@expr1073746336 getCPP (@expr1073746337 str@var952 ) ;
92: return !@expr1073746338 stdValue@var949 .@expr1073746339 empty (@expr1073746340 ) &&@expr1073746341 str@var952 ==@expr1073746342 getCPP (@expr1073746343 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073746344 cpp@var948 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var953 ) {
98: switch (@expr1073746345 std@var953 ) {
99: case CPP03 :@expr4522 ;
100: return "c++03" ;
101: case CPP11 :@expr4522 ;
102: return "c++11" ;
103: case CPP14 :@expr4522 ;
104: return "c++14" ;
105: case CPP17 :@expr4522 ;
106: return "c++17" ;
107: case CPP20 :@expr4522 ;
108: return "c++20" ;
109: case CPP23 :@expr4522 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var954 ) {
115: if (@expr1073746352 std@var954 ==@expr1073746353 "c++03" ) {
116: return Standards ::@expr1073746354 CPP03 ;
117: }
118: if (@expr1073746355 std@var954 ==@expr1073746356 "c++11" ) {
119: return Standards ::@expr1073746357 CPP11 ;
120: }
121: if (@expr1073746358 std@var954 ==@expr1073746359 "c++14" ) {
122: return Standards ::@expr1073746360 CPP14 ;
123: }
124: if (@expr1073746361 std@var954 ==@expr1073746362 "c++17" ) {
125: return Standards ::@expr1073746363 CPP17 ;
126: }
127: if (@expr1073746364 std@var954 ==@expr1073746365 "c++20" ) {
128: return Standards ::@expr1073746366 CPP20 ;
129: }
130: if (@expr1073746367 std@var954 ==@expr1073746368 "c++23" ) {
131: return Standards ::@expr1073746369 CPP23 ;
132: }
133: return Standards ::@expr1073746370 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var958 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var955 ) : errorcode@var958 ( e@var955 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var956 , T && r@var957 ) : errorcode@var958 ( e@var956 ) , reason@var959 ( r@var957 ) { }
66: ErrorCode errorcode@var958 ;
67: std :: string reason@var959 ;
68: } ;
69:
70: Error load ( const char exename@var960 [ ] , const char path@var961 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var962 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var963 [ ] , unsigned long len@var964 ) ;
75:
76: struct AllocFunc {
77: int groupId@var965 ;
78: int arg@var966 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var967 ;
81: int bufferSizeArg1@var968 ;
82: int bufferSizeArg2@var969 ;
83: int reallocArg@var970 ;
84: bool initData@var971 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var972 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var973 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var974 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var975 , int arg@var976 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var977 , int arg@var978 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var979 , int arg@var980 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var981 [ ] ) const {
107: return getAllocDealloc (@expr1073746371 mAlloc@var1247 , name@var981 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var982 [ ] ) const {
112: return getAllocDealloc (@expr1073746372 mDealloc@var1248 , name@var982 ) ;
113: }
114:
115:
116: int allocId ( const char name@var983 [ ] ) const {
117: const AllocFunc * af@var984 ; af@var984 =@expr1073746373 getAllocDealloc (@expr1073746374 mAlloc@var1247 , name@var983 ) ;
118: return af@var984 ?@expr1073746375 af@var984 .@expr1073746376 groupId@var985 :@expr1073746377 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var986 [ ] ) const {
123: const AllocFunc * af@var987 ; af@var987 =@expr1073746378 getAllocDealloc (@expr1073746379 mDealloc@var1248 , name@var986 ) ;
124: return af@var987 ?@expr1073746380 af@var987 .@expr1073746381 groupId@var988 :@expr1073746382 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var989 , int id@var990 , int arg@var991 ) {
129: mAlloc@var1247 [@expr4559 functionname@var989 ] .@expr1073746384 groupId@var3452 =@expr1073746385 id@var990 ;
130: mAlloc@var1247 [@expr4559 functionname@var989 ] .@expr1073746387 arg@var3453 =@expr1073746388 arg@var991 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var992 , int id@var993 , int arg@var994 ) {
134: mDealloc@var1248 [@expr4565 functionname@var992 ] .@expr1073746390 groupId@var3454 =@expr1073746391 id@var993 ;
135: mDealloc@var1248 [@expr4565 functionname@var992 ] .@expr1073746393 arg@var3455 =@expr1073746394 arg@var994 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var995 , int id@var996 , int arg@var997 , int reallocArg@var998 = 1 ) {
139: mRealloc@var1249 [@expr4571 functionname@var995 ] .@expr1073746396 groupId@var3456 =@expr1073746397 id@var996 ;
140: mRealloc@var1249 [@expr4571 functionname@var995 ] .@expr1073746399 arg@var3457 =@expr1073746400 arg@var997 ;
141: mRealloc@var1249 [@expr4571 functionname@var995 ] .@expr1073746402 reallocArg@var3458 =@expr1073746403 reallocArg@var998 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var999 , bool noreturn@var1000 ) {
146: mNoReturn@var1250 [@expr1073746404 funcname@var999 ] =@expr1073746405 noreturn@var1000 ?@expr1073746406 FalseTrueMaybe ::@expr1073746407 True :@expr1073746408 FalseTrueMaybe ::@expr1073746409 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var1001 ) ;
150:
151:
152: static bool ismemory ( const int id@var1002 ) {
153: return (@expr4586 (@expr4586 id@var1002 >@expr1073746412 0 ) &&@expr1073746413 (@expr4586 (@expr4586 id@var1002 &@expr1073746416 1 ) ==@expr1073746417 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var1003 ) {
156: return (@expr4594 (@expr4594 func@var1003 .@expr4596 groupId@var1004 >@expr1073746421 0 ) &&@expr1073746422 (@expr4594 (@expr4594 func@var1003 .@expr4596 groupId@var1004 &@expr1073746426 1 ) ==@expr1073746427 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var1005 ) {
161: return (@expr4604 (@expr4604 id@var1005 >@expr1073746430 0 ) &&@expr1073746431 (@expr4604 (@expr4604 id@var1005 &@expr1073746434 1 ) ==@expr1073746435 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var1006 ) {
164: return (@expr4612 (@expr4612 func@var1006 .@expr4614 groupId@var1007 >@expr1073746439 0 ) &&@expr1073746440 (@expr4612 (@expr4612 func@var1006 .@expr4614 groupId@var1007 &@expr1073746444 1 ) ==@expr1073746445 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var1008 ) const ;
168: int formatstr_argno ( const Token * ftok@var1009 ) const ;
169: bool formatstr_scan ( const Token * ftok@var1010 ) const ;
170: bool formatstr_secure ( const Token * ftok@var1011 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var1012 ;
174: int ptr2Arg@var1013 ;
175: int sizeArg@var1014 ;
176: int strlenArg@var1015 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var1016 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var1017 ;
182: Standards standards@var1018 ;
183: Severity :: SeverityType severity@var1019 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var1020 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var1021 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var1022 ) const ;
191: bool matchArguments ( const Token * ftok@var1023 , const std :: string & functionName@var1024 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var1025 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var1026 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var1027 ) const ;
198: int returnValueContainer ( const Token * ftok@var1028 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var1029 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var1030 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var1031 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var1032 , std :: string * unknownFunc@var1033 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var1043 ( -1 ) ,
210: size_templateArgNo@var1045 ( -1 ) ,
211: arrayLike_indexOp@var1046 ( false ) ,
212: stdStringLike@var1047 ( false ) ,
213: stdAssociativeLike@var1048 ( false ) ,
214: opLessAllowed@var1049 ( true ) ,
215: hasInitializerListConstructor@var1050 ( false ) ,
216: unstableErase@var1051 ( false ) ,
217: unstableInsert@var1052 ( false ) ,
218: view@var1053 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var1034 ;
248: Yield yield@var1035 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var1036 ;
252: int templateParameter@var1037 ;
253: } ;
254: std :: string startPattern@var1038 ; std :: string startPattern2@var1039 ; std :: string endPattern@var1040 ; std :: string itEndPattern@var1041 ;
255: std :: map < std :: string , Function > functions@var1042 ;
256: int type_templateArgNo@var1043 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var1044 ;
258: int size_templateArgNo@var1045 ;
259: bool arrayLike_indexOp@var1046 ;
260: bool stdStringLike@var1047 ;
261: bool stdAssociativeLike@var1048 ;
262: bool opLessAllowed@var1049 ;
263: bool hasInitializerListConstructor@var1050 ;
264: bool unstableErase@var1051 ;
265: bool unstableInsert@var1052 ;
266: bool view@var1053 ;
267:
268: Action getAction ( const std :: string & function@var1054 ) const {
269: const std ::@expr1073746446 map < std ::@expr1073746447 string , Function > ::@expr1073746448 const_iterator i@var1055 =@expr1073746449 functions@var1042 .@expr1073746450 find (@expr1073746451 function@var1054 ) ;
270: if (@expr1073746452 i@var1055 !=@expr1073746453 functions@var1042 .@expr1073746454 end (@expr1073746455 ) ) {
271: return i@var1055 .@expr1073746456 second@var1056 .@expr1073746457 action@var1057 ; }
272: return Action ::@expr1073746458 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var1058 ) const {
276: const std ::@expr1073746459 map < std ::@expr1073746460 string , Function > ::@expr1073746461 const_iterator i@var1059 =@expr1073746462 functions@var1042 .@expr1073746463 find (@expr1073746464 function@var1058 ) ;
277: if (@expr1073746465 i@var1059 !=@expr1073746466 functions@var1042 .@expr1073746467 end (@expr1073746468 ) ) {
278: return i@var1059 .@expr1073746469 second@var1060 .@expr1073746470 yield@var1061 ; }
279: return Yield ::@expr1073746471 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var1062 ) ;
283: static Action actionFrom ( const std :: string & actionName@var1063 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var1064 ;
286: const Container * detectContainer ( const Token * typeStart@var1065 , bool iterator@var1066 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var1067 , bool * isIterator@var1068 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var1069 ( false ) ,
293: notnull@var1070 ( false ) ,
294: notuninit@var1071 ( -1 ) ,
295: formatstr@var1072 ( false ) ,
296: strz@var1073 ( false ) ,
297: optional@var1074 ( false ) ,
298: variadic@var1075 ( false ) ,
299: iteratorInfo@var1081 ( ) ,
300: direction@var1089 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var1069 ;
303: bool notnull@var1070 ;
304: int notuninit@var1071 ;
305: bool formatstr@var1072 ;
306: bool strz@var1073 ;
307: bool optional@var1074 ;
308: bool variadic@var1075 ;
309: std :: string valid@var1076 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var1077 ( 0 ) , it@var1078 ( false ) , first@var1079 ( false ) , last@var1080 ( false ) { }
314:
315: int container@var1077 ;
316: bool it@var1078 ;
317: bool first@var1079 ;
318: bool last@var1080 ;
319: } ;
320: IteratorInfo iteratorInfo@var1081 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var1082 , int a@var1083 ) : type@var1084 ( t@var1082 ) , arg@var1085 ( a@var1083 ) , arg2@var1086 ( 0 ) , value@var1087 ( 0 ) { }
326: Type type@var1084 ;
327: int arg@var1085 ;
328: int arg2@var1086 ;
329: long long value@var1087 ;
330: } ;
331: std :: vector < MinSize > minsizes@var1088 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var1089 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var1090 ;
344: bool use@var1091 ;
345: bool leakignore@var1092 ;
346: bool isconst@var1093 ;
347: bool ispure@var1094 ;
348: UseRetValType useretval@var1095 ;
349: bool ignore@var1096 ;
350: bool formatstr@var1097 ;
351: bool formatstr_scan@var1098 ;
352: bool formatstr_secure@var1099 ;
353: Container :: Action containerAction@var1100 ;
354: Container :: Yield containerYield@var1101 ;
355: Function ( )
356: : use@var1091 ( false ) ,
357: leakignore@var1092 ( false ) ,
358: isconst@var1093 ( false ) ,
359: ispure@var1094 ( false ) ,
360: useretval@var1095 ( UseRetValType :: NONE ) ,
361: ignore@var1096 ( false ) ,
362: formatstr@var1097 ( false ) ,
363: formatstr_scan@var1098 ( false ) ,
364: formatstr_secure@var1099 ( false ) ,
365: containerAction@var1100 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var1101 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var1102 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var1103 ;
372: bool isUse ( const std :: string & functionName@var1104 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var1105 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var1106 , bool pure@var1107 ) const ;
375: bool isFunctionConst ( const Token * ftok@var1108 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var1109 , int argnr@var1110 ) const {
378: const ArgumentChecks * arg@var1111 ; arg@var1111 =@expr1073746472 getarg (@expr1073746473 ftok@var1109 , argnr@var1110 ) ;
379: return arg@var1111 &&@expr1073746474 arg@var1111 .@expr1073746475 notbool@var1112 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var1113 , int argnr@var1114 ) const ;
383: bool isuninitargbad ( const Token * ftok@var1115 , int argnr@var1116 , int indirect@var1117 = 0 , bool * hasIndirect@var1118 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var1119 , int argnr@var1120 ) const {
386: const ArgumentChecks * arg@var1121 ; arg@var1121 =@expr1073746476 getarg (@expr1073746477 ftok@var1119 , argnr@var1120 ) ;
387: return arg@var1121 &&@expr1073746478 arg@var1121 .@expr1073746479 formatstr@var1122 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var1123 , int argnr@var1124 ) const {
391: const ArgumentChecks * arg@var1125 ; arg@var1125 =@expr1073746480 getarg (@expr1073746481 ftok@var1123 , argnr@var1124 ) ;
392: return arg@var1125 &&@expr1073746482 arg@var1125 .@expr1073746483 strz@var1126 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var1127 , int argnr@var1128 , const long long argvalue@var1129 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var1130 , int argnr@var1131 , double argvalue@var1132 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var1133 , int argnr@var1134 ) const {
399: const ArgumentChecks * arg@var1135 ; arg@var1135 =@expr1073746484 getarg (@expr1073746485 ftok@var1133 , argnr@var1134 ) ;
400: return arg@var1135 ?@expr1073746486 arg@var1135 .@expr1073746487 valid@var1136 :@expr1073746488 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var1137 ;
405: std :: string op1@var1138 ;
406: std :: string op2@var1139 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073746489 isInt (@expr1073746490 op1@var1138 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var1140 , int argnr@var1141 ) const {
413: const ArgumentChecks * arg@var1142 ; arg@var1142 =@expr1073746491 getarg (@expr1073746492 ftok@var1140 , argnr@var1141 ) ;
414: return arg@var1142 &&@expr1073746493 arg@var1142 .@expr4670 iteratorInfo@var1143 .@expr1073746495 it@var1144 ?@expr1073746496 &@expr1073746497 arg@var1142 .@expr4670 iteratorInfo@var1143 :@expr1073746499 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var1145 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var1146 , int argnr@var1147 ) const {
420: const ArgumentChecks * arg@var1148 ; arg@var1148 =@expr1073746500 getarg (@expr1073746501 ftok@var1146 , argnr@var1147 ) ;
421: return arg@var1148 ?@expr1073746502 &@expr1073746503 arg@var1148 .@expr1073746504 minsizes@var1149 :@expr1073746505 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var1150 , int argnr@var1151 ) const ;
425:
426: bool markupFile ( const std :: string & path@var1152 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var1153 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1257 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var1154 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var1155 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var1156 , const std :: string & token@var1157 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var1158 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var1159 ) const ;
443: const std :: string & blockend ( const std :: string & file@var1160 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var1161 , const std :: string & keyword@var1162 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var1163 ) const {
448: return mExporters@var1260 .@expr1073746506 find (@expr1073746507 prefix@var1163 ) !=@expr1073746508 mExporters@var1260 .@expr1073746509 end (@expr1073746510 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var1164 , const std :: string & token@var1165 ) const {
452: const std ::@expr1073746511 map < std ::@expr1073746512 string , ExportedFunctions > ::@expr1073746513 const_iterator it@var1166 =@expr1073746514 mExporters@var1260 .@expr1073746515 find (@expr1073746516 prefix@var1164 ) ;
453: return (@expr1073746517 it@var1166 !=@expr1073746518 mExporters@var1260 .@expr1073746519 end (@expr1073746520 ) &&@expr1073746521 it@var1166 .@expr1073746522 second@var1167 .@expr1073746523 isPrefix (@expr1073746524 token@var1165 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var1168 , const std :: string & token@var1169 ) const {
457: const std ::@expr1073746525 map < std ::@expr1073746526 string , ExportedFunctions > ::@expr1073746527 const_iterator it@var1170 =@expr1073746528 mExporters@var1260 .@expr1073746529 find (@expr1073746530 prefix@var1168 ) ;
458: return (@expr1073746531 it@var1170 !=@expr1073746532 mExporters@var1260 .@expr1073746533 end (@expr1073746534 ) &&@expr1073746535 it@var1170 .@expr1073746536 second@var1171 .@expr1073746537 isSuffix (@expr1073746538 token@var1169 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var1172 , const std :: string & importer@var1173 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var1174 , Container :: Yield yield@var1175 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var1176 , Container :: Action action@var1177 ) const ;
465:
466: bool isreflection ( const std :: string & token@var1178 ) const {
467: return mReflection@var1262 .@expr1073746539 find (@expr1073746540 token@var1178 ) !=@expr1073746541 mReflection@var1262 .@expr1073746542 end (@expr1073746543 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var1179 ) const {
471: const std ::@expr1073746544 map < std ::@expr1073746545 string , int > ::@expr1073746546 const_iterator it@var1180 =@expr1073746547 mReflection@var1262 .@expr1073746548 find (@expr1073746549 token@var1179 ) ;
472: if (@expr1073746550 it@var1180 !=@expr1073746551 mReflection@var1262 .@expr1073746552 end (@expr1073746553 ) ) {
473: return it@var1180 .@expr1073746554 second@var1181 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var1182 ;
478:
479: struct SmartPointer {
480: std :: string name@var1183 ; name@var1183 = "" ;
481: bool unique@var1184 ; unique@var1184 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var1185 ;
485: bool isSmartPointer ( const Token * tok@var1186 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var1187 ) const ;
487:
488: struct PodType {
489: unsigned int size@var1188 ;
490: char sign@var1189 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var1190 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var1191 ) const {
494: const std ::@expr1073746555 unordered_map < std ::@expr1073746556 string , PodType > ::@expr1073746557 const_iterator it@var1192 =@expr1073746558 mPodTypes@var1263 .@expr1073746559 find (@expr1073746560 name@var1191 ) ;
495: return (@expr4737 it@var1192 !=@expr1073746562 mPodTypes@var1263 .@expr1073746563 end (@expr1073746564 ) ) ?@expr1073746565 &@expr1073746566 (@expr4737 it@var1192 .@expr1073746568 second@var1193 ) :@expr1073746569 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var1204 ( false )
501: , mUnsigned@var1205 ( false )
502: , mLong@var1206 ( false )
503: , mPointer@var1207 ( false )
504: , mPtrPtr@var1208 ( false )
505: , mConstPtr@var1209 ( false ) { }
506: bool operator== ( const PlatformType & type@var1194 ) const {
507: return (@expr1073746570 mSigned@var1204 ==@expr1073746571 type@var1194 .@expr1073746572 mSigned@var1195 &&@expr1073746573
508: mUnsigned@var1205 ==@expr1073746574 type@var1194 .@expr1073746575 mUnsigned@var1196 &&@expr1073746576
509: mLong@var1206 ==@expr1073746577 type@var1194 .@expr1073746578 mLong@var1197 &&@expr1073746579
510: mPointer@var1207 ==@expr1073746580 type@var1194 .@expr1073746581 mPointer@var1198 &&@expr1073746582
511: mPtrPtr@var1208 ==@expr1073746583 type@var1194 .@expr1073746584 mPtrPtr@var1199 &&@expr1073746585
512: mConstPtr@var1209 ==@expr1073746586 type@var1194 .@expr1073746587 mConstPtr@var1200 &&@expr1073746588
513: mType@var1203 ==@expr1073746589 type@var1194 .@expr1073746590 mType@var1201 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var1202 ) const {
516: return !@expr1073746591 (@expr1073746592 *@expr1073746593 this@expr1073746594 ==@expr1073746595 type@var1202 ) ;
517: }
518: std :: string mType@var1203 ;
519: bool mSigned@var1204 ;
520: bool mUnsigned@var1205 ;
521: bool mLong@var1206 ;
522: bool mPointer@var1207 ;
523: bool mPtrPtr@var1208 ;
524: bool mConstPtr@var1209 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var1210 ) const {
529: const std ::@expr1073746596 map < std ::@expr1073746597 string , PlatformType > ::@expr1073746598 const_iterator it@var1211 =@expr1073746599 mPlatformTypes@var1213 .@expr1073746600 find (@expr1073746601 name@var1210 ) ;
530: return (@expr4778 it@var1211 !=@expr1073746603 mPlatformTypes@var1213 .@expr1073746604 end (@expr1073746605 ) ) ?@expr1073746606 &@expr1073746607 (@expr4778 it@var1211 .@expr1073746609 second@var1212 ) :@expr1073746610 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var1213 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var1214 , const std :: string & platform@var1215 ) const {
536: const std ::@expr1073746611 map < std ::@expr4788 string , Platform > ::@expr1073746613 const_iterator it@var1216 =@expr1073746614 mPlatforms@var1265 .@expr1073746615 find (@expr1073746616 platform@var1215 ) ;
537: if (@expr1073746617 it@var1216 !=@expr1073746618 mPlatforms@var1265 .@expr1073746619 end (@expr1073746620 ) ) {
538: const PlatformType * const type@var1217 ; type@var1217 =@expr1073746621 it@var1216 .@expr1073746622 second@var1218 .@expr1073746623 platform_type (@expr1073746624 name@var1214 ) ;
539: if (@expr1073746625 type@var1217 ) {
540: return type@var1217 ; }
541: }
542:
543: const std ::@expr1073746626 map < std ::@expr4788 string , PlatformType > ::@expr1073746628 const_iterator it2@var1219 =@expr1073746629 mPlatformTypes@var1264 .@expr1073746630 find (@expr1073746631 name@var1214 ) ;
544: return (@expr4808 it2@var1219 !=@expr1073746633 mPlatformTypes@var1264 .@expr1073746634 end (@expr1073746635 ) ) ?@expr1073746636 &@expr1073746637 (@expr4808 it2@var1219 .@expr1073746639 second@var1220 ) :@expr1073746640 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var1221 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var1222 , Library :: Container :: Yield y@var1223 , const std :: string & fallback@var1224 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1225 , const std :: string & typeName@var1226 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1227 , const std :: string & name@var1228 , std :: set < std :: string > & unknown_elements@var1229 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1230 ) {
565: mPrefixes@var1234 .@expr1073746641 insert (@expr1073746642 prefix@var1230 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1231 ) {
568: mSuffixes@var1235 .@expr1073746643 insert (@expr1073746644 suffix@var1231 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1232 ) const {
571: return (@expr1073746645 mPrefixes@var1234 .@expr1073746646 find (@expr1073746647 prefix@var1232 ) !=@expr1073746648 mPrefixes@var1234 .@expr1073746649 end (@expr1073746650 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1233 ) const {
574: return (@expr1073746651 mSuffixes@var1235 .@expr1073746652 find (@expr1073746653 suffix@var1233 ) !=@expr1073746654 mSuffixes@var1235 .@expr1073746655 end (@expr1073746656 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1234 ;
579: std :: set < std :: string > mSuffixes@var1235 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1243 ( 0 ) { }
584:
585: void setStart ( const char * s@var1236 ) {
586: mStart@var1241 =@expr1073746657 s@var1236 ;
587: }
588: void setEnd ( const char * e@var1237 ) {
589: mEnd@var1242 =@expr1073746658 e@var1237 ;
590: }
591: void setOffset ( const int o@var1238 ) {
592: mOffset@var1243 =@expr1073746659 o@var1238 ;
593: }
594: void addBlock ( const char * blockName@var1239 ) {
595: mBlocks@var1244 .@expr1073746660 insert (@expr1073746661 blockName@var1239 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1241 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1242 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1243 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1240 ) const {
607: return mBlocks@var1244 .@expr1073746662 find (@expr1073746663 blockName@var1240 ) !=@expr1073746664 mBlocks@var1244 .@expr1073746665 end (@expr1073746666 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1241 ;
612: std :: string mEnd@var1242 ;
613: int mOffset@var1243 ;
614: std :: set < std :: string > mBlocks@var1244 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1245 ;
618: std :: set < std :: string > mFiles@var1246 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1247 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1248 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1249 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1250 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1251 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1252 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1253 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1254 ;
627: std :: map < std :: string , bool > mReportErrors@var1255 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1256 ;
629: std :: set < std :: string > mMarkupExtensions@var1257 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1258 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1259 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1260 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1261 ;
634: std :: map < std :: string , int > mReflection@var1262 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1263 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1264 ;
637: std :: map < std :: string , Platform > mPlatforms@var1265 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1266 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1267 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1268 , int argnr@var1269 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1270 , bool * error@var1271 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1272 , const std :: string & name@var1273 ) {
646: const std ::@expr1073746667 map < std ::@expr1073746668 string , AllocFunc > ::@expr1073746669 const_iterator it@var1274 =@expr1073746670 data@var1272 .@expr1073746671 find (@expr1073746672 name@var1273 ) ;
647: return (@expr1073746673 it@var1274 ==@expr1073746674 data@var1272 .@expr1073746675 end (@expr1073746676 ) ) ?@expr1073746677 nullptr :@expr1073746678 &@expr1073746679 it@var1274 .@expr1073746680 second@var1275 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1276 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1277 ,
654: const Settings * settings@var1278 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1279 = nullptr ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1280 ( nullptr ) , num@var1281 ( 0 ) , known@var1282 ( true ) { }
62:
63: const Token * tok@var1280 ;
64: long long num@var1281 ;
65: bool known@var1282 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1283 ;
72: const Scope * classScope@var1284 ;
73: const Scope * enclosingScope@var1285 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1286 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1288 ( nullptr ) , nameTok@var1289 ( nullptr ) , access@var1290 ( AccessControl :: Public ) , isVirtual@var1291 ( false ) { }
82:
83: std :: string name@var1287 ;
84: const Type * type@var1288 ;
85: const Token * nameTok@var1289 ;
86: AccessControl access@var1290 ;
87: bool isVirtual@var1291 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1292 ) const {
90: return this@expr1073746681 .@expr1073746682 type@var1288 <@expr1073746683 rhs@var1292 .@expr1073746684 type@var1293 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1294 ( nullptr ) , nameEnd@var1295 ( nullptr ) , type@var1296 ( nullptr ) { }
97:
98: const Token * nameStart@var1294 ;
99: const Token * nameEnd@var1295 ;
100: const Type * type@var1296 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1297 ;
104: std :: vector < FriendInfo > friendList@var1298 ;
105:
106: const Token * typeStart@var1299 ;
107: const Token * typeEnd@var1300 ;
108: long long sizeOf@var1301 ;
109:
110: Type ( const Token * classDef_@var1302 = nullptr , const Scope * classScope_@var1303 = nullptr , const Scope * enclosingScope_@var1304 = nullptr ) :
111: classDef@var1283 ( classDef_@var1302 ) ,
112: classScope@var1284 ( classScope_@var1303 ) ,
113: enclosingScope@var1285 ( enclosingScope_@var1304 ) ,
114: needInitialization@var1286 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1299 ( nullptr ) ,
116: typeEnd@var1300 ( nullptr ) ,
117: sizeOf@var1301 ( 0 ) {
118: if (@expr1073746685 classDef_@var1302 &&@expr1073746686 classDef_@var1302 .@expr4863 str (@expr4864 ) ==@expr1073746689 "enum" ) {
119: needInitialization@var1286 =@expr1073746690 NeedInitialization ::@expr1073746691 True ; }
120: else { if (@expr1073746692 classDef_@var1302 &&@expr1073746693 classDef_@var1302 .@expr4863 str (@expr4864 ) ==@expr1073746696 "using" ) {
121: typeStart@var1299 =@expr1073746697 classDef@var1283 .@expr1073746698 tokAt (@expr1073746699 3 ) ;
122: typeEnd@var1300 =@expr1073746700 typeStart@var1299 ;
123: while (@expr1073746701 typeEnd@var1300 .@expr4878 next (@expr4879 ) &&@expr1073746704 typeEnd@var1300 .@expr4878 next (@expr4879 ) .@expr1073746707 str (@expr1073746708 ) !=@expr1073746709 ";" ) {
124: typeEnd@var1300 =@expr1073746710 typeEnd@var1300 .@expr4878 next (@expr4879 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1283 ?@expr1073746713 classDef@var1283 .@expr1073746714 str (@expr1073746715 ) :@expr1073746716 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1283 &&@expr1073746717 classDef@var1283 .@expr1073746718 str (@expr1073746719 ) ==@expr1073746720 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1305 , const Token * tok1@var1306 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1307 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1308 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1309 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1310 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1311 ) : scope@var1312 ( scope_@var1311 ) , name@var1313 ( nullptr ) , value@var1314 ( 0 ) , start@var1315 ( nullptr ) , end@var1316 ( nullptr ) , value_known@var1317 ( false ) { }
167: const Scope * scope@var1312 ;
168: const Token * name@var1313 ;
169: long long value@var1314 ;
170: const Token * start@var1315 ;
171: const Token * end@var1316 ;
172: bool value_known@var1317 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1318 ) const {
204: return (@expr4897 (@expr4897 mFlags@var1354 &@expr1073746723 flag_@var1318 ) !=@expr1073746724 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1319 , bool state_@var1320 ) {
213: mFlags@var1354 =@expr1073746725 state_@var1320 ?@expr1073746726 mFlags@var1354 |@expr1073746727 flag_@var1319 :@expr1073746728 mFlags@var1354 &@expr1073746729 ~@expr1073746730 flag_@var1319 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1321 , bool * isContainer@var1322 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1323 , const Token * start_@var1324 , const Token * end_@var1325 ,
226: int index_@var1326 , AccessControl access_@var1327 , const Type * type_@var1328 ,
227: const Scope * scope_@var1329 , const Settings * settings@var1330 )
228: : mNameToken@var1349 ( name_@var1323 ) ,
229: mTypeStartToken@var1350 ( start_@var1324 ) ,
230: mTypeEndToken@var1351 ( end_@var1325 ) ,
231: mIndex@var1352 ( index_@var1326 ) ,
232: mAccess@var1353 ( access_@var1327 ) ,
233: mFlags@var1354 ( 0 ) ,
234: mType@var1355 ( type_@var1328 ) ,
235: mScope@var1356 ( scope_@var1329 ) ,
236: mValueType@var1357 ( nullptr ) {
237: evaluate (@expr1073746731 settings@var1330 ) ;
238: }
239:
240: Variable ( const Token * name_@var1331 , const std :: string & clangType@var1332 , const Token * typeStart@var1333 ,
241: const Token * typeEnd@var1334 , int index_@var1335 , AccessControl access_@var1336 ,
242: const Type * type_@var1337 , const Scope * scope_@var1338 ) ;
243:
244: Variable ( const Variable & var@var1339 , const Scope * scope@var1340 ) ;
245:
246: Variable ( const Variable & var@var1341 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1342 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1349 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1350 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1351 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746732 mNameToken@var1349 ) {
300: return mNameToken@var1349 .@expr1073746733 str (@expr1073746734 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746735 mNameToken@var1349 ) {
312: return mNameToken@var1349 .@expr1073746736 varId (@expr1073746737 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1352 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1353 ==@expr1073746738 AccessControl ::@expr1073746739 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1353 ==@expr1073746740 AccessControl ::@expr1073746741 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1353 ==@expr1073746742 AccessControl ::@expr1073746743 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1353 ==@expr1073746744 AccessControl ::@expr1073746745 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1353 ==@expr1073746746 AccessControl ::@expr1073746747 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1353 ==@expr1073746748 AccessControl ::@expr1073746749 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746751 mAccess@var1353 ==@expr1073746752 AccessControl ::@expr1073746753 Local@expr1073746750 ) &&@expr1073746754 !@expr1073746755 isExtern (@expr1073746756 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746757 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746758 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746759 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746760 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746761 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1353 ==@expr1073746762 AccessControl ::@expr1073746763 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746764 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746765 fIsArray ) &&@expr1073746766 !@expr1073746767 getFlag (@expr1073746768 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746769 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746770 ) &&@expr1073746771 getFlag (@expr1073746772 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746773 fIsArray ) ||@expr1073746774 getFlag (@expr1073746775 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746776 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746777 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746778 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746779 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1355 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1355 ?@expr1073746780 mType@var1355 .@expr1073746781 classScope@var1360 :@expr1073746782 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1356 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1358 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1343 ) const {
550: return mDimensions@var1358 [@expr1073746783 index_@var1343 ] .@expr1073746784 num@var3459 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1344 ) const {
558: return mDimensions@var1358 [@expr1073746785 index_@var1344 ] .@expr1073746786 known@var3460 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746787 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746788 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746789 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1345 ) const {
602: return isStlType (@expr1073746790 ) &&@expr1073746791 stlType@var1345 ==@expr1073746792 mTypeStartToken@var1350 .@expr1073746793 strAt (@expr1073746794 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1346 ) const {
616: return isStlType (@expr1073746795 ) &&@expr1073746796 stlTypes@var1346 .@expr1073746797 find (@expr1073746798 mTypeStartToken@var1350 .@expr1073746799 strAt (@expr1073746800 2 ) ) !=@expr1073746801 stlTypes@var1346 .@expr1073746802 end (@expr1073746803 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746804 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4981 ) &&@expr1073746806 type (@expr4981 ) .@expr1073746808 isEnumType (@expr1073746809 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746810 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1357 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1347 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1353 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1348 ) {
660: mType@var1355 =@expr1073746811 t@var1348 ;
661: }
662:
663:
664: const Token * mNameToken@var1349 ;
665:
666:
667: const Token * mTypeStartToken@var1350 ;
668:
669:
670: const Token * mTypeEndToken@var1351 ;
671:
672:
673: int mIndex@var1352 ;
674:
675:
676: AccessControl mAccess@var1353 ;
677:
678:
679: unsigned int mFlags@var1354 ;
680:
681:
682: const Type * mType@var1355 ;
683:
684:
685: const Scope * mScope@var1356 ;
686:
687: ValueType * mValueType@var1357 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1358 ;
691:
692:
693: void evaluate ( const Settings * settings@var1359 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1361 ) const {
735: return (@expr4988 (@expr4988 mFlags@var1410 &@expr1073746814 flag@var1361 ) !=@expr1073746815 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1362 , bool state@var1363 ) {
744: mFlags@var1410 =@expr1073746816 state@var1363 ?@expr1073746817 mFlags@var1410 |@expr1073746818 flag@var1362 :@expr1073746819 mFlags@var1410 &@expr1073746820 ~@expr1073746821 flag@var1362 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1364 , const Token * tok@var1365 , const Scope * scope@var1366 , const Token * tokDef@var1367 , const Token * tokArgDef@var1368 ) ;
751: Function ( const Token * tokenDef@var1369 , const std :: string & clangType@var1370 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1380 .@expr1073746822 str (@expr1073746823 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1388 .@expr1073746824 size (@expr1073746825 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1388 .@expr1073746826 size (@expr1073746827 ) -@expr1073746828 initArgCount@var1389 ;
764: }
765: const Variable * getArgumentVar ( int num@var1371 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1389 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1372 , const Scope * scope@var1373 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1374 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1375 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1390 ==@expr1073746829 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1390 ==@expr1073746830 eConstructor ||@expr1073746831
785: type@var1390 ==@expr1073746832 eCopyConstructor ||@expr1073746833
786: type@var1390 ==@expr1073746834 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1390 ==@expr1073746835 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1380 .@expr1073746836 isAttributeConstructor (@expr1073746837 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1380 .@expr1073746838 isAttributeDestructor (@expr1073746839 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1380 .@expr1073746840 isAttributePure (@expr1073746841 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1380 .@expr1073746842 isAttributeConst (@expr1073746843 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1380 .@expr1073746844 isAttributeNoreturn (@expr1073746845 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1380 .@expr1073746846 isAttributeNothrow (@expr1073746847 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1380 .@expr1073746848 isAttributeNodiscard (@expr1073746849 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746850 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746851 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746852 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746853 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746854 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746855 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746856 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746857 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746858 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746859 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746860 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746861 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746862 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746863 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746864 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746865 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746866 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746867 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746868 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746869 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746870 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746871 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1376 ) {
881: setFlag (@expr1073746872 fHasBody , state@var1376 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746873 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746874 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1377 ) {
891: setFlag (@expr1073746875 fIsEscapeFunction , state@var1377 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746876 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1378 ) {
898: setFlag (@expr1073746877 fIsConstexpr , state@var1378 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1379 ) const ;
901:
902: const Token * tokenDef@var1380 ;
903: const Token * argDef@var1381 ;
904: const Token * token@var1382 ;
905: const Token * arg@var1383 ;
906: const Token * retDef@var1384 ;
907: const :: Type * retType@var1385 ;
908: const Scope * functionScope@var1386 ;
909: const Scope * nestedIn@var1387 ;
910: std :: list < Variable > argumentList@var1388 ;
911: int initArgCount@var1389 ;
912: Type type@var1390 ;
913: AccessControl access@var1391 ;
914: const Token * noexceptArg@var1392 ;
915: const Token * throwArg@var1393 ;
916: const Token * templateDef@var1394 ;
917: const Token * functionPointerUsage@var1395 ;
918:
919: bool argsMatch ( const Scope * scope@var1396 , const Token * first@var1397 , const Token * second@var1398 , const std :: string & path@var1399 , int path_length@var1400 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1401 , bool unknown@var1402 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1403 , bool unknown@var1404 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1405 , bool unknown@var1406 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1407 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746878 this@expr1073746879 .@expr1073746880 hasTrailingReturnType (@expr1073746881 ) ) {
931: return Token ::@expr1073746882 findmatch (@expr1073746883 retDef@var1384 , "{|;" ) ;
932: } else {
933: return tokenDef@var1380 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1408 , bool * foundAllBaseClasses@var1409 ) const ;
946:
947: unsigned int mFlags@var1410 ;
948:
949: void isInline ( bool state@var1411 ) {
950: setFlag (@expr1073746884 fIsInline , state@var1411 ) ;
951: }
952: void isConst ( bool state@var1412 ) {
953: setFlag (@expr1073746885 fIsConst , state@var1412 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1413 ) {
956: setFlag (@expr1073746886 fHasVirtualSpecifier , state@var1413 ) ;
957: }
958: void isPure ( bool state@var1414 ) {
959: setFlag (@expr1073746887 fIsPure , state@var1414 ) ;
960: }
961: void isStatic ( bool state@var1415 ) {
962: setFlag (@expr1073746888 fIsStatic , state@var1415 ) ;
963: }
964: void isStaticLocal ( bool state@var1416 ) {
965: setFlag (@expr1073746889 fIsStaticLocal , state@var1416 ) ;
966: }
967: void isExtern ( bool state@var1417 ) {
968: setFlag (@expr1073746890 fIsExtern , state@var1417 ) ;
969: }
970: void isFriend ( bool state@var1418 ) {
971: setFlag (@expr1073746891 fIsFriend , state@var1418 ) ;
972: }
973: void isExplicit ( bool state@var1419 ) {
974: setFlag (@expr1073746892 fIsExplicit , state@var1419 ) ;
975: }
976: void isDefault ( bool state@var1420 ) {
977: setFlag (@expr1073746893 fIsDefault , state@var1420 ) ;
978: }
979: void isDelete ( bool state@var1421 ) {
980: setFlag (@expr1073746894 fIsDelete , state@var1421 ) ;
981: }
982: void isNoExcept ( bool state@var1422 ) {
983: setFlag (@expr1073746895 fIsNoExcept , state@var1422 ) ;
984: }
985: void isThrow ( bool state@var1423 ) {
986: setFlag (@expr1073746896 fIsThrow , state@var1423 ) ;
987: }
988: void isOperator ( bool state@var1424 ) {
989: setFlag (@expr1073746897 fIsOperator , state@var1424 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1425 ) {
992: setFlag (@expr1073746898 fHasLvalRefQual , state@var1425 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1426 ) {
995: setFlag (@expr1073746899 fHasRvalRefQual , state@var1426 ) ;
996: }
997: void isVariadic ( bool state@var1427 ) {
998: setFlag (@expr1073746900 fIsVariadic , state@var1427 ) ;
999: }
1000: void isVolatile ( bool state@var1428 ) {
1001: setFlag (@expr1073746901 fIsVolatile , state@var1428 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1429 ) {
1004: return setFlag (@expr1073746902 fHasTrailingReturnType , state@var1429 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1430 ) {
1007: setFlag (@expr1073746903 fIsInlineKeyword , state@var1430 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1431 , const Scope * scope@var1432 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1433 ;
1019: const Scope * scope@var1434 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1435 , const Token * classDef_@var1436 , const Scope * nestedIn_@var1437 ) ;
1025: Scope ( const SymbolDatabase * check_@var1438 , const Token * classDef_@var1439 , const Scope * nestedIn_@var1440 , ScopeType type_@var1441 , const Token * start_@var1442 ) ;
1026:
1027: const SymbolDatabase * check@var1443 ;
1028: std :: string className@var1444 ;
1029: const Token * classDef@var1445 ;
1030: const Token * bodyStart@var1446 ;
1031: const Token * bodyEnd@var1447 ;
1032: std :: list < Function > functionList@var1448 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1449 ;
1034: std :: list < Variable > varlist@var1450 ;
1035: const Scope * nestedIn@var1451 ;
1036: std :: list < Scope * > nestedList@var1452 ;
1037: int numConstructors@var1453 ;
1038: int numCopyOrMoveConstructors@var1454 ;
1039: std :: list < UsingInfo > usingList@var1455 ;
1040: ScopeType type@var1456 ;
1041: Type * definedType@var1457 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1458 ;
1043: std :: vector < const Token * > bodyStartList@var1459 ;
1044:
1045:
1046: const Scope * functionOf@var1460 ;
1047: Function * function@var1461 ;
1048:
1049:
1050: const Token * enumType@var1462 ;
1051: bool enumClass@var1463 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1464 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1465 ) {
1056: bodyStart@var1446 =@expr1073746904 start@var1465 ;
1057: bodyEnd@var1447 =@expr1073746905 start@var1465 ?@expr1073746906 start@var1465 .@expr1073746907 link (@expr1073746908 ) :@expr1073746909 nullptr ;
1058: if (@expr1073746910 start@var1465 ) {
1059: bodyStartList@var1459 .@expr1073746911 push_back (@expr1073746912 start@var1465 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1444 .@expr1073746913 size (@expr1073746914 ) >@expr1073746915 9 &&@expr1073746916 className@var1444 .@expr1073746917 compare (@expr1073746918 0 , 9 , "Anonymous" ) ==@expr1073746919 0 &&@expr1073746920 std ::@expr1073746921 isdigit (@expr1073746922 className@var1444 [@expr1073746923 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1466 ) const {
1068: for (@expr1073746924 const Enumerator &@expr1073746925 i@var1467 :@expr1073746926 enumeratorList@var1464 ) {
1069: if (@expr1073746927 i@var1467 .@expr1073746928 name@var1468 .@expr1073746929 str (@expr1073746930 ) ==@expr1073746931 name@var1466 ) {
1070: return &@expr1073746932 i@var1467 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1469 ) const {
1076: if (@expr1073746933 !@expr1073746934 outer@var1469 ) {
1077: return false ; }
1078: if (@expr1073746935 outer@var1469 ==@expr1073746936 this@expr1073746937 ) {
1079: return true ; }
1080: const Scope * parent@var1470 ; parent@var1470 =@expr1073746938 nestedIn@var1451 ;
1081: while (@expr1073746939 outer@var1469 !=@expr1073746940 parent@var1470 &&@expr1073746941 parent@var1470 ) {
1082: parent@var1470 =@expr1073746942 parent@var1470 .@expr1073746943 nestedIn@var1471 ; }
1083: if (@expr1073746944 parent@var1470 &&@expr1073746945 parent@var1470 ==@expr1073746946 outer@var1469 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1472 ) {
1089: while (@expr1073746947 scope@var1472 ) {
1090: if (@expr1073746948 scope@var1472 .@expr1073746949 type@var1473 ==@expr1073746950 Scope ::@expr1073746951 eFunction ) {
1091: break ; }
1092: scope@var1472 =@expr1073746952 scope@var1472 .@expr1073746953 nestedIn@var1474 ;
1093: }
1094: if (@expr1073746954 !@expr1073746955 scope@var1472 ) {
1095: return nullptr ; }
1096: return scope@var1472 .@expr1073746956 function@var1475 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746957 type@var1456 ==@expr1073746958 eClass ||@expr1073746959 type@var1456 ==@expr1073746960 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746961 type@var1456 ==@expr1073746962 eClass ||@expr1073746963 type@var1456 ==@expr1073746964 eStruct ||@expr1073746965 type@var1456 ==@expr1073746966 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1456 !=@expr1073746967 eClass &&@expr1073746968 type@var1456 !=@expr1073746969 eStruct &&@expr1073746970 type@var1456 !=@expr1073746971 eUnion &&@expr1073746972 type@var1456 !=@expr1073746973 eGlobal &&@expr1073746974 type@var1456 !=@expr1073746975 eNamespace &&@expr1073746976 type@var1456 !=@expr1073746977 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1456 ==@expr1073746978 Scope ::@expr5155 ScopeType ::@expr1073746980 eFor ||@expr1073746981 type@var1456 ==@expr1073746982 Scope ::@expr5155 ScopeType ::@expr1073746984 eWhile ||@expr1073746985 type@var1456 ==@expr1073746986 Scope ::@expr5155 ScopeType ::@expr1073746988 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746989 type@var1456 ==@expr1073746990 eIf ||@expr1073746991 type@var1456 ==@expr1073746992 eElse ||@expr1073746993
1117: type@var1456 ==@expr1073746994 eFor ||@expr1073746995 type@var1456 ==@expr1073746996 eWhile ||@expr1073746997 type@var1456 ==@expr1073746998 eDo ||@expr1073746999
1118: type@var1456 ==@expr1073747000 eSwitch ||@expr1073747001 type@var1456 ==@expr1073747002 eUnconditional ||@expr1073747003
1119: type@var1456 ==@expr1073747004 eTry ||@expr1073747005 type@var1456 ==@expr1073747006 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1476 , bool requireConst@var1477 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1478 , bool isC@var1479 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1480 ) {
1135: return const_cast < Scope *@expr5183 > (@expr1073747008 const_cast < const Scope *@expr5183 > (@expr1073747010 this@expr1073747011 ) .@expr1073747012 findRecordInNestedList (@expr1073747013 name@var1480 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1481 ) const ;
1139: Type * findType ( const std :: string & name@var1482 ) {
1140: return const_cast < Type *@expr5190 > (@expr1073747015 const_cast < const Scope *@expr5190 > (@expr1073747017 this@expr1073747018 ) .@expr1073747019 findType (@expr1073747020 name@var1482 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1483 ) ;
1148:
1149: void addVariable ( const Token * token_@var1484 , const Token * start_@var1485 ,
1150: const Token * end_@var1486 , AccessControl access_@var1487 , const Type * type_@var1488 ,
1151: const Scope * scope_@var1489 , const Settings * settings@var1490 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1491 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1492 ) {
1159: functionList@var1448 .@expr1073747021 push_back (@expr1073747022 func@var1492 ) ;
1160:
1161: const Function * back@var1493 ; back@var1493 =@expr1073747023 &@expr1073747024 functionList@var1448 .@expr1073747025 back (@expr1073747026 ) ;
1162:
1163: functionMap@var1449 .@expr1073747027 insert (@expr1073747028 make_pair (@expr1073747029 back@var1493 .@expr1073747030 tokenDef@var1494 .@expr1073747031 str (@expr1073747032 ) , back@var1493 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1495 , AccessControl varaccess@var1496 , const Settings * settings@var1497 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1498 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1499 , bool isCpp@var1500 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1501 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1502 , const Token * & vartok@var1503 , const Token * & typetok@var1504 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1505 , int args@var1506 , std :: vector < const Function * > & matches@var1507 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1508 , const Token * start@var1509 , const Token * end@var1510 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1511 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1512 ;
1239: int bits@var1513 ;
1240: int pointer@var1514 ;
1241: int constness@var1515 ;
1242: Reference reference@var1516 ; reference@var1516 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1517 ;
1245: const :: Type * smartPointerType@var1518 ;
1246: const Token * smartPointerTypeToken@var1519 ;
1247: const Library :: SmartPointer * smartPointer@var1520 ;
1248: const Library :: Container * container@var1521 ;
1249:
1250: const Token * containerTypeToken@var1522 ;
1251:
1252: std :: string originalTypeName@var1523 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1511 ( UNKNOWN_SIGN ) ,
1257: type@var1512 ( UNKNOWN_TYPE ) ,
1258: bits@var1513 ( 0 ) ,
1259: pointer@var1514 ( 0U ) ,
1260: constness@var1515 ( 0U ) ,
1261: typeScope@var1517 ( nullptr ) ,
1262: smartPointerType@var1518 ( nullptr ) ,
1263: smartPointerTypeToken@var1519 ( nullptr ) ,
1264: smartPointer@var1520 ( nullptr ) ,
1265: container@var1521 ( nullptr ) ,
1266: containerTypeToken@var1522 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1524 , enum Type t@var1525 , int p@var1526 )
1269: : sign@var1511 ( s@var1524 ) ,
1270: type@var1512 ( t@var1525 ) ,
1271: bits@var1513 ( 0 ) ,
1272: pointer@var1514 ( p@var1526 ) ,
1273: constness@var1515 ( 0U ) ,
1274: typeScope@var1517 ( nullptr ) ,
1275: smartPointerType@var1518 ( nullptr ) ,
1276: smartPointerTypeToken@var1519 ( nullptr ) ,
1277: smartPointer@var1520 ( nullptr ) ,
1278: container@var1521 ( nullptr ) ,
1279: containerTypeToken@var1522 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1527 , enum Type t@var1528 , int p@var1529 , int c@var1530 )
1282: : sign@var1511 ( s@var1527 ) ,
1283: type@var1512 ( t@var1528 ) ,
1284: bits@var1513 ( 0 ) ,
1285: pointer@var1514 ( p@var1529 ) ,
1286: constness@var1515 ( c@var1530 ) ,
1287: typeScope@var1517 ( nullptr ) ,
1288: smartPointerType@var1518 ( nullptr ) ,
1289: smartPointerTypeToken@var1519 ( nullptr ) ,
1290: smartPointer@var1520 ( nullptr ) ,
1291: container@var1521 ( nullptr ) ,
1292: containerTypeToken@var1522 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1531 , enum Type t@var1532 , int p@var1533 , int c@var1534 , const std :: string & otn@var1535 )
1295: : sign@var1511 ( s@var1531 ) ,
1296: type@var1512 ( t@var1532 ) ,
1297: bits@var1513 ( 0 ) ,
1298: pointer@var1514 ( p@var1533 ) ,
1299: constness@var1515 ( c@var1534 ) ,
1300: typeScope@var1517 ( nullptr ) ,
1301: smartPointerType@var1518 ( nullptr ) ,
1302: smartPointerTypeToken@var1519 ( nullptr ) ,
1303: smartPointer@var1520 ( nullptr ) ,
1304: container@var1521 ( nullptr ) ,
1305: containerTypeToken@var1522 ( nullptr ) ,
1306: originalTypeName@var1523 ( otn@var1535 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1536 , const Settings * settings@var1537 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1538 , bool longType@var1539 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1540 , const ValueType * func@var1541 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1542 , const Variable * callVar@var1543 , const Variable * funcVar@var1544 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073747033 type@var1512 >=@expr1073747034 ValueType ::@expr1073747035 Type ::@expr1073747036 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073747037 type@var1512 >=@expr1073747038 ValueType ::@expr5215 Type ::@expr1073747040 BOOL &&@expr1073747041 type@var1512 <=@expr1073747042 ValueType ::@expr5215 Type ::@expr1073747044 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073747045 type@var1512 >=@expr1073747046 ValueType ::@expr5223 Type ::@expr1073747048 FLOAT &&@expr1073747049 type@var1512 <=@expr1073747050 ValueType ::@expr5223 Type ::@expr1073747052 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1545 , const Settings * settings@var1546 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1517 &&@expr1073747053 typeScope@var1517 .@expr1073747054 type@var1547 ==@expr1073747055 Scope ::@expr1073747056 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1548 , bool p@var1549 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1550 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1551 , const Settings * settings@var1552 , ErrorLogger * errorLogger@var1553 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1554 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1555 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1556 ;
1359:
1360:
1361: std :: list < Type > typeList@var1557 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1558 , const Token * typeTok@var1559 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1560 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1561 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1562 , const Scope * startScope@var1563 , bool lookOutside@var1564 = false ) const ;
1382: Type * findType ( const Token * startTok@var1565 , Scope * startScope@var1566 , bool lookOutside@var1567 = false ) const {
1383: return const_cast < Type *@expr5233 > (@expr1073747058 this@expr1073747059 .@expr1073747060 findType (@expr1073747061 startTok@var1565 , const_cast < const Scope *@expr5233 > (@expr1073747063 startScope@var1566 ) , lookOutside@var1567 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1568 , const Scope * startScope@var1569 ) const ;
1387: Scope * findScope ( const Token * tok@var1570 , Scope * startScope@var1571 ) const {
1388: return const_cast < Scope *@expr5240 > (@expr1073747065 this@expr1073747066 .@expr1073747067 findScope (@expr1073747068 tok@var1570 , const_cast < const Scope *@expr5240 > (@expr1073747070 startScope@var1571 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1572 ) const {
1392: return varid@var1572 <@expr1073747071 mVariableList@var1629 .@expr1073747072 size (@expr1073747073 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1573 ) const {
1396: return mVariableList@var1629 .@expr1073747074 at (@expr1073747075 varId@var1573 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1629 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1574 , const std :: string & type@var1575 , const std :: string & msg@var1576 ) const ;
1407:
1408: void printOut ( const char * title@var1577 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1578 , const char * indent@var1579 ) const ;
1410: void printXml ( std :: ostream & out@var1580 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1581 , Token * tokens@var1582 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1583 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1584 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1585 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1586 , const Token * * tok@var1587 , const Token * argStart@var1588 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1589 , const Token * tok@var1590 , const Token * argStart@var1591 , const Token * funcStart@var1592 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1593 , const Token * & tok@var1594 , const Token * argStart@var1595 , const Token * funcStart@var1596 ) ;
1469: void addNewFunction ( Scope * * scope@var1597 , const Token * * tok@var1598 ) ;
1470: bool isFunction ( const Token * tok@var1599 , const Scope * outerScope@var1600 , const Token * * funcStart@var1601 , const Token * * argStart@var1602 , const Token * * declEnd@var1603 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1604 , const Scope * startScope@var1605 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1606 , const Scope * scope@var1607 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1608 , const Scope * ns@var1609 , const std :: string & path@var1610 , int path_length@var1611 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1612 , const Token * typeTok@var1613 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1614 , const Token * vartok@var1615 , Token * membertok@var1616 , const Variable * membervar@var1617 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1618 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1619 ) const ;
1485:
1486: void setValueType ( Token * tok@var1620 , const ValueType & valuetype@var1621 ) ;
1487: void setValueType ( Token * tok@var1622 , const Variable & var@var1623 ) ;
1488: void setValueType ( Token * tok@var1624 , const Enumerator & enumerator@var1625 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1626 ;
1491: const Settings * mSettings@var1627 ;
1492: ErrorLogger * mErrorLogger@var1628 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1629 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1630 ;
1499:
1500: bool mIsCpp@var1631 ;
1501: ValueType :: Sign mDefaultSignedness@var1632 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1633 ;
1505: } ;

##file cppcheck-2.8/lib/checkclass.h

1:
|
35:
36: class ErrorLogger ;
37: class Settings ;
38: class Token ;
39:
40: namespace CTU {
41: class FileInfo ;
42: }
43:
44: namespace tinyxml2 {
45: class XMLElement ;
46: }
47:
|
52:
53: class CheckClass : public Check {
54: public:
55:
56: CheckClass ( ) : Check ( myName ( ) ) , mSymbolDatabase@var1666 ( nullptr ) { }
57:
58:
59: CheckClass ( const Tokenizer * tokenizer@var1634 , const Settings * settings@var1635 , ErrorLogger * errorLogger@var1636 ) ;
60:
61:
62: void runChecks ( const Tokenizer * tokenizer@var1637 , const Settings * settings@var1638 , ErrorLogger * errorLogger@var1639 ) override {
63: if (@expr1073747076 tokenizer@var1637 .@expr1073747077 isC (@expr1073747078 ) ) {
64: return ; }
65:
66: CheckClass checkClass@var1640 (@expr1073747079 tokenizer@var1637 , settings@var1638 , errorLogger@var1639 ) ;
67:
68:
69: checkClass@var1640 .@expr1073747080 checkMemset (@expr1073747081 ) ;
70: checkClass@var1640 .@expr1073747082 constructors (@expr1073747083 ) ;
71: checkClass@var1640 .@expr1073747084 privateFunctions (@expr1073747085 ) ;
72: checkClass@var1640 .@expr1073747086 operatorEqRetRefThis (@expr1073747087 ) ;
73: checkClass@var1640 .@expr1073747088 thisSubtraction (@expr1073747089 ) ;
74: checkClass@var1640 .@expr1073747090 operatorEqToSelf (@expr1073747091 ) ;
75: checkClass@var1640 .@expr1073747092 initializerListOrder (@expr1073747093 ) ;
76: checkClass@var1640 .@expr1073747094 initializationListUsage (@expr1073747095 ) ;
77: checkClass@var1640 .@expr1073747096 checkSelfInitialization (@expr1073747097 ) ;
78: checkClass@var1640 .@expr1073747098 virtualDestructor (@expr1073747099 ) ;
79: checkClass@var1640 .@expr1073747100 checkConst (@expr1073747101 ) ;
80: checkClass@var1640 .@expr1073747102 copyconstructors (@expr1073747103 ) ;
81: checkClass@var1640 .@expr1073747104 checkVirtualFunctionCallInConstructor (@expr1073747105 ) ;
82: checkClass@var1640 .@expr1073747106 checkDuplInheritedMembers (@expr1073747107 ) ;
83: checkClass@var1640 .@expr1073747108 checkExplicitConstructors (@expr1073747109 ) ;
84: checkClass@var1640 .@expr1073747110 checkCopyCtorAndEqOperator (@expr1073747111 ) ;
85: checkClass@var1640 .@expr1073747112 checkOverride (@expr1073747113 ) ;
86: checkClass@var1640 .@expr1073747114 checkThisUseAfterFree (@expr1073747115 ) ;
87: checkClass@var1640 .@expr1073747116 checkUnsafeClassRefMember (@expr1073747117 ) ;
88: }
89:
90:
91: void constructors ( ) ;
92:
93:
94:
95: void checkExplicitConstructors ( ) ;
96:
97:
98: void privateFunctions ( ) ;
99:
|
107:
108: void checkMemset ( ) ;
109: void checkMemsetType ( const Scope * start@var1641 , const Token * tok@var1642 , const Scope * type@var1643 , bool allocation@var1644 , std :: set < const Scope * > parsedTypes@var1645 ) ;
110:
111:
112: void operatorEqRetRefThis ( ) ;
113:
114:
115: void operatorEqToSelf ( ) ;
116:
117:
118: void virtualDestructor ( ) ;
119:
120:
121: void thisSubtraction ( ) ;
122:
123:
124: void checkConst ( ) ;
125:
126:
127: void initializerListOrder ( ) ;
128:
129:
130: void initializationListUsage ( ) ;
131:
132:
133: void checkSelfInitialization ( ) ;
134:
135: void copyconstructors ( ) ;
136:
137:
138: void checkVirtualFunctionCallInConstructor ( ) ;
139:
140:
141: void checkDuplInheritedMembers ( ) ;
142:
143:
144: void checkCopyCtorAndEqOperator ( ) ;
145:
146:
147: void checkOverride ( ) ;
148:
149:
150: void checkThisUseAfterFree ( ) ;
151:
152:
153: void checkUnsafeClassRefMember ( ) ;
154:
155:
156:
157: class MyFileInfo : public Check :: FileInfo {
158: public:
159: struct NameLoc {
160: std :: string className@var1646 ;
161: std :: string fileName@var1647 ;
162: int lineNumber@var1648 ;
163: int column@var1649 ;
164: unsigned long hash@var1650 ;
165:
166: bool operator== ( const NameLoc & other@var1651 ) const {
167: return isSameLocation (@expr1073747118 other@var1651 ) &&@expr1073747119 hash@var1650 ==@expr1073747120 other@var1651 .@expr1073747121 hash@var1652 ;
168: }
169:
170: bool isSameLocation ( const NameLoc & other@var1653 ) const {
171: return fileName@var1647 ==@expr1073747122 other@var1653 .@expr1073747123 fileName@var1654 &&@expr1073747124
172: lineNumber@var1648 ==@expr1073747125 other@var1653 .@expr1073747126 lineNumber@var1655 &&@expr1073747127
173: column@var1649 ==@expr1073747128 other@var1653 .@expr1073747129 column@var1656 ;
174: }
175: } ;
176: std :: vector < NameLoc > classDefinitions@var1657 ;
177:
178:
179: std :: string toString ( ) const override ;
180: } ;
181:
182:
183: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var1658 , const Settings * settings@var1659 ) const override ;
184:
185: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var1660 ) const override ;
186:
187:
188: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var1661 , const std :: list < Check :: FileInfo * > & fileInfo@var1662 , const Settings & settings@var1663 , ErrorLogger & errorLogger@var1664 ) override ;
189:
190:
191: static const std :: set < std :: string > stl_containers_not_const@var1665 ;
192:
193: private:
194: const SymbolDatabase * mSymbolDatabase@var1666 ;
195:
196:
197: void noConstructorError ( const Token * tok@var1667 , const std :: string & classname@var1668 , bool isStruct@var1669 ) ;
198: void noExplicitConstructorError ( const Token * tok@var1670 , const std :: string & classname@var1671 , bool isStruct@var1672 ) ;
199:
200: void copyConstructorShallowCopyError ( const Token * tok@var1673 , const std :: string & varname@var1674 ) ;
201: void noCopyConstructorError ( const Scope * scope@var1675 , bool isdefault@var1676 , const Token * alloc@var1677 , bool inconclusive@var1678 ) ;
202: void noOperatorEqError ( const Scope * scope@var1679 , bool isdefault@var1680 , const Token * alloc@var1681 , bool inconclusive@var1682 ) ;
203: void noDestructorError ( const Scope * scope@var1683 , bool isdefault@var1684 , const Token * alloc@var1685 ) ;
204: void uninitVarError ( const Token * tok@var1686 , bool isprivate@var1687 , Function :: Type functionType@var1688 , const std :: string & classname@var1689 , const std :: string & varname@var1690 , bool derived@var1691 , bool inconclusive@var1692 ) ;
205: void uninitVarError ( const Token * tok@var1693 , const std :: string & classname@var1694 , const std :: string & varname@var1695 ) ;
206: void missingMemberCopyError ( const Token * tok@var1696 , Function :: Type functionType@var1697 , const std :: string & classname@var1698 , const std :: string & varname@var1699 ) ;
207: void operatorEqVarError ( const Token * tok@var1700 , const std :: string & classname@var1701 , const std :: string & varname@var1702 , bool inconclusive@var1703 ) ;
208: void unusedPrivateFunctionError ( const Token * tok@var1704 , const std :: string & classname@var1705 , const std :: string & funcname@var1706 ) ;
209: void memsetError ( const Token * tok@var1707 , const std :: string & memfunc@var1708 , const std :: string & classname@var1709 , const std :: string & type@var1710 ) ;
210: void memsetErrorReference ( const Token * tok@var1711 , const std :: string & memfunc@var1712 , const std :: string & type@var1713 ) ;
211: void memsetErrorFloat ( const Token * tok@var1714 , const std :: string & type@var1715 ) ;
212: void mallocOnClassError ( const Token * tok@var1716 , const std :: string & memfunc@var1717 , const Token * classTok@var1718 , const std :: string & classname@var1719 ) ;
213: void mallocOnClassWarning ( const Token * tok@var1720 , const std :: string & memfunc@var1721 , const Token * classTok@var1722 ) ;
214: void virtualDestructorError ( const Token * tok@var1723 , const std :: string & Base@var1724 , const std :: string & Derived@var1725 , bool inconclusive@var1726 ) ;
215: void thisSubtractionError ( const Token * tok@var1727 ) ;
216: void operatorEqRetRefThisError ( const Token * tok@var1728 ) ;
217: void operatorEqShouldBeLeftUnimplementedError ( const Token * tok@var1729 ) ;
218: void operatorEqMissingReturnStatementError ( const Token * tok@var1730 , bool error@var1731 ) ;
219: void operatorEqToSelfError ( const Token * tok@var1732 ) ;
220: void checkConstError ( const Token * tok@var1733 , const std :: string & classname@var1734 , const std :: string & funcname@var1735 , bool suggestStatic@var1736 ) ;
221: void checkConstError2 ( const Token * tok1@var1737 , const Token * tok2@var1738 , const std :: string & classname@var1739 , const std :: string & funcname@var1740 , bool suggestStatic@var1741 ) ;
222: void initializerListError ( const Token * tok1@var1742 , const Token * tok2@var1743 , const std :: string & classname@var1744 , const std :: string & varname@var1745 ) ;
223: void suggestInitializationList ( const Token * tok@var1746 , const std :: string & varname@var1747 ) ;
224: void selfInitializationError ( const Token * tok@var1748 , const std :: string & varname@var1749 ) ;
225: void pureVirtualFunctionCallInConstructorError ( const Function * scopeFunction@var1750 , const std :: list < const Token * > & tokStack@var1751 , const std :: string & purefuncname@var1752 ) ;
226: void virtualFunctionCallInConstructorError ( const Function * scopeFunction@var1753 , const std :: list < const Token * > & tokStack@var1754 , const std :: string & funcname@var1755 ) ;
227: void duplInheritedMembersError ( const Token * tok1@var1756 , const Token * tok2@var1757 , const std :: string & derivedName@var1758 , const std :: string & baseName@var1759 , const std :: string & variableName@var1760 , bool derivedIsStruct@var1761 , bool baseIsStruct@var1762 ) ;
228: void copyCtorAndEqOperatorError ( const Token * tok@var1763 , const std :: string & classname@var1764 , bool isStruct@var1765 , bool hasCopyCtor@var1766 ) ;
229: void overrideError ( const Function * funcInBase@var1767 , const Function * funcInDerived@var1768 ) ;
230: void thisUseAfterFree ( const Token * self@var1769 , const Token * free@var1770 , const Token * use@var1771 ) ;
231: void unsafeClassRefMemberError ( const Token * tok@var1772 , const std :: string & varname@var1773 ) ;
232: void checkDuplInheritedMembersRecursive ( const Type * typeCurrent@var1774 , const Type * typeBase@var1775 ) ;
233:
234: void getErrorMessages ( ErrorLogger * errorLogger@var1776 , const Settings * settings@var1777 ) const override {
235: CheckClass c@var1778 (@expr1073747130 nullptr , settings@var1777 , errorLogger@var1776 ) ;
236: c@var1778 .@expr1073747131 noConstructorError (@expr1073747132 nullptr , "classname" , false ) ;
237: c@var1778 .@expr1073747133 noExplicitConstructorError (@expr1073747134 nullptr , "classname" , false ) ;
238:
239: c@var1778 .@expr1073747135 copyConstructorShallowCopyError (@expr1073747136 nullptr , "var" ) ;
240: c@var1778 .@expr1073747137 noCopyConstructorError (@expr1073747138 nullptr , false , nullptr , false ) ;
241: c@var1778 .@expr1073747139 noOperatorEqError (@expr1073747140 nullptr , false , nullptr , false ) ;
242: c@var1778 .@expr1073747141 noDestructorError (@expr1073747142 nullptr , false , nullptr ) ;
243: c@var1778 .@expr5319 uninitVarError (@expr1073747144 nullptr , false , Function ::@expr5321 eConstructor , "classname" , "varname" , false , false ) ;
244: c@var1778 .@expr5319 uninitVarError (@expr1073747147 nullptr , true , Function ::@expr5321 eConstructor , "classname" , "varnamepriv" , false , false ) ;
245: c@var1778 .@expr5319 uninitVarError (@expr1073747150 nullptr , false , Function ::@expr5321 eConstructor , "classname" , "varname" , true , false ) ;
246: c@var1778 .@expr5319 uninitVarError (@expr1073747153 nullptr , true , Function ::@expr5321 eConstructor , "classname" , "varnamepriv" , true , false ) ;
247: c@var1778 .@expr1073747155 missingMemberCopyError (@expr1073747156 nullptr , Function ::@expr5321 eConstructor , "classname" , "varnamepriv" ) ;
248: c@var1778 .@expr1073747158 operatorEqVarError (@expr1073747159 nullptr , "classname" , emptyString@var1 , false ) ;
249: c@var1778 .@expr1073747160 unusedPrivateFunctionError (@expr1073747161 nullptr , "classname" , "funcname" ) ;
250: c@var1778 .@expr1073747162 memsetError (@expr1073747163 nullptr , "memfunc" , "classname" , "class" ) ;
251: c@var1778 .@expr1073747164 memsetErrorReference (@expr1073747165 nullptr , "memfunc" , "class" ) ;
252: c@var1778 .@expr1073747166 memsetErrorFloat (@expr1073747167 nullptr , "class" ) ;
253: c@var1778 .@expr1073747168 mallocOnClassWarning (@expr1073747169 nullptr , "malloc" , nullptr ) ;
254: c@var1778 .@expr1073747170 mallocOnClassError (@expr1073747171 nullptr , "malloc" , nullptr , "std::string" ) ;
255: c@var1778 .@expr1073747172 virtualDestructorError (@expr1073747173 nullptr , "Base" , "Derived" , false ) ;
256: c@var1778 .@expr1073747174 thisSubtractionError (@expr1073747175 nullptr ) ;
257: c@var1778 .@expr1073747176 operatorEqRetRefThisError (@expr1073747177 nullptr ) ;
258: c@var1778 .@expr1073747178 operatorEqMissingReturnStatementError (@expr1073747179 nullptr , true ) ;
259: c@var1778 .@expr1073747180 operatorEqShouldBeLeftUnimplementedError (@expr1073747181 nullptr ) ;
260: c@var1778 .@expr1073747182 operatorEqToSelfError (@expr1073747183 nullptr ) ;
261: c@var1778 .@expr5360 checkConstError (@expr1073747185 nullptr , "class" , "function" , false ) ;
262: c@var1778 .@expr5360 checkConstError (@expr1073747187 nullptr , "class" , "function" , true ) ;
263: c@var1778 .@expr1073747188 initializerListError (@expr1073747189 nullptr , nullptr , "class" , "variable" ) ;
264: c@var1778 .@expr1073747190 suggestInitializationList (@expr1073747191 nullptr , "variable" ) ;
265: c@var1778 .@expr1073747192 selfInitializationError (@expr1073747193 nullptr , "var" ) ;
266: c@var1778 .@expr1073747194 duplInheritedMembersError (@expr1073747195 nullptr , nullptr , "class" , "class" , "variable" , false , false ) ;
267: c@var1778 .@expr1073747196 copyCtorAndEqOperatorError (@expr1073747197 nullptr , "class" , false , false ) ;
268: c@var1778 .@expr1073747198 pureVirtualFunctionCallInConstructorError (@expr1073747199 nullptr , std ::@expr5376 list < const Token *@expr5377 > (@expr5378 ) , "f" ) ;
269: c@var1778 .@expr1073747203 virtualFunctionCallInConstructorError (@expr1073747204 nullptr , std ::@expr5376 list < const Token *@expr5377 > (@expr5378 ) , "f" ) ;
270: c@var1778 .@expr1073747208 overrideError (@expr1073747209 nullptr , nullptr ) ;
271: c@var1778 .@expr1073747210 thisUseAfterFree (@expr1073747211 nullptr , nullptr , nullptr ) ;
272: c@var1778 .@expr1073747212 unsafeClassRefMemberError (@expr1073747213 nullptr , "UnsafeClass::var" ) ;
273: }
274:
275: static std :: string myName ( ) {
276: return "Class" ;
277: }
278:
279: std :: string classInfo ( ) const override {
280: return "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
281:
|
301:
302: ;
303: }
304:
305:
306: void checkReturnPtrThis ( const Scope * scope@var1779 , const Function * func@var1780 , const Token * tok@var1781 , const Token * last@var1782 ) ;
307: void checkReturnPtrThis ( const Scope * scope@var1783 , const Function * func@var1784 , const Token * tok@var1785 , const Token * last@var1786 , std :: set < const Function * > & analyzedFunctions@var1787 ) ;
308:
309:
310: bool hasAllocation ( const Function * func@var1788 , const Scope * scope@var1789 ) const ;
311: bool hasAllocation ( const Function * func@var1790 , const Scope * scope@var1791 , const Token * start@var1792 , const Token * end@var1793 ) const ;
312: bool hasAllocationInIfScope ( const Function * func@var1794 , const Scope * scope@var1795 , const Token * ifStatementScopeStart@var1796 ) const ;
313: static bool hasAssignSelf ( const Function * func@var1797 , const Token * rhs@var1798 , const Token * * out_ifStatementScopeStart@var1799 ) ;
314: enum class Bool { TRUE , FALSE , BAILOUT } ;
315: static Bool isInverted ( const Token * tok@var1800 , const Token * rhs@var1801 ) ;
316: static const Token * getIfStmtBodyStart ( const Token * tok@var1802 , const Token * rhs@var1803 ) ;
317:
318:
319: bool isMemberVar ( const Scope * scope@var1804 , const Token * tok@var1805 ) const ;
320: bool isMemberFunc ( const Scope * scope@var1806 , const Token * tok@var1807 ) const ;
321: bool isConstMemberFunc ( const Scope * scope@var1808 , const Token * tok@var1809 ) const ;
322: bool checkConstFunc ( const Scope * scope@var1810 , const Function * func@var1811 , bool & memberAccessed@var1812 ) const ;
323:
324:
325:
326: struct Usage {
327: explicit Usage ( const Variable * var@var1813 ) : var@var1814 ( var@var1813 ) , assign@var1815 ( false ) , init@var1816 ( false ) { }
328:
329:
330: const Variable * var@var1814 ;
331:
332:
333: bool assign@var1815 ;
334:
335:
336: bool init@var1816 ;
337: } ;
338:
339: static bool isBaseClassFunc ( const Token * tok@var1817 , const Scope * scope@var1818 ) ;
340:
|
345:
346: static std :: vector < Usage > createUsageList ( const Scope * scope@var1819 ) ;
347:
|
352:
353: static void assignVar ( std :: vector < Usage > & usageList@var1820 , int varid@var1821 ) ;
354:
|
359:
360: static void initVar ( std :: vector < Usage > & usageList@var1822 , int varid@var1823 ) ;
361:
|
365:
366: static void assignAllVar ( std :: vector < Usage > & usageList@var1824 ) ;
367:
|
371:
372: static void clearAllVar ( std :: vector < Usage > & usageList@var1825 ) ;
373:
|
380:
381: void initializeVarList ( const Function & func@var1826 , std :: list < const Function * > & callstack@var1827 , const Scope * scope@var1828 , std :: vector < Usage > & usage@var1829 ) ;
382:
|
388:
389: const std :: list < const Token * > & getVirtualFunctionCalls (
390: const Function & function@var1830 ,
391: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var1831 ) ;
392:
|
398:
399: void getFirstVirtualFunctionCallStack (
400: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var1832 ,
401: const Token * callToken@var1833 ,
402: std :: list < const Token * > & pureFuncStack@var1834 ) ;
403:
404: static bool canNotCopy ( const Scope * scope@var1835 ) ;
405:
406: static bool canNotMove ( const Scope * scope@var1836 ) ;
407:
|
410:
411: bool checkThisUseAfterFreeRecursive ( const Scope * classScope@var1837 , const Function * func@var1838 , const Variable * selfPointer@var1839 , std :: set < const Function * > callstack@var1840 , const Token * * freeToken@var1841 ) ;
412: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1842 , const TFunc & visitor@var1843 )
52: {
53: if (@expr1073747214 !@expr1073747215 ast@var1842 ) {
54: return ; }
55:
56: std ::@expr1073747216 stack < T *@expr5393 , std ::@expr1073747218 vector < T *@expr5393 > > tokens@var1844 ;
57: T * tok@var1845 ; tok@var1845 =@expr1073747220 ast@var1842 ;
58: do {
59: ChildrenToVisit c@var1846 ; c@var1846 =@expr1073747221 visitor@var1843 (@expr1073747222 tok@var1845 ) ;
60:
61: if (@expr1073747223 c@var1846 ==@expr1073747224 ChildrenToVisit ::@expr1073747225 done ) {
62: break ; }
63: if (@expr1073747226 c@var1846 ==@expr1073747227 ChildrenToVisit ::@expr1073747228 op2 ||@expr1073747229 c@var1846 ==@expr5406 ChildrenToVisit ::@expr5407 op1_and_op2 ) {
64: T * t2@var1847 ; t2@var1847 =@expr1073747232 tok@var1845 .@expr1073747233 astOperand2 (@expr1073747234 ) ;
65: if (@expr1073747235 t2@var1847 ) {
66: tokens@var1844 .@expr5412 push (@expr1073747237 t2@var1847 ) ; }
67: }
68: if (@expr1073747238 c@var1846 ==@expr1073747239 ChildrenToVisit ::@expr1073747240 op1 ||@expr1073747241 c@var1846 ==@expr5406 ChildrenToVisit ::@expr5407 op1_and_op2 ) {
69: T * t1@var1848 ; t1@var1848 =@expr1073747244 tok@var1845 .@expr1073747245 astOperand1 (@expr1073747246 ) ;
70: if (@expr1073747247 t1@var1848 ) {
71: tokens@var1844 .@expr5412 push (@expr1073747249 t1@var1848 ) ; }
72: }
73:
74: if (@expr1073747250 tokens@var1844 .@expr1073747251 empty (@expr1073747252 ) ) {
75: break ; }
76:
77: tok@var1845 =@expr1073747253 tokens@var1844 .@expr1073747254 top (@expr1073747255 ) ;
78: tokens@var1844 .@expr1073747256 pop (@expr1073747257 ) ;
79: } while (@expr1073747258 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1849 , const std :: function < bool ( const Token * ) > & pred@var1850 ) ;
83: const Token * findExpression ( const int exprid@var1851 ,
84: const Token * start@var1852 ,
85: const Token * end@var1853 ,
86: const std :: function < bool ( const Token * ) > & pred@var1854 ) ;
87: const Token * findExpression ( const Token * start@var1855 , const int exprid@var1856 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1857 , const char * op@var1858 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1859 , const char * op@var1860 ) ;
91:
92: int astCount ( const Token * tok@var1861 , const char * op@var1862 , int depth@var1863 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1864 , const Token * tok@var1865 ) ;
95:
96: bool astHasVar ( const Token * tok@var1866 , int varid@var1867 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1868 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1869 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1870 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1871 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1872 , bool unknown@var1873 ) ;
107: bool astIsUnsigned ( const Token * tok@var1874 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1875 , bool unknown@var1876 ) ;
110:
111: bool astIsBool ( const Token * tok@var1877 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1878 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1879 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1880 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1881 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1882 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1883 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1884 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1885 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1886 , const std :: string & comp@var1887 , const std :: string & rhs@var1888 , const Token * * vartok@var1889 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1890 ) ;
140:
141: bool isTemporary ( bool cpp@var1891 , const Token * tok@var1892 , const Library * library@var1893 , bool unknown@var1894 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1895 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1896 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1897 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1898 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1899 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1900 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1901 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1902 ) ;
155: const Token * getParentLifetime ( bool cpp@var1903 , const Token * tok@var1904 , const Library * library@var1905 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1906 ) ;
158: bool astIsRHS ( const Token * tok@var1907 ) ;
159:
160: Token * getCondTok ( Token * tok@var1908 ) ;
161: const Token * getCondTok ( const Token * tok@var1909 ) ;
162:
163: Token * getInitTok ( Token * tok@var1910 ) ;
164: const Token * getInitTok ( const Token * tok@var1911 ) ;
165:
166: Token * getStepTok ( Token * tok@var1912 ) ;
167: const Token * getStepTok ( const Token * tok@var1913 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1914 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1915 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1916 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1917 ,
180: int * const varid@var1918 ,
181: bool * const knownInitValue@var1919 ,
182: long long * const initValue@var1920 ,
183: bool * const partialCond@var1921 ,
184: long long * const stepValue@var1922 ,
185: long long * const lastValue@var1923 ) ;
186:
187: bool precedes ( const Token * tok1@var1924 , const Token * tok2@var1925 ) ;
188: bool succeeds ( const Token * tok1@var1926 , const Token * tok2@var1927 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1928 , bool onVar@var1929 = true , int depth@var1930 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1931 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1932 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1933 ,
198: bool temporary@var1934 = true ,
199: bool inconclusive@var1935 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1936 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1937 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1938 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1939 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1940 , bool macro@var1941 , const Token * tok1@var1942 , const Token * tok2@var1943 , const Library & library@var1944 , bool pure@var1945 , bool followVar@var1946 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1947 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1948 , const Token * const tok2@var1949 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1950 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1951 , bool cpp@var1952 , const Token * const cond1@var1953 , const Token * const cond2@var1954 , const Library & library@var1955 , bool pure@var1956 , bool followVar@var1957 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1958 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1959 , const Token * const tok1@var1960 , const Token * const tok2@var1961 , const Library & library@var1962 , bool pure@var1963 , bool followVar@var1964 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1965 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1966 , const Library & library@var1967 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1968 , const Library & library@var1969 , bool pure@var1970 , bool cpp@var1971 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1972 , const Token * tok@var1973 , bool checkArrayAccess@var1974 = false , bool checkReference@var1975 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1976 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1977 , const Library * library@var1978 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1979 ,
238: const Library * library@var1980 = nullptr ,
239: const Token * * unknownFunc@var1981 = nullptr ,
240: bool functionScope@var1982 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1983 ,
244: const Variable * var@var1984 ,
245: Scope :: ScopeType type@var1985 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1986 , int & argn@var1987 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1988 , int & argn@var1989 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1990 , int argnr@var1991 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1992 , int indirect@var1993 , int varid@var1994 , const Settings * settings@var1995 , bool * inconclusive@var1996 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1997 , int indirect@var1998 , const Settings * settings@var1999 , bool * inconclusive@var2000 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var2001 , const Token * end@var2002 , const int exprid@var2003 , bool globalvar@var2004 , const Settings * settings@var2005 , bool cpp@var2006 , int depth@var2007 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var2008 , const Token * end@var2009 , int indirect@var2010 , const int exprid@var2011 , bool globalvar@var2012 , const Settings * settings@var2013 , bool cpp@var2014 , int depth@var2015 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var2016 , int indirect@var2017 , const Settings * settings@var2018 , bool cpp@var2019 , int depth@var2020 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var2021 , const Settings * settings@var2022 , bool cpp@var2023 , int depth@var2024 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var2025 ,
283: const Token * end@var2026 ,
284: int indirect@var2027 ,
285: std :: vector < const Variable * > vars@var2028 ,
286: const Settings * settings@var2029 ,
287: bool cpp@var2030 ) ;
288:
289: bool isThisChanged ( const Token * tok@var2031 , int indirect@var2032 , const Settings * settings@var2033 , bool cpp@var2034 ) ;
290: bool isThisChanged ( const Token * start@var2035 , const Token * end@var2036 , int indirect@var2037 , const Settings * settings@var2038 , bool cpp@var2039 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var2040 , const Token * end@var2041 , int indirect@var2042 , const int exprid@var2043 , bool globalvar@var2044 , const Settings * settings@var2045 , bool cpp@var2046 , int depth@var2047 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var2048 , const Token * end@var2049 , int indirect@var2050 , const int exprid@var2051 , bool globalvar@var2052 , const Settings * settings@var2053 , bool cpp@var2054 , int depth@var2055 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var2056 ,
296: const Token * start@var2057 ,
297: const Token * end@var2058 ,
298: const Settings * settings@var2059 ,
299: bool cpp@var2060 ,
300: int depth@var2061 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var2062 ,
303: const Token * tok@var2063 ,
304: int indirect@var2064 ,
305: bool globalvar@var2065 ,
306: const Settings * settings@var2066 ,
307: bool cpp@var2067 ,
308: int depth@var2068 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var2069 , int varid@var2070 , bool * inconclusive@var2071 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var2072 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var2073 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var2074 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var2075 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var2076 ) ;
330:
331: int getArgumentPos ( const Variable * var@var2077 , const Function * f@var2078 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var2079 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var2080 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var2081 ) ;
346: Token * findLambdaEndToken ( Token * first@var2082 ) ;
347:
348: bool isLikelyStream ( bool cpp@var2083 , const Token * stream@var2084 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var2085 , const Token * op@var2086 ) ;
356:
357: bool isCPPCast ( const Token * tok@var2087 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var2088 , const char * skipMatch@var2089 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var2090 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var2091 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var2092 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var2093 , const Library & library@var2094 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var2095 ) ;
371:
372: bool isNullOperand ( const Token * expr@var2096 ) ;
373:
374: bool isGlobalData ( const Token * expr@var2097 , bool cpp@var2098 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var2099 , const Library & library@var2100 ) : mCpp@var2133 ( cpp@var2099 ) , mLibrary@var2134 ( library@var2100 ) , mWhat@var2135 ( What :: Reassign ) , mValueFlowKnown@var2137 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var2101 , const Token * lhs@var2102 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var2103 , const Token * startToken@var2104 , const Token * endToken@var2105 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var2106 , const Token * startToken@var2107 , const Token * endToken@var2108 ) ;
404:
405: struct KnownAndToken {
406: bool known@var2109 ;
407: const Token * token@var2110 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var2111 , const Token * startToken@var2112 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var2113 , bool * localOut@var2114 = nullptr , bool * unknownVarIdOut@var2115 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var2116 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var2117 ;
420: explicit Result ( Type type@var2118 ) : type@var2117 ( type@var2118 ) , token@var2121 ( nullptr ) { }
421: Result ( Type type@var2119 , const Token * token@var2120 ) : type@var2117 ( type@var2119 ) , token@var2121 ( token@var2120 ) { }
422: const Token * token@var2121 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var2122 , const Token * startToken@var2123 , const Token * endToken@var2124 ) ;
426: struct Result checkRecursive ( const Token * expr@var2125 , const Token * startToken@var2126 , const Token * endToken@var2127 , const std :: set < int > & exprVarIds@var2128 , bool local@var2129 , bool inInnerClass@var2130 , int depth@var2131 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var2132 ) const ;
430:
431: const bool mCpp@var2133 ;
432: const Library & mLibrary@var2134 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var2135 ;
434: std :: vector < KnownAndToken > mValueFlow@var2136 ;
435: bool mValueFlowKnown@var2137 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var2138 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2139 ) {
44: if (@expr1073747259 bit@var2139 >=@expr1073747260 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073747261 (@expr1073747262 1LL <<@expr1073747263 (@expr1073747264 bit@var2139 -@expr1073747265 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var2140 ) {
50: if (@expr1073747266 bit@var2140 >=@expr1073747267 64 ) {
51: return (@expr5444 ~@expr1073747269 0ULL ) >>@expr1073747270 1 ; }
52: return (@expr5444 1LL <<@expr1073747272 (@expr5444 bit@var2140 -@expr1073747274 1 ) ) -@expr1073747275 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var2141 ) const {
59: return value@var2141 >=@expr1073747276 min_value (@expr1073747277 int_bit@var2151 ) &&@expr1073747278 value@var2141 <=@expr1073747279 max_value (@expr1073747280 int_bit@var2151 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var2142 ) const {
63: unsigned long long intMax@var2143 ; intMax@var2143 =@expr1073747281 max_value (@expr1073747282 int_bit@var2151 ) ;
64: return value@var2142 <=@expr1073747283 intMax@var2143 ;
65: }
66:
67: bool isLongValue ( long long value@var2144 ) const {
68: return value@var2144 >=@expr1073747284 min_value (@expr1073747285 long_bit@var2152 ) &&@expr1073747286 value@var2144 <=@expr1073747287 max_value (@expr1073747288 long_bit@var2152 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var2145 ) const {
72: unsigned long long longMax@var2146 ; longMax@var2146 =@expr1073747289 max_value (@expr1073747290 long_bit@var2152 ) ;
73: return value@var2145 <=@expr1073747291 longMax@var2146 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var2147 ) const {
77: unsigned long long longLongMax@var2148 ; longLongMax@var2148 =@expr1073747292 max_value (@expr1073747293 long_long_bit@var2153 ) ;
78: return value@var2147 <=@expr1073747294 longLongMax@var2148 ;
79: }
80:
81: int char_bit@var2149 ;
82: int short_bit@var2150 ;
83: int int_bit@var2151 ;
84: int long_bit@var2152 ;
85: int long_long_bit@var2153 ;
86:
87:
88: int sizeof_bool@var2154 ;
89: int sizeof_short@var2155 ;
90: int sizeof_int@var2156 ;
91: int sizeof_long@var2157 ;
92: int sizeof_long_long@var2158 ;
93: int sizeof_float@var2159 ;
94: int sizeof_double@var2160 ;
95: int sizeof_long_double@var2161 ;
96: int sizeof_wchar_t@var2162 ;
97: int sizeof_size_t@var2163 ;
98: int sizeof_pointer@var2164 ;
99:
100: char defaultSign@var2165 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var2166 ;
115:
116:
117: bool platform ( PlatformType type@var2167 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var2168 [ ] , const std :: string & filename@var2169 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var2170 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var2166 ==@expr1073747295 Win32A ||@expr1073747296
136: platformType@var2166 ==@expr1073747297 Win32W ||@expr1073747298
137: platformType@var2166 ==@expr1073747299 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073747300 platformType@var2166 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var2171 ) {
145: switch (@expr1073747301 pt@var2171 ) {
146: case Unspecified :@expr5478 ;
147: return "Unspecified" ;
148: case Native :@expr5478 ;
149: return "Native" ;
150: case Win32A :@expr5478 ;
151: return "win32A" ;
152: case Win32W :@expr5478 ;
153: return "win32W" ;
154: case Win64 :@expr5478 ;
155: return "win64" ;
156: case Unix32 :@expr5478 ;
157: return "unix32" ;
158: case Unix64 :@expr5478 ;
159: return "unix64" ;
160: case PlatformFile :@expr5478 ;
161: return "platformFile" ;
162: default :@expr5478 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073747311 char_bit@var2149 +@expr1073747312 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073747313 char_bit@var2149 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073747314 char_bit@var2149 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var2172 , const std :: string & rhs@var2173 ) const {
41: return caseInsensitiveStringCompare (@expr1073747315 lhs@var2172 , rhs@var2173 ) <@expr1073747316 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var2181 ( cppcheck :: Platform :: Unspecified ) , msc@var2182 ( false ) , useMfc@var2183 ( false ) { }
67: std :: string cfg@var2174 ;
68: std :: string filename@var2175 ;
69: std :: string defines@var2176 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var2176 +@expr1073747317 (@expr1073747318 msc@var2182 ?@expr1073747319 ";_MSC_VER=1900" :@expr1073747320 "" ) +@expr1073747321 (@expr1073747322 useMfc@var2183 ?@expr1073747323 ";__AFXWIN_H__=1" :@expr1073747324 "" ) ;
72: }
73: std :: set < std :: string > undefs@var2177 ;
74: std :: list < std :: string > includePaths@var2178 ;
75: std :: list < std :: string > systemIncludePaths@var2179 ;
76: std :: string standard@var2180 ;
77: cppcheck :: Platform :: PlatformType platformType@var2181 ;
78: bool msc@var2182 ;
79: bool useMfc@var2183 ;
80:
81: void parseCommand ( std :: string command@var2184 ) ;
82: void setDefines ( std :: string defs@var2185 ) ;
83: void setIncludePaths ( const std :: string & basepath@var2186 , const std :: list < std :: string > & in@var2187 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2188 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var2189 ;
86: Type projectType@var2190 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var2191 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var2192 ;
97: std :: vector < std :: string > pathNames@var2193 ;
98: std :: list < std :: string > libraries@var2194 ;
99: std :: list < std :: string > excludedPaths@var2195 ;
100: std :: list < std :: string > checkVsConfigs@var2196 ;
101: std :: string projectFile@var2197 ;
102: std :: string platform@var2198 ;
103: } ; struct Anonymous4 guiProject@var2199 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var2200 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var2201 ) ;
107:
108: Type import ( const std :: string & filename@var2202 , Settings * settings@var2203 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var2204 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var2205 , Settings * settings@var2206 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2207 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2208 , const std :: string & path@var2209 , const std :: vector < std :: string > & fileFilters@var2210 ) ;
115: bool importVcxproj ( const std :: string & filename@var2211 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2212 , const std :: string & additionalIncludeDirectories@var2213 , const std :: vector < std :: string > & fileFilters@var2214 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2215 ) ;
117:
118: static void printError ( const std :: string & message@var2216 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2217 ) ;
121:
122: std :: string mPath@var2218 ;
123: std :: set < std :: string > mAllVSConfigs@var2219 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2220 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2221 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2222 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2223 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2224 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2225 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2226 [ 7 ] = "parser" ;
135: const char BugHunting@var2227 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2228 [ 11 ] = "includedir" ;
137: const char DirElementName@var2229 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2230 [ 5 ] = "name" ;
139: const char DefinesElementName@var2231 [ 8 ] = "defines" ;
140: const char DefineName@var2232 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2233 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2234 [ 10 ] = "undefines" ;
143: const char UndefineName@var2235 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2236 [ 6 ] = "paths" ;
145: const char PathName@var2237 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2238 [ 5 ] = "name" ;
147: const char RootPathName@var2239 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2240 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2241 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2242 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2243 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2244 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2245 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2246 [ 5 ] = "name" ;
155: const char FunctionContracts@var2247 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2248 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2249 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2250 [ 8 ] = "library" ;
159: const char PlatformElementName@var2251 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2252 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2253 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2254 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2255 [ 7 ] = "addons" ;
164: const char ToolElementName@var2256 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2257 [ 6 ] = "tools" ;
166: const char TagsElementName@var2258 [ 5 ] = "tags" ;
167: const char TagElementName@var2259 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2260 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2261 [ 4 ] = "tag" ;
170: const char WarningElementName@var2262 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2263 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2264 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2265 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2266 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2267 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2268 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2269 [ 11 ] = "clang-tidy" ;
178: const char Name@var2270 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2271 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2272 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var2273 ;
43: std :: string errorId@var2274 ;
44: void setFileName ( const std :: string & s@var2275 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var2279 ;
47: }
48: int lineNumber@var2276 ;
49: Certainty :: CertaintyLevel certainty@var2277 ;
50: std :: string symbolNames@var2278 ;
51: private:
52: std :: string mFileName@var2279 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2313 ( NO_LINE ) , hash@var2315 ( 0 ) , thisAndNextLine@var2316 ( false ) , matched@var2317 ( false ) , checked@var2318 ( false ) { }
57: Suppression ( const Suppression & other@var2280 ) {
58: *@expr1073747325 this@expr1073747326 =@expr1073747327 other@var2280 ;
59: }
60: Suppression ( const std :: string & id@var2281 , const std :: string & file@var2282 , int line@var2283 = NO_LINE ) : errorId@var2311 ( id@var2281 ) , fileName@var2312 ( file@var2282 ) , lineNumber@var2313 ( line@var2283 ) , hash@var2315 ( 0 ) , thisAndNextLine@var2316 ( false ) , matched@var2317 ( false ) , checked@var2318 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var2284 ) {
63: errorId@var2311 =@expr1073747328 other@var2284 .@expr1073747329 errorId@var2285 ;
64: fileName@var2312 =@expr1073747330 other@var2284 .@expr1073747331 fileName@var2286 ;
65: lineNumber@var2313 =@expr1073747332 other@var2284 .@expr1073747333 lineNumber@var2287 ;
66: symbolName@var2314 =@expr1073747334 other@var2284 .@expr1073747335 symbolName@var2288 ;
67: hash@var2315 =@expr1073747336 other@var2284 .@expr1073747337 hash@var2289 ;
68: thisAndNextLine@var2316 =@expr1073747338 other@var2284 .@expr1073747339 thisAndNextLine@var2290 ;
69: matched@var2317 =@expr1073747340 other@var2284 .@expr1073747341 matched@var2291 ;
70: checked@var2318 =@expr1073747342 other@var2284 .@expr1073747343 checked@var2292 ;
71: return *@expr1073747344 this@expr1073747345 ;
72: }
73:
74: bool operator< ( const Suppression & other@var2293 ) const {
75: if (@expr1073747346 errorId@var2311 !=@expr1073747347 other@var2293 .@expr5524 errorId@var2294 ) {
76: return errorId@var2311 <@expr1073747349 other@var2293 .@expr5524 errorId@var2294 ; }
77: if (@expr1073747351 lineNumber@var2313 <@expr1073747352 other@var2293 .@expr1073747353 lineNumber@var2295 ) {
78: return true ; }
79: if (@expr1073747354 fileName@var2312 !=@expr1073747355 other@var2293 .@expr5532 fileName@var2296 ) {
80: return fileName@var2312 <@expr1073747357 other@var2293 .@expr5532 fileName@var2296 ; }
81: if (@expr1073747359 symbolName@var2314 !=@expr1073747360 other@var2293 .@expr5537 symbolName@var2297 ) {
82: return symbolName@var2314 <@expr1073747362 other@var2293 .@expr5537 symbolName@var2297 ; }
83: if (@expr1073747364 hash@var2315 !=@expr1073747365 other@var2293 .@expr5542 hash@var2298 ) {
84: return hash@var2315 <@expr1073747367 other@var2293 .@expr5542 hash@var2298 ; }
85: if (@expr1073747369 thisAndNextLine@var2316 !=@expr1073747370 other@var2293 .@expr1073747371 thisAndNextLine@var2299 ) {
86: return thisAndNextLine@var2316 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2300 , std :: string * errorMessage@var2301 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2302 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2303 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073747373 fileName@var2312 .@expr1073747374 empty (@expr1073747375 ) &&@expr1073747376 fileName@var2312 .@expr1073747377 find_first_of (@expr1073747378 "?*" ) ==@expr1073747379 std ::@expr1073747380 string ::@expr1073747381 npos@expr1073747372 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2304 ) const {
109: return errorId@var2311 ==@expr1073747382 other@var2304 .@expr1073747383 errorId@var2305 &&@expr1073747384
110: fileName@var2312 ==@expr1073747385 other@var2304 .@expr1073747386 fileName@var2306 &&@expr1073747387
111: lineNumber@var2313 ==@expr1073747388 other@var2304 .@expr1073747389 lineNumber@var2307 &&@expr1073747390
112: symbolName@var2314 ==@expr1073747391 other@var2304 .@expr1073747392 symbolName@var2308 &&@expr1073747393
113: hash@var2315 ==@expr1073747394 other@var2304 .@expr1073747395 hash@var2309 &&@expr1073747396
114: thisAndNextLine@var2316 ==@expr1073747397 other@var2304 .@expr1073747398 thisAndNextLine@var2310 ;
115: }
116:
117: std :: string errorId@var2311 ;
118: std :: string fileName@var2312 ;
119: int lineNumber@var2313 ;
120: std :: string symbolName@var2314 ;
121: unsigned long hash@var2315 ;
122: bool thisAndNextLine@var2316 ;
123: bool matched@var2317 ;
124: bool checked@var2318 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2319 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2320 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2321 , std :: string * errorMessage@var2322 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2323 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2324 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2325 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2326 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2327 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2328 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2329 , const bool unusedFunctionChecking@var2330 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2331 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2332 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2333 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2334 , std :: clock_t clocks@var2335 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2336 ;
45: long mNumberOfResults@var2337 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2336 ( 0 )
49: , mNumberOfResults@var2337 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2338 =@expr1073747400 (@expr1073747401 double ) (@expr1073747402 (@expr1073747403 unsigned long ) mClocks@var2336 ) /@expr1073747404 (@expr1073747405 double ) CLOCKS_PER_SEC@expr1073747399 ;
53: return ret@var2338 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2339 ) const ;
62: void addResults ( const std :: string & str@var2340 , std :: clock_t clocks@var2341 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2342 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2343 , SHOWTIME_MODES showtimeMode@var2344 , TimerResultsIntf * timerResults@var2345 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2346 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2347 ;
79: TimerResultsIntf * mTimerResults@var2348 ;
80: std :: clock_t mStart@var2349 ;
81: const SHOWTIME_MODES mShowTimeMode@var2350 ;
82: bool mStopped@var2351 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2352 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2353 ;
103:
104:
105: std :: string addonPython@var2354 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2355 ;
109:
110:
111: std :: string buildDir@var2356 ;
112:
113:
114: bool checkAllConfigurations@var2357 ;
115:
116:
117: bool checkConfiguration@var2358 ;
118:
|
121:
122: bool checkHeaders@var2359 ;
123:
124:
125: bool checkLibrary@var2360 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2361 ;
129:
130:
131: bool checkUnusedTemplates@var2362 ;
132:
133:
134: bool clang@var2363 ;
135:
136:
137: std :: string clangExecutable@var2364 ;
138:
139:
140: bool clangTidy@var2365 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2366 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2367 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2368 ;
150:
151:
152: bool daca@var2369 ;
153:
154:
155: bool debugnormal@var2370 ;
156:
157:
158: bool debugSimplified@var2371 ;
159:
160:
161: bool debugtemplate@var2372 ;
162:
163:
164: bool debugwarnings@var2373 ;
165:
166:
167: bool dump@var2374 ;
168: std :: string dumpFile@var2375 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2376 ;
176:
177:
178: bool exceptionHandling@var2377 ;
179:
180:
181: std :: string exename@var2378 ;
182:
183:
184:
185: int exitCode@var2379 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2380 ;
189:
190:
191: bool force@var2381 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2382 ;
196:
197:
198: bool inlineSuppressions@var2383 ;
199:
200:
201:
202: unsigned int jobs@var2384 ;
203:
|
206:
207: bool jointSuppressionReport@var2385 ;
208:
209:
210: std :: list < std :: string > libraries@var2386 ;
211:
212:
213: Library library@var2387 ;
214:
215:
216:
217: int loadAverage@var2388 ;
218:
|
221:
222: int maxConfigs@var2389 ;
223:
224:
225: int maxCtuDepth@var2390 ;
226:
227:
228: int maxTemplateRecursion@var2391 ;
229:
230:
231: Suppressions nofail@var2392 ;
232:
233:
234: Suppressions nomsg@var2393 ;
235:
236:
237: std :: string outputFile@var2394 ;
238:
239:
240: std :: string plistOutput@var2395 ;
241:
242:
243: bool preprocessOnly@var2396 ;
244:
245: ImportProject project@var2397 ;
246:
247:
248: bool quiet@var2398 ;
249:
250:
251: bool relativePaths@var2399 ;
252:
253:
254: bool reportProgress@var2400 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2401 ( "simple" )
261: , id@var2403 ( "rule" )
262: , severity@var2405 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2401 ;
266: std :: string pattern@var2402 ;
267: std :: string id@var2403 ;
268: std :: string summary@var2404 ;
269: Severity :: SeverityType severity@var2405 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2406 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2412 ( false ) , externalFunctions@var2413 ( false ) , internalFunctions@var2414 ( false ) , externalVariables@var2415 ( false ) { }
281:
282: static const char XmlRootName@var2407 [ ] ;
283: static const char XmlClasses@var2408 [ ] ;
284: static const char XmlExternalFunctions@var2409 [ ] ;
285: static const char XmlInternalFunctions@var2410 [ ] ;
286: static const char XmlExternalVariables@var2411 [ ] ;
287:
288: void clear ( ) {
289: classes@var2412 =@expr1073747406 externalFunctions@var2413 =@expr1073747407 internalFunctions@var2414 =@expr1073747408 externalVariables@var2415 =@expr1073747409 false ;
290: }
291:
|
297:
298: bool classes@var2412 ;
299:
|
304:
305: bool externalFunctions@var2413 ;
306:
|
310:
311: bool internalFunctions@var2414 ;
312:
|
316:
317: bool externalVariables@var2415 ;
318: } ;
319:
320: SafeChecks safeChecks@var2416 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2417 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2418 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2419 ;
325:
326:
327: SHOWTIME_MODES showtime@var2420 ;
328:
329:
330: Standards standards@var2421 ;
331:
332:
333:
334: std :: string templateFormat@var2422 ;
335:
336:
337:
338: std :: string templateLocation@var2423 ;
339:
340:
341: std :: string userDefines@var2424 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2425 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2426 ;
348:
349:
350: bool verbose@var2427 ;
351:
352:
353: bool xml@var2428 ;
354:
355:
356: int xml_version@var2429 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2430 ) const {
363: for (@expr1073747410 const std ::@expr1073747411 string &@expr1073747412 configExcludePath@var2431 :@expr1073747413 configExcludePaths@var2366 ) {
364: if (@expr1073747414 file@var2430 .@expr1073747415 length (@expr1073747416 ) >=@expr1073747417 configExcludePath@var2431 .@expr5594 length (@expr5595 ) &&@expr1073747420 file@var2430 .@expr1073747421 compare (@expr1073747422 0 , configExcludePath@var2431 .@expr5594 length (@expr5595 ) , configExcludePath@var2431 ) ==@expr1073747425 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2432 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2433 , bool inconclusiveCheck@var2434 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073747426 find (@expr1073747427 libraries@var2386 .@expr1073747428 begin (@expr1073747429 ) , libraries@var2386 .@expr5606 end (@expr5607 ) , "posix" ) !=@expr1073747432 libraries@var2386 .@expr5606 end (@expr5607 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2435 = true ) {
392: Settings ::@expr1073747435 mTerminated@var2352 =@expr1073747436 t@var2435 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073747437 mTerminated@var2352 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2436 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var2437 , const Color & c@var2438 ) ;
42:
43: std :: string toString ( const Color & c@var2439 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var2440 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var2441 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var2442 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var2443 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var2444 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var2460 ( 0 ) , line@var2461 ( 0 ) , column@var2462 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var2445 , int line@var2446 , unsigned int column@var2447 )
73: : fileIndex@var2460 ( 0 ) , line@var2461 ( line@var2446 ) , column@var2462 ( column@var2447 ) , mOrigFileName@var2464 ( file@var2445 ) , mFileName@var2465 ( file@var2445 ) { }
74:
75: FileLocation ( const std :: string & file@var2448 , const std :: string & info@var2449 , int line@var2450 , unsigned int column@var2451 )
76: : fileIndex@var2460 ( 0 ) , line@var2461 ( line@var2450 ) , column@var2462 ( column@var2451 ) , mOrigFileName@var2464 ( file@var2448 ) , mFileName@var2465 ( file@var2448 ) , mInfo@var2466 ( info@var2449 ) { }
77:
78: FileLocation ( const Token * tok@var2452 , const TokenList * tokenList@var2453 ) ;
79: FileLocation ( const Token * tok@var2454 , const std :: string & info@var2455 , const TokenList * tokenList@var2456 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var2457 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var2458 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var2459 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var2460 ;
107: int line@var2461 ;
108: unsigned int column@var2462 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var2466 ;
112: }
113: void setinfo ( const std :: string & i@var2463 ) {
114: mInfo@var2466 =@expr1073747438 i@var2463 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var2464 ;
119: std :: string mFileName@var2465 ;
120: std :: string mInfo@var2466 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var2467 ,
124: const std :: string & file1@var2468 ,
125: Severity :: SeverityType severity@var2469 ,
126: const std :: string & msg@var2470 ,
127: const std :: string & id@var2471 , Certainty :: CertaintyLevel certainty@var2472 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var2473 ,
129: const std :: string & file1@var2474 ,
130: Severity :: SeverityType severity@var2475 ,
131: const std :: string & msg@var2476 ,
132: const std :: string & id@var2477 ,
133: const CWE & cwe@var2478 ,
134: Certainty :: CertaintyLevel certainty@var2479 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var2480 ,
136: const TokenList * list@var2481 ,
137: Severity :: SeverityType severity@var2482 ,
138: const std :: string & id@var2483 ,
139: const std :: string & msg@var2484 ,
140: Certainty :: CertaintyLevel certainty@var2485 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var2486 ,
142: const TokenList * list@var2487 ,
143: Severity :: SeverityType severity@var2488 ,
144: const std :: string & id@var2489 ,
145: const std :: string & msg@var2490 ,
146: const CWE & cwe@var2491 ,
147: Certainty :: CertaintyLevel certainty@var2492 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var2493 ,
149: const TokenList * tokenList@var2494 ,
150: Severity :: SeverityType severity@var2495 ,
151: const char id@var2496 [ ] ,
152: const std :: string & msg@var2497 ,
153: const CWE & cwe@var2498 ,
154: Certainty :: CertaintyLevel certainty@var2499 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var2500 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var2501 ,
176: const std :: string & templateFormat@var2502 = emptyString@var1 ,
177: const std :: string & templateLocation@var2503 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var2504 ) ;
181:
182: std :: list < FileLocation > callStack@var2505 ;
183: std :: string id@var2506 ;
184:
185:
186: std :: string file0@var2507 ;
187:
188: std :: string function@var2508 ;
189:
190: bool incomplete@var2509 ;
191:
192: Severity :: SeverityType severity@var2510 ;
193: CWE cwe@var2511 ;
194: Certainty :: CertaintyLevel certainty@var2512 ;
195:
196:
197: unsigned long hash@var2513 ;
198:
199:
200: void setmsg ( const std :: string & msg@var2514 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var2516 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var2517 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var2518 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var2515 ) ;
221:
222:
223: std :: string mShortMessage@var2516 ;
224:
225:
226: std :: string mVerboseMessage@var2517 ;
227:
228:
229: std :: string mSymbolNames@var2518 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var2519 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073747439 plistFile@var2519 .@expr1073747440 is_open (@expr1073747441 ) ) {
243: plistFile@var2519 <<@expr1073747442 ErrorLogger ::@expr1073747443 plistFooter (@expr1073747444 ) ;
244: plistFile@var2519 .@expr1073747445 close (@expr1073747446 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var2520 , Color c@var2521 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var2522 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var2523 , const char stage@var2524 [ ] , const unsigned long value@var2525 ) {
271: (@expr1073747447 void ) filename@var2523 ;
272: (@expr1073747448 void ) stage@var2524 ;
273: (@expr1073747449 void ) value@var2525 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var2526 ) {
281: reportErr (@expr1073747450 msg@var2526 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var2527 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var2528 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var2529 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var2530 , const std :: vector < std :: string > & files@var2531 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var2532 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var2533 , const std :: string & from@var2534 , const std :: string & to@var2535 ) ;

##file cppcheck-2.8/lib/checkclass.cpp

1:
|
44:
45: namespace CTU {
46: class FileInfo ;
47: }
48:
|
51:
52: namespace {
53: CheckClass instance@var2536 ;
54: }
55:
56: static const CWE CWE398@var2537 ( 398U ) ;
57: static const CWE CWE404@var2538 ( 404U ) ;
58: static const CWE CWE665@var2539 ( 665U ) ;
59: static const CWE CWE758@var2540 ( 758U ) ;
60: static const CWE CWE762@var2541 ( 762U ) ;
61:
62: static const CWE CWE_ONE_DEFINITION_RULE@var2542 ( 758U ) ;
63:
64: static const char * getFunctionTypeName ( Function :: Type type@var2543 )
65: {
66: switch (@expr1073747451 type@var2543 ) {
67: case Function ::@expr1073747452 eConstructor :@expr5629 ;
68: return "constructor" ;
69: case Function ::@expr1073747454 eCopyConstructor :@expr5629 ;
70: return "copy constructor" ;
71: case Function ::@expr1073747456 eMoveConstructor :@expr5629 ;
72: return "move constructor" ;
73: case Function ::@expr1073747458 eDestructor :@expr5629 ;
74: return "destructor" ;
75: case Function ::@expr1073747460 eFunction :@expr5629 ;
76: return "function" ;
77: case Function ::@expr1073747462 eOperatorEqual :@expr5629 ;
78: return "operator=" ;
79: case Function ::@expr1073747464 eLambda :@expr5629 ;
80: return "lambda" ;
81: }
82: return "" ;
83: }
84:
85: static bool isVariableCopyNeeded ( const Variable & var@var2544 , Function :: Type type@var2545 )
86: {
87: bool isOpEqual@var2546 ; isOpEqual@var2546 =@expr1073747466 false ;
88: switch (@expr1073747467 type@var2545 ) {
89: case Function ::@expr1073747468 eOperatorEqual :@expr5645 ;
90: isOpEqual@var2546 =@expr1073747470 true ;
91: break ;
92: case Function ::@expr1073747471 eCopyConstructor :@expr5645
93: case Function ::@expr1073747473 eMoveConstructor :@expr5645 ;
94: break ;
95: default :@expr5645 ;
96: return true ;
97: }
98:
99: return (@expr5652 !@expr1073747477 var@var2544 .@expr1073747478 hasDefault (@expr1073747479 ) ||@expr1073747480 isOpEqual@var2546 ) &&@expr1073747481
100: (@expr5652 var@var2544 .@expr1073747483 isPointer (@expr1073747484 ) ||@expr1073747485
101: (@expr5652 var@var2544 .@expr5663 type (@expr5664 ) &&@expr1073747489 var@var2544 .@expr5663 type (@expr5664 ) .@expr1073747492 needInitialization@var3461 ==@expr1073747493 Type ::@expr1073747494 NeedInitialization ::@expr1073747495 True ) ||@expr1073747496
102: (@expr5652 var@var2544 .@expr5674 valueType (@expr5675 ) &&@expr1073747500 var@var2544 .@expr5674 valueType (@expr5675 ) .@expr1073747503 type@var3462 >=@expr1073747504 ValueType ::@expr1073747505 Type ::@expr1073747506 CHAR ) ) ;
103: }
104:
105: static bool isVcl ( const Settings * settings@var2547 )
106: {
107: for (@expr1073747507 const std ::@expr1073747508 string &@expr1073747509 library@var2548 :@expr1073747510 settings@var2547 .@expr1073747511 libraries@var2549 ) {
108: if (@expr1073747512 library@var2548 ==@expr1073747513 "vcl" ) {
109: return true ; }
110: }
111: return false ;
112: }
113:
114: static bool isVclTypeInit ( const Type * type@var2550 )
115: {
116: if (@expr1073747514 !@expr1073747515 type@var2550 ) {
117: return false ; }
118: for (@expr1073747516 const Type ::@expr1073747517 BaseInfo &@expr1073747518 baseInfo@var2551 :@expr1073747519 type@var2550 .@expr1073747520 derivedFrom@var2552 ) {
119: if (@expr1073747521 !@expr1073747522 baseInfo@var2551 .@expr5699 type@var2553 ) {
120: return true ; }
121: if (@expr1073747524 isVclTypeInit (@expr1073747525 baseInfo@var2551 .@expr5699 type@var2553 ) ) {
122: return true ; }
123: }
124: return false ;
125: }
126:
127:
128:
129: CheckClass :: CheckClass ( const Tokenizer * tokenizer@var2554 , const Settings * settings@var2555 , ErrorLogger * errorLogger@var2556 )
130: : Check ( myName ( ) , tokenizer@var2554 , settings@var2555 , errorLogger@var2556 ) ,
131: mSymbolDatabase@var1666 ( tokenizer@var2554 ? tokenizer@var2554 . getSymbolDatabase ( ) : nullptr )
132: { }
133:
|
137:
138: void CheckClass :: constructors ( )
139: {
140: const bool printStyle@var2557 =@expr1073747528 mSettings@var29 .@expr5705 severity@var3441 .@expr5706 isEnabled (@expr1073747531 Severity ::@expr1073747532 style ) ;
141: const bool printWarnings@var2558 =@expr1073747533 mSettings@var29 .@expr5705 severity@var3441 .@expr5706 isEnabled (@expr1073747536 Severity ::@expr1073747537 warning ) ;
142: if (@expr1073747538 !@expr1073747539 printStyle@var2557 &&@expr1073747540 !@expr5717 printWarnings@var2558 ) {
143: return ; }
144:
145: const bool printInconclusive@var2559 =@expr1073747542 mSettings@var29 .@expr1073747543 certainty@var3442 .@expr1073747544 isEnabled (@expr1073747545 Certainty ::@expr1073747546 inconclusive@expr1073747527 ) ;
146: for (@expr1073747547 const Scope *@expr5724 scope@var2560 :@expr1073747549 mSymbolDatabase@var1666 .@expr1073747550 classAndStructScopes@var3443 ) {
147: if (@expr1073747551 isVcl (@expr1073747552 mSettings@var29 ) &&@expr1073747553 isVclTypeInit (@expr1073747554 scope@var2560 .@expr1073747555 definedType@var2561 ) ) {
148: continue ; }
149:
150: const bool unusedTemplate@var2562 =@expr1073747556 Token ::@expr1073747557 simpleMatch (@expr1073747558 scope@var2560 .@expr5735 classDef@var2563 .@expr1073747560 previous (@expr1073747561 ) , ">" ) ;
151:
152: bool usedInUnion@var2564 ; usedInUnion@var2564 =@expr1073747562 false ;
153: for (@expr1073747563 const Scope &@expr5740 unionScope@var2565 :@expr1073747565 mSymbolDatabase@var1666 .@expr1073747566 scopeList@var3444 ) {
154: if (@expr1073747567 unionScope@var2565 .@expr1073747568 type@var2566 !=@expr1073747569 Scope ::@expr5746 eUnion ) {
155: continue ; }
156: for (@expr1073747571 const Variable &@expr5740 var@var2567 :@expr1073747573 unionScope@var2565 .@expr1073747574 varlist@var2568 ) {
157: if (@expr1073747575 var@var2567 .@expr5752 type (@expr5753 ) &&@expr1073747578 var@var2567 .@expr5752 type (@expr5753 ) .@expr1073747581 classScope@var3463 ==@expr1073747582 scope@var2560 ) {
158: usedInUnion@var2564 =@expr1073747583 true ;
159: break ;
160: }
161: }
162: }
163:
164:
165: if (@expr1073747584 scope@var2560 .@expr1073747585 numConstructors@var2569 ==@expr1073747586 0 &&@expr1073747587 printStyle@var2557 &&@expr1073747588 !@expr1073747589 usedInUnion@var2564 ) {
166:
167: int needInit@var2570 ; needInit@var2570 =@expr1073747590 0 ; int haveInit@var2571 ; haveInit@var2571 =@expr1073747591 0 ;
168: std ::@expr1073747592 vector < const Variable *@expr5724 > uninitVars@var2572 ;
169: for (@expr1073747594 const Variable &@expr5740 var@var2573 :@expr1073747596 scope@var2560 .@expr1073747597 varlist@var2574 ) {
170: if (@expr1073747598 var@var2573 .@expr1073747599 isPrivate (@expr1073747600 ) &&@expr1073747601 !@expr1073747602 var@var2573 .@expr1073747603 isStatic (@expr1073747604 ) &&@expr1073747605
171: (@expr1073747606 !@expr1073747607 var@var2573 .@expr1073747608 isClass (@expr1073747609 ) ||@expr1073747610 (@expr1073747611 var@var2573 .@expr5788 type (@expr5789 ) &&@expr1073747614 var@var2573 .@expr5788 type (@expr5789 ) .@expr1073747617 needInitialization@var3461 ==@expr1073747618 Type ::@expr5795 NeedInitialization ::@expr5796 True ) ) ) {
172: ++@expr1073747621 needInit@var2570 ;
173: if (@expr1073747622 !@expr1073747623 var@var2573 .@expr1073747624 isInit (@expr1073747625 ) &&@expr1073747626 !@expr1073747627 var@var2573 .@expr1073747628 hasDefault (@expr1073747629 ) &&@expr1073747630 var@var2573 .@expr1073747631 nameToken (@expr1073747632 ) .@expr1073747633 scope (@expr1073747634 ) ==@expr1073747635 scope@var2560 ) {
174: uninitVars@var2572 .@expr1073747636 emplace_back (@expr1073747637 &@expr1073747638 var@var2573 ) ; }
175: else {
176: ++@expr1073747639 haveInit@var2571 ; }
177: }
178: }
179: if (@expr1073747640 needInit@var2570 >@expr1073747641 haveInit@var2571 ) {
180: if (@expr1073747642 haveInit@var2571 ==@expr1073747643 0 ) {
181: noConstructorError (@expr1073747644 scope@var2560 .@expr5735 classDef@var2563 , scope@var2560 .@expr5822 className@var2575 , scope@var2560 .@expr5735 classDef@var2563 .@expr1073747648 str (@expr1073747649 ) ==@expr1073747650 "struct" ) ; }
182: else {
183: for (@expr1073747651 const Variable *@expr5724 uv@var2576 :@expr1073747653 uninitVars@var2572 ) {
184: uninitVarError (@expr1073747654 uv@var2576 .@expr1073747655 typeStartToken (@expr1073747656 ) , uv@var2576 .@expr1073747657 scope (@expr1073747658 ) .@expr1073747659 className@var3464 , uv@var2576 .@expr1073747660 name (@expr1073747661 ) ) ; } }
185: }
186: }
187:
188: if (@expr1073747662 !@expr5717 printWarnings@var2558 ) {
189: continue ; }
190:
191:
192:
193: {
194: bool bailout@var2577 ; bailout@var2577 =@expr1073747664 false ;
195: for (@expr1073747665 const Scope *@expr5724 const nestedScope@var2578 :@expr1073747667 scope@var2560 .@expr1073747668 nestedList@var2579 ) {
196: if (@expr1073747669 nestedScope@var2578 .@expr1073747670 type@var2580 ==@expr1073747671 Scope ::@expr5746 eUnion ) {
197: bailout@var2577 =@expr1073747673 true ;
198: break ;
199: }
200: }
201: if (@expr1073747674 bailout@var2577 ) {
202: continue ; }
203: }
204:
205:
206: std ::@expr1073747675 vector < Usage > usageList@var2581 ; usageList@var2581 =@expr1073747676 createUsageList (@expr1073747677 scope@var2560 ) ;
207:
208: for (@expr1073747678 const Function &@expr5740 func@var2582 :@expr1073747680 scope@var2560 .@expr1073747681 functionList@var2583 ) {
209: if (@expr1073747682 !@expr1073747683 (@expr1073747684 func@var2582 .@expr1073747685 isConstructor (@expr1073747686 ) &&@expr1073747687 (@expr1073747688 func@var2582 .@expr5865 hasBody (@expr5866 ) ||@expr1073747691 (@expr1073747692 func@var2582 .@expr1073747693 isDefault (@expr1073747694 ) &&@expr1073747695 func@var2582 .@expr5872 type@var2584 ==@expr5873 Function ::@expr5874 eConstructor ) ) ) &&@expr1073747699
210: !@expr1073747700 (@expr1073747701 func@var2582 .@expr5872 type@var2584 ==@expr5879 Function ::@expr5880 eOperatorEqual &&@expr1073747705 func@var2582 .@expr5865 hasBody (@expr5866 ) ) ) {
211: continue ; }
212:
213:
214: if (@expr1073747708 unusedTemplate@var2562 &&@expr1073747709 func@var2582 .@expr5872 type@var2584 ==@expr5873 Function ::@expr5874 eConstructor ) {
215: const Token * initList@var2585 ; initList@var2585 =@expr1073747713 func@var2582 .@expr1073747714 constructorMemberInitialization (@expr1073747715 ) ;
216: if (@expr1073747716 Token ::@expr1073747717 Match (@expr1073747718 initList@var2585 , ": %name% (" ) &&@expr1073747719 initList@var2585 .@expr1073747720 next (@expr1073747721 ) .@expr1073747722 tokType (@expr1073747723 ) ==@expr1073747724 Token ::@expr1073747725 eName ) {
217: break ; }
218: }
219:
220:
221: clearAllVar (@expr1073747726 usageList@var2581 ) ;
222:
223: std ::@expr1073747727 list < const Function *@expr5724 > callstack@var2586 ;
224: initializeVarList (@expr1073747729 func@var2582 , callstack@var2586 , scope@var2560 , usageList@var2581 ) ;
225:
226:
227: for (@expr1073747730 Usage &@expr5740 usage@var2587 :@expr1073747732 usageList@var2581 ) {
228: const Variable &@expr5740 var@var2588 =@expr1073747734 *@expr1073747735 usage@var2587 .@expr1073747736 var@var2589 ;
229:
230:
231: if (@expr1073747737 var@var2588 .@expr1073747738 hasDefault (@expr1073747739 ) &&@expr1073747740 func@var2582 .@expr5872 type@var2584 !=@expr1073747742 Function ::@expr5880 eOperatorEqual &&@expr1073747744 func@var2582 .@expr5872 type@var2584 !=@expr1073747746 Function ::@expr1073747747 eCopyConstructor ) {
232: usage@var2587 .@expr5924 init@var2590 =@expr1073747749 true ;
233: continue ;
234: }
235:
236: if (@expr1073747750 usage@var2587 .@expr1073747751 assign@var2591 ||@expr1073747752 usage@var2587 .@expr5924 init@var2590 ||@expr1073747754 var@var2588 .@expr1073747755 isStatic (@expr1073747756 ) ) {
237: continue ; }
238:
239: if (@expr1073747757 var@var2588 .@expr5934 valueType (@expr5935 ) &&@expr1073747760 var@var2588 .@expr5934 valueType (@expr5935 ) .@expr1073747763 pointer@var3465 ==@expr1073747764 0 &&@expr1073747765 var@var2588 .@expr5942 type (@expr5943 ) &&@expr1073747768 var@var2588 .@expr5942 type (@expr5943 ) .@expr5947 needInitialization@var3461 ==@expr1073747772 Type ::@expr5795 NeedInitialization ::@expr1073747774 False &&@expr1073747775 var@var2588 .@expr5942 type (@expr5943 ) .@expr1073747778 derivedFrom@var3466 .@expr1073747779 empty (@expr1073747780 ) ) {
240: continue ; }
241:
242: if (@expr1073747781 var@var2588 .@expr1073747782 isConst (@expr1073747783 ) &&@expr1073747784 func@var2582 .@expr1073747785 isOperator (@expr1073747786 ) ) {
243: continue ; }
244:
245:
246: if (@expr1073747787 !@expr5964 var@var2588 .@expr5965 isPointer (@expr5966 ) &&@expr5967 !@expr5968 var@var2588 .@expr5969 isPointerArray (@expr5970 ) &&@expr1073747795 var@var2588 .@expr1073747796 isClass (@expr1073747797 ) &&@expr1073747798 func@var2582 .@expr5872 type@var2584 ==@expr5873 Function ::@expr5874 eConstructor ) {
247:
248: if (@expr1073747802 !@expr1073747803 var@var2588 .@expr5942 type (@expr5943 ) ) {
249: continue ; }
250:
251:
252:
253: else { if (@expr1073747806 var@var2588 .@expr5942 type (@expr5943 ) .@expr5947 needInitialization@var3461 !=@expr1073747810 Type ::@expr5795 NeedInitialization ::@expr5796 True ) {
254: continue ; } }
255: }
256:
257:
258: if (@expr1073747813 !@expr5964 var@var2588 .@expr5965 isPointer (@expr5966 ) &&@expr5967 !@expr5968 var@var2588 .@expr5969 isPointerArray (@expr5970 ) &&@expr1073747821 var@var2588 .@expr5998 typeScope (@expr5999 ) ) {
259: if (@expr1073747824 func@var2582 .@expr5872 type@var2584 ==@expr1073747826 Function ::@expr1073747827 eMoveConstructor ) {
260: if (@expr1073747828 canNotMove (@expr1073747829 var@var2588 .@expr5998 typeScope (@expr5999 ) ) ) {
261: continue ; }
262: } else {
263: if (@expr1073747832 canNotCopy (@expr1073747833 var@var2588 .@expr5998 typeScope (@expr5999 ) ) ) {
264: continue ; }
265: }
266: }
267:
268:
269: bool missingCopy@var2592 ; missingCopy@var2592 =@expr1073747836 false ;
270:
271:
272:
273: if (@expr1073747837 !@expr1073747838 isVariableCopyNeeded (@expr1073747839 var@var2588 , func@var2582 .@expr5872 type@var2584 ) ) {
274: if (@expr1073747841 !@expr1073747842 printInconclusive@var2559 ) {
275: continue ; }
276:
277: missingCopy@var2592 =@expr1073747843 true ;
278: }
279:
280:
281: if (@expr1073747844 func@var2582 .@expr5872 type@var2584 ==@expr5879 Function ::@expr5880 eOperatorEqual ) {
282: const Token * operStart@var2593 ; operStart@var2593 =@expr1073747848 func@var2582 .@expr6025 arg@var2594 ;
283:
284: bool classNameUsed@var2595 ; classNameUsed@var2595 =@expr1073747850 false ;
285: for (@expr1073747851 const Token *@expr5724 operTok@var2596 =@expr1073747853 operStart@var2593 ; operTok@var2596 !=@expr1073747854 operStart@var2593 .@expr1073747855 link (@expr1073747856 ) ; operTok@var2596 =@expr1073747857 operTok@var2596 .@expr1073747858 next (@expr1073747859 ) ) {
286: if (@expr1073747860 operTok@var2596 .@expr1073747861 str (@expr1073747862 ) ==@expr1073747863 scope@var2560 .@expr5822 className@var2575 ) {
287: classNameUsed@var2595 =@expr1073747865 true ;
288: break ;
289: }
290: }
291:
292: if (@expr1073747866 classNameUsed@var2595 &&@expr1073747867 mSettings@var29 .@expr1073747868 library@var3445 .@expr1073747869 getTypeCheck (@expr1073747870 "operatorEqVarError" , var@var2588 .@expr1073747871 getTypeName (@expr1073747872 ) ) !=@expr1073747873 Library ::@expr1073747874 TypeCheck ::@expr1073747875 suppress ) {
293: operatorEqVarError (@expr1073747876 func@var2582 .@expr6053 token@var2597 , scope@var2560 .@expr5822 className@var2575 , var@var2588 .@expr6055 name (@expr6056 ) , missingCopy@var2592 ) ; }
294: } else { if (@expr1073747881 func@var2582 .@expr6058 access@var2598 !=@expr1073747883 AccessControl ::@expr6060 Private ||@expr1073747885 mSettings@var29 .@expr1073747886 standards@var3446 .@expr1073747887 cpp@var3447 >=@expr1073747888 Standards ::@expr1073747889 CPP11 ) {
295:
296: if (@expr1073747890 !@expr1073747891 precedes (@expr1073747892 scope@var2560 .@expr1073747893 bodyStart@var2599 , func@var2582 .@expr1073747894 tokenDef@var2600 ) ) {
297: continue ; }
298: const Scope * varType@var2601 ; varType@var2601 =@expr1073747895 var@var2588 .@expr5998 typeScope (@expr5999 ) ;
299: if (@expr1073747898 !@expr1073747899 varType@var2601 ||@expr1073747900 varType@var2601 .@expr1073747901 type@var2602 !=@expr1073747902 Scope ::@expr5746 eUnion ) {
300: const bool derived@var2603 =@expr1073747904 scope@var2560 !=@expr1073747905 var@var2588 .@expr6082 scope (@expr6083 ) ;
301: if (@expr1073747908 func@var2582 .@expr5872 type@var2584 ==@expr5873 Function ::@expr5874 eConstructor &&@expr1073747912
302: func@var2582 .@expr6089 nestedIn@var2604 &&@expr1073747914 (@expr1073747915 func@var2582 .@expr6089 nestedIn@var2604 .@expr1073747917 numConstructors@var2605 -@expr1073747918 func@var2582 .@expr6089 nestedIn@var2604 .@expr1073747920 numCopyOrMoveConstructors@var2606 ) >@expr1073747921 1 &&@expr1073747922
303: func@var2582 .@expr1073747923 argCount (@expr1073747924 ) ==@expr1073747925 0 &&@expr1073747926 func@var2582 .@expr6103 functionScope@var2607 &&@expr1073747928
304: func@var2582 .@expr6025 arg@var2594 &&@expr1073747930 func@var2582 .@expr6025 arg@var2594 .@expr1073747932 link (@expr1073747933 ) .@expr1073747934 next (@expr1073747935 ) ==@expr1073747936 func@var2582 .@expr6103 functionScope@var2607 .@expr6114 bodyStart@var2608 &&@expr1073747939
305: func@var2582 .@expr6103 functionScope@var2607 .@expr6114 bodyStart@var2608 .@expr1073747942 link (@expr1073747943 ) ==@expr1073747944 func@var2582 .@expr6103 functionScope@var2607 .@expr6114 bodyStart@var2608 .@expr1073747947 next (@expr1073747948 ) ) {
306:
307: if (@expr1073747949 printInconclusive@var2559 ) {
308: uninitVarError (@expr1073747950 func@var2582 .@expr6053 token@var2597 , func@var2582 .@expr6058 access@var2598 ==@expr6129 AccessControl ::@expr6060 Private , func@var2582 .@expr5872 type@var2584 , var@var2588 .@expr6082 scope (@expr6083 ) .@expr6134 className@var3464 , var@var2588 .@expr6055 name (@expr6056 ) , derived@var2603 , true ) ; }
309: } else { if (@expr1073747961 missingCopy@var2592 ) {
310: missingMemberCopyError (@expr1073747962 func@var2582 .@expr6053 token@var2597 , func@var2582 .@expr5872 type@var2584 , var@var2588 .@expr6082 scope (@expr6083 ) .@expr6134 className@var3464 , var@var2588 .@expr6055 name (@expr6056 ) ) ; }
311: else {
312: uninitVarError (@expr1073747970 func@var2582 .@expr6053 token@var2597 , func@var2582 .@expr6058 access@var2598 ==@expr6129 AccessControl ::@expr6060 Private , func@var2582 .@expr5872 type@var2584 , var@var2588 .@expr6082 scope (@expr6083 ) .@expr6134 className@var3464 , var@var2588 .@expr6055 name (@expr6056 ) , derived@var2603 , false ) ; } }
313: }
314: } }
315: }
316: }
317: }
318: }
319:
320: void CheckClass :: checkExplicitConstructors ( )
321: {
322: if (@expr1073747981 !@expr1073747982 mSettings@var29 .@expr1073747983 severity@var3441 .@expr1073747984 isEnabled (@expr1073747985 Severity ::@expr1073747986 style ) ) {
323: return ; }
324:
325: for (@expr1073747987 const Scope *@expr1073747988 scope@var2609 :@expr1073747989 mSymbolDatabase@var1666 .@expr1073747990 classAndStructScopes@var3443 ) {
326:
327: if (@expr1073747991 scope@var2609 .@expr1073747992 numConstructors@var2610 ==@expr1073747993 0 ) {
328: continue ; }
329:
330:
331:
332: bool isAbstractClass@var2611 ; isAbstractClass@var2611 =@expr1073747994 false ;
333: for (@expr1073747995 const Function &@expr6172 func@var2612 :@expr1073747997 scope@var2609 .@expr6174 functionList@var2613 ) {
334: if (@expr1073747999 func@var2612 .@expr1073748000 isPure (@expr1073748001 ) ) {
335: isAbstractClass@var2611 =@expr1073748002 true ;
336: break ;
337: }
338: }
339:
340:
341:
342: if (@expr1073748003 isAbstractClass@var2611 &&@expr1073748004 mSettings@var29 .@expr1073748005 standards@var3446 .@expr1073748006 cpp@var3447 >=@expr1073748007 Standards ::@expr1073748008 CPP11 ) {
343: continue ; }
344:
345: for (@expr1073748009 const Function &@expr6172 func@var2614 :@expr1073748011 scope@var2609 .@expr6174 functionList@var2613 ) {
346:
|
351:
352: if (@expr1073748013 !@expr1073748014 func@var2614 .@expr1073748015 isConstructor (@expr1073748016 ) ||@expr1073748017 func@var2614 .@expr1073748018 isDelete (@expr1073748019 ) ||@expr1073748020 (@expr1073748021 !@expr1073748022 func@var2614 .@expr1073748023 hasBody (@expr1073748024 ) &&@expr1073748025 func@var2614 .@expr1073748026 access@var2615 ==@expr1073748027 AccessControl ::@expr1073748028 Private ) ) {
353: continue ; }
354:
355: if (@expr1073748029 !@expr1073748030 func@var2614 .@expr1073748031 isExplicit (@expr1073748032 ) &&@expr1073748033
356: func@var2614 .@expr1073748034 minArgCount (@expr1073748035 ) ==@expr1073748036 1 &&@expr1073748037
357: func@var2614 .@expr6214 type@var2616 !=@expr1073748039 Function ::@expr1073748040 eCopyConstructor &&@expr1073748041
358: func@var2614 .@expr6214 type@var2616 !=@expr1073748043 Function ::@expr1073748044 eMoveConstructor ) {
359: noExplicitConstructorError (@expr1073748045 func@var2614 .@expr1073748046 tokenDef@var2617 , scope@var2609 .@expr1073748047 className@var2618 , scope@var2609 .@expr1073748048 type@var2619 ==@expr1073748049 Scope ::@expr1073748050 eStruct ) ;
360: }
361: }
362: }
363: }
364:
365: static bool hasNonCopyableBase ( const Scope * scope@var2620 , bool * unknown@var2621 )
366: {
367:
368: for (@expr1073748051 const Type ::@expr1073748052 BaseInfo &@expr6229 baseInfo@var2622 :@expr1073748054 scope@var2620 .@expr1073748055 definedType@var2623 .@expr1073748056 derivedFrom@var2624 ) {
369: if (@expr1073748057 !@expr1073748058 baseInfo@var2622 .@expr6235 type@var2625 ||@expr1073748060 !@expr1073748061 baseInfo@var2622 .@expr6235 type@var2625 .@expr6239 classScope@var2626 ) {
370: *@expr6240 unknown@var2621 =@expr1073748065 true ;
371: continue ;
372: }
373:
374: if (@expr1073748066 hasNonCopyableBase (@expr1073748067 baseInfo@var2622 .@expr6235 type@var2625 .@expr6239 classScope@var2626 , unknown@var2621 ) ) {
375: return true ; }
376:
377: for (@expr1073748070 const Function &@expr6229 func@var2627 :@expr1073748072 baseInfo@var2622 .@expr6235 type@var2625 .@expr6239 classScope@var2626 .@expr1073748075 functionList@var2628 ) {
378: if (@expr1073748076 func@var2627 .@expr1073748077 type@var2629 !=@expr1073748078 Function ::@expr1073748079 eCopyConstructor ) {
379: continue ; }
380: if (@expr1073748080 func@var2627 .@expr1073748081 access@var2630 ==@expr1073748082 AccessControl ::@expr1073748083 Private ||@expr1073748084 func@var2627 .@expr1073748085 isDelete (@expr1073748086 ) ) {
381: *@expr6240 unknown@var2621 =@expr1073748088 false ;
382: return true ;
383: }
384: }
385: }
386: return false ;
387: }
388:
389: void CheckClass :: copyconstructors ( )
390: {
391: if (@expr1073748090 !@expr1073748091 mSettings@var29 .@expr1073748092 severity@var3441 .@expr1073748093 isEnabled (@expr1073748094 Severity ::@expr1073748095 warning ) ) {
392: return ; }
393:
394: for (@expr1073748096 const Scope *@expr6273 scope@var2631 :@expr1073748098 mSymbolDatabase@var1666 .@expr1073748099 classAndStructScopes@var3443 ) {
395: std ::@expr1073748100 map < int , const Token *@expr6273 > allocatedVars@var2632 ;
396:
397: for (@expr1073748102 const Function &@expr6279 func@var2633 :@expr1073748104 scope@var2631 .@expr6281 functionList@var2634 ) {
398: if (@expr1073748106 func@var2633 .@expr1073748107 type@var2635 !=@expr1073748108 Function ::@expr1073748109 eConstructor ||@expr1073748110 !@expr1073748111 func@var2633 .@expr6288 functionScope@var2636 ) {
399: continue ; }
400: const Token * tok@var2637 ; tok@var2637 =@expr1073748113 func@var2633 .@expr1073748114 token@var2638 .@expr1073748115 linkAt (@expr1073748116 1 ) ;
401: for (@expr1073748117 const Token *@expr6273 const end@var2639 =@expr1073748119 func@var2633 .@expr6288 functionScope@var2636 .@expr1073748121 bodyStart@var2640 ; tok@var2637 !=@expr1073748122 end@var2639 ; tok@var2637 =@expr1073748123 tok@var2637 .@expr6300 next (@expr6301 ) ) {
402: if (@expr1073748126 Token ::@expr6303 Match (@expr1073748128 tok@var2637 , "%var% ( new" ) ||@expr1073748129
403: (@expr1073748130 Token ::@expr6303 Match (@expr1073748132 tok@var2637 , "%var% ( %name% (" ) &&@expr1073748133 mSettings@var29 .@expr6310 library@var3445 .@expr6311 getAllocFuncInfo (@expr6312 tok@var2637 .@expr6313 tokAt (@expr6314 2 ) ) ) ) {
404: const Variable * var@var2641 ; var@var2641 =@expr1073748139 tok@var2637 .@expr6316 variable (@expr6317 ) ;
405: if (@expr1073748142 var@var2641 &&@expr1073748143 var@var2641 .@expr1073748144 isPointer (@expr1073748145 ) &&@expr1073748146 var@var2641 .@expr1073748147 scope (@expr1073748148 ) ==@expr1073748149 scope@var2631 ) {
406: allocatedVars@var2632 [@expr6326 tok@var2637 .@expr6327 varId (@expr6328 ) ] =@expr1073748153 tok@var2637 ; }
407: }
408: }
409: for (@expr1073748154 const Token *@expr6273 const end@var2642 =@expr1073748156 func@var2633 .@expr6288 functionScope@var2636 .@expr1073748158 bodyEnd@var2643 ; tok@var2637 !=@expr1073748159 end@var2642 ; tok@var2637 =@expr1073748160 tok@var2637 .@expr6300 next (@expr6301 ) ) {
410: if (@expr1073748163 Token ::@expr6303 Match (@expr1073748165 tok@var2637 , "%var% = new" ) ||@expr1073748166
411: (@expr1073748167 Token ::@expr6303 Match (@expr1073748169 tok@var2637 , "%var% = %name% (" ) &&@expr1073748170 mSettings@var29 .@expr6310 library@var3445 .@expr6311 getAllocFuncInfo (@expr6312 tok@var2637 .@expr6313 tokAt (@expr6314 2 ) ) ) ) {
412: const Variable * var@var2644 ; var@var2644 =@expr1073748176 tok@var2637 .@expr6316 variable (@expr6317 ) ;
413: if (@expr1073748179 var@var2644 &&@expr1073748180 var@var2644 .@expr1073748181 isPointer (@expr1073748182 ) &&@expr1073748183 var@var2644 .@expr1073748184 scope (@expr1073748185 ) ==@expr1073748186 scope@var2631 &&@expr1073748187 !@expr1073748188 var@var2644 .@expr1073748189 isStatic (@expr1073748190 ) ) {
414: allocatedVars@var2632 [@expr6326 tok@var2637 .@expr6327 varId (@expr6328 ) ] =@expr1073748194 tok@var2637 ; }
415: }
416: }
417: }
418:
419: if (@expr1073748195 !@expr1073748196 allocatedVars@var2632 .@expr1073748197 empty (@expr1073748198 ) ) {
420: const Function * funcCopyCtor@var2645 ; funcCopyCtor@var2645 =@expr1073748199 nullptr ;
421: const Function * funcOperatorEq@var2646 ; funcOperatorEq@var2646 =@expr1073748200 nullptr ;
422: const Function * funcDestructor@var2647 ; funcDestructor@var2647 =@expr1073748201 nullptr ;
423: for (@expr1073748202 const Function &@expr6279 func@var2648 :@expr1073748204 scope@var2631 .@expr6281 functionList@var2634 ) {
424: if (@expr1073748206 func@var2648 .@expr6383 type@var2649 ==@expr1073748208 Function ::@expr6385 eCopyConstructor ) {
425: funcCopyCtor@var2645 =@expr1073748210 &@expr6387 func@var2648 ; }
426: else { if (@expr1073748212 func@var2648 .@expr6383 type@var2649 ==@expr1073748214 Function ::@expr1073748215 eOperatorEqual ) {
427: funcOperatorEq@var2646 =@expr1073748216 &@expr6387 func@var2648 ; }
428: else { if (@expr1073748218 func@var2648 .@expr6383 type@var2649 ==@expr1073748220 Function ::@expr1073748221 eDestructor ) {
429: funcDestructor@var2647 =@expr1073748222 &@expr6387 func@var2648 ; } } }
430: }
431: if (@expr1073748224 !@expr1073748225 funcCopyCtor@var2645 ||@expr1073748226 funcCopyCtor@var2645 .@expr1073748227 isDefault (@expr1073748228 ) ) {
432: bool unknown@var2650 ; unknown@var2650 =@expr1073748229 false ;
433: if (@expr1073748230 !@expr1073748231 hasNonCopyableBase (@expr1073748232 scope@var2631 , &@expr1073748233 unknown@var2650 ) &&@expr1073748234 !@expr1073748235 unknown@var2650 ) {
434: noCopyConstructorError (@expr1073748236 scope@var2631 , funcCopyCtor@var2645 , allocatedVars@var2632 .@expr6413 begin (@expr6414 ) .@expr6415 second@expr6265 , unknown@var2650 ) ; }
435: }
436: if (@expr1073748240 !@expr1073748241 funcOperatorEq@var2646 ||@expr1073748242 funcOperatorEq@var2646 .@expr1073748243 isDefault (@expr1073748244 ) ) {
437: bool unknown@var2651 ; unknown@var2651 =@expr1073748245 false ;
438: if (@expr1073748246 !@expr1073748247 hasNonCopyableBase (@expr1073748248 scope@var2631 , &@expr1073748249 unknown@var2651 ) &&@expr1073748250 !@expr1073748251 unknown@var2651 ) {
439: noOperatorEqError (@expr1073748252 scope@var2631 , funcOperatorEq@var2646 , allocatedVars@var2632 .@expr6413 begin (@expr6414 ) .@expr6415 second@expr6265 , unknown@var2651 ) ; }
440: }
441: if (@expr1073748256 !@expr1073748257 funcDestructor@var2647 ||@expr1073748258 funcDestructor@var2647 .@expr1073748259 isDefault (@expr1073748260 ) ) {
442: const Token * mustDealloc@var2652 ; mustDealloc@var2652 =@expr1073748261 nullptr ;
443: for (@expr1073748262 std ::@expr6439 map < int , const Token *@expr6273 > ::@expr6439 const_iterator it@var2653 =@expr1073748266 allocatedVars@var2632 .@expr6413 begin (@expr6414 ) ; it@var2653 !=@expr1073748269 allocatedVars@var2632 .@expr6446 end (@expr6447 ) ; ++@expr1073748272 it@var2653 ) {
444: if (@expr1073748273 !@expr1073748274 Token ::@expr6303 Match (@expr1073748276 it@var2653 .@expr6453 second@var2654 , "%var% [(=] new %type%" ) ) {
445: mustDealloc@var2652 =@expr1073748278 it@var2653 .@expr6453 second@var2654 ;
446: break ;
447: }
448: if (@expr1073748280 it@var2653 .@expr6453 second@var2654 .@expr6458 valueType (@expr6459 ) &&@expr1073748284 it@var2653 .@expr6453 second@var2654 .@expr6458 valueType (@expr6459 ) .@expr1073748288 isIntegral (@expr1073748289 ) ) {
449: mustDealloc@var2652 =@expr1073748290 it@var2653 .@expr6453 second@var2654 ;
450: break ;
451: }
452: const Variable * var@var2655 ; var@var2655 =@expr1073748292 it@var2653 .@expr6453 second@var2654 .@expr1073748294 variable (@expr1073748295 ) ;
453: if (@expr1073748296 var@var2655 &&@expr1073748297 var@var2655 .@expr6474 typeScope (@expr6475 ) &&@expr1073748300 var@var2655 .@expr6474 typeScope (@expr6475 ) .@expr1073748303 functionList@var3467 .@expr1073748304 empty (@expr1073748305 ) &&@expr1073748306 var@var2655 .@expr1073748307 type (@expr1073748308 ) .@expr1073748309 derivedFrom@var3466 .@expr1073748310 empty (@expr1073748311 ) ) {
454: mustDealloc@var2652 =@expr1073748312 it@var2653 .@expr6453 second@var2654 ;
455: break ;
456: }
457: }
458: if (@expr1073748314 mustDealloc@var2652 ) {
459: noDestructorError (@expr1073748315 scope@var2631 , funcDestructor@var2647 , mustDealloc@var2652 ) ; }
460: }
461: }
462:
463: std ::@expr1073748316 set < const Token *@expr6273 > copiedVars@var2656 ;
464: const Token * copyCtor@var2657 ; copyCtor@var2657 =@expr1073748318 nullptr ;
465: for (@expr1073748319 const Function &@expr6279 func@var2658 :@expr1073748321 scope@var2631 .@expr6281 functionList@var2634 ) {
466: if (@expr1073748323 func@var2658 .@expr1073748324 type@var2659 !=@expr1073748325 Function ::@expr6385 eCopyConstructor ) {
467: continue ; }
468: copyCtor@var2657 =@expr1073748327 func@var2658 .@expr6504 tokenDef@var2660 ;
469: if (@expr1073748329 !@expr1073748330 func@var2658 .@expr6507 functionScope@var2661 ) {
470: allocatedVars@var2632 .@expr1073748332 clear (@expr1073748333 ) ;
471: break ;
472: }
473: const Token * tok@var2662 ; tok@var2662 =@expr1073748334 func@var2658 .@expr6504 tokenDef@var2660 .@expr1073748336 linkAt (@expr1073748337 1 ) .@expr1073748338 next (@expr1073748339 ) ;
474: if (@expr1073748340 tok@var2662 .@expr1073748341 str (@expr1073748342 ) ==@expr1073748343 ":" ) {
475: tok@var2662 =@expr1073748344 tok@var2662 .@expr6521 next (@expr6522 ) ;
476: while (@expr1073748347 Token ::@expr6303 Match (@expr1073748349 tok@var2662 , "%name% (" ) ) {
477: if (@expr1073748350 allocatedVars@var2632 .@expr6527 find (@expr6528 tok@var2662 .@expr6529 varId (@expr6530 ) ) !=@expr6531 allocatedVars@var2632 .@expr6446 end (@expr6447 ) ) {
478: if (@expr1073748358 tok@var2662 .@expr6529 varId (@expr6530 ) &&@expr1073748361 Token ::@expr6303 Match (@expr1073748363 tok@var2662 .@expr6540 tokAt (@expr6541 2 ) , "%name% . %name% )" ) ) {
479: copiedVars@var2656 .@expr6542 insert (@expr6543 tok@var2662 ) ; }
480: else { if (@expr1073748368 !@expr1073748369 Token ::@expr6303 Match (@expr1073748371 tok@var2662 .@expr6540 tokAt (@expr6541 2 ) , "%any% )" ) ) {
481: allocatedVars@var2632 .@expr6550 erase (@expr6551 tok@var2662 .@expr6529 varId (@expr6530 ) ) ; } }
482: }
483: tok@var2662 =@expr1073748378 tok@var2662 .@expr1073748379 linkAt (@expr1073748380 1 ) .@expr1073748381 tokAt (@expr1073748382 2 ) ;
484: }
485: }
486: for (@expr1073748383 tok@var2662 =@expr1073748384 func@var2658 .@expr6507 functionScope@var2661 .@expr1073748386 bodyStart@var2663 ; tok@var2662 !=@expr1073748387 func@var2658 .@expr6507 functionScope@var2661 .@expr1073748389 bodyEnd@var2664 ; tok@var2662 =@expr1073748390 tok@var2662 .@expr6521 next (@expr6522 ) ) {
487: if (@expr1073748393 Token ::@expr6303 Match (@expr1073748395 tok@var2662 , "%var% = new|malloc|g_malloc|g_try_malloc|realloc|g_realloc|g_try_realloc" ) ) {
488: allocatedVars@var2632 .@expr6550 erase (@expr6551 tok@var2662 .@expr6529 varId (@expr6530 ) ) ;
489: } else { if (@expr1073748400 Token ::@expr6303 Match (@expr1073748402 tok@var2662 , "%var% = %name% . %name% ;" ) &&@expr1073748403 allocatedVars@var2632 .@expr6527 find (@expr6528 tok@var2662 .@expr6529 varId (@expr6530 ) ) !=@expr6531 allocatedVars@var2632 .@expr6446 end (@expr6447 ) ) {
490: copiedVars@var2656 .@expr6542 insert (@expr6543 tok@var2662 ) ;
491: } }
492: }
493: break ;
494: }
495: if (@expr1073748413 copyCtor@var2657 &&@expr1073748414 !@expr1073748415 copiedVars@var2656 .@expr1073748416 empty (@expr1073748417 ) ) {
496: for (@expr1073748418 const Token *@expr6273 cv@var2665 :@expr1073748420 copiedVars@var2656 ) {
497: copyConstructorShallowCopyError (@expr1073748421 cv@var2665 , cv@var2665 .@expr1073748422 str (@expr1073748423 ) ) ; }
498:
|
503:
504: }
505: }
506: }
507:
|
517:
518: void CheckClass :: copyConstructorShallowCopyError ( const Token * tok@var2666 , const std :: string & varname@var2667 )
519: {
520: reportError (@expr1073748424 tok@var2666 , Severity ::@expr1073748425 warning , "copyCtorPointerCopying" ,
521: "$symbol:" +@expr1073748426 varname@var2667 +@expr1073748427 "\nValue of pointer '$symbol', which points to allocated memory, is copied in copy constructor instead of allocating new memory." , CWE398@var2537 , Certainty ::@expr1073748428 normal ) ;
522: }
523:
524: static std :: string noMemberErrorMessage ( const Scope * scope@var2668 , const char function@var2669 [ ] , bool isdefault@var2670 )
525: {
526: const std ::@expr6605 string &@expr1073748430 classname@var2671 =@expr1073748431 scope@var2668 ?@expr1073748432 scope@var2668 .@expr1073748433 className@var2672 :@expr1073748434 "class" ;
527: const std ::@expr6605 string type@var2673 =@expr1073748436 (@expr1073748437 scope@var2668 &&@expr1073748438 scope@var2668 .@expr1073748439 type@var2674 ==@expr1073748440 Scope ::@expr1073748441 eStruct ) ?@expr1073748442 "Struct" :@expr1073748443 "Class" ;
528: const bool isDestructor@var2675 =@expr1073748444 function@var2669 [@expr1073748445 0 ] ==@expr1073748446 'd' ;
529: std ::@expr1073748447 string errmsg@var2676 ; errmsg@var2676 =@expr1073748448 "$symbol:" +@expr1073748449 classname@var2671 +@expr1073748450 '\n' ;
530:
531: if (@expr1073748451 isdefault@var2670 ) {
532: errmsg@var2676 +=@expr1073748452 type@var2673 +@expr1073748453 " '$symbol' has dynamic memory/resource allocation(s). The " +@expr1073748454 function@var2669 +@expr1073748455 " is explicitly defaulted but the default " +@expr1073748456 function@var2669 +@expr1073748457 " does not work well." ;
533: if (@expr1073748458 isDestructor@var2675 ) {
534: errmsg@var2676 +=@expr1073748459 " It is recommended to define the " +@expr1073748460 std ::@expr6637 string (@expr6638 function@var2669 ) +@expr1073748463 '.' ; }
535: else {
536: errmsg@var2676 +=@expr1073748464 " It is recommended to define or delete the " +@expr1073748465 std ::@expr6637 string (@expr6638 function@var2669 ) +@expr1073748468 '.' ; }
537: } else {
538: errmsg@var2676 +=@expr1073748469 type@var2673 +@expr1073748470 " '$symbol' does not have a " +@expr1073748471 function@var2669 +@expr1073748472 " which is recommended since it has dynamic memory/resource allocation(s)." ;
539: }
540:
541: return errmsg@var2676 ;
542: }
543:
544: void CheckClass :: noCopyConstructorError ( const Scope * scope@var2677 , bool isdefault@var2678 , const Token * alloc@var2679 , bool inconclusive@var2680 )
545: {
546: reportError (@expr1073748473 alloc@var2679 , Severity ::@expr1073748474 warning , "noCopyConstructor" , noMemberErrorMessage (@expr1073748475 scope@var2677 , "copy constructor" , isdefault@var2678 ) , CWE398@var2537 , inconclusive@var2680 ?@expr1073748476 Certainty ::@expr1073748477 inconclusive :@expr1073748478 Certainty ::@expr1073748479 normal ) ;
547: }
548:
549: void CheckClass :: noOperatorEqError ( const Scope * scope@var2681 , bool isdefault@var2682 , const Token * alloc@var2683 , bool inconclusive@var2684 )
550: {
551: reportError (@expr1073748480 alloc@var2683 , Severity ::@expr1073748481 warning , "noOperatorEq" , noMemberErrorMessage (@expr1073748482 scope@var2681 , "operator=" , isdefault@var2682 ) , CWE398@var2537 , inconclusive@var2684 ?@expr1073748483 Certainty ::@expr1073748484 inconclusive :@expr1073748485 Certainty ::@expr1073748486 normal ) ;
552: }
553:
554: void CheckClass :: noDestructorError ( const Scope * scope@var2685 , bool isdefault@var2686 , const Token * alloc@var2687 )
555: {
556: reportError (@expr1073748487 alloc@var2687 , Severity ::@expr1073748488 warning , "noDestructor" , noMemberErrorMessage (@expr1073748489 scope@var2685 , "destructor" , isdefault@var2686 ) , CWE398@var2537 , Certainty ::@expr1073748490 normal ) ;
557: }
558:
559: bool CheckClass :: canNotCopy ( const Scope * scope@var2688 )
560: {
561: bool constructor@var2689 ; constructor@var2689 =@expr1073748491 false ;
562: bool publicAssign@var2690 ; publicAssign@var2690 =@expr1073748492 false ;
563: bool publicCopy@var2691 ; publicCopy@var2691 =@expr1073748493 false ;
564:
565: for (@expr1073748494 const Function &@expr1073748495 func@var2692 :@expr1073748496 scope@var2688 .@expr1073748497 functionList@var2693 ) {
566: if (@expr1073748498 func@var2692 .@expr1073748499 isConstructor (@expr1073748500 ) ) {
567: constructor@var2689 =@expr1073748501 true ; }
568: if (@expr1073748502 func@var2692 .@expr1073748503 access@var2694 !=@expr1073748504 AccessControl ::@expr1073748505 Public ) {
569: continue ; }
570: if (@expr1073748506 func@var2692 .@expr6683 type@var2695 ==@expr1073748508 Function ::@expr1073748509 eCopyConstructor ) {
571: publicCopy@var2691 =@expr1073748510 true ;
572: break ;
573: } else { if (@expr1073748511 func@var2692 .@expr6683 type@var2695 ==@expr1073748513 Function ::@expr1073748514 eOperatorEqual ) {
574: publicAssign@var2690 =@expr1073748515 true ;
575: break ;
576: } }
577: }
578:
579: return constructor@var2689 &&@expr1073748516 !@expr1073748517 (@expr1073748518 publicAssign@var2690 ||@expr1073748519 publicCopy@var2691 ) ;
580: }
581:
582: bool CheckClass :: canNotMove ( const Scope * scope@var2696 )
583: {
584: bool constructor@var2697 ; constructor@var2697 =@expr1073748520 false ;
585: bool publicAssign@var2698 ; publicAssign@var2698 =@expr1073748521 false ;
586: bool publicCopy@var2699 ; publicCopy@var2699 =@expr1073748522 false ;
587: bool publicMove@var2700 ; publicMove@var2700 =@expr1073748523 false ;
588:
589: for (@expr1073748524 const Function &@expr1073748525 func@var2701 :@expr1073748526 scope@var2696 .@expr1073748527 functionList@var2702 ) {
590: if (@expr1073748528 func@var2701 .@expr1073748529 isConstructor (@expr1073748530 ) ) {
591: constructor@var2697 =@expr1073748531 true ; }
592: if (@expr1073748532 func@var2701 .@expr1073748533 access@var2703 !=@expr1073748534 AccessControl ::@expr1073748535 Public ) {
593: continue ; }
594: if (@expr1073748536 func@var2701 .@expr6713 type@var2704 ==@expr1073748538 Function ::@expr1073748539 eCopyConstructor ) {
595: publicCopy@var2699 =@expr1073748540 true ;
596: break ;
597: } else { if (@expr1073748541 func@var2701 .@expr6713 type@var2704 ==@expr1073748543 Function ::@expr1073748544 eMoveConstructor ) {
598: publicMove@var2700 =@expr1073748545 true ;
599: break ;
600: } else { if (@expr1073748546 func@var2701 .@expr6713 type@var2704 ==@expr1073748548 Function ::@expr1073748549 eOperatorEqual ) {
601: publicAssign@var2698 =@expr1073748550 true ;
602: break ;
603: } } }
604: }
605:
606: return constructor@var2697 &&@expr1073748551 !@expr1073748552 (@expr1073748553 publicAssign@var2698 ||@expr1073748554 publicCopy@var2699 ||@expr1073748555 publicMove@var2700 ) ;
607: }
608:
609: static void getAllVariableMembers ( const Scope * scope@var2705 , std :: vector < const Variable * > & varList@var2706 )
610: {
611: for (@expr1073748556 const Variable &@expr6733 var@var2707 :@expr1073748558 scope@var2705 .@expr1073748559 varlist@var2708 ) {
612: varList@var2706 .@expr1073748560 push_back (@expr1073748561 &@expr1073748562 var@var2707 ) ; }
613: if (@expr1073748563 scope@var2705 .@expr6740 definedType@var2709 ) {
614: for (@expr1073748565 const Type ::@expr1073748566 BaseInfo &@expr6733 baseInfo@var2710 :@expr1073748568 scope@var2705 .@expr6740 definedType@var2709 .@expr1073748570 derivedFrom@var2711 ) {
615: if (@expr1073748571 scope@var2705 .@expr6740 definedType@var2709 ==@expr1073748573 baseInfo@var2710 .@expr6750 type@var2712 ) {
616: continue ; }
617: const Scope * baseClass@var2713 ; baseClass@var2713 =@expr1073748575 baseInfo@var2710 .@expr6750 type@var2712 ?@expr1073748577 baseInfo@var2710 .@expr6750 type@var2712 .@expr1073748579 classScope@var2714 :@expr1073748580 nullptr ;
618: if (@expr1073748581 baseClass@var2713 &&@expr1073748582 baseClass@var2713 .@expr1073748583 isClassOrStruct (@expr1073748584 ) &&@expr1073748585 baseClass@var2713 .@expr1073748586 numConstructors@var2715 ==@expr1073748587 0 ) {
619: getAllVariableMembers (@expr1073748588 baseClass@var2713 , varList@var2706 ) ; }
620: }
621: }
622: }
623:
624: std :: vector < CheckClass :: Usage > CheckClass :: createUsageList ( const Scope * scope@var2716 )
625: {
626: std ::@expr1073748589 vector < Usage > ret@var2717 ;
627: std ::@expr1073748590 vector < const Variable *@expr6767 > varlist@var2718 ;
628: getAllVariableMembers (@expr1073748592 scope@var2716 , varlist@var2718 ) ;
629: ret@var2717 .@expr1073748593 reserve (@expr1073748594 varlist@var2718 .@expr1073748595 size (@expr1073748596 ) ) ;
630: for (@expr1073748597 const Variable *@expr6767 var@var2719 :@expr1073748599 varlist@var2718 ) {
631: ret@var2717 .@expr1073748600 emplace_back (@expr1073748601 var@var2719 ) ; }
632: return ret@var2717 ;
633: }
634:
635: void CheckClass :: assignVar ( std :: vector < Usage > & usageList@var2720 , int varid@var2721 )
636: {
637: for (@expr1073748602 Usage &@expr1073748603 usage@var2722 :@expr1073748604 usageList@var2720 ) {
638: if (@expr1073748605 usage@var2722 .@expr1073748606 var@var2723 .@expr1073748607 declarationId (@expr1073748608 ) ==@expr1073748609 varid@var2721 ) {
639: usage@var2722 .@expr1073748610 assign@var2724 =@expr1073748611 true ;
640: return ;
641: }
642: }
643: }
644:
645: void CheckClass :: initVar ( std :: vector < Usage > & usageList@var2725 , int varid@var2726 )
646: {
647: for (@expr1073748612 Usage &@expr1073748613 usage@var2727 :@expr1073748614 usageList@var2725 ) {
648: if (@expr1073748615 usage@var2727 .@expr1073748616 var@var2728 .@expr1073748617 declarationId (@expr1073748618 ) ==@expr1073748619 varid@var2726 ) {
649: usage@var2727 .@expr1073748620 init@var2729 =@expr1073748621 true ;
650: return ;
651: }
652: }
653: }
654:
655: void CheckClass :: assignAllVar ( std :: vector < Usage > & usageList@var2730 )
656: {
657: for (@expr1073748622 Usage &@expr1073748623 i@var2731 :@expr1073748624 usageList@var2730 ) {
658: i@var2731 .@expr1073748625 assign@var2732 =@expr1073748626 true ; }
659: }
660:
661: void CheckClass :: clearAllVar ( std :: vector < Usage > & usageList@var2733 )
662: {
663: for (@expr1073748627 Usage &@expr1073748628 i@var2734 :@expr1073748629 usageList@var2733 ) {
664: i@var2734 .@expr1073748630 assign@var2735 =@expr1073748631 false ;
665: i@var2734 .@expr1073748632 init@var2736 =@expr1073748633 false ;
666: }
667: }
668:
669: bool CheckClass :: isBaseClassFunc ( const Token * tok@var2737 , const Scope * scope@var2738 )
670: {
671:
672: for (@expr1073748634 const Type ::@expr1073748635 BaseInfo &@expr6812 i@var2739 :@expr1073748637 scope@var2738 .@expr1073748638 definedType@var2740 .@expr1073748639 derivedFrom@var2741 ) {
673: const Type * derivedFrom@var2742 ; derivedFrom@var2742 =@expr1073748640 i@var2739 .@expr1073748641 type@var2743 ;
674:
675:
676: if (@expr1073748642 derivedFrom@var2742 &&@expr1073748643 derivedFrom@var2742 .@expr6820 classScope@var2744 ) {
677: const std ::@expr1073748645 list < Function > & functionList@var2745 =@expr1073748646 derivedFrom@var2742 .@expr6820 classScope@var2744 .@expr1073748648 functionList@var2746 ;
678:
679: for (@expr1073748649 const Function &@expr6812 func@var2747 :@expr1073748651 functionList@var2745 ) {
680: if (@expr1073748652 func@var2747 .@expr1073748653 tokenDef@var2748 .@expr1073748654 str (@expr1073748655 ) ==@expr1073748656 tok@var2737 .@expr1073748657 str (@expr1073748658 ) ) {
681: return true ; }
682: }
683: if (@expr1073748659 isBaseClassFunc (@expr1073748660 tok@var2737 , derivedFrom@var2742 .@expr6820 classScope@var2744 ) ) {
684: return true ; }
685: }
686:
687:
688: else {
689: return true ; }
690: }
691:
692: return false ;
693: }
694:
695: void CheckClass :: initializeVarList ( const Function & func@var2749 , std :: list < const Function * > & callstack@var2750 , const Scope * scope@var2751 , std :: vector < Usage > & usage@var2752 )
696: {
697: if (@expr1073748662 !@expr1073748663 func@var2749 .@expr6840 functionScope@var2753 ) {
698: return ; }
699:
700: bool initList@var2754 ; initList@var2754 =@expr1073748665 func@var2749 .@expr6842 isConstructor (@expr6843 ) ;
701: const Token * ftok@var2755 ; ftok@var2755 =@expr1073748668 func@var2749 .@expr1073748669 arg@var2756 .@expr1073748670 link (@expr1073748671 ) .@expr1073748672 next (@expr1073748673 ) ;
702: int level@var2757 ; level@var2757 =@expr1073748674 0 ;
703: for (@expr1073748675 ; ftok@var2755 &&@expr1073748676 ftok@var2755 !=@expr1073748677 func@var2749 .@expr6840 functionScope@var2753 .@expr1073748679 bodyEnd@var2758 ; ftok@var2755 =@expr1073748680 ftok@var2755 .@expr6857 next (@expr6858 ) ) {
704:
705:
706: if (@expr6859 initList@var2754 ) {
707: if (@expr1073748684 level@var2757 ==@expr1073748685 0 &&@expr1073748686 Token ::@expr6863 Match (@expr1073748688 ftok@var2755 , "%name% {|(" ) &&@expr1073748689 Token ::@expr6863 Match (@expr1073748691 ftok@var2755 .@expr6868 linkAt (@expr6869 1 ) , "}|) ,|{" ) ) {
708: if (@expr1073748694 ftok@var2755 .@expr6871 str (@expr6872 ) !=@expr1073748697 func@var2749 .@expr1073748698 name (@expr1073748699 ) ) {
709: initVar (@expr1073748700 usage@var2752 , ftok@var2755 .@expr6877 varId (@expr6878 ) ) ;
710: } else {
711: const Function * member@var2759 ; member@var2759 =@expr1073748703 ftok@var2755 .@expr6880 function (@expr6881 ) ;
712:
713: if (@expr1073748706 !@expr1073748707 member@var2759 ) {
714: assignAllVar (@expr6884 usage@var2752 ) ;
715: return ;
716: }
717:
718:
719:
720: if (@expr1073748709 std ::@expr6886 find (@expr1073748711 callstack@var2750 .@expr6888 begin (@expr6889 ) , callstack@var2750 .@expr6890 end (@expr6891 ) , member@var2759 ) !=@expr1073748716 callstack@var2750 .@expr6890 end (@expr6891 ) ) {
721:
722: assignAllVar (@expr6884 usage@var2752 ) ;
723: return ;
724: }
725:
726:
727: if (@expr1073748720 member@var2759 .@expr1073748721 hasBody (@expr1073748722 ) ) {
728:
729: callstack@var2750 .@expr6899 push_back (@expr1073748724 member@var2759 ) ;
730: initializeVarList (@expr1073748725 *@expr1073748726 member@var2759 , callstack@var2750 , scope@var2751 , usage@var2752 ) ;
731: callstack@var2750 .@expr6903 pop_back (@expr6904 ) ;
732: }
733:
734:
735: else {
736: assignAllVar (@expr6884 usage@var2752 ) ;
737: }
738: }
739: } else { if (@expr1073748730 level@var2757 !=@expr6907 0 &&@expr1073748732 Token ::@expr6863 Match (@expr6910 ftok@var2755 , "%name% =" ) ) {
740: assignVar (@expr6911 usage@var2752 , ftok@var2755 .@expr6877 varId (@expr6878 ) ) ; } }
741:
742:
743: if (@expr1073748738 ftok@var2755 .@expr6915 link (@expr6916 ) &&@expr1073748741 Token ::@expr6863 Match (@expr1073748743 ftok@var2755 , "(|<" ) ) {
744: level@var2757 ++@expr1073748744 ; }
745: else { if (@expr1073748745 ftok@var2755 .@expr6871 str (@expr6872 ) ==@expr1073748748 "{" ) {
746: if (@expr1073748749 level@var2757 !=@expr6907 0 ||@expr1073748751
747: (@expr1073748752 Token ::@expr6863 Match (@expr1073748754 ftok@var2755 .@expr1073748755 previous (@expr1073748756 ) , "%name%|>" ) &&@expr1073748757 Token ::@expr6863 Match (@expr1073748759 ftok@var2755 .@expr6915 link (@expr6916 ) , "} ,|{" ) ) ) {
748: level@var2757 ++@expr1073748762 ; }
749: else {
750: initList@var2754 =@expr1073748763 false ; }
751: } else { if (@expr1073748764 ftok@var2755 .@expr6915 link (@expr6916 ) &&@expr1073748767 Token ::@expr6863 Match (@expr1073748769 ftok@var2755 , ")|>|}" ) ) {
752: level@var2757 --@expr1073748770 ; } } }
753: }
754:
755: if (@expr6859 initList@var2754 ) {
756: continue ; }
757:
758:
759: if (@expr1073748772 Token ::@expr6863 Match (@expr1073748774 ftok@var2755 , ">>|& %name%" ) &&@expr1073748775 isLikelyStreamRead (@expr1073748776 true , ftok@var2755 ) ) {
760: assignVar (@expr6953 usage@var2752 , ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6956 varId (@expr6957 ) ) ;
761: }
762:
763:
764: if (@expr1073748782 Token ::@expr6863 Match (@expr1073748784 ftok@var2755 , "%oror%|&&" ) ) {
765: continue ; }
766:
767: if (@expr1073748785 Token ::@expr6962 simpleMatch (@expr1073748787 ftok@var2755 , "( !" ) ) {
768: ftok@var2755 =@expr1073748788 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
769:
770:
771: if (@expr1073748791 Token ::@expr6863 Match (@expr1073748793 ftok@var2755 .@expr6857 next (@expr6858 ) , "return| (| * this )| =" ) ) {
772: assignAllVar (@expr6884 usage@var2752 ) ;
773: break ;
774: }
775:
776:
777: if (@expr1073748797 func@var2749 .@expr1073748798 type@var2760 ==@expr1073748799 Function ::@expr1073748800 eOperatorEqual &&@expr1073748801 Token ::@expr6863 Match (@expr1073748803 ftok@var2755 , "[;{}] %name% (" ) &&@expr1073748804 Token ::@expr6863 Match (@expr1073748806 ftok@var2755 .@expr6868 linkAt (@expr1073748808 2 ) , ") . %name% ( *| this ) ;" ) ) {
778: assignAllVar (@expr6884 usage@var2752 ) ;
779: break ;
780: }
781:
782:
783: if (@expr1073748810 Token ::@expr6863 Match (@expr1073748812 ftok@var2755 .@expr6857 next (@expr6858 ) , "%var% . %name% (" ) &&@expr1073748815 !@expr1073748816 (@expr1073748817 ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6996 valueType (@expr6997 ) &&@expr1073748822 ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6996 valueType (@expr6997 ) .@expr1073748827 pointer@var3480 ) ) {
784: for (@expr1073748828 const Variable &@expr1073748829 var@var2761 :@expr1073748830 scope@var2751 .@expr1073748831 varlist@var2762 ) {
785: if (@expr1073748832 var@var2761 .@expr1073748833 declarationId (@expr1073748834 ) ==@expr1073748835 ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6956 varId (@expr6957 ) ) {
786:
787: assignVar (@expr6953 usage@var2752 , ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6956 varId (@expr6957 ) ) ;
788: break ;
789: }
790: }
791:
792: ftok@var2755 =@expr1073748845 ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) ;
793: }
794:
795: if (@expr1073748848 !@expr1073748849 Token ::@expr6863 Match (@expr1073748851 ftok@var2755 .@expr6857 next (@expr6858 ) , "::| %name%" ) &&@expr1073748854
796: !@expr1073748855 Token ::@expr6863 Match (@expr1073748857 ftok@var2755 .@expr6857 next (@expr6858 ) , "*| this . %name%" ) &&@expr1073748860
797: !@expr1073748861 Token ::@expr6863 Match (@expr1073748863 ftok@var2755 .@expr6857 next (@expr6858 ) , "* %name% =" ) &&@expr1073748866
798: !@expr1073748867 Token ::@expr6863 Match (@expr1073748869 ftok@var2755 .@expr6857 next (@expr6858 ) , "( * this ) . %name%" ) ) {
799: continue ; }
800:
801:
802: ftok@var2755 =@expr1073748872 ftok@var2755 .@expr6857 next (@expr6858 ) ;
803:
804:
805: if (@expr1073748875 ftok@var2755 .@expr6871 str (@expr6872 ) ==@expr1073748878 "return" ) {
806: ftok@var2755 =@expr1073748879 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
807:
808:
809: if (@expr1073748882 Token ::@expr6962 simpleMatch (@expr1073748884 ftok@var2755 , "( * this ) ." ) ) {
810: ftok@var2755 =@expr1073748885 ftok@var2755 .@expr7022 tokAt (@expr1073748887 5 ) ;
811: }
812:
813:
814: if (@expr1073748888 Token ::@expr6962 simpleMatch (@expr1073748890 ftok@var2755 , "this ." ) ) {
815: ftok@var2755 =@expr1073748891 ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) ; }
816:
817:
818: if (@expr1073748894 Token ::@expr6863 Match (@expr1073748896 ftok@var2755 , ":: %name%" ) ) {
819: ftok@var2755 =@expr1073748897 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
820: while (@expr1073748900 Token ::@expr6863 Match (@expr1073748902 ftok@var2755 , "%name% ::" ) ) {
821: ftok@var2755 =@expr1073748903 ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) ; }
822:
823:
824: if (@expr1073748906 Token ::@expr6863 Match (@expr1073748908 ftok@var2755 , "::| memset ( this ," ) ) {
825: assignAllVar (@expr6884 usage@var2752 ) ;
826: return ;
827: }
828:
829:
830: else { if (@expr1073748910 Token ::@expr6863 Match (@expr1073748912 ftok@var2755 , "::| memset ( &| this . %name%" ) ) {
831: if (@expr7089 ftok@var2755 .@expr6871 str (@expr6872 ) ==@expr7092 "::" ) {
832: ftok@var2755 =@expr1073748917 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
833: int offsetToMember@var2763 ; offsetToMember@var2763 =@expr1073748920 4 ;
834: if (@expr1073748921 ftok@var2755 .@expr1073748922 strAt (@expr1073748923 2 ) ==@expr1073748924 "&" ) {
835: ++@expr1073748925 offsetToMember@var2763 ; }
836: assignVar (@expr1073748926 usage@var2752 , ftok@var2755 .@expr7022 tokAt (@expr1073748928 offsetToMember@var2763 ) .@expr1073748929 varId (@expr1073748930 ) ) ;
837: ftok@var2755 =@expr1073748931 ftok@var2755 .@expr6868 linkAt (@expr6869 1 ) ;
838: continue ;
839: }
840:
841:
842: else { if (@expr1073748934 Token ::@expr6863 Match (@expr1073748936 ftok@var2755 , "::| memset ( %name% ," ) ) {
843: if (@expr7089 ftok@var2755 .@expr6871 str (@expr6872 ) ==@expr7092 "::" ) {
844: ftok@var2755 =@expr1073748941 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
845: assignVar (@expr1073748944 usage@var2752 , ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) .@expr1073748947 varId (@expr1073748948 ) ) ;
846: ftok@var2755 =@expr1073748949 ftok@var2755 .@expr6868 linkAt (@expr6869 1 ) ;
847: continue ;
848: }
849:
850:
851: else { if (@expr1073748952 Token ::@expr6962 simpleMatch (@expr1073748954 ftok@var2755 , "operator= (" ) ) {
852: if (@expr1073748955 ftok@var2755 .@expr6880 function (@expr6881 ) ) {
853: const Function * member@var2764 ; member@var2764 =@expr1073748958 ftok@var2755 .@expr6880 function (@expr6881 ) ;
854:
855:
856: if (@expr1073748961 std ::@expr6886 find (@expr1073748963 callstack@var2750 .@expr6888 begin (@expr6889 ) , callstack@var2750 .@expr6890 end (@expr6891 ) , member@var2764 ) !=@expr1073748968 callstack@var2750 .@expr6890 end (@expr6891 ) ) {
857:
858: assignAllVar (@expr6884 usage@var2752 ) ;
859: return ;
860: }
861:
862:
863: if (@expr1073748972 member@var2764 .@expr1073748973 hasBody (@expr1073748974 ) ) {
864:
865: callstack@var2750 .@expr6899 push_back (@expr1073748976 member@var2764 ) ;
866: initializeVarList (@expr1073748977 *@expr1073748978 member@var2764 , callstack@var2750 , scope@var2751 , usage@var2752 ) ;
867: callstack@var2750 .@expr6903 pop_back (@expr6904 ) ;
868: }
869:
870:
871: else {
872: assignAllVar (@expr6884 usage@var2752 ) ;
873: }
874: }
875:
876:
877: else {
878: assignAllVar (@expr6884 usage@var2752 ) ;
879: }
880: } else { if (@expr1073748983 Token ::@expr6863 Match (@expr1073748985 ftok@var2755 , "::| %name% (" ) &&@expr1073748986 !@expr1073748987 Token ::@expr6863 Match (@expr1073748989 ftok@var2755 , "if|while|for" ) ) {
881: if (@expr7089 ftok@var2755 .@expr6871 str (@expr6872 ) ==@expr7092 "::" ) {
882: ftok@var2755 =@expr1073748994 ftok@var2755 .@expr6857 next (@expr6858 ) ; }
883:
884:
885: for (@expr1073748997 const Token *@expr7174 tok2@var2765 =@expr1073748999 ftok@var2755 .@expr6857 next (@expr6858 ) .@expr7178 link (@expr7179 ) ; tok2@var2765 &&@expr1073749004 tok2@var2765 !=@expr1073749005 ftok@var2755 ; tok2@var2765 =@expr1073749006 tok2@var2765 .@expr1073749007 previous (@expr1073749008 ) ) {
886: if (@expr1073749009 tok2@var2765 .@expr1073749010 str (@expr1073749011 ) ==@expr1073749012 "this" ) {
887: assignAllVar (@expr6884 usage@var2752 ) ;
888: return ;
889: }
890: }
891:
892:
893: if (@expr1073749014 ftok@var2755 .@expr6880 function (@expr6881 ) &&@expr1073749017 ftok@var2755 .@expr6880 function (@expr6881 ) .@expr1073749020 nestedIn@var3468 ==@expr1073749021 scope@var2751 &&@expr1073749022
894: !@expr1073749023 ftok@var2755 .@expr6880 function (@expr6881 ) .@expr1073749026 isConstructor (@expr1073749027 ) ) {
895: const Function * member@var2766 ; member@var2766 =@expr1073749028 ftok@var2755 .@expr6880 function (@expr6881 ) ;
896:
897:
898:
899: if (@expr1073749031 std ::@expr6886 find (@expr1073749033 callstack@var2750 .@expr6888 begin (@expr6889 ) , callstack@var2750 .@expr6890 end (@expr6891 ) , member@var2766 ) !=@expr1073749038 callstack@var2750 .@expr6890 end (@expr6891 ) ) {
900: assignAllVar (@expr6884 usage@var2752 ) ;
901: return ;
902: }
903:
904:
905: if (@expr1073749042 member@var2766 .@expr1073749043 hasBody (@expr1073749044 ) ) {
906:
907: callstack@var2750 .@expr6899 push_back (@expr1073749046 member@var2766 ) ;
908: initializeVarList (@expr1073749047 *@expr1073749048 member@var2766 , callstack@var2750 , scope@var2751 , usage@var2752 ) ;
909: callstack@var2750 .@expr6903 pop_back (@expr6904 ) ;
910:
911:
912: for (@expr1073749051 const Token *@expr7174 tok2@var2767 =@expr1073749053 ftok@var2755 ; tok2@var2767 ; tok2@var2767 =@expr1073749054 tok2@var2767 .@expr7231 next (@expr7232 ) ) {
913: if (@expr1073749057 Token ::@expr6863 Match (@expr1073749059 tok2@var2767 , "[;{}]" ) ) {
914: break ; }
915: if (@expr1073749060 Token ::@expr6863 Match (@expr1073749062 tok2@var2767 , "[(,] &| %name% [,)]" ) ) {
916: tok2@var2767 =@expr1073749063 tok2@var2767 .@expr7231 next (@expr7232 ) ;
917: if (@expr1073749066 tok2@var2767 .@expr1073749067 str (@expr1073749068 ) ==@expr1073749069 "&" ) {
918: tok2@var2767 =@expr1073749070 tok2@var2767 .@expr7231 next (@expr7232 ) ; }
919: assignVar (@expr1073749073 usage@var2752 , tok2@var2767 .@expr1073749074 varId (@expr1073749075 ) ) ;
920: }
921: }
922: }
923:
924:
925: else {
926: assignAllVar (@expr6884 usage@var2752 ) ;
927: }
928: }
929:
930:
931: else {
932:
933: if (@expr1073749077 !@expr1073749078 func@var2749 .@expr6842 isConstructor (@expr6843 ) &&@expr1073749081 isBaseClassFunc (@expr1073749082 ftok@var2755 , scope@var2751 ) ) {
934:
935:
936:
937: assignAllVar (@expr6884 usage@var2752 ) ;
938: }
939:
940:
941: if (@expr1073749084 !@expr1073749085 scope@var2751 .@expr1073749086 definedType@var2768 .@expr1073749087 friendList@var2769 .@expr1073749088 empty (@expr1073749089 ) ) {
942: assignAllVar (@expr6884 usage@var2752 ) ; }
943:
944:
945:
946: else {
947: for (@expr1073749091 const Token *@expr7174 tok@var2770 =@expr1073749093 ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) ; tok@var2770 &&@expr1073749096 tok@var2770 !=@expr1073749097 ftok@var2755 .@expr6857 next (@expr6858 ) .@expr7178 link (@expr7179 ) ; tok@var2770 =@expr1073749102 tok@var2770 .@expr1073749103 next (@expr1073749104 ) ) {
948: if (@expr1073749105 tok@var2770 .@expr1073749106 isName (@expr1073749107 ) ) {
949: assignVar (@expr1073749108 usage@var2752 , tok@var2770 .@expr1073749109 varId (@expr1073749110 ) ) ;
950: }
951: }
952: }
953: }
954: }
955:
956:
957: else { if (@expr1073749111 Token ::@expr6863 Match (@expr6910 ftok@var2755 , "%name% =" ) ) {
958: assignVar (@expr6911 usage@var2752 , ftok@var2755 .@expr6877 varId (@expr6878 ) ) ;
959: bool bailout@var2771 ; bailout@var2771 =@expr1073749117 ftok@var2755 .@expr7294 variable (@expr7295 ) &&@expr1073749120 ftok@var2755 .@expr7294 variable (@expr7295 ) .@expr1073749123 isReference (@expr1073749124 ) ;
960: const Token * tok2@var2772 ; tok2@var2772 =@expr1073749125 ftok@var2755 .@expr7022 tokAt (@expr7023 2 ) ;
961: if (@expr1073749128 tok2@var2772 .@expr1073749129 str (@expr1073749130 ) ==@expr1073749131 "&" ) {
962: tok2@var2772 =@expr1073749132 tok2@var2772 .@expr1073749133 next (@expr1073749134 ) ;
963: bailout@var2771 =@expr1073749135 true ;
964: }
965: if (@expr1073749136 tok2@var2772 .@expr7313 variable (@expr7314 ) &&@expr1073749139 (@expr1073749140 bailout@var2771 ||@expr1073749141 tok2@var2772 .@expr7313 variable (@expr7314 ) .@expr1073749144 isArray (@expr1073749145 ) ) &&@expr1073749146 tok2@var2772 .@expr1073749147 strAt (@expr1073749148 1 ) !=@expr1073749149 "[" ) {
966: assignVar (@expr1073749150 usage@var2752 , tok2@var2772 .@expr1073749151 varId (@expr1073749152 ) ) ; }
967: }
968:
969:
970: else { if (@expr1073749153 Token ::@expr6863 Match (@expr1073749155 ftok@var2755 , "%name% [|." ) ) {
971: const Token * tok2@var2773 ; tok2@var2773 =@expr1073749156 ftok@var2755 ;
972: while (@expr1073749157 tok2@var2773 ) {
973: if (@expr1073749158 tok2@var2773 .@expr7335 strAt (@expr7336 1 ) ==@expr1073749161 "[" ) {
974: tok2@var2773 =@expr1073749162 tok2@var2773 .@expr7339 next (@expr7340 ) .@expr1073749165 link (@expr1073749166 ) ; }
975: else { if (@expr1073749167 Token ::@expr6863 Match (@expr1073749169 tok2@var2773 .@expr7339 next (@expr7340 ) , ". %name%" ) ) {
976: tok2@var2773 =@expr1073749172 tok2@var2773 .@expr1073749173 tokAt (@expr1073749174 2 ) ; }
977: else {
978: break ; } }
979: }
980: if (@expr1073749175 tok2@var2773 &&@expr1073749176 tok2@var2773 .@expr7335 strAt (@expr7336 1 ) ==@expr1073749179 "=" ) {
981: assignVar (@expr6911 usage@var2752 , ftok@var2755 .@expr6877 varId (@expr6878 ) ) ; }
982: }
983:
984:
985: else { if (@expr1073749183 Token ::@expr6863 Match (@expr1073749185 ftok@var2755 , "* %name% =" ) ) {
986: assignVar (@expr6953 usage@var2752 , ftok@var2755 .@expr6857 next (@expr6858 ) .@expr6956 varId (@expr6957 ) ) ;
987: } else { if (@expr1073749191 Token ::@expr6863 Match (@expr1073749193 ftok@var2755 , "* this . %name% =" ) ) {
988: assignVar (@expr1073749194 usage@var2752 , ftok@var2755 .@expr7022 tokAt (@expr1073749196 3 ) .@expr1073749197 varId (@expr1073749198 ) ) ;
989: } } } } } } } } }
990:
991:
992: if (@expr1073749199 Token ::@expr6863 Match (@expr1073749201 ftok@var2755 , "%name% . clear|Clear (" ) ) {
993: assignVar (@expr6911 usage@var2752 , ftok@var2755 .@expr6877 varId (@expr6878 ) ) ;
994: }
995: }
996: }
997:
998: void CheckClass :: noConstructorError ( const Token * tok@var2774 , const std :: string & classname@var2775 , bool isStruct@var2776 )
999: {
1000:
1001: reportError (@expr1073749205 tok@var2774 , Severity ::@expr1073749206 style , "noConstructor" ,
1002: "$symbol:" +@expr1073749207 classname@var2775 +@expr1073749208 "\n" +@expr1073749209
1003: "The " +@expr1073749210 std ::@expr7387 string (@expr7388 isStruct@var2776 ?@expr7389 "struct" :@expr7390 "class" ) +@expr1073749215 " '$symbol' does not declare a constructor although it has private member variables which likely require initialization.\nThe "
1004: +@expr1073749216 std ::@expr7387 string (@expr7388 isStruct@var2776 ?@expr7389 "struct" :@expr7390 "class" ) +@expr1073749221 " '$symbol' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior."
1005:
1006: , CWE398@var2537 , Certainty ::@expr1073749222 normal ) ;
1007: }
1008:
1009: void CheckClass :: noExplicitConstructorError ( const Token * tok@var2777 , const std :: string & classname@var2778 , bool isStruct@var2779 )
1010: {
1011: const std ::@expr1073749223 string message@var2780 (@expr1073749224 std ::@expr1073749225 string (@expr1073749226 isStruct@var2779 ?@expr1073749227 "Struct" :@expr1073749228 "Class" ) +@expr1073749229 " '$symbol' has a constructor with 1 argument that is not explicit." ) ;
1012: const std ::@expr1073749230 string verbose@var2781 (@expr1073749231 message@var2780 +@expr1073749232 " Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided." ) ;
1013: reportError (@expr1073749233 tok@var2777 , Severity ::@expr1073749234 style , "noExplicitConstructor" , "$symbol:" +@expr1073749235 classname@var2778 +@expr1073749236 '\n' +@expr1073749237 message@var2780 +@expr1073749238 '\n' +@expr1073749239 verbose@var2781 , CWE398@var2537 , Certainty ::@expr1073749240 normal ) ;
1014: }
1015:
1016: void CheckClass :: uninitVarError ( const Token * tok@var2782 , bool isprivate@var2783 , Function :: Type functionType@var2784 , const std :: string & classname@var2785 , const std :: string & varname@var2786 , bool derived@var2787 , bool inconclusive@var2788 )
1017: {
1018: std ::@expr1073749241 string ctor@var2789 ;
1019: if (@expr1073749242 functionType@var2784 ==@expr1073749243 Function ::@expr1073749244 eCopyConstructor ) {
1020: ctor@var2789 =@expr1073749245 "copy " ; }
1021: else { if (@expr1073749246 functionType@var2784 ==@expr1073749247 Function ::@expr1073749248 eMoveConstructor ) {
1022: ctor@var2789 =@expr1073749249 "move " ; } }
1023: std ::@expr1073749250 string message@var2790 (@expr1073749251 "Member variable '$symbol' is not initialized in the " +@expr1073749252 ctor@var2789 +@expr1073749253 "constructor." ) ;
1024: if (@expr1073749254 derived@var2787 ) {
1025: message@var2790 +=@expr1073749255 " Maybe it should be initialized directly in the class " +@expr1073749256 classname@var2785 +@expr1073749257 "?" ; }
1026: std ::@expr1073749258 string id@var2791 ; id@var2791 =@expr1073749259 std ::@expr1073749260 string (@expr1073749261 "uninit" ) +@expr1073749262 (@expr1073749263 derived@var2787 ?@expr1073749264 "Derived" :@expr1073749265 "" ) +@expr1073749266 "MemberVar" +@expr1073749267 (@expr1073749268 isprivate@var2783 ?@expr1073749269 "Private" :@expr1073749270 "" ) ;
1027: reportError (@expr1073749271 tok@var2782 , Severity ::@expr1073749272 warning , id@var2791 , "$symbol:" +@expr1073749273 classname@var2785 +@expr1073749274 "::" +@expr1073749275 varname@var2786 +@expr1073749276 "\n" +@expr1073749277 message@var2790 , CWE398@var2537 , inconclusive@var2788 ?@expr1073749278 Certainty ::@expr1073749279 inconclusive :@expr1073749280 Certainty ::@expr1073749281 normal ) ;
1028: }
1029:
1030: void CheckClass :: uninitVarError ( const Token * tok@var2792 , const std :: string & classname@var2793 , const std :: string & varname@var2794 )
1031: {
1032: const std ::@expr1073749282 string message@var2795 (@expr1073749283 "Member variable '$symbol' is not initialized." ) ;
1033: const std ::@expr1073749284 string id@var2796 =@expr1073749285 std ::@expr1073749286 string (@expr1073749287 "uninitMemberVarPrivate" ) ;
1034: reportError (@expr1073749288 tok@var2792 , Severity ::@expr1073749289 warning , id@var2796 , "$symbol:" +@expr1073749290 classname@var2793 +@expr1073749291 "::" +@expr1073749292 varname@var2794 +@expr1073749293 "\n" +@expr1073749294 message@var2795 , CWE398@var2537 , Certainty ::@expr1073749295 normal ) ;
1035: }
1036:
1037: void CheckClass :: missingMemberCopyError ( const Token * tok@var2797 , Function :: Type functionType@var2798 , const std :: string & classname@var2799 , const std :: string & varname@var2800 )
1038: {
1039: const std ::@expr1073749297 string ctor@var2801 (@expr1073749298 functionType@var2798 ==@expr7475 Function ::@expr7476 Type ::@expr7477 eCopyConstructor ?@expr1073749302 "copy" :@expr1073749303 "move" ) ;
1040: const std ::@expr1073749304 string action@var2802 (@expr1073749305 functionType@var2798 ==@expr7475 Function ::@expr7476 Type ::@expr7477 eCopyConstructor ?@expr1073749309 "copied?" :@expr1073749310 "moved?" ) ;
1041: const std ::@expr1073749311 string message@var2803 =@expr1073749312
1042: "$symbol:" +@expr1073749313 classname@var2799 +@expr1073749314 "::" +@expr1073749315 varname@var2800 +@expr1073749316 "\n" +@expr1073749317
1043: "Member variable '$symbol' is not assigned in the " +@expr1073749318 ctor@var2801 +@expr1073749319 " constructor. Should it be " +@expr1073749320 action@var2802 ;
1044: const char id@var2804 [@expr1073749321 18 ] =@expr1073749322 "missingMemberCopy" ;
1045: reportError (@expr1073749323 tok@var2797 , Severity ::@expr1073749324 warning , id@var2804 , message@var2803 , CWE398@var2537 , Certainty ::@expr1073749325 inconclusive@expr1073749296 ) ;
1046: }
1047:
1048: void CheckClass :: operatorEqVarError ( const Token * tok@var2805 , const std :: string & classname@var2806 , const std :: string & varname@var2807 , bool inconclusive@var2808 )
1049: {
1050: reportError (@expr1073749326 tok@var2805 , Severity ::@expr1073749327 warning , "operatorEqVarError" , "$symbol:" +@expr1073749328 classname@var2806 +@expr1073749329 "::" +@expr1073749330 varname@var2807 +@expr1073749331 "\nMember variable '$symbol' is not assigned a value in '" +@expr1073749332 classname@var2806 +@expr1073749333 "::operator='." , CWE398@var2537 , inconclusive@var2808 ?@expr1073749334 Certainty ::@expr1073749335 inconclusive :@expr1073749336 Certainty ::@expr1073749337 normal ) ;
1051: }
1052:
|
1056:
1057: void CheckClass :: initializationListUsage ( )
1058: {
1059: if (@expr1073749338 !@expr1073749339 mSettings@var29 .@expr1073749340 severity@var3441 .@expr1073749341 isEnabled (@expr1073749342 Severity ::@expr1073749343 performance ) ) {
1060: return ; }
1061:
1062: for (@expr1073749344 const Scope *@expr7521 scope@var2809 :@expr1073749346 mSymbolDatabase@var1666 .@expr1073749347 functionScopes@var3448 ) {
1063:
1064: if (@expr1073749348 !@expr1073749349 scope@var2809 .@expr7526 function@var2810 ||@expr1073749351 !@expr1073749352 scope@var2809 .@expr7526 function@var2810 .@expr1073749354 isConstructor (@expr1073749355 ) ) {
1065: continue ; }
1066:
1067:
1068: if (@expr1073749356 const Token *@expr7521 initList@var2811 =@expr1073749358 scope@var2809 .@expr7526 function@var2810 .@expr1073749360 constructorMemberInitialization (@expr1073749361 ) ) {
1069: if (@expr1073749362 Token ::@expr7539 Match (@expr1073749364 initList@var2811 , ": %name% {|(" ) &&@expr1073749365 initList@var2811 .@expr1073749366 strAt (@expr1073749367 1 ) ==@expr1073749368 scope@var2809 .@expr1073749369 className@var2812 ) {
1070: continue ; }
1071: }
1072:
1073: const Scope * owner@var2813 ; owner@var2813 =@expr1073749370 scope@var2809 .@expr1073749371 functionOf@var2814 ;
1074: for (@expr1073749372 const Token *@expr7521 tok@var2815 =@expr1073749374 scope@var2809 .@expr1073749375 bodyStart@var2816 ; tok@var2815 !=@expr1073749376 scope@var2809 .@expr1073749377 bodyEnd@var2817 ; tok@var2815 =@expr1073749378 tok@var2815 .@expr7555 next (@expr7556 ) ) {
1075: if (@expr1073749381 Token ::@expr7539 Match (@expr1073749383 tok@var2815 , "%name% (" ) ) {
1076: break ; }
1077: if (@expr1073749384 Token ::@expr7539 Match (@expr1073749386 tok@var2815 , "try|do {" ) ) {
1078: break ; }
1079: if (@expr1073749387 !@expr1073749388 Token ::@expr7539 Match (@expr1073749390 tok@var2815 , "%var% =" ) ||@expr1073749391 tok@var2815 .@expr7568 strAt (@expr7569 -1 ) ==@expr1073749394 "*" ||@expr1073749395 tok@var2815 .@expr7568 strAt (@expr7569 -1 ) ==@expr1073749398 "." ) {
1080: continue ; }
1081:
1082: const Variable * var@var2818 ; var@var2818 =@expr1073749399 tok@var2815 .@expr1073749400 variable (@expr1073749401 ) ;
1083: if (@expr1073749402 !@expr1073749403 var@var2818 ||@expr1073749404 var@var2818 .@expr1073749405 scope (@expr1073749406 ) !=@expr1073749407 owner@var2813 ||@expr1073749408 var@var2818 .@expr1073749409 isStatic (@expr1073749410 ) ) {
1084: continue ; }
1085: if (@expr1073749411 var@var2818 .@expr1073749412 isPointer (@expr1073749413 ) ||@expr1073749414 var@var2818 .@expr1073749415 isReference (@expr1073749416 ) ||@expr1073749417 var@var2818 .@expr1073749418 isEnumType (@expr1073749419 ) ) {
1086: continue ; }
1087: if (@expr1073749420 !@expr1073749421 $(@expr1073749422 $(@expr1073749423 !@expr1073749424 var@var2818 .@expr7601 valueType (@expr7602 ) $) $&&@expr1073749427 $wrongData $(@expr1073749428 tok@var2815 $, "!var->valueType()" $) $) &&@expr1073749429 var@var2818 .@expr7601 valueType (@expr7602 ) .@expr1073749432 type@var3462 >@expr1073749433 ValueType ::@expr1073749434 Type ::@expr1073749435 ITERATOR ) {
1088: continue ; }
1089:
1090:
1091: if (@expr1073749436 findLambdaEndToken (@expr1073749437 tok@var2815 .@expr7614 tokAt (@expr7615 2 ) ) &&@expr1073749440 tok@var2815 .@expr7614 tokAt (@expr7615 2 ) .@expr1073749443 findExpressionStartEndTokens (@expr1073749444 ) .@expr1073749445 second .@expr1073749446 linenr (@expr1073749447 ) >@expr1073749448 tok@var2815 .@expr7614 tokAt (@expr7615 2 ) .@expr1073749451 linenr (@expr1073749452 ) ) {
1092: continue ; }
1093:
1094:
1095: bool localmember@var2819 ; localmember@var2819 =@expr1073749453 false ;
1096: visitAstNodes (@expr1073749454 tok@var2815 .@expr7555 next (@expr7556 ) .@expr7633 astOperand2 (@expr7634 ) ,
1097: [@expr1073749459 &@expr7636 ] (@expr1073749461 const Token *@expr7521 rhs@var2820 ) {
1098: if (@expr1073749463 rhs@var2820 .@expr1073749464 str (@expr1073749465 ) ==@expr1073749466 "." &&@expr1073749467 rhs@var2820 .@expr7644 astOperand1 (@expr7645 ) &&@expr1073749470 rhs@var2820 .@expr7644 astOperand1 (@expr7645 ) .@expr7649 variable (@expr7650 ) &&@expr1073749475 rhs@var2820 .@expr7644 astOperand1 (@expr7645 ) .@expr7649 variable (@expr7650 ) .@expr1073749480 isLocal (@expr1073749481 ) ) {
1099: localmember@var2819 =@expr1073749482 true ; }
1100: return ChildrenToVisit ::@expr7659 op1_and_op2 ;
1101: } ) ;
1102: if (@expr1073749484 localmember@var2819 ) {
1103: continue ; }
1104:
1105: bool allowed@var2821 ; allowed@var2821 =@expr1073749485 true ;
1106: visitAstNodes (@expr1073749486 tok@var2815 .@expr7555 next (@expr7556 ) .@expr7633 astOperand2 (@expr7634 ) ,
1107: [@expr1073749491 &@expr7636 ] (@expr1073749493 const Token *@expr7521 tok2@var2822 ) {
1108: const Variable * var2@var2823 ; var2@var2823 =@expr1073749495 tok2@var2822 .@expr1073749496 variable (@expr1073749497 ) ;
1109: if (@expr1073749498 var2@var2823 ) {
1110: if (@expr1073749499 var2@var2823 .@expr1073749500 scope (@expr1073749501 ) ==@expr1073749502 owner@var2813 &&@expr1073749503 tok2@var2822 .@expr7680 strAt (@expr7681 -1 ) !=@expr7682 "." ) {
1111: allowed@var2821 =@expr1073749507 false ;
1112: return ChildrenToVisit ::@expr7684 done ;
1113: } else { if (@expr1073749509 var2@var2823 .@expr1073749510 isArray (@expr1073749511 ) &&@expr1073749512 var2@var2823 .@expr1073749513 isLocal (@expr1073749514 ) ) {
1114: allowed@var2821 =@expr1073749515 false ;
1115: return ChildrenToVisit ::@expr7684 done ;
1116: } }
1117: } else { if (@expr1073749517 tok2@var2822 .@expr1073749518 str (@expr1073749519 ) ==@expr1073749520 "this" ) {
1118: allowed@var2821 =@expr1073749521 false ;
1119: return ChildrenToVisit ::@expr7684 done ;
1120: } else { if (@expr1073749523 Token ::@expr7539 Match (@expr1073749525 tok2@var2822 , "%name% (" ) &&@expr1073749526 tok2@var2822 .@expr7680 strAt (@expr7681 -1 ) !=@expr7682 "." &&@expr1073749530 isMemberFunc (@expr1073749531 owner@var2813 , tok2@var2822 ) ) {
1121: allowed@var2821 =@expr1073749532 false ;
1122: return ChildrenToVisit ::@expr7684 done ;
1123: } } }
1124: return ChildrenToVisit ::@expr7659 op1_and_op2 ;
1125: } ) ;
1126: if (@expr1073749535 !@expr1073749536 allowed@var2821 ) {
1127: continue ; }
1128:
1129: suggestInitializationList (@expr1073749537 tok@var2815 , tok@var2815 .@expr1073749538 str (@expr1073749539 ) ) ;
1130: }
1131: }
1132: }
1133:
1134: void CheckClass :: suggestInitializationList ( const Token * tok@var2824 , const std :: string & varname@var2825 )
1135: {
1136: reportError (@expr1073749540 tok@var2824 , Severity ::@expr1073749541 performance , "useInitializationList" , "$symbol:" +@expr1073749542 varname@var2825 +@expr1073749543 "\nVariable '$symbol' is assigned in constructor body. Consider performing initialization in initialization list.\nWhen an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '$symbol' a value by passing the value to the constructor in the initialization list."
1137:
1138:
1139: , CWE398@var2537 , Certainty ::@expr1073749544 normal ) ;
1140: }
1141:
|
1145:
1146: static bool checkFunctionUsage ( const Function * privfunc@var2826 , const Scope * scope@var2827 )
1147: {
1148: if (@expr1073749545 !@expr1073749546 scope@var2827 ) {
1149: return true ; }
1150:
1151: for (@expr1073749547 std ::@expr7724 list < Function > ::@expr7724 const_iterator func@var2828 =@expr1073749550 scope@var2827 .@expr7727 functionList@var2829 .@expr1073749552 begin (@expr1073749553 ) ; func@var2828 !=@expr1073749554 scope@var2827 .@expr7727 functionList@var2829 .@expr1073749556 end (@expr1073749557 ) ; ++@expr1073749558 func@var2828 ) {
1152: if (@expr1073749559 func@var2828 .@expr7736 functionScope@var2830 ) {
1153: if (@expr1073749561 Token ::@expr7738 Match (@expr1073749563 func@var2828 .@expr7740 tokenDef@var2831 , "%name% (" ) ) {
1154: for (@expr1073749565 const Token *@expr7742 ftok@var2832 =@expr1073749567 func@var2828 .@expr7740 tokenDef@var2831 .@expr1073749569 tokAt (@expr1073749570 2 ) ; ftok@var2832 &&@expr1073749571 ftok@var2832 .@expr7748 str (@expr7749 ) !=@expr1073749574 ")" ; ftok@var2832 =@expr1073749575 ftok@var2832 .@expr1073749576 next (@expr1073749577 ) ) {
1155: if (@expr1073749578 Token ::@expr7738 Match (@expr1073749580 ftok@var2832 , "= %name% [(,)]" ) &&@expr1073749581 ftok@var2832 .@expr1073749582 strAt (@expr1073749583 1 ) ==@expr1073749584 privfunc@var2826 .@expr7761 name (@expr7762 ) ) {
1156: return true ; }
1157: if (@expr1073749587 ftok@var2832 .@expr7748 str (@expr7749 ) ==@expr1073749590 "(" ) {
1158: ftok@var2832 =@expr1073749591 ftok@var2832 .@expr1073749592 link (@expr1073749593 ) ; }
1159: }
1160: }
1161: for (@expr1073749594 const Token *@expr7742 ftok@var2833 =@expr1073749596 func@var2828 .@expr7736 functionScope@var2830 .@expr1073749598 classDef@var2834 .@expr1073749599 linkAt (@expr1073749600 1 ) ; ftok@var2833 !=@expr1073749601 func@var2828 .@expr7736 functionScope@var2830 .@expr1073749603 bodyEnd@var2835 ; ftok@var2833 =@expr1073749604 ftok@var2833 .@expr1073749605 next (@expr1073749606 ) ) {
1162: if (@expr1073749607 ftok@var2833 .@expr1073749608 function (@expr1073749609 ) ==@expr1073749610 privfunc@var2826 ) {
1163: return true ; }
1164: if (@expr1073749611 ftok@var2833 .@expr1073749612 varId (@expr1073749613 ) ==@expr1073749614 0U &&@expr1073749615 ftok@var2833 .@expr1073749616 str (@expr1073749617 ) ==@expr1073749618 privfunc@var2826 .@expr7761 name (@expr7762 ) ) {
1165: return true ; }
1166: }
1167: } else { if (@expr1073749621 (@expr1073749622 func@var2828 .@expr7799 type@var2836 !=@expr1073749624 Function ::@expr1073749625 eCopyConstructor &&@expr1073749626
1168: func@var2828 .@expr7799 type@var2836 !=@expr1073749628 Function ::@expr1073749629 eOperatorEqual ) ||@expr1073749630
1169: func@var2828 .@expr1073749631 access@var2837 !=@expr1073749632 AccessControl ::@expr1073749633 Private ) {
1170: return true ; } }
1171: }
1172:
1173: const std ::@expr1073749634 map < std ::@expr7724 string , Type *@expr7742 > ::@expr1073749637 const_iterator end@var2838 =@expr1073749638 scope@var2827 .@expr7815 definedTypesMap@var2839 .@expr1073749640 end (@expr1073749641 ) ;
1174: for (@expr1073749642 std ::@expr7724 map < std ::@expr7724 string , Type *@expr7742 > ::@expr7724 const_iterator iter@var2840 =@expr1073749647 scope@var2827 .@expr7815 definedTypesMap@var2839 .@expr1073749649 begin (@expr1073749650 ) ; iter@var2840 !=@expr1073749651 end@var2838 ; ++@expr1073749652 iter@var2840 ) {
1175: const Type * type@var2841 ; type@var2841 =@expr1073749653 (@expr1073749654 *@expr1073749655 iter@var2840 ) .@expr1073749656 second@var2842 ;
1176: if (@expr1073749657 type@var2841 .@expr1073749658 enclosingScope@var2843 ==@expr1073749659 scope@var2827 &&@expr1073749660 checkFunctionUsage (@expr1073749661 privfunc@var2826 , type@var2841 .@expr1073749662 classScope@var2844 ) ) {
1177: return true ; }
1178: }
1179:
1180: for (@expr1073749663 const Variable &@expr1073749664 var@var2845 :@expr1073749665 scope@var2827 .@expr1073749666 varlist@var2846 ) {
1181: if (@expr1073749667 var@var2845 .@expr1073749668 isStatic (@expr1073749669 ) ) {
1182: const Token * tok@var2847 ; tok@var2847 =@expr1073749670 Token ::@expr1073749671 findmatch (@expr1073749672 scope@var2827 .@expr1073749673 bodyStart@var2848 , "%varid% =|(|{" , var@var2845 .@expr1073749674 declarationId (@expr1073749675 ) ) ;
1183: if (@expr1073749676 tok@var2847 ) {
1184: tok@var2847 =@expr1073749677 tok@var2847 .@expr1073749678 tokAt (@expr1073749679 2 ) ; }
1185: while (@expr1073749680 tok@var2847 &&@expr1073749681 tok@var2847 .@expr1073749682 str (@expr1073749683 ) !=@expr1073749684 ";" ) {
1186: if (@expr1073749685 tok@var2847 .@expr1073749686 function (@expr1073749687 ) ==@expr1073749688 privfunc@var2826 ) {
1187: return true ; }
1188: tok@var2847 =@expr1073749689 tok@var2847 .@expr1073749690 next (@expr1073749691 ) ;
1189: }
1190: }
1191: }
1192:
1193: return false ;
1194: }
1195:
1196: void CheckClass :: privateFunctions ( )
1197: {
1198: if (@expr1073749693 !@expr1073749694 mSettings@var29 .@expr1073749695 severity@var3441 .@expr1073749696 isEnabled (@expr1073749697 Severity ::@expr1073749698 style ) ) {
1199: return ; }
1200:
1201: for (@expr1073749699 const Scope *@expr7876 scope@var2849 :@expr1073749701 mSymbolDatabase@var1666 .@expr1073749702 classAndStructScopes@var3443 ) {
1202:
1203:
1204: if (@expr1073749703 Token ::@expr1073749704 findsimplematch (@expr1073749705 scope@var2849 .@expr1073749706 bodyStart@var2850 , "; __property ;" , scope@var2849 .@expr1073749707 bodyEnd@var2851 ) ) {
1205: continue ; }
1206:
1207: std ::@expr1073749708 list < const Function *@expr7876 > privateFuncs@var2852 ;
1208: for (@expr1073749710 const Function &@expr1073749711 func@var2853 :@expr1073749712 scope@var2849 .@expr1073749713 functionList@var2854 ) {
1209:
1210: if (@expr1073749714 func@var2853 .@expr1073749715 type@var2855 ==@expr1073749716 Function ::@expr1073749717 eFunction &&@expr1073749718 func@var2853 .@expr1073749719 access@var2856 ==@expr1073749720 AccessControl ::@expr1073749721 Private &&@expr1073749722 !@expr1073749723 func@var2853 .@expr1073749724 isOperator (@expr1073749725 ) ) {
1211: privateFuncs@var2852 .@expr1073749726 push_back (@expr1073749727 &@expr1073749728 func@var2853 ) ; }
1212: }
1213:
1214:
1215: if (@expr1073749729 !@expr1073749730 scope@var2849 .@expr7907 definedType@var2857 .@expr1073749732 derivedFrom@var2858 .@expr1073749733 empty (@expr1073749734 ) ) {
1216:
1217: for (@expr1073749735 std ::@expr7912 list < const Function *@expr7876 > ::@expr7912 iterator it@var2859 =@expr1073749739 privateFuncs@var2852 .@expr1073749740 begin (@expr1073749741 ) ; it@var2859 !=@expr1073749742 privateFuncs@var2852 .@expr1073749743 end (@expr1073749744 ) ; ) {
1218: if (@expr1073749745 (@expr1073749746 *@expr1073749747 it@var2859 ) .@expr1073749748 isImplicitlyVirtual (@expr1073749749 true ) ) {
1219: privateFuncs@var2852 .@expr1073749750 erase (@expr1073749751 it@var2859 ++@expr1073749752 ) ; }
1220: else {
1221: ++@expr1073749753 it@var2859 ; }
1222: }
1223: }
1224:
1225: while (@expr1073749754 !@expr1073749755 privateFuncs@var2852 .@expr1073749756 empty (@expr1073749757 ) ) {
1226:
1227: bool used@var2860 ; used@var2860 =@expr1073749758 checkFunctionUsage (@expr1073749759 privateFuncs@var2852 .@expr7936 front (@expr7937 ) , scope@var2849 ) ;
1228:
1229: const std ::@expr1073749762 vector < Type ::@expr7912 FriendInfo > & friendList@var2861 =@expr1073749764 scope@var2849 .@expr7907 definedType@var2857 .@expr1073749766 friendList@var2862 ;
1230: for (@expr1073749767 int i@var2863 =@expr1073749768 0 ; i@var2863 <@expr1073749769 friendList@var2861 .@expr1073749770 size (@expr1073749771 ) &&@expr1073749772 !@expr7949 used@var2860 ; i@var2863 ++@expr1073749774 ) {
1231: if (@expr1073749775 friendList@var2861 [@expr7952 i@var2863 ] .@expr7953 type@var3469 ) {
1232: used@var2860 =@expr1073749778 checkFunctionUsage (@expr1073749779 privateFuncs@var2852 .@expr7936 front (@expr7937 ) , friendList@var2861 [@expr7952 i@var2863 ] .@expr7953 type@var3469 .@expr1073749784 classScope@var3470 ) ; }
1233: else {
1234: used@var2860 =@expr1073749785 true ; }
1235: }
1236:
1237: if (@expr1073749786 !@expr7949 used@var2860 ) {
1238: unusedPrivateFunctionError (@expr1073749788 privateFuncs@var2852 .@expr7936 front (@expr7937 ) .@expr1073749791 tokenDef@expr1073749692 , scope@var2849 .@expr1073749792 className@var2864 , privateFuncs@var2852 .@expr7936 front (@expr7937 ) .@expr1073749795 name (@expr1073749796 ) ) ; }
1239:
1240: privateFuncs@var2852 .@expr1073749797 pop_front (@expr1073749798 ) ;
1241: }
1242: }
1243: }
1244:
1245: void CheckClass :: unusedPrivateFunctionError ( const Token * tok@var2865 , const std :: string & classname@var2866 , const std :: string & funcname@var2867 )
1246: {
1247: reportError (@expr1073749799 tok@var2865 , Severity ::@expr1073749800 style , "unusedPrivateFunction" , "$symbol:" +@expr1073749801 classname@var2866 +@expr1073749802 "::" +@expr1073749803 funcname@var2867 +@expr1073749804 "\nUnused private function: '$symbol'" , CWE398@var2537 , Certainty ::@expr1073749805 normal ) ;
1248: }
1249:
|
1253:
1254: static const Scope * findFunctionOf ( const Scope * scope@var2868 )
1255: {
1256: while (@expr1073749806 scope@var2868 ) {
1257: if (@expr1073749807 scope@var2868 .@expr1073749808 type@var2869 ==@expr1073749809 Scope ::@expr1073749810 eFunction ) {
1258: return scope@var2868 .@expr1073749811 functionOf@var2870 ; }
1259: scope@var2868 =@expr1073749812 scope@var2868 .@expr1073749813 nestedIn@var2871 ;
1260: }
1261: return nullptr ;
1262: }
1263:
1264: void CheckClass :: checkMemset ( )
1265: {
1266: const bool printWarnings@var2872 =@expr1073749814 mSettings@var29 .@expr1073749815 severity@var3441 .@expr1073749816 isEnabled (@expr1073749817 Severity ::@expr1073749818 warning ) ;
1267: for (@expr1073749819 const Scope *@expr7996 scope@var2873 :@expr1073749821 mSymbolDatabase@var1666 .@expr1073749822 functionScopes@var3448 ) {
1268: for (@expr1073749823 const Token *@expr7996 tok@var2874 =@expr1073749825 scope@var2873 .@expr1073749826 bodyStart@var2875 ; tok@var2874 &&@expr1073749827 tok@var2874 !=@expr1073749828 scope@var2873 .@expr1073749829 bodyEnd@var2876 ; tok@var2874 =@expr1073749830 tok@var2874 .@expr1073749831 next (@expr1073749832 ) ) {
1269: if (@expr1073749833 Token ::@expr8010 Match (@expr1073749835 tok@var2874 , "memset|memcpy|memmove (" ) ) {
1270: const Token * arg1@var2877 ; arg1@var2877 =@expr1073749836 tok@var2874 .@expr8013 tokAt (@expr8014 2 ) ;
1271: const Token * arg3@var2878 ; arg3@var2878 =@expr1073749839 arg1@var2877 .@expr1073749840 nextArgument (@expr1073749841 ) ;
1272: if (@expr1073749842 arg3@var2878 ) {
1273: arg3@var2878 =@expr1073749843 arg3@var2878 .@expr1073749844 nextArgument (@expr1073749845 ) ; }
1274: if (@expr1073749846 !@expr1073749847 arg3@var2878 ) {
1275:
1276:
1277: continue ; }
1278:
1279: const Token * typeTok@var2879 ; typeTok@var2879 =@expr1073749848 nullptr ;
1280: const Scope * type@var2880 ; type@var2880 =@expr1073749849 nullptr ;
1281: if (@expr1073749850 Token ::@expr8010 Match (@expr1073749852 arg3@var2878 , "sizeof ( %type% ) )" ) ) {
1282: typeTok@var2879 =@expr1073749853 arg3@var2878 .@expr8030 tokAt (@expr1073749855 2 ) ; }
1283: else { if (@expr1073749856 Token ::@expr8010 Match (@expr1073749858 arg3@var2878 , "sizeof ( %type% :: %type% ) )" ) ) {
1284: typeTok@var2879 =@expr1073749859 arg3@var2878 .@expr8030 tokAt (@expr1073749861 4 ) ; }
1285: else { if (@expr1073749862 Token ::@expr8010 Match (@expr1073749864 arg3@var2878 , "sizeof ( struct %type% ) )" ) ) {
1286: typeTok@var2879 =@expr1073749865 arg3@var2878 .@expr8030 tokAt (@expr1073749867 3 ) ; }
1287: else { if (@expr1073749868 Token ::@expr8045 simpleMatch (@expr1073749870 arg3@var2878 , "sizeof ( * this ) )" ) ||@expr1073749871 Token ::@expr8045 simpleMatch (@expr1073749873 arg1@var2877 , "this ," ) ) {
1288: type@var2880 =@expr1073749874 findFunctionOf (@expr1073749875 arg3@var2878 .@expr1073749876 scope (@expr1073749877 ) ) ;
1289: } else { if (@expr1073749878 Token ::@expr8010 Match (@expr1073749880 arg1@var2877 , "&|*|%var%" ) ) {
1290: int numIndirToVariableType@var2881 ; numIndirToVariableType@var2881 =@expr1073749881 0 ;
1291: for (@expr1073749882 ; ; arg1@var2877 =@expr1073749883 arg1@var2877 .@expr1073749884 next (@expr1073749885 ) ) {
1292: if (@expr1073749886 arg1@var2877 .@expr8063 str (@expr8064 ) ==@expr1073749889 "&" ) {
1293: ++@expr1073749890 numIndirToVariableType@var2881 ; }
1294: else { if (@expr1073749891 arg1@var2877 .@expr8063 str (@expr8064 ) ==@expr1073749894 "*" ) {
1295: --@expr1073749895 numIndirToVariableType@var2881 ; }
1296: else {
1297: break ; } }
1298: }
1299:
1300: const Variable * const var@var2882 ; var@var2882 =@expr1073749896 arg1@var2877 .@expr1073749897 variable (@expr1073749898 ) ;
1301: if (@expr1073749899 var@var2882 &&@expr1073749900 arg1@var2877 .@expr1073749901 strAt (@expr1073749902 1 ) ==@expr1073749903 "," ) {
1302: if (@expr1073749904 var@var2882 .@expr1073749905 isArrayOrPointer (@expr1073749906 ) ) {
1303: const Token * endTok@var2883 ; endTok@var2883 =@expr1073749907 var@var2882 .@expr1073749908 typeEndToken (@expr1073749909 ) ;
1304: while (@expr1073749910 Token ::@expr8045 simpleMatch (@expr1073749912 endTok@var2883 , "*" ) ) {
1305: ++@expr1073749913 numIndirToVariableType@var2881 ;
1306: endTok@var2883 =@expr1073749914 endTok@var2883 .@expr1073749915 previous (@expr1073749916 ) ;
1307: }
1308: }
1309:
1310: if (@expr1073749917 var@var2882 .@expr1073749918 isArray (@expr1073749919 ) ) {
1311: numIndirToVariableType@var2881 +=@expr1073749920 int (@expr1073749921 var@var2882 .@expr1073749922 dimensions (@expr1073749923 ) .@expr1073749924 size (@expr1073749925 ) ) ; }
1312:
1313: if (@expr1073749926 numIndirToVariableType@var2881 ==@expr1073749927 1 ) {
1314: type@var2880 =@expr1073749928 var@var2882 .@expr1073749929 typeScope (@expr1073749930 ) ; }
1315: }
1316: } } } } }
1317:
1318:
1319: if (@expr1073749931 !@expr1073749932 typeTok@var2879 &&@expr1073749933 !@expr8110 type@var2880 ) {
1320: continue ; }
1321:
1322: if (@expr1073749935 typeTok@var2879 &&@expr1073749936 typeTok@var2879 .@expr1073749937 str (@expr1073749938 ) ==@expr1073749939 "(" ) {
1323: typeTok@var2879 =@expr1073749940 typeTok@var2879 .@expr1073749941 next (@expr1073749942 ) ; }
1324:
1325: if (@expr1073749943 !@expr8110 type@var2880 &&@expr1073749945 typeTok@var2879 .@expr8122 type (@expr8123 ) ) {
1326: type@var2880 =@expr1073749948 typeTok@var2879 .@expr8122 type (@expr8123 ) .@expr1073749951 classScope@var3463 ; }
1327:
1328: if (@expr1073749952 type@var2880 ) {
1329: const std ::@expr1073749953 set < const Scope *@expr7996 > parsedTypes@var2884 ;
1330: checkMemsetType (@expr1073749955 scope@var2873 , tok@var2874 , type@var2880 , false , parsedTypes@var2884 ) ;
1331: }
1332: } else { if (@expr1073749956 tok@var2874 .@expr8133 variable (@expr8134 ) &&@expr1073749959 tok@var2874 .@expr8133 variable (@expr8134 ) .@expr8138 typeScope (@expr8139 ) &&@expr1073749964 Token ::@expr8010 Match (@expr1073749966 tok@var2874 , "%var% = calloc|malloc|realloc|g_malloc|g_try_malloc|g_realloc|g_try_realloc (" ) ) {
1333: const std ::@expr1073749967 set < const Scope *@expr7996 > parsedTypes@var2885 ;
1334: checkMemsetType (@expr1073749969 scope@var2873 , tok@var2874 .@expr8013 tokAt (@expr8014 2 ) , tok@var2874 .@expr8133 variable (@expr8134 ) .@expr8138 typeScope (@expr8139 ) , true , parsedTypes@var2885 ) ;
1335:
1336: if (@expr1073749976 printWarnings@var2872 &&@expr1073749977 tok@var2874 .@expr8133 variable (@expr8134 ) .@expr8138 typeScope (@expr8139 ) .@expr1073749982 numConstructors@var3481 >@expr1073749983 0 ) {
1337: mallocOnClassWarning (@expr1073749984 tok@var2874 , tok@var2874 .@expr1073749985 strAt (@expr1073749986 2 ) , tok@var2874 .@expr8133 variable (@expr8134 ) .@expr8138 typeScope (@expr8139 ) .@expr1073749991 classDef@var3482 ) ; }
1338: } }
1339: }
1340: }
1341: }
1342:
1343: void CheckClass :: checkMemsetType ( const Scope * start@var2886 , const Token * tok@var2887 , const Scope * type@var2888 , bool allocation@var2889 , std :: set < const Scope * > parsedTypes@var2890 )
1344: {
1345:
1346: if (@expr1073749992 parsedTypes@var2890 .@expr1073749993 find (@expr1073749994 type@var2888 ) !=@expr1073749995 parsedTypes@var2890 .@expr1073749996 end (@expr1073749997 ) ) {
1347: return ; }
1348: parsedTypes@var2890 .@expr1073749998 insert (@expr1073749999 type@var2888 ) ;
1349:
1350: const bool printPortability@var2891 =@expr1073750000 mSettings@var29 .@expr1073750001 severity@var3441 .@expr1073750002 isEnabled (@expr1073750003 Severity ::@expr1073750004 portability ) ;
1351:
1352:
1353: for (@expr1073750005 const Type ::@expr1073750006 BaseInfo &@expr8183 i@var2892 :@expr1073750008 type@var2888 .@expr1073750009 definedType@var2893 .@expr1073750010 derivedFrom@var2894 ) {
1354: const Type * derivedFrom@var2895 ; derivedFrom@var2895 =@expr1073750011 i@var2892 .@expr1073750012 type@var2896 ;
1355: if (@expr1073750013 derivedFrom@var2895 &&@expr1073750014 derivedFrom@var2895 .@expr8191 classScope@var2897 ) {
1356: checkMemsetType (@expr1073750016 start@var2886 , tok@var2887 , derivedFrom@var2895 .@expr8191 classScope@var2897 , allocation@var2889 , parsedTypes@var2890 ) ; }
1357: }
1358:
1359:
1360: for (@expr1073750018 const Function &@expr8183 func@var2898 :@expr1073750020 type@var2888 .@expr1073750021 functionList@var2899 ) {
1361: if (@expr1073750022 func@var2898 .@expr1073750023 hasVirtualSpecifier (@expr1073750024 ) ) {
1362: if (@expr8201 allocation@var2889 ) {
1363: mallocOnClassError (@expr1073750026 tok@var2887 , tok@var2887 .@expr8203 str (@expr8204 ) , type@var2888 .@expr8205 classDef@var2900 , "virtual function" ) ; }
1364: else {
1365: memsetError (@expr1073750030 tok@var2887 , tok@var2887 .@expr8203 str (@expr8204 ) , "virtual function" , type@var2888 .@expr8205 classDef@var2900 .@expr8210 str (@expr8211 ) ) ; }
1366: }
1367: }
1368:
1369:
1370: for (@expr1073750036 const Variable &@expr8183 var@var2901 :@expr1073750038 type@var2888 .@expr1073750039 varlist@var2902 ) {
1371: if (@expr1073750040 var@var2901 .@expr1073750041 isReference (@expr1073750042 ) &&@expr1073750043 !@expr8220 var@var2901 .@expr8221 isStatic (@expr8222 ) ) {
1372: memsetErrorReference (@expr1073750047 tok@var2887 , tok@var2887 .@expr8203 str (@expr8204 ) , type@var2888 .@expr8205 classDef@var2900 .@expr8210 str (@expr8211 ) ) ;
1373: continue ;
1374: }
1375:
1376: if (@expr1073750053 !@expr8220 var@var2901 .@expr8221 isStatic (@expr8222 ) &&@expr1073750057 !@expr1073750058 var@var2901 .@expr1073750059 isConst (@expr1073750060 ) &&@expr1073750061 !@expr1073750062 var@var2901 .@expr1073750063 isPointer (@expr1073750064 ) &&@expr1073750065 (@expr1073750066 !@expr1073750067 var@var2901 .@expr1073750068 isArray (@expr1073750069 ) ||@expr1073750070 var@var2901 .@expr1073750071 typeEndToken (@expr1073750072 ) .@expr1073750073 str (@expr1073750074 ) !=@expr1073750075 "*" ) ) {
1377: const Token * tok1@var2903 ; tok1@var2903 =@expr1073750076 var@var2901 .@expr1073750077 typeStartToken (@expr1073750078 ) ;
1378: const Scope * typeScope@var2904 ; typeScope@var2904 =@expr1073750079 var@var2901 .@expr1073750080 typeScope (@expr1073750081 ) ;
1379:
1380: std ::@expr1073750082 string typeName@var2905 ;
1381: if (@expr1073750083 Token ::@expr8260 Match (@expr1073750085 tok1@var2903 , "%type% ::" ) ) {
1382: const Token * typeTok@var2906 ; typeTok@var2906 =@expr1073750086 tok1@var2903 ;
1383: while (@expr1073750087 Token ::@expr8260 Match (@expr1073750089 typeTok@var2906 , "%type% ::" ) ) {
1384: typeName@var2905 +=@expr1073750090 typeTok@var2906 .@expr8267 str (@expr8268 ) +@expr1073750093 "::" ;
1385: typeTok@var2906 =@expr1073750094 typeTok@var2906 .@expr1073750095 tokAt (@expr1073750096 2 ) ;
1386: }
1387: typeName@var2905 +=@expr1073750097 typeTok@var2906 .@expr8267 str (@expr8268 ) ;
1388: }
1389:
1390:
1391: if (@expr1073750100 var@var2901 .@expr1073750101 isStlType (@expr1073750102 ) &&@expr1073750103 typeName@var2905 !=@expr1073750104 "std::array" &&@expr1073750105 !@expr1073750106 mSettings@var29 .@expr1073750107 library@var3445 .@expr1073750108 podtype (@expr1073750109 typeName@var2905 ) ) {
1392: if (@expr8201 allocation@var2889 ) {
1393: mallocOnClassError (@expr1073750111 tok@var2887 , tok@var2887 .@expr8203 str (@expr8204 ) , type@var2888 .@expr8205 classDef@var2900 , "'" +@expr8291 typeName@var2905 +@expr8292 "'" ) ; }
1394: else {
1395: memsetError (@expr1073750117 tok@var2887 , tok@var2887 .@expr8203 str (@expr8204 ) , "'" +@expr8291 typeName@var2905 +@expr8292 "'" , type@var2888 .@expr8205 classDef@var2900 .@expr8210 str (@expr8211 ) ) ; }
1396: }
1397:
1398:
1399: else { if (@expr1073750125 typeScope@var2904 &&@expr1073750126 typeScope@var2904 !=@expr1073750127 type@var2888 ) {
1400: checkMemsetType (@expr1073750128 start@var2886 , tok@var2887 , typeScope@var2904 , allocation@var2889 , parsedTypes@var2890 ) ; }
1401:
1402:
1403: else { if (@expr1073750129 printPortability@var2891 &&@expr1073750130 var@var2901 .@expr1073750131 isFloatingType (@expr1073750132 ) &&@expr1073750133 tok@var2887 .@expr8203 str (@expr8204 ) ==@expr1073750136 "memset" ) {
1404: memsetErrorFloat (@expr1073750137 tok@var2887 , type@var2888 .@expr8205 classDef@var2900 .@expr8210 str (@expr8211 ) ) ; } } }
1405: }
1406: }
1407: }
1408:
1409: void CheckClass :: mallocOnClassWarning ( const Token * tok@var2907 , const std :: string & memfunc@var2908 , const Token * classTok@var2909 )
1410: {
1411: std ::@expr1073750141 list < const Token *@expr1073750142 > toks@var2910 ; toks@var2910 =@expr1073750143 {@expr1073750144 tok@var2907 , classTok@var2909 } ;
1412: reportError (@expr1073750145 toks@var2910 , Severity ::@expr1073750146 warning , "mallocOnClassWarning" ,
1413: "$symbol:" +@expr1073750147 memfunc@var2908 +@expr1073750148 "\nMemory for class instance allocated with $symbol(), but class provides constructors.\nMemory for class instance allocated with $symbol(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead."
1414:
1415:
1416: , CWE762@var2541 , Certainty ::@expr1073750149 normal ) ;
1417: }
1418:
1419: void CheckClass :: mallocOnClassError ( const Token * tok@var2911 , const std :: string & memfunc@var2912 , const Token * classTok@var2913 , const std :: string & classname@var2914 )
1420: {
1421: std ::@expr1073750151 list < const Token *@expr1073750152 > toks@var2915 ; toks@var2915 =@expr1073750153 {@expr1073750154 tok@var2911 , classTok@var2913 } ;
1422: reportError (@expr1073750155 toks@var2915 , Severity ::@expr1073750156 error@expr1073750150 , "mallocOnClassError" ,
1423: "$symbol:" +@expr1073750157 memfunc@var2912 +@expr1073750158 "\n$symbol:"
1424: +@expr1073750159 classname@var2914 +@expr1073750160 "\nMemory for class instance allocated with "
1425: +@expr1073750161 memfunc@var2912 +@expr1073750162 "(), but class contains a " +@expr1073750163 classname@var2914 +@expr1073750164 ".\nMemory for class instance allocated with "
1426: +@expr1073750165 memfunc@var2912 +@expr1073750166 "(), but class a " +@expr1073750167 classname@var2914 +@expr1073750168 ". This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead."
1427: , CWE665@var2539 , Certainty ::@expr1073750169 normal ) ;
1428: }
1429:
1430: void CheckClass :: memsetError ( const Token * tok@var2916 , const std :: string & memfunc@var2917 , const std :: string & classname@var2918 , const std :: string & type@var2919 )
1431: {
1432: reportError (@expr1073750171 tok@var2916 , Severity ::@expr1073750172 error@expr1073750170 , "memsetClass" ,
1433: "$symbol:" +@expr1073750173 memfunc@var2917 +@expr1073750174 "\n$symbol:"
1434: +@expr1073750175 classname@var2918 +@expr1073750176 "\nUsing '"
1435: +@expr1073750177 memfunc@var2917 +@expr1073750178 "' on " +@expr1073750179 type@var2919 +@expr1073750180 " that contains a " +@expr1073750181 classname@var2918 +@expr1073750182 ".\nUsing '"
1436: +@expr1073750183 memfunc@var2917 +@expr1073750184 "' on " +@expr1073750185 type@var2919 +@expr1073750186 " that contains a " +@expr1073750187 classname@var2918 +@expr1073750188 " is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created."
1437:
1438: , CWE762@var2541 , Certainty ::@expr1073750189 normal ) ;
1439: }
1440:
1441: void CheckClass :: memsetErrorReference ( const Token * tok@var2920 , const std :: string & memfunc@var2921 , const std :: string & type@var2922 )
1442: {
1443: reportError (@expr1073750191 tok@var2920 , Severity ::@expr1073750192 error@expr1073750190 , "memsetClassReference" ,
1444: "$symbol:" +@expr1073750193 memfunc@var2921 +@expr1073750194 "\nUsing '"
1445: +@expr1073750195 memfunc@var2921 +@expr1073750196 "' on " +@expr1073750197 type@var2922 +@expr1073750198 " that contains a reference." , CWE665@var2539 , Certainty ::@expr1073750199 normal ) ;
1446: }
1447:
1448: void CheckClass :: memsetErrorFloat ( const Token * tok@var2923 , const std :: string & type@var2924 )
1449: {
1450: reportError (@expr1073750200 tok@var2923 , Severity ::@expr1073750201 portability , "memsetClassFloat" , "Using memset() on " +@expr1073750202 type@var2924 +@expr1073750203 " which contains a floating point number.\nUsing memset() on "
1451: +@expr1073750204 type@var2924 +@expr1073750205 " which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0."
1452:
1453:
1454: , CWE758@var2540 , Certainty ::@expr1073750206 normal ) ;
1455: }
1456:
|
1462:
1463: void CheckClass :: operatorEqRetRefThis ( )
1464: {
1465: if (@expr1073750207 !@expr1073750208 mSettings@var29 .@expr1073750209 severity@var3441 .@expr1073750210 isEnabled (@expr1073750211 Severity ::@expr1073750212 style ) ) {
1466: return ; }
1467:
1468: for (@expr1073750213 const Scope *@expr1073750214 scope@var2925 :@expr1073750215 mSymbolDatabase@var1666 .@expr1073750216 classAndStructScopes@var3443 ) {
1469: for (@expr1073750217 std ::@expr8394 list < Function > ::@expr8394 const_iterator func@var2926 =@expr1073750220 scope@var2925 .@expr8397 functionList@var2927 .@expr1073750222 begin (@expr1073750223 ) ; func@var2926 !=@expr1073750224 scope@var2925 .@expr8397 functionList@var2927 .@expr1073750226 end (@expr1073750227 ) ; ++@expr1073750228 func@var2926 ) {
1470: if (@expr1073750229 func@var2926 .@expr1073750230 type@var2928 ==@expr1073750231 Function ::@expr1073750232 eOperatorEqual &&@expr1073750233 func@var2926 .@expr1073750234 hasBody (@expr1073750235 ) ) {
1471:
1472: if (@expr1073750236 func@var2926 .@expr1073750237 retType@var2929 ==@expr1073750238 func@var2926 .@expr1073750239 nestedIn@var2930 .@expr1073750240 definedType@var2931 &&@expr1073750241 func@var2926 .@expr1073750242 tokenDef@var2932 .@expr1073750243 strAt (@expr1073750244 -1 ) ==@expr1073750245 "&" ) {
1473: checkReturnPtrThis (@expr1073750246 scope@var2925 , &@expr1073750247 (@expr1073750248 *@expr1073750249 func@var2926 ) , func@var2926 .@expr8426 functionScope@var2933 .@expr1073750251 bodyStart@var2934 , func@var2926 .@expr8426 functionScope@var2933 .@expr1073750253 bodyEnd@var2935 ) ;
1474: }
1475: }
1476: }
1477: }
1478: }
1479:
1480: void CheckClass :: checkReturnPtrThis ( const Scope * scope@var2936 , const Function * func@var2937 , const Token * tok@var2938 , const Token * last@var2939 )
1481: {
1482: std ::@expr1073750254 set < const Function *@expr1073750255 > analyzedFunctions@var2940 ;
1483: checkReturnPtrThis (@expr1073750256 scope@var2936 , func@var2937 , tok@var2938 , last@var2939 , analyzedFunctions@var2940 ) ;
1484: }
1485:
1486: void CheckClass :: checkReturnPtrThis ( const Scope * scope@var2941 , const Function * func@var2942 , const Token * tok@var2943 , const Token * last@var2944 , std :: set < const Function * > & analyzedFunctions@var2945 )
1487: {
1488: bool foundReturn@var2946 ; foundReturn@var2946 =@expr1073750257 false ;
1489:
1490: const Token * const startTok@var2947 ; startTok@var2947 =@expr1073750258 tok@var2943 ;
1491:
1492: for (@expr1073750259 ; tok@var2943 &&@expr1073750260 tok@var2943 !=@expr1073750261 last@var2944 ; tok@var2943 =@expr1073750262 tok@var2943 .@expr8439 next (@expr8440 ) ) {
1493:
1494: if (@expr1073750265 tok@var2943 .@expr1073750266 str (@expr1073750267 ) !=@expr1073750268 "return" ) {
1495: continue ; }
1496:
1497: foundReturn@var2946 =@expr1073750269 true ;
1498:
1499: const Token * retExpr@var2948 ; retExpr@var2948 =@expr1073750270 tok@var2943 .@expr1073750271 astOperand1 (@expr1073750272 ) ;
1500: if (@expr1073750273 retExpr@var2948 &&@expr1073750274 retExpr@var2948 .@expr1073750275 str (@expr1073750276 ) ==@expr1073750277 "=" ) {
1501: retExpr@var2948 =@expr1073750278 retExpr@var2948 .@expr8455 astOperand1 (@expr8456 ) ; }
1502: if (@expr1073750281 retExpr@var2948 &&@expr1073750282 retExpr@var2948 .@expr1073750283 isUnaryOp (@expr1073750284 "*" ) &&@expr1073750285 Token ::@expr8462 simpleMatch (@expr1073750287 retExpr@var2948 .@expr8455 astOperand1 (@expr8456 ) , "this" ) ) {
1503: continue ; }
1504:
1505: std ::@expr1073750290 string cast@var2949 (@expr1073750291 "( " +@expr1073750292 scope@var2941 .@expr8469 className@var2950 +@expr1073750294 " & )" ) ;
1506: if (@expr1073750295 Token ::@expr8462 simpleMatch (@expr1073750297 tok@var2943 .@expr8439 next (@expr8440 ) , cast@var2949 .@expr1073750300 c_str (@expr1073750301 ) , cast@var2949 .@expr1073750302 size (@expr1073750303 ) ) ) {
1507: tok@var2943 =@expr1073750304 tok@var2943 .@expr1073750305 tokAt (@expr1073750306 4 ) ; }
1508:
1509:
1510: if (@expr1073750307 tok@var2943 .@expr1073750308 strAt (@expr1073750309 2 ) ==@expr1073750310 "(" &&@expr1073750311
1511: tok@var2943 .@expr1073750312 linkAt (@expr1073750313 2 ) .@expr1073750314 next (@expr1073750315 ) .@expr1073750316 str (@expr1073750317 ) ==@expr1073750318 ";" ) {
1512:
1513: for (@expr1073750319 std ::@expr8496 list < Function > ::@expr8496 const_iterator it@var2951 =@expr1073750322 scope@var2941 .@expr8499 functionList@var2952 .@expr1073750324 begin (@expr1073750325 ) ; it@var2951 !=@expr1073750326 scope@var2941 .@expr8499 functionList@var2952 .@expr1073750328 end (@expr1073750329 ) ; ++@expr1073750330 it@var2951 ) {
1514:
1515: if (@expr1073750331 it@var2951 .@expr1073750332 type@var2953 ==@expr1073750333 Function ::@expr1073750334 eFunction &&@expr1073750335 it@var2951 .@expr1073750336 hasBody (@expr1073750337 ) &&@expr1073750338
1516: it@var2951 .@expr1073750339 token@var2954 .@expr1073750340 str (@expr1073750341 ) ==@expr1073750342 tok@var2943 .@expr8439 next (@expr8440 ) .@expr8521 str (@expr8522 ) ) {
1517:
1518: if (@expr1073750347 it@var2951 .@expr8524 tokenDef@var2955 .@expr1073750349 previous (@expr1073750350 ) .@expr1073750351 str (@expr1073750352 ) ==@expr1073750353 "&" &&@expr1073750354
1519: it@var2951 .@expr8524 tokenDef@var2955 .@expr1073750356 strAt (@expr1073750357 -2 ) ==@expr1073750358 scope@var2941 .@expr8469 className@var2950 ) {
1520:
1521: if (@expr1073750360 !@expr1073750361 it@var2951 .@expr1073750362 isConst (@expr1073750363 ) ) {
1522:
1523:
1524: if (@expr1073750364 analyzedFunctions@var2945 .@expr1073750365 find (@expr1073750366 &@expr8543 *@expr8544 it@var2951 ) ==@expr1073750369 analyzedFunctions@var2945 .@expr1073750370 end (@expr1073750371 ) ) {
1525: analyzedFunctions@var2945 .@expr1073750372 insert (@expr1073750373 &@expr8543 *@expr8544 it@var2951 ) ;
1526: checkReturnPtrThis (@expr1073750376 scope@var2941 , &@expr8543 *@expr8544 it@var2951 , it@var2951 .@expr8555 arg@var2956 .@expr8556 link (@expr8557 ) .@expr8558 next (@expr8559 ) , it@var2951 .@expr8555 arg@var2956 .@expr8556 link (@expr8557 ) .@expr8558 next (@expr8559 ) .@expr1073750389 link (@expr1073750390 ) ,
1527: analyzedFunctions@var2945 ) ;
1528: }
1529:
1530: else {
1531: return ; }
1532: }
1533: }
1534: }
1535: }
1536: }
1537:
1538:
1539: else { if (@expr1073750391 !@expr1073750392 (@expr1073750393 Token ::@expr8462 simpleMatch (@expr1073750395 tok@var2943 .@expr8439 next (@expr8440 ) , "operator= (" ) ||@expr1073750398
1540: Token ::@expr8462 simpleMatch (@expr1073750400 tok@var2943 .@expr8439 next (@expr8440 ) , "this . operator= (" ) ||@expr1073750403
1541: (@expr1073750404 Token ::@expr1073750405 Match (@expr1073750406 tok@var2943 .@expr8439 next (@expr8440 ) , "%type% :: operator= (" ) &&@expr1073750409
1542: tok@var2943 .@expr8439 next (@expr8440 ) .@expr8521 str (@expr8522 ) ==@expr1073750414 scope@var2941 .@expr8469 className@var2950 ) ) ) {
1543: operatorEqRetRefThisError (@expr1073750416 func@var2942 .@expr8593 token@var2957 ) ; } }
1544: }
1545: if (@expr1073750418 foundReturn@var2946 ) {
1546: return ;
1547: }
1548: if (@expr1073750419 startTok@var2947 .@expr1073750420 next (@expr1073750421 ) ==@expr1073750422 last@var2944 ) {
1549: const std ::@expr1073750423 string tmp@var2958 (@expr1073750424 "( const " +@expr1073750425 scope@var2941 .@expr8469 className@var2950 +@expr1073750427 " &" ) ;
1550: if (@expr1073750428 Token ::@expr8462 simpleMatch (@expr1073750430 func@var2942 .@expr1073750431 argDef@var2959 , tmp@var2958 .@expr1073750432 c_str (@expr1073750433 ) , tmp@var2958 .@expr1073750434 size (@expr1073750435 ) ) ) {
1551:
1552: operatorEqMissingReturnStatementError (@expr8612 func@var2942 .@expr8593 token@var2957 , func@var2942 .@expr8614 access@var2960 ==@expr8615 AccessControl ::@expr8616 Public ) ;
1553: } else {
1554: operatorEqMissingReturnStatementError (@expr1073750441 func@var2942 .@expr8593 token@var2957 , true ) ;
1555: }
1556: return ;
1557: }
1558: if (@expr1073750443 mSettings@var29 .@expr1073750444 library@var3445 .@expr1073750445 isScopeNoReturn (@expr1073750446 last@var2944 , nullptr ) ) {
1559:
1560:
1561: operatorEqShouldBeLeftUnimplementedError (@expr1073750447 func@var2942 .@expr8593 token@var2957 ) ;
1562: return ;
1563: }
1564:
1565: operatorEqMissingReturnStatementError (@expr8612 func@var2942 .@expr8593 token@var2957 , func@var2942 .@expr8614 access@var2960 ==@expr8615 AccessControl ::@expr8616 Public ) ;
1566: }
1567:
1568: void CheckClass :: operatorEqRetRefThisError ( const Token * tok@var2961 )
1569: {
1570: reportError (@expr1073750454 tok@var2961 , Severity ::@expr1073750455 style , "operatorEqRetRefThis" , "'operator=' should return reference to 'this' instance." , CWE398@var2537 , Certainty ::@expr1073750456 normal ) ;
1571: }
1572:
1573: void CheckClass :: operatorEqShouldBeLeftUnimplementedError ( const Token * tok@var2962 )
1574: {
1575: reportError (@expr1073750457 tok@var2962 , Severity ::@expr1073750458 style , "operatorEqShouldBeLeftUnimplemented" , "'operator=' should either return reference to 'this' instance or be declared private and left unimplemented." , CWE398@var2537 , Certainty ::@expr1073750459 normal ) ;
1576: }
1577:
1578: void CheckClass :: operatorEqMissingReturnStatementError ( const Token * tok@var2963 , bool error@var2964 )
1579: {
1580: if (@expr1073750461 error@var2964 ) {
1581: reportError (@expr1073750462 tok@var2963 , Severity ::@expr1073750463 error@expr1073750460 , "operatorEqMissingReturnStatement" , "No 'return' statement in non-void function causes undefined behavior." , CWE398@var2537 , Certainty ::@expr1073750464 normal ) ;
1582: } else {
1583: operatorEqRetRefThisError (@expr1073750465 tok@var2963 ) ;
1584: }
1585: }
1586:
|
1600:
1601: void CheckClass :: operatorEqToSelf ( )
1602: {
1603: if (@expr1073750466 !@expr1073750467 mSettings@var29 .@expr1073750468 severity@var3441 .@expr1073750469 isEnabled (@expr1073750470 Severity ::@expr1073750471 warning ) ) {
1604: return ; }
1605:
1606: for (@expr1073750472 const Scope *@expr1073750473 scope@var2965 :@expr1073750474 mSymbolDatabase@var1666 .@expr1073750475 classAndStructScopes@var3443 ) {
1607:
1608: if (@expr1073750476 scope@var2965 .@expr1073750477 definedType@var2966 .@expr1073750478 derivedFrom@var2967 .@expr1073750479 size (@expr1073750480 ) >@expr1073750481 1 ) {
1609: continue ; }
1610:
1611: for (@expr1073750482 const Function &@expr1073750483 func@var2968 :@expr1073750484 scope@var2965 .@expr1073750485 functionList@var2969 ) {
1612: if (@expr1073750486 func@var2968 .@expr1073750487 type@var2970 ==@expr1073750488 Function ::@expr1073750489 eOperatorEqual &&@expr1073750490 func@var2968 .@expr1073750491 hasBody (@expr1073750492 ) ) {
1613:
1614: if (@expr1073750493 func@var2968 .@expr8670 argumentList@var2971 .@expr1073750495 empty (@expr1073750496 ) ) {
1615: continue ; }
1616: const Token * typeTok@var2972 ; typeTok@var2972 =@expr1073750497 func@var2968 .@expr8670 argumentList@var2971 .@expr1073750499 front (@expr1073750500 ) .@expr1073750501 typeEndToken (@expr1073750502 ) ;
1617: while (@expr1073750503 typeTok@var2972 .@expr8680 str (@expr8681 ) ==@expr1073750506 "const" ||@expr1073750507 typeTok@var2972 .@expr8680 str (@expr8681 ) ==@expr1073750510 "&" ||@expr1073750511 typeTok@var2972 .@expr8680 str (@expr8681 ) ==@expr1073750514 "*" ) {
1618: typeTok@var2972 =@expr1073750515 typeTok@var2972 .@expr1073750516 previous (@expr1073750517 ) ; }
1619: if (@expr1073750518 typeTok@var2972 .@expr8680 str (@expr8681 ) !=@expr1073750521 scope@var2965 .@expr8698 className@var2973 ) {
1620: continue ; }
1621:
1622:
1623: if (@expr1073750523 Token ::@expr1073750524 Match (@expr1073750525 func@var2968 .@expr8702 retDef@var2974 , "%type% &" ) &&@expr1073750527 func@var2968 .@expr8702 retDef@var2974 .@expr1073750529 str (@expr1073750530 ) ==@expr1073750531 scope@var2965 .@expr8698 className@var2973 ) {
1624:
1625: const Token * rhs@var2975 ; rhs@var2975 =@expr1073750533 func@var2968 .@expr8670 argumentList@var2971 .@expr1073750535 begin (@expr1073750536 ) .@expr1073750537 nameToken (@expr1073750538 ) ;
1626: const Token * out_ifStatementScopeStart@var2976 ; out_ifStatementScopeStart@var2976 =@expr1073750539 nullptr ;
1627: if (@expr1073750540 !@expr1073750541 hasAssignSelf (@expr1073750542 &@expr8719 func@var2968 , rhs@var2975 , &@expr1073750544 out_ifStatementScopeStart@var2976 ) ) {
1628: if (@expr1073750545 hasAllocation (@expr1073750546 &@expr8719 func@var2968 , scope@var2965 ) ) {
1629: operatorEqToSelfError (@expr8724 func@var2968 .@expr8725 token@var2977 ) ; }
1630: } else { if (@expr1073750550 out_ifStatementScopeStart@var2976 !=@expr1073750551 nullptr ) {
1631: if (@expr1073750552 hasAllocationInIfScope (@expr1073750553 &@expr8719 func@var2968 , scope@var2965 , out_ifStatementScopeStart@var2976 ) ) {
1632: operatorEqToSelfError (@expr8724 func@var2968 .@expr8725 token@var2977 ) ; }
1633: } }
1634: }
1635: }
1636: }
1637: }
1638: }
1639:
1640: bool CheckClass :: hasAllocationInIfScope ( const Function * func@var2978 , const Scope * scope@var2979 , const Token * ifStatementScopeStart@var2980 ) const
1641: {
1642: const Token * end@var2981 ;
1643: if (@expr1073750557 ifStatementScopeStart@var2980 .@expr1073750558 str (@expr1073750559 ) ==@expr1073750560 "{" ) {
1644: end@var2981 =@expr1073750561 ifStatementScopeStart@var2980 .@expr1073750562 link (@expr1073750563 ) ; }
1645: else {
1646: end@var2981 =@expr1073750564 func@var2978 .@expr1073750565 functionScope@var2982 .@expr1073750566 bodyEnd@var2983 ; }
1647: return hasAllocation (@expr1073750567 func@var2978 , scope@var2979 , ifStatementScopeStart@var2980 , end@var2981 ) ;
1648: }
1649:
1650: bool CheckClass :: hasAllocation ( const Function * func@var2984 , const Scope * scope@var2985 ) const
1651: {
1652: return hasAllocation (@expr1073750568 func@var2984 , scope@var2985 , func@var2984 .@expr8745 functionScope@var2986 .@expr1073750570 bodyStart@var2987 , func@var2984 .@expr8745 functionScope@var2986 .@expr1073750572 bodyEnd@var2988 ) ;
1653: }
1654:
1655: bool CheckClass :: hasAllocation ( const Function * func@var2989 , const Scope * scope@var2990 , const Token * start@var2991 , const Token * end@var2992 ) const
1656: {
1657: if (@expr1073750573 !@expr1073750574 end@var2992 ) {
1658: end@var2992 =@expr1073750575 func@var2989 .@expr1073750576 functionScope@var2993 .@expr1073750577 bodyEnd@var2994 ; }
1659: for (@expr1073750578 const Token *@expr8755 tok@var2995 =@expr1073750580 start@var2991 ; tok@var2995 &&@expr1073750581 (@expr1073750582 tok@var2995 !=@expr1073750583 end@var2992 ) ; tok@var2995 =@expr1073750584 tok@var2995 .@expr8761 next (@expr8762 ) ) {
1660: if (@expr1073750587 Token ::@expr8764 Match (@expr1073750589 tok@var2995 , "%var% = malloc|realloc|calloc|new" ) &&@expr1073750590 isMemberVar (@expr1073750591 scope@var2990 , tok@var2995 ) ) {
1661: return true ; }
1662:
1663:
1664: const Token * var@var2996 ;
1665: if (@expr1073750592 Token ::@expr8764 Match (@expr1073750594 tok@var2995 , "free ( %var%" ) ) {
1666: var@var2996 =@expr1073750595 tok@var2995 .@expr8772 tokAt (@expr1073750597 2 ) ; }
1667: else { if (@expr1073750598 Token ::@expr8764 Match (@expr1073750600 tok@var2995 , "delete [ ] %var%" ) ) {
1668: var@var2996 =@expr1073750601 tok@var2995 .@expr8772 tokAt (@expr1073750603 3 ) ; }
1669: else { if (@expr1073750604 Token ::@expr8764 Match (@expr1073750606 tok@var2995 , "delete %var%" ) ) {
1670: var@var2996 =@expr1073750607 tok@var2995 .@expr8761 next (@expr8762 ) ; }
1671: else {
1672: continue ; } } }
1673:
1674: if (@expr1073750610 isMemberVar (@expr1073750611 scope@var2990 , var@var2996 ) ) {
1675: for (@expr1073750612 const Token *@expr8755 tok1@var2997 =@expr1073750614 var@var2996 .@expr1073750615 next (@expr1073750616 ) ; tok1@var2997 &&@expr1073750617 (@expr1073750618 tok1@var2997 !=@expr1073750619 end@var2992 ) ; tok1@var2997 =@expr1073750620 tok1@var2997 .@expr1073750621 next (@expr1073750622 ) ) {
1676: if (@expr1073750623 Token ::@expr8764 Match (@expr1073750625 tok1@var2997 , "%varid% =" , var@var2996 .@expr1073750626 varId (@expr1073750627 ) ) ) {
1677: return true ; }
1678: }
1679: }
1680: }
1681:
1682: return false ;
1683: }
1684:
1685: static bool isTrueKeyword ( const Token * tok@var2998 )
1686: {
1687: return tok@var2998 .@expr1073750628 hasKnownIntValue (@expr1073750629 ) &&@expr1073750630 tok@var2998 .@expr1073750631 getKnownIntValue (@expr1073750632 ) ==@expr1073750633 1 ;
1688: }
1689:
1690: static bool isFalseKeyword ( const Token * tok@var2999 )
1691: {
1692: return tok@var2999 .@expr1073750634 hasKnownIntValue (@expr1073750635 ) &&@expr1073750636 tok@var2999 .@expr1073750637 getKnownIntValue (@expr1073750638 ) ==@expr1073750639 0 ;
1693: }
1694:
|
1698:
1699: CheckClass :: Bool CheckClass :: isInverted ( const Token * tok@var3000 , const Token * rhs@var3001 )
1700: {
1701: bool res@var3002 ; res@var3002 =@expr1073750643 true ;
1702: for (@expr1073750644 const Token *@expr1073750645 itr@var3003 =@expr1073750646 tok@var3000 ; itr@var3003 &&@expr1073750647 itr@var3003 .@expr1073750648 str (@expr1073750649 ) !=@expr1073750650 "(" ; itr@var3003 =@expr1073750651 itr@var3003 .@expr1073750652 astParent (@expr1073750653 ) ) {
1703: if (@expr1073750654 Token ::@expr8831 simpleMatch (@expr8832 itr@var3003 , "!=" ) &&@expr1073750657 (@expr1073750658 isTrueKeyword (@expr8835 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) ) ||@expr8838 isTrueKeyword (@expr8839 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) ) ) ) {
1704: res@var3002 =@expr1073750666 !@expr8843 res@var3002 ;
1705: } else { if (@expr1073750668 Token ::@expr8831 simpleMatch (@expr8832 itr@var3003 , "!=" ) &&@expr1073750671 (@expr1073750672 (@expr1073750673 Token ::@expr8831 simpleMatch (@expr8851 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) , "this" ) &&@expr8854 Token ::@expr8831 simpleMatch (@expr8856 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) , "&" ) &&@expr8859 Token ::@expr8831 simpleMatch (@expr8861 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) .@expr8864 next (@expr8865 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8868 c_str (@expr8869 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8872 size (@expr8873 ) ) )
1706: ||@expr8874 (@expr1073750699 Token ::@expr8831 simpleMatch (@expr8877 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) , "this" ) &&@expr8880 Token ::@expr8831 simpleMatch (@expr8882 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) , "&" ) &&@expr8885 Token ::@expr8831 simpleMatch (@expr8887 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) .@expr8890 next (@expr8891 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8868 c_str (@expr8869 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8872 size (@expr8873 ) ) ) ) ) {
1707: res@var3002 =@expr1073750724 !@expr8843 res@var3002 ;
1708: } else { if (@expr1073750726 Token ::@expr8831 simpleMatch (@expr8832 itr@var3003 , "!=" ) &&@expr1073750729 (@expr1073750730 isFalseKeyword (@expr8907 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) ) ||@expr8910 isFalseKeyword (@expr8911 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) ) ) ) {
1709:
1710: } else { if (@expr1073750738 Token ::@expr8831 simpleMatch (@expr1073750740 itr@var3003 , "!" ) ) {
1711: res@var3002 =@expr1073750741 !@expr8843 res@var3002 ;
1712: } else { if (@expr1073750743 Token ::@expr8831 simpleMatch (@expr8921 itr@var3003 , "==" ) &&@expr1073750746 (@expr1073750747 isFalseKeyword (@expr8907 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) ) ||@expr8910 isFalseKeyword (@expr8911 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) ) ) ) {
1713: res@var3002 =@expr1073750755 !@expr8843 res@var3002 ;
1714: } else { if (@expr1073750757 Token ::@expr8831 simpleMatch (@expr8921 itr@var3003 , "==" ) &&@expr1073750760 (@expr1073750761 isTrueKeyword (@expr8835 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) ) ||@expr8838 isTrueKeyword (@expr8839 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) ) ) ) {
1715:
1716: } else { if (@expr1073750769 Token ::@expr8831 simpleMatch (@expr8921 itr@var3003 , "==" ) &&@expr1073750772 (@expr1073750773 (@expr1073750774 Token ::@expr8831 simpleMatch (@expr8851 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) , "this" ) &&@expr8854 Token ::@expr8831 simpleMatch (@expr8856 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) , "&" ) &&@expr8859 Token ::@expr8831 simpleMatch (@expr8861 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) .@expr8864 next (@expr8865 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8868 c_str (@expr8869 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8872 size (@expr8873 ) ) )
1717: ||@expr8874 (@expr1073750800 Token ::@expr8831 simpleMatch (@expr8877 itr@var3003 .@expr8840 astOperand2 (@expr8841 ) , "this" ) &&@expr8880 Token ::@expr8831 simpleMatch (@expr8882 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) , "&" ) &&@expr8885 Token ::@expr8831 simpleMatch (@expr8887 itr@var3003 .@expr8836 astOperand1 (@expr8837 ) .@expr8890 next (@expr8891 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8868 c_str (@expr8869 ) , rhs@var3001 .@expr8866 str (@expr8867 ) .@expr8872 size (@expr8873 ) ) ) ) ) {
1718:
1719: } else {
1720: return Bool ::@expr1073750825 BAILOUT@expr1073750640 ;
1721: } } } } } } }
1722: }
1723: if (@expr1073750826 res@var3002 ) {
1724: return Bool ::@expr1073750827 TRUE@expr1073750641 ; }
1725: return Bool ::@expr1073750828 FALSE@expr1073750642 ;
1726: }
1727:
1728: const Token * CheckClass :: getIfStmtBodyStart ( const Token * tok@var3004 , const Token * rhs@var3005 )
1729: {
1730: const Token * top@var3006 ; top@var3006 =@expr1073750829 tok@var3004 .@expr1073750830 astTop (@expr1073750831 ) ;
1731: if (@expr1073750832 Token ::@expr1073750833 simpleMatch (@expr1073750834 top@var3006 .@expr9011 link (@expr9012 ) , ") {" ) ) {
1732: switch (@expr1073750837 isInverted (@expr1073750838 tok@var3004 .@expr1073750839 astParent (@expr1073750840 ) , rhs@var3005 ) ) {
1733: case Bool ::@expr1073750841 BAILOUT :@expr9018 ;
1734: return nullptr ;
1735: case Bool ::@expr1073750843 TRUE :@expr9018 ;
1736: return top@var3006 .@expr9011 link (@expr9012 ) .@expr9023 next (@expr9024 ) ;
1737: case Bool ::@expr1073750849 FALSE :@expr9018 ;
1738: return top@var3006 .@expr9011 link (@expr9012 ) .@expr9023 next (@expr9024 ) .@expr1073750855 link (@expr1073750856 ) ;
1739: }
1740: }
1741: return nullptr ;
1742: }
1743:
1744: bool CheckClass :: hasAssignSelf ( const Function * func@var3007 , const Token * rhs@var3008 , const Token * * out_ifStatementScopeStart@var3009 )
1745: {
1746: if (@expr1073750857 !@expr1073750858 rhs@var3008 ) {
1747: return false ; }
1748: const Token * last@var3010 ; last@var3010 =@expr1073750859 func@var3007 .@expr9036 functionScope@var3011 .@expr1073750861 bodyEnd@var3012 ;
1749: for (@expr1073750862 const Token *@expr9039 tok@var3013 =@expr1073750864 func@var3007 .@expr9036 functionScope@var3011 .@expr1073750866 bodyStart@var3014 ; tok@var3013 &&@expr1073750867 tok@var3013 !=@expr1073750868 last@var3010 ; tok@var3013 =@expr1073750869 tok@var3013 .@expr9046 next (@expr9047 ) ) {
1750: if (@expr1073750872 !@expr1073750873 Token ::@expr9050 simpleMatch (@expr1073750875 tok@var3013 , "if (" ) ) {
1751: continue ; }
1752:
1753: bool ret@var3015 ; ret@var3015 =@expr1073750876 false ;
1754: visitAstNodes (@expr1073750877 tok@var3013 .@expr9046 next (@expr9047 ) .@expr1073750880 astOperand2 (@expr1073750881 ) ,
1755: [@expr1073750882 &@expr1073750883 ] (@expr1073750884 const Token *@expr9039 tok2@var3016 ) {
1756: if (@expr1073750886 !@expr1073750887 Token ::@expr1073750888 Match (@expr1073750889 tok2@var3016 , "==|!=" ) ) {
1757: return ChildrenToVisit ::@expr9066 op1_and_op2 ; }
1758: if (@expr1073750891 Token ::@expr9050 simpleMatch (@expr1073750893 tok2@var3016 .@expr9070 astOperand1 (@expr9071 ) , "this" ) ) {
1759: tok2@var3016 =@expr1073750896 tok2@var3016 .@expr9073 astOperand2 (@expr9074 ) ; }
1760: else { if (@expr1073750899 Token ::@expr9050 simpleMatch (@expr1073750901 tok2@var3016 .@expr9073 astOperand2 (@expr9074 ) , "this" ) ) {
1761: tok2@var3016 =@expr1073750904 tok2@var3016 .@expr9070 astOperand1 (@expr9071 ) ; }
1762: else {
1763: return ChildrenToVisit ::@expr9066 op1_and_op2 ; } }
1764: if (@expr1073750908 tok2@var3016 &&@expr1073750909 tok2@var3016 .@expr1073750910 isUnaryOp (@expr1073750911 "&" ) &&@expr1073750912 tok2@var3016 .@expr9070 astOperand1 (@expr9071 ) .@expr1073750915 str (@expr1073750916 ) ==@expr1073750917 rhs@var3008 .@expr1073750918 str (@expr1073750919 ) ) {
1765: ret@var3015 =@expr1073750920 true ; }
1766: if (@expr9097 ret@var3015 ) {
1767: *@expr1073750922 out_ifStatementScopeStart@var3009 =@expr1073750923 getIfStmtBodyStart (@expr1073750924 tok2@var3016 , rhs@var3008 ) ;
1768: }
1769: return ret@var3015 ?@expr1073750925 ChildrenToVisit ::@expr1073750926 done :@expr1073750927 ChildrenToVisit ::@expr9066 op1_and_op2 ;
1770: } ) ;
1771: if (@expr9097 ret@var3015 ) {
1772: return ret@var3015 ; }
1773: }
1774:
1775: return false ;
1776: }
1777:
1778: void CheckClass :: operatorEqToSelfError ( const Token * tok@var3017 )
1779: {
1780: reportError (@expr1073750930 tok@var3017 , Severity ::@expr1073750931 warning , "operatorEqToSelf" ,
1781: "'operator=' should check for assignment to self to avoid problems with dynamic memory.\n'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class."
1782:
1783: , CWE398@var2537 , Certainty ::@expr1073750932 normal ) ;
1784: }
1785:
|
1789:
1790: void CheckClass :: virtualDestructor ( )
1791: {
1792:
|
1797:
1798: const bool printInconclusive@var3018 =@expr1073750934 mSettings@var29 .@expr1073750935 certainty@var3442 .@expr1073750936 isEnabled (@expr1073750937 Certainty ::@expr1073750938 inconclusive@expr1073750933 ) ;
1799:
1800: std ::@expr1073750939 list < const Function *@expr9116 > inconclusiveErrors@var3019 ;
1801:
1802: for (@expr1073750941 const Scope *@expr9116 scope@var3020 :@expr1073750943 mSymbolDatabase@var1666 .@expr1073750944 classAndStructScopes@var3443 ) {
1803:
1804:
1805: if (@expr1073750945 scope@var3020 .@expr9122 definedType@var3021 .@expr9123 derivedFrom@var3022 .@expr1073750948 empty (@expr1073750949 ) ) {
1806: if (@expr1073750950 printInconclusive@var3018 ) {
1807: const Function * destructor@var3023 ; destructor@var3023 =@expr1073750951 scope@var3020 .@expr9128 getDestructor (@expr9129 ) ;
1808: if (@expr1073750954 destructor@var3023 &&@expr1073750955 !@expr1073750956 destructor@var3023 .@expr1073750957 hasVirtualSpecifier (@expr1073750958 ) &&@expr1073750959 destructor@var3023 .@expr1073750960 access@var3024 ==@expr1073750961 AccessControl ::@expr9138 Public ) {
1809: for (@expr1073750963 const Function &@expr9140 func@var3025 :@expr1073750965 scope@var3020 .@expr1073750966 functionList@var3026 ) {
1810: if (@expr1073750967 func@var3025 .@expr1073750968 hasVirtualSpecifier (@expr1073750969 ) ) {
1811: inconclusiveErrors@var3019 .@expr1073750970 push_back (@expr1073750971 destructor@var3023 ) ;
1812: break ;
1813: }
1814: }
1815: }
1816: }
1817: continue ;
1818: }
1819:
1820:
1821: if (@expr1073750972 mSettings@var29 .@expr1073750973 standards@var3446 .@expr1073750974 cpp@var3447 <=@expr1073750975 Standards ::@expr1073750976 CPP03 ) {
1822:
1823: const Function * destructor@var3027 ; destructor@var3027 =@expr1073750977 scope@var3020 .@expr9128 getDestructor (@expr9129 ) ;
1824:
1825:
1826: if (@expr1073750980 !@expr1073750981 destructor@var3027 ||@expr1073750982 !@expr1073750983 destructor@var3027 .@expr1073750984 hasBody (@expr1073750985 ) ) {
1827: continue ; }
1828:
1829:
1830: if (@expr1073750986 destructor@var3027 .@expr9163 token@var3028 .@expr1073750988 linkAt (@expr1073750989 3 ) ==@expr1073750990 destructor@var3027 .@expr9163 token@var3028 .@expr1073750992 tokAt (@expr1073750993 4 ) ) {
1831: continue ; }
1832: }
1833:
1834: const Token * derived@var3029 ; derived@var3029 =@expr1073750994 scope@var3020 .@expr1073750995 classDef@var3030 ;
1835: const Token * derivedClass@var3031 ; derivedClass@var3031 =@expr1073750996 derived@var3029 .@expr1073750997 next (@expr1073750998 ) ;
1836:
1837:
1838: for (@expr1073750999 const Type ::@expr1073751000 BaseInfo &@expr9140 j@var3032 :@expr1073751002 scope@var3020 .@expr9122 definedType@var3021 .@expr9123 derivedFrom@var3022 ) {
1839:
1840: if (@expr1073751005 j@var3032 .@expr1073751006 access@var3033 !=@expr1073751007 AccessControl ::@expr1073751008 Private &&@expr1073751009 j@var3032 .@expr9186 type@var3034 ) {
1841: const Type * derivedFrom@var3035 ; derivedFrom@var3035 =@expr1073751011 j@var3032 .@expr9186 type@var3034 ;
1842: const Scope * derivedFromScope@var3036 ; derivedFromScope@var3036 =@expr1073751013 derivedFrom@var3035 .@expr1073751014 classScope@var3037 ;
1843: if (@expr1073751015 !@expr1073751016 derivedFromScope@var3036 ) {
1844: continue ; }
1845:
|
1850:
1851: {
1852:
1853: std ::@expr1073751017 set < int > baseClassPointers@var3038 ;
1854:
1855: for (@expr1073751018 const Variable *@expr9116 var@var3039 :@expr1073751020 mSymbolDatabase@var1666 .@expr1073751021 variableList (@expr1073751022 ) ) {
1856: if (@expr1073751023 var@var3039 &&@expr1073751024 var@var3039 .@expr1073751025 isPointer (@expr1073751026 ) &&@expr1073751027 var@var3039 .@expr1073751028 type (@expr1073751029 ) ==@expr1073751030 derivedFrom@var3035 ) {
1857: baseClassPointers@var3038 .@expr1073751031 insert (@expr1073751032 var@var3039 .@expr1073751033 declarationId (@expr1073751034 ) ) ; }
1858: }
1859:
1860:
1861: std ::@expr1073751035 set < int > dontDelete@var3040 ;
1862:
1863:
1864: bool ok@var3041 ; ok@var3041 =@expr1073751036 true ;
1865:
1866: for (@expr1073751037 const Token *@expr9116 tok@var3042 =@expr1073751039 mTokenizer@var28 .@expr1073751040 tokens (@expr1073751041 ) ; tok@var3042 ; tok@var3042 =@expr1073751042 tok@var3042 .@expr9219 next (@expr9220 ) ) {
1867: if (@expr1073751045 Token ::@expr9222 Match (@expr1073751047 tok@var3042 , "[;{}] %var% =" ) &&@expr1073751048
1868: baseClassPointers@var3038 .@expr1073751049 find (@expr1073751050 tok@var3042 .@expr9219 next (@expr9220 ) .@expr9229 varId (@expr9230 ) ) !=@expr1073751055 baseClassPointers@var3038 .@expr1073751056 end (@expr1073751057 ) ) {
1869:
1870: const std ::@expr1073751058 string tmp@var3043 (@expr1073751059 "new " +@expr1073751060 derivedClass@var3031 .@expr9237 str (@expr9238 ) ) ;
1871: if (@expr1073751063 Token ::@expr1073751064 simpleMatch (@expr1073751065 tok@var3042 .@expr1073751066 tokAt (@expr1073751067 3 ) , tmp@var3043 .@expr1073751068 c_str (@expr1073751069 ) , tmp@var3043 .@expr1073751070 size (@expr1073751071 ) ) ) {
1872: dontDelete@var3040 .@expr1073751072 insert (@expr1073751073 tok@var3042 .@expr9219 next (@expr9220 ) .@expr9229 varId (@expr9230 ) ) ;
1873: }
1874: }
1875:
1876:
1877: else { if (@expr1073751078 Token ::@expr9222 Match (@expr1073751080 tok@var3042 , "delete %var% ;" ) &&@expr1073751081
1878: dontDelete@var3040 .@expr1073751082 find (@expr1073751083 tok@var3042 .@expr9219 next (@expr9220 ) .@expr9229 varId (@expr9230 ) ) !=@expr1073751088 dontDelete@var3040 .@expr1073751089 end (@expr1073751090 ) ) {
1879: ok@var3041 =@expr1073751091 false ;
1880: break ;
1881: } }
1882: }
1883:
1884:
1885: if (@expr1073751092 ok@var3041 ) {
1886: continue ; }
1887: }
1888:
1889:
1890: const Function * baseDestructor@var3044 ; baseDestructor@var3044 =@expr1073751093 derivedFromScope@var3036 .@expr1073751094 getDestructor (@expr1073751095 ) ;
1891:
1892:
1893: if (@expr1073751096 !@expr1073751097 baseDestructor@var3044 ) {
1894: if (@expr9274 derivedFrom@var3035 .@expr9275 derivedFrom@var3045 .@expr9276 empty (@expr9277 ) ) {
1895: virtualDestructorError (@expr1073751102 derivedFrom@var3035 .@expr1073751103 classDef@var3046 , derivedFrom@var3035 .@expr9280 name (@expr9281 ) , derivedClass@var3031 .@expr9237 str (@expr9238 ) , false ) ;
1896: }
1897: } else { if (@expr1073751108 !@expr1073751109 baseDestructor@var3044 .@expr1073751110 hasVirtualSpecifier (@expr1073751111 ) ) {
1898:
|
1903:
1904: if (@expr9274 derivedFrom@var3035 .@expr9275 derivedFrom@var3045 .@expr9276 empty (@expr9277 ) ) {
1905:
1906:
1907:
1908: if (@expr1073751116 baseDestructor@var3044 .@expr1073751117 access@var3047 ==@expr1073751118 AccessControl ::@expr9138 Public ) {
1909: virtualDestructorError (@expr1073751120 baseDestructor@var3044 .@expr1073751121 token@var3048 , derivedFrom@var3035 .@expr9280 name (@expr9281 ) , derivedClass@var3031 .@expr9237 str (@expr9238 ) , false ) ;
1910:
1911: const std ::@expr1073751126 list < const Function *@expr9116 > ::@expr1073751128 iterator found@var3049 =@expr1073751129 find (@expr1073751130 inconclusiveErrors@var3019 .@expr1073751131 begin (@expr1073751132 ) , inconclusiveErrors@var3019 .@expr9309 end (@expr9310 ) , baseDestructor@var3044 ) ;
1912: if (@expr1073751135 found@var3049 !=@expr1073751136 inconclusiveErrors@var3019 .@expr9309 end (@expr9310 ) ) {
1913: inconclusiveErrors@var3019 .@expr1073751139 erase (@expr1073751140 found@var3049 ) ; }
1914: }
1915: }
1916: } }
1917: }
1918: }
1919: }
1920:
1921: for (@expr1073751141 const Function *@expr9116 func@var3050 :@expr1073751143 inconclusiveErrors@var3019 ) {
1922: virtualDestructorError (@expr1073751144 func@var3050 .@expr1073751145 tokenDef@var3051 , func@var3050 .@expr1073751146 name (@expr1073751147 ) , emptyString@var1 , true ) ; }
1923: }
1924:
1925: void CheckClass :: virtualDestructorError ( const Token * tok@var3052 , const std :: string & Base@var3053 , const std :: string & Derived@var3054 , bool inconclusive@var3055 )
1926: {
1927: if (@expr1073751150 inconclusive@var3055 ) {
1928: if (@expr1073751151 mSettings@var29 .@expr1073751152 severity@var3441 .@expr1073751153 isEnabled (@expr1073751154 Severity ::@expr9331 warning ) ) {
1929: reportError (@expr1073751156 tok@var3052 , Severity ::@expr9331 warning , "virtualDestructor" , "$symbol:" +@expr9334 Base@var3053 +@expr1073751159 "\nClass '$symbol' which has virtual members does not have a virtual destructor." , CWE404@var2538 , Certainty ::@expr1073751160 inconclusive@expr1073751148 ) ; }
1930: } else {
1931: reportError (@expr1073751161 tok@var3052 , Severity ::@expr1073751162 error@expr1073751149 , "virtualDestructor" ,
1932: "$symbol:" +@expr9334 Base@var3053 +@expr1073751164 "\n$symbol:"
1933: +@expr1073751165 Derived@var3054 +@expr1073751166 "\nClass '"
1934: +@expr1073751167 Base@var3053 +@expr1073751168 "' which is inherited by class '" +@expr1073751169 Derived@var3054 +@expr1073751170 "' does not have a virtual destructor.\nClass '"
1935: +@expr1073751171 Base@var3053 +@expr1073751172 "' which is inherited by class '" +@expr1073751173 Derived@var3054 +@expr1073751174 "' does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class."
1936:
1937:
1938: , CWE404@var2538 , Certainty ::@expr1073751175 normal ) ;
1939: }
1940: }
1941:
|
1945:
1946: void CheckClass :: thisSubtraction ( )
1947: {
1948: if (@expr1073751176 !@expr1073751177 mSettings@var29 .@expr1073751178 severity@var3441 .@expr1073751179 isEnabled (@expr1073751180 Severity ::@expr1073751181 warning ) ) {
1949: return ; }
1950:
1951: const Token * tok@var3056 ; tok@var3056 =@expr1073751182 mTokenizer@var28 .@expr1073751183 tokens (@expr1073751184 ) ;
1952: for (@expr1073751185 ; ; ) {
1953: tok@var3056 =@expr1073751186 Token ::@expr1073751187 findmatch (@expr1073751188 tok@var3056 , "this - %name%" ) ;
1954: if (@expr1073751189 !@expr1073751190 tok@var3056 ) {
1955: break ; }
1956:
1957: if (@expr1073751191 tok@var3056 .@expr1073751192 strAt (@expr1073751193 -1 ) !=@expr1073751194 "*" ) {
1958: thisSubtractionError (@expr1073751195 tok@var3056 ) ; }
1959:
1960: tok@var3056 =@expr1073751196 tok@var3056 .@expr1073751197 next (@expr1073751198 ) ;
1961: }
1962: }
1963:
1964: void CheckClass :: thisSubtractionError ( const Token * tok@var3057 )
1965: {
1966: reportError (@expr1073751199 tok@var3057 , Severity ::@expr1073751200 warning , "thisSubtraction" , "Suspicious pointer subtraction. Did you intend to write '->'?" , CWE398@var2537 , Certainty ::@expr1073751201 normal ) ;
1967: }
1968:
|
1972:
1973: void CheckClass :: checkConst ( )
1974: {
1975:
1976: if (@expr1073751203 !@expr1073751204 mSettings@var29 .@expr1073751205 certainty@var3442 .@expr1073751206 isEnabled (@expr1073751207 Certainty ::@expr1073751208 inconclusive@expr1073751202 ) ) {
1977: return ; }
1978:
1979: if (@expr1073751209 !@expr1073751210 mSettings@var29 .@expr1073751211 severity@var3441 .@expr1073751212 isEnabled (@expr1073751213 Severity ::@expr1073751214 style ) ) {
1980: return ; }
1981:
1982: for (@expr1073751215 const Scope *@expr9392 scope@var3058 :@expr1073751217 mSymbolDatabase@var1666 .@expr1073751218 classAndStructScopes@var3443 ) {
1983: for (@expr1073751219 const Function &@expr9396 func@var3059 :@expr1073751221 scope@var3058 .@expr1073751222 functionList@var3060 ) {
1984:
1985: if (@expr1073751223 func@var3059 .@expr1073751224 type@var3061 !=@expr1073751225 Function ::@expr1073751226 eFunction ||@expr1073751227 !@expr1073751228 func@var3059 .@expr1073751229 hasBody (@expr1073751230 ) ) {
1986: continue ; }
1987:
1988: if (@expr1073751231 func@var3059 .@expr1073751232 isFriend (@expr1073751233 ) ||@expr1073751234 func@var3059 .@expr1073751235 isStatic (@expr1073751236 ) ||@expr1073751237 func@var3059 .@expr1073751238 hasVirtualSpecifier (@expr1073751239 ) ) {
1989: continue ; }
1990:
1991:
1992: auto isPointerOrReference@var3062 ; isPointerOrReference@var3062 =@expr1073751240 [@expr1073751241 this@expr1073751242 ] (@expr1073751243 const Token *@expr9392 start@var3063 , const Token *@expr9392 end@var3064 ) .@expr1073751246 bool {
1993: bool inTemplArgList@var3065 ; inTemplArgList@var3065 =@expr1073751247 false ; bool isConstTemplArg@var3066 ; isConstTemplArg@var3066 =@expr1073751248 false ;
1994: for (@expr1073751249 const Token *@expr9392 tok@var3067 =@expr1073751251 start@var3063 ; tok@var3067 !=@expr1073751252 end@var3064 ; tok@var3067 =@expr1073751253 tok@var3067 .@expr1073751254 next (@expr1073751255 ) ) {
1995: if (@expr1073751256 tok@var3067 .@expr9433 str (@expr9434 ) ==@expr1073751259 "{" ) {
1996: return false ; }
1997: if (@expr1073751260 tok@var3067 .@expr9433 str (@expr9434 ) ==@expr1073751263 "<" ) {
1998: if (@expr1073751264 !@expr1073751265 tok@var3067 .@expr1073751266 link (@expr1073751267 ) ) {
1999: mSymbolDatabase@var1666 .@expr1073751268 debugMessage (@expr1073751269 tok@var3067 , "debug" , "CheckClass::checkConst found unlinked template argument list '" +@expr1073751270 tok@var3067 .@expr1073751271 expressionString (@expr1073751272 ) +@expr1073751273 "'." ) ; }
2000: inTemplArgList@var3065 =@expr1073751274 true ;
2001: }
2002: else { if (@expr1073751275 tok@var3067 .@expr9433 str (@expr9434 ) ==@expr1073751278 ">" ) {
2003: inTemplArgList@var3065 =@expr1073751279 false ;
2004: isConstTemplArg@var3066 =@expr1073751280 false ;
2005: }
2006: else { if (@expr1073751281 tok@var3067 .@expr9433 str (@expr9434 ) ==@expr1073751284 "const" ) {
2007: if (@expr1073751285 !@expr1073751286 inTemplArgList@var3065 ) {
2008: return false ; }
2009: isConstTemplArg@var3066 =@expr1073751287 true ;
2010: }
2011: else { if (@expr1073751288 !@expr1073751289 isConstTemplArg@var3066 &&@expr1073751290 Token ::@expr1073751291 Match (@expr1073751292 tok@var3067 , "*|&" ) ) {
2012: return true ; } } } }
2013: }
2014: return false ;
2015: } ;
2016:
2017: const bool returnsPtrOrRef@var3068 =@expr1073751293 isPointerOrReference@var3062 (@expr1073751294 func@var3059 .@expr9471 retDef@var3069 , func@var3059 .@expr9472 tokenDef@var3070 ) ;
2018:
2019: if (@expr1073751297 func@var3059 .@expr9474 isOperator (@expr9475 ) ) {
2020: const std ::@expr1073751300 string &@expr9396 opName@var3071 =@expr1073751302 func@var3059 .@expr9472 tokenDef@var3070 .@expr9480 str (@expr9481 ) ;
2021: if (@expr1073751306 opName@var3071 .@expr1073751307 compare (@expr1073751308 8 , 5 , "const" ) !=@expr1073751309 0 &&@expr1073751310 (@expr1073751311 endsWith (@expr1073751312 opName@var3071 , '&' ) ||@expr1073751313 endsWith (@expr1073751314 opName@var3071 , '*' ) ) ) {
2022: continue ; }
2023: } else { if (@expr1073751315 mSettings@var29 .@expr1073751316 library@var3445 .@expr1073751317 isSmartPointer (@expr1073751318 func@var3059 .@expr9471 retDef@var3069 ) ) {
2024:
2025: continue ;
2026: } else {
2027:
2028:
2029: if (@expr1073751320 func@var3059 .@expr9471 retDef@var3069 .@expr1073751322 str (@expr1073751323 ) .@expr1073751324 size (@expr1073751325 ) >@expr1073751326 2 &&@expr1073751327 !@expr1073751328 func@var3059 .@expr9471 retDef@var3069 .@expr1073751330 type (@expr1073751331 ) &&@expr1073751332 func@var3059 .@expr9471 retDef@var3069 .@expr1073751334 isUpperCaseName (@expr1073751335 ) ) {
2030: continue ; }
2031: } }
2032:
2033:
2034: if (@expr1073751336 !@expr1073751337 scope@var3058 .@expr1073751338 definedType@var3072 .@expr1073751339 derivedFrom@var3073 .@expr1073751340 empty (@expr1073751341 ) &&@expr1073751342 func@var3059 .@expr1073751343 isImplicitlyVirtual (@expr1073751344 true ) ) {
2035: continue ; }
2036:
2037: bool memberAccessed@var3074 ; memberAccessed@var3074 =@expr1073751345 false ;
2038:
2039: if (@expr1073751346 !@expr1073751347 checkConstFunc (@expr1073751348 scope@var3058 , &@expr1073751349 func@var3059 , memberAccessed@var3074 ) ) {
2040: continue ; }
2041:
2042: const bool suggestStatic@var3075 =@expr1073751350 !@expr1073751351 memberAccessed@var3074 &&@expr1073751352 !@expr1073751353 func@var3059 .@expr9474 isOperator (@expr9475 ) ;
2043: if (@expr1073751356 (@expr1073751357 returnsPtrOrRef@var3068 ||@expr1073751358 func@var3059 .@expr1073751359 isConst (@expr1073751360 ) ) &&@expr1073751361 !@expr1073751362 suggestStatic@var3075 ) {
2044: continue ; }
2045:
2046: std ::@expr1073751363 string classname@var3076 ; classname@var3076 =@expr1073751364 scope@var3058 .@expr1073751365 className@var3077 ;
2047: const Scope * nest@var3078 ; nest@var3078 =@expr1073751366 scope@var3058 .@expr1073751367 nestedIn@var3079 ;
2048: while (@expr1073751368 nest@var3078 &&@expr1073751369 nest@var3078 .@expr1073751370 type@var3080 !=@expr1073751371 Scope ::@expr1073751372 eGlobal ) {
2049: classname@var3076 =@expr1073751373 std ::@expr1073751374 string (@expr1073751375 nest@var3078 .@expr1073751376 className@var3081 +@expr1073751377 "::" +@expr1073751378 classname@var3076 ) ;
2050: nest@var3078 =@expr1073751379 nest@var3078 .@expr1073751380 nestedIn@var3082 ;
2051: }
2052:
2053:
2054: std ::@expr1073751381 string functionName@var3083 ; functionName@var3083 =@expr1073751382 (@expr1073751383 func@var3059 .@expr9472 tokenDef@var3070 .@expr1073751385 isName (@expr1073751386 ) ?@expr1073751387 "" :@expr1073751388 "operator" ) +@expr1073751389 func@var3059 .@expr9472 tokenDef@var3070 .@expr9480 str (@expr9481 ) ;
2055:
2056: if (@expr1073751393 func@var3059 .@expr9472 tokenDef@var3070 .@expr9480 str (@expr9481 ) ==@expr1073751397 "(" ) {
2057: functionName@var3083 +=@expr1073751398 ")" ; }
2058: else { if (@expr1073751399 func@var3059 .@expr9472 tokenDef@var3070 .@expr9480 str (@expr9481 ) ==@expr1073751403 "[" ) {
2059: functionName@var3083 +=@expr1073751404 "]" ; } }
2060:
2061: if (@expr1073751405 func@var3059 .@expr1073751406 isInline (@expr1073751407 ) ) {
2062: checkConstError (@expr1073751408 func@var3059 .@expr9585 token@var3084 , classname@var3076 , functionName@var3083 , suggestStatic@var3075 ) ; }
2063: else {
2064: checkConstError2 (@expr1073751410 func@var3059 .@expr9585 token@var3084 , func@var3059 .@expr9472 tokenDef@var3070 , classname@var3076 , functionName@var3083 , suggestStatic@var3075 ) ; }
2065: }
2066: }
2067: }
2068:
2069: bool CheckClass :: isMemberVar ( const Scope * scope@var3085 , const Token * tok@var3086 ) const
2070: {
2071: bool again@var3087 ; again@var3087 =@expr1073751413 false ;
2072:
2073:
2074: do {
2075: again@var3087 =@expr1073751414 false ;
2076:
2077: if (@expr1073751415 tok@var3086 .@expr9592 str (@expr9593 ) ==@expr1073751418 "this" ) {
2078: return true ;
2079: } else { if (@expr1073751419 Token ::@expr1073751420 simpleMatch (@expr1073751421 tok@var3086 .@expr9598 tokAt (@expr9599 -3 ) , "( * this )" ) ) {
2080: return true ;
2081: } else { if (@expr1073751424 Token ::@expr9601 Match (@expr1073751426 tok@var3086 .@expr9598 tokAt (@expr9599 -3 ) , "%name% ) . %name%" ) ) {
2082: tok@var3086 =@expr1073751429 tok@var3086 .@expr9598 tokAt (@expr9599 -3 ) ;
2083: again@var3087 =@expr1073751432 true ;
2084: } else { if (@expr1073751433 Token ::@expr9601 Match (@expr1073751435 tok@var3086 .@expr9598 tokAt (@expr9613 -2 ) , "%name% . %name%" ) ) {
2085: tok@var3086 =@expr1073751438 tok@var3086 .@expr9598 tokAt (@expr9613 -2 ) ;
2086: again@var3087 =@expr1073751441 true ;
2087: } else { if (@expr1073751442 Token ::@expr9601 Match (@expr1073751444 tok@var3086 .@expr9598 tokAt (@expr9613 -2 ) , "] . %name%" ) ) {
2088: tok@var3086 =@expr1073751447 tok@var3086 .@expr1073751448 linkAt (@expr1073751449 -2 ) .@expr1073751450 previous (@expr1073751451 ) ;
2089: again@var3087 =@expr1073751452 true ;
2090: } else { if (@expr1073751453 tok@var3086 .@expr9592 str (@expr9593 ) ==@expr1073751456 "]" ) {
2091: tok@var3086 =@expr1073751457 tok@var3086 .@expr1073751458 link (@expr1073751459 ) .@expr1073751460 previous (@expr1073751461 ) ;
2092: again@var3087 =@expr1073751462 true ;
2093: } } } } } }
2094: } while (@expr1073751463 again@var3087 ) ;
2095:
2096: for (@expr1073751464 const Variable &@expr9641 var@var3088 :@expr1073751466 scope@var3085 .@expr1073751467 varlist@var3089 ) {
2097: if (@expr1073751468 var@var3088 .@expr1073751469 name (@expr1073751470 ) ==@expr1073751471 tok@var3086 .@expr9592 str (@expr9593 ) ) {
2098: if (@expr1073751474 Token ::@expr9601 Match (@expr1073751476 tok@var3086 , "%name% ::" ) ) {
2099: continue ; }
2100: const Token * fqTok@var3090 ; fqTok@var3090 =@expr1073751477 tok@var3086 ;
2101: while (@expr1073751478 Token ::@expr9601 Match (@expr1073751480 fqTok@var3090 .@expr9657 tokAt (@expr9658 -2 ) , "%name% ::" ) ) {
2102: fqTok@var3090 =@expr1073751483 fqTok@var3090 .@expr9657 tokAt (@expr9658 -2 ) ; }
2103: if (@expr1073751486 fqTok@var3090 .@expr1073751487 strAt (@expr1073751488 -1 ) ==@expr1073751489 "::" ) {
2104: fqTok@var3090 =@expr1073751490 fqTok@var3090 .@expr1073751491 previous (@expr1073751492 ) ; }
2105: bool isMember@var3091 ; isMember@var3091 =@expr1073751493 tok@var3086 ==@expr1073751494 fqTok@var3090 ;
2106: std ::@expr1073751495 string scopeStr@var3092 ;
2107: const Scope * curScope@var3093 ; curScope@var3093 =@expr1073751496 scope@var3085 ;
2108: while (@expr1073751497 !@expr1073751498 isMember@var3091 &&@expr1073751499 curScope@var3093 &&@expr1073751500 curScope@var3093 .@expr1073751501 type@var3094 !=@expr1073751502 Scope ::@expr1073751503 ScopeType ::@expr1073751504 eGlobal ) {
2109: scopeStr@var3092 .@expr1073751505 insert (@expr1073751506 0 , curScope@var3093 .@expr1073751507 className@var3095 +@expr1073751508 " :: " ) ;
2110: isMember@var3091 =@expr1073751509 Token ::@expr9601 Match (@expr1073751511 fqTok@var3090 , scopeStr@var3092 .@expr1073751512 c_str (@expr1073751513 ) ) ;
2111:
2112: curScope@var3093 =@expr1073751514 curScope@var3093 .@expr1073751515 nestedIn@var3096 ;
2113: }
2114: if (@expr1073751516 isMember@var3091 ) {
2115: if (@expr1073751517 tok@var3086 .@expr1073751518 varId (@expr1073751519 ) ==@expr1073751520 0 ) {
2116: mSymbolDatabase@var1666 .@expr1073751521 debugMessage (@expr1073751522 tok@var3086 , "varid0" , "CheckClass::isMemberVar found used member variable \'" +@expr1073751523 tok@var3086 .@expr9592 str (@expr9593 ) +@expr1073751526 "\' with varid 0" ) ; }
2117:
2118: return !@expr1073751527 var@var3088 .@expr1073751528 isStatic (@expr1073751529 ) ;
2119: }
2120: }
2121: }
2122:
2123:
2124: if (@expr1073751530 !@expr1073751531 scope@var3085 .@expr9708 definedType@var3097 .@expr9709 derivedFrom@var3098 .@expr1073751534 empty (@expr1073751535 ) ) {
2125:
2126: for (@expr1073751536 const Type ::@expr1073751537 BaseInfo &@expr9641 i@var3099 :@expr1073751539 scope@var3085 .@expr9708 definedType@var3097 .@expr9709 derivedFrom@var3098 ) {
2127:
2128: const Type * derivedFrom@var3100 ; derivedFrom@var3100 =@expr1073751542 i@var3099 .@expr1073751543 type@var3101 ;
2129:
2130:
2131: if (@expr1073751544 derivedFrom@var3100 &&@expr1073751545 derivedFrom@var3100 .@expr9722 classScope@var3102 &&@expr1073751547 derivedFrom@var3100 .@expr9722 classScope@var3102 !=@expr1073751549 scope@var3085 ) {
2132: if (@expr1073751550 isMemberVar (@expr1073751551 derivedFrom@var3100 .@expr9722 classScope@var3102 , tok@var3086 ) ) {
2133: return true ; }
2134: }
2135: }
2136: }
2137:
2138: return false ;
2139: }
2140:
2141: bool CheckClass :: isMemberFunc ( const Scope * scope@var3103 , const Token * tok@var3104 ) const
2142: {
2143: if (@expr1073751553 !@expr1073751554 tok@var3104 .@expr9731 function (@expr9732 ) ) {
2144: for (@expr1073751557 const Function &@expr9734 func@var3105 :@expr1073751559 scope@var3103 .@expr1073751560 functionList@var3106 ) {
2145: if (@expr1073751561 func@var3105 .@expr1073751562 name (@expr1073751563 ) ==@expr1073751564 tok@var3104 .@expr1073751565 str (@expr1073751566 ) ) {
2146: const Token * tok2@var3107 ; tok2@var3107 =@expr1073751567 tok@var3104 .@expr1073751568 tokAt (@expr1073751569 2 ) ;
2147: int argsPassed@var3108 ; argsPassed@var3108 =@expr1073751570 tok2@var3107 .@expr1073751571 str (@expr1073751572 ) ==@expr1073751573 ")" ?@expr1073751574 0 :@expr1073751575 1 ;
2148: for (@expr1073751576 ; ; ) {
2149: tok2@var3107 =@expr1073751577 tok2@var3107 .@expr1073751578 nextArgument (@expr1073751579 ) ;
2150: if (@expr1073751580 tok2@var3107 ) {
2151: argsPassed@var3108 ++@expr1073751581 ; }
2152: else {
2153: break ; }
2154: }
2155: if (@expr1073751582 argsPassed@var3108 ==@expr1073751583 func@var3105 .@expr9760 argCount (@expr9761 ) ||@expr1073751586
2156: (@expr1073751587 func@var3105 .@expr1073751588 isVariadic (@expr1073751589 ) &&@expr1073751590 argsPassed@var3108 >=@expr1073751591 (@expr1073751592 func@var3105 .@expr9760 argCount (@expr9761 ) -@expr1073751595 1 ) ) ||@expr1073751596
2157: (@expr1073751597 argsPassed@var3108 <@expr1073751598 func@var3105 .@expr9760 argCount (@expr9761 ) &&@expr1073751601 argsPassed@var3108 >=@expr1073751602 func@var3105 .@expr1073751603 minArgCount (@expr1073751604 ) ) ) {
2158: return true ; }
2159: }
2160: }
2161: } else { if (@expr1073751605 tok@var3104 .@expr9731 function (@expr9732 ) .@expr1073751608 nestedIn@var3468 ==@expr1073751609 scope@var3103 ) {
2162: return !@expr1073751610 tok@var3104 .@expr9731 function (@expr9732 ) .@expr1073751613 isStatic (@expr1073751614 ) ; } }
2163:
2164:
2165: if (@expr1073751615 !@expr1073751616 scope@var3103 .@expr9793 definedType@var3109 .@expr9794 derivedFrom@var3110 .@expr1073751619 empty (@expr1073751620 ) ) {
2166:
2167: for (@expr1073751621 const Type ::@expr1073751622 BaseInfo &@expr9734 i@var3111 :@expr1073751624 scope@var3103 .@expr9793 definedType@var3109 .@expr9794 derivedFrom@var3110 ) {
2168:
2169: const Type * derivedFrom@var3112 ; derivedFrom@var3112 =@expr1073751627 i@var3111 .@expr1073751628 type@var3113 ;
2170:
2171:
2172: if (@expr1073751629 derivedFrom@var3112 &&@expr1073751630 derivedFrom@var3112 .@expr9807 classScope@var3114 &&@expr1073751632 derivedFrom@var3112 .@expr9807 classScope@var3114 !=@expr1073751634 scope@var3103 ) {
2173: if (@expr1073751635 isMemberFunc (@expr1073751636 derivedFrom@var3112 .@expr9807 classScope@var3114 , tok@var3104 ) ) {
2174: return true ; }
2175: }
2176: }
2177: }
2178:
2179: return false ;
2180: }
2181:
2182: bool CheckClass :: isConstMemberFunc ( const Scope * scope@var3115 , const Token * tok@var3116 ) const
2183: {
2184: if (@expr1073751638 !@expr1073751639 tok@var3116 .@expr9816 function (@expr9817 ) ) {
2185: return false ; }
2186: else { if (@expr1073751642 tok@var3116 .@expr9816 function (@expr9817 ) .@expr1073751645 nestedIn@var3468 ==@expr1073751646 scope@var3115 ) {
2187: return tok@var3116 .@expr9816 function (@expr9817 ) .@expr1073751649 isConst (@expr1073751650 ) ; } }
2188:
2189:
2190: if (@expr1073751651 !@expr1073751652 scope@var3115 .@expr9829 definedType@var3117 .@expr9830 derivedFrom@var3118 .@expr1073751655 empty (@expr1073751656 ) ) {
2191:
2192: for (@expr1073751657 const Type ::@expr1073751658 BaseInfo &@expr1073751659 i@var3119 :@expr1073751660 scope@var3115 .@expr9829 definedType@var3117 .@expr9830 derivedFrom@var3118 ) {
2193:
2194: const Type * derivedFrom@var3120 ; derivedFrom@var3120 =@expr1073751663 i@var3119 .@expr1073751664 type@var3121 ;
2195:
2196:
2197: if (@expr1073751665 derivedFrom@var3120 &&@expr1073751666 derivedFrom@var3120 .@expr9843 classScope@var3122 ) {
2198: if (@expr1073751668 isConstMemberFunc (@expr1073751669 derivedFrom@var3120 .@expr9843 classScope@var3122 , tok@var3116 ) ) {
2199: return true ; }
2200: }
2201: }
2202: }
2203:
2204: return false ;
2205: }
2206:
2207: const std :: set < std :: string > CheckClass :: stl_containers_not_const@var1665 = { "map" , "unordered_map" } ;
2208:
2209: bool CheckClass :: checkConstFunc ( const Scope * scope@var3123 , const Function * func@var3124 , bool & memberAccessed@var3125 ) const
2210: {
2211: if (@expr1073751671 mTokenizer@var28 .@expr1073751672 hasIfdef (@expr1073751673 func@var3124 .@expr9850 functionScope@var3126 .@expr9851 bodyStart@var3127 , func@var3124 .@expr9850 functionScope@var3126 .@expr9853 bodyEnd@var3128 ) ) {
2212: return false ; }
2213:
2214:
2215:
2216: for (@expr1073751678 const Token *@expr9855 tok1@var3129 =@expr1073751680 func@var3124 .@expr9850 functionScope@var3126 .@expr9851 bodyStart@var3127 ; tok1@var3129 &&@expr1073751683 tok1@var3129 !=@expr1073751684 func@var3124 .@expr9850 functionScope@var3126 .@expr9853 bodyEnd@var3128 ; tok1@var3129 =@expr1073751687 tok1@var3129 .@expr9864 next (@expr9865 ) ) {
2217: if (@expr1073751690 tok1@var3129 .@expr1073751691 isName (@expr1073751692 ) &&@expr1073751693 isMemberVar (@expr1073751694 scope@var3123 , tok1@var3129 ) ) {
2218: memberAccessed@var3125 =@expr1073751695 true ;
2219: const Variable * v@var3130 ; v@var3130 =@expr1073751696 tok1@var3129 .@expr1073751697 variable (@expr1073751698 ) ;
2220: if (@expr1073751699 v@var3130 &&@expr1073751700 v@var3130 .@expr1073751701 isMutable (@expr1073751702 ) ) {
2221: continue ; }
2222:
2223: if (@expr1073751703 tok1@var3129 .@expr1073751704 str (@expr1073751705 ) ==@expr1073751706 "this" ) {
2224: if (@expr1073751707 tok1@var3129 .@expr9884 previous (@expr9885 ) .@expr9886 isAssignmentOp (@expr9887 ) ) {
2225: return false ; }
2226: if (@expr1073751712 Token ::@expr9889 Match (@expr1073751714 tok1@var3129 .@expr9884 previous (@expr9885 ) , "( this . * %var% )" ) ) {
2227: return false ; }
2228: }
2229:
2230:
2231: if (@expr1073751717 tok1@var3129 .@expr9894 valueType (@expr9895 ) &&@expr1073751720 tok1@var3129 .@expr9894 valueType (@expr9895 ) .@expr1073751723 pointer@var3465 >@expr1073751724 0 &&@expr1073751725 tok1@var3129 .@expr9902 astParent (@expr9903 ) &&@expr1073751728 tok1@var3129 .@expr9902 astParent (@expr9903 ) .@expr1073751731 isCast (@expr1073751732 ) &&@expr1073751733 !@expr1073751734 Token ::@expr9911 simpleMatch (@expr1073751736 tok1@var3129 .@expr9902 astParent (@expr9903 ) , "( const" ) ) {
2232: return false ; }
2233:
2234: const Token * lhs@var3131 ; lhs@var3131 =@expr1073751739 tok1@var3129 .@expr9884 previous (@expr9885 ) ;
2235: if (@expr1073751742 lhs@var3131 .@expr9919 str (@expr9920 ) ==@expr1073751745 "(" &&@expr1073751746 tok1@var3129 .@expr9902 astParent (@expr9903 ) &&@expr1073751749 tok1@var3129 .@expr9902 astParent (@expr9903 ) .@expr9928 astParent (@expr9929 ) ) {
2236: lhs@var3131 =@expr1073751754 tok1@var3129 .@expr9902 astParent (@expr9903 ) .@expr9928 astParent (@expr9929 ) ; }
2237: if (@expr1073751759 lhs@var3131 .@expr9919 str (@expr9920 ) ==@expr1073751762 "&" ) {
2238: lhs@var3131 =@expr1073751763 lhs@var3131 .@expr9940 previous (@expr9941 ) ;
2239: if (@expr1073751766 lhs@var3131 .@expr9943 isAssignmentOp (@expr9944 ) &&@expr1073751769 lhs@var3131 .@expr9940 previous (@expr9941 ) .@expr9948 variable (@expr9949 ) ) {
2240: if (@expr1073751774 lhs@var3131 .@expr9940 previous (@expr9941 ) .@expr9948 variable (@expr9949 ) .@expr1073751779 typeStartToken (@expr1073751780 ) .@expr1073751781 strAt (@expr1073751782 -1 ) !=@expr1073751783 "const" &&@expr1073751784 lhs@var3131 .@expr9940 previous (@expr9941 ) .@expr9948 variable (@expr9949 ) .@expr1073751789 isPointer (@expr1073751790 ) ) {
2241: return false ; }
2242: }
2243: } else { if (@expr1073751791 lhs@var3131 .@expr9919 str (@expr9920 ) ==@expr1073751794 ":" &&@expr1073751795 lhs@var3131 .@expr9972 astParent (@expr9973 ) &&@expr1073751798 lhs@var3131 .@expr9972 astParent (@expr9973 ) .@expr1073751801 str (@expr1073751802 ) ==@expr1073751803 "(" ) {
2244:
2245: if (@expr1073751804 lhs@var3131 .@expr9972 astParent (@expr9973 ) .@expr1073751807 strAt (@expr1073751808 1 ) !=@expr1073751809 "const" ) {
2246: return false ; }
2247: } else {
2248: if (@expr1073751810 lhs@var3131 .@expr9943 isAssignmentOp (@expr9944 ) ) {
2249: const Variable * lhsVar@var3132 ; lhsVar@var3132 =@expr1073751813 lhs@var3131 .@expr9940 previous (@expr9941 ) .@expr9948 variable (@expr9949 ) ;
2250: if (@expr1073751818 lhsVar@var3132 &&@expr1073751819 !@expr1073751820 lhsVar@var3132 .@expr1073751821 isConst (@expr1073751822 ) &&@expr1073751823 lhsVar@var3132 .@expr1073751824 isReference (@expr1073751825 ) &&@expr1073751826 lhs@var3131 ==@expr1073751827 lhsVar@var3132 .@expr1073751828 nameToken (@expr1073751829 ) .@expr1073751830 next (@expr1073751831 ) ) {
2251: return false ; }
2252: }
2253: } }
2254:
2255: const Token * jumpBackToken@var3133 ; jumpBackToken@var3133 =@expr1073751832 nullptr ;
2256: const Token * lastVarTok@var3134 ; lastVarTok@var3134 =@expr1073751833 tok1@var3129 ;
2257: const Token * end@var3135 ; end@var3135 =@expr1073751834 tok1@var3129 ;
2258: for (@expr1073751835 ; ; ) {
2259: if (@expr1073751836 Token ::@expr9889 Match (@expr1073751838 end@var3135 .@expr10015 next (@expr10016 ) , ". %name%" ) ) {
2260: end@var3135 =@expr1073751841 end@var3135 .@expr1073751842 tokAt (@expr1073751843 2 ) ;
2261: if (@expr10020 end@var3135 .@expr10021 varId (@expr10022 ) ) {
2262: lastVarTok@var3134 =@expr1073751847 end@var3135 ; }
2263: } else { if (@expr1073751848 end@var3135 .@expr10025 strAt (@expr10026 1 ) ==@expr1073751851 "[" ) {
2264: if (@expr10020 end@var3135 .@expr10021 varId (@expr10022 ) ) {
2265: const Variable * var@var3136 ; var@var3136 =@expr1073751855 end@var3135 .@expr1073751856 variable (@expr1073751857 ) ;
2266: if (@expr1073751858 var@var3136 &&@expr1073751859 var@var3136 .@expr1073751860 isStlType (@expr1073751861 stl_containers_not_const@var1665 ) ) {
2267: return false ; }
2268: const Token * assignTok@var3137 ; assignTok@var3137 =@expr1073751862 end@var3135 .@expr10015 next (@expr10016 ) .@expr1073751865 astParent (@expr1073751866 ) ;
2269: if (@expr1073751867 var@var3136 &&@expr1073751868 assignTok@var3137 &&@expr1073751869 assignTok@var3137 .@expr1073751870 isAssignmentOp (@expr1073751871 ) &&@expr1073751872 assignTok@var3137 .@expr10049 astOperand1 (@expr10050 ) &&@expr1073751875 assignTok@var3137 .@expr10049 astOperand1 (@expr10050 ) .@expr10054 variable (@expr10055 ) ) {
2270: const Variable * assignVar@var3138 ; assignVar@var3138 =@expr1073751880 assignTok@var3137 .@expr10049 astOperand1 (@expr10050 ) .@expr10054 variable (@expr10055 ) ;
2271: if (@expr1073751885 assignVar@var3138 .@expr1073751886 isPointer (@expr1073751887 ) &&@expr1073751888 !@expr1073751889 assignVar@var3138 .@expr1073751890 isConst (@expr1073751891 ) &&@expr1073751892 var@var3136 .@expr10069 typeScope (@expr10070 ) ) {
2272: const auto &@expr10071 funcMap@var3139 =@expr1073751896 var@var3136 .@expr10069 typeScope (@expr10070 ) .@expr1073751899 functionMap@var3471 ;
2273:
2274: if (@expr1073751900 std ::@expr1073751901 none_of (@expr1073751902 funcMap@var3139 .@expr1073751903 begin (@expr1073751904 ) , funcMap@var3139 .@expr1073751905 end (@expr1073751906 ) , [@expr1073751907 ] (@expr1073751908 const std ::@expr10085 pair < std ::@expr10085 string , const Function *@expr9855 > &@expr10071 fm@var3140 ) {
2275: return fm@var3140 .@expr10089 second@var3141 .@expr1073751914 isConst (@expr1073751915 ) &&@expr1073751916 fm@var3140 .@expr1073751917 first@var3142 ==@expr1073751918 "operator[]" &&@expr1073751919 !@expr1073751920 Function ::@expr1073751921 returnsConst (@expr1073751922 fm@var3140 .@expr10089 second@var3141 ) ;
2276: } ) ) {
2277: return false ; }
2278: }
2279: }
2280: }
2281: if (@expr1073751924 !@expr1073751925 jumpBackToken@var3133 ) {
2282: jumpBackToken@var3133 =@expr1073751926 end@var3135 .@expr10015 next (@expr10016 ) ; }
2283: end@var3135 =@expr1073751929 end@var3135 .@expr1073751930 linkAt (@expr1073751931 1 ) ;
2284: } else { if (@expr1073751932 end@var3135 .@expr10025 strAt (@expr10026 1 ) ==@expr1073751935 ")" ) {
2285: end@var3135 =@expr1073751936 end@var3135 .@expr10015 next (@expr10016 ) ; }
2286: else {
2287: break ; } } }
2288: }
2289:
2290: if (@expr1073751939 end@var3135 .@expr10025 strAt (@expr10026 1 ) ==@expr1073751942 "(" ) {
2291: const Variable * var@var3143 ; var@var3143 =@expr1073751943 lastVarTok@var3134 .@expr1073751944 variable (@expr1073751945 ) ;
2292: if (@expr1073751946 !@expr1073751947 var@var3143 ) {
2293: return false ; }
2294: if (@expr1073751948 (@expr1073751949 var@var3143 .@expr1073751950 isStlType (@expr1073751951 )
2295: &&@expr1073751952 (@expr1073751953 Token ::@expr9889 Match (@expr1073751955 end@var3135 , "size|empty|cend|crend|cbegin|crbegin|max_size|length|count|capacity|get_allocator|c_str|str ( )" ) ||@expr1073751956 Token ::@expr9889 Match (@expr1073751958 end@var3135 , "rfind|copy" ) ) ) ||@expr1073751959
2296:
2297: (@expr1073751960 lastVarTok@var3134 .@expr10137 valueType (@expr10138 ) &&@expr1073751963 lastVarTok@var3134 .@expr10137 valueType (@expr10138 ) .@expr10142 container@var3472 &&@expr1073751967
2298: (@expr1073751968 (@expr1073751969 lastVarTok@var3134 .@expr10137 valueType (@expr10138 ) .@expr10142 container@var3472 .@expr10149 getYield (@expr10150 end@var3135 .@expr10151 str (@expr10152 ) ) ==@expr1073751977 Library ::@expr10154 Container ::@expr10155 Yield ::@expr1073751980 START_ITERATOR ) ||@expr1073751981
2299: (@expr1073751982 lastVarTok@var3134 .@expr10137 valueType (@expr10138 ) .@expr10142 container@var3472 .@expr10149 getYield (@expr10150 end@var3135 .@expr10151 str (@expr10152 ) ) ==@expr1073751990 Library ::@expr10154 Container ::@expr10155 Yield ::@expr1073751993 END_ITERATOR ) )
2300: &&@expr1073751994 (@expr1073751995 tok1@var3129 .@expr9884 previous (@expr9885 ) .@expr1073751998 isComparisonOp (@expr1073751999 ) ||@expr1073752000
2301: (@expr1073752001 tok1@var3129 .@expr9884 previous (@expr9885 ) .@expr9886 isAssignmentOp (@expr9887 ) &&@expr1073752006 tok1@var3129 .@expr10183 tokAt (@expr10184 -2 ) .@expr10185 variable (@expr10186 ) &&@expr1073752011 Token ::@expr9889 Match (@expr1073752013 tok1@var3129 .@expr10183 tokAt (@expr10184 -2 ) .@expr10185 variable (@expr10186 ) .@expr1073752018 typeEndToken (@expr1073752019 ) , "const_iterator|const_reverse_iterator" ) ) ) ) ) {
2302: ; }
2303: else { if (@expr1073752020 !@expr1073752021 var@var3143 .@expr10198 typeScope (@expr10199 ) ||@expr1073752024 !@expr1073752025 isConstMemberFunc (@expr1073752026 var@var3143 .@expr10198 typeScope (@expr10199 ) , end@var3135 ) ) {
2304: return false ; } }
2305: }
2306:
2307:
2308: else { if (@expr1073752029 end@var3135 .@expr10015 next (@expr10016 ) .@expr1073752032 isAssignmentOp (@expr1073752033 ) ) {
2309: return false ; }
2310:
2311:
2312: else { if (@expr1073752034 end@var3135 .@expr10025 strAt (@expr10026 1 ) ==@expr1073752037 "<<" &&@expr1073752038 tok1@var3129 .@expr10215 strAt (@expr10216 -1 ) !=@expr1073752041 "<<" ) {
2313: return false ; }
2314: else { if (@expr1073752042 isLikelyStreamRead (@expr1073752043 true , tok1@var3129 .@expr9884 previous (@expr9885 ) ) ) {
2315: return false ; }
2316:
2317:
2318: else { if (@expr1073752046 end@var3135 .@expr10015 next (@expr10016 ) .@expr1073752049 tokType (@expr1073752050 ) ==@expr1073752051 Token ::@expr10228 eIncDecOp ||@expr1073752053 tok1@var3129 .@expr9884 previous (@expr9885 ) .@expr1073752056 tokType (@expr1073752057 ) ==@expr1073752058 Token ::@expr10228 eIncDecOp ) {
2319: return false ; } } } } }
2320:
2321:
2322: const Token * start@var3144 ; start@var3144 =@expr1073752060 tok1@var3129 ;
2323: while (@expr1073752061 tok1@var3129 .@expr10215 strAt (@expr10216 -1 ) ==@expr1073752064 ")" ) {
2324: tok1@var3129 =@expr1073752065 tok1@var3129 .@expr1073752066 linkAt (@expr1073752067 -1 ) ; }
2325:
2326: if (@expr1073752068 start@var3144 .@expr1073752069 strAt (@expr1073752070 -1 ) ==@expr1073752071 "delete" ) {
2327: return false ; }
2328:
2329: tok1@var3129 =@expr1073752072 jumpBackToken@var3133 ?@expr1073752073 jumpBackToken@var3133 :@expr1073752074 end@var3135 ;
2330: if (@expr1073752075 tok1@var3129 ==@expr1073752076 end@var3135 &&@expr1073752077 Token ::@expr9889 Match (@expr1073752079 end@var3135 .@expr1073752080 previous (@expr1073752081 ) , ". %name% ( !!)" ) ) {
2331: tok1@var3129 =@expr1073752082 tok1@var3129 .@expr9884 previous (@expr9885 ) ; }
2332: }
2333:
2334:
2335: else { if (@expr1073752085 Token ::@expr9911 simpleMatch (@expr1073752087 tok1@var3129 .@expr9884 previous (@expr9885 ) , ") <<" ) &&@expr1073752090
2336: isMemberVar (@expr1073752091 scope@var3123 , tok1@var3129 .@expr10183 tokAt (@expr10184 -2 ) ) ) {
2337: const Variable * var@var3145 ; var@var3145 =@expr1073752094 tok1@var3129 .@expr10183 tokAt (@expr10184 -2 ) .@expr10185 variable (@expr10186 ) ;
2338: if (@expr1073752099 !@expr1073752100 var@var3145 ||@expr1073752101 !@expr1073752102 var@var3145 .@expr1073752103 isMutable (@expr1073752104 ) ) {
2339: return false ; }
2340: }
2341:
2342:
2343: else { if (@expr1073752105 Token ::@expr9911 simpleMatch (@expr1073752107 tok1@var3129 , ">> * this" ) &&@expr1073752108 isLikelyStreamRead (@expr1073752109 true , tok1@var3129 ) ) {
2344: return false ;
2345: }
2346:
2347:
2348: else { if (@expr1073752110 (@expr1073752111 Token ::@expr9889 Match (@expr1073752113 tok1@var3129 , "%name% (|{" ) ||@expr1073752114 Token ::@expr9911 simpleMatch (@expr1073752116 tok1@var3129 .@expr9902 astParent (@expr9903 ) , "return {" ) ) &&@expr1073752119 !@expr1073752120 tok1@var3129 .@expr1073752121 isStandardType (@expr1073752122 ) &&@expr1073752123
2349: !@expr1073752124 Token ::@expr9889 Match (@expr1073752126 tok1@var3129 , "return|if|string|switch|while|catch|for" ) ) {
2350: if (@expr1073752127 isMemberFunc (@expr1073752128 scope@var3123 , tok1@var3129 ) &&@expr1073752129 tok1@var3129 .@expr10215 strAt (@expr10216 -1 ) !=@expr1073752132 "." ) {
2351: if (@expr1073752133 !@expr1073752134 isConstMemberFunc (@expr1073752135 scope@var3123 , tok1@var3129 ) ) {
2352: return false ; }
2353: memberAccessed@var3125 =@expr1073752136 true ;
2354: }
2355:
2356: const Token * lpar@var3146 ; lpar@var3146 =@expr1073752137 tok1@var3129 .@expr9864 next (@expr9865 ) ;
2357: if (@expr1073752140 Token ::@expr9911 simpleMatch (@expr1073752142 lpar@var3146 , "( ) (" ) ) {
2358: lpar@var3146 =@expr1073752143 lpar@var3146 .@expr1073752144 tokAt (@expr1073752145 2 ) ; }
2359: for (@expr1073752146 const Token *@expr9855 tok2@var3147 =@expr1073752148 lpar@var3146 .@expr1073752149 next (@expr1073752150 ) ; tok2@var3147 &&@expr1073752151 tok2@var3147 !=@expr1073752152 tok1@var3129 .@expr9864 next (@expr9865 ) .@expr1073752155 link (@expr1073752156 ) ; tok2@var3147 =@expr1073752157 tok2@var3147 .@expr1073752158 next (@expr1073752159 ) ) {
2360: if (@expr1073752160 tok2@var3147 .@expr1073752161 str (@expr1073752162 ) ==@expr1073752163 "(" ) {
2361: tok2@var3147 =@expr1073752164 tok2@var3147 .@expr1073752165 link (@expr1073752166 ) ; }
2362: else { if (@expr1073752167 (@expr1073752168 tok2@var3147 .@expr1073752169 isName (@expr1073752170 ) &&@expr1073752171 isMemberVar (@expr1073752172 scope@var3123 , tok2@var3147 ) ) ||@expr1073752173 (@expr1073752174 tok2@var3147 .@expr1073752175 isUnaryOp (@expr1073752176 "&" ) &&@expr1073752177 (@expr1073752178 tok2@var3147 =@expr1073752179 tok2@var3147 .@expr1073752180 astOperand1 (@expr1073752181 ) ) ) ) {
2363: const Variable * var@var3148 ; var@var3148 =@expr1073752182 tok2@var3147 .@expr1073752183 variable (@expr1073752184 ) ;
2364: if (@expr1073752185 !@expr1073752186 var@var3148 ||@expr1073752187 !@expr1073752188 var@var3148 .@expr1073752189 isMutable (@expr1073752190 ) ) {
2365: return false ; }
2366: } }
2367: }
2368: } else { if (@expr1073752191 Token ::@expr9911 simpleMatch (@expr1073752193 tok1@var3129 , "> (" ) &&@expr1073752194 (@expr1073752195 !@expr1073752196 tok1@var3129 .@expr10373 link (@expr10374 ) ||@expr1073752199 !@expr1073752200 Token ::@expr9889 Match (@expr1073752202 tok1@var3129 .@expr10373 link (@expr10374 ) .@expr1073752205 previous (@expr1073752206 ) , "static_cast|const_cast|dynamic_cast|reinterpret_cast" ) ) ) {
2369: return false ;
2370: } } } } }
2371: }
2372:
2373: return true ;
2374: }
2375:
2376: void CheckClass :: checkConstError ( const Token * tok@var3149 , const std :: string & classname@var3150 , const std :: string & funcname@var3151 , bool suggestStatic@var3152 )
2377: {
2378: checkConstError2 (@expr1073752207 tok@var3149 , nullptr , classname@var3150 , funcname@var3151 , suggestStatic@var3152 ) ;
2379: }
2380:
2381: void CheckClass :: checkConstError2 ( const Token * tok1@var3153 , const Token * tok2@var3154 , const std :: string & classname@var3155 , const std :: string & funcname@var3156 , bool suggestStatic@var3157 )
2382: {
2383: std ::@expr1073752209 list < const Token *@expr1073752210 > toks@var3158 ;
2384: toks@var3158 .@expr10387 push_back (@expr1073752212 tok1@var3153 ) ;
2385: if (@expr1073752213 tok2@var3154 ) {
2386: toks@var3158 .@expr10387 push_back (@expr1073752215 tok2@var3154 ) ; }
2387: if (@expr1073752216 !@expr1073752217 suggestStatic@var3157 ) {
2388: reportError (@expr1073752218 toks@var3158 , Severity ::@expr1073752219 style , "functionConst" ,
2389: "$symbol:" +@expr10396 classname@var3155 +@expr10397 "::" +@expr10398 funcname@var3156 +@expr1073752223 "\nTechnically the member function '$symbol' can be const.\nThe member function '$symbol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?"
2390:
|
2394:
2395: , CWE398@var2537 , Certainty ::@expr10400 inconclusive@expr10384 ) ; }
2396: else {
2397: reportError (@expr1073752225 toks@var3158 , Severity ::@expr1073752226 performance , "functionStatic" ,
2398: "$symbol:" +@expr10396 classname@var3155 +@expr10397 "::" +@expr10398 funcname@var3156 +@expr1073752230 "\nTechnically the member function '$symbol' can be static (but you may consider moving to unnamed namespace).\nThe member function '$symbol' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace."
2399:
|
2404:
2405: , CWE398@var2537 , Certainty ::@expr10400 inconclusive@expr10384 ) ; }
2406: }
2407:
|
2411:
2412: namespace {
2413: struct VarInfo {
2414: VarInfo ( const Variable * _var@var3159 , const Token * _tok@var3160 )
2415: : var@var3161 ( _var@var3159 ) , tok@var3162 ( _tok@var3160 ) { }
2416:
2417: const Variable * var@var3161 ;
2418: const Token * tok@var3162 ;
2419: } ;
2420: }
2421:
2422: void CheckClass :: initializerListOrder ( )
2423: {
2424: if (@expr1073752233 !@expr1073752234 mSettings@var29 .@expr1073752235 severity@var3441 .@expr1073752236 isEnabled (@expr1073752237 Severity ::@expr1073752238 style ) ) {
2425: return ; }
2426:
|
2430:
2431: if (@expr1073752239 !@expr1073752240 mSettings@var29 .@expr1073752241 certainty@var3442 .@expr1073752242 isEnabled (@expr1073752243 Certainty ::@expr1073752244 inconclusive@expr1073752232 ) ) {
2432: return ; }
2433:
2434: for (@expr1073752245 const Scope *@expr1073752246 scope@var3163 :@expr1073752247 mSymbolDatabase@var1666 .@expr1073752248 classAndStructScopes@var3443 ) {
2435:
2436:
2437: for (@expr1073752249 std ::@expr10426 list < Function > ::@expr10426 const_iterator func@var3164 =@expr1073752252 scope@var3163 .@expr10429 functionList@var3165 .@expr1073752254 begin (@expr1073752255 ) ; func@var3164 !=@expr1073752256 scope@var3163 .@expr10429 functionList@var3165 .@expr1073752258 end (@expr1073752259 ) ; ++@expr1073752260 func@var3164 ) {
2438: if (@expr1073752261 func@var3164 .@expr1073752262 isConstructor (@expr1073752263 ) &&@expr1073752264 func@var3164 .@expr1073752265 hasBody (@expr1073752266 ) ) {
2439:
2440: const Token * tok@var3166 ; tok@var3166 =@expr1073752267 func@var3164 .@expr1073752268 arg@var3167 .@expr1073752269 link (@expr1073752270 ) .@expr1073752271 next (@expr1073752272 ) ;
2441:
2442: if (@expr1073752273 tok@var3166 .@expr10450 str (@expr10451 ) ==@expr1073752276 ":" ) {
2443: std ::@expr1073752277 vector < VarInfo > vars@var3168 ;
2444: tok@var3166 =@expr1073752278 tok@var3166 .@expr10455 next (@expr10456 ) ;
2445:
2446:
2447: while (@expr1073752281 tok@var3166 &&@expr1073752282 tok@var3166 !=@expr1073752283 func@var3164 .@expr1073752284 functionScope@var3169 .@expr1073752285 bodyStart@var3170 ) {
2448: if (@expr1073752286 Token ::@expr10463 Match (@expr1073752288 tok@var3166 , "%name% (|{" ) ) {
2449: const Variable * var@var3171 ; var@var3171 =@expr1073752289 scope@var3163 .@expr10466 getVariable (@expr1073752291 tok@var3166 .@expr10450 str (@expr10451 ) ) ;
2450: if (@expr10470 var@var3171 ) {
2451: vars@var3168 .@expr10471 emplace_back (@expr1073752296 var@var3171 , tok@var3166 ) ; }
2452:
2453: if (@expr1073752297 Token ::@expr10463 Match (@expr1073752299 tok@var3166 .@expr10476 tokAt (@expr10477 2 ) , "%name% =" ) ) {
2454: var@var3171 =@expr1073752302 scope@var3163 .@expr10466 getVariable (@expr1073752304 tok@var3166 .@expr1073752305 strAt (@expr1073752306 2 ) ) ;
2455:
2456: if (@expr10470 var@var3171 ) {
2457: vars@var3168 .@expr10471 emplace_back (@expr1073752309 var@var3171 , tok@var3166 .@expr10476 tokAt (@expr10477 2 ) ) ; }
2458: }
2459: tok@var3166 =@expr1073752312 tok@var3166 .@expr10455 next (@expr10456 ) .@expr1073752315 link (@expr1073752316 ) .@expr1073752317 next (@expr1073752318 ) ;
2460: } else {
2461: tok@var3166 =@expr1073752319 tok@var3166 .@expr10455 next (@expr10456 ) ; }
2462: }
2463:
2464:
2465: for (@expr1073752322 int j@var3172 =@expr1073752323 1 ; j@var3172 <@expr1073752324 vars@var3168 .@expr1073752325 size (@expr1073752326 ) ; j@var3172 ++@expr1073752327 ) {
2466:
2467: if (@expr1073752328 vars@var3168 [@expr10505 j@var3172 ] .@expr10506 var@var3473 .@expr1073752331 index (@expr1073752332 ) <@expr1073752333 vars@var3168 [@expr1073752334 j@var3172 -@expr1073752335 1 ] .@expr1073752336 var@var3473 .@expr1073752337 index (@expr1073752338 ) ) {
2468: initializerListError (@expr1073752339 vars@var3168 [@expr10505 j@var3172 ] .@expr1073752341 tok@var3474 , vars@var3168 [@expr10505 j@var3172 ] .@expr10506 var@var3473 .@expr1073752344 nameToken (@expr1073752345 ) , scope@var3163 .@expr1073752346 className@var3173 , vars@var3168 [@expr10505 j@var3172 ] .@expr10506 var@var3473 .@expr1073752349 name (@expr1073752350 ) ) ; }
2469: }
2470: }
2471: }
2472: }
2473: }
2474: }
2475:
2476: void CheckClass :: initializerListError ( const Token * tok1@var3174 , const Token * tok2@var3175 , const std :: string & classname@var3176 , const std :: string & varname@var3177 )
2477: {
2478: std ::@expr1073752352 list < const Token *@expr1073752353 > toks@var3178 ; toks@var3178 =@expr1073752354 {@expr1073752355 tok1@var3174 , tok2@var3175 } ;
2479: reportError (@expr1073752356 toks@var3178 , Severity ::@expr1073752357 style , "initializerList" ,
2480: "$symbol:" +@expr1073752358 classname@var3176 +@expr1073752359 "::" +@expr1073752360 varname@var3177 +@expr1073752361 "\nMember variable '$symbol' is in the wrong place in the initializer list.\nMember variable '$symbol' is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors."
2481:
|
2485:
2486: , CWE398@var2537 , Certainty ::@expr1073752362 inconclusive@expr1073752351 ) ;
2487: }
2488:
|
2493:
2494: void CheckClass :: checkSelfInitialization ( )
2495: {
2496: for (@expr1073752363 const Scope *@expr10540 scope@var3179 :@expr1073752365 mSymbolDatabase@var1666 .@expr1073752366 functionScopes@var3448 ) {
2497: const Function * function@var3180 ; function@var3180 =@expr1073752367 scope@var3179 .@expr1073752368 function@var3181 ;
2498: if (@expr1073752369 !@expr1073752370 function@var3180 ||@expr1073752371 !@expr1073752372 function@var3180 .@expr1073752373 isConstructor (@expr1073752374 ) ) {
2499: continue ; }
2500:
2501: const Token * tok@var3182 ; tok@var3182 =@expr1073752375 function@var3180 .@expr1073752376 arg@var3183 .@expr1073752377 link (@expr1073752378 ) .@expr1073752379 next (@expr1073752380 ) ;
2502: if (@expr1073752381 tok@var3182 .@expr1073752382 str (@expr1073752383 ) !=@expr1073752384 ":" ) {
2503: continue ; }
2504:
2505: for (@expr1073752385 ; tok@var3182 !=@expr1073752386 scope@var3179 .@expr1073752387 bodyStart@var3184 ; tok@var3182 =@expr1073752388 tok@var3182 .@expr10565 next (@expr10566 ) ) {
2506: if (@expr1073752391 Token ::@expr10568 Match (@expr1073752393 tok@var3182 , "[:,] %var% (|{" ) ) {
2507: const Token * varTok@var3185 ; varTok@var3185 =@expr1073752394 tok@var3182 .@expr10565 next (@expr10566 ) ;
2508: if (@expr1073752397 Token ::@expr10568 Match (@expr1073752399 varTok@var3185 .@expr10576 astParent (@expr10577 ) , "(|{" ) ) {
2509: if (@expr1073752402 const Token *@expr10540 initTok@var3186 =@expr1073752404 varTok@var3185 .@expr10576 astParent (@expr10577 ) .@expr1073752407 astOperand2 (@expr1073752408 ) ) {
2510: if (@expr1073752409 initTok@var3186 .@expr1073752410 varId (@expr1073752411 ) ==@expr1073752412 varTok@var3185 .@expr10589 varId (@expr10590 ) ) {
2511: selfInitializationError (@expr10591 tok@var3182 , varTok@var3185 .@expr10592 str (@expr10593 ) ) ; }
2512: else { if (@expr1073752418 initTok@var3186 .@expr1073752419 isCast (@expr1073752420 ) &&@expr1073752421 (@expr1073752422 (@expr1073752423 initTok@var3186 .@expr10600 astOperand1 (@expr10601 ) &&@expr1073752426 initTok@var3186 .@expr10600 astOperand1 (@expr10601 ) .@expr1073752429 varId (@expr1073752430 ) ==@expr1073752431 varTok@var3185 .@expr10589 varId (@expr10590 ) ) ||@expr1073752434 (@expr1073752435 initTok@var3186 .@expr10612 astOperand2 (@expr10613 ) &&@expr1073752438 initTok@var3186 .@expr10612 astOperand2 (@expr10613 ) .@expr1073752441 varId (@expr1073752442 ) ==@expr1073752443 varTok@var3185 .@expr10589 varId (@expr10590 ) ) ) ) {
2513: selfInitializationError (@expr10591 tok@var3182 , varTok@var3185 .@expr10592 str (@expr10593 ) ) ; } }
2514: }
2515: }
2516: }
2517: }
2518: }
2519: }
2520:
2521: void CheckClass :: selfInitializationError ( const Token * tok@var3187 , const std :: string & varname@var3188 )
2522: {
2523: reportError (@expr1073752450 tok@var3187 , Severity ::@expr1073752451 error@expr1073752449 , "selfInitialization" , "$symbol:" +@expr1073752452 varname@var3188 +@expr1073752453 "\nMember variable '$symbol' is initialized by itself." , CWE665@var2539 , Certainty ::@expr1073752454 normal ) ;
2524: }
2525:
|
2530:
2531: void CheckClass :: checkVirtualFunctionCallInConstructor ( )
2532: {
2533: if (@expr1073752455 !@expr1073752456 mSettings@var29 .@expr1073752457 severity@var3441 .@expr1073752458 isEnabled (@expr1073752459 Severity ::@expr1073752460 warning ) ) {
2534: return ; }
2535: std ::@expr1073752461 map < const Function *@expr10638 , std ::@expr1073752463 list < const Token *@expr10638 > > virtualFunctionCallsMap@var3189 ;
2536: for (@expr1073752465 const Scope *@expr10638 scope@var3190 :@expr1073752467 mSymbolDatabase@var1666 .@expr1073752468 functionScopes@var3448 ) {
2537: if (@expr1073752469 scope@var3190 .@expr10646 function@var3191 ==@expr1073752471 nullptr ||@expr1073752472 !@expr1073752473 scope@var3190 .@expr10646 function@var3191 .@expr1073752475 hasBody (@expr1073752476 ) ||@expr1073752477
2538: !@expr1073752478 (@expr1073752479 scope@var3190 .@expr10646 function@var3191 .@expr1073752481 isConstructor (@expr1073752482 ) ||@expr1073752483
2539: scope@var3190 .@expr10646 function@var3191 .@expr1073752485 isDestructor (@expr1073752486 ) ) ) {
2540: continue ; }
2541:
2542: const std ::@expr1073752487 list < const Token *@expr10638 > & virtualFunctionCalls@var3192 =@expr1073752489 getVirtualFunctionCalls (@expr1073752490 *@expr1073752491 scope@var3190 .@expr10646 function@var3191 , virtualFunctionCallsMap@var3189 ) ;
2543: for (@expr1073752493 const Token *@expr10638 callToken@var3193 :@expr1073752495 virtualFunctionCalls@var3192 ) {
2544: std ::@expr1073752496 list < const Token *@expr10638 > callstack@var3194 (@expr1073752498 1 , callToken@var3193 ) ;
2545: getFirstVirtualFunctionCallStack (@expr1073752499 virtualFunctionCallsMap@var3189 , callToken@var3193 , callstack@var3194 ) ;
2546: if (@expr1073752500 callstack@var3194 .@expr1073752501 empty (@expr1073752502 ) ) {
2547: continue ; }
2548: if (@expr1073752503 !@expr1073752504 (@expr1073752505 callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10684 function (@expr10685 ) .@expr1073752510 hasVirtualSpecifier (@expr1073752511 ) ||@expr1073752512 callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10684 function (@expr10685 ) .@expr1073752517 hasOverrideSpecifier (@expr1073752518 ) ) ) {
2549: continue ; }
2550: if (@expr1073752519 callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10684 function (@expr10685 ) .@expr1073752524 isPure (@expr1073752525 ) ) {
2551: pureVirtualFunctionCallInConstructorError (@expr1073752526 scope@var3190 .@expr10646 function@var3191 , callstack@var3194 , callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10706 str (@expr10707 ) ) ; }
2552: else { if (@expr1073752532 !@expr1073752533 callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10684 function (@expr10685 ) .@expr1073752538 hasFinalSpecifier (@expr1073752539 ) ) {
2553: virtualFunctionCallInConstructorError (@expr1073752540 scope@var3190 .@expr10646 function@var3191 , callstack@var3194 , callstack@var3194 .@expr10682 back (@expr10683 ) .@expr10706 str (@expr10707 ) ) ; } }
2554: }
2555: }
2556: }
2557:
2558: const std :: list < const Token * > & CheckClass :: getVirtualFunctionCalls ( const Function & function@var3195 ,
2559: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var3196 )
2560: {
2561: const std ::@expr1073752546 map < const Function *@expr10723 , std ::@expr1073752548 list < const Token *@expr10723 > > ::@expr1073752550 const_iterator found@var3197 =@expr1073752551 virtualFunctionCallsMap@var3196 .@expr1073752552 find (@expr1073752553 &@expr10730 function@var3195 ) ;
2562: if (@expr1073752555 found@var3197 !=@expr1073752556 virtualFunctionCallsMap@var3196 .@expr1073752557 end (@expr1073752558 ) ) {
2563: return found@var3197 .@expr1073752559 second@var3198 ; }
2564:
2565: virtualFunctionCallsMap@var3196 [@expr1073752560 &@expr10730 function@var3195 ] =@expr1073752562 std ::@expr10739 list < const Token *@expr10723 > (@expr1073752565 ) ;
2566: std ::@expr10739 list < const Token *@expr10723 > & virtualFunctionCalls@var3199 =@expr1073752568 virtualFunctionCallsMap@var3196 .@expr1073752569 find@var3200 function@var3195 .@expr1073752570 second@var3201 ;
2567:
2568: if (@expr1073752571 !@expr1073752572 function@var3195 .@expr1073752573 hasBody (@expr1073752574 ) ||@expr1073752575 !@expr1073752576 function@var3195 .@expr10753 functionScope@var3202 ) {
2569: return virtualFunctionCalls@var3199 ; }
2570:
2571: for (@expr1073752578 const Token *@expr10723 tok@var3203 =@expr1073752580 function@var3195 .@expr1073752581 arg@var3204 .@expr1073752582 link (@expr1073752583 ) ; tok@var3203 !=@expr1073752584 function@var3195 .@expr10753 functionScope@var3202 .@expr1073752586 bodyEnd@var3205 ; tok@var3203 =@expr1073752587 tok@var3203 .@expr1073752588 next (@expr1073752589 ) ) {
2572: if (@expr1073752590 function@var3195 .@expr10767 type@var3206 !=@expr1073752592 Function ::@expr1073752593 eConstructor &&@expr1073752594
2573: function@var3195 .@expr10767 type@var3206 !=@expr1073752596 Function ::@expr1073752597 eCopyConstructor &&@expr1073752598
2574: function@var3195 .@expr10767 type@var3206 !=@expr1073752600 Function ::@expr1073752601 eMoveConstructor &&@expr1073752602
2575: function@var3195 .@expr10767 type@var3206 !=@expr1073752604 Function ::@expr1073752605 eDestructor ) {
2576: if (@expr1073752606 (@expr1073752607 Token ::@expr10784 simpleMatch (@expr1073752609 tok@var3203 , ") {" ) &&@expr1073752610 tok@var3203 .@expr10787 link (@expr10788 ) &&@expr1073752613 Token ::@expr1073752614 Match (@expr1073752615 tok@var3203 .@expr10787 link (@expr10788 ) .@expr1073752618 previous (@expr1073752619 ) , "if|switch" ) ) ||@expr1073752620
2577: Token ::@expr10784 simpleMatch (@expr1073752622 tok@var3203 , "else {" ) ) {
2578:
2579: tok@var3203 =@expr1073752623 tok@var3203 .@expr1073752624 linkAt (@expr1073752625 1 ) ;
2580: continue ;
2581: }
2582: }
2583: if (@expr1073752626 tok@var3203 .@expr10803 scope (@expr10804 ) .@expr1073752629 type@var3475 ==@expr1073752630 Scope ::@expr1073752631 eLambda ) {
2584: tok@var3203 =@expr1073752632 tok@var3203 .@expr10803 scope (@expr10804 ) .@expr1073752635 bodyEnd@var3476 .@expr1073752636 next (@expr1073752637 ) ; }
2585:
2586: const Function * callFunction@var3207 ; callFunction@var3207 =@expr1073752638 tok@var3203 .@expr1073752639 function (@expr1073752640 ) ;
2587: if (@expr1073752641 !@expr1073752642 callFunction@var3207 ||@expr1073752643
2588: function@var3195 .@expr1073752644 nestedIn@var3208 !=@expr1073752645 callFunction@var3207 .@expr1073752646 nestedIn@var3209 ||@expr1073752647
2589: Token ::@expr10784 simpleMatch (@expr1073752649 tok@var3203 .@expr10826 previous (@expr10827 ) , "." ) ||@expr1073752652
2590: !@expr1073752653 (@expr1073752654 tok@var3203 .@expr10831 astParent (@expr10832 ) &&@expr1073752657 (@expr1073752658 tok@var3203 .@expr10831 astParent (@expr10832 ) .@expr10837 str (@expr10838 ) ==@expr1073752663 "(" ||@expr1073752664 (@expr1073752665 tok@var3203 .@expr10831 astParent (@expr10832 ) .@expr10837 str (@expr10838 ) ==@expr1073752670 "::" &&@expr1073752671 Token ::@expr10784 simpleMatch (@expr1073752673 tok@var3203 .@expr10831 astParent (@expr10832 ) .@expr1073752676 astParent (@expr1073752677 ) , "(" ) ) ) ) ) {
2591: continue ; }
2592:
2593: if (@expr1073752678 tok@var3203 .@expr10826 previous (@expr10827 ) &&@expr1073752681
2594: tok@var3203 .@expr10826 previous (@expr10827 ) .@expr1073752684 str (@expr1073752685 ) ==@expr1073752686 "(" ) {
2595: const Token * prev@var3210 ; prev@var3210 =@expr1073752687 tok@var3203 .@expr10826 previous (@expr10827 ) ;
2596: if (@expr1073752690 prev@var3210 .@expr10867 previous (@expr10868 ) &&@expr1073752693
2597: (@expr1073752694 mSettings@var29 .@expr10871 library@var3445 .@expr10872 ignorefunction (@expr1073752697 tok@var3203 .@expr1073752698 str (@expr1073752699 ) )
2598: ||@expr1073752700 mSettings@var29 .@expr10871 library@var3445 .@expr10872 ignorefunction (@expr1073752703 prev@var3210 .@expr10867 previous (@expr10868 ) .@expr1073752706 str (@expr1073752707 ) ) ) ) {
2599: continue ; }
2600: }
2601:
2602: if (@expr1073752708 callFunction@var3207 .@expr1073752709 isImplicitlyVirtual (@expr1073752710 ) ) {
2603: if (@expr1073752711 !@expr1073752712 callFunction@var3207 .@expr1073752713 isPure (@expr1073752714 ) &&@expr1073752715 Token ::@expr10784 simpleMatch (@expr1073752717 tok@var3203 .@expr10826 previous (@expr10827 ) , "::" ) ) {
2604: continue ; }
2605: virtualFunctionCalls@var3199 .@expr10896 push_back (@expr10897 tok@var3203 ) ;
2606: continue ;
2607: }
2608:
2609: const std ::@expr10739 list < const Token *@expr10723 > & virtualFunctionCallsOfTok@var3211 =@expr1073752724 getVirtualFunctionCalls (@expr1073752725 *@expr1073752726 callFunction@var3207 , virtualFunctionCallsMap@var3196 ) ;
2610: if (@expr1073752727 !@expr1073752728 virtualFunctionCallsOfTok@var3211 .@expr1073752729 empty (@expr1073752730 ) ) {
2611: virtualFunctionCalls@var3199 .@expr10896 push_back (@expr10897 tok@var3203 ) ; }
2612: }
2613: return virtualFunctionCalls@var3199 ;
2614: }
2615:
2616: void CheckClass :: getFirstVirtualFunctionCallStack (
2617: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var3212 ,
2618: const Token * callToken@var3213 ,
2619: std :: list < const Token * > & pureFuncStack@var3214 )
2620: {
2621: const Function * callFunction@var3215 ; callFunction@var3215 =@expr1073752733 callToken@var3213 .@expr1073752734 function (@expr1073752735 ) ;
2622: if (@expr1073752736 callFunction@var3215 .@expr1073752737 isImplicitlyVirtual (@expr1073752738 ) &&@expr1073752739 (@expr1073752740 !@expr1073752741 callFunction@var3215 .@expr1073752742 isPure (@expr1073752743 ) ||@expr1073752744 !@expr1073752745 callFunction@var3215 .@expr1073752746 hasBody (@expr1073752747 ) ) ) {
2623: pureFuncStack@var3214 .@expr10924 push_back (@expr1073752749 callFunction@var3215 .@expr1073752750 tokenDef@var3216 ) ;
2624: return ;
2625: }
2626: std ::@expr1073752751 map < const Function *@expr10928 , std ::@expr1073752753 list < const Token *@expr10928 > > ::@expr1073752755 const_iterator found@var3217 ; found@var3217 =@expr1073752756 virtualFunctionCallsMap@var3212 .@expr1073752757 find (@expr1073752758 callFunction@var3215 ) ;
2627: if (@expr1073752759 found@var3217 ==@expr1073752760 virtualFunctionCallsMap@var3212 .@expr1073752761 end (@expr1073752762 ) ||@expr1073752763 found@var3217 .@expr10940 second@var3218 .@expr1073752765 empty (@expr1073752766 ) ) {
2628: pureFuncStack@var3214 .@expr1073752767 clear (@expr1073752768 ) ;
2629: return ;
2630: }
2631: const Token * firstCall@var3219 ; firstCall@var3219 =@expr1073752769 *@expr1073752770 found@var3217 .@expr10940 second@var3218 .@expr1073752772 begin (@expr1073752773 ) ;
2632: pureFuncStack@var3214 .@expr10924 push_back (@expr1073752775 firstCall@var3219 ) ;
2633: getFirstVirtualFunctionCallStack (@expr1073752776 virtualFunctionCallsMap@var3212 , firstCall@var3219 , pureFuncStack@var3214 ) ;
2634: }
2635:
2636: void CheckClass :: virtualFunctionCallInConstructorError (
2637: const Function * scopeFunction@var3220 ,
2638: const std :: list < const Token * > & tokStack@var3221 ,
2639: const std :: string & funcname@var3222 )
2640: {
2641: const char * scopeFunctionTypeName@var3223 ; scopeFunctionTypeName@var3223 =@expr1073752778 scopeFunction@var3220 ?@expr1073752779 getFunctionTypeName (@expr1073752780 scopeFunction@var3220 .@expr10957 type@var3224 ) :@expr1073752782 "constructor" ;
2642:
2643: std ::@expr1073752783 list < std ::@expr10960 pair < const Token *@expr10961 , std ::@expr10960 string > > errorPath@var3225 ;
2644: int lineNumber@var3226 ; lineNumber@var3226 =@expr1073752787 1 ;
2645: for (@expr1073752788 const Token *@expr10961 tok@var3227 :@expr1073752790 tokStack@var3221 ) {
2646: errorPath@var3225 .@expr1073752791 emplace_back (@expr1073752792 tok@var3227 , "Calling " +@expr1073752793 tok@var3227 .@expr1073752794 str (@expr1073752795 ) ) ; }
2647: if (@expr1073752796 !@expr1073752797 errorPath@var3225 .@expr1073752798 empty (@expr1073752799 ) ) {
2648: lineNumber@var3226 =@expr1073752800 errorPath@var3225 .@expr1073752801 front (@expr1073752802 ) .@expr1073752803 first .@expr1073752804 linenr (@expr1073752805 ) ;
2649: errorPath@var3225 .@expr1073752806 back (@expr1073752807 ) .@expr1073752808 second@expr1073752777 =@expr1073752809 funcname@var3222 +@expr1073752810 " is a virtual function" ;
2650: }
2651:
2652: std ::@expr1073752811 string constructorName@var3228 ;
2653: if (@expr1073752812 scopeFunction@var3220 ) {
2654: const Token * endToken@var3229 ; endToken@var3229 =@expr1073752813 scopeFunction@var3220 .@expr1073752814 argDef@var3230 .@expr1073752815 link (@expr1073752816 ) .@expr1073752817 next (@expr1073752818 ) ;
2655: if (@expr1073752819 scopeFunction@var3220 .@expr10957 type@var3224 ==@expr1073752821 Function ::@expr1073752822 Type ::@expr1073752823 eDestructor ) {
2656: constructorName@var3228 =@expr1073752824 "~" ; }
2657: for (@expr1073752825 const Token *@expr10961 tok@var3231 =@expr1073752827 scopeFunction@var3220 .@expr1073752828 tokenDef@var3232 ; tok@var3231 !=@expr1073752829 endToken@var3229 ; tok@var3231 =@expr1073752830 tok@var3231 .@expr1073752831 next (@expr1073752832 ) ) {
2658: if (@expr1073752833 !@expr1073752834 constructorName@var3228 .@expr1073752835 empty (@expr1073752836 ) &&@expr1073752837 Token ::@expr1073752838 Match (@expr1073752839 tok@var3231 .@expr1073752840 previous (@expr1073752841 ) , "%name%|%num% %name%|%num%" ) ) {
2659: constructorName@var3228 +=@expr1073752842 ' ' ; }
2660: constructorName@var3228 +=@expr1073752843 tok@var3231 .@expr11020 str (@expr11021 ) ;
2661: if (@expr1073752846 tok@var3231 .@expr11020 str (@expr11021 ) ==@expr1073752849 ")" ) {
2662: break ; }
2663: }
2664: }
2665:
2666: reportError (@expr1073752850 errorPath@var3225 , Severity ::@expr1073752851 style , "virtualCallInConstructor" ,
2667: "Virtual function '" +@expr1073752852 funcname@var3222 +@expr1073752853 "' is called from " +@expr1073752854 scopeFunctionTypeName@var3223 +@expr1073752855 " '" +@expr1073752856 constructorName@var3228 +@expr1073752857 "' at line " +@expr1073752858 MathLib ::@expr1073752859 toString (@expr1073752860 lineNumber@var3226 ) +@expr1073752861 ". Dynamic binding is not used." , CWE (@expr1073752862 0U ) , Certainty ::@expr1073752863 normal ) ;
2668: }
2669:
2670: void CheckClass :: pureVirtualFunctionCallInConstructorError (
2671: const Function * scopeFunction@var3233 ,
2672: const std :: list < const Token * > & tokStack@var3234 ,
2673: const std :: string & purefuncname@var3235 )
2674: {
2675: const char * scopeFunctionTypeName@var3236 ; scopeFunctionTypeName@var3236 =@expr1073752865 scopeFunction@var3233 ?@expr1073752866 getFunctionTypeName (@expr1073752867 scopeFunction@var3233 .@expr1073752868 type@var3237 ) :@expr1073752869 "constructor" ;
2676:
2677: std ::@expr1073752870 list < std ::@expr11047 pair < const Token *@expr11048 , std ::@expr11047 string > > errorPath@var3238 ;
2678: for (@expr1073752874 const Token *@expr11048 tok@var3239 :@expr1073752876 tokStack@var3234 ) {
2679: errorPath@var3238 .@expr1073752877 emplace_back (@expr1073752878 tok@var3239 , "Calling " +@expr1073752879 tok@var3239 .@expr1073752880 str (@expr1073752881 ) ) ; }
2680: if (@expr1073752882 !@expr1073752883 errorPath@var3238 .@expr1073752884 empty (@expr1073752885 ) ) {
2681: errorPath@var3238 .@expr1073752886 back (@expr1073752887 ) .@expr1073752888 second@expr1073752864 =@expr1073752889 purefuncname@var3235 +@expr1073752890 " is a pure virtual function without body" ; }
2682:
2683: reportError (@expr1073752891 errorPath@var3238 , Severity ::@expr1073752892 warning , "pureVirtualCall" ,
2684: "$symbol:" +@expr1073752893 purefuncname@var3235 +@expr1073752894 "\nCall of pure virtual function '$symbol' in "
2685: +@expr1073752895 scopeFunctionTypeName@var3236 +@expr1073752896 ".\nCall of pure virtual function '$symbol' in "
2686: +@expr1073752897 scopeFunctionTypeName@var3236 +@expr1073752898 ". The call will fail during runtime." , CWE (@expr1073752899 0U ) , Certainty ::@expr1073752900 normal ) ;
2687: }
2688:
|
2693:
2694: void CheckClass :: checkDuplInheritedMembers ( )
2695: {
2696: if (@expr1073752901 !@expr1073752902 mSettings@var29 .@expr1073752903 severity@var3441 .@expr1073752904 isEnabled (@expr1073752905 Severity ::@expr1073752906 warning ) ) {
2697: return ; }
2698:
2699:
2700: for (@expr1073752907 const Type &@expr1073752908 classIt@var3240 :@expr1073752909 mSymbolDatabase@var1666 .@expr1073752910 typeList@var3449 ) {
2701:
2702: checkDuplInheritedMembersRecursive (@expr1073752911 &@expr11088 classIt@var3240 , &@expr11088 classIt@var3240 ) ;
2703: }
2704: }
2705:
2706: void CheckClass :: checkDuplInheritedMembersRecursive ( const Type * typeCurrent@var3241 , const Type * typeBase@var3242 )
2707: {
2708: for (@expr1073752914 const Type ::@expr1073752915 BaseInfo &@expr11092 parentClassIt@var3243 :@expr1073752917 typeBase@var3242 .@expr1073752918 derivedFrom@var3244 ) {
2709:
2710: if (@expr1073752919 !@expr1073752920 parentClassIt@var3243 .@expr11097 type@var3245 ||@expr1073752922 !@expr1073752923 parentClassIt@var3243 .@expr11097 type@var3245 .@expr11101 classScope@var3246 ) {
2711: continue ; }
2712:
2713: if (@expr1073752926 parentClassIt@var3243 .@expr11097 type@var3245 ==@expr1073752928 typeBase@var3242 ) {
2714: continue ; }
2715:
2716: for (@expr1073752929 const Variable &@expr11092 classVarIt@var3247 :@expr1073752931 typeCurrent@var3241 .@expr11108 classScope@var3248 .@expr1073752933 varlist@var3249 ) {
2717: for (@expr1073752934 const Variable &@expr11092 parentClassVarIt@var3250 :@expr1073752936 parentClassIt@var3243 .@expr11097 type@var3245 .@expr11101 classScope@var3246 .@expr1073752939 varlist@var3251 ) {
2718: if (@expr1073752940 classVarIt@var3247 .@expr11117 name (@expr11118 ) ==@expr1073752943 parentClassVarIt@var3250 .@expr1073752944 name (@expr1073752945 ) &&@expr1073752946 !@expr1073752947 parentClassVarIt@var3250 .@expr1073752948 isPrivate (@expr1073752949 ) ) {
2719: duplInheritedMembersError (@expr1073752950 classVarIt@var3247 .@expr1073752951 nameToken (@expr1073752952 ) , parentClassVarIt@var3250 .@expr1073752953 nameToken (@expr1073752954 ) ,
2720: typeCurrent@var3241 .@expr1073752955 name (@expr1073752956 ) , parentClassIt@var3243 .@expr11097 type@var3245 .@expr1073752958 name (@expr1073752959 ) , classVarIt@var3247 .@expr11117 name (@expr11118 ) ,
2721: typeCurrent@var3241 .@expr11108 classScope@var3248 .@expr1073752963 type@var3252 ==@expr1073752964 Scope ::@expr11141 eStruct ,
2722: parentClassIt@var3243 .@expr11097 type@var3245 .@expr11101 classScope@var3246 .@expr1073752968 type@var3253 ==@expr1073752969 Scope ::@expr11141 eStruct ) ;
2723: }
2724: }
2725: }
2726: if (@expr1073752971 typeCurrent@var3241 !=@expr1073752972 parentClassIt@var3243 .@expr11097 type@var3245 ) {
2727: checkDuplInheritedMembersRecursive (@expr1073752974 typeCurrent@var3241 , parentClassIt@var3243 .@expr11097 type@var3245 ) ; }
2728: }
2729: }
2730:
2731: void CheckClass :: duplInheritedMembersError ( const Token * tok1@var3254 , const Token * tok2@var3255 ,
2732: const std :: string & derivedName@var3256 , const std :: string & baseName@var3257 ,
2733: const std :: string & variableName@var3258 , bool derivedIsStruct@var3259 , bool baseIsStruct@var3260 )
2734: {
2735: std ::@expr1073752976 list < std ::@expr11153 pair < const Token *@expr1073752978 , std ::@expr11153 string > > errorPath@var3261 ;
2736: errorPath@var3261 .@expr11156 emplace_back (@expr1073752981 tok2@var3255 , "Parent variable '" +@expr1073752982 baseName@var3257 +@expr1073752983 "::" +@expr1073752984 variableName@var3258 +@expr1073752985 "'" ) ;
2737: errorPath@var3261 .@expr11156 emplace_back (@expr1073752987 tok1@var3254 , "Derived variable '" +@expr1073752988 derivedName@var3256 +@expr1073752989 "::" +@expr1073752990 variableName@var3258 +@expr1073752991 "'" ) ;
2738:
2739: const std ::@expr11153 string symbols@var3262 =@expr1073752993 "$symbol:" +@expr1073752994 derivedName@var3256 +@expr1073752995 "\n$symbol:" +@expr1073752996 variableName@var3258 +@expr1073752997 "\n$symbol:" +@expr1073752998 baseName@var3257 ;
2740:
2741: const std ::@expr11153 string message@var3263 =@expr1073753000 "The " +@expr1073753001 std ::@expr11178 string (@expr1073753003 derivedIsStruct@var3259 ?@expr1073753004 "struct" :@expr11181 "class" ) +@expr1073753006 " '" +@expr1073753007 derivedName@var3256 +@expr1073753008
2742: "' defines member variable with name '" +@expr1073753009 variableName@var3258 +@expr1073753010 "' also defined in its parent " +@expr1073753011
2743: std ::@expr11178 string (@expr1073753013 baseIsStruct@var3260 ?@expr1073753014 "struct" :@expr11181 "class" ) +@expr1073753016 " '" +@expr1073753017 baseName@var3257 +@expr1073753018 "'." ;
2744: reportError (@expr1073753019 errorPath@var3261 , Severity ::@expr1073753020 warning , "duplInheritedMember" , symbols@var3262 +@expr1073753021 '\n' +@expr1073753022 message@var3263 , CWE398@var2537 , Certainty ::@expr1073753023 normal ) ;
2745: }
2746:
|
2751:
2752: enum class CtorType {
2753: NO ,
2754: WITHOUT_BODY ,
2755: WITH_BODY
2756: } ;
2757:
2758: void CheckClass :: checkCopyCtorAndEqOperator ( )
2759: {
2760:
2761:
2762: return ;
2763:
2764:
2765: if (@expr1073753024 !@expr1073753025 mSettings@var29 .@expr1073753026 severity@var3441 .@expr1073753027 isEnabled (@expr1073753028 Severity ::@expr1073753029 warning ) ) {
2766: return ; }
2767:
2768: for (@expr1073753030 const Scope *@expr1073753031 scope@var3264 :@expr1073753032 mSymbolDatabase@var1666 .@expr1073753033 classAndStructScopes@var3443 ) {
2769:
2770: bool hasNonStaticVars@var3265 ; hasNonStaticVars@var3265 =@expr1073753034 false ;
2771: for (@expr1073753035 std ::@expr11212 list < Variable > ::@expr11212 const_iterator var@var3266 =@expr1073753038 scope@var3264 .@expr11215 varlist@var3267 .@expr1073753040 begin (@expr1073753041 ) ; var@var3266 !=@expr1073753042 scope@var3264 .@expr11215 varlist@var3267 .@expr1073753044 end (@expr1073753045 ) ; ++@expr1073753046 var@var3266 ) {
2772: if (@expr1073753047 !@expr1073753048 var@var3266 .@expr1073753049 isStatic (@expr1073753050 ) ) {
2773: hasNonStaticVars@var3265 =@expr1073753051 true ;
2774: break ;
2775: }
2776: }
2777: if (@expr1073753052 !@expr1073753053 hasNonStaticVars@var3265 ) {
2778: continue ; }
2779:
2780: CtorType copyCtors@var3268 ; copyCtors@var3268 =@expr1073753054 CtorType ::@expr11231 NO ;
2781: bool moveCtor@var3269 ; moveCtor@var3269 =@expr1073753056 false ;
2782: CtorType assignmentOperators@var3270 ; assignmentOperators@var3270 =@expr1073753057 CtorType ::@expr11231 NO ;
2783:
2784: for (@expr1073753059 const Function &@expr1073753060 func@var3271 :@expr1073753061 scope@var3264 .@expr1073753062 functionList@var3272 ) {
2785: if (@expr1073753063 copyCtors@var3268 ==@expr1073753064 CtorType ::@expr11231 NO &&@expr1073753066 func@var3271 .@expr11243 type@var3273 ==@expr1073753068 Function ::@expr1073753069 eCopyConstructor ) {
2786: copyCtors@var3268 =@expr1073753070 func@var3271 .@expr11247 hasBody (@expr11248 ) ?@expr11249 CtorType ::@expr11250 WITH_BODY :@expr11251 CtorType ::@expr11252 WITHOUT_BODY ;
2787: }
2788: if (@expr1073753077 assignmentOperators@var3270 ==@expr1073753078 CtorType ::@expr11231 NO &&@expr1073753080 func@var3271 .@expr11243 type@var3273 ==@expr1073753082 Function ::@expr1073753083 eOperatorEqual ) {
2789: const Variable * variable@var3274 ; variable@var3274 =@expr1073753084 func@var3271 .@expr1073753085 getArgumentVar (@expr1073753086 0 ) ;
2790: if (@expr1073753087 variable@var3274 &&@expr1073753088 variable@var3274 .@expr11265 type (@expr11266 ) &&@expr1073753091 variable@var3274 .@expr11265 type (@expr11266 ) .@expr1073753094 classScope@var3463 ==@expr1073753095 scope@var3264 ) {
2791: assignmentOperators@var3270 =@expr1073753096 func@var3271 .@expr11247 hasBody (@expr11248 ) ?@expr11249 CtorType ::@expr11250 WITH_BODY :@expr11251 CtorType ::@expr11252 WITHOUT_BODY ;
2792: }
2793: }
2794: if (@expr1073753103 func@var3271 .@expr11243 type@var3273 ==@expr1073753105 Function ::@expr1073753106 eMoveConstructor ) {
2795: moveCtor@var3269 =@expr1073753107 true ;
2796: break ;
2797: }
2798: }
2799:
2800: if (@expr1073753108 moveCtor@var3269 ) {
2801: continue ; }
2802:
2803:
2804: if (@expr1073753109 copyCtors@var3268 !=@expr1073753110 CtorType ::@expr11250 WITH_BODY &&@expr1073753112 assignmentOperators@var3270 !=@expr1073753113 CtorType ::@expr11250 WITH_BODY ) {
2805: continue ; }
2806:
2807:
2808: if (@expr1073753115 copyCtors@var3268 !=@expr1073753116 CtorType ::@expr11231 NO &&@expr1073753118 assignmentOperators@var3270 !=@expr1073753119 CtorType ::@expr11231 NO ) {
2809: continue ; }
2810:
2811: copyCtorAndEqOperatorError (@expr1073753121 scope@var3264 .@expr1073753122 classDef@var3275 , scope@var3264 .@expr1073753123 className@var3276 , scope@var3264 .@expr1073753124 type@var3277 ==@expr1073753125 Scope ::@expr1073753126 eStruct , copyCtors@var3268 ==@expr1073753127 CtorType ::@expr11250 WITH_BODY ) ;
2812: }
2813: }
2814:
2815: void CheckClass :: copyCtorAndEqOperatorError ( const Token * tok@var3278 , const std :: string & classname@var3279 , bool isStruct@var3280 , bool hasCopyCtor@var3281 )
2816: {
2817: const std ::@expr1073753129 string message@var3282 =@expr1073753130 "$symbol:" +@expr1073753131 classname@var3279 +@expr1073753132 "\nThe "
2818: +@expr1073753133 std ::@expr1073753134 string (@expr1073753135 isStruct@var3280 ?@expr1073753136 "struct" :@expr1073753137 "class" ) +@expr1073753138 " '$symbol' has '" +@expr1073753139
2819: getFunctionTypeName (@expr1073753140 hasCopyCtor@var3281 ?@expr1073753141 Function ::@expr11318 eCopyConstructor :@expr1073753143 Function ::@expr11320 eOperatorEqual ) +@expr1073753145
2820: "' but lack of '" +@expr1073753146 getFunctionTypeName (@expr1073753147 hasCopyCtor@var3281 ?@expr1073753148 Function ::@expr11320 eOperatorEqual :@expr1073753150 Function ::@expr11318 eCopyConstructor ) +@expr1073753152
2821: "'." ;
2822: reportError (@expr1073753153 tok@var3278 , Severity ::@expr1073753154 warning , "copyCtorAndEqOperator" , message@var3282 ) ;
2823: }
2824:
2825: void CheckClass :: checkOverride ( )
2826: {
2827: if (@expr1073753155 !@expr1073753156 mSettings@var29 .@expr1073753157 severity@var3441 .@expr1073753158 isEnabled (@expr1073753159 Severity ::@expr1073753160 style ) ) {
2828: return ; }
2829: if (@expr1073753161 mSettings@var29 .@expr1073753162 standards@var3446 .@expr1073753163 cpp@var3447 <@expr1073753164 Standards ::@expr1073753165 CPP11 ) {
2830: return ; }
2831: for (@expr1073753166 const Scope *@expr1073753167 classScope@var3283 :@expr1073753168 mSymbolDatabase@var1666 .@expr1073753169 classAndStructScopes@var3443 ) {
2832: if (@expr1073753170 !@expr1073753171 classScope@var3283 .@expr11348 definedType@var3284 ||@expr1073753173 classScope@var3283 .@expr11348 definedType@var3284 .@expr1073753175 derivedFrom@var3285 .@expr1073753176 empty (@expr1073753177 ) ) {
2833: continue ; }
2834: for (@expr1073753178 const Function &@expr1073753179 func@var3286 :@expr1073753180 classScope@var3283 .@expr1073753181 functionList@var3287 ) {
2835: if (@expr1073753182 func@var3286 .@expr1073753183 hasOverrideSpecifier (@expr1073753184 ) ||@expr1073753185 func@var3286 .@expr1073753186 hasFinalSpecifier (@expr1073753187 ) ) {
2836: continue ; }
2837: const Function * baseFunc@var3288 ; baseFunc@var3288 =@expr1073753188 func@var3286 .@expr1073753189 getOverriddenFunction (@expr1073753190 ) ;
2838: if (@expr1073753191 baseFunc@var3288 ) {
2839: overrideError (@expr1073753192 baseFunc@var3288 , &@expr1073753193 func@var3286 ) ; }
2840: }
2841: }
2842: }
2843:
2844: void CheckClass :: overrideError ( const Function * funcInBase@var3289 , const Function * funcInDerived@var3290 )
2845: {
2846: const std ::@expr11370 string functionName@var3291 =@expr1073753195 funcInDerived@var3290 ?@expr1073753196 (@expr1073753197 (@expr1073753198 funcInDerived@var3290 .@expr11375 isDestructor (@expr11376 ) ?@expr1073753201 "~" :@expr1073753202 "" ) +@expr1073753203 funcInDerived@var3290 .@expr1073753204 name (@expr1073753205 ) ) :@expr1073753206 "" ;
2847: const std ::@expr11370 string funcType@var3292 =@expr1073753208 (@expr1073753209 funcInDerived@var3290 &&@expr1073753210 funcInDerived@var3290 .@expr11375 isDestructor (@expr11376 ) ) ?@expr1073753213 "destructor" :@expr1073753214 "function" ;
2848:
2849: std ::@expr1073753215 list < std ::@expr11370 pair < const Token *@expr11393 , std ::@expr11370 string > > errorPath@var3293 ;
2850: if (@expr1073753219 funcInBase@var3289 &&@expr1073753220 funcInDerived@var3290 ) {
2851: errorPath@var3293 .@expr11397 push_back (@expr1073753222 std ::@expr11399 pair < const Token *@expr11393 , std ::@expr11370 string > (@expr1073753226 funcInBase@var3289 .@expr1073753227 tokenDef@var3294 , "Virtual " +@expr1073753228 funcType@var3292 +@expr1073753229 " in base class" ) ) ;
2852: errorPath@var3293 .@expr11397 push_back (@expr1073753231 std ::@expr11399 pair < const Token *@expr11393 , std ::@expr11370 string > (@expr1073753235 funcInDerived@var3290 .@expr1073753236 tokenDef@var3295 , char (@expr1073753237 std ::@expr1073753238 toupper (@expr1073753239 funcType@var3292 [@expr1073753240 0 ] ) ) +@expr1073753241 funcType@var3292 .@expr1073753242 substr (@expr1073753243 1 ) +@expr1073753244 " in derived class" ) ) ;
2853: }
2854:
2855: reportError (@expr1073753245 errorPath@var3293 , Severity ::@expr1073753246 style , "missingOverride" ,
2856: "$symbol:" +@expr1073753247 functionName@var3291 +@expr1073753248 "\nThe "
2857: +@expr1073753249 funcType@var3292 +@expr1073753250 " '$symbol' overrides a " +@expr1073753251 funcType@var3292 +@expr1073753252 " in a base class but is not marked with a 'override' specifier." ,
2858: CWE (@expr1073753253 0U ) ,
2859: Certainty ::@expr1073753254 normal ) ;
2860: }
2861:
2862: void CheckClass :: checkThisUseAfterFree ( )
2863: {
2864: if (@expr1073753255 !@expr1073753256 mSettings@var29 .@expr1073753257 severity@var3441 .@expr1073753258 isEnabled (@expr1073753259 Severity ::@expr1073753260 warning ) ) {
2865: return ; }
2866:
2867: for (@expr1073753261 const Scope *@expr11438 classScope@var3296 :@expr1073753263 mSymbolDatabase@var1666 .@expr1073753264 classAndStructScopes@var3443 ) {
2868:
2869: for (@expr1073753265 const Variable &@expr11442 var@var3297 :@expr1073753267 classScope@var3296 .@expr1073753268 varlist@var3298 ) {
2870:
2871: if (@expr1073753269 var@var3297 .@expr11446 valueType (@expr11447 ) &&@expr1073753272 var@var3297 .@expr11446 valueType (@expr11447 ) .@expr1073753275 smartPointerType@var3477 !=@expr1073753276 classScope@var3296 .@expr11453 definedType@var3299 &&@expr1073753278 var@var3297 .@expr11446 valueType (@expr11447 ) .@expr1073753281 typeScope@var3478 !=@expr1073753282 classScope@var3296 ) {
2872: const ValueType valueType@var3300 =@expr1073753283 ValueType ::@expr1073753284 parseDecl (@expr1073753285 var@var3297 .@expr1073753286 typeStartToken (@expr1073753287 ) , mSettings@var29 ) ;
2873: if (@expr1073753288 valueType@var3300 .@expr1073753289 smartPointerType@var3301 !=@expr1073753290 classScope@var3296 .@expr11453 definedType@var3299 ) {
2874: continue ; }
2875: }
2876:
2877:
2878: if (@expr1073753292 !@expr1073753293 var@var3297 .@expr1073753294 isStatic (@expr1073753295 ) ) {
2879: bool hasAssign@var3302 ; hasAssign@var3302 =@expr1073753296 false ;
2880: for (@expr1073753297 const Function &@expr11442 func@var3303 :@expr1073753299 classScope@var3296 .@expr11476 functionList@var3304 ) {
2881: if (@expr1073753301 func@var3303 .@expr1073753302 type@var3305 !=@expr1073753303 Function ::@expr11480 Type ::@expr11481 eFunction ||@expr1073753306 !@expr1073753307 func@var3303 .@expr1073753308 hasBody (@expr1073753309 ) ) {
2882: continue ; }
2883: for (@expr1073753310 const Token *@expr11438 tok@var3306 =@expr1073753312 func@var3303 .@expr11489 functionScope@var3307 .@expr1073753314 bodyStart@var3308 ; tok@var3306 !=@expr1073753315 func@var3303 .@expr11489 functionScope@var3307 .@expr1073753317 bodyEnd@var3309 ; tok@var3306 =@expr1073753318 tok@var3306 .@expr1073753319 next (@expr1073753320 ) ) {
2884: if (@expr1073753321 Token ::@expr1073753322 Match (@expr1073753323 tok@var3306 , "%varid% = this|shared_from_this" , var@var3297 .@expr1073753324 declarationId (@expr1073753325 ) ) ) {
2885: hasAssign@var3302 =@expr1073753326 true ;
2886: break ;
2887: }
2888: }
2889: if (@expr1073753327 hasAssign@var3302 ) {
2890: break ; }
2891: }
2892: if (@expr1073753328 !@expr1073753329 hasAssign@var3302 ) {
2893: continue ; }
2894: }
2895:
2896:
2897: for (@expr1073753330 const Function &@expr11442 func@var3310 :@expr1073753332 classScope@var3296 .@expr11476 functionList@var3304 ) {
2898: if (@expr1073753334 func@var3310 .@expr1073753335 type@var3311 !=@expr1073753336 Function ::@expr11480 Type ::@expr11481 eFunction ||@expr1073753339 !@expr1073753340 func@var3310 .@expr1073753341 hasBody (@expr1073753342 ) ) {
2899: continue ; }
2900:
2901: const Token * freeToken@var3312 ; freeToken@var3312 =@expr1073753343 nullptr ;
2902: std ::@expr1073753344 set < const Function *@expr11438 > callstack@var3313 ;
2903: checkThisUseAfterFreeRecursive (@expr1073753346 classScope@var3296 , &@expr1073753347 func@var3310 , &@expr1073753348 var@var3297 , callstack@var3313 , &@expr1073753349 freeToken@var3312 ) ;
2904: }
2905: }
2906: }
2907: }
2908:
2909: bool CheckClass :: checkThisUseAfterFreeRecursive ( const Scope * classScope@var3314 , const Function * func@var3315 , const Variable * selfPointer@var3316 , std :: set < const Function * > callstack@var3317 , const Token * * freeToken@var3318 )
2910: {
2911: if (@expr1073753350 !@expr1073753351 func@var3315 ||@expr1073753352 !@expr1073753353 func@var3315 .@expr11530 functionScope@var3319 ) {
2912: return false ; }
2913:
2914:
2915: if (@expr1073753355 callstack@var3317 .@expr1073753356 count (@expr1073753357 func@var3315 ) ) {
2916: return false ; }
2917: callstack@var3317 .@expr1073753358 insert (@expr1073753359 func@var3315 ) ;
2918:
2919: const Token * const bodyStart@var3320 ; bodyStart@var3320 =@expr1073753360 func@var3315 .@expr11530 functionScope@var3319 .@expr1073753362 bodyStart@var3321 ;
2920: const Token * const bodyEnd@var3322 ; bodyEnd@var3322 =@expr1073753363 func@var3315 .@expr11530 functionScope@var3319 .@expr1073753365 bodyEnd@var3323 ;
2921: for (@expr1073753366 const Token *@expr1073753367 tok@var3324 =@expr1073753368 bodyStart@var3320 ; tok@var3324 !=@expr1073753369 bodyEnd@var3322 ; tok@var3324 =@expr1073753370 tok@var3324 .@expr11547 next (@expr11548 ) ) {
2922: const bool isDestroyed@var3325 =@expr1073753373 *@expr11550 freeToken@var3318 !=@expr1073753375 nullptr &&@expr1073753376 !@expr1073753377 func@var3315 .@expr1073753378 isStatic (@expr1073753379 ) ;
2923: if (@expr1073753380 Token ::@expr11557 Match (@expr1073753382 tok@var3324 , "delete %var% ;" ) &&@expr1073753383 selfPointer@var3316 ==@expr1073753384 tok@var3324 .@expr11547 next (@expr11548 ) .@expr1073753387 variable (@expr1073753388 ) ) {
2924: *@expr11550 freeToken@var3318 =@expr1073753390 tok@var3324 ;
2925: tok@var3324 =@expr1073753391 tok@var3324 .@expr1073753392 tokAt (@expr1073753393 2 ) ;
2926: } else { if (@expr1073753394 Token ::@expr11557 Match (@expr1073753396 tok@var3324 , "%var% . reset ( )" ) &&@expr1073753397 selfPointer@var3316 ==@expr1073753398 tok@var3324 .@expr11575 variable (@expr11576 ) ) {
2927: *@expr11550 freeToken@var3318 =@expr1073753402 tok@var3324 ; }
2928: else { if (@expr1073753403 Token ::@expr11557 Match (@expr1073753405 tok@var3324 .@expr11582 previous (@expr11583 ) , "!!. %name% (" ) &&@expr1073753408 tok@var3324 .@expr11585 function (@expr11586 ) &&@expr1073753411 tok@var3324 .@expr11585 function (@expr11586 ) .@expr1073753414 nestedIn@var3468 ==@expr1073753415 classScope@var3314 ) {
2929: if (@expr1073753416 isDestroyed@var3325 ) {
2930: thisUseAfterFree (@expr11593 selfPointer@var3316 .@expr11594 nameToken (@expr11595 ) , *@expr11550 freeToken@var3318 , tok@var3324 ) ;
2931: return true ;
2932: }
2933: if (@expr1073753421 checkThisUseAfterFreeRecursive (@expr1073753422 classScope@var3314 , tok@var3324 .@expr11585 function (@expr11586 ) , selfPointer@var3316 , callstack@var3317 , freeToken@var3318 ) ) {
2934: return true ; }
2935: } else { if (@expr1073753425 isDestroyed@var3325 &&@expr1073753426 Token ::@expr11557 Match (@expr1073753428 tok@var3324 .@expr11582 previous (@expr11583 ) , "!!. %name%" ) &&@expr1073753431 tok@var3324 .@expr11575 variable (@expr11576 ) &&@expr1073753434 tok@var3324 .@expr11575 variable (@expr11576 ) .@expr1073753437 scope (@expr1073753438 ) ==@expr1073753439 classScope@var3314 &&@expr1073753440 !@expr1073753441 tok@var3324 .@expr11575 variable (@expr11576 ) .@expr1073753444 isStatic (@expr1073753445 ) &&@expr1073753446 !@expr1073753447 tok@var3324 .@expr11575 variable (@expr11576 ) .@expr1073753450 isArgument (@expr1073753451 ) ) {
2936: thisUseAfterFree (@expr11593 selfPointer@var3316 .@expr11594 nameToken (@expr11595 ) , *@expr11550 freeToken@var3318 , tok@var3324 ) ;
2937: return true ;
2938: } else { if (@expr1073753456 *@expr11550 freeToken@var3318 &&@expr1073753458 Token ::@expr11557 Match (@expr1073753460 tok@var3324 , "return|throw" ) ) {
2939:
2940: return tok@var3324 .@expr11637 str (@expr11638 ) ==@expr1073753463 "throw" ;
2941: } else { if (@expr1073753464 tok@var3324 .@expr11637 str (@expr11638 ) ==@expr1073753467 "{" &&@expr1073753468 tok@var3324 .@expr1073753469 scope (@expr1073753470 ) .@expr1073753471 type@var3475 ==@expr1073753472 Scope ::@expr1073753473 ScopeType ::@expr1073753474 eLambda ) {
2942: tok@var3324 =@expr1073753475 tok@var3324 .@expr1073753476 link (@expr1073753477 ) ;
2943: } } } } } }
2944: }
2945: return false ;
2946: }
2947:
2948: void CheckClass :: thisUseAfterFree ( const Token * self@var3326 , const Token * free@var3327 , const Token * use@var3328 )
2949: {
2950: std ::@expr1073753478 string selfPointer@var3329 ; selfPointer@var3329 =@expr1073753479 self@var3326 ?@expr1073753480 self@var3326 .@expr1073753481 str (@expr1073753482 ) :@expr1073753483 "ptr" ;
2951: const std ::@expr1073753484 list < std ::@expr11661 pair < const Token *@expr11662 , std ::@expr11661 string > > errorPath@var3330 =@expr1073753488 {@expr1073753489 std ::@expr11666 pair < const Token *@expr11662 , std ::@expr11661 string > (@expr1073753493 self@var3326 , "Assuming '" +@expr1073753494 selfPointer@var3329 +@expr1073753495 "' is used as 'this'" ) , std ::@expr11666 pair < const Token *@expr11662 , std ::@expr11661 string > (@expr1073753499 free@var3327 , "Delete '" +@expr1073753500 selfPointer@var3329 +@expr1073753501 "', invalidating 'this'" ) , std ::@expr11666 pair < const Token *@expr11662 , std ::@expr11661 string > (@expr1073753505 use@var3328 , "Call method when 'this' is invalid" ) } ;
2952: const std ::@expr11661 string usestr@var3331 =@expr1073753507 use@var3328 ?@expr1073753508 use@var3328 .@expr1073753509 str (@expr1073753510 ) :@expr1073753511 "x" ;
2953: const std ::@expr11661 string usemsg@var3332 =@expr1073753513 use@var3328 &&@expr1073753514 use@var3328 .@expr1073753515 function (@expr1073753516 ) ?@expr1073753517 (@expr1073753518 "Calling method '" +@expr1073753519 usestr@var3331 +@expr1073753520 "()'" ) :@expr1073753521 (@expr1073753522 "Using member '" +@expr1073753523 usestr@var3331 +@expr1073753524 "'" ) ;
2954: reportError (@expr1073753525 errorPath@var3330 , Severity ::@expr1073753526 warning , "thisUseAfterFree" ,
2955: "$symbol:" +@expr1073753527 selfPointer@var3329 +@expr1073753528 "\n" +@expr1073753529
2956: usemsg@var3332 +@expr1073753530 " when 'this' might be invalid" ,
2957: CWE (@expr1073753531 0 ) , Certainty ::@expr1073753532 normal ) ;
2958: }
2959:
2960: void CheckClass :: checkUnsafeClassRefMember ( )
2961: {
2962: if (@expr1073753533 !@expr1073753534 mSettings@var29 .@expr1073753535 safeChecks@var3450 .@expr1073753536 classes@var3451 ||@expr1073753537 !@expr1073753538 mSettings@var29 .@expr1073753539 severity@var3441 .@expr1073753540 isEnabled (@expr1073753541 Severity ::@expr1073753542 warning ) ) {
2963: return ; }
2964: for (@expr1073753543 const Scope *@expr1073753544 classScope@var3333 :@expr1073753545 mSymbolDatabase@var1666 .@expr1073753546 classAndStructScopes@var3443 ) {
2965: for (@expr1073753547 const Function &@expr1073753548 func@var3334 :@expr1073753549 classScope@var3333 .@expr1073753550 functionList@var3335 ) {
2966: if (@expr1073753551 !@expr1073753552 func@var3334 .@expr1073753553 hasBody (@expr1073753554 ) ||@expr1073753555 !@expr1073753556 func@var3334 .@expr1073753557 isConstructor (@expr1073753558 ) ) {
2967: continue ; }
2968:
2969: const Token * initList@var3336 ; initList@var3336 =@expr1073753559 func@var3334 .@expr1073753560 constructorMemberInitialization (@expr1073753561 ) ;
2970: while (@expr1073753562 Token ::@expr11739 Match (@expr1073753564 initList@var3336 , "[:,] %name% (" ) ) {
2971: if (@expr1073753565 Token ::@expr11739 Match (@expr1073753567 initList@var3336 .@expr11744 tokAt (@expr1073753569 2 ) , "( %var% )" ) ) {
2972: const Variable * const memberVar@var3337 ; memberVar@var3337 =@expr1073753570 initList@var3336 .@expr11747 next (@expr11748 ) .@expr1073753573 variable (@expr1073753574 ) ;
2973: const Variable * const argVar@var3338 ; argVar@var3338 =@expr1073753575 initList@var3336 .@expr11744 tokAt (@expr1073753577 3 ) .@expr1073753578 variable (@expr1073753579 ) ;
2974: if (@expr1073753580 memberVar@var3337 &&@expr1073753581 argVar@var3338 &&@expr1073753582 memberVar@var3337 .@expr1073753583 isConst (@expr1073753584 ) &&@expr1073753585 memberVar@var3337 .@expr1073753586 isReference (@expr1073753587 ) &&@expr1073753588 argVar@var3338 .@expr1073753589 isArgument (@expr1073753590 ) &&@expr1073753591 argVar@var3338 .@expr1073753592 isConst (@expr1073753593 ) &&@expr1073753594 argVar@var3338 .@expr1073753595 isReference (@expr1073753596 ) ) {
2975: unsafeClassRefMemberError (@expr1073753597 initList@var3336 .@expr11747 next (@expr11748 ) , classScope@var3333 .@expr1073753600 className@var3339 +@expr1073753601 "::" +@expr1073753602 memberVar@var3337 .@expr1073753603 name (@expr1073753604 ) ) ; }
2976: }
2977: initList@var3336 =@expr1073753605 initList@var3336 .@expr1073753606 linkAt (@expr1073753607 2 ) .@expr1073753608 next (@expr1073753609 ) ;
2978: }
2979: }
2980: }
2981: }
2982:
2983: void CheckClass :: unsafeClassRefMemberError ( const Token * tok@var3340 , const std :: string & varname@var3341 )
2984: {
2985: reportError (@expr1073753610 tok@var3340 , Severity ::@expr1073753611 warning , "unsafeClassRefMember" ,
2986: "$symbol:" +@expr1073753612 varname@var3341 +@expr1073753613 "\nUnsafe class: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\nUnsafe class checking: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member '$symbol' a non-reference variable or a smart pointer."
2987:
2988: ,
2989: CWE (@expr1073753614 0 ) , Certainty ::@expr1073753615 normal ) ;
2990: }
2991:
2992: Check :: FileInfo * CheckClass :: getFileInfo ( const Tokenizer * tokenizer@var3342 , const Settings * settings@var3343 ) const
2993: {
2994: if (@expr1073753616 !@expr1073753617 tokenizer@var3342 .@expr1073753618 isCPP (@expr1073753619 ) ) {
2995: return nullptr ; }
2996: (@expr1073753620 void ) settings@var3343 ;
2997:
2998: std ::@expr1073753621 vector < MyFileInfo ::@expr11798 NameLoc > classDefinitions@var3344 ;
2999: for (@expr1073753623 const Scope *@expr11800 classScope@var3345 :@expr1073753625 tokenizer@var3342 .@expr1073753626 getSymbolDatabase (@expr1073753627 ) .@expr1073753628 classAndStructScopes@var3479 ) {
3000: if (@expr1073753629 classScope@var3345 .@expr1073753630 isAnonymous (@expr1073753631 ) ) {
3001: continue ; }
3002:
3003:
3004: bool fullDefinition@var3346 ; fullDefinition@var3346 =@expr1073753632 std ::@expr1073753633 all_of (@expr1073753634 classScope@var3345 .@expr11811 functionList@var3347 .@expr1073753636 begin (@expr1073753637 ) ,
3005: classScope@var3345 .@expr11811 functionList@var3347 .@expr1073753639 end (@expr1073753640 ) ,
3006: [@expr1073753641 ] (@expr1073753642 const Function &@expr11819 f@var3348 ) {
3007: return f@var3348 .@expr1073753644 hasBody (@expr1073753645 ) ;
3008: } ) ;
3009: if (@expr1073753646 !@expr1073753647 fullDefinition@var3346 ) {
3010: continue ; }
3011:
3012: std ::@expr1073753648 string name@var3349 ;
3013: const Scope * scope@var3350 ; scope@var3350 =@expr1073753649 classScope@var3345 ;
3014: while (@expr1073753650 scope@var3350 .@expr1073753651 isClassOrStruct (@expr1073753652 ) &&@expr1073753653 !@expr1073753654 classScope@var3345 .@expr1073753655 className@var3351 .@expr1073753656 empty (@expr1073753657 ) ) {
3015: if (@expr1073753658 Token ::@expr1073753659 Match (@expr1073753660 scope@var3350 .@expr1073753661 classDef@var3352 , "struct|class %name% :: %name%" ) ) {
3016:
3017: name@var3349 .@expr1073753662 clear (@expr1073753663 ) ;
3018: break ;
3019: }
3020: name@var3349 =@expr1073753664 scope@var3350 .@expr1073753665 className@var3353 +@expr1073753666 "::" +@expr1073753667 name@var3349 ;
3021: scope@var3350 =@expr1073753668 scope@var3350 .@expr1073753669 nestedIn@var3354 ;
3022: }
3023: if (@expr1073753670 name@var3349 .@expr1073753671 empty (@expr1073753672 ) ) {
3024: continue ; }
3025: name@var3349 .@expr1073753673 erase (@expr1073753674 name@var3349 .@expr1073753675 size (@expr1073753676 ) -@expr1073753677 2 ) ;
3026: if (@expr1073753678 scope@var3350 .@expr1073753679 type@var3355 !=@expr1073753680 Scope ::@expr1073753681 ScopeType ::@expr1073753682 eGlobal ) {
3027: continue ; }
3028:
3029: MyFileInfo ::@expr1073753683 NameLoc nameLoc@var3356 ;
3030: nameLoc@var3356 .@expr1073753684 className@var3357 =@expr1073753685 name@var3349 ;
3031: nameLoc@var3356 .@expr1073753686 fileName@var3358 =@expr1073753687 tokenizer@var3342 .@expr1073753688 list@var3359 .@expr1073753689 file (@expr1073753690 classScope@var3345 .@expr11867 classDef@var3360 ) ;
3032: nameLoc@var3356 .@expr1073753692 lineNumber@var3361 =@expr1073753693 classScope@var3345 .@expr11867 classDef@var3360 .@expr1073753695 linenr (@expr1073753696 ) ;
3033: nameLoc@var3356 .@expr1073753697 column@var3362 =@expr1073753698 classScope@var3345 .@expr11867 classDef@var3360 .@expr1073753700 column (@expr1073753701 ) ;
3034:
3035:
3036: std ::@expr1073753702 string def@var3363 ;
3037: for (@expr1073753703 const Token *@expr11800 tok@var3364 =@expr1073753705 classScope@var3345 .@expr11867 classDef@var3360 ; tok@var3364 !=@expr1073753707 classScope@var3345 .@expr1073753708 bodyEnd@var3365 ; tok@var3364 =@expr1073753709 tok@var3364 .@expr1073753710 next (@expr1073753711 ) ) {
3038: def@var3363 +=@expr1073753712 tok@var3364 .@expr1073753713 str (@expr1073753714 ) ; }
3039: for (@expr1073753715 const Function &@expr11819 f@var3366 :@expr1073753717 classScope@var3345 .@expr11811 functionList@var3347 ) {
3040: if (@expr1073753719 f@var3366 .@expr11896 functionScope@var3367 &&@expr1073753721 f@var3366 .@expr11896 functionScope@var3367 .@expr1073753723 nestedIn@var3368 !=@expr1073753724 classScope@var3345 ) {
3041: for (@expr1073753725 const Token *@expr11800 tok@var3369 =@expr1073753727 f@var3366 .@expr11896 functionScope@var3367 .@expr1073753729 bodyStart@var3370 ; tok@var3369 !=@expr1073753730 f@var3366 .@expr11896 functionScope@var3367 .@expr1073753732 bodyEnd@var3371 ; tok@var3369 =@expr1073753733 tok@var3369 .@expr1073753734 next (@expr1073753735 ) ) {
3042: def@var3363 +=@expr1073753736 tok@var3369 .@expr1073753737 str (@expr1073753738 ) ; }
3043: }
3044: }
3045: nameLoc@var3356 .@expr1073753739 hash@var3372 =@expr1073753740 std ::@expr1073753741 hash < std ::@expr11798 string > {@expr1073753743 } (@expr1073753744 def@var3363 ) ;
3046:
3047: classDefinitions@var3344 .@expr1073753745 push_back (@expr1073753746 nameLoc@var3356 ) ;
3048: }
3049:
3050: if (@expr1073753747 classDefinitions@var3344 .@expr1073753748 empty (@expr1073753749 ) ) {
3051: return nullptr ; }
3052:
3053: MyFileInfo * fileInfo@var3373 ; fileInfo@var3373 =@expr1073753750 new MyFileInfo ;
3054: fileInfo@var3373 .@expr1073753751 classDefinitions@var3374 .@expr1073753752 swap (@expr1073753753 classDefinitions@var3344 ) ;
3055: return fileInfo@var3373 ;
3056: }
3057:
3058: std :: string CheckClass :: MyFileInfo :: toString ( ) const
3059: {
3060: std ::@expr1073753754 string ret@var3375 ;
3061: for (@expr1073753755 const MyFileInfo ::@expr1073753756 NameLoc &@expr1073753757 nameLoc@var3376 :@expr1073753758 classDefinitions@var1657 ) {
3062: ret@var3375 +=@expr1073753759 "<class name=\"" +@expr1073753760 ErrorLogger ::@expr11937 toxml (@expr1073753762 nameLoc@var3376 .@expr1073753763 className@var3377 ) +@expr1073753764
3063: "\" file=\"" +@expr1073753765 ErrorLogger ::@expr11937 toxml (@expr1073753767 nameLoc@var3376 .@expr1073753768 fileName@var3378 ) +@expr1073753769
3064: "\" line=\"" +@expr1073753770 std ::@expr11947 to_string (@expr1073753772 nameLoc@var3376 .@expr1073753773 lineNumber@var3379 ) +@expr1073753774
3065: "\" col=\"" +@expr1073753775 std ::@expr11947 to_string (@expr1073753777 nameLoc@var3376 .@expr1073753778 column@var3380 ) +@expr1073753779
3066: "\" hash=\"" +@expr1073753780 std ::@expr11947 to_string (@expr1073753782 nameLoc@var3376 .@expr1073753783 hash@var3381 ) +@expr1073753784
3067: "\"/>\n" ;
3068: }
3069: return ret@var3375 ;
3070: }
3071:
3072: Check :: FileInfo * CheckClass :: loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var3382 ) const
3073: {
3074: MyFileInfo * fileInfo@var3383 ; fileInfo@var3383 =@expr1073753785 new MyFileInfo ;
3075: for (@expr1073753786 const tinyxml2 ::@expr1073753787 XMLElement *@expr1073753788 e@var3384 =@expr1073753789 xmlElement@var3382 .@expr1073753790 FirstChildElement (@expr1073753791 ) ; e@var3384 ; e@var3384 =@expr1073753792 e@var3384 .@expr1073753793 NextSiblingElement (@expr1073753794 ) ) {
3076: if (@expr1073753795 std ::@expr1073753796 strcmp (@expr1073753797 e@var3384 .@expr1073753798 Name (@expr1073753799 ) , "class" ) !=@expr1073753800 0 ) {
3077: continue ; }
3078: const char * name@var3385 ; name@var3385 =@expr1073753801 e@var3384 .@expr11978 Attribute (@expr1073753803 "name" ) ;
3079: const char * file@var3386 ; file@var3386 =@expr1073753804 e@var3384 .@expr11978 Attribute (@expr1073753806 "file" ) ;
3080: const char * line@var3387 ; line@var3387 =@expr1073753807 e@var3384 .@expr11978 Attribute (@expr1073753809 "line" ) ;
3081: const char * col@var3388 ; col@var3388 =@expr1073753810 e@var3384 .@expr11978 Attribute (@expr1073753812 "col" ) ;
3082: const char * hash@var3389 ; hash@var3389 =@expr1073753813 e@var3384 .@expr11978 Attribute (@expr1073753815 "hash" ) ;
3083: if (@expr1073753816 name@var3385 &&@expr1073753817 file@var3386 &&@expr1073753818 line@var3387 &&@expr1073753819 col@var3388 &&@expr1073753820 hash@var3389 ) {
3084: MyFileInfo ::@expr1073753821 NameLoc nameLoc@var3390 ;
3085: nameLoc@var3390 .@expr1073753822 className@var3391 =@expr1073753823 name@var3385 ;
3086: nameLoc@var3390 .@expr1073753824 fileName@var3392 =@expr1073753825 file@var3386 ;
3087: nameLoc@var3390 .@expr1073753826 lineNumber@var3393 =@expr1073753827 std ::@expr12004 atoi (@expr1073753829 line@var3387 ) ;
3088: nameLoc@var3390 .@expr1073753830 column@var3394 =@expr1073753831 std ::@expr12004 atoi (@expr1073753833 col@var3388 ) ;
3089: nameLoc@var3390 .@expr1073753834 hash@var3395 =@expr1073753835 MathLib ::@expr1073753836 toULongNumber (@expr1073753837 hash@var3389 ) ;
3090: fileInfo@var3383 .@expr12014 classDefinitions@var3396 .@expr1073753839 push_back (@expr1073753840 nameLoc@var3390 ) ;
3091: }
3092: }
3093: if (@expr1073753841 fileInfo@var3383 .@expr12014 classDefinitions@var3396 .@expr1073753843 empty (@expr1073753844 ) ) {
3094: delete fileInfo@var3383 ;
3095: fileInfo@var3383 =@expr1073753845 nullptr ;
3096: }
3097: return fileInfo@var3383 ;
3098: }
3099:
3100: bool CheckClass :: analyseWholeProgram ( const CTU :: FileInfo * ctu@var3397 , const std :: list < Check :: FileInfo * > & fileInfo@var3398 , const Settings & settings@var3399 , ErrorLogger & errorLogger@var3400 )
3101: {
3102: bool foundErrors@var3401 ; foundErrors@var3401 =@expr1073753847 false ;
3103: (@expr1073753848 void ) ctu@var3397 ;
3104: (@expr1073753849 void ) settings@var3399 ;
3105:
3106: std ::@expr1073753850 unordered_map < std ::@expr12027 string , MyFileInfo ::@expr12027 NameLoc > all@var3402 ;
3107:
3108: for (@expr1073753853 Check ::@expr12027 FileInfo *@expr12031 fi1@var3403 :@expr1073753856 fileInfo@var3398 ) {
3109: const MyFileInfo * fi@var3404 ; fi@var3404 =@expr1073753857 dynamic_cast < MyFileInfo *@expr12031 > (@expr1073753859 fi1@var3403 ) ;
3110: if (@expr1073753860 !@expr1073753861 fi@var3404 ) {
3111: continue ; }
3112: for (@expr1073753862 const MyFileInfo ::@expr12027 NameLoc &@expr1073753864 nameLoc@var3405 :@expr1073753865 fi@var3404 .@expr1073753866 classDefinitions@var3406 ) {
3113: auto it@var3407 ; it@var3407 =@expr1073753867 all@var3402 .@expr1073753868 find (@expr1073753869 nameLoc@var3405 .@expr12046 className@var3408 ) ;
3114: if (@expr1073753871 it@var3407 ==@expr1073753872 all@var3402 .@expr1073753873 end (@expr1073753874 ) ) {
3115: all@var3402 [@expr1073753875 nameLoc@var3405 .@expr12046 className@var3408 ] =@expr1073753877 nameLoc@var3405 ;
3116: continue ;
3117: }
3118: if (@expr1073753878 it@var3407 .@expr12055 second@var3409 .@expr1073753880 hash@var3410 ==@expr1073753881 nameLoc@var3405 .@expr1073753882 hash@var3411 ) {
3119: continue ; }
3120:
3121: if (@expr1073753883 it@var3407 .@expr12055 second@var3409 .@expr1073753885 isSameLocation (@expr1073753886 nameLoc@var3405 ) ) {
3122: continue ; }
3123:
3124: std ::@expr1073753887 list < ErrorMessage ::@expr12027 FileLocation > locationList@var3412 ;
3125: locationList@var3412 .@expr12065 emplace_back (@expr1073753890 nameLoc@var3405 .@expr1073753891 fileName@var3413 , nameLoc@var3405 .@expr1073753892 lineNumber@var3414 , nameLoc@var3405 .@expr1073753893 column@var3415 ) ;
3126: locationList@var3412 .@expr12065 emplace_back (@expr1073753895 it@var3407 .@expr12055 second@var3409 .@expr1073753897 fileName@var3416 , it@var3407 .@expr12055 second@var3409 .@expr1073753899 lineNumber@var3417 , it@var3407 .@expr12055 second@var3409 .@expr1073753901 column@var3418 ) ;
3127:
3128: const ErrorMessage errmsg@var3419 (@expr1073753902 locationList@var3412 ,
3129: emptyString@var1 ,
3130: Severity ::@expr1073753903 error@expr1073753846 ,
3131: "$symbol:" +@expr1073753904 nameLoc@var3405 .@expr12046 className@var3408 +@expr1073753906
3132: "\nThe one definition rule is violated, different classes/structs have the same name '$symbol'" ,
3133: "ctuOneDefinitionRuleViolation" ,
3134: CWE_ONE_DEFINITION_RULE@var2542 ,
3135: Certainty ::@expr1073753907 normal ) ;
3136: errorLogger@var3400 .@expr1073753908 reportErr (@expr1073753909 errmsg@var3419 ) ;
3137:
3138: foundErrors@var3401 =@expr1073753910 true ;
3139: }
3140: }
3141: return foundErrors@var3401 ;
3142: }

##file cppcheck-2.8/lib/settings.h

19:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3420 ; mFlags@var3420 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3420 ;
54: }
55: void clear ( ) {
56: mFlags@var3420 =@expr1073753911 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3420 =@expr1073753912 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3421 ) {
62: if (@expr1073753913 enabled@var3421 ) {
63: fill (@expr1073753914 ) ; }
64: else {
65: clear (@expr1073753915 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3422 ) const {
68: return (@expr12092 mFlags@var3420 &@expr1073753917 (@expr12092 1U <<@expr1073753919 (@expr1073753920 uint32_t ) flag@var3422 ) ) !=@expr1073753921 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3423 ) {
71: mFlags@var3420 |=@expr1073753922 (@expr1073753923 1U <<@expr1073753924 (@expr1073753925 uint32_t ) flag@var3423 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3424 ) {
74: mFlags@var3420 &=@expr1073753926 ~@expr1073753927 (@expr1073753928 1U <<@expr1073753929 (@expr1073753930 uint32_t ) flag@var3424 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3425 , bool enabled@var3426 ) {
77: if (@expr1073753931 enabled@var3426 ) {
78: enable (@expr1073753932 flag@var3425 ) ; }
79: else {
80: disable (@expr1073753933 flag@var3425 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3427 ; mFlags@var3427 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3427 ;
54: }
55: void clear ( ) {
56: mFlags@var3427 =@expr1073753934 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3427 =@expr1073753935 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3428 ) {
62: if (@expr1073753936 enabled@var3428 ) {
63: fill (@expr1073753937 ) ; }
64: else {
65: clear (@expr1073753938 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3429 ) const {
68: return (@expr12115 mFlags@var3427 &@expr1073753940 (@expr12115 1U <<@expr1073753942 (@expr1073753943 uint32_t ) flag@var3429 ) ) !=@expr1073753944 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3430 ) {
71: mFlags@var3427 |=@expr1073753945 (@expr1073753946 1U <<@expr1073753947 (@expr1073753948 uint32_t ) flag@var3430 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3431 ) {
74: mFlags@var3427 &=@expr1073753949 ~@expr1073753950 (@expr1073753951 1U <<@expr1073753952 (@expr1073753953 uint32_t ) flag@var3431 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3432 , bool enabled@var3433 ) {
77: if (@expr1073753954 enabled@var3433 ) {
78: enable (@expr1073753955 flag@var3432 ) ; }
79: else {
80: disable (@expr1073753956 flag@var3432 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3434 ; mFlags@var3434 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3434 ;
54: }
55: void clear ( ) {
56: mFlags@var3434 =@expr1073753957 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3434 =@expr1073753958 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3435 ) {
62: if (@expr1073753959 enabled@var3435 ) {
63: fill (@expr1073753960 ) ; }
64: else {
65: clear (@expr1073753961 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3436 ) const {
68: return (@expr12138 mFlags@var3434 &@expr1073753963 (@expr12138 1U <<@expr1073753965 (@expr1073753966 uint32_t ) flag@var3436 ) ) !=@expr1073753967 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3437 ) {
71: mFlags@var3434 |=@expr1073753968 (@expr1073753969 1U <<@expr1073753970 (@expr1073753971 uint32_t ) flag@var3437 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3438 ) {
74: mFlags@var3434 &=@expr1073753972 ~@expr1073753973 (@expr1073753974 1U <<@expr1073753975 (@expr1073753976 uint32_t ) flag@var3438 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3439 , bool enabled@var3440 ) {
77: if (@expr1073753977 enabled@var3440 ) {
78: enable (@expr1073753978 flag@var3439 ) ; }
79: else {
80: disable (@expr1073753979 flag@var3439 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  severity possible 2@92
  id possible "copyCtorAndEqOperator"@92
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  severity possible {2@24,3@35,5@78,4@171}
  id possible {"unsafeClassRefMember"@24,"thisSubtraction"@148,"operatorEqToSelf"@179,"operatorEqShouldBeLeftUnimplemented"@35,"operatorEqRetRefThis"@36,"memsetClassFloat"@78,"unusedPrivateFunction"@147,"useInitializationList"@171,"noExplicitConstructor"@206,"noConstructor"@207}
  msg possible {"Suspicious pointer subtraction. Did you intend to write '->'?"@148,"'operator=' should check for assignment to self to avoid problems with dynamic memory.\n'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class."@179,"'operator=' should either return reference to 'this' instance or be declared private and left unimplemented."@35,"'operator=' should return reference to 'this' instance."@36}
  certainty possible 0@24
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@9,128@10,64@11,32@12,16@13,8@14,4@15,2@16,1@17}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@18,128@19,64@20,32@21,16@22,8@23,4@24,2@25,1@26}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@18,4294967167@19,4294967231@20,4294967263@21,4294967279@22,4294967287@23,4294967291@24,4294967293@25,4294967294@26}
  flag {!<=-1,256@18,128@19,64@20,32@21,16@22,8@23,4@24,2@25,1@26}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible {symbolic=(func.tokenDef->str())@134,symbolic=(opName)@134,size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str {symbolic=(func.tokenDef->str())@134,symbolic=(opName)@134,!size=0}
  == always {!<=-1,!>=2}
  c possible {38@134,42@135,39@42503,34@42759}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@166,34@167}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@166,""@167,""@168,"U"@169,"U"@170,"u"@171,"u"@172,"u8"@173,"u8"@174}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@4,34@5}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@1,34@3}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok1->next())@72,symbolic=(var->typeEndToken())@126}
  pattern possible {") {"@130,"else {"@134,"."@139,"("@146,"::"@158,"( const"@236,") <<"@60,">> * this"@65,"return {"@66,"( ) ("@72}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@155,4@156,0@157}
  t possible {10@155,4@156,0@157}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@155,4@156,0@157}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@155,0@157}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@155,0@157}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@155}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@155}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@155}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@155}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@155}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"&"@81,"&"@191,"*"@42}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@163}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible "; __property ;"@149
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@165,17179869184@176,8589934592@178,34359738368@180,4294967296@182,2147483648@184,1073741824@186,536870912@188,268435456@190}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@252,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@253}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@164,17179869184@175,8589934592@177,34359738368@179,4294967296@181,2147483648@183,1073741824@185,536870912@187,268435456@189}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@164,17179869184@175,8589934592@177,34359738368@179,4294967296@181,2147483648@183,1073741824@185,536870912@187,268435456@189}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@88,4096@91,16384@94,2048@95,1024@96,65536@97,512@98,256@99,128@100}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@53,4194304@55,8388608@56,2097152@58,1048576@59,524288@60,262144@61,131072@62,65536@63}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@31,2097152@32,1048576@33,524288@34,262144@35,131072@36,65536@37,32768@38,16384@39}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@31,4292870143@32,4293918719@33,4294443007@34,4294705151@35,4294836223@36,4294901759@37,4294934527@38,4294950911@39}
  flag {!<=-1,8388608@31,2097152@32,1048576@33,524288@34,262144@35,131072@36,65536@37,32768@38,16384@39}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 56
  ( always "Class"
  nullptr always 0
Line 63
  ( always {!<=-1,!>=2}
Line 164
  hash always !<=-1
Line 166
  ( always {!<=-1,!>=2}
Line 167
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 170
  ( always {!<=-1,!>=2}
Line 171
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 172
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 173
  == always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 235
  nullptr always 0
Line 236
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 237
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 239
  nullptr always 0
  "var" always "var"
Line 240
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 241
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 242
  nullptr always 0
  false always 0
  nullptr always 0
Line 243
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  false always 0
  false always 0
Line 244
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  false always 0
  false always 0
Line 245
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  true always 1
  false always 0
Line 246
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  true always 1
  false always 0
Line 247
  nullptr always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
Line 248
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 249
  nullptr always 0
  "classname" always "classname"
  "funcname" always "funcname"
Line 250
  nullptr always 0
  "memfunc" always "memfunc"
  "classname" always "classname"
  "class" always "class"
Line 251
  nullptr always 0
  "memfunc" always "memfunc"
  "class" always "class"
Line 252
  nullptr always 0
  "class" always "class"
Line 253
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
Line 254
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
  "std::string" always "std::string"
Line 255
  nullptr always 0
  "Base" always "Base"
  "Derived" always "Derived"
  false always 0
Line 256
  nullptr always 0
Line 257
  nullptr always 0
Line 258
  nullptr always 0
  true always 1
Line 259
  nullptr always 0
Line 260
  nullptr always 0
Line 261
  nullptr always 0
  "class" always "class"
  "function" always "function"
  false always 0
Line 262
  nullptr always 0
  "class" always "class"
  "function" always "function"
  true always 1
Line 263
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "variable" always "variable"
Line 264
  nullptr always 0
  "variable" always "variable"
Line 265
  nullptr always 0
  "var" always "var"
Line 266
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "class" always "class"
  "variable" always "variable"
  false always 0
  false always 0
Line 267
  nullptr always 0
  "class" always "class"
  false always 0
  false always 0
Line 268
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 269
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 270
  nullptr always 0
  nullptr always 0
Line 271
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 272
  nullptr always 0
  "UnsafeClass::var" always "UnsafeClass::var"
Line 276
  "Class" always "Class"
Line 280
  "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n" always "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
Line 310
  ( always {!<=-1,!>=2}
Line 311
  ( always {!<=-1,!>=2}
Line 312
  ( always {!<=-1,!>=2}
Line 313
  ( always {!<=-1,!>=2}
Line 314
  TRUE always 0
  FALSE always 1
  BAILOUT always 2
Line 319
  ( always {!<=-1,!>=2}
Line 320
  ( always {!<=-1,!>=2}
Line 321
  ( always {!<=-1,!>=2}
Line 322
  ( always {!<=-1,!>=2}
Line 327
  ( inconclusive lifetime[SubObject]=(var)
  assign always {!<=-1,!>=2}
  false always 0
  init always {!<=-1,!>=2}
  false always 0
Line 333
  assign always {!<=-1,!>=2}
Line 336
  init always {!<=-1,!>=2}
Line 339
  ( always {!<=-1,!>=2}
Line 404
  ( always {!<=-1,!>=2}
Line 406
  ( always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible {lifetime[Lambda]=(rhs)@182,lifetime[Lambda]=(ret)@182,lifetime[Lambda]=(localmember)@184,lifetime[Lambda]=(owner)@194,lifetime[Lambda]=(allowed)@194}
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 56
  398U always 398
Line 57
  404U always 404
Line 58
  665U always 665
Line 59
  758U always 758
Line 60
  762U always 762
Line 62
  758U always 758
Line 66
  type possible {1@90,3@90,4@113}
Line 67
  :: always 0
  eConstructor always 0
Line 68
  "constructor" always "constructor"
Line 69
  :: always 1
  eCopyConstructor always 1
Line 70
  "copy constructor" always "copy constructor"
Line 71
  :: always 2
  eMoveConstructor always 2
Line 72
  "move constructor" always "move constructor"
Line 73
  :: always 4
  eDestructor always 4
Line 74
  "destructor" always "destructor"
Line 75
  :: always 5
  eFunction always 5
Line 76
  "function" always "function"
Line 77
  :: always 3
  eOperatorEqual always 3
Line 78
  "operator=" always "operator="
Line 79
  :: always 6
  eLambda always 6
Line 80
  "lambda" always "lambda"
Line 82
  "" always ""
Line 85
  ( always {!<=-1,!>=2}
Line 87
  isOpEqual always {!<=-1,!>=2}
  isOpEqual always {!<=-1,!>=2}
  = always 0
  false always 0
Line 88
  type possible 3@186
Line 89
  :: always 3
  eOperatorEqual always 3
Line 90
  isOpEqual always {!<=-1,!>=2}
  = always 1
  true always 1
Line 92
  :: always 1
  eCopyConstructor always 1
Line 93
  :: always 2
  eMoveConstructor always 2
Line 96
  return always {!<=-1,!>=2}
  true always 1
Line 99
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isOpEqual always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 101
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
  || always {!<=-1,!>=2}
Line 102
  && always {!<=-1,!>=2}
  ( always !0
  >= always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
Line 105
  ( always {!<=-1,!>=2}
Line 107
  library possible size=3
Line 108
  == always {!<=-1,!>=2}
  "vcl" always "vcl"
Line 109
  return always {!<=-1,!>=2}
  true always 1
Line 111
  return always {!<=-1,!>=2}
  false always 0
Line 114
  ( always {!<=-1,!>=2}
Line 116
  ! always {!<=-1,!>=2}
Line 117
  return always {!<=-1,!>=2}
  false always 0
Line 118
  type always !0
Line 119
  ! always {!<=-1,!>=2}
Line 120
  return always {!<=-1,!>=2}
  true always 1
Line 121
  ( always {!<=-1,!>=2}
  . always !0
Line 122
  return always {!<=-1,!>=2}
  true always 1
Line 124
  return always {!<=-1,!>=2}
  false always 0
Line 131
  ? possible 0
  : always 0
  nullptr always 0
Line 140
  printStyle always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 141
  printWarnings always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 142
  ! always {!<=-1,!>=2}
  printStyle always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printWarnings always {!<=-1,!>=2}
Line 145
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 147
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  unusedTemplate always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">" always ">"
Line 152
  usedInUnion always {!<=-1,!>=2}
  usedInUnion always {!<=-1,!>=2}
  = always 0
  false always 0
Line 154
  != always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 157
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 158
  usedInUnion always {!<=-1,!>=2}
  = always 1
  true always 1
Line 165
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  printStyle always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  usedInUnion always {!<=-1,!>=2}
Line 167
  = always 0
  0 always 0
  = always 0
  0 always 0
Line 170
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 171
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
Line 173
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 174
  & {lifetime[Address]=(scope->varlist),!0}
Line 179
  > always {!<=-1,!>=2}
  haveInit possible 0
Line 180
  haveInit {<=symbolic=(needInit-1),!>=symbolic=(needInit)}
  == always {!<=-1,!>=2}
  0 always 0
Line 181
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 188
  ! always {!<=-1,!>=2}
  printWarnings always {!<=-1,!>=2}
Line 194
  bailout always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  = always 0
  false always 0
Line 196
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 197
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  bailout {!<=-1,!>=2,1}
Line 209
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
  && always {!<=-1,!>=2}
Line 210
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 214
  unusedTemplate always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
Line 216
  ( always {!<=-1,!>=2}
  initList always symbolic=(func.constructorMemberInitialization())
  ": %name% (" always ": %name% ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 224
  callstack always size=0
Line 231
  var always symbolic=(*usage.var)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  && always {!<=-1,!>=2}
  . always !3
  != always {!<=-1,!>=2}
  :: always 1
  eCopyConstructor always 1
Line 232
  . always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  = always 1
  true always 1
Line 236
  . always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always symbolic=(*usage.var)
  ( always {!<=-1,!>=2}
Line 239
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  False always 2
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 246
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
Line 248
  ! always {!<=-1,!>=2}
Line 253
  ( always !0
  != always {!<=-1,!>=2}
  :: always 1
  True always 1
Line 258
  ! {!<=-1,!>=2,1}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 259
  == always {!<=-1,!>=2}
  :: always 2
  eMoveConstructor always 2
Line 260
  ( always {!<=-1,!>=2}
  ( always !0
Line 263
  ( always {!<=-1,!>=2}
  ( always !0
Line 269
  missingCopy {!<=-1,!>=2,0}
  missingCopy always {!<=-1,!>=2}
  = always 0
  false always 0
Line 273
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . possible 3
Line 274
  ! always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
Line 277
  missingCopy always {!<=-1,!>=2}
  = always 1
  true always 1
Line 281
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
Line 284
  classNameUsed always {!<=-1,!>=2}
  classNameUsed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 285
  = always symbolic=(func.arg)
  operStart always symbolic=(func.arg)
  operTok possible symbolic=(func.arg)
  != always {!<=-1,!>=2}
  operStart {symbolic=(func.arg),symbolic=(operTok)}
Line 286
  == always {!<=-1,!>=2}
Line 287
  classNameUsed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 292
  classNameUsed {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  "operatorEqVarError" always "operatorEqVarError"
  != always {!<=-1,!>=2}
  :: always 2
  suppress always 2
Line 293
  missingCopy always {!<=-1,!>=2}
Line 294
  != always {!<=-1,!>=2}
  :: always 2
  Private always 2
  || always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 296
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 299
  ! {!<=-1,!>=2,1}
  varType {symbolic=(var.typeScope()),0}
  || always {!<=-1,!>=2}
  varType {symbolic=(var.typeScope()),!0}
  != always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 300
  derived always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 301
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
  && always {!<=-1,!>=2}
Line 302
  && always {!<=-1,!>=2}
  . always !0
  . always !0
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 303
  ( always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 304
  && always {!<=-1,!>=2}
  . always !0
  == always {!<=-1,!>=2}
  . always !0
  && always {!<=-1,!>=2}
Line 305
  . always symbolic=(func.arg->link()->next())
  == always {!<=-1,!>=2}
  . always symbolic=(func.arg->link()->next())
Line 307
  printInconclusive always {!<=-1,!>=2}
Line 308
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
  derived always {!<=-1,!>=2}
  true always 1
Line 309
  missingCopy always {!<=-1,!>=2}
Line 312
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
  derived always {!<=-1,!>=2}
  false always 0
Line 322
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 327
  == always {!<=-1,!>=2}
  0 always 0
Line 332
  isAbstractClass always {!<=-1,!>=2}
  isAbstractClass always {!<=-1,!>=2}
  = always 0
  false always 0
Line 334
  ( always {!<=-1,!>=2}
Line 335
  isAbstractClass always {!<=-1,!>=2}
  = always 1
  true always 1
Line 342
  isAbstractClass {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 352
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 355
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 356
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 357
  != always {!<=-1,!>=2}
  :: always 1
  eCopyConstructor always 1
  && always {!<=-1,!>=2}
Line 358
  . always !1
  != always {!<=-1,!>=2}
  :: always 2
  eMoveConstructor always 2
Line 359
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
Line 365
  ( always {!<=-1,!>=2}
Line 369
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
Line 370
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 374
  ( always {!<=-1,!>=2}
  . always !0
  . always !0
Line 375
  return always {!<=-1,!>=2}
  true always 1
Line 378
  != always {!<=-1,!>=2}
  :: always 1
  eCopyConstructor always 1
Line 380
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 381
  * always {!<=-1,!>=2}
  = always 0
  false always 0
Line 382
  return always {!<=-1,!>=2}
  true always 1
Line 386
  return always {!<=-1,!>=2}
  false always 0
Line 391
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 398
  != always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 400
  1 always 1
Line 401
  != always {!<=-1,!>=2}
  tok possible symbolic=(allocatedVars[tok->varId()])
Line 402
  ( always {!<=-1,!>=2}
  "%var% ( new" always "%var% ( new"
  || always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
  "%var% ( %name% (" always "%var% ( %name% ("
  && always {!<=-1,!>=2}
  2 always 2
Line 405
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
Line 409
  != always {!<=-1,!>=2}
  tok possible symbolic=(allocatedVars[tok->varId()])
Line 410
  ( always {!<=-1,!>=2}
  "%var% = new" always "%var% = new"
  || always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
  "%var% = %name% (" always "%var% = %name% ("
  && always {!<=-1,!>=2}
  2 always 2
Line 413
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  ( always {!<=-1,!>=2}
Line 419
  ! {!<=-1,!>=2,0}
  allocatedVars possible size=0
  ( {!<=-1,!>=2,1}
Line 420
  = always 0
  nullptr always 0
Line 421
  = always 0
  nullptr always 0
Line 422
  = always 0
  nullptr always 0
Line 424
  . possible {3,4}
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
Line 425
  = {&,lifetime[Address]=(scope->functionList),symbolic=(funcCopyCtor),!0}
  & {&,lifetime[Address]=(scope->functionList),symbolic=(funcCopyCtor),!0}
Line 426
  . {4,!1}
  == {!<=-1,!>=2,0}
  :: always 3
  eOperatorEqual always 3
Line 427
  = {&,lifetime[Address]=(scope->functionList),!0}
  & {&,lifetime[Address]=(scope->functionList),!0}
Line 428
  . always {!1,!3}
  == always {!<=-1,!>=2}
  :: always 4
  eDestructor always 4
Line 429
  = {&,lifetime[Address]=(scope->functionList),!0}
  & {&,lifetime[Address]=(scope->functionList),!0}
Line 431
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  funcCopyCtor always !0
  ( always {!<=-1,!>=2}
Line 432
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 433
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(unknown),!0}
  unknown always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 434
  allocatedVars always !size=0
  ( {lifetime[Iterator]=(allocatedVars),!size=0,start=0}
  unknown always 0
Line 436
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  funcOperatorEq always !0
  ( always {!<=-1,!>=2}
Line 437
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 438
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(unknown),!0}
  unknown always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 439
  allocatedVars always !size=0
  ( {lifetime[Iterator]=(allocatedVars),!size=0,start=0}
  unknown always 0
Line 441
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  funcDestructor always !0
  ( always {!<=-1,!>=2}
Line 442
  = always 0
  nullptr always 0
Line 443
  = {lifetime[Iterator]=(allocatedVars),!size=0,start=0}
  allocatedVars always !size=0
  ( {lifetime[Iterator]=(allocatedVars),!size=0,start=0}
  it {lifetime[Iterator]=(allocatedVars),!size=0,start=0}
  != always {!<=-1,!>=2}
  allocatedVars always !size=0
  ( {lifetime[Iterator]=(allocatedVars),!size=0,end=0}
Line 444
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  it {lifetime[Iterator]=(allocatedVars),!symbolic=(allocatedVars.end()),!end=0,!size=0}
  "%var% [(=] new %type%" always "%var% [(=] new %type%"
Line 445
  it {lifetime[Iterator]=(allocatedVars),!symbolic=(allocatedVars.end()),!end=0,!size=0}
Line 448
  && always {!<=-1,!>=2}
Line 453
  && always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 458
  mustDealloc possible {symbolic=(it->second),0}
Line 459
  mustDealloc {symbolic=(it->second),!0}
Line 464
  = always 0
  nullptr always 0
Line 466
  != always {!<=-1,!>=2}
  :: always 1
  eCopyConstructor always 1
Line 469
  ! always {!<=-1,!>=2}
Line 470
  allocatedVars always NonMovedVariable
Line 473
  . always symbolic=(copyCtor)
  1 always 1
Line 474
  == always {!<=-1,!>=2}
  ":" always ":"
Line 476
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 477
  ( possible lifetime[Iterator]=(allocatedVars)
  ( possible 0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(allocatedVars),end=0}
Line 478
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% . %name% )" always "%name% . %name% )"
Line 480
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%any% )" always "%any% )"
Line 483
  1 always 1
  2 always 2
Line 486
  != always {!<=-1,!>=2}
Line 487
  ( always {!<=-1,!>=2}
  "%var% = new|malloc|g_malloc|g_try_malloc|realloc|g_realloc|g_try_realloc" always "%var% = new|malloc|g_malloc|g_try_malloc|realloc|g_realloc|g_try_realloc"
Line 489
  ( always {!<=-1,!>=2}
  "%var% = %name% . %name% ;" always "%var% = %name% . %name% ;"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(allocatedVars)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(allocatedVars),end=0}
Line 495
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 496
  copiedVars always !size=0
Line 520
  tok possible 0@229
  :: always 2
  warning always 2
  "copyCtorPointerCopying" always "copyCtorPointerCopying"
Line 521
  "$symbol:" always "$symbol:"
  varname possible "var"@229
  "\nValue of pointer '$symbol', which points to allocated memory, is copied in copy constructor instead of allocating new memory." always "\nValue of pointer '$symbol', which points to allocated memory, is copied in copy constructor instead of allocating new memory."
  :: always 0
  normal always 0
Line 524
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
Line 526
  = possible "class"
  ? possible "class"
  scope always !0
  : always "class"
  "class" always "class"
Line 527
  && always {!<=-1,!>=2}
  scope always !0
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
  "Struct" always "Struct"
  : always "Class"
  "Class" always "Class"
Line 528
  isDestructor always {!<=-1,!>=2}
  = {!<=-1,!>=2,1,0}
  function possible {"destructor"@86,"operator="@87,"copy constructor"@88}
  [ possible {100,111,99}
  0 always 0
  == {!<=-1,!>=2,1,0}
  'd' always 100
Line 529
  "$symbol:" always "$symbol:"
  classname always symbolic=(scope?scope->className:"class")
  '\n' always 10
Line 531
  isdefault always {!<=-1,!>=2}
Line 532
  " '$symbol' has dynamic memory/resource allocation(s). The " always " '$symbol' has dynamic memory/resource allocation(s). The "
  function possible {"destructor"@86,"operator="@87,"copy constructor"@88}
  " is explicitly defaulted but the default " always " is explicitly defaulted but the default "
  function possible {"destructor"@86,"operator="@87,"copy constructor"@88}
  " does not work well." always " does not work well."
Line 533
  isDestructor {symbolic=(function[0]=='d'),!<=-1,!>=2,1,0}
Line 534
  " It is recommended to define the " always " It is recommended to define the "
  function possible "destructor"@86
  '.' always 46
Line 536
  " It is recommended to define or delete the " always " It is recommended to define or delete the "
  function possible {"operator="@87,"copy constructor"@88}
  '.' always 46
Line 538
  " '$symbol' does not have a " always " '$symbol' does not have a "
  function possible {"destructor"@86,"operator="@87,"copy constructor"@88}
  " which is recommended since it has dynamic memory/resource allocation(s)." always " which is recommended since it has dynamic memory/resource allocation(s)."
Line 544
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 546
  alloc possible 0@230
  :: always 2
  warning always 2
  "noCopyConstructor" always "noCopyConstructor"
  scope inconclusive 0@230
  "copy constructor" always "copy constructor"
  isdefault {!<=-1,!>=2,0@230}
  inconclusive {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 549
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 551
  alloc possible 0@231
  :: always 2
  warning always 2
  "noOperatorEq" always "noOperatorEq"
  scope inconclusive 0@231
  "operator=" always "operator="
  isdefault {!<=-1,!>=2,0@231}
  inconclusive {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 554
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
Line 556
  alloc possible {symbolic=(it->second)@112,0@232}
  :: always 2
  warning always 2
  "noDestructor" always "noDestructor"
  scope possible 0@232
  "destructor" always "destructor"
  isdefault {!<=-1,!>=2,0@232}
  :: always 0
  normal always 0
Line 559
  ( always {!<=-1,!>=2}
Line 561
  constructor always {!<=-1,!>=2}
  constructor always {!<=-1,!>=2}
  = always 0
  false always 0
Line 562
  publicAssign always {!<=-1,!>=2}
  publicAssign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 563
  publicCopy always {!<=-1,!>=2}
  publicCopy always {!<=-1,!>=2}
  = always 0
  false always 0
Line 566
  ( always {!<=-1,!>=2}
Line 567
  constructor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 568
  != always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 570
  . possible 3
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
Line 571
  publicCopy always {!<=-1,!>=2}
  = always 1
  true always 1
Line 573
  . always !1
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
Line 574
  publicAssign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 579
  return always {!<=-1,!>=2}
  constructor always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  publicAssign {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  publicCopy {!<=-1,!>=2,1}
Line 582
  ( always {!<=-1,!>=2}
Line 584
  constructor always {!<=-1,!>=2}
  constructor always {!<=-1,!>=2}
  = always 0
  false always 0
Line 585
  publicAssign always {!<=-1,!>=2}
  publicAssign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 586
  publicCopy always {!<=-1,!>=2}
  publicCopy always {!<=-1,!>=2}
  = always 0
  false always 0
Line 587
  publicMove always {!<=-1,!>=2}
  publicMove always {!<=-1,!>=2}
  = always 0
  false always 0
Line 590
  ( always {!<=-1,!>=2}
Line 591
  constructor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 592
  != always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 594
  . possible {2,3}
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
Line 595
  publicCopy always {!<=-1,!>=2}
  = always 1
  true always 1
Line 597
  . {3,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  eMoveConstructor always 2
Line 598
  publicMove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 600
  . always {!1,!2}
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
Line 601
  publicAssign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 606
  return always {!<=-1,!>=2}
  constructor always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  publicAssign {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  publicCopy {!<=-1,!>=2,1}
  || always {!<=-1,!>=2}
  publicMove {!<=-1,!>=2,1}
Line 612
  varList possible {lifetime[Object]=(scope->varlist),size=0@80}
  & {lifetime[Address]=(scope->varlist),!0}
Line 614
  . always !0
Line 615
  . always !0
  == always {!<=-1,!>=2}
Line 617
  . always !symbolic=(scope->definedType)
  . always {!symbolic=(scope->definedType),!0}
  : always 0
  nullptr always 0
Line 618
  baseClass always symbolic=(baseInfo.type?baseInfo.type->classScope:nullptr)
  && always {!<=-1,!>=2}
  baseClass {symbolic=(baseInfo.type?baseInfo.type->classScope:nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  baseClass {symbolic=(baseInfo.type?baseInfo.type->classScope:nullptr),!0}
  == always {!<=-1,!>=2}
  0 always 0
Line 619
  baseClass always !0
Line 628
  varlist always size=0
Line 629
  ret always size=0
  ( always !<=-1
Line 631
  ret possible size=0
Line 638
  == always {!<=-1,!>=2}
Line 639
  . always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 648
  == always {!<=-1,!>=2}
Line 649
  . always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  = always 1
  true always 1
Line 658
  . always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 664
  . always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 665
  . always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  = always 0
  false always 0
Line 669
  ( always {!<=-1,!>=2}
Line 676
  derivedFrom always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
Line 677
  derivedFrom {symbolic=(i.type),!0}
  . always !0
Line 680
  == always {!<=-1,!>=2}
Line 681
  return always {!<=-1,!>=2}
  true always 1
Line 683
  ( always {!<=-1,!>=2}
Line 684
  return always {!<=-1,!>=2}
  true always 1
Line 689
  return always {!<=-1,!>=2}
  true always 1
Line 692
  return always {!<=-1,!>=2}
  false always 0
Line 697
  ! always {!<=-1,!>=2}
Line 700
  initList always {!<=-1,!>=2}
  initList always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 702
  = always 0
  0 always 0
Line 703
  ftok possible symbolic=(func.arg->link()->next())
  && always {!<=-1,!>=2}
  ftok {symbolic=(func.arg->link()->next()),!0}
  != always {!<=-1,!>=2}
Line 706
  initList always {!<=-1,!>=2}
Line 707
  level possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% {|(" always "%name% {|("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "}|) ,|{" always "}|) ,|{"
Line 708
  != always {!<=-1,!>=2}
Line 713
  ! {!<=-1,!>=2,1}
  member {symbolic=(ftok->function()),0}
Line 720
  ( possible lifetime[Iterator]=(callstack)
  ( {lifetime[Iterator]=(callstack),start=0}
  ( {lifetime[Iterator]=(callstack),end=0}
  member {symbolic=(ftok->function()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callstack),end=0}
Line 727
  ( always {!<=-1,!>=2}
Line 739
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
Line 743
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|<" always "(|<"
Line 745
  == always {!<=-1,!>=2}
  "{" always "{"
Line 746
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 747
  ( always {!<=-1,!>=2}
  "%name%|>" always "%name%|>"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} ,|{" always "} ,|{"
Line 750
  initList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 751
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")|>|}" always ")|>|}"
Line 755
  initList {!<=-1,!>=2,0}
Line 759
  ( always {!<=-1,!>=2}
  ">>|& %name%" always ">>|& %name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 764
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 767
  ( always {!<=-1,!>=2}
  "( !" always "( !"
Line 771
  ( always {!<=-1,!>=2}
  "return| (| * this )| =" always "return| (| * this )| ="
Line 777
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %name% (" always "[;{}] %name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") . %name% ( *| this ) ;" always ") . %name% ( *| this ) ;"
Line 783
  ( always {!<=-1,!>=2}
  "%var% . %name% (" always "%var% . %name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 785
  == always {!<=-1,!>=2}
Line 792
  2 always 2
Line 795
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "::| %name%" always "::| %name%"
  && always {!<=-1,!>=2}
Line 796
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*| this . %name%" always "*| this . %name%"
  && always {!<=-1,!>=2}
Line 797
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "* %name% =" always "* %name% ="
  && always {!<=-1,!>=2}
Line 798
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( * this ) . %name%" always "( * this ) . %name%"
Line 805
  == always {!<=-1,!>=2}
  "return" always "return"
Line 809
  ( always {!<=-1,!>=2}
  "( * this ) ." always "( * this ) ."
Line 810
  5 always 5
Line 814
  ( always {!<=-1,!>=2}
  "this ." always "this ."
Line 815
  2 always 2
Line 818
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
Line 820
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 821
  2 always 2
Line 824
  ( always {!<=-1,!>=2}
  "::| memset ( this ," always "::| memset ( this ,"
Line 830
  ( always {!<=-1,!>=2}
  "::| memset ( &| this . %name%" always "::| memset ( &| this . %name%"
Line 831
  == always {!<=-1,!>=2}
  "::" always "::"
Line 833
  = always 4
  4 always 4
Line 834
  2 always 2
  == always {!<=-1,!>=2}
  "&" always "&"
Line 835
  ++ always 5
  offsetToMember always 4
Line 836
  offsetToMember possible 4
Line 837
  1 always 1
Line 842
  ( always {!<=-1,!>=2}
  "::| memset ( %name% ," always "::| memset ( %name% ,"
Line 843
  == always {!<=-1,!>=2}
  "::" always "::"
Line 845
  2 always 2
Line 846
  1 always 1
Line 851
  ( always {!<=-1,!>=2}
  "operator= (" always "operator= ("
Line 853
  = always !0
  ( always !0
Line 856
  ( possible lifetime[Iterator]=(callstack)
  ( {lifetime[Iterator]=(callstack),start=0}
  ( {lifetime[Iterator]=(callstack),end=0}
  member {symbolic=(ftok->function()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callstack),end=0}
Line 863
  member inconclusive symbolic=(ftok->function())
  ( always {!<=-1,!>=2}
Line 880
  ( always {!<=-1,!>=2}
  "::| %name% (" always "::| %name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while|for" always "if|while|for"
Line 881
  == always {!<=-1,!>=2}
  "::" always "::"
Line 885
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 886
  == always {!<=-1,!>=2}
  "this" always "this"
Line 893
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 894
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 895
  = always !0
  ( always !0
Line 899
  ( possible lifetime[Iterator]=(callstack)
  ( {lifetime[Iterator]=(callstack),start=0}
  ( {lifetime[Iterator]=(callstack),end=0}
  member {symbolic=(ftok->function()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callstack),end=0}
Line 905
  member inconclusive symbolic=(ftok->function())
  ( always {!<=-1,!>=2}
Line 908
  scope always symbolic=(ftok->function()->nestedIn)
Line 913
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 915
  ( always {!<=-1,!>=2}
  "[(,] &| %name% [,)]" always "[(,] &| %name% [,)]"
Line 917
  == always {!<=-1,!>=2}
  "&" always "&"
Line 933
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 941
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 947
  2 always 2
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 948
  ( always {!<=-1,!>=2}
Line 957
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
Line 959
  bailout always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 960
  2 always 2
Line 961
  == always {!<=-1,!>=2}
  "&" always "&"
Line 963
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 965
  && always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "[" always "["
Line 970
  ( always {!<=-1,!>=2}
  "%name% [|." always "%name% [|."
Line 972
  tok2 possible symbolic=(ftok)
Line 973
  tok2 {symbolic=(ftok),!0}
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 974
  tok2 always !0
Line 975
  ( always {!<=-1,!>=2}
  tok2 always !0
  ". %name%" always ". %name%"
Line 976
  tok2 always !0
  2 always 2
Line 980
  tok2 possible {symbolic=(ftok),0}
  && always {!<=-1,!>=2}
  tok2 always !0
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 985
  ( always {!<=-1,!>=2}
  "* %name% =" always "* %name% ="
Line 987
  ( always {!<=-1,!>=2}
  "* this . %name% =" always "* this . %name% ="
Line 988
  3 always 3
Line 992
  ( always {!<=-1,!>=2}
  "%name% . clear|Clear (" always "%name% . clear|Clear ("
Line 998
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 1001
  tok possible 0@227
  :: always 3
  style always 3
  "noConstructor" always "noConstructor"
Line 1002
  "$symbol:" always "$symbol:"
  classname possible "classname"@227
  "\n" always "\n"
Line 1003
  "The " always "The "
  isStruct {!<=-1,!>=2,0,1@152}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
  " '$symbol' does not declare a constructor although it has private member variables which likely require initialization.\nThe " always " '$symbol' does not declare a constructor although it has private member variables which likely require initialization.\nThe "
Line 1004
  isStruct {!<=-1,!>=2,0@152,1@152}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
  " '$symbol' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior." always " '$symbol' does not declare a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior."
Line 1006
  :: always 0
  normal always 0
Line 1009
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 1011
  isStruct {!<=-1,!>=2,0@133,1@133}
  ? possible {"Struct","Class"}
  "Struct" always "Struct"
  : always "Class"
  "Class" always "Class"
  " '$symbol' has a constructor with 1 argument that is not explicit." always " '$symbol' has a constructor with 1 argument that is not explicit."
Line 1012
  " Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided." always " Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided."
Line 1013
  tok possible 0@228
  :: always 3
  style always 3
  "noExplicitConstructor" always "noExplicitConstructor"
  "$symbol:" always "$symbol:"
  classname possible "classname"@228
  '\n' always 10
  '\n' always 10
  :: always 0
  normal always 0
Line 1016
  , always {!<=-1,!>=2}
  isprivate always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  derived always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1019
  functionType possible {2,0@233}
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
Line 1020
  = always "copy "
  "copy " always "copy "
Line 1021
  functionType {!1,0@233}
  == always {!<=-1,!>=2}
  :: always 2
  eMoveConstructor always 2
Line 1022
  = always "move "
  "move " always "move "
Line 1023
  "Member variable '$symbol' is not initialized in the " always "Member variable '$symbol' is not initialized in the "
  + possible size=57
  ctor possible {"copy ",size=5,"move "}
  + possible size=69
  "constructor." always "constructor."
Line 1024
  derived {!<=-1,!>=2,0@233,1@235}
Line 1025
  " Maybe it should be initialized directly in the class " always " Maybe it should be initialized directly in the class "
  classname possible {"classname"@235,"classname"@236}
  "?" always "?"
Line 1026
  "uninit" always "uninit"
  derived {!<=-1,!>=2,1,0}
  ? possible {"Derived",""}
  "Derived" always "Derived"
  : always ""
  "" always ""
  "MemberVar" always "MemberVar"
  isprivate {!<=-1,!>=2,0@199,1@199}
  ? possible {"Private",""}
  "Private" always "Private"
  : always ""
  "" always ""
Line 1027
  tok possible 0@233
  :: always 2
  warning always 2
  "$symbol:" always "$symbol:"
  classname inconclusive {"classname"@233,"classname"@234,"classname"@235,"classname"@236}
  "::" always "::"
  varname inconclusive {"varname"@233,"varnamepriv"@234,"varname"@235,"varnamepriv"@236}
  "\n" always "\n"
  inconclusive {!<=-1,!>=2,1@199,0@205}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1032
  "Member variable '$symbol' is not initialized." always "Member variable '$symbol' is not initialized."
Line 1033
  "uninitMemberVarPrivate" always "uninitMemberVarPrivate"
Line 1034
  :: always 2
  warning always 2
  "$symbol:" always "$symbol:"
  "::" always "::"
  "\n" always "\n"
  :: always 0
  normal always 0
Line 1039
  functionType possible {1,0@237}
  == {!<=-1,!>=2,1}
  :: always 1
  eCopyConstructor always 1
  ? possible {"copy","move"}
  "copy" always "copy"
  : always "move"
  "move" always "move"
Line 1040
  functionType possible 0@237
  == {!<=-1,!>=2,0}
  :: always 1
  eCopyConstructor always 1
  ? possible {"copied?","moved?"}
  "copied?" always "copied?"
  : always "moved?"
  "moved?" always "moved?"
Line 1042
  "$symbol:" always "$symbol:"
  classname possible "classname"@237
  "::" always "::"
  varname possible "varnamepriv"@237
  "\n" always "\n"
Line 1043
  "Member variable '$symbol' is not assigned in the " always "Member variable '$symbol' is not assigned in the "
  " constructor. Should it be " always " constructor. Should it be "
Line 1044
  18 always 18
  = always "missingMemberCopy"
  "missingMemberCopy" always "missingMemberCopy"
Line 1045
  tok possible 0@237
  :: always 2
  warning always 2
  id always "missingMemberCopy"
Line 1048
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1050
  tok possible 0@238
  :: always 2
  warning always 2
  "operatorEqVarError" always "operatorEqVarError"
  "$symbol:" always "$symbol:"
  classname inconclusive "classname"@238
  "::" always "::"
  "\nMember variable '$symbol' is not assigned a value in '" always "\nMember variable '$symbol' is not assigned a value in '"
  classname inconclusive "classname"@238
  "::operator='." always "::operator='."
  inconclusive {!<=-1,!>=2,0@238}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1059
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 1064
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
Line 1068
  . always !0
Line 1069
  ( always {!<=-1,!>=2}
  initList always !0
  ": %name% {|(" always ": %name% {|("
  && always {!<=-1,!>=2}
  initList always !0
  1 always 1
  == always {!<=-1,!>=2}
Line 1074
  != always {!<=-1,!>=2}
Line 1075
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1077
  ( always {!<=-1,!>=2}
  "try|do {" always "try|do {"
Line 1079
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "." always "."
Line 1083
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1085
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1087
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!var->valueType()" always "!var->valueType()"
  && always {!<=-1,!>=2}
  var always !0
  > always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 1091
  2 always 2
  && always {!<=-1,!>=2}
  2 always 2
  > always {!<=-1,!>=2}
  2 always 2
Line 1095
  localmember {!<=-1,!>=2,0}
  localmember always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1097
  [ possible lifetime[Lambda]=(localmember)
Line 1098
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1099
  localmember always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1100
  :: always 3
  op1_and_op2 always 3
Line 1102
  localmember always {!<=-1,!>=2}
Line 1105
  allowed {!<=-1,!>=2,1}
  allowed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1107
  [ possible {lifetime[Lambda]=(owner),lifetime[Lambda]=(allowed),lifetime[Lambda]=(if(Token::Match(tok2,"%name% (")&&tok2->strAt(-1)!="."&&isMemberFunc(owner,tok2)))}
Line 1109
  var2 always symbolic=(tok2->variable())
Line 1110
  var2 {symbolic=(tok2->variable()),!0}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "." always "."
Line 1111
  allowed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1112
  :: always 4
  done always 4
Line 1113
  var2 {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var2 {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1114
  allowed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1115
  :: always 4
  done always 4
Line 1117
  == always {!<=-1,!>=2}
  "this" always "this"
Line 1118
  allowed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1119
  :: always 4
  done always 4
Line 1120
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1121
  allowed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1122
  :: always 4
  done always 4
Line 1124
  :: always 3
  op1_and_op2 always 3
Line 1126
  ! always {!<=-1,!>=2}
  allowed always {!<=-1,!>=2}
Line 1136
  tok possible 0@254
  :: always 4
  performance always 4
  "useInitializationList" always "useInitializationList"
  "$symbol:" always "$symbol:"
  varname possible "variable"@254
  "\nVariable '$symbol' is assigned in constructor body. Consider performing initialization in initialization list.\nWhen an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '$symbol' a value by passing the value to the constructor in the initialization list." always "\nVariable '$symbol' is assigned in constructor body. Consider performing initialization in initialization list.\nWhen an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '$symbol' a value by passing the value to the constructor in the initialization list."
Line 1139
  :: always 0
  normal always 0
Line 1146
  ( always {!<=-1,!>=2}
Line 1148
  ! always {!<=-1,!>=2}
Line 1149
  return always {!<=-1,!>=2}
  true always 1
Line 1151
  = {lifetime[Iterator]=(scope->functionList),start=0}
  scope always !0
  ( {lifetime[Iterator]=(scope->functionList),start=0}
  func possible {lifetime[Iterator]=(scope->functionList),start=0}
  != always {!<=-1,!>=2}
  scope always !0
  ( {lifetime[Iterator]=(scope->functionList),end=0}
  func possible lifetime[Iterator]=(scope->functionList)
Line 1152
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
Line 1153
  ( always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  "%name% (" always "%name% ("
Line 1154
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  2 always 2
  && always {!<=-1,!>=2}
  ftok always !0
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1155
  ( always {!<=-1,!>=2}
  "= %name% [(,)]" always "= %name% [(,)]"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
Line 1156
  return always {!<=-1,!>=2}
  true always 1
Line 1157
  == always {!<=-1,!>=2}
  "(" always "("
Line 1161
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  1 always 1
  != always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
Line 1162
  == always {!<=-1,!>=2}
Line 1163
  return always {!<=-1,!>=2}
  true always 1
Line 1164
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  privfunc always !symbolic=(ftok->function())
Line 1165
  return always {!<=-1,!>=2}
  true always 1
Line 1167
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  . possible 3
  != {!<=-1,!>=2,1}
  :: always 1
  eCopyConstructor always 1
  && always {!<=-1,!>=2}
Line 1168
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  . always !1
  != always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  || always {!<=-1,!>=2}
Line 1169
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  != always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 1170
  return always {!<=-1,!>=2}
  true always 1
Line 1173
  = {lifetime[Iterator]=(scope->definedTypesMap),end=0}
  scope always !0
  ( {lifetime[Iterator]=(scope->definedTypesMap),end=0}
Line 1174
  = {lifetime[Iterator]=(scope->definedTypesMap),start=0}
  scope always !0
  ( {lifetime[Iterator]=(scope->definedTypesMap),start=0}
  iter possible {lifetime[Iterator]=(scope->definedTypesMap),start=0}
  != always {!<=-1,!>=2}
Line 1175
  iter {lifetime[Iterator]=(scope->definedTypesMap),!symbolic=(end)}
Line 1176
  type always symbolic=((*iter).second)
  == always {!<=-1,!>=2}
  scope always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type always symbolic=((*iter).second)
Line 1177
  return always {!<=-1,!>=2}
  true always 1
Line 1180
  scope always !0
Line 1181
  ( always {!<=-1,!>=2}
Line 1182
  scope always !0
  "%varid% =|(|{" always "%varid% =|(|{"
Line 1184
  tok always !0
  2 always 2
Line 1185
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1186
  tok always !0
  == always {!<=-1,!>=2}
Line 1187
  return always {!<=-1,!>=2}
  true always 1
Line 1188
  tok always !0
Line 1193
  return always {!<=-1,!>=2}
  false always 0
Line 1198
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1204
  "; __property ;" always "; __property ;"
Line 1210
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1211
  privateFuncs possible lifetime[Object]=(scope->functionList)
  & {lifetime[Address]=(scope->functionList),!0}
Line 1215
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1217
  = {lifetime[Iterator]=(privateFuncs),start=0}
  privateFuncs possible lifetime[Object]=(scope->functionList)
  ( {lifetime[Iterator]=(privateFuncs),start=0}
  it {lifetime[Iterator]=(privateFuncs),start=0}
  != always {!<=-1,!>=2}
  privateFuncs possible lifetime[Object]=(scope->functionList)
  ( {lifetime[Iterator]=(privateFuncs),end=0}
Line 1218
  * possible lifetime[Object]=(scope->functionList)
  it {lifetime[Iterator]=(privateFuncs),start=0}
  ( always {!<=-1,!>=2}
  true always 1
Line 1219
  privateFuncs possible lifetime[Object]=(scope->functionList)
  it possible lifetime[Iterator]=(privateFuncs)
Line 1221
  it possible lifetime[Iterator]=(privateFuncs)
Line 1225
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1227
  used always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  privateFuncs always !size=0
Line 1230
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
Line 1232
  used always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  privateFuncs always !size=0
  . always !0
Line 1234
  used always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1237
  ! {!<=-1,!>=2,0}
  used {!<=-1,!>=2,1}
Line 1238
  privateFuncs always !size=0
  privateFuncs always !size=0
Line 1240
  privateFuncs always !size=0
Line 1247
  tok possible 0@239
  :: always 3
  style always 3
  "unusedPrivateFunction" always "unusedPrivateFunction"
  "$symbol:" always "$symbol:"
  classname possible "classname"@239
  "::" always "::"
  funcname possible "funcname"@239
  "\nUnused private function: '$symbol'" always "\nUnused private function: '$symbol'"
  :: always 0
  normal always 0
Line 1257
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1258
  scope always !0
Line 1259
  scope always !0
Line 1261
  nullptr always 0
Line 1266
  printWarnings always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1268
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1269
  ( always {!<=-1,!>=2}
  "memset|memcpy|memmove (" always "memset|memcpy|memmove ("
Line 1270
  2 always 2
Line 1272
  arg3 always symbolic=(arg1->nextArgument())
Line 1273
  arg3 {symbolic=(arg1->nextArgument()),!0}
Line 1274
  ! always {!<=-1,!>=2}
  arg3 possible symbolic=(arg1->nextArgument())
Line 1279
  = always 0
  nullptr always 0
Line 1280
  = always 0
  nullptr always 0
Line 1281
  ( always {!<=-1,!>=2}
  arg3 always !0
  "sizeof ( %type% ) )" always "sizeof ( %type% ) )"
Line 1282
  arg3 always !0
  2 always 2
Line 1283
  ( always {!<=-1,!>=2}
  arg3 always !0
  "sizeof ( %type% :: %type% ) )" always "sizeof ( %type% :: %type% ) )"
Line 1284
  arg3 always !0
  4 always 4
Line 1285
  ( always {!<=-1,!>=2}
  arg3 always !0
  "sizeof ( struct %type% ) )" always "sizeof ( struct %type% ) )"
Line 1286
  arg3 always !0
  3 always 3
Line 1287
  ( always {!<=-1,!>=2}
  arg3 always !0
  "sizeof ( * this ) )" always "sizeof ( * this ) )"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this ," always "this ,"
Line 1288
  arg3 always !0
Line 1289
  ( always {!<=-1,!>=2}
  "&|*|%var%" always "&|*|%var%"
Line 1290
  = always 0
  0 always 0
Line 1292
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1294
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1301
  var always symbolic=(arg1->variable())
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "," always ","
Line 1302
  var {symbolic=(arg1->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1303
  var {symbolic=(arg1->variable()),!0}
Line 1304
  ( always {!<=-1,!>=2}
  endTok possible symbolic=(var->typeEndToken())
  "*" always "*"
Line 1310
  var {symbolic=(arg1->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1311
  var {symbolic=(arg1->variable()),!0}
  ( always !<=-1
Line 1313
  == always {!<=-1,!>=2}
  1 always 1
Line 1314
  var {symbolic=(arg1->variable()),!0}
Line 1319
  ! {!<=-1,!>=2,1}
  typeTok possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  type possible symbolic=(var->typeScope())
Line 1322
  && always {!<=-1,!>=2}
  typeTok always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 1323
  typeTok always !0
Line 1325
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1326
  ( always !0
Line 1328
  type possible symbolic=(typeTok->type()->classScope)
Line 1330
  type always !0
  false always 0
  parsedTypes always size=0
Line 1332
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% = calloc|malloc|realloc|g_malloc|g_try_malloc|g_realloc|g_try_realloc (" always "%var% = calloc|malloc|realloc|g_malloc|g_try_malloc|g_realloc|g_try_realloc ("
Line 1334
  2 always 2
  ( always !0
  ( always !0
  true always 1
  parsedTypes always size=0
Line 1336
  printWarnings always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 1337
  2 always 2
  ( always !0
  ( always !0
Line 1343
  , always {!<=-1,!>=2}
  allocation always {!<=-1,!>=2}
Line 1346
  parsedTypes possible size=0@135
  ( possible lifetime[Iterator]=(parsedTypes)
  != always {!<=-1,!>=2}
  parsedTypes possible size=0@135
  ( {lifetime[Iterator]=(parsedTypes),end=0}
Line 1348
  parsedTypes possible {lifetime[Object]=(type),size=0@135}
Line 1350
  printPortability always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 1355
  derivedFrom always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
Line 1356
  derivedFrom always !0
  allocation always {!<=-1,!>=2}
  parsedTypes {lifetime[Object]=(type),!size=0}
Line 1361
  ( always {!<=-1,!>=2}
Line 1362
  allocation {!<=-1,!>=2,1,0}
Line 1363
  "virtual function" always "virtual function"
Line 1365
  "virtual function" always "virtual function"
Line 1371
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1376
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "*" always "*"
Line 1381
  ( always {!<=-1,!>=2}
  tok1 always symbolic=(var.typeStartToken())
  "%type% ::" always "%type% ::"
Line 1383
  ( always {!<=-1,!>=2}
  typeTok possible symbolic=(tok1)
  "%type% ::" always "%type% ::"
Line 1384
  "::" always "::"
Line 1385
  2 always 2
Line 1387
  typeTok possible symbolic=(tok1)
Line 1391
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "std::array" always "std::array"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1392
  allocation always {!<=-1,!>=2}
Line 1393
  "'" always "'"
  "'" always "'"
Line 1395
  "'" always "'"
  "'" always "'"
Line 1399
  typeScope possible symbolic=(type)
  && always {!<=-1,!>=2}
  typeScope always !0
  != always {!<=-1,!>=2}
Line 1400
  typeScope always {!symbolic=(type),!0}
  allocation always {!<=-1,!>=2}
Line 1403
  printPortability always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "memset" always "memset"
Line 1411
  tok possible 0@243
  classTok inconclusive 0@243
Line 1412
  toks always {{,size=2}
  :: always 2
  warning always 2
  "mallocOnClassWarning" always "mallocOnClassWarning"
Line 1413
  "$symbol:" always "$symbol:"
  memfunc inconclusive "malloc"@243
  "\nMemory for class instance allocated with $symbol(), but class provides constructors.\nMemory for class instance allocated with $symbol(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead." always "\nMemory for class instance allocated with $symbol(), but class provides constructors.\nMemory for class instance allocated with $symbol(), but class provides constructors. This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead."
Line 1416
  :: always 0
  normal always 0
Line 1421
  tok possible 0@244
  classTok inconclusive 0@244
Line 1422
  toks always {{,size=2}
  "mallocOnClassError" always "mallocOnClassError"
Line 1423
  "$symbol:" always "$symbol:"
  memfunc inconclusive "malloc"@244
  "\n$symbol:" always "\n$symbol:"
Line 1424
  classname {"virtual function"@82,"std::string"@244}
  "\nMemory for class instance allocated with " always "\nMemory for class instance allocated with "
Line 1425
  memfunc inconclusive "malloc"@244
  "(), but class contains a " always "(), but class contains a "
  classname {"virtual function"@82,"std::string"@244}
  ".\nMemory for class instance allocated with " always ".\nMemory for class instance allocated with "
Line 1426
  memfunc inconclusive "malloc"@244
  "(), but class a " always "(), but class a "
  classname {"virtual function"@82,"std::string"@244}
  ". This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead." always ". This is unsafe, since no constructor is called and class members remain uninitialized. Consider using 'new' instead."
Line 1427
  :: always 0
  normal always 0
Line 1432
  tok possible 0@240
  "memsetClass" always "memsetClass"
Line 1433
  "$symbol:" always "$symbol:"
  memfunc inconclusive "memfunc"@240
  "\n$symbol:" always "\n$symbol:"
Line 1434
  classname {"virtual function"@84,"classname"@240}
  "\nUsing '" always "\nUsing '"
Line 1435
  memfunc inconclusive "memfunc"@240
  "' on " always "' on "
  type inconclusive "class"@240
  " that contains a " always " that contains a "
  classname {"virtual function"@84,"classname"@240}
  ".\nUsing '" always ".\nUsing '"
Line 1436
  memfunc inconclusive "memfunc"@240
  "' on " always "' on "
  type inconclusive "class"@240
  " that contains a " always " that contains a "
  classname {"virtual function"@84,"classname"@240}
  " is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created." always " is unsafe, because constructor, destructor and copy operator calls are omitted. These are necessary for this non-POD type to ensure that a valid object is created."
Line 1438
  :: always 0
  normal always 0
Line 1443
  tok possible 0@241
  "memsetClassReference" always "memsetClassReference"
Line 1444
  "$symbol:" always "$symbol:"
  memfunc inconclusive "memfunc"@241
  "\nUsing '" always "\nUsing '"
Line 1445
  memfunc inconclusive "memfunc"@241
  "' on " always "' on "
  type inconclusive "class"@241
  " that contains a reference." always " that contains a reference."
  :: always 0
  normal always 0
Line 1450
  tok possible 0@242
  :: always 5
  portability always 5
  "memsetClassFloat" always "memsetClassFloat"
  "Using memset() on " always "Using memset() on "
  type possible "class"@242
  " which contains a floating point number.\nUsing memset() on " always " which contains a floating point number.\nUsing memset() on "
Line 1451
  type possible "class"@242
  " which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0." always " which contains a floating point number. This is not portable because memset() sets each byte of a block of memory to a specific value and the actual representation of a floating-point value is implementation defined. Note: In case of an IEEE754-1985 compatible implementation setting all bits to zero results in the value 0.0."
Line 1454
  :: always 0
  normal always 0
Line 1465
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1469
  = {lifetime[Iterator]=(scope->functionList),start=0}
  ( {lifetime[Iterator]=(scope->functionList),start=0}
  func possible {lifetime[Iterator]=(scope->functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->functionList),end=0}
  func possible lifetime[Iterator]=(scope->functionList)
Line 1470
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  && always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 1472
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  == always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  && always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  -1 always -1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1473
  & {lifetime[Object]=(scope->functionList),!0}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
Line 1483
  func possible lifetime[Object]=(scope->functionList)@77
  analyzedFunctions always size=0
Line 1488
  foundReturn always {!<=-1,!>=2}
  foundReturn always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1492
  tok possible symbolic=(startTok)
  && always {!<=-1,!>=2}
  tok {symbolic=(startTok),!0}
  != always {!<=-1,!>=2}
Line 1494
  != always {!<=-1,!>=2}
  "return" always "return"
Line 1497
  foundReturn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1500
  retExpr always symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  retExpr {symbolic=(tok->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "=" always "="
Line 1501
  retExpr {symbolic=(tok->astOperand1()),!0}
Line 1502
  retExpr possible symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  retExpr always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  retExpr always !0
  "this" always "this"
Line 1505
  "( " always "( "
  " & )" always " & )"
Line 1506
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(cast),!0}
  ( always !<=-1
Line 1507
  4 always 4
Line 1510
  2 always 2
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 1511
  2 always 2
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1513
  = {lifetime[Iterator]=(scope->functionList),start=0}
  ( {lifetime[Iterator]=(scope->functionList),start=0}
  it possible {lifetime[Iterator]=(scope->functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->functionList),end=0}
Line 1515
  it possible lifetime[Iterator]=(scope->functionList)
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(scope->functionList)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1516
  it possible lifetime[Iterator]=(scope->functionList)
  == always {!<=-1,!>=2}
Line 1518
  it possible lifetime[Iterator]=(scope->functionList)
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 1519
  it possible lifetime[Iterator]=(scope->functionList)
  -2 always -2
  == always {!<=-1,!>=2}
Line 1521
  ! always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(scope->functionList)
  ( always {!<=-1,!>=2}
Line 1524
  ( possible lifetime[Iterator]=(analyzedFunctions)
  & {lifetime[Object]=(scope->functionList),!0}
  it possible lifetime[Iterator]=(scope->functionList)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(analyzedFunctions),end=0}
Line 1525
  analyzedFunctions possible lifetime[Object]=(*it)
  & {lifetime[Address]=(*it),!0}
Line 1526
  & {lifetime[Address]=(*it),!0}
Line 1539
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "operator= (" always "operator= ("
  || always {!<=-1,!>=2}
Line 1540
  ( always {!<=-1,!>=2}
  "this . operator= (" always "this . operator= ("
  || always {!<=-1,!>=2}
Line 1541
  ( always {!<=-1,!>=2}
  "%type% :: operator= (" always "%type% :: operator= ("
  && always {!<=-1,!>=2}
Line 1542
  == always {!<=-1,!>=2}
Line 1545
  foundReturn {!<=-1,!>=2,0}
Line 1548
  startTok possible symbolic=(tok)
  == always {!<=-1,!>=2}
Line 1549
  "( const " always "( const "
  " &" always " &"
Line 1550
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(tmp),!0}
  ( always !<=-1
Line 1552
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 1554
  true always 1
Line 1558
  ( always {!<=-1,!>=2}
  last always !symbolic=(startTok->next())
  nullptr always 0
Line 1565
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 1570
  tok possible 0@247
  :: always 3
  style always 3
  "operatorEqRetRefThis" always "operatorEqRetRefThis"
  "'operator=' should return reference to 'this' instance." always "'operator=' should return reference to 'this' instance."
  :: always 0
  normal always 0
Line 1575
  tok possible 0@249
  :: always 3
  style always 3
  "operatorEqShouldBeLeftUnimplemented" always "operatorEqShouldBeLeftUnimplemented"
  "'operator=' should either return reference to 'this' instance or be declared private and left unimplemented." always "'operator=' should either return reference to 'this' instance or be declared private and left unimplemented."
  :: always 0
  normal always 0
Line 1578
  , always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 1580
  error {!<=-1,!>=2,0@70,1@70}
Line 1581
  tok possible 0@248
  "operatorEqMissingReturnStatement" always "operatorEqMissingReturnStatement"
  "No 'return' statement in non-void function causes undefined behavior." always "No 'return' statement in non-void function causes undefined behavior."
  :: always 0
  normal always 0
Line 1603
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1608
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
Line 1612
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1614
  ( always {!<=-1,!>=2}
Line 1616
  . always !size=0
Line 1617
  typeTok possible symbolic=(func.argumentList.front().typeEndToken())
  ( possible symbolic=(scope->className)
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
  typeTok possible symbolic=(func.argumentList.front().typeEndToken())
  == always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
  typeTok possible symbolic=(func.argumentList.front().typeEndToken())
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1619
  typeTok possible symbolic=(func.argumentList.front().typeEndToken())
  != always {!<=-1,!>=2}
Line 1623
  ( always {!<=-1,!>=2}
  "%type% &" always "%type% &"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {symbolic=(scope->className),symbolic=(typeTok->str())}
Line 1625
  ( {lifetime[Iterator]=(func.argumentList),lifetime[Object]=(argumentList),start=0}
Line 1626
  = always 0
  nullptr always 0
Line 1627
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(scope->functionList),!0}
  & {lifetime[Address]=(out_ifStatementScopeStart),!0}
  out_ifStatementScopeStart always 0
Line 1628
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(scope->functionList),!0}
Line 1630
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1631
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(scope->functionList),!0}
  out_ifStatementScopeStart always !0
Line 1640
  ( always {!<=-1,!>=2}
Line 1643
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1646
  func possible lifetime[Address]=(scope->functionList)@32
Line 1647
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  func possible lifetime[Address]=(scope->functionList)@32
  end possible {symbolic=(ifStatementScopeStart->link()),symbolic=(func->functionScope->bodyEnd)}
Line 1650
  ( always {!<=-1,!>=2}
Line 1652
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  func possible lifetime[Address]=(scope->functionList)@30
  func possible lifetime[Address]=(scope->functionList)@30
  func possible lifetime[Address]=(scope->functionList)@30
Line 1655
  ( always {!<=-1,!>=2}
Line 1657
  ! always {!<=-1,!>=2}
  end possible {symbolic=(ifStatementScopeStart->link())@19,symbolic=(func->functionScope->bodyEnd)@19}
Line 1658
  func possible lifetime[Address]=(scope->functionList)@7696
Line 1659
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1660
  ( always {!<=-1,!>=2}
  "%var% = malloc|realloc|calloc|new" always "%var% = malloc|realloc|calloc|new"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1661
  return always {!<=-1,!>=2}
  true always 1
Line 1665
  ( always {!<=-1,!>=2}
  "free ( %var%" always "free ( %var%"
Line 1666
  2 always 2
Line 1667
  ( always {!<=-1,!>=2}
  "delete [ ] %var%" always "delete [ ] %var%"
Line 1668
  3 always 3
Line 1669
  ( always {!<=-1,!>=2}
  "delete %var%" always "delete %var%"
Line 1674
  ( always {!<=-1,!>=2}
  var possible symbolic=(tok->next())
Line 1675
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
Line 1676
  ( always {!<=-1,!>=2}
  "%varid% =" always "%varid% ="
Line 1677
  return always {!<=-1,!>=2}
  true always 1
Line 1682
  return always {!<=-1,!>=2}
  false always 0
Line 1685
  ( always {!<=-1,!>=2}
Line 1687
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 1690
  ( always {!<=-1,!>=2}
Line 1692
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1701
  res always {!<=-1,!>=2}
  res always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1702
  && always {!<=-1,!>=2}
  itr always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 1703
  ( always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1704
  res always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  res always {!<=-1,!>=2}
Line 1705
  ( always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(rhs->str()),!0}
  ( always !<=-1
Line 1706
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(rhs->str()),!0}
  ( always !<=-1
Line 1707
  res always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  res always {!<=-1,!>=2}
Line 1708
  ( always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1710
  ( always {!<=-1,!>=2}
  "!" always "!"
Line 1711
  res always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  res always {!<=-1,!>=2}
Line 1712
  ( always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1713
  res always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  res always {!<=-1,!>=2}
Line 1714
  ( always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1716
  ( always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(rhs->str()),!0}
  ( always !<=-1
Line 1717
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "this" always "this"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(rhs->str()),!0}
  ( always !<=-1
Line 1723
  res always {!<=-1,!>=2}
Line 1731
  ( always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
  ") {" always ") {"
Line 1734
  nullptr always 0
Line 1741
  nullptr always 0
Line 1744
  ( always {!<=-1,!>=2}
Line 1746
  ! always {!<=-1,!>=2}
Line 1747
  return always {!<=-1,!>=2}
  false always 0
Line 1748
  func possible lifetime[Address]=(scope->functionList)@29
Line 1749
  func possible lifetime[Address]=(scope->functionList)@29
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  last always symbolic=(func->functionScope->bodyEnd)
Line 1750
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 1753
  ret {!<=-1,!>=2,0}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1755
  [ possible {lifetime[Lambda]=(rhs),lifetime[Lambda]=(ret)}
Line 1756
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 1757
  :: always 3
  op1_and_op2 always 3
Line 1758
  ( always {!<=-1,!>=2}
  "this" always "this"
Line 1760
  ( always {!<=-1,!>=2}
  "this" always "this"
Line 1763
  :: always 3
  op1_and_op2 always 3
Line 1764
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
Line 1765
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1766
  ret {!<=-1,!>=2,1,0}
Line 1769
  ret {!<=-1,!>=2,1,0}
  ? possible {4,3}
  :: always 4
  done always 4
  : always 3
  :: always 3
  op1_and_op2 always 3
Line 1771
  ret always {!<=-1,!>=2}
Line 1772
  return always {!<=-1,!>=2}
  ret always 1
Line 1775
  return always {!<=-1,!>=2}
  false always 0
Line 1780
  tok possible 0@250
  :: always 2
  warning always 2
  "operatorEqToSelf" always "operatorEqToSelf"
Line 1781
  "'operator=' should check for assignment to self to avoid problems with dynamic memory.\n'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class." always "'operator=' should check for assignment to self to avoid problems with dynamic memory.\n'operator=' should check for assignment to self to ensure that each block of dynamically allocated memory is owned and managed by only one instance of the class."
Line 1783
  :: always 0
  normal always 0
Line 1798
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1805
  ( always {!<=-1,!>=2}
Line 1806
  printInconclusive always {!<=-1,!>=2}
Line 1808
  destructor {symbolic=(scope->getDestructor()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  destructor {symbolic=(scope->getDestructor()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  destructor {symbolic=(scope->getDestructor()),!0}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 1810
  ( always {!<=-1,!>=2}
Line 1821
  <= always {!<=-1,!>=2}
  :: always 0
  CPP03 always 0
Line 1826
  ! {!<=-1,!>=2,1}
  destructor {symbolic=(scope->getDestructor()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  destructor {symbolic=(scope->getDestructor()),!0}
  ( always {!<=-1,!>=2}
Line 1830
  destructor {symbolic=(scope->getDestructor()),!0}
  3 always 3
  == always {!<=-1,!>=2}
  destructor {symbolic=(scope->getDestructor()),!0}
  4 always 4
Line 1835
  derived always symbolic=(scope->classDef)
Line 1838
  . always !size=0
Line 1840
  != always {!<=-1,!>=2}
  :: always 2
  Private always 2
  && always {!<=-1,!>=2}
Line 1841
  = always !0
  . always !0
Line 1842
  derivedFrom {symbolic=(j.type),!0}
Line 1843
  ! always {!<=-1,!>=2}
  derivedFromScope always symbolic=(derivedFrom->classScope)
Line 1856
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  derivedFrom {symbolic=(j.type),!0}
Line 1857
  var always !0
Line 1864
  ok always {!<=-1,!>=2}
  ok always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1867
  ( always {!<=-1,!>=2}
  "[;{}] %var% =" always "[;{}] %var% ="
  && always {!<=-1,!>=2}
Line 1868
  ( possible lifetime[Iterator]=(baseClassPointers)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(baseClassPointers),end=0}
Line 1870
  "new " always "new "
Line 1871
  ( always {!<=-1,!>=2}
  3 always 3
  ( {lifetime[Object]=(tmp),!0}
  ( always !<=-1
Line 1877
  ( always {!<=-1,!>=2}
  "delete %var% ;" always "delete %var% ;"
  && always {!<=-1,!>=2}
Line 1878
  ( possible lifetime[Iterator]=(dontDelete)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(dontDelete),end=0}
Line 1879
  ok always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1885
  ok {!<=-1,!>=2,1,0}
Line 1893
  ! always {!<=-1,!>=2}
  baseDestructor always symbolic=(derivedFromScope->getDestructor())
Line 1894
  ( always {!<=-1,!>=2}
Line 1895
  false always 0
Line 1897
  ! always {!<=-1,!>=2}
  baseDestructor {symbolic=(derivedFromScope->getDestructor()),!0}
  ( always {!<=-1,!>=2}
Line 1904
  ( always {!<=-1,!>=2}
Line 1908
  baseDestructor {symbolic=(derivedFromScope->getDestructor()),!0}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 1909
  baseDestructor {symbolic=(derivedFromScope->getDestructor()),!0}
  false always 0
Line 1911
  :: possible {symbolic=(inconclusiveErrors.end()),end=0}
  found possible {symbolic=(inconclusiveErrors.end()),end=0}
  ( {lifetime[Iterator]=(inconclusiveErrors),start=0}
  ( {lifetime[Iterator]=(inconclusiveErrors),end=0}
  baseDestructor {symbolic=(derivedFromScope->getDestructor()),!0}
Line 1912
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(inconclusiveErrors),end=0}
Line 1913
  found always !end=0
Line 1922
  true always 1
Line 1925
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1927
  inconclusive {!<=-1,!>=2,0@172,1@177}
Line 1928
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1929
  :: always 2
  warning always 2
  "virtualDestructor" always "virtualDestructor"
  "$symbol:" always "$symbol:"
  "\nClass '$symbol' which has virtual members does not have a virtual destructor." always "\nClass '$symbol' which has virtual members does not have a virtual destructor."
Line 1931
  tok possible 0@245
  "virtualDestructor" always "virtualDestructor"
Line 1932
  "$symbol:" always "$symbol:"
  Base inconclusive "Base"@245
  "\n$symbol:" always "\n$symbol:"
Line 1933
  Derived inconclusive "Derived"@245
  "\nClass '" always "\nClass '"
Line 1934
  Base inconclusive "Base"@245
  "' which is inherited by class '" always "' which is inherited by class '"
  Derived inconclusive "Derived"@245
  "' does not have a virtual destructor.\nClass '" always "' does not have a virtual destructor.\nClass '"
Line 1935
  Base inconclusive "Base"@245
  "' which is inherited by class '" always "' which is inherited by class '"
  Derived inconclusive "Derived"@245
  "' does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class." always "' does not have a virtual destructor. If you destroy instances of the derived class by deleting a pointer that points to the base class, only the destructor of the base class is executed. Thus, dynamic memory that is managed by the derived class could leak. This can be avoided by adding a virtual destructor to the base class."
Line 1938
  :: always 0
  normal always 0
Line 1948
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1953
  tok possible symbolic=(mTokenizer->tokens())
  "this - %name%" always "this - %name%"
Line 1954
  ! always {!<=-1,!>=2}
Line 1957
  tok always !0
  -1 always -1
  != always {!<=-1,!>=2}
  "*" always "*"
Line 1958
  tok always !0
Line 1960
  tok always !0
Line 1966
  tok possible 0@246
  :: always 2
  warning always 2
  "thisSubtraction" always "thisSubtraction"
  "Suspicious pointer subtraction. Did you intend to write '->'?" always "Suspicious pointer subtraction. Did you intend to write '->'?"
  :: always 0
  normal always 0
Line 1976
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1979
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1985
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1988
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1992
  = possible lifetime[Lambda]=(this)
  [ possible lifetime[Lambda]=(this)
  this always !0
  ( always {!<=-1,!>=2}
  { always {!<=-1,!>=2}
Line 1993
  inTemplArgList always {!<=-1,!>=2}
  inTemplArgList always {!<=-1,!>=2}
  = always 0
  false always 0
  isConstTemplArg always {!<=-1,!>=2}
  isConstTemplArg always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1994
  != always {!<=-1,!>=2}
Line 1995
  ( possible {size=1,size=5}
  == {!<=-1,!>=2,0}
  "{" always "{"
Line 1996
  false always 0
Line 1997
  ( possible {size=1,size=5}
  == {!<=-1,!>=2,0}
  "<" always "<"
Line 1998
  ! always {!<=-1,!>=2}
Line 1999
  "debug" always "debug"
  "CheckClass::checkConst found unlinked template argument list '" always "CheckClass::checkConst found unlinked template argument list '"
  "'." always "'."
Line 2000
  inTemplArgList always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2002
  ( possible size=5
  == {!<=-1,!>=2,0}
  ">" always ">"
Line 2003
  inTemplArgList always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2004
  isConstTemplArg always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2006
  == always {!<=-1,!>=2}
  "const" always "const"
Line 2007
  ! always {!<=-1,!>=2}
  inTemplArgList always {!<=-1,!>=2}
Line 2008
  false always 0
Line 2009
  isConstTemplArg always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2011
  ! always {!<=-1,!>=2}
  isConstTemplArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*|&" always "*|&"
Line 2012
  true always 1
Line 2014
  false always 0
Line 2017
  returnsPtrOrRef always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  isPointerOrReference possible lifetime[Lambda]=(this)
  ( always {!<=-1,!>=2}
Line 2019
  ( always {!<=-1,!>=2}
Line 2021
  opName always {symbolic=(func.tokenDef->str()),symbolic=(opName)}
  8 always 8
  5 always 5
  "const" always "const"
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  opName always {symbolic=(func.tokenDef->str()),symbolic=(opName)}
  '&' always 38
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '*' always 42
Line 2023
  ( always {!<=-1,!>=2}
Line 2029
  ( always !<=-1
  > always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2034
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 2037
  memberAccessed always {!<=-1,!>=2}
  memberAccessed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2039
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(scope->functionList),!0}
  memberAccessed always 0
Line 2042
  suggestStatic always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  memberAccessed always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2043
  returnsPtrOrRef always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  suggestStatic {symbolic=(!memberAccessed&&!func.isOperator()),!<=-1,!>=2}
Line 2048
  nest possible symbolic=(scope->nestedIn)
  && always {!<=-1,!>=2}
  nest {symbolic=(scope->nestedIn),!0}
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 2049
  nest always !0
  "::" always "::"
Line 2050
  nest always !0
Line 2054
  ( always {!<=-1,!>=2}
  "" always ""
  : always "operator"
  "operator" always "operator"
  ( possible size=1
Line 2056
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 2057
  ")" always ")"
Line 2058
  == always {!<=-1,!>=2}
  "[" always "["
Line 2059
  "]" always "]"
Line 2061
  ( always {!<=-1,!>=2}
Line 2062
  suggestStatic always {!<=-1,!>=2}
Line 2064
  suggestStatic always {!<=-1,!>=2}
Line 2069
  ( always {!<=-1,!>=2}
Line 2071
  again always {!<=-1,!>=2}
  again always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2075
  again always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2077
  tok possible symbolic=(tok->next())@12
  ( possible size=1
  == {!<=-1,!>=2,0}
  "this" always "this"
Line 2078
  return always {!<=-1,!>=2}
  true always 1
Line 2079
  ( always {!<=-1,!>=2}
  -3 always -3
  "( * this )" always "( * this )"
Line 2080
  return always {!<=-1,!>=2}
  true always 1
Line 2081
  ( always {!<=-1,!>=2}
  -3 always -3
  "%name% ) . %name%" always "%name% ) . %name%"
Line 2082
  -3 always -3
Line 2083
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2084
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% . %name%" always "%name% . %name%"
Line 2085
  -2 always -2
Line 2086
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2087
  ( always {!<=-1,!>=2}
  -2 always -2
  "] . %name%" always "] . %name%"
Line 2088
  -2 always -2
Line 2089
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2090
  == always {!<=-1,!>=2}
  "]" always "]"
Line 2092
  again always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2094
  again always {!<=-1,!>=2}
Line 2097
  == always {!<=-1,!>=2}
Line 2098
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 2101
  ( always {!<=-1,!>=2}
  fqTok possible symbolic=(tok)
  -2 always -2
  "%name% ::" always "%name% ::"
Line 2102
  -2 always -2
Line 2103
  fqTok possible symbolic=(tok)
  -1 always -1
  == always {!<=-1,!>=2}
  "::" always "::"
Line 2105
  isMember always {!<=-1,!>=2}
  isMember always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2108
  ! {!<=-1,!>=2,1}
  isMember {symbolic=(tok==fqTok),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  curScope possible symbolic=(scope)
  && always {!<=-1,!>=2}
  curScope {symbolic=(scope),!0}
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 2109
  ( possible lifetime[Iterator]=(scopeStr)
  0 always 0
  curScope always !0
  " :: " always " :: "
Line 2110
  isMember always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Object]=(scopeStr),!0}
Line 2112
  curScope always !0
Line 2114
  isMember {symbolic=(tok==fqTok),!<=-1,!>=2}
Line 2115
  == always {!<=-1,!>=2}
  0 always 0
Line 2116
  "varid0" always "varid0"
  "CheckClass::isMemberVar found used member variable \'" always "CheckClass::isMemberVar found used member variable \'"
  "\' with varid 0" always "\' with varid 0"
Line 2118
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2124
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2126
  . always !size=0
Line 2131
  derivedFrom always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  . always !0
  != always {!<=-1,!>=2}
Line 2132
  ( always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  . always {!symbolic=(scope),!0}
Line 2133
  return always {!<=-1,!>=2}
  true always 1
Line 2138
  return always {!<=-1,!>=2}
  false always 0
Line 2141
  ( always {!<=-1,!>=2}
Line 2143
  ! always {!<=-1,!>=2}
Line 2145
  == always {!<=-1,!>=2}
Line 2146
  2 always 2
Line 2147
  == always {!<=-1,!>=2}
  ")" always ")"
  0 always 0
  : always 1
  1 always 1
Line 2155
  argsPassed possible {>=symbolic=(func.argCount()-1),<=symbolic=(func.argCount()-1-1),>=symbolic=(func.minArgCount()),<=symbolic=(func.minArgCount()-1)}
  == always {!<=-1,!>=2}
  ( always !<=-1
  || always {!<=-1,!>=2}
Line 2156
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argsPassed always !symbolic=(func.argCount())
  >= always {!<=-1,!>=2}
  ( always {!symbolic=(argsPassed),!<=-1}
  - always !<=-2
  1 always 1
  || always {!<=-1,!>=2}
Line 2157
  argsPassed always !symbolic=(func.argCount())
  < always {!<=-1,!>=2}
  ( always {!symbolic=(argsPassed),!<=-1}
  && always {!<=-1,!>=2}
  argsPassed {!symbolic=(func.argCount()),<=symbolic=(func.argCount()-1)}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 2158
  return always {!<=-1,!>=2}
  true always 1
Line 2161
  ( always !0
  == always {!<=-1,!>=2}
Line 2162
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2165
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2167
  . always !size=0
Line 2172
  derivedFrom always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  . always !0
  != always {!<=-1,!>=2}
Line 2173
  ( always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  . always {!symbolic=(scope),!0}
Line 2174
  return always {!<=-1,!>=2}
  true always 1
Line 2179
  return always {!<=-1,!>=2}
  false always 0
Line 2182
  ( always {!<=-1,!>=2}
Line 2184
  ! always {!<=-1,!>=2}
Line 2185
  return always {!<=-1,!>=2}
  false always 0
Line 2186
  ( always !0
  == always {!<=-1,!>=2}
Line 2187
  return always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2190
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 2192
  . always !size=0
Line 2197
  derivedFrom always symbolic=(i.type)
  && always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
Line 2198
  ( always {!<=-1,!>=2}
  derivedFrom {symbolic=(i.type),!0}
  . always !0
Line 2199
  return always {!<=-1,!>=2}
  true always 1
Line 2204
  return always {!<=-1,!>=2}
  false always 0
Line 2207
  "map" always "map"
  "unordered_map" always "unordered_map"
Line 2209
  ( always {!<=-1,!>=2}
  memberAccessed always {!<=-1,!>=2}
Line 2211
  ( always {!<=-1,!>=2}
  func possible lifetime[Address]=(scope->functionList)@138
  func possible lifetime[Address]=(scope->functionList)@138
Line 2212
  return always {!<=-1,!>=2}
  false always 0
Line 2216
  func possible lifetime[Address]=(scope->functionList)@138
  && always {!<=-1,!>=2}
  tok1 always !0
  != always {!<=-1,!>=2}
  tok1 possible symbolic=(jumpBackToken?jumpBackToken:end)
Line 2217
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2218
  memberAccessed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2220
  v always symbolic=(tok1->variable())
  && always {!<=-1,!>=2}
  v {symbolic=(tok1->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2223
  == always {!<=-1,!>=2}
  "this" always "this"
Line 2224
  ( always {!<=-1,!>=2}
Line 2225
  return always {!<=-1,!>=2}
  false always 0
Line 2226
  ( always {!<=-1,!>=2}
  "( this . * %var% )" always "( this . * %var% )"
Line 2227
  return always {!<=-1,!>=2}
  false always 0
Line 2231
  && always {!<=-1,!>=2}
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "( const" always "( const"
Line 2232
  return always {!<=-1,!>=2}
  false always 0
Line 2235
  lhs always symbolic=(tok1->previous())
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 2236
  = always !0
  ( always !0
  ( always !0
Line 2237
  lhs possible {symbolic=(tok1->previous()),symbolic=(tok1->astParent()->astParent())}
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 2239
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2240
  ( always !0
  -1 always -1
  != always {!<=-1,!>=2}
  "const" always "const"
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2241
  return always {!<=-1,!>=2}
  false always 0
Line 2243
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 2245
  ( always !0
  1 always 1
  != always {!<=-1,!>=2}
  "const" always "const"
Line 2246
  return always {!<=-1,!>=2}
  false always 0
Line 2248
  ( always {!<=-1,!>=2}
Line 2250
  lhsVar {symbolic=(lhs->previous()->variable()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhsVar {symbolic=(lhs->previous()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lhsVar {symbolic=(lhs->previous()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  lhsVar always symbolic=(lhs->previous()->variable())
Line 2251
  return always {!<=-1,!>=2}
  false always 0
Line 2255
  = always 0
  nullptr always 0
Line 2257
  = always symbolic=(lastVarTok)
  tok1 always symbolic=(lastVarTok)
Line 2259
  ( always {!<=-1,!>=2}
  end possible {symbolic=(tok1),symbolic=(lastVarTok)}
  ". %name%" always ". %name%"
Line 2260
  2 always 2
Line 2263
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 2266
  var {symbolic=(end->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(end->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2267
  return always {!<=-1,!>=2}
  false always 0
Line 2269
  var {symbolic=(end->variable()),0}
  && always {!<=-1,!>=2}
  assignTok always symbolic=(end->next()->astParent())
  && always {!<=-1,!>=2}
  assignTok {symbolic=(end->next()->astParent()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  assignTok {symbolic=(end->next()->astParent()),!0}
  && always {!<=-1,!>=2}
  assignTok always symbolic=(end->next()->astParent())
  ( always !0
Line 2270
  = always !0
  assignTok {symbolic=(end->next()->astParent()),!0}
  ( always !0
  ( always !0
Line 2271
  assignVar {symbolic=(assignTok->astOperand1()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  assignVar {symbolic=(assignTok->astOperand1()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(end->variable()),!0}
Line 2272
  var {symbolic=(end->variable()),!0}
  ( always !0
Line 2274
  ( always {!<=-1,!>=2}
  funcMap always symbolic=(var->typeScope()->functionMap)
  ( {lifetime[Iterator]=(var->typeScope()->functionMap),start=0}
  funcMap always symbolic=(var->typeScope()->functionMap)
  ( {lifetime[Iterator]=(var->typeScope()->functionMap),end=0}
Line 2275
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "operator[]" always "operator[]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2277
  return always {!<=-1,!>=2}
  false always 0
Line 2281
  ! always {!<=-1,!>=2}
Line 2283
  1 always 1
Line 2284
  1 always 1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2290
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 2292
  ! always {!<=-1,!>=2}
  var always symbolic=(lastVarTok->variable())
Line 2293
  return always {!<=-1,!>=2}
  false always 0
Line 2294
  var {symbolic=(lastVarTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2295
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size|empty|cend|crend|cbegin|crbegin|max_size|length|count|capacity|get_allocator|c_str|str ( )" always "size|empty|cend|crend|cbegin|crbegin|max_size|length|count|capacity|get_allocator|c_str|str ( )"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "rfind|copy" always "rfind|copy"
  || always {!<=-1,!>=2}
Line 2297
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 2298
  ( always !0
  . always !0
  == always {!<=-1,!>=2}
  :: always 4
  START_ITERATOR always 4
  || always {!<=-1,!>=2}
Line 2299
  ( always !0
  . always !0
  ( always !4
  == always {!<=-1,!>=2}
  :: always 5
  END_ITERATOR always 5
Line 2300
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2301
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "const_iterator|const_reverse_iterator" always "const_iterator|const_reverse_iterator"
Line 2303
  ! always {!<=-1,!>=2}
  var {symbolic=(lastVarTok->variable()),!0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var {symbolic=(lastVarTok->variable()),!0}
  ( always !0
Line 2304
  return always {!<=-1,!>=2}
  false always 0
Line 2308
  ( always {!<=-1,!>=2}
Line 2309
  return always {!<=-1,!>=2}
  false always 0
Line 2312
  1 always 1
  == always {!<=-1,!>=2}
  "<<" always "<<"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "<<" always "<<"
Line 2313
  return always {!<=-1,!>=2}
  false always 0
Line 2314
  ( always {!<=-1,!>=2}
  true always 1
Line 2315
  return always {!<=-1,!>=2}
  false always 0
Line 2318
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 2319
  return always {!<=-1,!>=2}
  false always 0
Line 2323
  tok1 possible symbolic=(start)
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2324
  -1 always -1
Line 2326
  start possible symbolic=(tok1)
  -1 always -1
  == always {!<=-1,!>=2}
  "delete" always "delete"
Line 2327
  return always {!<=-1,!>=2}
  false always 0
Line 2329
  = possible 1
  ? possible 1
  jumpBackToken always !0
  : always 1
Line 2330
  tok1 {symbolic=(jumpBackToken?jumpBackToken:end),1}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always symbolic=(tok1)
  ". %name% ( !!)" always ". %name% ( !!)"
Line 2331
  tok1 always {symbolic=(jumpBackToken?jumpBackToken:end),symbolic=(end)}
Line 2335
  ( always {!<=-1,!>=2}
  ") <<" always ") <<"
  && always {!<=-1,!>=2}
Line 2336
  ( always {!<=-1,!>=2}
  -2 always -2
Line 2337
  -2 always -2
Line 2338
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 2339
  return always {!<=-1,!>=2}
  false always 0
Line 2343
  ( always {!<=-1,!>=2}
  ">> * this" always ">> * this"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 2344
  return always {!<=-1,!>=2}
  false always 0
Line 2348
  ( always {!<=-1,!>=2}
  "%name% (|{" always "%name% (|{"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return {" always "return {"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2349
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|if|string|switch|while|catch|for" always "return|if|string|switch|while|catch|for"
Line 2350
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "." always "."
Line 2351
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2352
  return always {!<=-1,!>=2}
  false always 0
Line 2353
  memberAccessed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2357
  ( always {!<=-1,!>=2}
  lpar always symbolic=(tok1->next())
  "( ) (" always "( ) ("
Line 2358
  lpar always symbolic=(tok1->next())
  2 always 2
Line 2359
  lpar possible symbolic=(tok1->next())
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
Line 2360
  == always {!<=-1,!>=2}
  "(" always "("
Line 2362
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 2364
  ! always {!<=-1,!>=2}
  var always symbolic=(tok2->variable())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok2->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2365
  return always {!<=-1,!>=2}
  false always 0
Line 2368
  ( always {!<=-1,!>=2}
  "> (" always "> ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "static_cast|const_cast|dynamic_cast|reinterpret_cast" always "static_cast|const_cast|dynamic_cast|reinterpret_cast"
Line 2369
  return always {!<=-1,!>=2}
  false always 0
Line 2373
  return always {!<=-1,!>=2}
  true always 1
Line 2376
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 2378
  tok possible 0@251
  nullptr always 0
  classname possible {"class"@251,"class"@252}
  funcname possible {"function"@251,"function"@252}
  suggestStatic {!<=-1,!>=2,0@251,1@252}
Line 2381
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 2384
  toks {lifetime[Object]=(tok1),size=0}
Line 2385
  tok2 possible 0@221
Line 2386
  toks {lifetime[Object]=(tok1),lifetime[Object]=(tok2),size=1}
  tok2 always !0
Line 2387
  ! always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 2388
  toks possible {lifetime[Object]=(tok1),lifetime[Object]=(tok2)}
  :: always 3
  style always 3
  "functionConst" always "functionConst"
Line 2389
  "$symbol:" always "$symbol:"
  "::" always "::"
  "\nTechnically the member function '$symbol' can be const.\nThe member function '$symbol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?" always "\nTechnically the member function '$symbol' can be const.\nThe member function '$symbol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state?"
Line 2397
  toks possible {lifetime[Object]=(tok1),lifetime[Object]=(tok2)}
  :: always 4
  performance always 4
  "functionStatic" always "functionStatic"
Line 2398
  "$symbol:" always "$symbol:"
  "::" always "::"
  "\nTechnically the member function '$symbol' can be static (but you may consider moving to unnamed namespace).\nThe member function '$symbol' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace." always "\nTechnically the member function '$symbol' can be static (but you may consider moving to unnamed namespace).\nThe member function '$symbol' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace."
Line 2415
  ( inconclusive lifetime[SubObject]=(_var)
Line 2424
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2431
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2437
  = {lifetime[Iterator]=(scope->functionList),start=0}
  ( {lifetime[Iterator]=(scope->functionList),start=0}
  func possible {lifetime[Iterator]=(scope->functionList),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->functionList),end=0}
  func possible lifetime[Iterator]=(scope->functionList)
Line 2438
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 2440
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
Line 2442
  tok always symbolic=(func->arg->link()->next())
  == always {!<=-1,!>=2}
  ":" always ":"
Line 2444
  tok always symbolic=(func->arg->link()->next())
Line 2447
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  func {lifetime[Iterator]=(scope->functionList),!symbolic=(scope->functionList.end()),!end=0}
Line 2448
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(func->functionScope->bodyStart),!0}
  "%name% (|{" always "%name% (|{"
Line 2449
  tok always {!symbolic=(func->functionScope->bodyStart),!0}
Line 2450
  var always symbolic=(scope->getVariable(tok->str()))
Line 2451
  var {symbolic=(scope->getVariable(tok->str())),!0}
  tok always {!symbolic=(func->functionScope->bodyStart),!0}
Line 2453
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% =" always "%name% ="
Line 2454
  2 always 2
Line 2457
  var always !0
  2 always 2
Line 2461
  tok always {!symbolic=(func->functionScope->bodyStart),!0}
Line 2465
  = always 1
  1 always 1
  j possible 1
  < {!<=-1,!>=2,0}
  vars possible size=0
  ( {!<=-1,0}
Line 2467
  j possible 1
  < always {!<=-1,!>=2}
  j possible 1
  - possible 0
  1 always 1
Line 2478
  tok1 possible 0@253
  tok2 inconclusive 0@253
Line 2479
  toks always {{,size=2}
  :: always 3
  style always 3
  "initializerList" always "initializerList"
Line 2480
  "$symbol:" always "$symbol:"
  classname inconclusive "class"@253
  "::" always "::"
  varname inconclusive "variable"@253
  "\nMember variable '$symbol' is in the wrong place in the initializer list.\nMember variable '$symbol' is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors." always "\nMember variable '$symbol' is in the wrong place in the initializer list.\nMember variable '$symbol' is in the wrong place in the initializer list. Members are initialized in the order they are declared, not in the order they are in the initializer list.  Keeping the initializer list in the same order that the members were declared prevents order dependent initialization errors."
Line 2498
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
  ( always {!<=-1,!>=2}
Line 2501
  function {symbolic=(scope->function),!0}
Line 2502
  tok always symbolic=(function->arg->link()->next())
  != always {!<=-1,!>=2}
  ":" always ":"
Line 2505
  tok possible symbolic=(function->arg->link()->next())
  != always {!<=-1,!>=2}
Line 2506
  ( always {!<=-1,!>=2}
  "[:,] %var% (|{" always "[:,] %var% (|{"
Line 2508
  ( always {!<=-1,!>=2}
  varTok always symbolic=(tok->next())
  "(|{" always "(|{"
Line 2509
  varTok always symbolic=(tok->next())
Line 2510
  initTok always !0
  == always {!<=-1,!>=2}
  varTok always symbolic=(tok->next())
  ( possible {symbolic=(initTok->astOperand1()->varId()),symbolic=(initTok->astOperand2()->varId())}
Line 2511
  varTok always symbolic=(tok->next())
Line 2512
  initTok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  initTok always !0
  && always {!<=-1,!>=2}
  initTok always !0
  ( always !0
  == always {!<=-1,!>=2}
  varTok always symbolic=(tok->next())
  ( always !symbolic=(initTok->varId())
  || always {!<=-1,!>=2}
  initTok always !0
  && always {!<=-1,!>=2}
  initTok always !0
  ( always !0
  == always {!<=-1,!>=2}
  varTok always symbolic=(tok->next())
  ( always !symbolic=(initTok->varId())
Line 2513
  varTok always symbolic=(tok->next())
Line 2523
  tok possible 0@255
  "selfInitialization" always "selfInitialization"
  "$symbol:" always "$symbol:"
  varname inconclusive "var"@255
  "\nMember variable '$symbol' is initialized by itself." always "\nMember variable '$symbol' is initialized by itself."
  :: always 0
  normal always 0
Line 2533
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2537
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2538
  ! always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2539
  . always !0
  ( always {!<=-1,!>=2}
Line 2542
  . always !0
Line 2544
  1 always 1
Line 2545
  callstack always size=1
Line 2546
  ( always {!<=-1,!>=2}
Line 2548
  ! always {!<=-1,!>=2}
  callstack always !size=0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  callstack always !size=0
  ( always {!<=-1,!>=2}
Line 2550
  callstack always !size=0
  ( always {!<=-1,!>=2}
Line 2551
  callstack always !size=0
  callstack always !size=0
Line 2552
  ! always {!<=-1,!>=2}
  callstack always !size=0
  ( always {!<=-1,!>=2}
Line 2553
  callstack always !size=0
  callstack always !size=0
Line 2561
  :: possible {symbolic=(virtualFunctionCallsMap.end()),end=0}
  found possible {symbolic=(virtualFunctionCallsMap.end()),end=0}
  = possible lifetime[Iterator]=(virtualFunctionCallsMap)
  ( possible lifetime[Iterator]=(virtualFunctionCallsMap)
  & {lifetime[Address]=(function),!0}
Line 2562
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(virtualFunctionCallsMap),end=0}
Line 2563
  found always {!symbolic=(virtualFunctionCallsMap.end()),!end=0}
Line 2565
  & {lifetime[Address]=(function),!0}
  = always size=0
  ( always size=0
Line 2568
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2571
  != always {!<=-1,!>=2}
Line 2572
  . possible {1,2,4}
  != {!<=-1,!>=2,1}
  :: always 0
  eConstructor always 0
  && {!<=-1,!>=2,1}
Line 2573
  . {2,4,!0}
  != {!<=-1,!>=2,1}
  :: always 1
  eCopyConstructor always 1
  && {!<=-1,!>=2,1}
Line 2574
  . {4,!0,!1}
  != {!<=-1,!>=2,1}
  :: always 2
  eMoveConstructor always 2
  && always {!<=-1,!>=2}
Line 2575
  . always {!1,!2}
  != always {!<=-1,!>=2}
  :: always 4
  eDestructor always 4
Line 2576
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "if|switch" always "if|switch"
  || always {!<=-1,!>=2}
Line 2577
  ( always {!<=-1,!>=2}
  "else {" always "else {"
Line 2579
  1 always 1
Line 2583
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 2587
  ! always {!<=-1,!>=2}
  callFunction always symbolic=(tok->function())
  || always {!<=-1,!>=2}
Line 2588
  != always {!<=-1,!>=2}
  callFunction {symbolic=(tok->function()),!0}
  || always {!<=-1,!>=2}
Line 2589
  ( always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
Line 2590
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "(" always "("
Line 2593
  && always {!<=-1,!>=2}
Line 2594
  ( always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 2595
  = always !0
  ( always !0
Line 2596
  prev {symbolic=(tok->previous()),!0}
  && always {!<=-1,!>=2}
Line 2597
  ( always {!<=-1,!>=2}
Line 2598
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  prev {symbolic=(tok->previous()),!0}
  ( always !0
Line 2602
  callFunction {symbolic=(tok->function()),!0}
  ( always {!<=-1,!>=2}
Line 2603
  ! always {!<=-1,!>=2}
  callFunction {symbolic=(tok->function()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "::" always "::"
Line 2609
  virtualFunctionCallsOfTok possible size=0
  callFunction always !0
Line 2610
  ! {!<=-1,!>=2,0}
  virtualFunctionCallsOfTok possible size=0
  ( {!<=-1,!>=2,1}
Line 2622
  callFunction always symbolic=(callToken->function())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  callFunction always symbolic=(callToken->function())
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  callFunction always symbolic=(callToken->function())
  ( always {!<=-1,!>=2}
Line 2623
  callFunction always symbolic=(callToken->function())
Line 2626
  = possible lifetime[Iterator]=(virtualFunctionCallsMap)
  ( possible lifetime[Iterator]=(virtualFunctionCallsMap)
  callFunction always symbolic=(callToken->function())
Line 2627
  found {lifetime[Iterator]=(virtualFunctionCallsMap),symbolic=(virtualFunctionCallsMap.find(callFunction))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(virtualFunctionCallsMap),end=0}
  || always {!<=-1,!>=2}
  found {lifetime[Iterator]=(virtualFunctionCallsMap),symbolic=(virtualFunctionCallsMap.find(callFunction)),!symbolic=(virtualFunctionCallsMap.end()),!end=0}
Line 2628
  pureFuncStack always NonMovedVariable
Line 2631
  found {lifetime[Iterator]=(virtualFunctionCallsMap),!end=0}
Line 2641
  = possible "constructor"
  scopeFunction possible 0
  ? possible "constructor"
  scopeFunction always !0
  . possible 4
  : always "constructor"
  "constructor" always "constructor"
Line 2644
  = always 1
  1 always 1
Line 2645
  tokStack possible size=0@3
Line 2646
  errorPath possible size=0
  "Calling " always "Calling "
Line 2647
  ! {!<=-1,!>=2,0}
  errorPath possible size=0
  ( {!<=-1,!>=2,1}
Line 2648
  errorPath always !size=0
Line 2649
  errorPath always !size=0
  " is a virtual function" always " is a virtual function"
Line 2653
  scopeFunction possible 0@3
Line 2654
  scopeFunction always !0
Line 2655
  scopeFunction always !0
  == always {!<=-1,!>=2}
  :: always 4
  eDestructor always 4
Line 2656
  = always "~"
  "~" always "~"
Line 2657
  scopeFunction always !0
  != always {!<=-1,!>=2}
  endToken always symbolic=(scopeFunction->argDef->link()->next())
Line 2658
  ! {!<=-1,!>=2,0}
  constructorName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|%num% %name%|%num%" always "%name%|%num% %name%|%num%"
Line 2659
  ' ' always 32
Line 2660
  ( possible size=1
Line 2661
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2666
  :: always 3
  style always 3
  "virtualCallInConstructor" always "virtualCallInConstructor"
Line 2667
  "Virtual function '" always "Virtual function '"
  funcname possible "f"@3
  "' is called from " always "' is called from "
  " '" always " '"
  constructorName possible size=0
  "' at line " always "' at line "
  ". Dynamic binding is not used." always ". Dynamic binding is not used."
  0U always 0
  :: always 0
  normal always 0
Line 2675
  = possible "constructor"
  scopeFunction possible 0@2
  ? possible "constructor"
  scopeFunction always !0
  : always "constructor"
  "constructor" always "constructor"
Line 2678
  tokStack possible size=0@2
Line 2679
  errorPath possible size=0
  "Calling " always "Calling "
Line 2680
  ! {!<=-1,!>=2,0}
  errorPath possible size=0
  ( {!<=-1,!>=2,1}
Line 2681
  errorPath always !size=0
  " is a pure virtual function without body" always " is a pure virtual function without body"
Line 2683
  errorPath possible size=0
  :: always 2
  warning always 2
  "pureVirtualCall" always "pureVirtualCall"
Line 2684
  "$symbol:" always "$symbol:"
  purefuncname possible "f"@2
  "\nCall of pure virtual function '$symbol' in " always "\nCall of pure virtual function '$symbol' in "
Line 2685
  ".\nCall of pure virtual function '$symbol' in " always ".\nCall of pure virtual function '$symbol' in "
Line 2686
  ". The call will fail during runtime." always ". The call will fail during runtime."
  0U always 0
  :: always 0
  normal always 0
Line 2696
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2702
  & {lifetime[Address]=(mSymbolDatabase->typeList),!0}
  & {lifetime[Address]=(mSymbolDatabase->typeList),!0}
Line 2708
  typeBase possible lifetime[Address]=(mSymbolDatabase->typeList)@109
Line 2710
  ! always {!<=-1,!>=2}
  . possible symbolic=(typeBase)
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
Line 2713
  . always !0
  == always {!<=-1,!>=2}
Line 2716
  typeCurrent possible symbolic=(parentClassIt.type)
Line 2718
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2721
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
Line 2722
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
Line 2726
  != always {!<=-1,!>=2}
Line 2733
  , always {!<=-1,!>=2}
  derivedIsStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  baseIsStruct always {!<=-1,!>=2}
Line 2736
  errorPath always size=0
  tok2 possible 0
  "Parent variable '" always "Parent variable '"
  baseName inconclusive "class"
  "::" always "::"
  variableName inconclusive "variable"
  "'" always "'"
Line 2737
  errorPath always !size=0
  tok1 inconclusive 0
  "Derived variable '" always "Derived variable '"
  derivedName inconclusive "class"
  "::" always "::"
  variableName inconclusive "variable"
  "'" always "'"
Line 2739
  "$symbol:" always "$symbol:"
  derivedName inconclusive "class"
  "\n$symbol:" always "\n$symbol:"
  variableName inconclusive "variable"
  "\n$symbol:" always "\n$symbol:"
  baseName inconclusive "class"
Line 2741
  "The " always "The "
  derivedIsStruct {!<=-1,!>=2,0@103,1@103}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
  " '" always " '"
  derivedName inconclusive "class"
Line 2742
  "' defines member variable with name '" always "' defines member variable with name '"
  variableName inconclusive "variable"
  "' also defined in its parent " always "' also defined in its parent "
Line 2743
  baseIsStruct {!<=-1,!>=2,0@103,1@103}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
  " '" always " '"
  baseName inconclusive "class"
  "'." always "'."
Line 2744
  errorPath always !size=0
  :: always 2
  warning always 2
  "duplInheritedMember" always "duplInheritedMember"
  '\n' always 10
  :: always 0
  normal always 0
Line 2753
  NO always 0
Line 2754
  WITHOUT_BODY always 1
Line 2755
  WITH_BODY always 2
Line 2765
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2770
  hasNonStaticVars always {!<=-1,!>=2}
  hasNonStaticVars always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2771
  = {lifetime[Iterator]=(scope->varlist),start=0}
  ( {lifetime[Iterator]=(scope->varlist),start=0}
  var possible {lifetime[Iterator]=(scope->varlist),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->varlist),end=0}
Line 2772
  ! always {!<=-1,!>=2}
  var {lifetime[Iterator]=(scope->varlist),!symbolic=(scope->varlist.end()),!end=0}
  ( always {!<=-1,!>=2}
Line 2773
  hasNonStaticVars always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2777
  ! {!<=-1,!>=2,1,0}
  hasNonStaticVars {!<=-1,!>=2,0,1}
Line 2780
  = always 0
  :: always 0
  NO always 0
Line 2781
  moveCtor always {!<=-1,!>=2}
  moveCtor always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2782
  = always 0
  :: always 0
  NO always 0
Line 2785
  copyCtors possible 0
  == {!<=-1,!>=2,1}
  :: always 0
  NO always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  eCopyConstructor always 1
Line 2786
  ( always {!<=-1,!>=2}
  :: always 2
  WITH_BODY always 2
  : always 1
  :: always 1
  WITHOUT_BODY always 1
Line 2788
  assignmentOperators possible symbolic=(func.hasBody()?CtorType::WITH_BODY:CtorType::WITHOUT_BODY)
  == always {!<=-1,!>=2}
  :: always 0
  NO always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  eOperatorEqual always 3
Line 2789
  0 always 0
Line 2790
  && always {!<=-1,!>=2}
  variable always !0
  && always {!<=-1,!>=2}
  variable always !0
  ( always !0
  == always {!<=-1,!>=2}
Line 2791
  ( always {!<=-1,!>=2}
  :: always 2
  WITH_BODY always 2
  : always 1
  :: always 1
  WITHOUT_BODY always 1
Line 2794
  == always {!<=-1,!>=2}
  :: always 2
  eMoveConstructor always 2
Line 2795
  moveCtor always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2800
  moveCtor {!<=-1,!>=2,1}
Line 2804
  copyCtors possible 0
  != {!<=-1,!>=2,1}
  :: always 2
  WITH_BODY always 2
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 2
  WITH_BODY always 2
Line 2808
  copyCtors possible 2
  != {!<=-1,!>=2,1}
  :: always 0
  NO always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  NO always 0
Line 2811
  == always {!<=-1,!>=2}
  :: always 2
  eStruct always 2
  copyCtors possible 0
  == {!<=-1,!>=2,0}
  :: always 2
  WITH_BODY always 2
Line 2815
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  hasCopyCtor always {!<=-1,!>=2}
Line 2817
  "$symbol:" always "$symbol:"
  classname possible "class"@1
  "\nThe " always "\nThe "
Line 2818
  isStruct {!<=-1,!>=2,0@99,1@99}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
  " '$symbol' has '" always " '$symbol' has '"
Line 2819
  hasCopyCtor {!<=-1,!>=2,0@99}
  ? possible {1,3}
  :: always 1
  eCopyConstructor always 1
  : always 3
  :: always 3
  eOperatorEqual always 3
Line 2820
  "' but lack of '" always "' but lack of '"
  hasCopyCtor {!<=-1,!>=2,0@99}
  ? possible {3,1}
  :: always 3
  eOperatorEqual always 3
  : always 1
  :: always 1
  eCopyConstructor always 1
Line 2821
  "'." always "'."
Line 2822
  tok possible 0@1
  :: always 2
  warning always 2
  "copyCtorAndEqOperator" always "copyCtorAndEqOperator"
Line 2827
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2829
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 2832
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
Line 2835
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2839
  baseFunc always !0
  & {lifetime[Address]=(classScope->functionList),!0}
Line 2846
  = possible ""
  funcInDerived possible {0,lifetime[Address]=(classScope->functionList)@89}
  ? possible ""
  funcInDerived {!0,lifetime[Address]=(classScope->functionList)@89}
  ( always {!<=-1,!>=2}
  "~" always "~"
  : always ""
  "" always ""
  funcInDerived {!0,lifetime[Address]=(classScope->functionList)@89}
  : always ""
  "" always ""
Line 2847
  funcInDerived possible {0,lifetime[Address]=(classScope->functionList)@89}
  && always {!<=-1,!>=2}
  funcInDerived {!0,lifetime[Address]=(classScope->functionList)@89}
  ( always {!<=-1,!>=2}
  "destructor" always "destructor"
  : always "function"
  "function" always "function"
Line 2850
  funcInBase possible 0@4
  && always {!<=-1,!>=2}
  funcInDerived possible lifetime[Address]=(classScope->functionList)@89
Line 2851
  errorPath always size=0
  funcInBase always !0
  "Virtual " always "Virtual "
  " in base class" always " in base class"
Line 2852
  errorPath always size=1
  funcInDerived {!0,lifetime[Address]=(classScope->functionList)@89}
  0 always 0
  1 always 1
  " in derived class" always " in derived class"
Line 2855
  errorPath possible size=0
  :: always 3
  style always 3
  "missingOverride" always "missingOverride"
Line 2856
  "$symbol:" always "$symbol:"
  functionName possible symbolic=(funcInDerived?((funcInDerived->isDestructor()?"~":"")+funcInDerived->name()):"")
  "\nThe " always "\nThe "
Line 2857
  " '$symbol' overrides a " always " '$symbol' overrides a "
  " in a base class but is not marked with a 'override' specifier." always " in a base class but is not marked with a 'override' specifier."
Line 2858
  0U always 0
Line 2859
  :: always 0
  normal always 0
Line 2864
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2871
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
Line 2873
  != always {!<=-1,!>=2}
Line 2878
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2879
  hasAssign always {!<=-1,!>=2}
  hasAssign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2881
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2883
  != always {!<=-1,!>=2}
Line 2884
  ( always {!<=-1,!>=2}
  "%varid% = this|shared_from_this" always "%varid% = this|shared_from_this"
Line 2885
  hasAssign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2889
  hasAssign {!<=-1,!>=2,1}
Line 2892
  ! always {!<=-1,!>=2}
  hasAssign always {!<=-1,!>=2}
Line 2898
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2901
  = always 0
  nullptr always 0
Line 2903
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(classScope->functionList),!0}
  & {lifetime[Address]=(classScope->varlist),!0}
  callstack always size=0
  & {lifetime[Address]=(freeToken),!0}
  freeToken always 0
Line 2909
  ( always {!<=-1,!>=2}
Line 2911
  ! always {!<=-1,!>=2}
  func possible lifetime[Address]=(classScope->functionList)@81
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  func {!0,lifetime[Address]=(classScope->functionList)@81}
Line 2912
  return always {!<=-1,!>=2}
  false always 0
Line 2915
  callstack possible size=0@81
  ( always !<=-1
  func {!0,lifetime[Address]=(classScope->functionList)@81}
Line 2916
  return always {!<=-1,!>=2}
  false always 0
Line 2917
  callstack possible lifetime[Object]=(func)
  func always !0
Line 2921
  = always symbolic=(func->functionScope->bodyStart)
  bodyStart always symbolic=(func->functionScope->bodyStart)
  tok possible symbolic=(func->functionScope->bodyStart)
  != always {!<=-1,!>=2}
  bodyEnd always symbolic=(func->functionScope->bodyEnd)
  tok possible symbolic=(*freeToken)
Line 2922
  isDestroyed always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2923
  ( always {!<=-1,!>=2}
  "delete %var% ;" always "delete %var% ;"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2925
  tok always symbolic=(*freeToken)
  2 always 2
Line 2926
  ( always {!<=-1,!>=2}
  "%var% . reset ( )" always "%var% . reset ( )"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 2928
  ( always {!<=-1,!>=2}
  "!!. %name% (" always "!!. %name% ("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 2929
  isDestroyed always {!<=-1,!>=2}
Line 2931
  return always {!<=-1,!>=2}
  true always 1
Line 2933
  ( always {!<=-1,!>=2}
  classScope always symbolic=(tok->function()->nestedIn)
  ( always !0
  callstack {lifetime[Object]=(func),!size=0}
Line 2934
  return always {!<=-1,!>=2}
  true always 1
Line 2935
  isDestroyed always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!!. %name%" always "!!. %name%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2937
  return always {!<=-1,!>=2}
  true always 1
Line 2938
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|throw" always "return|throw"
Line 2940
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "throw" always "throw"
Line 2941
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 2945
  return always {!<=-1,!>=2}
  false always 0
Line 2950
  = possible "ptr"
  self possible 0@5
  ? possible "ptr"
  self always !0
  : always "ptr"
  "ptr" always "ptr"
Line 2951
  self possible 0@5
  "Assuming '" always "Assuming '"
  "' is used as 'this'" always "' is used as 'this'"
  free inconclusive 0@5
  "Delete '" always "Delete '"
  "', invalidating 'this'" always "', invalidating 'this'"
  use inconclusive 0@5
  "Call method when 'this' is invalid" always "Call method when 'this' is invalid"
Line 2952
  = possible "x"
  use inconclusive 0@5
  ? possible "x"
  use always !0
  : always "x"
  "x" always "x"
Line 2953
  use inconclusive 0@5
  && always {!<=-1,!>=2}
  use always !0
  "Calling method '" always "Calling method '"
  usestr always symbolic=(use?use->str():"x")
  "()'" always "()'"
  "Using member '" always "Using member '"
  usestr always symbolic=(use?use->str():"x")
  "'" always "'"
Line 2954
  errorPath always {{,size=3}
  :: always 2
  warning always 2
  "thisUseAfterFree" always "thisUseAfterFree"
Line 2955
  "$symbol:" always "$symbol:"
  "\n" always "\n"
Line 2956
  usemsg always symbolic=(use&&use->function()?("Calling method '"+usestr+"()'"):("Using member '"+usestr+"'"))
  " when 'this' might be invalid" always " when 'this' might be invalid"
Line 2957
  0 always 0
  :: always 0
  normal always 0
Line 2962
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  classes always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2966
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2970
  ( always {!<=-1,!>=2}
  initList possible symbolic=(func.constructorMemberInitialization())
  "[:,] %name% (" always "[:,] %name% ("
Line 2971
  ( always {!<=-1,!>=2}
  2 always 2
  "( %var% )" always "( %var% )"
Line 2973
  3 always 3
Line 2974
  memberVar always symbolic=(initList->next()->variable())
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  memberVar {symbolic=(initList->next()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  memberVar always symbolic=(initList->next()->variable())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2975
  "::" always "::"
  memberVar {symbolic=(initList->next()->variable()),!0}
Line 2977
  2 always 2
Line 2985
  tok possible 0@6
  :: always 2
  warning always 2
  "unsafeClassRefMember" always "unsafeClassRefMember"
Line 2986
  "$symbol:" always "$symbol:"
  varname possible "UnsafeClass::var"@6
  "\nUnsafe class: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\nUnsafe class checking: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member '$symbol' a non-reference variable or a smart pointer." always "\nUnsafe class: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues.\nUnsafe class checking: The const reference member '$symbol' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member '$symbol' a non-reference variable or a smart pointer."
Line 2989
  0 always 0
  :: always 0
  normal always 0
Line 2994
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2995
  nullptr always 0
Line 3000
  ( always {!<=-1,!>=2}
Line 3004
  fullDefinition always {!<=-1,!>=2}
  fullDefinition always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(classScope->functionList),start=0}
Line 3005
  ( {lifetime[Iterator]=(classScope->functionList),end=0}
Line 3007
  ( always {!<=-1,!>=2}
Line 3009
  ! always {!<=-1,!>=2}
  fullDefinition always {!<=-1,!>=2}
Line 3014
  scope possible symbolic=(classScope)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  classScope possible symbolic=(scope)
  ( always {!<=-1,!>=2}
Line 3015
  ( always {!<=-1,!>=2}
  "struct|class %name% :: %name%" always "struct|class %name% :: %name%"
Line 3017
  name always NonMovedVariable
Line 3020
  "::" always "::"
Line 3023
  name possible {NonMovedVariable,size=0}
  ( {!<=-1,!>=2,1}
Line 3025
  name {NonMovedVariable,!size=0}
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 3026
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 3032
  classScope possible symbolic=(f.functionScope->nestedIn)
Line 3033
  classScope possible symbolic=(f.functionScope->nestedIn)
Line 3037
  != always {!<=-1,!>=2}
  classScope possible symbolic=(f.functionScope->nestedIn)
Line 3039
  classScope possible symbolic=(f.functionScope->nestedIn)
Line 3040
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
Line 3041
  . always !0
  != always {!<=-1,!>=2}
  . always !0
Line 3045
  . always !<=-1
  hash always !<=-1
  = always !<=-1
Line 3050
  ( always {!<=-1,!>=2}
Line 3051
  nullptr always 0
Line 3054
  fileInfo always size=0
  classDefinitions always !size=0
Line 3055
  fileInfo always size=0
Line 3062
  "<class name=\"" always "<class name=\""
Line 3063
  "\" file=\"" always "\" file=\""
Line 3064
  "\" line=\"" always "\" line=\""
Line 3065
  "\" col=\"" always "\" col=\""
Line 3066
  "\" hash=\"" always "\" hash=\""
  . always !<=-1
  hash always !<=-1
Line 3067
  "\"/>\n" always "\"/>\n"
Line 3076
  "class" always "class"
  != always {!<=-1,!>=2}
  0 always 0
Line 3078
  "name" always "name"
Line 3079
  "file" always "file"
Line 3080
  "line" always "line"
Line 3081
  "col" always "col"
Line 3082
  "hash" always "hash"
Line 3083
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3085
  = always !0
  name always !0
Line 3086
  = always !0
  file always !0
Line 3087
  line always !0
Line 3088
  col always !0
Line 3089
  . always !<=-1
  hash always !<=-1
  = always !<=-1
  ( always !<=-1
  hash always !0
Line 3090
  fileInfo always size=0
Line 3093
  fileInfo always size=0
  ( always {!<=-1,!>=2}
Line 3094
  fileInfo always size=0
Line 3095
  = always 0
  nullptr always 0
Line 3097
  fileInfo possible 0
Line 3100
  ( always {!<=-1,!>=2}
Line 3102
  foundErrors always {!<=-1,!>=2}
  foundErrors always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3110
  ! always {!<=-1,!>=2}
  fi always symbolic=(dynamic_cast<MyFileInfo*>(fi1))
Line 3112
  fi {symbolic=(dynamic_cast<MyFileInfo*>(fi1)),!0}
Line 3113
  = possible lifetime[Iterator]=(all)
  ( possible lifetime[Iterator]=(all)
Line 3114
  it {lifetime[Iterator]=(all),symbolic=(all.find(nameLoc.className))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(all),end=0}
Line 3118
  it {lifetime[Iterator]=(all),symbolic=(all.find(nameLoc.className)),!end=0}
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 3121
  it always !end=0
Line 3125
  locationList always size=0
Line 3126
  locationList always !size=0
Line 3128
  locationList always !size=0
Line 3131
  "$symbol:" always "$symbol:"
Line 3132
  "\nThe one definition rule is violated, different classes/structs have the same name '$symbol'" always "\nThe one definition rule is violated, different classes/structs have the same name '$symbol'"
Line 3133
  "ctuOneDefinitionRuleViolation" always "ctuOneDefinitionRuleViolation"
Line 3135
  :: always 0
  normal always 0
Line 3138
  foundErrors always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3141
  return always {!<=-1,!>=2}
  foundErrors always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,2@26,3@86,5@79,4@172}
  flag possible {2@26,3@86,5@79,4@172}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
