

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073744775 !@expr1073744776 mTokenizer@var28 ) {
69: instances (@expr1073744777 ) .@expr1073744778 remove (@expr1073744779 this@expr1073744780 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073744781 string (@expr1073744782 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073744783 void ) tokenizer@var21 ;
108: (@expr1073744784 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073744785 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073744786 void ) ctu@var24 ;
120: (@expr1073744787 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073744788 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073744789 0U ) , Certainty ::@expr1073744790 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073744791 list < const Token *@expr1073744792 > callstack@var41 (@expr1073744793 1 , tok@var35 ) ;
141: reportError (@expr1073744794 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073744795 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073744796 0U ) , Certainty ::@expr1073744797 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var64 ;
42: double mDoubleValue@var65 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var66 ;
44: bool mIsUnsigned@var67 ;
45:
46: void promote ( const value & v@var68 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var69 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var66 !=@expr1073744798 Type ::@expr1073744799 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var66 ==@expr1073744800 Type ::@expr1073744801 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744802 ) ?@expr1073744803 mDoubleValue@var65 :@expr1073744804 (@expr1073744805 double ) mIntValue@var64 ;
60: }
61:
62: static value calc ( char op@var70 , const value & v1@var71 , const value & v2@var72 ) ;
63: int compare ( const value & v@var73 ) const ;
64: value add ( int v@var74 ) const ;
65: value shiftLeft ( const value & v@var75 ) const ;
66: value shiftRight ( const value & v@var76 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var77 ;
72:
73: static long long toLongNumber ( const std :: string & str@var78 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var79 ) ;
75:
76: template < class T > static std :: string toString ( T value@var80 ) {
77: std ::@expr1073744806 ostringstream result@var81 ;
78: result@var81 <<@expr1073744807 value@var80 ;
79: return result@var81 .@expr1073744808 str (@expr1073744809 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var82 ) ;
82:
83: static bool isInt ( const std :: string & str@var83 ) ;
84: static bool isFloat ( const std :: string & str@var84 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var85 ) ;
86: static bool isNegative ( const std :: string & str@var86 ) ;
87: static bool isPositive ( const std :: string & str@var87 ) ;
88: static bool isDec ( const std :: string & str@var88 ) ;
89: static bool isFloatHex ( const std :: string & str@var89 ) ;
90: static bool isIntHex ( const std :: string & str@var90 ) ;
91: static bool isOct ( const std :: string & str@var91 ) ;
92: static bool isBin ( const std :: string & str@var92 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var93 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var94 , bool supportMicrosoftExtensions@var95 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var96 , const std :: string & second@var97 ) ;
105: static std :: string subtract ( const std :: string & first@var98 , const std :: string & second@var99 ) ;
106: static std :: string multiply ( const std :: string & first@var100 , const std :: string & second@var101 ) ;
107: static std :: string divide ( const std :: string & first@var102 , const std :: string & second@var103 ) ;
108: static std :: string mod ( const std :: string & first@var104 , const std :: string & second@var105 ) ;
109: static std :: string incdec ( const std :: string & var@var106 , const std :: string & op@var107 ) ;
110: static std :: string calculate ( const std :: string & first@var108 , const std :: string & second@var109 , char action@var110 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var111 ) ;
113: static std :: string cos ( const std :: string & tok@var112 ) ;
114: static std :: string tan ( const std :: string & tok@var113 ) ;
115: static std :: string abs ( const std :: string & tok@var114 ) ;
116: static bool isEqual ( const std :: string & first@var115 , const std :: string & second@var116 ) ;
117: static bool isNotEqual ( const std :: string & first@var117 , const std :: string & second@var118 ) ;
118: static bool isGreater ( const std :: string & first@var119 , const std :: string & second@var120 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var121 , const std :: string & second@var122 ) ;
120: static bool isLess ( const std :: string & first@var123 , const std :: string & second@var124 ) ;
121: static bool isLessEqual ( const std :: string & first@var125 , const std :: string & second@var126 ) ;
122: static bool isNullValue ( const std :: string & str@var127 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var128 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var129 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var130 , std :: string :: size_type iPos@var131 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var132 , const MathLib :: value & v2@var133 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var134 , const MathLib :: value & v2@var135 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var136 , const MathLib :: value & v2@var137 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var138 , const MathLib :: value & v2@var139 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var140 , const MathLib :: value & v2@var141 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var142 , const MathLib :: value & v2@var143 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var144 , const MathLib :: value & v2@var145 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var146 , const MathLib :: value & v2@var147 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var148 , const MathLib :: value & v2@var149 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var150 , const MathLib :: value & v2@var151 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var152 ) ;

##file cppcheck-2.8/lib/checkcondition.h

1:
|
32:
33: class Settings ;
34: class Token ;
35: class Tokenizer ;
36: class ErrorLogger ;
37: class ValueType ;
38:
39: namespace ValueFlow {
40: class Value ;
41: }
42:
|
49:
50: class CheckCondition : public Check {
51: public:
52:
53: CheckCondition ( ) : Check ( myName ( ) ) { }
54:
55:
56: CheckCondition ( const Tokenizer * tokenizer@var153 , const Settings * settings@var154 , ErrorLogger * errorLogger@var155 )
57: : Check ( myName ( ) , tokenizer@var153 , settings@var154 , errorLogger@var155 ) { }
58:
59: void runChecks ( const Tokenizer * tokenizer@var156 , const Settings * settings@var157 , ErrorLogger * errorLogger@var158 ) override {
60: CheckCondition checkCondition@var159 (@expr1073744810 tokenizer@var156 , settings@var157 , errorLogger@var158 ) ;
61: checkCondition@var159 .@expr1073744811 multiCondition (@expr1073744812 ) ;
62: checkCondition@var159 .@expr1073744813 clarifyCondition (@expr1073744814 ) ;
63: checkCondition@var159 .@expr1073744815 multiCondition2 (@expr1073744816 ) ;
64: checkCondition@var159 .@expr1073744817 checkIncorrectLogicOperator (@expr1073744818 ) ;
65: checkCondition@var159 .@expr1073744819 checkInvalidTestForOverflow (@expr1073744820 ) ;
66: checkCondition@var159 .@expr1073744821 duplicateCondition (@expr1073744822 ) ;
67: checkCondition@var159 .@expr1073744823 checkPointerAdditionResultNotNull (@expr1073744824 ) ;
68: checkCondition@var159 .@expr1073744825 checkDuplicateConditionalAssign (@expr1073744826 ) ;
69: checkCondition@var159 .@expr1073744827 assignIf (@expr1073744828 ) ;
70: checkCondition@var159 .@expr1073744829 alwaysTrueFalse (@expr1073744830 ) ;
71: checkCondition@var159 .@expr1073744831 checkBadBitmaskCheck (@expr1073744832 ) ;
72: checkCondition@var159 .@expr1073744833 comparison (@expr1073744834 ) ;
73: checkCondition@var159 .@expr1073744835 checkModuloAlwaysTrueFalse (@expr1073744836 ) ;
74: checkCondition@var159 .@expr1073744837 checkAssignmentInCondition (@expr1073744838 ) ;
75: checkCondition@var159 .@expr1073744839 checkCompareValueOutOfTypeRange (@expr1073744840 ) ;
76: }
77:
78:
79: void assignIf ( ) ;
80:
81:
82: bool assignIfParseScope ( const Token * const assignTok@var160 ,
83: const Token * const startTok@var161 ,
84: const int varid@var162 ,
85: const bool islocal@var163 ,
86: const char bitop@var164 ,
87: const long long num@var165 ) ;
88:
89:
90: void checkBadBitmaskCheck ( ) ;
91:
92:
93: void comparison ( ) ;
94:
95: void duplicateCondition ( ) ;
96:
97:
98: void multiCondition ( ) ;
99:
|
105:
106: void multiCondition2 ( ) ;
107:
108:
109: void checkIncorrectLogicOperator ( ) ;
110:
111:
112: void checkModuloAlwaysTrueFalse ( ) ;
113:
114:
115: void clarifyCondition ( ) ;
116:
117:
118: void alwaysTrueFalse ( ) ;
119:
120:
121: void checkInvalidTestForOverflow ( ) ;
122:
123:
124: void checkPointerAdditionResultNotNull ( ) ;
125:
126: void checkDuplicateConditionalAssign ( ) ;
127:
128:
129: void checkAssignmentInCondition ( ) ;
130:
131: private:
132:
133: std :: set < const Token * > mCondDiags@var166 ;
134: bool diag ( const Token * tok@var167 , bool insert@var168 = true ) ;
135: bool isAliased ( const std :: set < int > & vars@var169 ) const ;
136: bool isOverlappingCond ( const Token * const cond1@var170 , const Token * const cond2@var171 , bool pure@var172 ) const ;
137: void assignIfError ( const Token * tok1@var173 , const Token * tok2@var174 , const std :: string & condition@var175 , bool result@var176 ) ;
138: void mismatchingBitAndError ( const Token * tok1@var177 , const long long num1@var178 , const Token * tok2@var179 , const long long num2@var180 ) ;
139: void badBitmaskCheckError ( const Token * tok@var181 ) ;
140: void comparisonError ( const Token * tok@var182 ,
141: const std :: string & bitop@var183 ,
142: long long value1@var184 ,
143: const std :: string & op@var185 ,
144: long long value2@var186 ,
145: bool result@var187 ) ;
146: void duplicateConditionError ( const Token * tok1@var188 , const Token * tok2@var189 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var190 ) ;
147: void overlappingElseIfConditionError ( const Token * tok@var191 , int line1@var192 ) ;
148: void oppositeElseIfConditionError ( const Token * ifCond@var193 , const Token * elseIfCond@var194 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var195 ) ;
149:
150: void oppositeInnerConditionError ( const Token * tok1@var196 , const Token * tok2@var197 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var198 ) ;
151:
152: void identicalInnerConditionError ( const Token * tok1@var199 , const Token * tok2@var200 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var201 ) ;
153:
154: void identicalConditionAfterEarlyExitError ( const Token * cond1@var202 , const Token * cond2@var203 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var204 ) ;
155:
156: void incorrectLogicOperatorError ( const Token * tok@var205 , const std :: string & condition@var206 , bool always@var207 , bool inconclusive@var208 , std :: list < std :: pair < const Token * , std :: string > > errors@var209 ) ;
157: void redundantConditionError ( const Token * tok@var210 , const std :: string & text@var211 , bool inconclusive@var212 ) ;
158:
159: void moduloAlwaysTrueFalseError ( const Token * tok@var213 , const std :: string & maxVal@var214 ) ;
160:
161: void clarifyConditionError ( const Token * tok@var215 , bool assign@var216 , bool boolop@var217 ) ;
162:
163: void alwaysTrueFalseError ( const Token * tok@var218 , const ValueFlow :: Value * value@var219 ) ;
164:
165: void invalidTestForOverflow ( const Token * tok@var220 , const ValueType * valueType@var221 , const std :: string & replace@var222 ) ;
166: void pointerAdditionResultNotNullError ( const Token * tok@var223 , const Token * calc@var224 ) ;
167:
168: void duplicateConditionalAssignError ( const Token * condTok@var225 , const Token * assignTok@var226 ) ;
169:
170: void assignmentInCondition ( const Token * eq@var227 ) ;
171:
172: void checkCompareValueOutOfTypeRange ( ) ;
173: void compareValueOutOfTypeRangeError ( const Token * comparison@var228 , const std :: string & type@var229 , long long value@var230 , bool result@var231 ) ;
174:
175: void getErrorMessages ( ErrorLogger * errorLogger@var232 , const Settings * settings@var233 ) const override {
176: CheckCondition c@var234 (@expr1073744841 nullptr , settings@var233 , errorLogger@var232 ) ;
177:
178: std ::@expr1073744842 list < std ::@expr3019 pair < const Token *@expr1073744844 , std ::@expr3019 string > > errorPath@var235 ;
179:
180: c@var234 .@expr1073744846 assignIfError (@expr1073744847 nullptr , nullptr , emptyString@var1 , false ) ;
181: c@var234 .@expr1073744848 badBitmaskCheckError (@expr1073744849 nullptr ) ;
182: c@var234 .@expr1073744850 comparisonError (@expr1073744851 nullptr , "&" , 6 , "==" , 1 , false ) ;
183: c@var234 .@expr1073744852 duplicateConditionError (@expr1073744853 nullptr , nullptr , errorPath@var235 ) ;
184: c@var234 .@expr1073744854 overlappingElseIfConditionError (@expr1073744855 nullptr , 1 ) ;
185: c@var234 .@expr1073744856 mismatchingBitAndError (@expr1073744857 nullptr , 0xf0 , nullptr , 1 ) ;
186: c@var234 .@expr1073744858 oppositeInnerConditionError (@expr1073744859 nullptr , nullptr , errorPath@var235 ) ;
187: c@var234 .@expr1073744860 identicalInnerConditionError (@expr1073744861 nullptr , nullptr , errorPath@var235 ) ;
188: c@var234 .@expr1073744862 identicalConditionAfterEarlyExitError (@expr1073744863 nullptr , nullptr , errorPath@var235 ) ;
189: c@var234 .@expr1073744864 incorrectLogicOperatorError (@expr1073744865 nullptr , "foo > 3 && foo < 4" , true , false , errorPath@var235 ) ;
190: c@var234 .@expr1073744866 redundantConditionError (@expr1073744867 nullptr , "If x > 11 the condition x > 10 is always true." , false ) ;
191: c@var234 .@expr1073744868 moduloAlwaysTrueFalseError (@expr1073744869 nullptr , "1" ) ;
192: c@var234 .@expr1073744870 clarifyConditionError (@expr1073744871 nullptr , true , false ) ;
193: c@var234 .@expr1073744872 alwaysTrueFalseError (@expr1073744873 nullptr , nullptr ) ;
194: c@var234 .@expr1073744874 invalidTestForOverflow (@expr1073744875 nullptr , nullptr , "false" ) ;
195: c@var234 .@expr1073744876 pointerAdditionResultNotNullError (@expr1073744877 nullptr , nullptr ) ;
196: c@var234 .@expr1073744878 duplicateConditionalAssignError (@expr1073744879 nullptr , nullptr ) ;
197: c@var234 .@expr1073744880 assignmentInCondition (@expr1073744881 nullptr ) ;
198: c@var234 .@expr1073744882 compareValueOutOfTypeRangeError (@expr1073744883 nullptr , "unsigned char" , 256 , true ) ;
199: }
200:
201: static std :: string myName ( ) {
202: return "Condition" ;
203: }
204:
205: std :: string classInfo ( ) const override {
206: return "Match conditions with assignments and other conditions:\n- Mismatching assignment and comparison => comparison is always true/false\n- Mismatching lhs and rhs in comparison => comparison is always true/false\n- Detect usage of | where & should be used\n- Duplicate condition and assignment\n- Detect matching 'if' and 'else if' conditions\n- Mismatching bitand (a &= 0xf0; a &= 1; => a = 0)\n- Opposite inner condition is always false\n- Identical condition after early exit is always false\n- Condition that is always true/false\n- Mutual exclusion over || always evaluating to true\n- Comparisons of modulo results that are always true/false.\n- Known variable values => condition is always true/false\n- Invalid test for overflow. Some mainstream compilers remove such overflow tests when optimising code.\n- Suspicious assignment of container/iterator in condition => condition is always true.\n"
207:
|
219:
220: ;
221: }
222: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var236 ) const {
35: return p@var236 .@expr1073744884 first@var237 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var238 ) const {
42: return p@var238 .@expr1073744885 second@var239 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var240 , const T & x@var241 )
48: {
49: return std ::@expr1073744886 find (@expr1073744887 r@var240 .@expr1073744888 begin (@expr1073744889 ) , r@var240 .@expr3066 end (@expr3067 ) , x@var241 ) !=@expr1073744892 r@var240 .@expr3066 end (@expr3067 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var242 , const T & x@var243 )
54: {
55: return std ::@expr1073744895 find (@expr1073744896 r@var242 .@expr1073744897 begin (@expr1073744898 ) , r@var242 .@expr3075 end (@expr3076 ) , x@var243 ) !=@expr1073744901 r@var242 .@expr3075 end (@expr3076 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var244 , const U & x@var245 )
60: {
61: return std ::@expr1073744904 find (@expr1073744905 r@var244 .@expr1073744906 begin (@expr1073744907 ) , r@var244 .@expr3084 end (@expr3085 ) , x@var245 ) !=@expr1073744910 r@var244 .@expr3084 end (@expr3085 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var246 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744913 t@var246 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var247 , char c@var248 )
74: {
75: return !@expr1073744914 str@var247 .@expr1073744915 empty (@expr1073744916 ) &&@expr1073744917 str@var247 .@expr1073744918 back (@expr1073744919 ) ==@expr1073744920 c@var248 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var249 , const char end@var250 [ ] , unsigned long endlen@var251 )
79: {
80: return (@expr3097 str@var249 .@expr3098 size (@expr3099 ) >=@expr1073744924 endlen@var251 ) &&@expr1073744925 (@expr3097 str@var249 .@expr1073744927 compare (@expr1073744928 str@var249 .@expr3098 size (@expr3099 ) -@expr1073744931 endlen@var251 , endlen@var251 , end@var250 ) ==@expr1073744932 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var252 , const char ( & end@var253 ) [ N ] )
85: {
86: return endsWith (@expr1073744934 str@var252 , end@var253 , N@expr1073744933 -@expr1073744935 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var254 , char q@var255 , const std :: string & p@var256 )
90: {
91: if (@expr1073744936 !@expr1073744937 endsWith (@expr1073744938 str@var254 , q@var255 ) ) {
92: return false ; }
93: if (@expr1073744939 (@expr1073744940 str@var254 .@expr1073744941 length (@expr1073744942 ) +@expr1073744943 1 ) >@expr1073744944 p@var256 .@expr1073744945 length (@expr1073744946 ) &&@expr1073744947 (@expr1073744948 str@var254 .@expr1073744949 compare (@expr1073744950 0 , p@var256 .@expr1073744951 size (@expr1073744952 ) +@expr1073744953 1 , p@var256 +@expr1073744954 q@var255 ) ==@expr1073744955 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var257 , char q@var258 )
99: {
100: static const std ::@expr3132 vector < std ::@expr3132 string > suffixes@var259 {@expr1073744958 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744959 const std ::@expr3132 string &@expr1073744961 p@var260 :@expr1073744962 suffixes@var259 ) {
102: if (@expr1073744963 isPrefixStringCharLiteral (@expr1073744964 str@var257 , q@var258 , p@var260 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var261 )
109: {
110: return isStringCharLiteral (@expr1073744965 str@var261 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var262 )
114: {
115: return isStringCharLiteral (@expr1073744966 str@var262 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var263 , char q@var264 )
119: {
120: const unsigned long quotePos@var265 =@expr1073744967 str@var263 .@expr1073744968 find (@expr1073744969 q@var264 ) ;
121: return str@var263 .@expr1073744970 substr (@expr1073744971 quotePos@var265 +@expr1073744972 1U , str@var263 .@expr1073744973 size (@expr1073744974 ) -@expr1073744975 quotePos@var265 -@expr1073744976 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var266 )
125: {
126: if (@expr1073744977 isStringLiteral (@expr1073744978 str@var266 ) ) {
127: return getStringCharLiteral (@expr1073744979 str@var266 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var267 )
132: {
133: if (@expr1073744980 isCharLiteral (@expr1073744981 str@var267 ) ) {
134: return getStringCharLiteral (@expr1073744982 str@var267 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var268 )
139: {
140: if (@expr1073744983 i@var268 ==@expr1073744984 1 ) {
141: return "st" ; }
142: if (@expr1073744985 i@var268 ==@expr1073744986 2 ) {
143: return "nd" ; }
144: if (@expr1073744987 i@var268 ==@expr1073744988 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var269 , const std :: string & rhs@var270 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var271 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var272 , const std :: string & name@var273 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var274 , const std :: string & name@var275 ) ;
156:
157: void strTolower ( std :: string & str@var276 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var277 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var278 ;
42:
43:
44: std :: string stdValue@var279 ;
45:
46:
47: Standards ( ) : c@var277 ( CLatest ) , cpp@var278 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var280 ) {
50: stdValue@var279 =@expr1073744989 str@var280 ;
51: if (@expr1073744990 str@var280 ==@expr1073744991 "c89" ||@expr1073744992 str@var280 ==@expr1073744993 "C89" ) {
52: c@var277 =@expr1073744994 C89 ;
53: return true ;
54: }
55: if (@expr1073744995 str@var280 ==@expr1073744996 "c99" ||@expr1073744997 str@var280 ==@expr1073744998 "C99" ) {
56: c@var277 =@expr1073744999 C99 ;
57: return true ;
58: }
59: if (@expr1073745000 str@var280 ==@expr1073745001 "c11" ||@expr1073745002 str@var280 ==@expr1073745003 "C11" ) {
60: c@var277 =@expr1073745004 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745005 c@var277 ) {
67: case C89 :@expr3182 ;
68: return "c89" ;
69: case C99 :@expr3182 ;
70: return "c99" ;
71: case C11 :@expr3182 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var281 ) {
77: if (@expr1073745009 std@var281 ==@expr1073745010 "c89" ) {
78: return Standards ::@expr1073745011 C89 ;
79: }
80: if (@expr1073745012 std@var281 ==@expr1073745013 "c99" ) {
81: return Standards ::@expr1073745014 C99 ;
82: }
83: if (@expr1073745015 std@var281 ==@expr1073745016 "c11" ) {
84: return Standards ::@expr1073745017 C11 ;
85: }
86: return Standards ::@expr1073745018 CLatest ;
87: }
88: bool setCPP ( std :: string str@var282 ) {
89: stdValue@var279 =@expr1073745019 str@var282 ;
90: strTolower (@expr1073745020 str@var282 ) ;
91: cpp@var278 =@expr1073745021 getCPP (@expr1073745022 str@var282 ) ;
92: return !@expr1073745023 stdValue@var279 .@expr1073745024 empty (@expr1073745025 ) &&@expr1073745026 str@var282 ==@expr1073745027 getCPP (@expr1073745028 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745029 cpp@var278 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var283 ) {
98: switch (@expr1073745030 std@var283 ) {
99: case CPP03 :@expr3207 ;
100: return "c++03" ;
101: case CPP11 :@expr3207 ;
102: return "c++11" ;
103: case CPP14 :@expr3207 ;
104: return "c++14" ;
105: case CPP17 :@expr3207 ;
106: return "c++17" ;
107: case CPP20 :@expr3207 ;
108: return "c++20" ;
109: case CPP23 :@expr3207 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var284 ) {
115: if (@expr1073745037 std@var284 ==@expr1073745038 "c++03" ) {
116: return Standards ::@expr1073745039 CPP03 ;
117: }
118: if (@expr1073745040 std@var284 ==@expr1073745041 "c++11" ) {
119: return Standards ::@expr1073745042 CPP11 ;
120: }
121: if (@expr1073745043 std@var284 ==@expr1073745044 "c++14" ) {
122: return Standards ::@expr1073745045 CPP14 ;
123: }
124: if (@expr1073745046 std@var284 ==@expr1073745047 "c++17" ) {
125: return Standards ::@expr1073745048 CPP17 ;
126: }
127: if (@expr1073745049 std@var284 ==@expr1073745050 "c++20" ) {
128: return Standards ::@expr1073745051 CPP20 ;
129: }
130: if (@expr1073745052 std@var284 ==@expr1073745053 "c++23" ) {
131: return Standards ::@expr1073745054 CPP23 ;
132: }
133: return Standards ::@expr1073745055 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var288 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var285 ) : errorcode@var288 ( e@var285 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var286 , T && r@var287 ) : errorcode@var288 ( e@var286 ) , reason@var289 ( r@var287 ) { }
66: ErrorCode errorcode@var288 ;
67: std :: string reason@var289 ;
68: } ;
69:
70: Error load ( const char exename@var290 [ ] , const char path@var291 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var292 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var293 [ ] , unsigned long len@var294 ) ;
75:
76: struct AllocFunc {
77: int groupId@var295 ;
78: int arg@var296 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var297 ;
81: int bufferSizeArg1@var298 ;
82: int bufferSizeArg2@var299 ;
83: int reallocArg@var300 ;
84: bool initData@var301 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var302 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var303 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var304 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var305 , int arg@var306 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var307 , int arg@var308 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var309 , int arg@var310 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var311 [ ] ) const {
107: return getAllocDealloc (@expr1073745056 mAlloc@var577 , name@var311 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var312 [ ] ) const {
112: return getAllocDealloc (@expr1073745057 mDealloc@var578 , name@var312 ) ;
113: }
114:
115:
116: int allocId ( const char name@var313 [ ] ) const {
117: const AllocFunc * af@var314 ; af@var314 =@expr1073745058 getAllocDealloc (@expr1073745059 mAlloc@var577 , name@var313 ) ;
118: return af@var314 ?@expr1073745060 af@var314 .@expr1073745061 groupId@var315 :@expr1073745062 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var316 [ ] ) const {
123: const AllocFunc * af@var317 ; af@var317 =@expr1073745063 getAllocDealloc (@expr1073745064 mDealloc@var578 , name@var316 ) ;
124: return af@var317 ?@expr1073745065 af@var317 .@expr1073745066 groupId@var318 :@expr1073745067 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var319 , int id@var320 , int arg@var321 ) {
129: mAlloc@var577 [@expr3244 functionname@var319 ] .@expr1073745069 groupId@var2960 =@expr1073745070 id@var320 ;
130: mAlloc@var577 [@expr3244 functionname@var319 ] .@expr1073745072 arg@var2961 =@expr1073745073 arg@var321 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var322 , int id@var323 , int arg@var324 ) {
134: mDealloc@var578 [@expr3250 functionname@var322 ] .@expr1073745075 groupId@var2962 =@expr1073745076 id@var323 ;
135: mDealloc@var578 [@expr3250 functionname@var322 ] .@expr1073745078 arg@var2963 =@expr1073745079 arg@var324 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var325 , int id@var326 , int arg@var327 , int reallocArg@var328 = 1 ) {
139: mRealloc@var579 [@expr3256 functionname@var325 ] .@expr1073745081 groupId@var2964 =@expr1073745082 id@var326 ;
140: mRealloc@var579 [@expr3256 functionname@var325 ] .@expr1073745084 arg@var2965 =@expr1073745085 arg@var327 ;
141: mRealloc@var579 [@expr3256 functionname@var325 ] .@expr1073745087 reallocArg@var2966 =@expr1073745088 reallocArg@var328 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var329 , bool noreturn@var330 ) {
146: mNoReturn@var580 [@expr1073745089 funcname@var329 ] =@expr1073745090 noreturn@var330 ?@expr1073745091 FalseTrueMaybe ::@expr1073745092 True :@expr1073745093 FalseTrueMaybe ::@expr1073745094 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var331 ) ;
150:
151:
152: static bool ismemory ( const int id@var332 ) {
153: return (@expr3271 (@expr3271 id@var332 >@expr1073745097 0 ) &&@expr1073745098 (@expr3271 (@expr3271 id@var332 &@expr1073745101 1 ) ==@expr1073745102 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var333 ) {
156: return (@expr3279 (@expr3279 func@var333 .@expr3281 groupId@var334 >@expr1073745106 0 ) &&@expr1073745107 (@expr3279 (@expr3279 func@var333 .@expr3281 groupId@var334 &@expr1073745111 1 ) ==@expr1073745112 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var335 ) {
161: return (@expr3289 (@expr3289 id@var335 >@expr1073745115 0 ) &&@expr1073745116 (@expr3289 (@expr3289 id@var335 &@expr1073745119 1 ) ==@expr1073745120 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var336 ) {
164: return (@expr3297 (@expr3297 func@var336 .@expr3299 groupId@var337 >@expr1073745124 0 ) &&@expr1073745125 (@expr3297 (@expr3297 func@var336 .@expr3299 groupId@var337 &@expr1073745129 1 ) ==@expr1073745130 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var338 ) const ;
168: int formatstr_argno ( const Token * ftok@var339 ) const ;
169: bool formatstr_scan ( const Token * ftok@var340 ) const ;
170: bool formatstr_secure ( const Token * ftok@var341 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var342 ;
174: int ptr2Arg@var343 ;
175: int sizeArg@var344 ;
176: int strlenArg@var345 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var346 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var347 ;
182: Standards standards@var348 ;
183: Severity :: SeverityType severity@var349 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var350 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var351 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var352 ) const ;
191: bool matchArguments ( const Token * ftok@var353 , const std :: string & functionName@var354 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var355 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var356 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var357 ) const ;
198: int returnValueContainer ( const Token * ftok@var358 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var359 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var360 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var361 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var362 , std :: string * unknownFunc@var363 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var373 ( -1 ) ,
210: size_templateArgNo@var375 ( -1 ) ,
211: arrayLike_indexOp@var376 ( false ) ,
212: stdStringLike@var377 ( false ) ,
213: stdAssociativeLike@var378 ( false ) ,
214: opLessAllowed@var379 ( true ) ,
215: hasInitializerListConstructor@var380 ( false ) ,
216: unstableErase@var381 ( false ) ,
217: unstableInsert@var382 ( false ) ,
218: view@var383 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var364 ;
248: Yield yield@var365 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var366 ;
252: int templateParameter@var367 ;
253: } ;
254: std :: string startPattern@var368 ; std :: string startPattern2@var369 ; std :: string endPattern@var370 ; std :: string itEndPattern@var371 ;
255: std :: map < std :: string , Function > functions@var372 ;
256: int type_templateArgNo@var373 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var374 ;
258: int size_templateArgNo@var375 ;
259: bool arrayLike_indexOp@var376 ;
260: bool stdStringLike@var377 ;
261: bool stdAssociativeLike@var378 ;
262: bool opLessAllowed@var379 ;
263: bool hasInitializerListConstructor@var380 ;
264: bool unstableErase@var381 ;
265: bool unstableInsert@var382 ;
266: bool view@var383 ;
267:
268: Action getAction ( const std :: string & function@var384 ) const {
269: const std ::@expr1073745131 map < std ::@expr1073745132 string , Function > ::@expr1073745133 const_iterator i@var385 =@expr1073745134 functions@var372 .@expr1073745135 find (@expr1073745136 function@var384 ) ;
270: if (@expr1073745137 i@var385 !=@expr1073745138 functions@var372 .@expr1073745139 end (@expr1073745140 ) ) {
271: return i@var385 .@expr1073745141 second@var386 .@expr1073745142 action@var387 ; }
272: return Action ::@expr1073745143 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var388 ) const {
276: const std ::@expr1073745144 map < std ::@expr1073745145 string , Function > ::@expr1073745146 const_iterator i@var389 =@expr1073745147 functions@var372 .@expr1073745148 find (@expr1073745149 function@var388 ) ;
277: if (@expr1073745150 i@var389 !=@expr1073745151 functions@var372 .@expr1073745152 end (@expr1073745153 ) ) {
278: return i@var389 .@expr1073745154 second@var390 .@expr1073745155 yield@var391 ; }
279: return Yield ::@expr1073745156 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var392 ) ;
283: static Action actionFrom ( const std :: string & actionName@var393 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var394 ;
286: const Container * detectContainer ( const Token * typeStart@var395 , bool iterator@var396 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var397 , bool * isIterator@var398 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var399 ( false ) ,
293: notnull@var400 ( false ) ,
294: notuninit@var401 ( -1 ) ,
295: formatstr@var402 ( false ) ,
296: strz@var403 ( false ) ,
297: optional@var404 ( false ) ,
298: variadic@var405 ( false ) ,
299: iteratorInfo@var411 ( ) ,
300: direction@var419 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var399 ;
303: bool notnull@var400 ;
304: int notuninit@var401 ;
305: bool formatstr@var402 ;
306: bool strz@var403 ;
307: bool optional@var404 ;
308: bool variadic@var405 ;
309: std :: string valid@var406 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var407 ( 0 ) , it@var408 ( false ) , first@var409 ( false ) , last@var410 ( false ) { }
314:
315: int container@var407 ;
316: bool it@var408 ;
317: bool first@var409 ;
318: bool last@var410 ;
319: } ;
320: IteratorInfo iteratorInfo@var411 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var412 , int a@var413 ) : type@var414 ( t@var412 ) , arg@var415 ( a@var413 ) , arg2@var416 ( 0 ) , value@var417 ( 0 ) { }
326: Type type@var414 ;
327: int arg@var415 ;
328: int arg2@var416 ;
329: long long value@var417 ;
330: } ;
331: std :: vector < MinSize > minsizes@var418 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var419 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var420 ;
344: bool use@var421 ;
345: bool leakignore@var422 ;
346: bool isconst@var423 ;
347: bool ispure@var424 ;
348: UseRetValType useretval@var425 ;
349: bool ignore@var426 ;
350: bool formatstr@var427 ;
351: bool formatstr_scan@var428 ;
352: bool formatstr_secure@var429 ;
353: Container :: Action containerAction@var430 ;
354: Container :: Yield containerYield@var431 ;
355: Function ( )
356: : use@var421 ( false ) ,
357: leakignore@var422 ( false ) ,
358: isconst@var423 ( false ) ,
359: ispure@var424 ( false ) ,
360: useretval@var425 ( UseRetValType :: NONE ) ,
361: ignore@var426 ( false ) ,
362: formatstr@var427 ( false ) ,
363: formatstr_scan@var428 ( false ) ,
364: formatstr_secure@var429 ( false ) ,
365: containerAction@var430 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var431 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var432 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var433 ;
372: bool isUse ( const std :: string & functionName@var434 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var435 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var436 , bool pure@var437 ) const ;
375: bool isFunctionConst ( const Token * ftok@var438 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var439 , int argnr@var440 ) const {
378: const ArgumentChecks * arg@var441 ; arg@var441 =@expr1073745157 getarg (@expr1073745158 ftok@var439 , argnr@var440 ) ;
379: return arg@var441 &&@expr1073745159 arg@var441 .@expr1073745160 notbool@var442 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var443 , int argnr@var444 ) const ;
383: bool isuninitargbad ( const Token * ftok@var445 , int argnr@var446 , int indirect@var447 = 0 , bool * hasIndirect@var448 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var449 , int argnr@var450 ) const {
386: const ArgumentChecks * arg@var451 ; arg@var451 =@expr1073745161 getarg (@expr1073745162 ftok@var449 , argnr@var450 ) ;
387: return arg@var451 &&@expr1073745163 arg@var451 .@expr1073745164 formatstr@var452 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var453 , int argnr@var454 ) const {
391: const ArgumentChecks * arg@var455 ; arg@var455 =@expr1073745165 getarg (@expr1073745166 ftok@var453 , argnr@var454 ) ;
392: return arg@var455 &&@expr1073745167 arg@var455 .@expr1073745168 strz@var456 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var457 , int argnr@var458 , const long long argvalue@var459 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var460 , int argnr@var461 , double argvalue@var462 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var463 , int argnr@var464 ) const {
399: const ArgumentChecks * arg@var465 ; arg@var465 =@expr1073745169 getarg (@expr1073745170 ftok@var463 , argnr@var464 ) ;
400: return arg@var465 ?@expr1073745171 arg@var465 .@expr1073745172 valid@var466 :@expr1073745173 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var467 ;
405: std :: string op1@var468 ;
406: std :: string op2@var469 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745174 isInt (@expr1073745175 op1@var468 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var470 , int argnr@var471 ) const {
413: const ArgumentChecks * arg@var472 ; arg@var472 =@expr1073745176 getarg (@expr1073745177 ftok@var470 , argnr@var471 ) ;
414: return arg@var472 &&@expr1073745178 arg@var472 .@expr3355 iteratorInfo@var473 .@expr1073745180 it@var474 ?@expr1073745181 &@expr1073745182 arg@var472 .@expr3355 iteratorInfo@var473 :@expr1073745184 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var475 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var476 , int argnr@var477 ) const {
420: const ArgumentChecks * arg@var478 ; arg@var478 =@expr1073745185 getarg (@expr1073745186 ftok@var476 , argnr@var477 ) ;
421: return arg@var478 ?@expr1073745187 &@expr1073745188 arg@var478 .@expr1073745189 minsizes@var479 :@expr1073745190 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var480 , int argnr@var481 ) const ;
425:
426: bool markupFile ( const std :: string & path@var482 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var483 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var587 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var484 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var485 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var486 , const std :: string & token@var487 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var488 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var489 ) const ;
443: const std :: string & blockend ( const std :: string & file@var490 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var491 , const std :: string & keyword@var492 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var493 ) const {
448: return mExporters@var590 .@expr1073745191 find (@expr1073745192 prefix@var493 ) !=@expr1073745193 mExporters@var590 .@expr1073745194 end (@expr1073745195 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var494 , const std :: string & token@var495 ) const {
452: const std ::@expr1073745196 map < std ::@expr1073745197 string , ExportedFunctions > ::@expr1073745198 const_iterator it@var496 =@expr1073745199 mExporters@var590 .@expr1073745200 find (@expr1073745201 prefix@var494 ) ;
453: return (@expr1073745202 it@var496 !=@expr1073745203 mExporters@var590 .@expr1073745204 end (@expr1073745205 ) &&@expr1073745206 it@var496 .@expr1073745207 second@var497 .@expr1073745208 isPrefix (@expr1073745209 token@var495 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var498 , const std :: string & token@var499 ) const {
457: const std ::@expr1073745210 map < std ::@expr1073745211 string , ExportedFunctions > ::@expr1073745212 const_iterator it@var500 =@expr1073745213 mExporters@var590 .@expr1073745214 find (@expr1073745215 prefix@var498 ) ;
458: return (@expr1073745216 it@var500 !=@expr1073745217 mExporters@var590 .@expr1073745218 end (@expr1073745219 ) &&@expr1073745220 it@var500 .@expr1073745221 second@var501 .@expr1073745222 isSuffix (@expr1073745223 token@var499 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var502 , const std :: string & importer@var503 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var504 , Container :: Yield yield@var505 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var506 , Container :: Action action@var507 ) const ;
465:
466: bool isreflection ( const std :: string & token@var508 ) const {
467: return mReflection@var592 .@expr1073745224 find (@expr1073745225 token@var508 ) !=@expr1073745226 mReflection@var592 .@expr1073745227 end (@expr1073745228 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var509 ) const {
471: const std ::@expr1073745229 map < std ::@expr1073745230 string , int > ::@expr1073745231 const_iterator it@var510 =@expr1073745232 mReflection@var592 .@expr1073745233 find (@expr1073745234 token@var509 ) ;
472: if (@expr1073745235 it@var510 !=@expr1073745236 mReflection@var592 .@expr1073745237 end (@expr1073745238 ) ) {
473: return it@var510 .@expr1073745239 second@var511 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var512 ;
478:
479: struct SmartPointer {
480: std :: string name@var513 ; name@var513 = "" ;
481: bool unique@var514 ; unique@var514 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var515 ;
485: bool isSmartPointer ( const Token * tok@var516 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var517 ) const ;
487:
488: struct PodType {
489: unsigned int size@var518 ;
490: char sign@var519 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var520 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var521 ) const {
494: const std ::@expr1073745240 unordered_map < std ::@expr1073745241 string , PodType > ::@expr1073745242 const_iterator it@var522 =@expr1073745243 mPodTypes@var593 .@expr1073745244 find (@expr1073745245 name@var521 ) ;
495: return (@expr3422 it@var522 !=@expr1073745247 mPodTypes@var593 .@expr1073745248 end (@expr1073745249 ) ) ?@expr1073745250 &@expr1073745251 (@expr3422 it@var522 .@expr1073745253 second@var523 ) :@expr1073745254 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var534 ( false )
501: , mUnsigned@var535 ( false )
502: , mLong@var536 ( false )
503: , mPointer@var537 ( false )
504: , mPtrPtr@var538 ( false )
505: , mConstPtr@var539 ( false ) { }
506: bool operator== ( const PlatformType & type@var524 ) const {
507: return (@expr1073745255 mSigned@var534 ==@expr1073745256 type@var524 .@expr1073745257 mSigned@var525 &&@expr1073745258
508: mUnsigned@var535 ==@expr1073745259 type@var524 .@expr1073745260 mUnsigned@var526 &&@expr1073745261
509: mLong@var536 ==@expr1073745262 type@var524 .@expr1073745263 mLong@var527 &&@expr1073745264
510: mPointer@var537 ==@expr1073745265 type@var524 .@expr1073745266 mPointer@var528 &&@expr1073745267
511: mPtrPtr@var538 ==@expr1073745268 type@var524 .@expr1073745269 mPtrPtr@var529 &&@expr1073745270
512: mConstPtr@var539 ==@expr1073745271 type@var524 .@expr1073745272 mConstPtr@var530 &&@expr1073745273
513: mType@var533 ==@expr1073745274 type@var524 .@expr1073745275 mType@var531 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var532 ) const {
516: return !@expr1073745276 (@expr1073745277 *@expr1073745278 this@expr1073745279 ==@expr1073745280 type@var532 ) ;
517: }
518: std :: string mType@var533 ;
519: bool mSigned@var534 ;
520: bool mUnsigned@var535 ;
521: bool mLong@var536 ;
522: bool mPointer@var537 ;
523: bool mPtrPtr@var538 ;
524: bool mConstPtr@var539 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var540 ) const {
529: const std ::@expr1073745281 map < std ::@expr1073745282 string , PlatformType > ::@expr1073745283 const_iterator it@var541 =@expr1073745284 mPlatformTypes@var543 .@expr1073745285 find (@expr1073745286 name@var540 ) ;
530: return (@expr3463 it@var541 !=@expr1073745288 mPlatformTypes@var543 .@expr1073745289 end (@expr1073745290 ) ) ?@expr1073745291 &@expr1073745292 (@expr3463 it@var541 .@expr1073745294 second@var542 ) :@expr1073745295 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var543 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var544 , const std :: string & platform@var545 ) const {
536: const std ::@expr1073745296 map < std ::@expr3473 string , Platform > ::@expr1073745298 const_iterator it@var546 =@expr1073745299 mPlatforms@var595 .@expr1073745300 find (@expr1073745301 platform@var545 ) ;
537: if (@expr1073745302 it@var546 !=@expr1073745303 mPlatforms@var595 .@expr1073745304 end (@expr1073745305 ) ) {
538: const PlatformType * const type@var547 ; type@var547 =@expr1073745306 it@var546 .@expr1073745307 second@var548 .@expr1073745308 platform_type (@expr1073745309 name@var544 ) ;
539: if (@expr1073745310 type@var547 ) {
540: return type@var547 ; }
541: }
542:
543: const std ::@expr1073745311 map < std ::@expr3473 string , PlatformType > ::@expr1073745313 const_iterator it2@var549 =@expr1073745314 mPlatformTypes@var594 .@expr1073745315 find (@expr1073745316 name@var544 ) ;
544: return (@expr3493 it2@var549 !=@expr1073745318 mPlatformTypes@var594 .@expr1073745319 end (@expr1073745320 ) ) ?@expr1073745321 &@expr1073745322 (@expr3493 it2@var549 .@expr1073745324 second@var550 ) :@expr1073745325 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var551 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var552 , Library :: Container :: Yield y@var553 , const std :: string & fallback@var554 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var555 , const std :: string & typeName@var556 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var557 , const std :: string & name@var558 , std :: set < std :: string > & unknown_elements@var559 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var560 ) {
565: mPrefixes@var564 .@expr1073745326 insert (@expr1073745327 prefix@var560 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var561 ) {
568: mSuffixes@var565 .@expr1073745328 insert (@expr1073745329 suffix@var561 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var562 ) const {
571: return (@expr1073745330 mPrefixes@var564 .@expr1073745331 find (@expr1073745332 prefix@var562 ) !=@expr1073745333 mPrefixes@var564 .@expr1073745334 end (@expr1073745335 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var563 ) const {
574: return (@expr1073745336 mSuffixes@var565 .@expr1073745337 find (@expr1073745338 suffix@var563 ) !=@expr1073745339 mSuffixes@var565 .@expr1073745340 end (@expr1073745341 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var564 ;
579: std :: set < std :: string > mSuffixes@var565 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var573 ( 0 ) { }
584:
585: void setStart ( const char * s@var566 ) {
586: mStart@var571 =@expr1073745342 s@var566 ;
587: }
588: void setEnd ( const char * e@var567 ) {
589: mEnd@var572 =@expr1073745343 e@var567 ;
590: }
591: void setOffset ( const int o@var568 ) {
592: mOffset@var573 =@expr1073745344 o@var568 ;
593: }
594: void addBlock ( const char * blockName@var569 ) {
595: mBlocks@var574 .@expr1073745345 insert (@expr1073745346 blockName@var569 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var571 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var572 ;
602: }
603: int offset ( ) const {
604: return mOffset@var573 ;
605: }
606: bool isBlock ( const std :: string & blockName@var570 ) const {
607: return mBlocks@var574 .@expr1073745347 find (@expr1073745348 blockName@var570 ) !=@expr1073745349 mBlocks@var574 .@expr1073745350 end (@expr1073745351 ) ;
608: }
609:
610: private:
611: std :: string mStart@var571 ;
612: std :: string mEnd@var572 ;
613: int mOffset@var573 ;
614: std :: set < std :: string > mBlocks@var574 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var575 ;
618: std :: set < std :: string > mFiles@var576 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var577 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var578 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var579 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var580 ;
623: std :: map < std :: string , std :: string > mReturnValue@var581 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var582 ;
625: std :: map < std :: string , int > mReturnValueContainer@var583 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var584 ;
627: std :: map < std :: string , bool > mReportErrors@var585 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var586 ;
629: std :: set < std :: string > mMarkupExtensions@var587 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var588 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var589 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var590 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var591 ;
634: std :: map < std :: string , int > mReflection@var592 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var593 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var594 ;
637: std :: map < std :: string , Platform > mPlatforms@var595 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var596 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var597 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var598 , int argnr@var599 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var600 , bool * error@var601 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var602 , const std :: string & name@var603 ) {
646: const std ::@expr1073745352 map < std ::@expr1073745353 string , AllocFunc > ::@expr1073745354 const_iterator it@var604 =@expr1073745355 data@var602 .@expr1073745356 find (@expr1073745357 name@var603 ) ;
647: return (@expr1073745358 it@var604 ==@expr1073745359 data@var602 .@expr1073745360 end (@expr1073745361 ) ) ?@expr1073745362 nullptr :@expr1073745363 &@expr1073745364 it@var604 .@expr1073745365 second@var605 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var606 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var607 ,
654: const Settings * settings@var608 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var609 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var610 ) const {
54: x@var610 ++@expr1073745366 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var611 ) const {
60: x@var611 --@expr1073745367 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var612 , const U & y@var613 ) const {
67: return x@var612 <@expr1073745368 y@var613 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var614 , const U & y@var615 ) const {
74: return std ::@expr1073745369 abs (@expr1073745370 x@var614 -@expr1073745371 y@var615 ) ==@expr1073745372 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var616 , T x@var617 , U y@var618 ) const {
81: result@var616 =@expr1073745373 !@expr1073745374 (@expr1073745375 x@var617 >@expr1073745376 y@var618 ||@expr1073745377 x@var617 <@expr1073745378 y@var618 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var619 = 0 , Bound b@var620 = Bound :: Point )
91: : valueType@var660 ( ValueType :: INT ) ,
92: bound@var661 ( b@var620 ) ,
93: intvalue@var662 ( val@var619 ) ,
94: tokvalue@var663 ( nullptr ) ,
95: floatValue@var664 ( 0.0 ) ,
96: moveKind@var665 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var666 ( val@var619 ) ,
98: condition@var667 ( nullptr ) ,
99: varId@var669 ( 0U ) ,
100: safe@var670 ( false ) ,
101: conditional@var671 ( false ) ,
102: macro@var672 ( false ) ,
103: defaultArg@var673 ( false ) ,
104: indirect@var674 ( 0 ) ,
105: path@var675 ( 0 ) ,
106: wideintvalue@var676 ( val@var619 ) ,
107: subexpressions@var677 ( ) ,
108: capturetok@var678 ( nullptr ) ,
109: lifetimeKind@var679 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var680 ( LifetimeScope :: Local ) ,
111: valueKind@var685 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var621 , long long val@var622 , Bound b@var623 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var624 ) const {
118: if (@expr1073745379 valueType@var660 !=@expr1073745380 rhs@var624 .@expr1073745381 valueType@var625 ) {
119: return false ; }
120: switch (@expr1073745382 valueType@var660 ) {
121: case ValueType ::@expr1073745383 INT :@expr3560
122: case ValueType ::@expr1073745385 CONTAINER_SIZE :@expr3560
123: case ValueType ::@expr1073745387 BUFFER_SIZE :@expr3560
124: case ValueType ::@expr1073745389 ITERATOR_START :@expr3560
125: case ValueType ::@expr1073745391 ITERATOR_END :@expr3560 ;
126: if (@expr3569 intvalue@var662 !=@expr3570 rhs@var624 .@expr3571 intvalue@var626 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745396 TOK :@expr3560 ;
130: if (@expr3574 tokvalue@var663 !=@expr3575 rhs@var624 .@expr3576 tokvalue@var627 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745401 FLOAT :@expr3560 ;
134:
135: if (@expr1073745403 floatValue@var664 >@expr1073745404 rhs@var624 .@expr3581 floatValue@var628 ||@expr1073745406 floatValue@var664 <@expr1073745407 rhs@var624 .@expr3581 floatValue@var628 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745409 MOVED :@expr3560 ;
139: if (@expr1073745411 moveKind@var665 !=@expr1073745412 rhs@var624 .@expr1073745413 moveKind@var629 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745414 UNINIT :@expr3560 ;
143: break ;
144: case ValueType ::@expr1073745416 LIFETIME :@expr3560 ;
145: if (@expr3574 tokvalue@var663 !=@expr3575 rhs@var624 .@expr3576 tokvalue@var627 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745421 SYMBOLIC :@expr3560 ;
149: if (@expr1073745423 !@expr1073745424 sameToken (@expr1073745425 tokvalue@var663 , rhs@var624 .@expr3576 tokvalue@var627 ) ) {
150: return false ; }
151: if (@expr3569 intvalue@var662 !=@expr3570 rhs@var624 .@expr3571 intvalue@var626 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var630 , F f@var631 ) {
160: switch (@expr1073745430 self@var630 .@expr1073745431 valueType@var632 ) {
161: case ValueType ::@expr1073745432 INT :@expr3609
162: case ValueType ::@expr1073745434 SYMBOLIC :@expr3609
163: case ValueType ::@expr1073745436 BUFFER_SIZE :@expr3609
164: case ValueType ::@expr1073745438 CONTAINER_SIZE :@expr3609
165: case ValueType ::@expr1073745440 ITERATOR_START :@expr3609
166: case ValueType ::@expr1073745442 ITERATOR_END :@expr3609 ; {
167: f@var631 (@expr1073745444 self@var630 .@expr1073745445 intvalue@var633 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745446 FLOAT :@expr3609 ; {
171: f@var631 (@expr1073745448 self@var630 .@expr1073745449 floatValue@var634 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745450 UNINIT :@expr3609
175: case ValueType ::@expr1073745452 TOK :@expr3609
176: case ValueType ::@expr1073745454 LIFETIME :@expr3609
177: case ValueType ::@expr1073745456 MOVED :@expr3609 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var635 , Compare compare@var636 , T x@var637 , U y@var638 ) const {
186: result@var635 =@expr1073745458 compare@var636 (@expr1073745459 x@var637 , y@var638 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var639 , const Value & rhs@var640 , Compare compare@var641 , T x@var642 ) const {
191: visitValue (@expr1073745461 rhs@var640 ,
192: std ::@expr1073745462 bind (@expr1073745463 innerVisitor {@expr1073745464 } , std ::@expr1073745465 ref (@expr1073745466 result@var639 ) , std ::@expr1073745467 move (@expr1073745468 compare@var641 ) , x@var642 , std ::@expr1073745469 placeholders ::@expr1073745470 _1@expr1073745460 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var643 , Compare compare@var644 ) const {
198: assert (@expr1073745472 (@expr1073745473 !@expr1073745474 this@expr3651 .@expr1073745476 isSymbolicValue (@expr1073745477 ) &&@expr1073745478 !@expr1073745479 rhs@var643 .@expr1073745480 isSymbolicValue (@expr1073745481 ) ) ||@expr1073745482
199: (@expr1073745483 this@expr3651 .@expr1073745484 valueType@var660 ==@expr1073745485 rhs@var643 .@expr1073745486 valueType@var645 &&@expr1073745487 sameToken (@expr1073745488 this@expr3651 .@expr1073745489 tokvalue@var663 , rhs@var643 .@expr1073745490 tokvalue@var646 ) ) ) ;
200: bool result@var647 ; result@var647 =@expr1073745491 false ;
201: visitValue (@expr1073745492
202: *@expr1073745493 this@expr3651 ,
203: std ::@expr1073745494 bind (@expr1073745495 compareVisitor {@expr1073745496 } , std ::@expr3673 ref (@expr1073745498 result@var647 ) , std ::@expr3673 ref (@expr1073745500 rhs@var643 ) , std ::@expr1073745501 move (@expr1073745502 compare@var644 ) , std ::@expr1073745503 placeholders ::@expr1073745504 _1@expr1073745471 ) ) ;
204: return result@var647 ;
205: }
206:
207: bool operator== ( const Value & rhs@var648 ) const {
208: if (@expr1073745505 !@expr1073745506 equalValue (@expr1073745507 rhs@var648 ) ) {
209: return false ; }
210:
211: return varvalue@var666 ==@expr1073745508 rhs@var648 .@expr1073745509 varvalue@var649 &&@expr1073745510
212: condition@var667 ==@expr1073745511 rhs@var648 .@expr1073745512 condition@var650 &&@expr1073745513
213: varId@var669 ==@expr1073745514 rhs@var648 .@expr1073745515 varId@var651 &&@expr1073745516
214: conditional@var671 ==@expr1073745517 rhs@var648 .@expr1073745518 conditional@var652 &&@expr1073745519
215: defaultArg@var673 ==@expr1073745520 rhs@var648 .@expr1073745521 defaultArg@var653 &&@expr1073745522
216: indirect@var674 ==@expr1073745523 rhs@var648 .@expr1073745524 indirect@var654 &&@expr1073745525
217: valueKind@var685 ==@expr1073745526 rhs@var648 .@expr1073745527 valueKind@var655 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var656 ) const {
221: return !@expr1073745528 (@expr1073745529 *@expr1073745530 this@expr1073745531 ==@expr1073745532 rhs@var656 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var657 ) const {
226: bool result@var658 ; result@var658 =@expr1073745534 false ;
227: visitValue (@expr1073745535 *@expr1073745536 this@expr1073745537 , std ::@expr1073745538 bind (@expr1073745539 equalVisitor {@expr1073745540 } , std ::@expr1073745541 ref (@expr1073745542 result@var658 ) , x@var657 , std ::@expr1073745543 placeholders ::@expr1073745544 _1@expr1073745533 ) ) ;
228: return result@var658 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745545 bound@var661 ==@expr1073745546 Bound ::@expr1073745547 Lower ) {
233: visitValue (@expr1073745548 *@expr3725 this@expr3726 , increment {@expr1073745551 } ) ; }
234: else { if (@expr1073745552 bound@var661 ==@expr1073745553 Bound ::@expr1073745554 Upper ) {
235: visitValue (@expr1073745555 *@expr3725 this@expr3726 , decrement {@expr1073745557 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745558 bound@var661 ==@expr1073745559 Bound ::@expr3736 Lower ) {
240: bound@var661 =@expr1073745561 Bound ::@expr3738 Upper ; }
241: else { if (@expr1073745563 bound@var661 ==@expr1073745564 Bound ::@expr3738 Upper ) {
242: bound@var661 =@expr1073745566 Bound ::@expr3736 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745568 ) ;
247: decreaseRange (@expr1073745569 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var659 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var660 ;
267: bool isIntValue ( ) const {
268: return valueType@var660 ==@expr1073745570 ValueType ::@expr1073745571 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var660 ==@expr1073745572 ValueType ::@expr1073745573 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var660 ==@expr1073745574 ValueType ::@expr1073745575 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var660 ==@expr1073745576 ValueType ::@expr1073745577 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var660 ==@expr1073745578 ValueType ::@expr1073745579 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var660 ==@expr1073745580 ValueType ::@expr1073745581 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var660 ==@expr1073745582 ValueType ::@expr1073745583 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var660 ==@expr1073745584 ValueType ::@expr1073745585 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var660 ==@expr1073745586 ValueType ::@expr1073745587 ITERATOR_START ||@expr1073745588 valueType@var660 ==@expr1073745589 ValueType ::@expr1073745590 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var660 ==@expr1073745591 ValueType ::@expr1073745592 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var660 ==@expr1073745593 ValueType ::@expr1073745594 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var660 ==@expr1073745595 ValueType ::@expr1073745596 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var660 ==@expr1073745598 ValueType ::@expr1073745599 LIFETIME &&@expr1073745600 lifetimeScope@var680 ==@expr1073745601 LifetimeScope ::@expr1073745602 Local@expr1073745597 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var660 ==@expr1073745603 ValueType ::@expr1073745604 LIFETIME &&@expr1073745605 lifetimeScope@var680 ==@expr1073745606 LifetimeScope ::@expr1073745607 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var660 ==@expr1073745608 ValueType ::@expr1073745609 LIFETIME &&@expr1073745610 lifetimeScope@var680 ==@expr1073745611 LifetimeScope ::@expr1073745612 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745613 ) ||@expr1073745614 isUninitValue (@expr1073745615 ) ||@expr1073745616 isLifetimeValue (@expr1073745617 ) ;
318: }
319:
320:
321: Bound bound@var661 ;
322:
323:
324: long long intvalue@var662 ;
325:
326:
327: const Token * tokvalue@var663 ;
328:
329:
330: double floatValue@var664 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var665 ;
334:
335:
336: long long varvalue@var666 ;
337:
338:
339: const Token * condition@var667 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var668 ;
342:
343:
344: int varId@var669 ;
345:
346:
347: bool safe@var670 ;
348:
349:
350: bool conditional@var671 ;
351:
352:
353: bool macro@var672 ;
354:
355:
356: bool defaultArg@var673 ;
357:
358: int indirect@var674 ;
359:
360:
361: long long path@var675 ;
362:
363:
364: long long wideintvalue@var676 ;
365:
366: std :: vector < std :: string > subexpressions@var677 ;
367:
368:
369: const Token * capturetok@var678 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var679 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var680 ;
385:
386: static const char * toString ( MoveKind moveKind@var681 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var682 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var683 ) ;
389: static const char * toString ( Bound bound@var684 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var685 ;
402:
403: void setKnown ( ) {
404: valueKind@var685 =@expr1073745618 ValueKind ::@expr1073745619 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var685 ==@expr1073745620 ValueKind ::@expr1073745621 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var685 =@expr1073745623 ValueKind ::@expr1073745624 Possible@expr1073745622 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var685 ==@expr1073745626 ValueKind ::@expr1073745627 Possible@expr1073745625 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var685 ==@expr1073745628 ValueKind ::@expr1073745629 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var685 =@expr1073745630 ValueKind ::@expr1073745631 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var686 = true ) {
428: if (@expr1073745632 inconclusive@var686 ) {
429: valueKind@var685 =@expr1073745633 ValueKind ::@expr1073745634 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var685 ==@expr1073745635 ValueKind ::@expr1073745636 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745638 isKnown (@expr1073745639 ) ) {
438: valueKind@var685 =@expr1073745640 ValueKind ::@expr1073745641 Possible@expr1073745637 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745642 condition@var667 &&@expr1073745643 !@expr1073745644 defaultArg@var673 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var687 , const Token * tok2@var688 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var689 , const Settings * settings@var690 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var691 , SymbolDatabase * symboldatabase@var692 , ErrorLogger * errorLogger@var693 , const Settings * settings@var694 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var695 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var696 , const Settings * settings@var697 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var698 ,
459: const Settings * settings@var699 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var700 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var701 , const Token * indexTok@var702 , bool possible@var703 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var704 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var705 , const Settings * settings@var706 = nullptr , int depth@var707 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var708 ;
471: bool addressOf@var709 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var710 ;
473: bool inconclusive@var711 ;
474:
475: LifetimeToken ( ) : token@var708 ( nullptr ) , addressOf@var709 ( false ) , errorPath@var710 ( ) , inconclusive@var711 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var712 , ValueFlow :: Value :: ErrorPath errorPath@var713 )
478: : token@var708 ( token@var712 ) , addressOf@var709 ( false ) , errorPath@var710 ( std :: move ( errorPath@var713 ) ) , inconclusive@var711 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var714 , bool addressOf@var715 , ValueFlow :: Value :: ErrorPath errorPath@var716 )
482: : token@var708 ( token@var714 ) , addressOf@var709 ( addressOf@var715 ) , errorPath@var710 ( std :: move ( errorPath@var716 ) ) , inconclusive@var711 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var717 , bool b@var718 ) {
486: for (@expr1073745645 LifetimeToken &@expr1073745646 x@var719 :@expr1073745647 v@var717 ) {
487: x@var719 .@expr1073745648 addressOf@var720 =@expr1073745649 b@var718 ; }
488: return v@var717 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var721 , bool b@var722 ) {
492: for (@expr1073745650 LifetimeToken &@expr1073745651 x@var723 :@expr1073745652 v@var721 ) {
493: x@var723 .@expr1073745653 inconclusive@var724 =@expr1073745654 b@var722 ; }
494: return v@var721 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var725 , ValueFlow :: Value & true_value@var726 , ValueFlow :: Value & false_value@var727 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var728 ) ;
499: const Token * parseCompareInt ( const Token * tok@var729 , ValueFlow :: Value & true_value@var730 , ValueFlow :: Value & false_value@var731 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var732 , long long val@var733 , const Token * varTok@var734 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var735 , const Token * varTok@var736 , long long val@var737 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var738 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var739 ,
508: ValueFlow :: Value & value@var740 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var741 ,
511: bool escape@var742 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var743 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var744 , const Token * lifetime@var745 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var746 , ValueFlow :: Value :: ErrorPath & errorPath@var747 , bool * addressOf@var748 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var749 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var750 , const Settings * settings@var751 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var752 , const ValueFlow :: Value * val@var753 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var754 , const ValueFlow :: Value * val@var755 , ValueFlow :: Value :: ErrorPath & errorPath@var756 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var757 , bool inconclusive@var758 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var759 ,
529: bool inconclusive@var760 = false ,
530: long long path@var761 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var762 , const Scope * defaultScope@var763 = nullptr , bool smallest@var764 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var765 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var766 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var767 ;
69: std :: string mScope@var768 ;
70: std :: string mName@var769 ;
71: std :: string mFullName@var770 ;
72: const Token * mNameToken@var771 ;
73: const Token * mParamEnd@var772 ;
74: unsigned int mFlags@var773 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var774 ) {
90: setFlag (@expr1073745655 fIsClass , state@var774 ) ;
91: }
92: void isFunction ( bool state@var775 ) {
93: setFlag (@expr1073745656 fIsFunction , state@var775 ) ;
94: }
95: void isVariable ( bool state@var776 ) {
96: setFlag (@expr1073745657 fIsVariable , state@var776 ) ;
97: }
98: void isAlias ( bool state@var777 ) {
99: setFlag (@expr1073745658 fIsAlias , state@var777 ) ;
100: }
101: void isSpecialization ( bool state@var778 ) {
102: setFlag (@expr1073745659 fIsSpecialization , state@var778 ) ;
103: }
104: void isPartialSpecialization ( bool state@var779 ) {
105: setFlag (@expr1073745660 fIsPartialSpecialization , state@var779 ) ;
106: }
107: void isForwardDeclaration ( bool state@var780 ) {
108: setFlag (@expr1073745661 fIsForwardDeclaration , state@var780 ) ;
109: }
110: void isVariadic ( bool state@var781 ) {
111: setFlag (@expr1073745662 fIsVariadic , state@var781 ) ;
112: }
113: void isFriend ( bool state@var782 ) {
114: setFlag (@expr1073745663 fIsFriend , state@var782 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var783 ) const {
123: return (@expr3840 (@expr3840 mFlags@var773 &@expr1073745666 flag@var783 ) !=@expr1073745667 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var784 , bool state@var785 ) {
132: mFlags@var773 =@expr1073745668 state@var785 ?@expr1073745669 mFlags@var773 |@expr1073745670 flag@var784 :@expr1073745671 mFlags@var773 &@expr1073745672 ~@expr1073745673 flag@var784 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var786 , const std :: string & scope@var787 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var788 , const std :: string & scope@var789 , const Token * nameToken@var790 , const Token * paramEnd@var791 ) ;
150: TokenAndName ( const TokenAndName & other@var792 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var793 ) const {
154: return mToken@var767 ==@expr1073745674 rhs@var793 .@expr1073745675 mToken@var794 &&@expr1073745676 mScope@var768 ==@expr1073745677 rhs@var793 .@expr1073745678 mScope@var795 &&@expr1073745679 mName@var769 ==@expr1073745680 rhs@var793 .@expr1073745681 mName@var796 &&@expr1073745682 mFullName@var770 ==@expr1073745683 rhs@var793 .@expr1073745684 mFullName@var797 &&@expr1073745685
155: mNameToken@var771 ==@expr1073745686 rhs@var793 .@expr1073745687 mNameToken@var798 &&@expr1073745688 mParamEnd@var772 ==@expr1073745689 rhs@var793 .@expr1073745690 mParamEnd@var799 &&@expr1073745691 mFlags@var773 ==@expr1073745692 rhs@var793 .@expr1073745693 mFlags@var800 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var767 ;
160: }
161: void token ( Token * token@var801 ) {
162: mToken@var767 =@expr1073745694 token@var801 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var768 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var769 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var770 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var771 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var772 ;
178: }
179: void paramEnd ( const Token * end@var802 ) {
180: mParamEnd@var772 =@expr1073745695 end@var802 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745696 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745697 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745698 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745699 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745700 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745701 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745702 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745703 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745704 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var803 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var804 ) const {
243:
244:
245: return (@expr3881 (@expr3881 mFlags@var773 &@expr1073745707 fFamilyMask ) &@expr1073745708 (@expr3881 decl@var804 .@expr1073745710 mFlags@var805 &@expr1073745711 fFamilyMask ) ) !=@expr1073745712 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var806 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var807 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var808 , const unsigned long numberOfArguments@var809 , bool variadic@var810 , const char patternAfter@var811 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var812 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var813 , int & namepos@var814 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var815 , int & namepos@var816 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var817 , int & namepos@var818 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var819 ,
306: bool & codeWithTemplates@var820 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var821 , bool isTemplate@var822 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var823 = nullptr , Token * backToken@var824 = nullptr , bool isTemplate@var825 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var826 , Token * end@var827 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var828 , const std :: string & scope@var829 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var830 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var831 ,
393: const std :: list < const Token * > & specializations@var832 ,
394: const std :: time_t maxtime@var833 ,
395: std :: set < std :: string > & expandedtemplates@var834 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var835 , const Token * tok@var836 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var837 , const Token * tok@var838 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var839 ,
422: const TokenAndName & templateInstantiation@var840 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var841 ,
424: const std :: string & newName@var842 ,
425: bool copy@var843 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var844 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var845 ,
435: const std :: string & newName@var846 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var847 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var848 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var849 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var850 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var851 ,
458: const Token * templateInstantiationNameToken@var852 ,
459: const std :: list < const Token * > & specializations@var853 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var854 , const Token * end@var855 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var856 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var857 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var858 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var859 ,
487: const std :: string & indent@var860 = "    " ) const ;
488: void printOut ( const std :: string & text@var861 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var862 ;
491: TokenList & mTokenList@var863 ;
492: const Settings * mSettings@var864 ;
493: ErrorLogger * mErrorLogger@var865 ;
494: bool mChanged@var866 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var867 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var868 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var869 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var870 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var871 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var872 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var873 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var874 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var875 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var876 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var877 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var878 ;
57: Token * back@var879 ;
58: const TokenList * list@var880 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var881 , const Token * bodyEnd_@var882 , const std :: set < std :: string > & usingNamespaces_@var883 = std :: set < std :: string > ( ) ) : name@var884 ( name_@var881 ) , bodyEnd@var885 ( bodyEnd_@var882 ) , usingNamespaces@var886 ( usingNamespaces_@var883 ) { }
63: std :: string name@var884 ;
64: const Token * const bodyEnd@var885 ;
65: std :: set < std :: string > usingNamespaces@var886 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var887 ;
70: int mFileIndex@var888 ;
71: int mLineNumber@var889 ;
72: int mColumn@var890 ;
73: int mExprId@var891 ;
74:
75:
76: Token * mAstOperand1@var892 ;
77: Token * mAstOperand2@var893 ;
78: Token * mAstParent@var894 ;
79:
80:
81: const Scope * mScope@var895 ;
82: union {
83: const Function * mFunction@var896 ;
84: const Variable * mVariable@var897 ;
85: const :: Type * mType@var898 ;
86: const Enumerator * mEnumerator@var899 ;
87: } ;
88:
|
92:
93: int mProgressValue@var900 ;
94:
|
97:
98: int mIndex@var901 ;
99:
100:
101: std :: string * mOriginalName@var902 ;
102:
103:
104: ValueType * mValueType@var903 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var904 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var905 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var906 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var907 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var908 ;
119: long long value@var909 ;
120: struct CppcheckAttributes * next@var910 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var911 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var912 ;
126:
127:
128: unsigned char mBits@var913 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var914 , long long value@var915 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var916 , long long * value@var917 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var887 ( 0 )
135: , mFileIndex@var888 ( 0 )
136: , mLineNumber@var889 ( 0 )
137: , mColumn@var890 ( 0 )
138: , mExprId@var891 ( 0 )
139: , mAstOperand1@var892 ( nullptr )
140: , mAstOperand2@var893 ( nullptr )
141: , mAstParent@var894 ( nullptr )
142: , mScope@var895 ( nullptr )
143: , mFunction@var896 ( nullptr )
144: , mProgressValue@var900 ( 0 )
145: , mIndex@var901 ( 0 )
146: , mOriginalName@var902 ( nullptr )
147: , mValueType@var903 ( nullptr )
148: , mValues@var904 ( nullptr )
149: , mTemplateSimplifierPointers@var906 ( nullptr )
150: , mScopeInfo@var907 ( nullptr )
151: , mCppcheckAttributes@var911 ( nullptr )
152: , mCpp11init@var912 ( Cpp11init :: UNKNOWN )
153: , mBits@var913 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var918 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var919 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var920 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var921 ) {
199: mStr@var1133 =@expr1073745713 s@var921 ;
200: mImpl@var1139 .@expr1073745714 mVarId@var1170 =@expr1073745715 0 ;
201:
202: update_property_info (@expr1073745716 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var922 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1133 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var923 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var924 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var925 ) const ;
236: Token * tokAt ( int index@var926 ) {
237: return const_cast < Token *@expr3893 > (@expr1073745718 const_cast < const Token *@expr3893 > (@expr1073745720 this@expr1073745721 ) .@expr1073745722 tokAt (@expr1073745723 index@var926 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var927 ) const ;
245: Token * linkAt ( int index@var928 ) {
246: return const_cast < Token *@expr3900 > (@expr1073745725 const_cast < const Token *@expr3900 > (@expr1073745727 this@expr1073745728 ) .@expr1073745729 linkAt (@expr1073745730 index@var928 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var929 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var930 , const char ( & pattern@var931 ) [ count ] ) {
276: return simpleMatch (@expr1073745732 tok@var930 , pattern@var931 , count@expr1073745731 -@expr1073745733 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var932 , const char pattern@var933 [ ] , unsigned long pattern_len@var934 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var935 , const char pattern@var936 [ ] , int varid@var937 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var938 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var939 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var940 , const Settings * const settings@var941 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var942 , long long index@var943 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1139 .@expr1073745734 mValueType@var1171 ;
366: }
367: void setValueType ( ValueType * vt@var944 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var945 ; top@var945 =@expr1073745735 this@expr1073745736 ;
371: while (@expr1073745737 top@var945 &&@expr1073745738 !@expr1073745739 Token ::@expr1073745740 Match (@expr1073745741 top@var945 .@expr3918 astParent (@expr3919 ) , ",|(" ) ) {
372: top@var945 =@expr1073745744 top@var945 .@expr3918 astParent (@expr3919 ) ; }
373: return top@var945 ?@expr1073745747 top@var945 .@expr1073745748 mImpl@var946 .@expr1073745749 mValueType@var947 :@expr1073745750 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1137 ;
378: }
379: void tokType ( Token :: Type t@var948 ) {
380: mTokType@var1137 =@expr1073745751 t@var948 ;
381:
382: const bool memoizedIsName@var949 =@expr1073745752 mTokType@var1137 ==@expr1073745753 eName ||@expr1073745754 mTokType@var1137 ==@expr1073745755 eType ||@expr1073745756 mTokType@var1137 ==@expr1073745757 eVariable ||@expr1073745758
383: mTokType@var1137 ==@expr1073745759 eFunction ||@expr1073745760 mTokType@var1137 ==@expr1073745761 eKeyword ||@expr1073745762 mTokType@var1137 ==@expr3939 eBoolean ||@expr1073745764
384: mTokType@var1137 ==@expr3941 eEnumerator ;
385: setFlag (@expr1073745766 fIsName , memoizedIsName@var949 ) ;
386:
387: const bool memoizedIsLiteral@var950 =@expr1073745767 mTokType@var1137 ==@expr1073745768 eNumber ||@expr1073745769 mTokType@var1137 ==@expr1073745770 eString ||@expr1073745771 mTokType@var1137 ==@expr1073745772 eChar ||@expr1073745773
388: mTokType@var1137 ==@expr3939 eBoolean ||@expr1073745775 mTokType@var1137 ==@expr1073745776 eLiteral ||@expr1073745777 mTokType@var1137 ==@expr3941 eEnumerator ;
389: setFlag (@expr1073745779 fIsLiteral , memoizedIsLiteral@var950 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1137 ==@expr1073745780 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745781 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1138 ==@expr1073745782 fIsName &&@expr1073745783 mTokType@var1137 ==@expr1073745784 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745785 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1137 ==@expr1073745786 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1137 ==@expr1073745787 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745788 isConstOp (@expr1073745789 ) ||@expr1073745790
412: isAssignmentOp (@expr1073745791 ) ||@expr1073745792
413: mTokType@var1137 ==@expr1073745793 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745794 isArithmeticalOp (@expr1073745795 ) ||@expr1073745796
417: mTokType@var1137 ==@expr1073745797 eLogicalOp ||@expr1073745798
418: mTokType@var1137 ==@expr1073745799 eComparisonOp ||@expr1073745800
419: mTokType@var1137 ==@expr1073745801 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745802 ) ||@expr1073745803
423: mTokType@var1137 ==@expr1073745804 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1137 ==@expr1073745805 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1137 ==@expr1073745806 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1137 ==@expr1073745807 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1137 ==@expr1073745808 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1137 ==@expr1073745809 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745810 ) !=@expr1073745811 nullptr &&@expr1073745812 astOperand2 (@expr1073745813 ) !=@expr1073745814 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var951 ) const {
444: return s@var951 ==@expr1073745815 mStr@var1133 &&@expr1073745816 astOperand1 (@expr1073745817 ) !=@expr1073745818 nullptr &&@expr1073745819 astOperand2 (@expr1073745820 ) ==@expr1073745821 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1138 ;
450: }
451: void flags ( const unsigned int flags_@var952 ) {
452: mFlags@var1138 =@expr1073745822 flags_@var952 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745823 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var953 ) {
458: setFlag (@expr1073745824 fIsUnsigned , sign@var953 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745825 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var954 ) {
464: setFlag (@expr1073745826 fIsSigned , sign@var954 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745827 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var955 ) {
470: setFlag (@expr1073745828 fIsPointerCompare , b@var955 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745829 fIsLong ) ;
474: }
475: void isLong ( bool size@var956 ) {
476: setFlag (@expr1073745830 fIsLong , size@var956 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745831 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var957 ) {
482: setFlag (@expr1073745832 fIsStandardType , b@var957 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745833 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var958 ) {
488: setFlag (@expr1073745834 fIsExpandedMacro , m@var958 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745835 fIsCast ) ;
492: }
493: void isCast ( bool c@var959 ) {
494: setFlag (@expr1073745836 fIsCast , c@var959 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745837 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var960 ) {
500: setFlag (@expr1073745838 fIsAttributeConstructor , ac@var960 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745839 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var961 ) {
506: setFlag (@expr1073745840 fIsAttributeDestructor , value@var961 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745841 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var962 ) {
512: setFlag (@expr1073745842 fIsAttributeUnused , unused@var962 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745843 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var963 ) {
518: setFlag (@expr1073745844 fIsAttributeUsed , unused@var963 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745845 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var964 ) {
524: setFlag (@expr1073745846 fIsAttributePure , value@var964 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745847 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var965 ) {
530: setFlag (@expr1073745848 fIsAttributeConst , value@var965 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745849 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var966 ) {
536: setFlag (@expr1073745850 fIsAttributeNoreturn , value@var966 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745851 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var967 ) {
542: setFlag (@expr1073745852 fIsAttributeNothrow , value@var967 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745853 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var968 ) {
548: setFlag (@expr1073745854 fIsAttributePacked , value@var968 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745855 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var969 ) {
554: setFlag (@expr1073745856 fIsAttributeNodiscard , value@var969 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745857 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var970 ) {
560: setFlag (@expr1073745858 fIsAttributeMaybeUnused , value@var970 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var971 , long long value@var972 ) {
563: mImpl@var1139 .@expr1073745859 setCppcheckAttribute (@expr1073745860 type@var971 , value@var972 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var973 , long long * value@var974 ) const {
566: return mImpl@var1139 .@expr1073745861 getCppcheckAttribute (@expr1073745862 type@var973 , value@var974 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745863 mImpl@var1139 .@expr1073745864 mCppcheckAttributes@var1172 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745865 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745866 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var975 ) {
578: setFlag (@expr1073745867 fIsOperatorKeyword , value@var975 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745868 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var976 ) {
584: setFlag (@expr1073745869 fIsComplex , value@var976 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745870 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var977 ) {
590: setFlag (@expr1073745871 fIsEnumType , value@var977 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745872 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var978 ) {
596: setFlag (@expr1073745873 fAtAddress , b@var978 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745874 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var979 ) {
602: setFlag (@expr1073745875 fIncompleteVar , b@var979 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745876 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var980 ) {
609: setFlag (@expr1073745877 fIsIncompleteConstant , b@var980 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745878 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var981 ) {
616: setFlag (@expr1073745879 fConstexpr , b@var981 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745880 fExternC ) ;
621: }
622: void isExternC ( bool b@var982 ) {
623: setFlag (@expr1073745881 fExternC , b@var982 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745882 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var983 ) {
630: setFlag (@expr1073745883 fIsSplitVarDeclComma , b@var983 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745884 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var984 ) {
637: setFlag (@expr1073745885 fIsSplitVarDeclEq , b@var984 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745886 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var985 ) {
644: setFlag (@expr1073745887 fIsImplicitInt , b@var985 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745888 fIsInline ) ;
649: }
650: void isInline ( bool b@var986 ) {
651: setFlag (@expr1073745889 fIsInline , b@var986 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745890 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var987 ) {
658: setFlag (@expr1073745891 fIsRemovedVoidParameter , b@var987 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745892 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var988 ) {
665: setFlag (@expr1073745893 fIsTemplate , b@var988 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745894 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var989 ) {
672: setFlag (@expr1073745895 fIsSimplifedScope , b@var989 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1139 .@expr1073745896 mBits@var1173 >@expr1073745897 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1139 .@expr1073745898 mBits@var1173 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1139 .@expr1073745899 mTemplateSimplifierPointers@var1174 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var990 ) {
685: if (@expr1073745900 !@expr1073745901 mImpl@var1139 .@expr4078 mTemplateSimplifierPointers@var1174 ) {
686: mImpl@var1139 .@expr4078 mTemplateSimplifierPointers@var1174 =@expr1073745904 new std ::@expr1073745905 set < TemplateSimplifier ::@expr1073745906 TokenAndName *@expr1073745907 > ; }
687: mImpl@var1139 .@expr4078 mTemplateSimplifierPointers@var1174 .@expr1073745909 insert (@expr1073745910 tokenAndName@var990 ) ;
688: }
689: void setBits ( const unsigned char b@var991 ) {
690: mImpl@var1139 .@expr1073745911 mBits@var1173 =@expr1073745912 b@var991 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4089 (@expr4089 (@expr4089 mTokType@var1137 ==@expr1073745916 eString ) &&@expr1073745917 isPrefixStringCharLiteral (@expr1073745918 mStr@var1133 , '"' , "u8" ) ) ||@expr1073745919
695: (@expr4089 (@expr4089 mTokType@var1137 ==@expr1073745922 eChar ) &&@expr1073745923 isPrefixStringCharLiteral (@expr1073745924 mStr@var1133 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4101 (@expr4101 (@expr4101 mTokType@var1137 ==@expr1073745928 eString ) &&@expr1073745929 isPrefixStringCharLiteral (@expr1073745930 mStr@var1133 , '"' , "u" ) ) ||@expr1073745931
700: (@expr4101 (@expr4101 mTokType@var1137 ==@expr1073745934 eChar ) &&@expr1073745935 isPrefixStringCharLiteral (@expr1073745936 mStr@var1133 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4113 (@expr4113 (@expr4113 mTokType@var1137 ==@expr1073745940 eString ) &&@expr1073745941 isPrefixStringCharLiteral (@expr1073745942 mStr@var1133 , '"' , "U" ) ) ||@expr1073745943
705: (@expr4113 (@expr4113 mTokType@var1137 ==@expr1073745946 eChar ) &&@expr1073745947 isPrefixStringCharLiteral (@expr1073745948 mStr@var1133 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4125 (@expr4125 (@expr4125 mTokType@var1137 ==@expr1073745952 eString ) &&@expr1073745953 isPrefixStringCharLiteral (@expr1073745954 mStr@var1133 , '"' , "" ) ) ||@expr1073745955
710: (@expr4125 (@expr4125 mTokType@var1137 ==@expr1073745958 eChar ) &&@expr1073745959 isPrefixStringCharLiteral (@expr1073745960 mStr@var1133 , '\'' , "" ) &&@expr1073745961 mStr@var1133 .@expr1073745962 length (@expr1073745963 ) ==@expr1073745964 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4141 (@expr4141 (@expr4141 mTokType@var1137 ==@expr1073745968 eChar ) &&@expr1073745969 isPrefixStringCharLiteral (@expr1073745970 mStr@var1133 , '\'' , "" ) ) &&@expr1073745971
715: (@expr4141 mStr@var1133 .@expr1073745973 length (@expr1073745974 ) >@expr1073745975 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745976 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var992 ) {
738: setFlag (@expr1073745977 fIsTemplateArg , value@var992 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var993 , const char ( & pattern@var994 ) [ count ] ) {
743: return findsimplematch (@expr1073745979 startTok@var993 , pattern@var994 , count@expr1073745978 -@expr1073745980 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var995 , const char pattern@var996 [ ] , unsigned long pattern_len@var997 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var998 , const char ( & pattern@var999 ) [ count ] , const Token * const end@var1000 ) {
749: return findsimplematch (@expr1073745982 startTok@var998 , pattern@var999 , count@expr1073745981 -@expr1073745983 1 , end@var1000 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1001 , const char pattern@var1002 [ ] , unsigned long pattern_len@var1003 , const Token * const end@var1004 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1005 , const char pattern@var1006 [ ] , const int varId@var1007 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1008 , const char pattern@var1009 [ ] , const Token * const end@var1010 , const int varId@var1011 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1012 , const char ( & pattern@var1013 ) [ count ] ) {
758: return findsimplematch (@expr1073745985 startTok@var1012 , pattern@var1013 , count@expr1073745984 -@expr1073745986 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1014 , const char pattern@var1015 [ ] , unsigned long pattern_len@var1016 ) {
761: return const_cast < Token *@expr4163 > (@expr1073745988 findsimplematch (@expr1073745989 const_cast < const Token *@expr4163 > (@expr1073745991 startTok@var1014 ) , pattern@var1015 , pattern_len@var1016 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1017 , const char ( & pattern@var1018 ) [ count ] , const Token * const end@var1019 ) {
765: return findsimplematch (@expr1073745993 startTok@var1017 , pattern@var1018 , count@expr1073745992 -@expr1073745994 1 , end@var1019 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1020 , const char pattern@var1021 [ ] , unsigned long pattern_len@var1022 , const Token * const end@var1023 ) {
768: return const_cast < Token *@expr4171 > (@expr1073745996 findsimplematch (@expr1073745997 const_cast < const Token *@expr4171 > (@expr1073745999 startTok@var1020 ) , pattern@var1021 , pattern_len@var1022 , end@var1023 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1024 , const char pattern@var1025 [ ] , const int varId@var1026 = 0 ) {
772: return const_cast < Token *@expr4176 > (@expr1073746001 findmatch (@expr1073746002 const_cast < const Token *@expr4176 > (@expr1073746004 startTok@var1024 ) , pattern@var1025 , varId@var1026 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1027 , const char pattern@var1028 [ ] , const Token * const end@var1029 , const int varId@var1030 = 0 ) {
775: return const_cast < Token *@expr4181 > (@expr1073746006 findmatch (@expr1073746007 const_cast < const Token *@expr4181 > (@expr1073746009 startTok@var1027 ) , pattern@var1028 , end@var1029 , varId@var1030 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1031 , const char * haystack@var1032 , int varid@var1033 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1139 .@expr1073746010 mFileIndex@var1175 ;
796: }
797: void fileIndex ( int indexOfFile@var1034 ) {
798: mImpl@var1139 .@expr1073746011 mFileIndex@var1175 =@expr1073746012 indexOfFile@var1034 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1139 .@expr1073746013 mLineNumber@var1176 ;
803: }
804: void linenr ( int lineNumber@var1035 ) {
805: mImpl@var1139 .@expr1073746014 mLineNumber@var1176 =@expr1073746015 lineNumber@var1035 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1139 .@expr1073746016 mColumn@var1177 ;
810: }
811: void column ( int c@var1036 ) {
812: mImpl@var1139 .@expr1073746017 mColumn@var1177 =@expr1073746018 c@var1036 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1134 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1037 , const Token * end@var1038 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1039 , const std :: string & originalNameStr@var1040 = emptyString@var1 , bool prepend@var1041 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1042 , const std :: string & originalNameStr@var1043 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746019 tokenStr@var1042 , originalNameStr@var1043 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1135 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1139 .@expr1073746020 mVarId@var1170 ;
851: }
852: void varId ( int id@var1044 ) {
853: mImpl@var1139 .@expr1073746021 mVarId@var1170 =@expr1073746022 id@var1044 ;
854: if (@expr1073746023 id@var1044 !=@expr1073746024 0 ) {
855: tokType (@expr1073746025 eVariable ) ;
856: isStandardType (@expr1073746026 false ) ;
857: } else {
858: update_property_info (@expr1073746027 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746028 mImpl@var1139 .@expr4205 mExprId@var1178 ) {
864: return mImpl@var1139 .@expr4205 mExprId@var1178 ; }
865: return mImpl@var1139 .@expr1073746031 mVarId@var1170 ;
866: }
867: void exprId ( int id@var1045 ) {
868: mImpl@var1139 .@expr1073746032 mExprId@var1178 =@expr1073746033 id@var1045 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1046 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1047 , const std :: vector < std :: string > & fileNames@var1048 ) const ;
888:
|
891:
892: void printLines ( int lines@var1049 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1050 , Token * start@var1051 , Token * end@var1052 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1053 ; varid@var1053 = false ;
905: bool exprid@var1054 ; exprid@var1054 = false ;
906: bool idtype@var1055 ; idtype@var1055 = false ;
907: bool attributes@var1056 ; attributes@var1056 = false ;
908: bool macro@var1057 ; macro@var1057 = false ;
909: bool linenumbers@var1058 ; linenumbers@var1058 = false ;
910: bool linebreaks@var1059 ; linebreaks@var1059 = false ;
911: bool files@var1060 ; files@var1060 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1061 ;
914: options@var1061 .@expr1073746034 attributes@var1062 =@expr1073746035 true ;
915: options@var1061 .@expr1073746036 macro@var1063 =@expr1073746037 true ;
916: options@var1061 .@expr1073746038 linenumbers@var1064 =@expr1073746039 true ;
917: options@var1061 .@expr1073746040 linebreaks@var1065 =@expr1073746041 true ;
918: options@var1061 .@expr1073746042 files@var1066 =@expr1073746043 true ;
919: return options@var1061 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1067 ; options@var1067 =@expr1073746044 forDebug (@expr1073746045 ) ;
923: options@var1067 .@expr1073746046 varid@var1068 =@expr1073746047 true ;
924: return options@var1067 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1069 ; options@var1069 =@expr1073746048 forDebug (@expr1073746049 ) ;
928: options@var1069 .@expr1073746050 exprid@var1070 =@expr1073746051 true ;
929: return options@var1069 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1071 ; options@var1071 =@expr1073746052 forDebug (@expr1073746053 ) ;
933: options@var1071 .@expr1073746054 exprid@var1072 =@expr1073746055 true ;
934: options@var1071 .@expr1073746056 varid@var1073 =@expr1073746057 true ;
935: options@var1071 .@expr1073746058 idtype@var1074 =@expr1073746059 true ;
936: return options@var1071 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1075 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1076 , bool attributes@var1077 , bool macro@var1078 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1079 , const std :: vector < std :: string > * fileNames@var1080 = nullptr , const Token * end@var1081 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1082 , bool attributes@var1083 = true ) const ;
952: std :: string stringifyList ( bool varid@var1084 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1085 , bool attributes@var1086 , bool linenumbers@var1087 , bool linebreaks@var1088 , bool files@var1089 , const std :: vector < std :: string > * fileNames@var1090 = nullptr , const Token * end@var1091 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1092 ) {
983: mLink@var1136 =@expr1073746060 linkToToken@var1092 ;
984: if (@expr1073746061 mStr@var1133 ==@expr1073746062 "<" ||@expr1073746063 mStr@var1133 ==@expr1073746064 ">" ) {
985: update_property_info (@expr1073746065 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1136 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1093 ) {
1006: mImpl@var1139 .@expr1073746066 mScope@var1179 =@expr1073746067 s@var1093 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1139 .@expr1073746068 mScope@var1179 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1094 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1137 ==@expr1073746069 eFunction ||@expr1073746070 mTokType@var1137 ==@expr1073746071 eLambda ?@expr1073746072 mImpl@var1139 .@expr1073746073 mFunction@var1180 :@expr1073746074 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1095 ) {
1034: mImpl@var1139 .@expr1073746075 mVariable@var1181 =@expr1073746076 v@var1095 ;
1035: if (@expr1073746077 v@var1095 ||@expr1073746078 mImpl@var1139 .@expr1073746079 mVarId@var1170 ) {
1036: tokType (@expr1073746080 eVariable ) ; }
1037: else { if (@expr1073746081 mTokType@var1137 ==@expr1073746082 eVariable ) {
1038: tokType (@expr1073746083 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1137 ==@expr1073746084 eVariable ?@expr1073746085 mImpl@var1139 .@expr1073746086 mVariable@var1181 :@expr1073746087 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1096 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1137 ==@expr1073746088 eType ?@expr1073746089 mImpl@var1139 .@expr1073746090 mType@var1182 :@expr1073746091 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1097 , const Token * * typeTok@var1098 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1099 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1100 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1137 ==@expr1073746092 eEnumerator ?@expr1073746093 mImpl@var1139 .@expr1073746094 mEnumerator@var1183 :@expr1073746095 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1101 ) {
1079: mImpl@var1139 .@expr1073746096 mEnumerator@var1183 =@expr1073746097 e@var1101 ;
1080: if (@expr1073746098 e@var1101 ) {
1081: tokType (@expr1073746099 eEnumerator ) ; }
1082: else { if (@expr1073746100 mTokType@var1137 ==@expr1073746101 eEnumerator ) {
1083: tokType (@expr1073746102 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1102 , Token * end@var1103 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1104 , Token * srcEnd@var1105 , Token * newLocation@var1106 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1139 .@expr1073746103 mProgressValue@var1184 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1107 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1139 .@expr4280 mOriginalName@var1185 ?@expr1073746105 *@expr1073746106 mImpl@var1139 .@expr4280 mOriginalName@var1185 :@expr1073746108 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1139 .@expr4285 mValues@var1158 ?@expr1073746110 *@expr1073746111 mImpl@var1139 .@expr4285 mValues@var1158 :@expr1073746113 TokenImpl ::@expr1073746114 mEmptyValueList@var905 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1108 ) {
1164: if (@expr1073746115 !@expr1073746116 mImpl@var1139 .@expr4293 mOriginalName@var1185 ) {
1165: mImpl@var1139 .@expr4293 mOriginalName@var1185 =@expr1073746119 new std ::@expr1073746120 string (@expr1073746121 name@var1108 ) ; }
1166: else {
1167: *@expr1073746122 mImpl@var1139 .@expr4293 mOriginalName@var1185 =@expr1073746124 name@var1108 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1109 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1110 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1111 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1139 .@expr1073746126 mValues@var1158 .@expr1073746127 front (@expr1073746128 ) .@expr1073746129 intvalue@expr1073746125 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1112 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1113 , long long path@var1114 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1115 , const Settings * settings@var1116 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1117 , const Settings * settings@var1118 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1119 , int argnr@var1120 , const Settings * settings@var1121 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1122 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1123 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1124 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1125 ) {
1200: if (@expr1073746130 mImpl@var1139 .@expr4307 mValues@var1158 ) {
1201: mImpl@var1139 .@expr4307 mValues@var1158 .@expr1073746133 remove_if (@expr1073746134 pred@var1125 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1139 .@expr1073746135 mIndex@var1186 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1126 ) {
1213: mNext@var1134 =@expr1073746136 nextToken@var1126 ;
1214: }
1215: void previous ( Token * previousToken@var1127 ) {
1216: mPrevious@var1135 =@expr1073746137 previousToken@var1127 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1128 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1129 , const char * word@var1130 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1131 , char c@var1132 ) ;
1235:
1236: std :: string mStr@var1133 ;
1237:
1238: Token * mNext@var1134 ;
1239: Token * mPrevious@var1135 ;
1240: Token * mLink@var1136 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1137 ;
1283:
1284: uint64_t mFlags@var1138 ;
1285:
1286: TokenImpl * mImpl@var1139 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1140 ) const {
1294: return (@expr4314 (@expr4314 mFlags@var1138 &@expr1073746140 flag_@var1140 ) !=@expr1073746141 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1141 , bool state_@var1142 ) {
1303: mFlags@var1138 =@expr1073746142 state_@var1142 ?@expr1073746143 mFlags@var1138 |@expr1073746144 flag_@var1141 :@expr1073746145 mFlags@var1138 &@expr1073746146 ~@expr1073746147 flag_@var1141 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1143 , const int indent1@var1144 = 0 , const int indent2@var1145 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1146 ) ;
1321: void astOperand2 ( Token * tok@var1147 ) ;
1322: void astParent ( Token * tok@var1148 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1139 .@expr1073746148 mAstOperand1@var1149 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1139 .@expr1073746149 mAstOperand1@var1149 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1139 .@expr1073746150 mAstOperand2@var1150 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1139 .@expr1073746151 mAstOperand2@var1150 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1139 .@expr1073746152 mAstParent@var1151 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1139 .@expr1073746153 mAstParent@var1151 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746154 !@expr1073746155 astParent (@expr4332 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746157 this@expr4334 ==@expr1073746159 astParent (@expr4332 ) .@expr4337 astOperand1 (@expr4338 ) ) {
1346: return astParent (@expr4332 ) .@expr4340 astOperand2 (@expr4341 ) ; }
1347: else { if (@expr1073746166 this@expr4334 ==@expr1073746167 astParent (@expr4332 ) .@expr4340 astOperand2 (@expr4341 ) ) {
1348: return astParent (@expr4332 ) .@expr4337 astOperand1 (@expr4338 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746174 !@expr1073746175 astParent (@expr4352 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746177 this@expr4354 ==@expr1073746179 astParent (@expr4352 ) .@expr4357 astOperand1 (@expr4358 ) ) {
1356: return astParent (@expr4352 ) .@expr4360 astOperand2 (@expr4361 ) ; }
1357: else { if (@expr1073746186 this@expr4354 ==@expr1073746187 astParent (@expr4352 ) .@expr4360 astOperand2 (@expr4361 ) ) {
1358: return astParent (@expr4352 ) .@expr4357 astOperand1 (@expr4358 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1152 ; ret@var1152 =@expr1073746194 this@expr1073746195 ;
1364: while (@expr1073746196 ret@var1152 .@expr4373 mImpl@var1153 .@expr4374 mAstParent@var1154 ) {
1365: ret@var1152 =@expr1073746199 ret@var1152 .@expr4373 mImpl@var1153 .@expr4374 mAstParent@var1154 ; }
1366: return ret@var1152 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1155 ; ret@var1155 =@expr1073746202 this@expr1073746203 ;
1371: while (@expr1073746204 ret@var1155 .@expr4381 mImpl@var1156 .@expr4382 mAstParent@var1157 ) {
1372: ret@var1155 =@expr1073746207 ret@var1155 .@expr4381 mImpl@var1156 .@expr4382 mAstParent@var1157 ; }
1373: return ret@var1155 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1139 .@expr1073746210 mAstOperand1@var1149 =@expr1073746211 mImpl@var1139 .@expr1073746212 mAstOperand2@var1150 =@expr1073746213 mImpl@var1139 .@expr1073746214 mAstParent@var1151 =@expr1073746215 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1139 .@expr4392 mValues@var1158 ;
1393: mImpl@var1139 .@expr4392 mValues@var1158 =@expr1073746218 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1159 = "" ) const {
1397: std ::@expr1073746219 string ret@var1160 ;
1398: if (@expr1073746220 mImpl@var1139 .@expr4397 mAstOperand1@var1149 ) {
1399: ret@var1160 =@expr1073746222 mImpl@var1139 .@expr4397 mAstOperand1@var1149 .@expr1073746224 astString (@expr1073746225 sep@var1159 ) ; }
1400: if (@expr1073746226 mImpl@var1139 .@expr4403 mAstOperand2@var1150 ) {
1401: ret@var1160 +=@expr1073746228 mImpl@var1139 .@expr4403 mAstOperand2@var1150 .@expr1073746230 astString (@expr1073746231 sep@var1159 ) ; }
1402: return ret@var1160 +@expr1073746232 sep@var1159 +@expr1073746233 mStr@var1133 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1161 , bool xml@var1162 , const std :: vector < std :: string > & fileNames@var1163 , std :: ostream & out@var1164 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1165 , std :: ostream & out@var1166 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1167 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1168 ) const {
1419: mImpl@var1139 .@expr1073746234 mCpp11init@var1169 =@expr1073746235 cpp11init@var1168 ?@expr1073746236 TokenImpl ::@expr4413 Cpp11init ::@expr1073746238 CPP11INIT :@expr1073746239 TokenImpl ::@expr4413 Cpp11init ::@expr1073746241 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1139 .@expr1073746242 mCpp11init@var1169 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1187 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1188 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1189 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1190 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1191 ( nullptr ) , num@var1192 ( 0 ) , known@var1193 ( true ) { }
62:
63: const Token * tok@var1191 ;
64: long long num@var1192 ;
65: bool known@var1193 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1194 ;
72: const Scope * classScope@var1195 ;
73: const Scope * enclosingScope@var1196 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1197 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1199 ( nullptr ) , nameTok@var1200 ( nullptr ) , access@var1201 ( AccessControl :: Public ) , isVirtual@var1202 ( false ) { }
82:
83: std :: string name@var1198 ;
84: const Type * type@var1199 ;
85: const Token * nameTok@var1200 ;
86: AccessControl access@var1201 ;
87: bool isVirtual@var1202 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1203 ) const {
90: return this@expr1073746243 .@expr1073746244 type@var1199 <@expr1073746245 rhs@var1203 .@expr1073746246 type@var1204 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1205 ( nullptr ) , nameEnd@var1206 ( nullptr ) , type@var1207 ( nullptr ) { }
97:
98: const Token * nameStart@var1205 ;
99: const Token * nameEnd@var1206 ;
100: const Type * type@var1207 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1208 ;
104: std :: vector < FriendInfo > friendList@var1209 ;
105:
106: const Token * typeStart@var1210 ;
107: const Token * typeEnd@var1211 ;
108: long long sizeOf@var1212 ;
109:
110: Type ( const Token * classDef_@var1213 = nullptr , const Scope * classScope_@var1214 = nullptr , const Scope * enclosingScope_@var1215 = nullptr ) :
111: classDef@var1194 ( classDef_@var1213 ) ,
112: classScope@var1195 ( classScope_@var1214 ) ,
113: enclosingScope@var1196 ( enclosingScope_@var1215 ) ,
114: needInitialization@var1197 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1210 ( nullptr ) ,
116: typeEnd@var1211 ( nullptr ) ,
117: sizeOf@var1212 ( 0 ) {
118: if (@expr1073746247 classDef_@var1213 &&@expr1073746248 classDef_@var1213 .@expr4425 str (@expr4426 ) ==@expr1073746251 "enum" ) {
119: needInitialization@var1197 =@expr1073746252 NeedInitialization ::@expr1073746253 True ; }
120: else { if (@expr1073746254 classDef_@var1213 &&@expr1073746255 classDef_@var1213 .@expr4425 str (@expr4426 ) ==@expr1073746258 "using" ) {
121: typeStart@var1210 =@expr1073746259 classDef@var1194 .@expr1073746260 tokAt (@expr1073746261 3 ) ;
122: typeEnd@var1211 =@expr1073746262 typeStart@var1210 ;
123: while (@expr1073746263 typeEnd@var1211 .@expr4440 next (@expr4441 ) &&@expr1073746266 typeEnd@var1211 .@expr4440 next (@expr4441 ) .@expr1073746269 str (@expr1073746270 ) !=@expr1073746271 ";" ) {
124: typeEnd@var1211 =@expr1073746272 typeEnd@var1211 .@expr4440 next (@expr4441 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1194 ?@expr1073746275 classDef@var1194 .@expr1073746276 str (@expr1073746277 ) :@expr1073746278 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1194 &&@expr1073746279 classDef@var1194 .@expr1073746280 str (@expr1073746281 ) ==@expr1073746282 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1216 , const Token * tok1@var1217 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1218 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1219 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1220 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1221 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1222 ) : scope@var1223 ( scope_@var1222 ) , name@var1224 ( nullptr ) , value@var1225 ( 0 ) , start@var1226 ( nullptr ) , end@var1227 ( nullptr ) , value_known@var1228 ( false ) { }
167: const Scope * scope@var1223 ;
168: const Token * name@var1224 ;
169: long long value@var1225 ;
170: const Token * start@var1226 ;
171: const Token * end@var1227 ;
172: bool value_known@var1228 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1229 ) const {
204: return (@expr4459 (@expr4459 mFlags@var1265 &@expr1073746285 flag_@var1229 ) !=@expr1073746286 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1230 , bool state_@var1231 ) {
213: mFlags@var1265 =@expr1073746287 state_@var1231 ?@expr1073746288 mFlags@var1265 |@expr1073746289 flag_@var1230 :@expr1073746290 mFlags@var1265 &@expr1073746291 ~@expr1073746292 flag_@var1230 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1232 , bool * isContainer@var1233 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1234 , const Token * start_@var1235 , const Token * end_@var1236 ,
226: int index_@var1237 , AccessControl access_@var1238 , const Type * type_@var1239 ,
227: const Scope * scope_@var1240 , const Settings * settings@var1241 )
228: : mNameToken@var1260 ( name_@var1234 ) ,
229: mTypeStartToken@var1261 ( start_@var1235 ) ,
230: mTypeEndToken@var1262 ( end_@var1236 ) ,
231: mIndex@var1263 ( index_@var1237 ) ,
232: mAccess@var1264 ( access_@var1238 ) ,
233: mFlags@var1265 ( 0 ) ,
234: mType@var1266 ( type_@var1239 ) ,
235: mScope@var1267 ( scope_@var1240 ) ,
236: mValueType@var1268 ( nullptr ) {
237: evaluate (@expr1073746293 settings@var1241 ) ;
238: }
239:
240: Variable ( const Token * name_@var1242 , const std :: string & clangType@var1243 , const Token * typeStart@var1244 ,
241: const Token * typeEnd@var1245 , int index_@var1246 , AccessControl access_@var1247 ,
242: const Type * type_@var1248 , const Scope * scope_@var1249 ) ;
243:
244: Variable ( const Variable & var@var1250 , const Scope * scope@var1251 ) ;
245:
246: Variable ( const Variable & var@var1252 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1253 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1260 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1261 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1262 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746294 mNameToken@var1260 ) {
300: return mNameToken@var1260 .@expr1073746295 str (@expr1073746296 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746297 mNameToken@var1260 ) {
312: return mNameToken@var1260 .@expr1073746298 varId (@expr1073746299 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1263 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1264 ==@expr1073746300 AccessControl ::@expr1073746301 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1264 ==@expr1073746302 AccessControl ::@expr1073746303 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1264 ==@expr1073746304 AccessControl ::@expr1073746305 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1264 ==@expr1073746306 AccessControl ::@expr1073746307 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1264 ==@expr1073746308 AccessControl ::@expr1073746309 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1264 ==@expr1073746310 AccessControl ::@expr1073746311 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746313 mAccess@var1264 ==@expr1073746314 AccessControl ::@expr1073746315 Local@expr1073746312 ) &&@expr1073746316 !@expr1073746317 isExtern (@expr1073746318 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746319 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746320 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746321 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746322 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746323 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1264 ==@expr1073746324 AccessControl ::@expr1073746325 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746326 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746327 fIsArray ) &&@expr1073746328 !@expr1073746329 getFlag (@expr1073746330 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746331 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746332 ) &&@expr1073746333 getFlag (@expr1073746334 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746335 fIsArray ) ||@expr1073746336 getFlag (@expr1073746337 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746338 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746339 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746340 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746341 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1266 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1266 ?@expr1073746342 mType@var1266 .@expr1073746343 classScope@var1271 :@expr1073746344 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1267 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1269 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1254 ) const {
550: return mDimensions@var1269 [@expr1073746345 index_@var1254 ] .@expr1073746346 num@var2967 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1255 ) const {
558: return mDimensions@var1269 [@expr1073746347 index_@var1255 ] .@expr1073746348 known@var2968 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746349 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746350 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746351 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1256 ) const {
602: return isStlType (@expr1073746352 ) &&@expr1073746353 stlType@var1256 ==@expr1073746354 mTypeStartToken@var1261 .@expr1073746355 strAt (@expr1073746356 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1257 ) const {
616: return isStlType (@expr1073746357 ) &&@expr1073746358 stlTypes@var1257 .@expr1073746359 find (@expr1073746360 mTypeStartToken@var1261 .@expr1073746361 strAt (@expr1073746362 2 ) ) !=@expr1073746363 stlTypes@var1257 .@expr1073746364 end (@expr1073746365 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746366 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4543 ) &&@expr1073746368 type (@expr4543 ) .@expr1073746370 isEnumType (@expr1073746371 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746372 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1268 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1258 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1264 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1259 ) {
660: mType@var1266 =@expr1073746373 t@var1259 ;
661: }
662:
663:
664: const Token * mNameToken@var1260 ;
665:
666:
667: const Token * mTypeStartToken@var1261 ;
668:
669:
670: const Token * mTypeEndToken@var1262 ;
671:
672:
673: int mIndex@var1263 ;
674:
675:
676: AccessControl mAccess@var1264 ;
677:
678:
679: unsigned int mFlags@var1265 ;
680:
681:
682: const Type * mType@var1266 ;
683:
684:
685: const Scope * mScope@var1267 ;
686:
687: ValueType * mValueType@var1268 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1269 ;
691:
692:
693: void evaluate ( const Settings * settings@var1270 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1272 ) const {
735: return (@expr4550 (@expr4550 mFlags@var1321 &@expr1073746376 flag@var1272 ) !=@expr1073746377 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1273 , bool state@var1274 ) {
744: mFlags@var1321 =@expr1073746378 state@var1274 ?@expr1073746379 mFlags@var1321 |@expr1073746380 flag@var1273 :@expr1073746381 mFlags@var1321 &@expr1073746382 ~@expr1073746383 flag@var1273 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1275 , const Token * tok@var1276 , const Scope * scope@var1277 , const Token * tokDef@var1278 , const Token * tokArgDef@var1279 ) ;
751: Function ( const Token * tokenDef@var1280 , const std :: string & clangType@var1281 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1291 .@expr1073746384 str (@expr1073746385 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1299 .@expr1073746386 size (@expr1073746387 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1299 .@expr1073746388 size (@expr1073746389 ) -@expr1073746390 initArgCount@var1300 ;
764: }
765: const Variable * getArgumentVar ( int num@var1282 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1300 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1283 , const Scope * scope@var1284 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1285 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1286 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1301 ==@expr1073746391 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1301 ==@expr1073746392 eConstructor ||@expr1073746393
785: type@var1301 ==@expr1073746394 eCopyConstructor ||@expr1073746395
786: type@var1301 ==@expr1073746396 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1301 ==@expr1073746397 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1291 .@expr1073746398 isAttributeConstructor (@expr1073746399 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1291 .@expr1073746400 isAttributeDestructor (@expr1073746401 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1291 .@expr1073746402 isAttributePure (@expr1073746403 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1291 .@expr1073746404 isAttributeConst (@expr1073746405 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1291 .@expr1073746406 isAttributeNoreturn (@expr1073746407 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1291 .@expr1073746408 isAttributeNothrow (@expr1073746409 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1291 .@expr1073746410 isAttributeNodiscard (@expr1073746411 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746412 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746413 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746414 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746415 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746416 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746417 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746418 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746419 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746420 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746421 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746422 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746423 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746424 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746425 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746426 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746427 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746428 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746429 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746430 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746431 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746432 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746433 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1287 ) {
881: setFlag (@expr1073746434 fHasBody , state@var1287 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746435 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746436 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1288 ) {
891: setFlag (@expr1073746437 fIsEscapeFunction , state@var1288 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746438 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1289 ) {
898: setFlag (@expr1073746439 fIsConstexpr , state@var1289 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1290 ) const ;
901:
902: const Token * tokenDef@var1291 ;
903: const Token * argDef@var1292 ;
904: const Token * token@var1293 ;
905: const Token * arg@var1294 ;
906: const Token * retDef@var1295 ;
907: const :: Type * retType@var1296 ;
908: const Scope * functionScope@var1297 ;
909: const Scope * nestedIn@var1298 ;
910: std :: list < Variable > argumentList@var1299 ;
911: int initArgCount@var1300 ;
912: Type type@var1301 ;
913: AccessControl access@var1302 ;
914: const Token * noexceptArg@var1303 ;
915: const Token * throwArg@var1304 ;
916: const Token * templateDef@var1305 ;
917: const Token * functionPointerUsage@var1306 ;
918:
919: bool argsMatch ( const Scope * scope@var1307 , const Token * first@var1308 , const Token * second@var1309 , const std :: string & path@var1310 , int path_length@var1311 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1312 , bool unknown@var1313 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1314 , bool unknown@var1315 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1316 , bool unknown@var1317 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1318 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746440 this@expr1073746441 .@expr1073746442 hasTrailingReturnType (@expr1073746443 ) ) {
931: return Token ::@expr1073746444 findmatch (@expr1073746445 retDef@var1295 , "{|;" ) ;
932: } else {
933: return tokenDef@var1291 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1319 , bool * foundAllBaseClasses@var1320 ) const ;
946:
947: unsigned int mFlags@var1321 ;
948:
949: void isInline ( bool state@var1322 ) {
950: setFlag (@expr1073746446 fIsInline , state@var1322 ) ;
951: }
952: void isConst ( bool state@var1323 ) {
953: setFlag (@expr1073746447 fIsConst , state@var1323 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1324 ) {
956: setFlag (@expr1073746448 fHasVirtualSpecifier , state@var1324 ) ;
957: }
958: void isPure ( bool state@var1325 ) {
959: setFlag (@expr1073746449 fIsPure , state@var1325 ) ;
960: }
961: void isStatic ( bool state@var1326 ) {
962: setFlag (@expr1073746450 fIsStatic , state@var1326 ) ;
963: }
964: void isStaticLocal ( bool state@var1327 ) {
965: setFlag (@expr1073746451 fIsStaticLocal , state@var1327 ) ;
966: }
967: void isExtern ( bool state@var1328 ) {
968: setFlag (@expr1073746452 fIsExtern , state@var1328 ) ;
969: }
970: void isFriend ( bool state@var1329 ) {
971: setFlag (@expr1073746453 fIsFriend , state@var1329 ) ;
972: }
973: void isExplicit ( bool state@var1330 ) {
974: setFlag (@expr1073746454 fIsExplicit , state@var1330 ) ;
975: }
976: void isDefault ( bool state@var1331 ) {
977: setFlag (@expr1073746455 fIsDefault , state@var1331 ) ;
978: }
979: void isDelete ( bool state@var1332 ) {
980: setFlag (@expr1073746456 fIsDelete , state@var1332 ) ;
981: }
982: void isNoExcept ( bool state@var1333 ) {
983: setFlag (@expr1073746457 fIsNoExcept , state@var1333 ) ;
984: }
985: void isThrow ( bool state@var1334 ) {
986: setFlag (@expr1073746458 fIsThrow , state@var1334 ) ;
987: }
988: void isOperator ( bool state@var1335 ) {
989: setFlag (@expr1073746459 fIsOperator , state@var1335 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1336 ) {
992: setFlag (@expr1073746460 fHasLvalRefQual , state@var1336 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1337 ) {
995: setFlag (@expr1073746461 fHasRvalRefQual , state@var1337 ) ;
996: }
997: void isVariadic ( bool state@var1338 ) {
998: setFlag (@expr1073746462 fIsVariadic , state@var1338 ) ;
999: }
1000: void isVolatile ( bool state@var1339 ) {
1001: setFlag (@expr1073746463 fIsVolatile , state@var1339 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1340 ) {
1004: return setFlag (@expr1073746464 fHasTrailingReturnType , state@var1340 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1341 ) {
1007: setFlag (@expr1073746465 fIsInlineKeyword , state@var1341 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1342 , const Scope * scope@var1343 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1344 ;
1019: const Scope * scope@var1345 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1346 , const Token * classDef_@var1347 , const Scope * nestedIn_@var1348 ) ;
1025: Scope ( const SymbolDatabase * check_@var1349 , const Token * classDef_@var1350 , const Scope * nestedIn_@var1351 , ScopeType type_@var1352 , const Token * start_@var1353 ) ;
1026:
1027: const SymbolDatabase * check@var1354 ;
1028: std :: string className@var1355 ;
1029: const Token * classDef@var1356 ;
1030: const Token * bodyStart@var1357 ;
1031: const Token * bodyEnd@var1358 ;
1032: std :: list < Function > functionList@var1359 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1360 ;
1034: std :: list < Variable > varlist@var1361 ;
1035: const Scope * nestedIn@var1362 ;
1036: std :: list < Scope * > nestedList@var1363 ;
1037: int numConstructors@var1364 ;
1038: int numCopyOrMoveConstructors@var1365 ;
1039: std :: list < UsingInfo > usingList@var1366 ;
1040: ScopeType type@var1367 ;
1041: Type * definedType@var1368 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1369 ;
1043: std :: vector < const Token * > bodyStartList@var1370 ;
1044:
1045:
1046: const Scope * functionOf@var1371 ;
1047: Function * function@var1372 ;
1048:
1049:
1050: const Token * enumType@var1373 ;
1051: bool enumClass@var1374 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1375 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1376 ) {
1056: bodyStart@var1357 =@expr1073746466 start@var1376 ;
1057: bodyEnd@var1358 =@expr1073746467 start@var1376 ?@expr1073746468 start@var1376 .@expr1073746469 link (@expr1073746470 ) :@expr1073746471 nullptr ;
1058: if (@expr1073746472 start@var1376 ) {
1059: bodyStartList@var1370 .@expr1073746473 push_back (@expr1073746474 start@var1376 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1355 .@expr1073746475 size (@expr1073746476 ) >@expr1073746477 9 &&@expr1073746478 className@var1355 .@expr1073746479 compare (@expr1073746480 0 , 9 , "Anonymous" ) ==@expr1073746481 0 &&@expr1073746482 std ::@expr1073746483 isdigit (@expr1073746484 className@var1355 [@expr1073746485 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1377 ) const {
1068: for (@expr1073746486 const Enumerator &@expr1073746487 i@var1378 :@expr1073746488 enumeratorList@var1375 ) {
1069: if (@expr1073746489 i@var1378 .@expr1073746490 name@var1379 .@expr1073746491 str (@expr1073746492 ) ==@expr1073746493 name@var1377 ) {
1070: return &@expr1073746494 i@var1378 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1380 ) const {
1076: if (@expr1073746495 !@expr1073746496 outer@var1380 ) {
1077: return false ; }
1078: if (@expr1073746497 outer@var1380 ==@expr1073746498 this@expr1073746499 ) {
1079: return true ; }
1080: const Scope * parent@var1381 ; parent@var1381 =@expr1073746500 nestedIn@var1362 ;
1081: while (@expr1073746501 outer@var1380 !=@expr1073746502 parent@var1381 &&@expr1073746503 parent@var1381 ) {
1082: parent@var1381 =@expr1073746504 parent@var1381 .@expr1073746505 nestedIn@var1382 ; }
1083: if (@expr1073746506 parent@var1381 &&@expr1073746507 parent@var1381 ==@expr1073746508 outer@var1380 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1383 ) {
1089: while (@expr1073746509 scope@var1383 ) {
1090: if (@expr1073746510 scope@var1383 .@expr1073746511 type@var1384 ==@expr1073746512 Scope ::@expr1073746513 eFunction ) {
1091: break ; }
1092: scope@var1383 =@expr1073746514 scope@var1383 .@expr1073746515 nestedIn@var1385 ;
1093: }
1094: if (@expr1073746516 !@expr1073746517 scope@var1383 ) {
1095: return nullptr ; }
1096: return scope@var1383 .@expr1073746518 function@var1386 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746519 type@var1367 ==@expr1073746520 eClass ||@expr1073746521 type@var1367 ==@expr1073746522 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746523 type@var1367 ==@expr1073746524 eClass ||@expr1073746525 type@var1367 ==@expr1073746526 eStruct ||@expr1073746527 type@var1367 ==@expr1073746528 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1367 !=@expr1073746529 eClass &&@expr1073746530 type@var1367 !=@expr1073746531 eStruct &&@expr1073746532 type@var1367 !=@expr1073746533 eUnion &&@expr1073746534 type@var1367 !=@expr1073746535 eGlobal &&@expr1073746536 type@var1367 !=@expr1073746537 eNamespace &&@expr1073746538 type@var1367 !=@expr1073746539 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1367 ==@expr1073746540 Scope ::@expr4717 ScopeType ::@expr1073746542 eFor ||@expr1073746543 type@var1367 ==@expr1073746544 Scope ::@expr4717 ScopeType ::@expr1073746546 eWhile ||@expr1073746547 type@var1367 ==@expr1073746548 Scope ::@expr4717 ScopeType ::@expr1073746550 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746551 type@var1367 ==@expr1073746552 eIf ||@expr1073746553 type@var1367 ==@expr1073746554 eElse ||@expr1073746555
1117: type@var1367 ==@expr1073746556 eFor ||@expr1073746557 type@var1367 ==@expr1073746558 eWhile ||@expr1073746559 type@var1367 ==@expr1073746560 eDo ||@expr1073746561
1118: type@var1367 ==@expr1073746562 eSwitch ||@expr1073746563 type@var1367 ==@expr1073746564 eUnconditional ||@expr1073746565
1119: type@var1367 ==@expr1073746566 eTry ||@expr1073746567 type@var1367 ==@expr1073746568 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1387 , bool requireConst@var1388 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1389 , bool isC@var1390 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1391 ) {
1135: return const_cast < Scope *@expr4745 > (@expr1073746570 const_cast < const Scope *@expr4745 > (@expr1073746572 this@expr1073746573 ) .@expr1073746574 findRecordInNestedList (@expr1073746575 name@var1391 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1392 ) const ;
1139: Type * findType ( const std :: string & name@var1393 ) {
1140: return const_cast < Type *@expr4752 > (@expr1073746577 const_cast < const Scope *@expr4752 > (@expr1073746579 this@expr1073746580 ) .@expr1073746581 findType (@expr1073746582 name@var1393 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1394 ) ;
1148:
1149: void addVariable ( const Token * token_@var1395 , const Token * start_@var1396 ,
1150: const Token * end_@var1397 , AccessControl access_@var1398 , const Type * type_@var1399 ,
1151: const Scope * scope_@var1400 , const Settings * settings@var1401 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1402 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1403 ) {
1159: functionList@var1359 .@expr1073746583 push_back (@expr1073746584 func@var1403 ) ;
1160:
1161: const Function * back@var1404 ; back@var1404 =@expr1073746585 &@expr1073746586 functionList@var1359 .@expr1073746587 back (@expr1073746588 ) ;
1162:
1163: functionMap@var1360 .@expr1073746589 insert (@expr1073746590 make_pair (@expr1073746591 back@var1404 .@expr1073746592 tokenDef@var1405 .@expr1073746593 str (@expr1073746594 ) , back@var1404 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1406 , AccessControl varaccess@var1407 , const Settings * settings@var1408 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1409 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1410 , bool isCpp@var1411 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1412 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1413 , const Token * & vartok@var1414 , const Token * & typetok@var1415 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1416 , int args@var1417 , std :: vector < const Function * > & matches@var1418 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1419 , const Token * start@var1420 , const Token * end@var1421 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1422 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1423 ;
1239: int bits@var1424 ;
1240: int pointer@var1425 ;
1241: int constness@var1426 ;
1242: Reference reference@var1427 ; reference@var1427 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1428 ;
1245: const :: Type * smartPointerType@var1429 ;
1246: const Token * smartPointerTypeToken@var1430 ;
1247: const Library :: SmartPointer * smartPointer@var1431 ;
1248: const Library :: Container * container@var1432 ;
1249:
1250: const Token * containerTypeToken@var1433 ;
1251:
1252: std :: string originalTypeName@var1434 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1422 ( UNKNOWN_SIGN ) ,
1257: type@var1423 ( UNKNOWN_TYPE ) ,
1258: bits@var1424 ( 0 ) ,
1259: pointer@var1425 ( 0U ) ,
1260: constness@var1426 ( 0U ) ,
1261: typeScope@var1428 ( nullptr ) ,
1262: smartPointerType@var1429 ( nullptr ) ,
1263: smartPointerTypeToken@var1430 ( nullptr ) ,
1264: smartPointer@var1431 ( nullptr ) ,
1265: container@var1432 ( nullptr ) ,
1266: containerTypeToken@var1433 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1435 , enum Type t@var1436 , int p@var1437 )
1269: : sign@var1422 ( s@var1435 ) ,
1270: type@var1423 ( t@var1436 ) ,
1271: bits@var1424 ( 0 ) ,
1272: pointer@var1425 ( p@var1437 ) ,
1273: constness@var1426 ( 0U ) ,
1274: typeScope@var1428 ( nullptr ) ,
1275: smartPointerType@var1429 ( nullptr ) ,
1276: smartPointerTypeToken@var1430 ( nullptr ) ,
1277: smartPointer@var1431 ( nullptr ) ,
1278: container@var1432 ( nullptr ) ,
1279: containerTypeToken@var1433 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1438 , enum Type t@var1439 , int p@var1440 , int c@var1441 )
1282: : sign@var1422 ( s@var1438 ) ,
1283: type@var1423 ( t@var1439 ) ,
1284: bits@var1424 ( 0 ) ,
1285: pointer@var1425 ( p@var1440 ) ,
1286: constness@var1426 ( c@var1441 ) ,
1287: typeScope@var1428 ( nullptr ) ,
1288: smartPointerType@var1429 ( nullptr ) ,
1289: smartPointerTypeToken@var1430 ( nullptr ) ,
1290: smartPointer@var1431 ( nullptr ) ,
1291: container@var1432 ( nullptr ) ,
1292: containerTypeToken@var1433 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1442 , enum Type t@var1443 , int p@var1444 , int c@var1445 , const std :: string & otn@var1446 )
1295: : sign@var1422 ( s@var1442 ) ,
1296: type@var1423 ( t@var1443 ) ,
1297: bits@var1424 ( 0 ) ,
1298: pointer@var1425 ( p@var1444 ) ,
1299: constness@var1426 ( c@var1445 ) ,
1300: typeScope@var1428 ( nullptr ) ,
1301: smartPointerType@var1429 ( nullptr ) ,
1302: smartPointerTypeToken@var1430 ( nullptr ) ,
1303: smartPointer@var1431 ( nullptr ) ,
1304: container@var1432 ( nullptr ) ,
1305: containerTypeToken@var1433 ( nullptr ) ,
1306: originalTypeName@var1434 ( otn@var1446 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1447 , const Settings * settings@var1448 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1449 , bool longType@var1450 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1451 , const ValueType * func@var1452 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1453 , const Variable * callVar@var1454 , const Variable * funcVar@var1455 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746595 type@var1423 >=@expr1073746596 ValueType ::@expr1073746597 Type ::@expr1073746598 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746599 type@var1423 >=@expr1073746600 ValueType ::@expr4777 Type ::@expr1073746602 BOOL &&@expr1073746603 type@var1423 <=@expr1073746604 ValueType ::@expr4777 Type ::@expr1073746606 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746607 type@var1423 >=@expr1073746608 ValueType ::@expr4785 Type ::@expr1073746610 FLOAT &&@expr1073746611 type@var1423 <=@expr1073746612 ValueType ::@expr4785 Type ::@expr1073746614 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1456 , const Settings * settings@var1457 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1428 &&@expr1073746615 typeScope@var1428 .@expr1073746616 type@var1458 ==@expr1073746617 Scope ::@expr1073746618 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1459 , bool p@var1460 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1461 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1462 , const Settings * settings@var1463 , ErrorLogger * errorLogger@var1464 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1465 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1466 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1467 ;
1359:
1360:
1361: std :: list < Type > typeList@var1468 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1469 , const Token * typeTok@var1470 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1471 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1472 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1473 , const Scope * startScope@var1474 , bool lookOutside@var1475 = false ) const ;
1382: Type * findType ( const Token * startTok@var1476 , Scope * startScope@var1477 , bool lookOutside@var1478 = false ) const {
1383: return const_cast < Type *@expr4795 > (@expr1073746620 this@expr1073746621 .@expr1073746622 findType (@expr1073746623 startTok@var1476 , const_cast < const Scope *@expr4795 > (@expr1073746625 startScope@var1477 ) , lookOutside@var1478 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1479 , const Scope * startScope@var1480 ) const ;
1387: Scope * findScope ( const Token * tok@var1481 , Scope * startScope@var1482 ) const {
1388: return const_cast < Scope *@expr4802 > (@expr1073746627 this@expr1073746628 .@expr1073746629 findScope (@expr1073746630 tok@var1481 , const_cast < const Scope *@expr4802 > (@expr1073746632 startScope@var1482 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1483 ) const {
1392: return varid@var1483 <@expr1073746633 mVariableList@var1540 .@expr1073746634 size (@expr1073746635 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1484 ) const {
1396: return mVariableList@var1540 .@expr1073746636 at (@expr1073746637 varId@var1484 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1540 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1485 , const std :: string & type@var1486 , const std :: string & msg@var1487 ) const ;
1407:
1408: void printOut ( const char * title@var1488 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1489 , const char * indent@var1490 ) const ;
1410: void printXml ( std :: ostream & out@var1491 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1492 , Token * tokens@var1493 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1494 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1495 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1496 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1497 , const Token * * tok@var1498 , const Token * argStart@var1499 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1500 , const Token * tok@var1501 , const Token * argStart@var1502 , const Token * funcStart@var1503 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1504 , const Token * & tok@var1505 , const Token * argStart@var1506 , const Token * funcStart@var1507 ) ;
1469: void addNewFunction ( Scope * * scope@var1508 , const Token * * tok@var1509 ) ;
1470: bool isFunction ( const Token * tok@var1510 , const Scope * outerScope@var1511 , const Token * * funcStart@var1512 , const Token * * argStart@var1513 , const Token * * declEnd@var1514 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1515 , const Scope * startScope@var1516 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1517 , const Scope * scope@var1518 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1519 , const Scope * ns@var1520 , const std :: string & path@var1521 , int path_length@var1522 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1523 , const Token * typeTok@var1524 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1525 , const Token * vartok@var1526 , Token * membertok@var1527 , const Variable * membervar@var1528 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1529 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1530 ) const ;
1485:
1486: void setValueType ( Token * tok@var1531 , const ValueType & valuetype@var1532 ) ;
1487: void setValueType ( Token * tok@var1533 , const Variable & var@var1534 ) ;
1488: void setValueType ( Token * tok@var1535 , const Enumerator & enumerator@var1536 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1537 ;
1491: const Settings * mSettings@var1538 ;
1492: ErrorLogger * mErrorLogger@var1539 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1540 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1541 ;
1499:
1500: bool mIsCpp@var1542 ;
1501: ValueType :: Sign mDefaultSignedness@var1543 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1544 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1545 , const TFunc & visitor@var1546 )
52: {
53: if (@expr1073746638 !@expr1073746639 ast@var1545 ) {
54: return ; }
55:
56: std ::@expr1073746640 stack < T *@expr4817 , std ::@expr1073746642 vector < T *@expr4817 > > tokens@var1547 ;
57: T * tok@var1548 ; tok@var1548 =@expr1073746644 ast@var1545 ;
58: do {
59: ChildrenToVisit c@var1549 ; c@var1549 =@expr1073746645 visitor@var1546 (@expr1073746646 tok@var1548 ) ;
60:
61: if (@expr1073746647 c@var1549 ==@expr1073746648 ChildrenToVisit ::@expr1073746649 done ) {
62: break ; }
63: if (@expr1073746650 c@var1549 ==@expr1073746651 ChildrenToVisit ::@expr1073746652 op2 ||@expr1073746653 c@var1549 ==@expr4830 ChildrenToVisit ::@expr4831 op1_and_op2 ) {
64: T * t2@var1550 ; t2@var1550 =@expr1073746656 tok@var1548 .@expr1073746657 astOperand2 (@expr1073746658 ) ;
65: if (@expr1073746659 t2@var1550 ) {
66: tokens@var1547 .@expr4836 push (@expr1073746661 t2@var1550 ) ; }
67: }
68: if (@expr1073746662 c@var1549 ==@expr1073746663 ChildrenToVisit ::@expr1073746664 op1 ||@expr1073746665 c@var1549 ==@expr4830 ChildrenToVisit ::@expr4831 op1_and_op2 ) {
69: T * t1@var1551 ; t1@var1551 =@expr1073746668 tok@var1548 .@expr1073746669 astOperand1 (@expr1073746670 ) ;
70: if (@expr1073746671 t1@var1551 ) {
71: tokens@var1547 .@expr4836 push (@expr1073746673 t1@var1551 ) ; }
72: }
73:
74: if (@expr1073746674 tokens@var1547 .@expr1073746675 empty (@expr1073746676 ) ) {
75: break ; }
76:
77: tok@var1548 =@expr1073746677 tokens@var1547 .@expr1073746678 top (@expr1073746679 ) ;
78: tokens@var1547 .@expr1073746680 pop (@expr1073746681 ) ;
79: } while (@expr1073746682 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1552 , const std :: function < bool ( const Token * ) > & pred@var1553 ) ;
83: const Token * findExpression ( const int exprid@var1554 ,
84: const Token * start@var1555 ,
85: const Token * end@var1556 ,
86: const std :: function < bool ( const Token * ) > & pred@var1557 ) ;
87: const Token * findExpression ( const Token * start@var1558 , const int exprid@var1559 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1560 , const char * op@var1561 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1562 , const char * op@var1563 ) ;
91:
92: int astCount ( const Token * tok@var1564 , const char * op@var1565 , int depth@var1566 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1567 , const Token * tok@var1568 ) ;
95:
96: bool astHasVar ( const Token * tok@var1569 , int varid@var1570 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1571 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1572 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1573 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1574 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1575 , bool unknown@var1576 ) ;
107: bool astIsUnsigned ( const Token * tok@var1577 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1578 , bool unknown@var1579 ) ;
110:
111: bool astIsBool ( const Token * tok@var1580 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1581 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1582 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1583 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1584 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1585 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1586 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1587 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1588 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1589 , const std :: string & comp@var1590 , const std :: string & rhs@var1591 , const Token * * vartok@var1592 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1593 ) ;
140:
141: bool isTemporary ( bool cpp@var1594 , const Token * tok@var1595 , const Library * library@var1596 , bool unknown@var1597 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1598 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1599 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1600 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1601 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1602 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1603 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1604 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1605 ) ;
155: const Token * getParentLifetime ( bool cpp@var1606 , const Token * tok@var1607 , const Library * library@var1608 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1609 ) ;
158: bool astIsRHS ( const Token * tok@var1610 ) ;
159:
160: Token * getCondTok ( Token * tok@var1611 ) ;
161: const Token * getCondTok ( const Token * tok@var1612 ) ;
162:
163: Token * getInitTok ( Token * tok@var1613 ) ;
164: const Token * getInitTok ( const Token * tok@var1614 ) ;
165:
166: Token * getStepTok ( Token * tok@var1615 ) ;
167: const Token * getStepTok ( const Token * tok@var1616 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1617 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1618 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1619 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1620 ,
180: int * const varid@var1621 ,
181: bool * const knownInitValue@var1622 ,
182: long long * const initValue@var1623 ,
183: bool * const partialCond@var1624 ,
184: long long * const stepValue@var1625 ,
185: long long * const lastValue@var1626 ) ;
186:
187: bool precedes ( const Token * tok1@var1627 , const Token * tok2@var1628 ) ;
188: bool succeeds ( const Token * tok1@var1629 , const Token * tok2@var1630 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1631 , bool onVar@var1632 = true , int depth@var1633 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1634 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1635 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1636 ,
198: bool temporary@var1637 = true ,
199: bool inconclusive@var1638 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1639 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1640 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1641 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1642 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1643 , bool macro@var1644 , const Token * tok1@var1645 , const Token * tok2@var1646 , const Library & library@var1647 , bool pure@var1648 , bool followVar@var1649 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1650 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1651 , const Token * const tok2@var1652 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1653 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1654 , bool cpp@var1655 , const Token * const cond1@var1656 , const Token * const cond2@var1657 , const Library & library@var1658 , bool pure@var1659 , bool followVar@var1660 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1661 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1662 , const Token * const tok1@var1663 , const Token * const tok2@var1664 , const Library & library@var1665 , bool pure@var1666 , bool followVar@var1667 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1668 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1669 , const Library & library@var1670 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1671 , const Library & library@var1672 , bool pure@var1673 , bool cpp@var1674 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1675 , const Token * tok@var1676 , bool checkArrayAccess@var1677 = false , bool checkReference@var1678 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1679 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1680 , const Library * library@var1681 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1682 ,
238: const Library * library@var1683 = nullptr ,
239: const Token * * unknownFunc@var1684 = nullptr ,
240: bool functionScope@var1685 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1686 ,
244: const Variable * var@var1687 ,
245: Scope :: ScopeType type@var1688 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1689 , int & argn@var1690 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1691 , int & argn@var1692 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1693 , int argnr@var1694 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1695 , int indirect@var1696 , int varid@var1697 , const Settings * settings@var1698 , bool * inconclusive@var1699 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1700 , int indirect@var1701 , const Settings * settings@var1702 , bool * inconclusive@var1703 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1704 , const Token * end@var1705 , const int exprid@var1706 , bool globalvar@var1707 , const Settings * settings@var1708 , bool cpp@var1709 , int depth@var1710 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1711 , const Token * end@var1712 , int indirect@var1713 , const int exprid@var1714 , bool globalvar@var1715 , const Settings * settings@var1716 , bool cpp@var1717 , int depth@var1718 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1719 , int indirect@var1720 , const Settings * settings@var1721 , bool cpp@var1722 , int depth@var1723 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1724 , const Settings * settings@var1725 , bool cpp@var1726 , int depth@var1727 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1728 ,
283: const Token * end@var1729 ,
284: int indirect@var1730 ,
285: std :: vector < const Variable * > vars@var1731 ,
286: const Settings * settings@var1732 ,
287: bool cpp@var1733 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1734 , int indirect@var1735 , const Settings * settings@var1736 , bool cpp@var1737 ) ;
290: bool isThisChanged ( const Token * start@var1738 , const Token * end@var1739 , int indirect@var1740 , const Settings * settings@var1741 , bool cpp@var1742 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1743 , const Token * end@var1744 , int indirect@var1745 , const int exprid@var1746 , bool globalvar@var1747 , const Settings * settings@var1748 , bool cpp@var1749 , int depth@var1750 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1751 , const Token * end@var1752 , int indirect@var1753 , const int exprid@var1754 , bool globalvar@var1755 , const Settings * settings@var1756 , bool cpp@var1757 , int depth@var1758 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1759 ,
296: const Token * start@var1760 ,
297: const Token * end@var1761 ,
298: const Settings * settings@var1762 ,
299: bool cpp@var1763 ,
300: int depth@var1764 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1765 ,
303: const Token * tok@var1766 ,
304: int indirect@var1767 ,
305: bool globalvar@var1768 ,
306: const Settings * settings@var1769 ,
307: bool cpp@var1770 ,
308: int depth@var1771 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1772 , int varid@var1773 , bool * inconclusive@var1774 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1775 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1776 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1777 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1778 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1779 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1780 , const Function * f@var1781 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1782 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1783 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1784 ) ;
346: Token * findLambdaEndToken ( Token * first@var1785 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1786 , const Token * stream@var1787 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1788 , const Token * op@var1789 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1790 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1791 , const char * skipMatch@var1792 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1793 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1794 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1795 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1796 , const Library & library@var1797 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1798 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1799 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1800 , bool cpp@var1801 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1802 , const Library & library@var1803 ) : mCpp@var1836 ( cpp@var1802 ) , mLibrary@var1837 ( library@var1803 ) , mWhat@var1838 ( What :: Reassign ) , mValueFlowKnown@var1840 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1804 , const Token * lhs@var1805 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1806 , const Token * startToken@var1807 , const Token * endToken@var1808 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1809 , const Token * startToken@var1810 , const Token * endToken@var1811 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1812 ;
407: const Token * token@var1813 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1814 , const Token * startToken@var1815 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1816 , bool * localOut@var1817 = nullptr , bool * unknownVarIdOut@var1818 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1819 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1820 ;
420: explicit Result ( Type type@var1821 ) : type@var1820 ( type@var1821 ) , token@var1824 ( nullptr ) { }
421: Result ( Type type@var1822 , const Token * token@var1823 ) : type@var1820 ( type@var1822 ) , token@var1824 ( token@var1823 ) { }
422: const Token * token@var1824 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1825 , const Token * startToken@var1826 , const Token * endToken@var1827 ) ;
426: struct Result checkRecursive ( const Token * expr@var1828 , const Token * startToken@var1829 , const Token * endToken@var1830 , const std :: set < int > & exprVarIds@var1831 , bool local@var1832 , bool inInnerClass@var1833 , int depth@var1834 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1835 ) const ;
430:
431: const bool mCpp@var1836 ;
432: const Library & mLibrary@var1837 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1838 ;
434: std :: vector < KnownAndToken > mValueFlow@var1839 ;
435: bool mValueFlowKnown@var1840 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1841 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1842 ) {
44: if (@expr1073746683 bit@var1842 >=@expr1073746684 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746685 (@expr1073746686 1LL <<@expr1073746687 (@expr1073746688 bit@var1842 -@expr1073746689 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1843 ) {
50: if (@expr1073746690 bit@var1843 >=@expr1073746691 64 ) {
51: return (@expr4868 ~@expr1073746693 0ULL ) >>@expr1073746694 1 ; }
52: return (@expr4868 1LL <<@expr1073746696 (@expr4868 bit@var1843 -@expr1073746698 1 ) ) -@expr1073746699 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1844 ) const {
59: return value@var1844 >=@expr1073746700 min_value (@expr1073746701 int_bit@var1854 ) &&@expr1073746702 value@var1844 <=@expr1073746703 max_value (@expr1073746704 int_bit@var1854 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1845 ) const {
63: unsigned long long intMax@var1846 ; intMax@var1846 =@expr1073746705 max_value (@expr1073746706 int_bit@var1854 ) ;
64: return value@var1845 <=@expr1073746707 intMax@var1846 ;
65: }
66:
67: bool isLongValue ( long long value@var1847 ) const {
68: return value@var1847 >=@expr1073746708 min_value (@expr1073746709 long_bit@var1855 ) &&@expr1073746710 value@var1847 <=@expr1073746711 max_value (@expr1073746712 long_bit@var1855 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1848 ) const {
72: unsigned long long longMax@var1849 ; longMax@var1849 =@expr1073746713 max_value (@expr1073746714 long_bit@var1855 ) ;
73: return value@var1848 <=@expr1073746715 longMax@var1849 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1850 ) const {
77: unsigned long long longLongMax@var1851 ; longLongMax@var1851 =@expr1073746716 max_value (@expr1073746717 long_long_bit@var1856 ) ;
78: return value@var1850 <=@expr1073746718 longLongMax@var1851 ;
79: }
80:
81: int char_bit@var1852 ;
82: int short_bit@var1853 ;
83: int int_bit@var1854 ;
84: int long_bit@var1855 ;
85: int long_long_bit@var1856 ;
86:
87:
88: int sizeof_bool@var1857 ;
89: int sizeof_short@var1858 ;
90: int sizeof_int@var1859 ;
91: int sizeof_long@var1860 ;
92: int sizeof_long_long@var1861 ;
93: int sizeof_float@var1862 ;
94: int sizeof_double@var1863 ;
95: int sizeof_long_double@var1864 ;
96: int sizeof_wchar_t@var1865 ;
97: int sizeof_size_t@var1866 ;
98: int sizeof_pointer@var1867 ;
99:
100: char defaultSign@var1868 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1869 ;
115:
116:
117: bool platform ( PlatformType type@var1870 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1871 [ ] , const std :: string & filename@var1872 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1873 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1869 ==@expr1073746719 Win32A ||@expr1073746720
136: platformType@var1869 ==@expr1073746721 Win32W ||@expr1073746722
137: platformType@var1869 ==@expr1073746723 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746724 platformType@var1869 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1874 ) {
145: switch (@expr1073746725 pt@var1874 ) {
146: case Unspecified :@expr4902 ;
147: return "Unspecified" ;
148: case Native :@expr4902 ;
149: return "Native" ;
150: case Win32A :@expr4902 ;
151: return "win32A" ;
152: case Win32W :@expr4902 ;
153: return "win32W" ;
154: case Win64 :@expr4902 ;
155: return "win64" ;
156: case Unix32 :@expr4902 ;
157: return "unix32" ;
158: case Unix64 :@expr4902 ;
159: return "unix64" ;
160: case PlatformFile :@expr4902 ;
161: return "platformFile" ;
162: default :@expr4902 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746735 char_bit@var1852 +@expr1073746736 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746737 char_bit@var1852 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746738 char_bit@var1852 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1875 , const std :: string & rhs@var1876 ) const {
41: return caseInsensitiveStringCompare (@expr1073746739 lhs@var1875 , rhs@var1876 ) <@expr1073746740 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1884 ( cppcheck :: Platform :: Unspecified ) , msc@var1885 ( false ) , useMfc@var1886 ( false ) { }
67: std :: string cfg@var1877 ;
68: std :: string filename@var1878 ;
69: std :: string defines@var1879 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1879 +@expr1073746741 (@expr1073746742 msc@var1885 ?@expr1073746743 ";_MSC_VER=1900" :@expr1073746744 "" ) +@expr1073746745 (@expr1073746746 useMfc@var1886 ?@expr1073746747 ";__AFXWIN_H__=1" :@expr1073746748 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1880 ;
74: std :: list < std :: string > includePaths@var1881 ;
75: std :: list < std :: string > systemIncludePaths@var1882 ;
76: std :: string standard@var1883 ;
77: cppcheck :: Platform :: PlatformType platformType@var1884 ;
78: bool msc@var1885 ;
79: bool useMfc@var1886 ;
80:
81: void parseCommand ( std :: string command@var1887 ) ;
82: void setDefines ( std :: string defs@var1888 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1889 , const std :: list < std :: string > & in@var1890 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1891 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1892 ;
86: Type projectType@var1893 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1894 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var1895 ;
97: std :: vector < std :: string > pathNames@var1896 ;
98: std :: list < std :: string > libraries@var1897 ;
99: std :: list < std :: string > excludedPaths@var1898 ;
100: std :: list < std :: string > checkVsConfigs@var1899 ;
101: std :: string projectFile@var1900 ;
102: std :: string platform@var1901 ;
103: } ; struct Anonymous4 guiProject@var1902 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1903 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1904 ) ;
107:
108: Type import ( const std :: string & filename@var1905 , Settings * settings@var1906 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1907 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1908 , Settings * settings@var1909 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1910 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1911 , const std :: string & path@var1912 , const std :: vector < std :: string > & fileFilters@var1913 ) ;
115: bool importVcxproj ( const std :: string & filename@var1914 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1915 , const std :: string & additionalIncludeDirectories@var1916 , const std :: vector < std :: string > & fileFilters@var1917 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1918 ) ;
117:
118: static void printError ( const std :: string & message@var1919 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1920 ) ;
121:
122: std :: string mPath@var1921 ;
123: std :: set < std :: string > mAllVSConfigs@var1922 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1923 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1924 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1925 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1926 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1927 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1928 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1929 [ 7 ] = "parser" ;
135: const char BugHunting@var1930 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1931 [ 11 ] = "includedir" ;
137: const char DirElementName@var1932 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1933 [ 5 ] = "name" ;
139: const char DefinesElementName@var1934 [ 8 ] = "defines" ;
140: const char DefineName@var1935 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1936 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1937 [ 10 ] = "undefines" ;
143: const char UndefineName@var1938 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1939 [ 6 ] = "paths" ;
145: const char PathName@var1940 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1941 [ 5 ] = "name" ;
147: const char RootPathName@var1942 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1943 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1944 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1945 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1946 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1947 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1948 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1949 [ 5 ] = "name" ;
155: const char FunctionContracts@var1950 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1951 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1952 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1953 [ 8 ] = "library" ;
159: const char PlatformElementName@var1954 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1955 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1956 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1957 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1958 [ 7 ] = "addons" ;
164: const char ToolElementName@var1959 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1960 [ 6 ] = "tools" ;
166: const char TagsElementName@var1961 [ 5 ] = "tags" ;
167: const char TagElementName@var1962 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1963 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1964 [ 4 ] = "tag" ;
170: const char WarningElementName@var1965 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1966 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1967 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1968 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1969 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1970 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1971 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1972 [ 11 ] = "clang-tidy" ;
178: const char Name@var1973 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1974 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1975 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1976 ;
43: std :: string errorId@var1977 ;
44: void setFileName ( const std :: string & s@var1978 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1982 ;
47: }
48: int lineNumber@var1979 ;
49: Certainty :: CertaintyLevel certainty@var1980 ;
50: std :: string symbolNames@var1981 ;
51: private:
52: std :: string mFileName@var1982 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2016 ( NO_LINE ) , hash@var2018 ( 0 ) , thisAndNextLine@var2019 ( false ) , matched@var2020 ( false ) , checked@var2021 ( false ) { }
57: Suppression ( const Suppression & other@var1983 ) {
58: *@expr1073746749 this@expr1073746750 =@expr1073746751 other@var1983 ;
59: }
60: Suppression ( const std :: string & id@var1984 , const std :: string & file@var1985 , int line@var1986 = NO_LINE ) : errorId@var2014 ( id@var1984 ) , fileName@var2015 ( file@var1985 ) , lineNumber@var2016 ( line@var1986 ) , hash@var2018 ( 0 ) , thisAndNextLine@var2019 ( false ) , matched@var2020 ( false ) , checked@var2021 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1987 ) {
63: errorId@var2014 =@expr1073746752 other@var1987 .@expr1073746753 errorId@var1988 ;
64: fileName@var2015 =@expr1073746754 other@var1987 .@expr1073746755 fileName@var1989 ;
65: lineNumber@var2016 =@expr1073746756 other@var1987 .@expr1073746757 lineNumber@var1990 ;
66: symbolName@var2017 =@expr1073746758 other@var1987 .@expr1073746759 symbolName@var1991 ;
67: hash@var2018 =@expr1073746760 other@var1987 .@expr1073746761 hash@var1992 ;
68: thisAndNextLine@var2019 =@expr1073746762 other@var1987 .@expr1073746763 thisAndNextLine@var1993 ;
69: matched@var2020 =@expr1073746764 other@var1987 .@expr1073746765 matched@var1994 ;
70: checked@var2021 =@expr1073746766 other@var1987 .@expr1073746767 checked@var1995 ;
71: return *@expr1073746768 this@expr1073746769 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1996 ) const {
75: if (@expr1073746770 errorId@var2014 !=@expr1073746771 other@var1996 .@expr4948 errorId@var1997 ) {
76: return errorId@var2014 <@expr1073746773 other@var1996 .@expr4948 errorId@var1997 ; }
77: if (@expr1073746775 lineNumber@var2016 <@expr1073746776 other@var1996 .@expr1073746777 lineNumber@var1998 ) {
78: return true ; }
79: if (@expr1073746778 fileName@var2015 !=@expr1073746779 other@var1996 .@expr4956 fileName@var1999 ) {
80: return fileName@var2015 <@expr1073746781 other@var1996 .@expr4956 fileName@var1999 ; }
81: if (@expr1073746783 symbolName@var2017 !=@expr1073746784 other@var1996 .@expr4961 symbolName@var2000 ) {
82: return symbolName@var2017 <@expr1073746786 other@var1996 .@expr4961 symbolName@var2000 ; }
83: if (@expr1073746788 hash@var2018 !=@expr1073746789 other@var1996 .@expr4966 hash@var2001 ) {
84: return hash@var2018 <@expr1073746791 other@var1996 .@expr4966 hash@var2001 ; }
85: if (@expr1073746793 thisAndNextLine@var2019 !=@expr1073746794 other@var1996 .@expr1073746795 thisAndNextLine@var2002 ) {
86: return thisAndNextLine@var2019 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2003 , std :: string * errorMessage@var2004 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2005 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2006 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746797 fileName@var2015 .@expr1073746798 empty (@expr1073746799 ) &&@expr1073746800 fileName@var2015 .@expr1073746801 find_first_of (@expr1073746802 "?*" ) ==@expr1073746803 std ::@expr1073746804 string ::@expr1073746805 npos@expr1073746796 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2007 ) const {
109: return errorId@var2014 ==@expr1073746806 other@var2007 .@expr1073746807 errorId@var2008 &&@expr1073746808
110: fileName@var2015 ==@expr1073746809 other@var2007 .@expr1073746810 fileName@var2009 &&@expr1073746811
111: lineNumber@var2016 ==@expr1073746812 other@var2007 .@expr1073746813 lineNumber@var2010 &&@expr1073746814
112: symbolName@var2017 ==@expr1073746815 other@var2007 .@expr1073746816 symbolName@var2011 &&@expr1073746817
113: hash@var2018 ==@expr1073746818 other@var2007 .@expr1073746819 hash@var2012 &&@expr1073746820
114: thisAndNextLine@var2019 ==@expr1073746821 other@var2007 .@expr1073746822 thisAndNextLine@var2013 ;
115: }
116:
117: std :: string errorId@var2014 ;
118: std :: string fileName@var2015 ;
119: int lineNumber@var2016 ;
120: std :: string symbolName@var2017 ;
121: unsigned long hash@var2018 ;
122: bool thisAndNextLine@var2019 ;
123: bool matched@var2020 ;
124: bool checked@var2021 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2022 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2023 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2024 , std :: string * errorMessage@var2025 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2026 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2027 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2028 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2029 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2030 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2031 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2032 , const bool unusedFunctionChecking@var2033 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2034 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2035 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2036 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2037 , std :: clock_t clocks@var2038 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2039 ;
45: long mNumberOfResults@var2040 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2039 ( 0 )
49: , mNumberOfResults@var2040 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2041 =@expr1073746824 (@expr1073746825 double ) (@expr1073746826 (@expr1073746827 unsigned long ) mClocks@var2039 ) /@expr1073746828 (@expr1073746829 double ) CLOCKS_PER_SEC@expr1073746823 ;
53: return ret@var2041 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2042 ) const ;
62: void addResults ( const std :: string & str@var2043 , std :: clock_t clocks@var2044 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2045 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2046 , SHOWTIME_MODES showtimeMode@var2047 , TimerResultsIntf * timerResults@var2048 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2049 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2050 ;
79: TimerResultsIntf * mTimerResults@var2051 ;
80: std :: clock_t mStart@var2052 ;
81: const SHOWTIME_MODES mShowTimeMode@var2053 ;
82: bool mStopped@var2054 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2055 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2056 ;
103:
104:
105: std :: string addonPython@var2057 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2058 ;
109:
110:
111: std :: string buildDir@var2059 ;
112:
113:
114: bool checkAllConfigurations@var2060 ;
115:
116:
117: bool checkConfiguration@var2061 ;
118:
|
121:
122: bool checkHeaders@var2062 ;
123:
124:
125: bool checkLibrary@var2063 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2064 ;
129:
130:
131: bool checkUnusedTemplates@var2065 ;
132:
133:
134: bool clang@var2066 ;
135:
136:
137: std :: string clangExecutable@var2067 ;
138:
139:
140: bool clangTidy@var2068 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2069 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2070 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2071 ;
150:
151:
152: bool daca@var2072 ;
153:
154:
155: bool debugnormal@var2073 ;
156:
157:
158: bool debugSimplified@var2074 ;
159:
160:
161: bool debugtemplate@var2075 ;
162:
163:
164: bool debugwarnings@var2076 ;
165:
166:
167: bool dump@var2077 ;
168: std :: string dumpFile@var2078 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2079 ;
176:
177:
178: bool exceptionHandling@var2080 ;
179:
180:
181: std :: string exename@var2081 ;
182:
183:
184:
185: int exitCode@var2082 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2083 ;
189:
190:
191: bool force@var2084 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2085 ;
196:
197:
198: bool inlineSuppressions@var2086 ;
199:
200:
201:
202: unsigned int jobs@var2087 ;
203:
|
206:
207: bool jointSuppressionReport@var2088 ;
208:
209:
210: std :: list < std :: string > libraries@var2089 ;
211:
212:
213: Library library@var2090 ;
214:
215:
216:
217: int loadAverage@var2091 ;
218:
|
221:
222: int maxConfigs@var2092 ;
223:
224:
225: int maxCtuDepth@var2093 ;
226:
227:
228: int maxTemplateRecursion@var2094 ;
229:
230:
231: Suppressions nofail@var2095 ;
232:
233:
234: Suppressions nomsg@var2096 ;
235:
236:
237: std :: string outputFile@var2097 ;
238:
239:
240: std :: string plistOutput@var2098 ;
241:
242:
243: bool preprocessOnly@var2099 ;
244:
245: ImportProject project@var2100 ;
246:
247:
248: bool quiet@var2101 ;
249:
250:
251: bool relativePaths@var2102 ;
252:
253:
254: bool reportProgress@var2103 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2104 ( "simple" )
261: , id@var2106 ( "rule" )
262: , severity@var2108 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2104 ;
266: std :: string pattern@var2105 ;
267: std :: string id@var2106 ;
268: std :: string summary@var2107 ;
269: Severity :: SeverityType severity@var2108 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2109 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2115 ( false ) , externalFunctions@var2116 ( false ) , internalFunctions@var2117 ( false ) , externalVariables@var2118 ( false ) { }
281:
282: static const char XmlRootName@var2110 [ ] ;
283: static const char XmlClasses@var2111 [ ] ;
284: static const char XmlExternalFunctions@var2112 [ ] ;
285: static const char XmlInternalFunctions@var2113 [ ] ;
286: static const char XmlExternalVariables@var2114 [ ] ;
287:
288: void clear ( ) {
289: classes@var2115 =@expr1073746830 externalFunctions@var2116 =@expr1073746831 internalFunctions@var2117 =@expr1073746832 externalVariables@var2118 =@expr1073746833 false ;
290: }
291:
|
297:
298: bool classes@var2115 ;
299:
|
304:
305: bool externalFunctions@var2116 ;
306:
|
310:
311: bool internalFunctions@var2117 ;
312:
|
316:
317: bool externalVariables@var2118 ;
318: } ;
319:
320: SafeChecks safeChecks@var2119 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2120 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2121 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2122 ;
325:
326:
327: SHOWTIME_MODES showtime@var2123 ;
328:
329:
330: Standards standards@var2124 ;
331:
332:
333:
334: std :: string templateFormat@var2125 ;
335:
336:
337:
338: std :: string templateLocation@var2126 ;
339:
340:
341: std :: string userDefines@var2127 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2128 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2129 ;
348:
349:
350: bool verbose@var2130 ;
351:
352:
353: bool xml@var2131 ;
354:
355:
356: int xml_version@var2132 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2133 ) const {
363: for (@expr1073746834 const std ::@expr1073746835 string &@expr1073746836 configExcludePath@var2134 :@expr1073746837 configExcludePaths@var2069 ) {
364: if (@expr1073746838 file@var2133 .@expr1073746839 length (@expr1073746840 ) >=@expr1073746841 configExcludePath@var2134 .@expr5018 length (@expr5019 ) &&@expr1073746844 file@var2133 .@expr1073746845 compare (@expr1073746846 0 , configExcludePath@var2134 .@expr5018 length (@expr5019 ) , configExcludePath@var2134 ) ==@expr1073746849 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2135 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2136 , bool inconclusiveCheck@var2137 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746850 find (@expr1073746851 libraries@var2089 .@expr1073746852 begin (@expr1073746853 ) , libraries@var2089 .@expr5030 end (@expr5031 ) , "posix" ) !=@expr1073746856 libraries@var2089 .@expr5030 end (@expr5031 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2138 = true ) {
392: Settings ::@expr1073746859 mTerminated@var2055 =@expr1073746860 t@var2138 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746861 mTerminated@var2055 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2139 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2140 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2141 ) {
47: mSettings@var2176 =@expr1073746862 settings@var2141 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2176 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2178 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2179 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2142 ) ;
72:
73: void addtoken ( const std :: string & str@var2143 , const int lineno@var2144 , const int column@var2145 , const int fileno@var2146 , bool split@var2147 = false ) ;
74: void addtoken ( const std :: string & str@var2148 , const Token * locationTok@var2149 ) ;
75:
76: void addtoken ( const Token * tok@var2150 , const int lineno@var2151 , const int column@var2152 , const int fileno@var2153 ) ;
77: void addtoken ( const Token * tok@var2154 , const Token * locationTok@var2155 ) ;
78: void addtoken ( const Token * tok@var2156 ) ;
79:
80: static void insertTokens ( Token * dest@var2157 , const Token * src@var2158 , int n@var2159 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2160 , const Token * first@var2161 , const Token * last@var2162 , bool one_line@var2163 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2164 , const std :: string & file0@var2165 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2166 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2167 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2173 .@expr1073746863 front@var2180 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2173 .@expr1073746864 front@var2180 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2173 .@expr1073746865 back@var2181 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2173 .@expr1073746866 back@var2181 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2174 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2168 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2169 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2170 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2171 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2172 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2173 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2174 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2175 ;
212:
213:
214: const Settings * mSettings@var2176 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2177 ;
217:
218:
219: bool mIsC@var2178 ;
220: bool mIsCpp@var2179 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2182 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2183 ;
67: mutable int mVarId@var2184 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2185 ) ;
73: bool hasVariable ( const std :: string & varname@var2186 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2187 ) const {
75: return mVariableId@var2182 .@expr1073746867 find (@expr1073746868 varname@var2187 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2182 .@expr1073746869 end (@expr1073746870 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2182 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746871 mVarId@var2184 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2188 , ErrorLogger * errorLogger@var2189 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2190 ) {
95: mTimerResults@var2310 =@expr1073746872 tr@var2190 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2288 .@expr1073746873 isC (@expr1073746874 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2288 .@expr1073746875 isCPP (@expr1073746876 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2191 , bool * unknown@var2192 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2193 , const std :: string & FileName@var2194 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2195 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2196 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2197 ,
142: const char FileName@var2198 [ ] ,
143: const std :: string & configuration@var2199 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2200 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2201 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2202 , const Token * end@var2203 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2204 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2205 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2206 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2207 , const Token * const tokEnd@var2208 , const bool only_k_r_fpar@var2209 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2210 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2211 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2212 , bool commandWithCondition@var2213 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2214 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2215 , Token * * _tok2@var2216 , Token * * _tok3@var2217 , std :: string & value@var2218 , int & valueVarId@var2219 , bool & valueIsPointer@var2220 , bool floatvar@var2221 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2222 , Token * tok3@var2223 , int varid@var2224 , const std :: string & structname@var2225 , std :: string & value@var2226 , int valueVarId@var2227 , bool valueIsPointer@var2228 , const Token * const valueToken@var2229 , int indentlevel@var2230 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2231 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2232 , const std :: string & endsWith@var2233 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2234 , const std :: string & endsWith@var2235 , bool cpp@var2236 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2237 ) {
585: mPreprocessor@var2311 =@expr1073746877 preprocessor@var2237 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2311 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2238 , const Token * end@var2239 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2240 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2241 , const std :: string & code@var2242 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2243 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2244 , const std :: string & what@var2245 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2246 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2247 , const std :: string & msg@var2248 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2249 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2250 , const std :: string & macroName@var2251 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2252 , const Token * end@var2253 , bool allowSemicolon@var2254 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2255 , const Severity :: SeverityType severity@var2256 , const std :: string & id@var2257 , const std :: string & msg@var2258 , bool inconclusive@var2259 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2260 , Severity :: SeverityType severity@var2261 , const std :: string & id@var2262 , const std :: string & msg@var2263 , bool inconclusive@var2264 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2265 , const Token * name@var2266 , const Token * typeDef@var2267 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2268 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2269 ,
821: const VariableMap & variableMap@var2270 ,
822: const int scopeStartVarId@var2271 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2272 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2273 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2274 ,
827: int * varId@var2275 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2276 ,
830: Token * const startToken@var2277 ,
831: const Token * const endToken@var2278 ,
832: const std :: map < std :: string , int > & varlist@var2279 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2280 ,
834: int * varId_@var2281 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2282 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2283 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2309 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2284 ) {
861: mSettings@var2295 =@expr1073746878 settings@var2284 ;
862: list@var2288 .@expr1073746879 setSettings (@expr1073746880 settings@var2284 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2297 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2285 ) const ;
877:
878: void dump ( std :: ostream & out@var2286 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2287 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2307 ;
888: }
889:
|
892:
893: TokenList list@var2288 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2288 .@expr1073746881 front (@expr1073746882 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2289 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2290 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2291 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2292 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2295 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2293 , bool inOperator@var2294 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746883 mVarId@var2307 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2295 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2296 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2297 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2298 ;
973:
974:
975:
976: std :: string mConfiguration@var2299 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2300 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2301 ;
983: std :: string filename@var2302 ;
984: int lineNumber@var2303 ;
985: int column@var2304 ;
986: bool used@var2305 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2306 ;
989:
990:
991: int mVarId@var2307 ;
992:
993:
994: int mUnnamedCount@var2308 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2309 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2310 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2311 ;
1013: } ;

##file cppcheck-2.8/lib/checkother.h

1:
|
31:
32: namespace ValueFlow {
33: class Value ;
34: }
35:
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class Function ;
40: class Variable ;
41: class ErrorLogger ;
42:
|
48:
49: class CheckOther : public Check {
50: public:
51:
52: CheckOther ( ) : Check ( myName ( ) ) { }
53:
54:
55: CheckOther ( const Tokenizer * tokenizer@var2312 , const Settings * settings@var2313 , ErrorLogger * errorLogger@var2314 )
56: : Check ( myName ( ) , tokenizer@var2312 , settings@var2313 , errorLogger@var2314 ) { }
57:
58:
59: void runChecks ( const Tokenizer * tokenizer@var2315 , const Settings * settings@var2316 , ErrorLogger * errorLogger@var2317 ) override {
60: CheckOther checkOther@var2318 (@expr1073746884 tokenizer@var2315 , settings@var2316 , errorLogger@var2317 ) ;
61:
62:
63: checkOther@var2318 .@expr1073746885 warningOldStylePointerCast (@expr1073746886 ) ;
64: checkOther@var2318 .@expr1073746887 invalidPointerCast (@expr1073746888 ) ;
65: checkOther@var2318 .@expr1073746889 checkCharVariable (@expr1073746890 ) ;
66: checkOther@var2318 .@expr1073746891 checkRedundantAssignment (@expr1073746892 ) ;
67: checkOther@var2318 .@expr1073746893 checkRedundantAssignmentInSwitch (@expr1073746894 ) ;
68: checkOther@var2318 .@expr1073746895 checkSuspiciousCaseInSwitch (@expr1073746896 ) ;
69: checkOther@var2318 .@expr1073746897 checkDuplicateBranch (@expr1073746898 ) ;
70: checkOther@var2318 .@expr1073746899 checkDuplicateExpression (@expr1073746900 ) ;
71: checkOther@var2318 .@expr1073746901 checkUnreachableCode (@expr1073746902 ) ;
72: checkOther@var2318 .@expr1073746903 checkSuspiciousSemicolon (@expr1073746904 ) ;
73: checkOther@var2318 .@expr1073746905 checkVariableScope (@expr1073746906 ) ;
74: checkOther@var2318 .@expr1073746907 checkSignOfUnsignedVariable (@expr1073746908 ) ;
75: checkOther@var2318 .@expr1073746909 checkIncompleteArrayFill (@expr1073746910 ) ;
76: checkOther@var2318 .@expr1073746911 checkVarFuncNullUB (@expr1073746912 ) ;
77: checkOther@var2318 .@expr1073746913 checkNanInArithmeticExpression (@expr1073746914 ) ;
78: checkOther@var2318 .@expr1073746915 checkCommaSeparatedReturn (@expr1073746916 ) ;
79: checkOther@var2318 .@expr1073746917 checkRedundantPointerOp (@expr1073746918 ) ;
80: checkOther@var2318 .@expr1073746919 checkZeroDivision (@expr1073746920 ) ;
81: checkOther@var2318 .@expr1073746921 checkNegativeBitwiseShift (@expr1073746922 ) ;
82: checkOther@var2318 .@expr1073746923 checkInterlockedDecrement (@expr1073746924 ) ;
83: checkOther@var2318 .@expr1073746925 checkUnusedLabel (@expr1073746926 ) ;
84: checkOther@var2318 .@expr1073746927 checkEvaluationOrder (@expr1073746928 ) ;
85: checkOther@var2318 .@expr1073746929 checkFuncArgNamesDifferent (@expr1073746930 ) ;
86: checkOther@var2318 .@expr1073746931 checkShadowVariables (@expr1073746932 ) ;
87: checkOther@var2318 .@expr1073746933 checkKnownArgument (@expr1073746934 ) ;
88: checkOther@var2318 .@expr1073746935 checkComparePointers (@expr1073746936 ) ;
89: checkOther@var2318 .@expr1073746937 checkIncompleteStatement (@expr1073746938 ) ;
90: checkOther@var2318 .@expr1073746939 checkPipeParameterSize (@expr1073746940 ) ;
91: checkOther@var2318 .@expr1073746941 checkRedundantCopy (@expr1073746942 ) ;
92: checkOther@var2318 .@expr1073746943 clarifyCalculation (@expr1073746944 ) ;
93: checkOther@var2318 .@expr1073746945 checkPassByReference (@expr1073746946 ) ;
94: checkOther@var2318 .@expr1073746947 checkConstVariable (@expr1073746948 ) ;
95: checkOther@var2318 .@expr1073746949 checkConstPointer (@expr1073746950 ) ;
96: checkOther@var2318 .@expr1073746951 checkComparisonFunctionIsAlwaysTrueOrFalse (@expr1073746952 ) ;
97: checkOther@var2318 .@expr1073746953 checkInvalidFree (@expr1073746954 ) ;
98: checkOther@var2318 .@expr1073746955 clarifyStatement (@expr1073746956 ) ;
99: checkOther@var2318 .@expr1073746957 checkCastIntToCharAndBack (@expr1073746958 ) ;
100: checkOther@var2318 .@expr1073746959 checkMisusedScopedObject (@expr1073746960 ) ;
101: checkOther@var2318 .@expr1073746961 checkAccessOfMovedVariable (@expr1073746962 ) ;
102: checkOther@var2318 .@expr1073746963 checkModuloOfOne (@expr1073746964 ) ;
103: checkOther@var2318 .@expr1073746965 checkOverlappingWrite (@expr1073746966 ) ;
104: }
105:
106:
107: static bool comparisonNonZeroExpressionLessThanZero ( const Token * tok@var2319 , const ValueFlow :: Value * * zeroValue@var2320 , const Token * * nonZeroExpr@var2321 ) ;
108:
109:
110: static bool testIfNonZeroExpressionIsPositive ( const Token * tok@var2322 , const ValueFlow :: Value * * zeroValue@var2323 , const Token * * nonZeroExpr@var2324 ) ;
111:
112:
113:
114: void clarifyCalculation ( ) ;
115:
116:
117: void clarifyStatement ( ) ;
118:
119:
120: void warningOldStylePointerCast ( ) ;
121:
122:
123: void invalidPointerCast ( ) ;
124:
125:
126: void checkVariableScope ( ) ;
127: static bool checkInnerScope ( const Token * tok@var2325 , const Variable * var@var2326 , bool & used@var2327 ) ;
128:
129:
130: void checkCommaSeparatedReturn ( ) ;
131:
132:
133: void checkPassByReference ( ) ;
134:
135: void checkConstVariable ( ) ;
136: void checkConstPointer ( ) ;
137:
138:
139: void checkCharVariable ( ) ;
140:
141:
142: void checkIncompleteStatement ( ) ;
143:
144:
145: void checkZeroDivision ( ) ;
146:
147:
148: void checkNanInArithmeticExpression ( ) ;
149:
150:
151: void checkRedundantAssignment ( ) ;
152:
153:
154: void checkRedundantAssignmentInSwitch ( ) ;
155:
156:
157: void checkSuspiciousCaseInSwitch ( ) ;
158:
159:
160: void checkMisusedScopedObject ( ) ;
161:
162:
163: void checkDuplicateBranch ( ) ;
164:
165:
166: void checkDuplicateExpression ( ) ;
167:
168:
169: void checkUnreachableCode ( ) ;
170:
171:
172: void checkSignOfUnsignedVariable ( ) ;
173:
174:
175: void checkSuspiciousSemicolon ( ) ;
176:
177:
178: void checkInvalidFree ( ) ;
179: void invalidFreeError ( const Token * tok@var2328 , const std :: string & allocation@var2329 , bool inconclusive@var2330 ) ;
180:
181:
182: void checkRedundantCopy ( ) ;
183:
184:
185: void checkNegativeBitwiseShift ( ) ;
186:
187:
188: void checkIncompleteArrayFill ( ) ;
189:
190:
191: void checkVarFuncNullUB ( ) ;
192:
193:
194: void checkPipeParameterSize ( ) ;
195:
196:
197: void checkCastIntToCharAndBack ( ) ;
198:
199:
200: void checkComparisonFunctionIsAlwaysTrueOrFalse ( ) ;
201:
202:
203: void checkRedundantPointerOp ( ) ;
204:
205:
206: void checkInterlockedDecrement ( ) ;
207:
208:
209: void checkUnusedLabel ( ) ;
210:
211:
212: void checkEvaluationOrder ( ) ;
213:
214:
215: void checkAccessOfMovedVariable ( ) ;
216:
217:
218: void checkFuncArgNamesDifferent ( ) ;
219:
220:
221: void checkShadowVariables ( ) ;
222:
223: void checkKnownArgument ( ) ;
224:
225: void checkComparePointers ( ) ;
226:
227: void checkModuloOfOne ( ) ;
228:
229: void checkOverlappingWrite ( ) ;
230: void overlappingWriteUnion ( const Token * tok@var2331 ) ;
231: void overlappingWriteFunction ( const Token * tok@var2332 ) ;
232:
233: private:
234:
235: void checkComparisonFunctionIsAlwaysTrueOrFalseError ( const Token * tok@var2333 , const std :: string & functionName@var2334 , const std :: string & varName@var2335 , const bool result@var2336 ) ;
236: void checkCastIntToCharAndBackError ( const Token * tok@var2337 , const std :: string & strFunctionName@var2338 ) ;
237: void checkPipeParameterSizeError ( const Token * tok@var2339 , const std :: string & strVarName@var2340 , const std :: string & strDim@var2341 ) ;
238: void clarifyCalculationError ( const Token * tok@var2342 , const std :: string & op@var2343 ) ;
239: void clarifyStatementError ( const Token * tok@var2344 ) ;
240: void cstyleCastError ( const Token * tok@var2345 ) ;
241: void invalidPointerCastError ( const Token * tok@var2346 , const std :: string & from@var2347 , const std :: string & to@var2348 , bool inconclusive@var2349 , bool toIsInt@var2350 ) ;
242: void passedByValueError ( const Token * tok@var2351 , const std :: string & parname@var2352 , bool inconclusive@var2353 ) ;
243: void constVariableError ( const Variable * var@var2354 , const Function * function@var2355 ) ;
244: void constStatementError ( const Token * tok@var2356 , const std :: string & type@var2357 , bool inconclusive@var2358 ) ;
245: void signedCharArrayIndexError ( const Token * tok@var2359 ) ;
246: void unknownSignCharArrayIndexError ( const Token * tok@var2360 ) ;
247: void charBitOpError ( const Token * tok@var2361 ) ;
248: void variableScopeError ( const Token * tok@var2362 , const std :: string & varname@var2363 ) ;
249: void zerodivError ( const Token * tok@var2364 , const ValueFlow :: Value * value@var2365 ) ;
250: void nanInArithmeticExpressionError ( const Token * tok@var2366 ) ;
251: void redundantAssignmentError ( const Token * tok1@var2367 , const Token * tok2@var2368 , const std :: string & var@var2369 , bool inconclusive@var2370 ) ;
252: void redundantInitializationError ( const Token * tok1@var2371 , const Token * tok2@var2372 , const std :: string & var@var2373 , bool inconclusive@var2374 ) ;
253: void redundantAssignmentInSwitchError ( const Token * tok1@var2375 , const Token * tok2@var2376 , const std :: string & var@var2377 ) ;
254: void redundantCopyError ( const Token * tok1@var2378 , const Token * tok2@var2379 , const std :: string & var@var2380 ) ;
255: void redundantCopyInSwitchError ( const Token * tok1@var2381 , const Token * tok2@var2382 , const std :: string & var@var2383 ) ;
256: void redundantBitwiseOperationInSwitchError ( const Token * tok@var2384 , const std :: string & varname@var2385 ) ;
257: void suspiciousCaseInSwitchError ( const Token * tok@var2386 , const std :: string & operatorString@var2387 ) ;
258: void selfAssignmentError ( const Token * tok@var2388 , const std :: string & varname@var2389 ) ;
259: void misusedScopeObjectError ( const Token * tok@var2390 , const std :: string & varname@var2391 ) ;
260: void duplicateBranchError ( const Token * tok1@var2392 , const Token * tok2@var2393 , std :: list < std :: pair < const Token * , std :: string > > errors@var2394 ) ;
261: void duplicateAssignExpressionError ( const Token * tok1@var2395 , const Token * tok2@var2396 , bool inconclusive@var2397 ) ;
262: void oppositeExpressionError ( const Token * opTok@var2398 , std :: list < std :: pair < const Token * , std :: string > > errors@var2399 ) ;
263: void duplicateExpressionError ( const Token * tok1@var2400 , const Token * tok2@var2401 , const Token * opTok@var2402 , std :: list < std :: pair < const Token * , std :: string > > errors@var2403 , bool hasMultipleExpr@var2404 = false ) ;
264: void duplicateValueTernaryError ( const Token * tok@var2405 ) ;
265: void duplicateExpressionTernaryError ( const Token * tok@var2406 , std :: list < std :: pair < const Token * , std :: string > > errors@var2407 ) ;
266: void duplicateBreakError ( const Token * tok@var2408 , bool inconclusive@var2409 ) ;
267: void unreachableCodeError ( const Token * tok@var2410 , bool inconclusive@var2411 ) ;
268: void unsignedLessThanZeroError ( const Token * tok@var2412 , const ValueFlow :: Value * v@var2413 , const std :: string & varname@var2414 ) ;
269: void pointerLessThanZeroError ( const Token * tok@var2415 , const ValueFlow :: Value * v@var2416 ) ;
270: void unsignedPositiveError ( const Token * tok@var2417 , const ValueFlow :: Value * v@var2418 , const std :: string & varname@var2419 ) ;
271: void pointerPositiveError ( const Token * tok@var2420 , const ValueFlow :: Value * v@var2421 ) ;
272: void suspiciousSemicolonError ( const Token * tok@var2422 ) ;
273: void negativeBitwiseShiftError ( const Token * tok@var2423 , int op@var2424 ) ;
274: void redundantCopyError ( const Token * tok@var2425 , const std :: string & varname@var2426 ) ;
275: void incompleteArrayFillError ( const Token * tok@var2427 , const std :: string & buffer@var2428 , const std :: string & function@var2429 , bool boolean@var2430 ) ;
276: void varFuncNullUBError ( const Token * tok@var2431 ) ;
277: void commaSeparatedReturnError ( const Token * tok@var2432 ) ;
278: void redundantPointerOpError ( const Token * tok@var2433 , const std :: string & varname@var2434 , bool inconclusive@var2435 , bool addressOfDeref@var2436 ) ;
279: void raceAfterInterlockedDecrementError ( const Token * tok@var2437 ) ;
280: void unusedLabelError ( const Token * tok@var2438 , bool inSwitch@var2439 , bool hasIfdef@var2440 ) ;
281: void unknownEvaluationOrder ( const Token * tok@var2441 ) ;
282: static bool isMovedParameterAllowedForInconclusiveFunction ( const Token * tok@var2442 ) ;
283: void accessMovedError ( const Token * tok@var2443 , const std :: string & varname@var2444 , const ValueFlow :: Value * value@var2445 , bool inconclusive@var2446 ) ;
284: void funcArgNamesDifferent ( const std :: string & functionName@var2447 , int index@var2448 , const Token * declaration@var2449 , const Token * definition@var2450 ) ;
285: void funcArgOrderDifferent ( const std :: string & functionName@var2451 , const Token * declaration@var2452 , const Token * definition@var2453 , const std :: vector < const Token * > & declarations@var2454 , const std :: vector < const Token * > & definitions@var2455 ) ;
286: void shadowError ( const Token * var@var2456 , const Token * shadowed@var2457 , std :: string type@var2458 ) ;
287: void knownArgumentError ( const Token * tok@var2459 , const Token * ftok@var2460 , const ValueFlow :: Value * value@var2461 , const std :: string & varexpr@var2462 , bool isVariableExpressionHidden@var2463 ) ;
288: void comparePointersError ( const Token * tok@var2464 , const ValueFlow :: Value * v1@var2465 , const ValueFlow :: Value * v2@var2466 ) ;
289: void checkModuloOfOneError ( const Token * tok@var2467 ) ;
290:
291: void getErrorMessages ( ErrorLogger * errorLogger@var2468 , const Settings * settings@var2469 ) const override {
292: CheckOther c@var2470 (@expr1073746967 nullptr , settings@var2469 , errorLogger@var2468 ) ;
293:
294: std ::@expr1073746968 list < std ::@expr5145 pair < const Token *@expr5146 , std ::@expr5145 string > > errorPath@var2471 ;
295:
296:
297: c@var2470 .@expr1073746972 zerodivError (@expr1073746973 nullptr , nullptr ) ;
298: c@var2470 .@expr1073746974 misusedScopeObjectError (@expr1073746975 nullptr , "varname" ) ;
299: c@var2470 .@expr1073746976 invalidPointerCastError (@expr1073746977 nullptr , "float *" , "double *" , false , false ) ;
300: c@var2470 .@expr5154 negativeBitwiseShiftError (@expr1073746979 nullptr , 1 ) ;
301: c@var2470 .@expr5154 negativeBitwiseShiftError (@expr1073746981 nullptr , 2 ) ;
302: c@var2470 .@expr1073746982 checkPipeParameterSizeError (@expr1073746983 nullptr , "varname" , "dimension" ) ;
303: c@var2470 .@expr1073746984 raceAfterInterlockedDecrementError (@expr1073746985 nullptr ) ;
304: c@var2470 .@expr1073746986 invalidFreeError (@expr1073746987 nullptr , "malloc" , false ) ;
305: c@var2470 .@expr1073746988 overlappingWriteUnion (@expr1073746989 nullptr ) ;
306: c@var2470 .@expr1073746990 overlappingWriteFunction (@expr1073746991 nullptr ) ;
307:
308:
309: c@var2470 .@expr5168 redundantCopyError (@expr1073746993 nullptr , "varname" ) ;
310: c@var2470 .@expr5168 redundantCopyError (@expr1073746995 nullptr , nullptr , "var" ) ;
311:
312:
313: c@var2470 .@expr1073746996 checkComparisonFunctionIsAlwaysTrueOrFalseError (@expr1073746997 nullptr , "isless" , "varName" , false ) ;
314: c@var2470 .@expr1073746998 checkCastIntToCharAndBackError (@expr1073746999 nullptr , "func_name" ) ;
315: c@var2470 .@expr1073747000 cstyleCastError (@expr1073747001 nullptr ) ;
316: c@var2470 .@expr1073747002 passedByValueError (@expr1073747003 nullptr , "parametername" , false ) ;
317: c@var2470 .@expr1073747004 constVariableError (@expr1073747005 nullptr , nullptr ) ;
318: c@var2470 .@expr1073747006 constStatementError (@expr1073747007 nullptr , "type" , false ) ;
319: c@var2470 .@expr1073747008 signedCharArrayIndexError (@expr1073747009 nullptr ) ;
320: c@var2470 .@expr1073747010 unknownSignCharArrayIndexError (@expr1073747011 nullptr ) ;
321: c@var2470 .@expr1073747012 charBitOpError (@expr1073747013 nullptr ) ;
322: c@var2470 .@expr1073747014 variableScopeError (@expr1073747015 nullptr , "varname" ) ;
323: c@var2470 .@expr1073747016 redundantAssignmentInSwitchError (@expr1073747017 nullptr , nullptr , "var" ) ;
324: c@var2470 .@expr1073747018 redundantCopyInSwitchError (@expr1073747019 nullptr , nullptr , "var" ) ;
325: c@var2470 .@expr1073747020 suspiciousCaseInSwitchError (@expr1073747021 nullptr , "||" ) ;
326: c@var2470 .@expr1073747022 selfAssignmentError (@expr1073747023 nullptr , "varname" ) ;
327: c@var2470 .@expr1073747024 clarifyCalculationError (@expr1073747025 nullptr , "+" ) ;
328: c@var2470 .@expr1073747026 clarifyStatementError (@expr1073747027 nullptr ) ;
329: c@var2470 .@expr1073747028 duplicateBranchError (@expr1073747029 nullptr , nullptr , errorPath@var2471 ) ;
330: c@var2470 .@expr1073747030 duplicateAssignExpressionError (@expr1073747031 nullptr , nullptr , true ) ;
331: c@var2470 .@expr1073747032 oppositeExpressionError (@expr1073747033 nullptr , errorPath@var2471 ) ;
332: c@var2470 .@expr1073747034 duplicateExpressionError (@expr1073747035 nullptr , nullptr , nullptr , errorPath@var2471 ) ;
333: c@var2470 .@expr1073747036 duplicateValueTernaryError (@expr1073747037 nullptr ) ;
334: c@var2470 .@expr1073747038 duplicateExpressionTernaryError (@expr1073747039 nullptr , errorPath@var2471 ) ;
335: c@var2470 .@expr1073747040 duplicateBreakError (@expr1073747041 nullptr , false ) ;
336: c@var2470 .@expr1073747042 unreachableCodeError (@expr1073747043 nullptr , false ) ;
337: c@var2470 .@expr1073747044 unsignedLessThanZeroError (@expr1073747045 nullptr , nullptr , "varname" ) ;
338: c@var2470 .@expr1073747046 unsignedPositiveError (@expr1073747047 nullptr , nullptr , "varname" ) ;
339: c@var2470 .@expr1073747048 pointerLessThanZeroError (@expr1073747049 nullptr , nullptr ) ;
340: c@var2470 .@expr1073747050 pointerPositiveError (@expr1073747051 nullptr , nullptr ) ;
341: c@var2470 .@expr1073747052 suspiciousSemicolonError (@expr1073747053 nullptr ) ;
342: c@var2470 .@expr1073747054 incompleteArrayFillError (@expr1073747055 nullptr , "buffer" , "memset" , false ) ;
343: c@var2470 .@expr1073747056 varFuncNullUBError (@expr1073747057 nullptr ) ;
344: c@var2470 .@expr1073747058 nanInArithmeticExpressionError (@expr1073747059 nullptr ) ;
345: c@var2470 .@expr1073747060 commaSeparatedReturnError (@expr1073747061 nullptr ) ;
346: c@var2470 .@expr1073747062 redundantPointerOpError (@expr1073747063 nullptr , "varname" , false , true ) ;
347: c@var2470 .@expr5240 unusedLabelError (@expr1073747065 nullptr , false , false ) ;
348: c@var2470 .@expr5240 unusedLabelError (@expr1073747067 nullptr , false , true ) ;
349: c@var2470 .@expr5240 unusedLabelError (@expr1073747069 nullptr , true , false ) ;
350: c@var2470 .@expr5240 unusedLabelError (@expr1073747071 nullptr , true , true ) ;
351: c@var2470 .@expr1073747072 unknownEvaluationOrder (@expr1073747073 nullptr ) ;
352: c@var2470 .@expr1073747074 accessMovedError (@expr1073747075 nullptr , "v" , nullptr , false ) ;
353: c@var2470 .@expr1073747076 funcArgNamesDifferent (@expr1073747077 "function" , 1 , nullptr , nullptr ) ;
354: c@var2470 .@expr1073747078 redundantBitwiseOperationInSwitchError (@expr1073747079 nullptr , "varname" ) ;
355: c@var2470 .@expr5256 shadowError (@expr1073747081 nullptr , nullptr , "variable" ) ;
356: c@var2470 .@expr5256 shadowError (@expr1073747083 nullptr , nullptr , "function" ) ;
357: c@var2470 .@expr5256 shadowError (@expr1073747085 nullptr , nullptr , "argument" ) ;
358: c@var2470 .@expr1073747086 knownArgumentError (@expr1073747087 nullptr , nullptr , nullptr , "x" , false ) ;
359: c@var2470 .@expr1073747088 comparePointersError (@expr1073747089 nullptr , nullptr , nullptr ) ;
360: c@var2470 .@expr1073747090 redundantAssignmentError (@expr1073747091 nullptr , nullptr , "var" , false ) ;
361: c@var2470 .@expr1073747092 redundantInitializationError (@expr1073747093 nullptr , nullptr , "var" , false ) ;
362:
363: const std ::@expr1073747094 vector < const Token *@expr5146 > nullvec@var2472 ;
364: c@var2470 .@expr1073747096 funcArgOrderDifferent (@expr1073747097 "function" , nullptr , nullptr , nullvec@var2472 , nullvec@var2472 ) ;
365: c@var2470 .@expr1073747098 checkModuloOfOneError (@expr1073747099 nullptr ) ;
366: }
367:
368: static std :: string myName ( ) {
369: return "Other" ;
370: }
371:
372: std :: string classInfo ( ) const override {
373: return "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n"
374:
|
428:
429: ;
430: }
431: } ;

##file cppcheck-2.8/lib/checkcondition.cpp

1:
|
45:
46: static const struct CWE uncheckedErrorConditionCWE@var2473 ( 391U ) ;
47: static const struct CWE CWE398@var2474 ( 398U ) ;
48: static const struct CWE CWE570@var2475 ( 570U ) ;
49: static const struct CWE CWE571@var2476 ( 571U ) ;
50:
|
53:
54: namespace {
55: CheckCondition instance@var2477 ;
56: }
57:
58: bool CheckCondition :: diag ( const Token * tok@var2478 , bool insert@var2479 )
59: {
60: if (@expr1073747100 !@expr1073747101 tok@var2478 ) {
61: return false ; }
62: const Token * parent@var2480 ; parent@var2480 =@expr1073747102 tok@var2478 .@expr1073747103 astParent (@expr1073747104 ) ;
63: bool hasParent@var2481 ; hasParent@var2481 =@expr1073747105 false ;
64: while (@expr1073747106 Token ::@expr1073747107 Match (@expr1073747108 parent@var2480 , "&&|%oror%" ) ) {
65: if (@expr1073747109 mCondDiags@var166 .@expr5286 count (@expr1073747111 parent@var2480 ) !=@expr1073747112 0 ) {
66: hasParent@var2481 =@expr1073747113 true ;
67: break ;
68: }
69: parent@var2480 =@expr1073747114 parent@var2480 .@expr1073747115 astParent (@expr1073747116 ) ;
70: }
71: if (@expr1073747117 mCondDiags@var166 .@expr5286 count (@expr1073747119 tok@var2478 ) ==@expr1073747120 0 &&@expr1073747121 !@expr1073747122 hasParent@var2481 ) {
72: if (@expr1073747123 insert@var2479 ) {
73: mCondDiags@var166 .@expr1073747124 insert (@expr1073747125 tok@var2478 ) ; }
74: return false ;
75: }
76: return true ;
77: }
78:
79: bool CheckCondition :: isAliased ( const std :: set < int > & vars@var2482 ) const
80: {
81: for (@expr1073747126 const Token *@expr1073747127 tok@var2483 =@expr1073747128 mTokenizer@var28 .@expr1073747129 tokens (@expr1073747130 ) ; tok@var2483 ; tok@var2483 =@expr1073747131 tok@var2483 .@expr1073747132 next (@expr1073747133 ) ) {
82: if (@expr1073747134 Token ::@expr1073747135 Match (@expr1073747136 tok@var2483 , "= & %var% ;" ) &&@expr1073747137 vars@var2482 .@expr1073747138 find (@expr1073747139 tok@var2483 .@expr1073747140 tokAt (@expr1073747141 2 ) .@expr1073747142 varId (@expr1073747143 ) ) !=@expr1073747144 vars@var2482 .@expr1073747145 end (@expr1073747146 ) ) {
83: return true ; }
84: }
85: return false ;
86: }
87:
88: void CheckCondition :: assignIf ( )
89: {
90: if (@expr1073747147 !@expr1073747148 mSettings@var29 .@expr1073747149 severity@var2951 .@expr1073747150 isEnabled (@expr1073747151 Severity ::@expr1073747152 style ) ) {
91: return ; }
92:
93: for (@expr1073747153 const Token *@expr1073747154 tok@var2484 =@expr1073747155 mTokenizer@var28 .@expr1073747156 tokens (@expr1073747157 ) ; tok@var2484 ; tok@var2484 =@expr1073747158 tok@var2484 .@expr5335 next (@expr5336 ) ) {
94: if (@expr1073747161 tok@var2484 .@expr1073747162 str (@expr1073747163 ) !=@expr1073747164 "=" ) {
95: continue ; }
96:
97: if (@expr1073747165 Token ::@expr5342 Match (@expr1073747167 tok@var2484 .@expr5344 tokAt (@expr1073747169 -2 ) , "[;{}] %var% =" ) ) {
98: const Variable * var@var2485 ; var@var2485 =@expr1073747170 tok@var2484 .@expr1073747171 previous (@expr1073747172 ) .@expr1073747173 variable (@expr1073747174 ) ;
99: if (@expr1073747175 var@var2485 ==@expr1073747176 nullptr ) {
100: continue ; }
101:
102: char bitop@var2486 ; bitop@var2486 =@expr1073747177 '\0' ;
103: long long num@var2487 ; num@var2487 =@expr1073747178 0 ;
104:
105: if (@expr1073747179 Token ::@expr5342 Match (@expr1073747181 tok@var2484 .@expr5335 next (@expr5336 ) , "%num% [&|]" ) ) {
106: bitop@var2486 =@expr1073747184 tok@var2484 .@expr1073747185 strAt (@expr1073747186 2 ) .@expr1073747187 at (@expr1073747188 0 ) ;
107: num@var2487 =@expr1073747189 MathLib ::@expr5366 toLongNumber (@expr1073747191 tok@var2484 .@expr5335 next (@expr5336 ) .@expr1073747194 str (@expr1073747195 ) ) ;
108: } else {
109: const Token * endToken@var2488 ; endToken@var2488 =@expr1073747196 Token ::@expr1073747197 findsimplematch (@expr1073747198 tok@var2484 , ";" ) ;
110:
111:
112: if (@expr1073747199 endToken@var2488 &&@expr1073747200 Token ::@expr5342 Match (@expr1073747202 endToken@var2488 .@expr5379 tokAt (@expr1073747204 -4 ) , "* ) & %any% ;" ) ) {
113: endToken@var2488 =@expr1073747205 nullptr ; }
114:
115: if (@expr1073747206 endToken@var2488 &&@expr1073747207 Token ::@expr5342 Match (@expr1073747209 endToken@var2488 .@expr5379 tokAt (@expr1073747211 -2 ) , "[&|] %num% ;" ) ) {
116: bitop@var2486 =@expr1073747212 endToken@var2488 .@expr1073747213 strAt (@expr1073747214 -2 ) .@expr1073747215 at (@expr1073747216 0 ) ;
117: num@var2487 =@expr1073747217 MathLib ::@expr5366 toLongNumber (@expr1073747219 endToken@var2488 .@expr1073747220 previous (@expr1073747221 ) .@expr1073747222 str (@expr1073747223 ) ) ;
118: }
119: }
120:
121: if (@expr1073747224 bitop@var2486 ==@expr1073747225 '\0' ) {
122: continue ; }
123:
124: if (@expr1073747226 num@var2487 <@expr1073747227 0 &&@expr1073747228 bitop@var2486 ==@expr1073747229 '|' ) {
125: continue ; }
126:
127: assignIfParseScope (@expr1073747230 tok@var2484 , tok@var2484 .@expr5344 tokAt (@expr1073747232 4 ) , var@var2485 .@expr1073747233 declarationId (@expr1073747234 ) , var@var2485 .@expr1073747235 isLocal (@expr1073747236 ) , bitop@var2486 , num@var2487 ) ;
128: }
129: }
130: }
131:
132: static bool isParameterChanged ( const Token * partok@var2489 )
133: {
134: bool addressOf@var2490 ; addressOf@var2490 =@expr1073747237 Token ::@expr1073747238 Match (@expr1073747239 partok@var2489 , "[(,] &" ) ;
135: int argumentNumber@var2491 ; argumentNumber@var2491 =@expr1073747240 0 ;
136: const Token * ftok@var2492 ;
137: for (@expr1073747241 ftok@var2492 =@expr1073747242 partok@var2489 ; ftok@var2492 &&@expr1073747243 ftok@var2492 .@expr5420 str (@expr5421 ) !=@expr1073747246 "(" ; ftok@var2492 =@expr1073747247 ftok@var2492 .@expr5424 previous (@expr5425 ) ) {
138: if (@expr1073747250 ftok@var2492 .@expr5420 str (@expr5421 ) ==@expr1073747253 ")" ) {
139: ftok@var2492 =@expr1073747254 ftok@var2492 .@expr1073747255 link (@expr1073747256 ) ; }
140: else { if (@expr1073747257 argumentNumber@var2491 ==@expr1073747258 0U &&@expr1073747259 ftok@var2492 .@expr5420 str (@expr5421 ) ==@expr1073747262 "&" ) {
141: addressOf@var2490 =@expr1073747263 true ; }
142: else { if (@expr1073747264 ftok@var2492 .@expr5420 str (@expr5421 ) ==@expr1073747267 "," ) {
143: argumentNumber@var2491 ++@expr1073747268 ; } } }
144: }
145: ftok@var2492 =@expr1073747269 ftok@var2492 ?@expr1073747270 ftok@var2492 .@expr5424 previous (@expr5425 ) :@expr1073747273 nullptr ;
146: if (@expr1073747274 !@expr1073747275 (@expr1073747276 ftok@var2492 &&@expr1073747277 ftok@var2492 .@expr5454 function (@expr5455 ) ) ) {
147: return true ; }
148: const Variable * par@var2493 ; par@var2493 =@expr1073747280 ftok@var2492 .@expr5454 function (@expr5455 ) .@expr1073747283 getArgumentVar (@expr1073747284 argumentNumber@var2491 ) ;
149: if (@expr1073747285 !@expr1073747286 par@var2493 ) {
150: return true ; }
151: if (@expr1073747287 par@var2493 .@expr1073747288 isConst (@expr1073747289 ) ) {
152: return false ; }
153: if (@expr1073747290 addressOf@var2490 ||@expr1073747291 par@var2493 .@expr1073747292 isReference (@expr1073747293 ) ||@expr1073747294 par@var2493 .@expr1073747295 isPointer (@expr1073747296 ) ) {
154: return true ; }
155: return false ;
156: }
157:
158:
159: bool CheckCondition :: assignIfParseScope ( const Token * const assignTok@var2494 ,
160: const Token * const startTok@var2495 ,
161: const int varid@var2496 ,
162: const bool islocal@var2497 ,
163: const char bitop@var2498 ,
164: const long long num@var2499 )
165: {
166: bool ret@var2500 ; ret@var2500 =@expr1073747297 false ;
167:
168: for (@expr1073747298 const Token *@expr1073747299 tok2@var2501 =@expr1073747300 startTok@var2495 ; tok2@var2501 ; tok2@var2501 =@expr1073747301 tok2@var2501 .@expr5478 next (@expr5479 ) ) {
169: if (@expr1073747304 (@expr1073747305 bitop@var2498 ==@expr5482 '&' ) &&@expr1073747307 Token ::@expr5484 Match (@expr1073747309 tok2@var2501 .@expr1073747310 tokAt (@expr1073747311 2 ) , "%varid% %cop% %num% ;" , varid@var2496 ) &&@expr1073747312 tok2@var2501 .@expr5489 strAt (@expr1073747314 3 ) ==@expr1073747315 std ::@expr5492 string (@expr1073747317 1U , bitop@var2498 ) ) {
170: const long long num2@var2502 =@expr1073747318 MathLib ::@expr5495 toLongNumber (@expr1073747320 tok2@var2501 .@expr5489 strAt (@expr1073747322 4 ) ) ;
171: if (@expr1073747323 0 ==@expr1073747324 (@expr1073747325 num@var2499 &@expr1073747326 num2@var2502 ) ) {
172: mismatchingBitAndError (@expr1073747327 assignTok@var2494 , num@var2499 , tok2@var2501 , num2@var2502 ) ; }
173: }
174: if (@expr1073747328 Token ::@expr5484 Match (@expr1073747330 tok2@var2501 , "%varid% =" , varid@var2496 ) ) {
175: return true ;
176: }
177: if (@expr1073747331 bitop@var2498 ==@expr5482 '&' &&@expr1073747333 Token ::@expr5484 Match (@expr1073747335 tok2@var2501 , "%varid% &= %num% ;" , varid@var2496 ) ) {
178: const long long num2@var2503 =@expr1073747336 MathLib ::@expr5495 toLongNumber (@expr1073747338 tok2@var2501 .@expr5489 strAt (@expr1073747340 2 ) ) ;
179: if (@expr1073747341 0 ==@expr1073747342 (@expr1073747343 num@var2499 &@expr1073747344 num2@var2503 ) ) {
180: mismatchingBitAndError (@expr1073747345 assignTok@var2494 , num@var2499 , tok2@var2501 , num2@var2503 ) ; }
181: }
182: if (@expr1073747346 Token ::@expr5484 Match (@expr1073747348 tok2@var2501 , "++|-- %varid%" , varid@var2496 ) ||@expr1073747349 Token ::@expr5484 Match (@expr1073747351 tok2@var2501 , "%varid% ++|--" , varid@var2496 ) ) {
183: return true ; }
184: if (@expr1073747352 Token ::@expr5484 Match (@expr5530 tok2@var2501 , "[(,] &| %varid% [,)]" , varid@var2496 ) &&@expr1073747355 isParameterChanged (@expr1073747356 tok2@var2501 ) ) {
185: return true ; }
186: if (@expr1073747357 tok2@var2501 .@expr5534 str (@expr5535 ) ==@expr1073747360 "}" ) {
187: return false ; }
188: if (@expr1073747361 Token ::@expr5484 Match (@expr1073747363 tok2@var2501 , "break|continue|return" ) ) {
189: ret@var2500 =@expr1073747364 true ; }
190: if (@expr1073747365 ret@var2500 &&@expr1073747366 tok2@var2501 .@expr5534 str (@expr5535 ) ==@expr1073747369 ";" ) {
191: return false ; }
192: if (@expr1073747370 !@expr5547 islocal@var2497 &&@expr1073747372 Token ::@expr5484 Match (@expr1073747374 tok2@var2501 , "%name% (" ) &&@expr1073747375 !@expr1073747376 Token ::@expr5553 simpleMatch (@expr1073747378 tok2@var2501 .@expr5478 next (@expr5479 ) .@expr5557 link (@expr5558 ) , ") {" ) ) {
193: return true ; }
194: if (@expr1073747383 Token ::@expr5484 Match (@expr1073747385 tok2@var2501 , "if|while (" ) ) {
195: if (@expr1073747386 !@expr5547 islocal@var2497 &&@expr1073747388 tok2@var2501 .@expr5534 str (@expr5535 ) ==@expr5567 "while" ) {
196: continue ; }
197: if (@expr1073747392 tok2@var2501 .@expr5534 str (@expr5535 ) ==@expr5567 "while" ) {
198:
199: const Token * bodyStart@var2504 ; bodyStart@var2504 =@expr1073747396 tok2@var2501 .@expr1073747397 linkAt (@expr1073747398 1 ) .@expr1073747399 next (@expr1073747400 ) ;
200: const Token * bodyEnd@var2505 ; bodyEnd@var2505 =@expr1073747401 bodyStart@var2504 ?@expr1073747402 bodyStart@var2504 .@expr1073747403 link (@expr1073747404 ) :@expr1073747405 nullptr ;
201: if (@expr1073747406 !@expr1073747407 bodyEnd@var2505 ||@expr1073747408 bodyEnd@var2505 .@expr1073747409 str (@expr1073747410 ) !=@expr1073747411 "}" ||@expr1073747412 isVariableChanged (@expr1073747413 bodyStart@var2504 , bodyEnd@var2505 , varid@var2496 , !@expr5547 islocal@var2497 , mSettings@var29 , mTokenizer@var28 .@expr1073747415 isCPP (@expr1073747416 ) ) ) {
202: continue ; }
203: }
204:
205:
206: const Token * const end@var2506 ; end@var2506 =@expr1073747417 tok2@var2501 .@expr5478 next (@expr5479 ) .@expr5557 link (@expr5558 ) ;
207: for (@expr1073747422 ; tok2@var2501 !=@expr1073747423 end@var2506 ; tok2@var2501 =@expr1073747424 tok2@var2501 .@expr5478 next (@expr5479 ) ) {
208: if (@expr1073747427 Token ::@expr5484 Match (@expr5530 tok2@var2501 , "[(,] &| %varid% [,)]" , varid@var2496 ) ) {
209: return true ;
210: }
211: if (@expr1073747430 Token ::@expr5484 Match (@expr1073747432 tok2@var2501 , "&&|%oror%|( %varid% ==|!= %num% &&|%oror%|)" , varid@var2496 ) ) {
212: const Token * vartok@var2507 ; vartok@var2507 =@expr1073747433 tok2@var2501 .@expr5478 next (@expr5479 ) ;
213: const long long num2@var2508 =@expr1073747436 MathLib ::@expr5495 toLongNumber (@expr1073747438 vartok@var2507 .@expr5615 strAt (@expr5616 2 ) ) ;
214: if (@expr1073747441 (@expr1073747442 num@var2499 &@expr1073747443 num2@var2508 ) !=@expr1073747444 (@expr1073747445 (@expr1073747446 bitop@var2498 ==@expr5482 '&' ) ?@expr1073747448 num2@var2508 :@expr1073747449 num@var2499 ) ) {
215: const std ::@expr5492 string & op@var2509 (@expr1073747451 vartok@var2507 .@expr5615 strAt (@expr1073747453 1 ) ) ;
216: const bool alwaysTrue@var2510 =@expr1073747454 op@var2509 ==@expr1073747455 "!=" ;
217: const std ::@expr1073747456 string condition@var2511 (@expr1073747457 vartok@var2507 .@expr1073747458 str (@expr1073747459 ) +@expr1073747460 op@var2509 +@expr1073747461 vartok@var2507 .@expr5615 strAt (@expr5616 2 ) ) ;
218: assignIfError (@expr1073747464 assignTok@var2494 , tok2@var2501 , condition@var2511 , alwaysTrue@var2510 ) ;
219: }
220: }
221: if (@expr1073747465 Token ::@expr5484 Match (@expr1073747467 tok2@var2501 , "%varid% %op%" , varid@var2496 ) &&@expr1073747468 tok2@var2501 .@expr5478 next (@expr5479 ) .@expr1073747471 isAssignmentOp (@expr1073747472 ) ) {
222: return true ;
223: }
224: }
225:
226: const bool ret1@var2512 =@expr1073747473 assignIfParseScope (@expr1073747474 assignTok@var2494 , end@var2506 .@expr1073747475 tokAt (@expr1073747476 2 ) , varid@var2496 , islocal@var2497 , bitop@var2498 , num@var2499 ) ;
227: bool ret2@var2513 ; ret2@var2513 =@expr1073747477 false ;
228: if (@expr1073747478 Token ::@expr5553 simpleMatch (@expr1073747480 end@var2506 .@expr5657 next (@expr5658 ) .@expr5659 link (@expr5660 ) , "} else {" ) ) {
229: ret2@var2513 =@expr1073747485 assignIfParseScope (@expr1073747486 assignTok@var2494 , end@var2506 .@expr5657 next (@expr5658 ) .@expr5659 link (@expr5660 ) .@expr1073747491 tokAt (@expr1073747492 3 ) , varid@var2496 , islocal@var2497 , bitop@var2498 , num@var2499 ) ; }
230: if (@expr1073747493 ret1@var2512 ||@expr1073747494 ret2@var2513 ) {
231: return true ; }
232: }
233: }
234: return false ;
235: }
236:
237: void CheckCondition :: assignIfError ( const Token * tok1@var2514 , const Token * tok2@var2515 , const std :: string & condition@var2516 , bool result@var2517 )
238: {
239: if (@expr1073747495 tok2@var2515 &&@expr1073747496 diag (@expr1073747497 tok2@var2515 .@expr1073747498 tokAt (@expr1073747499 2 ) ) ) {
240: return ; }
241: std ::@expr1073747500 list < const Token *@expr1073747501 > locations@var2518 ; locations@var2518 =@expr1073747502 {@expr1073747503 tok1@var2514 , tok2@var2515 } ;
242: reportError (@expr1073747504 locations@var2518 ,
243: Severity ::@expr1073747505 style ,
244: "assignIfError" ,
245: "Mismatching assignment and comparison, comparison '" +@expr1073747506 condition@var2516 +@expr1073747507 "' is always " +@expr1073747508 std ::@expr1073747509 string (@expr1073747510 result@var2517 ?@expr1073747511 "true" :@expr1073747512 "false" ) +@expr1073747513 "." , CWE398@var2474 , Certainty ::@expr1073747514 normal ) ;
246: }
247:
248:
249: void CheckCondition :: mismatchingBitAndError ( const Token * tok1@var2519 , const long long num1@var2520 , const Token * tok2@var2521 , const long long num2@var2522 )
250: {
251: std ::@expr1073747516 list < const Token *@expr1073747517 > locations@var2523 ; locations@var2523 =@expr1073747518 {@expr1073747519 tok1@var2519 , tok2@var2521 } ;
252:
253: std ::@expr1073747520 ostringstream msg@var2524 ;
254: msg@var2524 <<@expr1073747521 "Mismatching bitmasks. Result is always 0 ("
255: <<@expr1073747522 "X = Y & 0x" <<@expr1073747523 std ::@expr5700 hex@expr5691 <<@expr1073747525 num1@var2520 <<@expr1073747526 "; Z = X & 0x" <<@expr1073747527 std ::@expr5700 hex@expr5691 <<@expr1073747529 num2@var2522 <<@expr1073747530 "; => Z=0)." ;
256:
257: reportError (@expr1073747531 locations@var2523 ,
258: Severity ::@expr1073747532 style ,
259: "mismatchingBitAnd" ,
260: msg@var2524 .@expr1073747533 str (@expr1073747534 ) , CWE398@var2474 , Certainty ::@expr1073747535 normal ) ;
261: }
262:
263:
264: static void getnumchildren ( const Token * tok@var2525 , std :: list < long long > & numchildren@var2526 )
265: {
266: if (@expr1073747536 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) &&@expr1073747539 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) .@expr1073747542 isNumber (@expr1073747543 ) ) {
267: numchildren@var2526 .@expr5720 push_back (@expr1073747545 MathLib ::@expr5722 toLongNumber (@expr1073747547 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) .@expr5726 str (@expr5727 ) ) ) ; }
268: else { if (@expr1073747552 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) &&@expr1073747555 tok@var2525 .@expr5732 str (@expr5733 ) ==@expr1073747558 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) .@expr5726 str (@expr5727 ) ) {
269: getnumchildren (@expr1073747563 tok@var2525 .@expr5713 astOperand1 (@expr5714 ) , numchildren@var2526 ) ; } }
270: if (@expr1073747566 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) &&@expr1073747569 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) .@expr1073747572 isNumber (@expr1073747573 ) ) {
271: numchildren@var2526 .@expr5720 push_back (@expr1073747575 MathLib ::@expr5722 toLongNumber (@expr1073747577 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) .@expr5756 str (@expr5757 ) ) ) ; }
272: else { if (@expr1073747582 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) &&@expr1073747585 tok@var2525 .@expr5732 str (@expr5733 ) ==@expr1073747588 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) .@expr5756 str (@expr5757 ) ) {
273: getnumchildren (@expr1073747593 tok@var2525 .@expr5743 astOperand2 (@expr5744 ) , numchildren@var2526 ) ; } }
274: }
275:
276:
277: static bool inBooleanFunction ( const Token * tok@var2527 )
278: {
279: const Scope * scope@var2528 ; scope@var2528 =@expr1073747596 tok@var2527 ?@expr1073747597 tok@var2527 .@expr1073747598 scope (@expr1073747599 ) :@expr1073747600 nullptr ;
280: while (@expr1073747601 scope@var2528 &&@expr1073747602 scope@var2528 .@expr1073747603 isLocal (@expr1073747604 ) ) {
281: scope@var2528 =@expr1073747605 scope@var2528 .@expr1073747606 nestedIn@var2529 ; }
282: if (@expr1073747607 scope@var2528 &&@expr1073747608 scope@var2528 .@expr1073747609 type@var2530 ==@expr1073747610 Scope ::@expr1073747611 eFunction ) {
283: const Function * func@var2531 ; func@var2531 =@expr1073747612 scope@var2528 .@expr1073747613 function@var2532 ;
284: if (@expr1073747614 func@var2531 ) {
285: const Token * ret@var2533 ; ret@var2533 =@expr1073747615 func@var2531 .@expr1073747616 retDef@var2534 ;
286: while (@expr1073747617 Token ::@expr5794 Match (@expr1073747619 ret@var2533 , "static|const" ) ) {
287: ret@var2533 =@expr1073747620 ret@var2533 .@expr1073747621 next (@expr1073747622 ) ; }
288: return Token ::@expr5794 Match (@expr1073747624 ret@var2533 , "bool|_Bool" ) ;
289: }
290: }
291: return false ;
292: }
293:
294: void CheckCondition :: checkBadBitmaskCheck ( )
295: {
296: if (@expr1073747627 !@expr1073747628 mSettings@var29 .@expr1073747629 severity@var2951 .@expr1073747630 isEnabled (@expr1073747631 Severity ::@expr1073747632 warning ) ) {
297: return ; }
298:
299: for (@expr1073747633 const Token *@expr1073747634 tok@var2535 =@expr1073747635 mTokenizer@var28 .@expr1073747636 tokens (@expr1073747637 ) ; tok@var2535 ; tok@var2535 =@expr1073747638 tok@var2535 .@expr1073747639 next (@expr1073747640 ) ) {
300: if (@expr1073747641 tok@var2535 .@expr1073747642 str (@expr1073747643 ) ==@expr1073747644 "|" &&@expr1073747645 tok@var2535 .@expr5822 astOperand1 (@expr5823 ) &&@expr1073747648 tok@var2535 .@expr5825 astOperand2 (@expr5826 ) &&@expr1073747651 tok@var2535 .@expr5828 astParent (@expr5829 ) ) {
301: const Token * parent@var2536 ; parent@var2536 =@expr1073747654 tok@var2535 .@expr5828 astParent (@expr5829 ) ;
302: const bool isBoolean@var2537 =@expr1073747657 Token ::@expr5834 Match (@expr1073747659 parent@var2536 , "&&|%oror%" ) ||@expr1073747660
303: (@expr1073747661 parent@var2536 .@expr5838 str (@expr5839 ) ==@expr1073747664 "?" &&@expr1073747665 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) ==@expr5844 tok@var2535 ) ||@expr1073747669
304: (@expr1073747670 parent@var2536 .@expr5838 str (@expr5839 ) ==@expr1073747673 "=" &&@expr1073747674 parent@var2536 .@expr1073747675 astOperand2 (@expr1073747676 ) ==@expr1073747677 tok@var2535 &&@expr1073747678 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) &&@expr1073747681 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) .@expr5860 variable (@expr5861 ) &&@expr1073747686 Token ::@expr5834 Match (@expr1073747688 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) .@expr5860 variable (@expr5861 ) .@expr1073747693 typeStartToken (@expr1073747694 ) , "bool|_Bool" ) ) ||@expr1073747695
305: (@expr1073747696 parent@var2536 .@expr5838 str (@expr5839 ) ==@expr1073747699 "(" &&@expr1073747700 Token ::@expr5834 Match (@expr1073747702 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) , "if|while" ) ) ||@expr1073747705
306: (@expr1073747706 parent@var2536 .@expr5838 str (@expr5839 ) ==@expr1073747709 "return" &&@expr1073747710 parent@var2536 .@expr5842 astOperand1 (@expr5843 ) ==@expr5844 tok@var2535 &&@expr1073747714 inBooleanFunction (@expr1073747715 tok@var2535 ) ) ;
307:
308: const bool isTrue@var2538 =@expr1073747716 (@expr1073747717 tok@var2535 .@expr5822 astOperand1 (@expr5823 ) .@expr1073747720 hasKnownIntValue (@expr1073747721 ) &&@expr1073747722 tok@var2535 .@expr5822 astOperand1 (@expr5823 ) .@expr1073747725 values (@expr1073747726 ) .@expr1073747727 front (@expr1073747728 ) .@expr1073747729 intvalue@expr1073747625 !=@expr1073747730 0 ) ||@expr1073747731
309: (@expr1073747732 tok@var2535 .@expr5825 astOperand2 (@expr5826 ) .@expr1073747735 hasKnownIntValue (@expr1073747736 ) &&@expr1073747737 tok@var2535 .@expr5825 astOperand2 (@expr5826 ) .@expr1073747740 values (@expr1073747741 ) .@expr1073747742 front (@expr1073747743 ) .@expr1073747744 intvalue@expr1073747626 !=@expr1073747745 0 ) ;
310:
311: if (@expr1073747746 isBoolean@var2537 &&@expr1073747747 isTrue@var2538 ) {
312: badBitmaskCheckError (@expr1073747748 tok@var2535 ) ; }
313: }
314: }
315: }
316:
317: void CheckCondition :: badBitmaskCheckError ( const Token * tok@var2539 )
318: {
319: reportError (@expr1073747749 tok@var2539 , Severity ::@expr1073747750 warning , "badBitmaskCheck" , "Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'?" , CWE571@var2476 , Certainty ::@expr1073747751 normal ) ;
320: }
321:
322: void CheckCondition :: comparison ( )
323: {
324: if (@expr1073747752 !@expr1073747753 mSettings@var29 .@expr1073747754 severity@var2951 .@expr1073747755 isEnabled (@expr1073747756 Severity ::@expr1073747757 style ) ) {
325: return ; }
326:
327: for (@expr1073747758 const Token *@expr1073747759 tok@var2540 =@expr1073747760 mTokenizer@var28 .@expr1073747761 tokens (@expr1073747762 ) ; tok@var2540 ; tok@var2540 =@expr1073747763 tok@var2540 .@expr1073747764 next (@expr1073747765 ) ) {
328: if (@expr1073747766 !@expr1073747767 tok@var2540 .@expr1073747768 isComparisonOp (@expr1073747769 ) ) {
329: continue ; }
330:
331: const Token * expr1@var2541 ; expr1@var2541 =@expr1073747770 tok@var2540 .@expr1073747771 astOperand1 (@expr1073747772 ) ;
332: const Token * expr2@var2542 ; expr2@var2542 =@expr1073747773 tok@var2540 .@expr1073747774 astOperand2 (@expr1073747775 ) ;
333: if (@expr1073747776 !@expr1073747777 expr1@var2541 ||@expr1073747778 !@expr1073747779 expr2@var2542 ) {
334: continue ; }
335: if (@expr1073747780 expr1@var2541 .@expr1073747781 isNumber (@expr1073747782 ) ) {
336: std ::@expr1073747783 swap (@expr1073747784 expr1@var2541 , expr2@var2542 ) ; }
337: if (@expr1073747785 !@expr1073747786 expr2@var2542 .@expr1073747787 isNumber (@expr1073747788 ) ) {
338: continue ; }
339: const long long num2@var2543 =@expr1073747789 MathLib ::@expr1073747790 toLongNumber (@expr1073747791 expr2@var2542 .@expr1073747792 str (@expr1073747793 ) ) ;
340: if (@expr1073747794 num2@var2543 <@expr1073747795 0 ) {
341: continue ; }
342: if (@expr1073747796 !@expr1073747797 Token ::@expr5974 Match (@expr1073747799 expr1@var2541 , "[&|]" ) ) {
343: continue ; }
344: std ::@expr1073747800 list < long long > numbers@var2544 ;
345: getnumchildren (@expr1073747801 expr1@var2541 , numbers@var2544 ) ;
346: for (@expr1073747802 const long long num1@var2545 :@expr1073747803 numbers@var2544 ) {
347: if (@expr1073747804 num1@var2545 <@expr1073747805 0 ) {
348: continue ; }
349: if (@expr1073747806 Token ::@expr5974 Match (@expr1073747808 tok@var2540 , "==|!=" ) ) {
350: if (@expr1073747809 (@expr1073747810 expr1@var2541 .@expr5987 str (@expr5988 ) ==@expr5989 "&" &&@expr1073747814 (@expr1073747815 num1@var2545 &@expr1073747816 num2@var2543 ) !=@expr1073747817 num2@var2543 ) ||@expr1073747818
351: (@expr1073747819 expr1@var2541 .@expr5987 str (@expr5988 ) ==@expr5998 "|" &&@expr1073747823 (@expr1073747824 num1@var2545 |@expr1073747825 num2@var2543 ) !=@expr1073747826 num2@var2543 ) ) {
352: const std ::@expr6003 string & op@var2546 (@expr1073747828 tok@var2540 .@expr6005 str (@expr6006 ) ) ;
353: comparisonError (@expr1073747831 expr1@var2541 , expr1@var2541 .@expr5987 str (@expr5988 ) , num1@var2545 , op@var2546 , num2@var2543 , op@var2546 ==@expr1073747834 "==" ?@expr1073747835 false :@expr6012 true ) ;
354: }
355: } else { if (@expr1073747837 expr1@var2541 .@expr5987 str (@expr5988 ) ==@expr5989 "&" ) {
356: const bool or_equal@var2547 =@expr1073747841 Token ::@expr5974 Match (@expr6019 tok@var2540 , ">=|<=" ) ;
357: const std ::@expr6003 string & op@var2548 (@expr1073747845 tok@var2540 .@expr6005 str (@expr6006 ) ) ;
358: if (@expr1073747848 (@expr1073747849 Token ::@expr5974 Match (@expr6027 tok@var2540 , ">=|<" ) ) &&@expr1073747852 (@expr1073747853 num1@var2545 <@expr1073747854 num2@var2543 ) ) {
359: comparisonError (@expr1073747855 expr1@var2541 , expr1@var2541 .@expr5987 str (@expr5988 ) , num1@var2545 , op@var2548 , num2@var2543 , or_equal@var2547 ?@expr1073747858 false :@expr6012 true ) ;
360: } else { if (@expr1073747860 (@expr1073747861 Token ::@expr5974 Match (@expr6039 tok@var2540 , "<=|>" ) ) &&@expr1073747864 (@expr1073747865 num1@var2545 <=@expr1073747866 num2@var2543 ) ) {
361: comparisonError (@expr1073747867 expr1@var2541 , expr1@var2541 .@expr5987 str (@expr5988 ) , num1@var2545 , op@var2548 , num2@var2543 , or_equal@var2547 ?@expr1073747870 true :@expr6047 false ) ;
362: } }
363: } else { if (@expr1073747872 expr1@var2541 .@expr5987 str (@expr5988 ) ==@expr5998 "|" ) {
364: if (@expr1073747876 (@expr1073747877 expr1@var2541 .@expr6054 astOperand1 (@expr6055 ) .@expr6056 valueType (@expr6057 ) ) &&@expr1073747882
365: (@expr1073747883 expr1@var2541 .@expr6054 astOperand1 (@expr6055 ) .@expr6056 valueType (@expr6057 ) .@expr1073747888 sign@var2975 ==@expr1073747889 ValueType ::@expr1073747890 Sign ::@expr1073747891 UNSIGNED ) ) {
366: const bool or_equal@var2549 =@expr1073747892 Token ::@expr5974 Match (@expr6019 tok@var2540 , ">=|<=" ) ;
367: const std ::@expr6003 string & op@var2550 (@expr1073747896 tok@var2540 .@expr6005 str (@expr6006 ) ) ;
368: if (@expr1073747899 (@expr1073747900 Token ::@expr5974 Match (@expr6027 tok@var2540 , ">=|<" ) ) &&@expr1073747903 (@expr1073747904 num1@var2545 >=@expr1073747905 num2@var2543 ) ) {
369:
370:
371: comparisonError (@expr1073747906 expr1@var2541 , expr1@var2541 .@expr5987 str (@expr5988 ) , num1@var2545 , op@var2550 , num2@var2543 , or_equal@var2549 ?@expr1073747909 true :@expr6047 false ) ;
372: } else { if (@expr1073747911 (@expr1073747912 Token ::@expr5974 Match (@expr6039 tok@var2540 , "<=|>" ) ) &&@expr1073747915 (@expr1073747916 num1@var2545 >@expr1073747917 num2@var2543 ) ) {
373:
374:
375: comparisonError (@expr1073747918 expr1@var2541 , expr1@var2541 .@expr5987 str (@expr5988 ) , num1@var2545 , op@var2550 , num2@var2543 , or_equal@var2549 ?@expr1073747921 false :@expr6012 true ) ;
376: } }
377: }
378: } } }
379: }
380: }
381: }
382:
383: void CheckCondition :: comparisonError ( const Token * tok@var2551 , const std :: string & bitop@var2552 , long long value1@var2553 , const std :: string & op@var2554 , long long value2@var2555 , bool result@var2556 )
384: {
385: std ::@expr1073747924 ostringstream expression@var2557 ;
386: expression@var2557 <<@expr1073747925 std ::@expr1073747926 hex@expr1073747923 <<@expr1073747927 "(X " <<@expr1073747928 bitop@var2552 <<@expr1073747929 " 0x" <<@expr1073747930 value1@var2553 <<@expr1073747931 ") " <<@expr1073747932 op@var2554 <<@expr1073747933 " 0x" <<@expr1073747934 value2@var2555 ;
387:
388: const std ::@expr1073747935 string errmsg@var2558 (@expr1073747936 "Expression '" +@expr1073747937 expression@var2557 .@expr6114 str (@expr6115 ) +@expr1073747940 "' is always " +@expr1073747941 (@expr1073747942 result@var2556 ?@expr6119 "true" :@expr6120 "false" ) +@expr1073747945 ".\nThe expression '"
389: +@expr1073747946 expression@var2557 .@expr6114 str (@expr6115 ) +@expr1073747949 "' is always " +@expr1073747950 (@expr1073747951 result@var2556 ?@expr6119 "true" :@expr6120 "false" ) +@expr1073747954
390: ". Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions."
391:
392: ) ;
393:
394: reportError (@expr1073747955 tok@var2551 , Severity ::@expr1073747956 style , "comparisonError" , errmsg@var2558 , CWE398@var2474 , Certainty ::@expr1073747957 normal ) ;
395: }
396:
397: bool CheckCondition :: isOverlappingCond ( const Token * const cond1@var2559 , const Token * const cond2@var2560 , bool pure@var2561 ) const
398: {
399: if (@expr1073747958 !@expr1073747959 cond1@var2559 ||@expr1073747960 !@expr1073747961 cond2@var2560 ) {
400: return false ; }
401:
402:
403: if (@expr1073747962 isSameExpression (@expr1073747963 mTokenizer@var28 .@expr6140 isCPP (@expr6141 ) , true , cond1@var2559 , cond2@var2560 , mSettings@var29 .@expr6142 library@var2952 , pure@var2561 , false ) ) {
404: return true ; }
405:
406:
407: if (@expr1073747967 cond1@var2559 .@expr1073747968 str (@expr1073747969 ) ==@expr1073747970 "&" &&@expr1073747971 cond1@var2559 .@expr6148 astOperand1 (@expr6149 ) &&@expr1073747974 cond2@var2560 .@expr6151 astOperand2 (@expr6152 ) ) {
408: const Token * expr1@var2562 ; expr1@var2562 =@expr1073747977 cond1@var2559 .@expr6148 astOperand1 (@expr6149 ) ;
409: const Token * num1@var2563 ; num1@var2563 =@expr1073747980 cond1@var2559 .@expr1073747981 astOperand2 (@expr1073747982 ) ;
410: if (@expr1073747983 !@expr1073747984 num1@var2563 ) {
411: return false ; }
412: if (@expr1073747985 !@expr6162 num1@var2563 .@expr6163 isNumber (@expr6164 ) ) {
413: std ::@expr6165 swap (@expr1073747990 expr1@var2562 , num1@var2563 ) ; }
414: if (@expr1073747991 !@expr6162 num1@var2563 .@expr6163 isNumber (@expr6164 ) ||@expr1073747995 MathLib ::@expr6172 isNegative (@expr1073747997 num1@var2563 .@expr6174 str (@expr6175 ) ) ) {
415: return false ; }
416:
417: if (@expr1073748000 !@expr1073748001 Token ::@expr1073748002 Match (@expr1073748003 cond2@var2560 , "&|==" ) ||@expr1073748004 !@expr1073748005 cond2@var2560 .@expr6182 astOperand1 (@expr6183 ) ||@expr1073748008 !@expr1073748009 cond2@var2560 .@expr6151 astOperand2 (@expr6152 ) ) {
418: return false ; }
419: const Token * expr2@var2564 ; expr2@var2564 =@expr1073748012 cond2@var2560 .@expr6182 astOperand1 (@expr6183 ) ;
420: const Token * num2@var2565 ; num2@var2565 =@expr1073748015 cond2@var2560 .@expr6151 astOperand2 (@expr6152 ) ;
421: if (@expr1073748018 !@expr6195 num2@var2565 .@expr6196 isNumber (@expr6197 ) ) {
422: std ::@expr6165 swap (@expr1073748023 expr2@var2564 , num2@var2565 ) ; }
423: if (@expr1073748024 !@expr6195 num2@var2565 .@expr6196 isNumber (@expr6197 ) ||@expr1073748028 MathLib ::@expr6172 isNegative (@expr1073748030 num2@var2565 .@expr6207 str (@expr6208 ) ) ) {
424: return false ; }
425:
426: if (@expr1073748033 !@expr1073748034 isSameExpression (@expr1073748035 mTokenizer@var28 .@expr6140 isCPP (@expr6141 ) , true , expr1@var2562 , expr2@var2564 , mSettings@var29 .@expr6142 library@var2952 , pure@var2561 , false ) ) {
427: return false ; }
428:
429: const long long value1@var2566 =@expr1073748039 MathLib ::@expr6216 toLongNumber (@expr1073748041 num1@var2563 .@expr6174 str (@expr6175 ) ) ;
430: const long long value2@var2567 =@expr1073748044 MathLib ::@expr6216 toLongNumber (@expr1073748046 num2@var2565 .@expr6207 str (@expr6208 ) ) ;
431: if (@expr1073748049 cond2@var2560 .@expr1073748050 str (@expr1073748051 ) ==@expr1073748052 "&" ) {
432: return (@expr6229 (@expr6229 value1@var2566 &@expr6231 value2@var2567 ) ==@expr1073748056 value2@var2567 ) ; }
433: return (@expr6229 (@expr6229 value1@var2566 &@expr6231 value2@var2567 ) >@expr1073748060 0 ) ;
434: }
435: return false ;
436: }
437:
438: void CheckCondition :: duplicateCondition ( )
439: {
440: if (@expr1073748061 !@expr1073748062 mSettings@var29 .@expr1073748063 severity@var2951 .@expr1073748064 isEnabled (@expr1073748065 Severity ::@expr1073748066 style ) ) {
441: return ; }
442:
443: const SymbolDatabase * const symbolDatabase@var2568 ; symbolDatabase@var2568 =@expr1073748067 mTokenizer@var28 .@expr1073748068 getSymbolDatabase (@expr1073748069 ) ;
444:
445: for (@expr1073748070 const Scope &@expr1073748071 scope@var2569 :@expr1073748072 symbolDatabase@var2568 .@expr1073748073 scopeList@var2570 ) {
446: if (@expr1073748074 scope@var2569 .@expr1073748075 type@var2571 !=@expr1073748076 Scope ::@expr1073748077 eIf ) {
447: continue ; }
448:
449: const Token * tok2@var2572 ; tok2@var2572 =@expr1073748078 scope@var2569 .@expr6255 classDef@var2573 .@expr6256 next (@expr6257 ) ;
450: if (@expr1073748082 !@expr1073748083 tok2@var2572 ) {
451: continue ; }
452: const Token * cond1@var2574 ; cond1@var2574 =@expr1073748084 tok2@var2572 .@expr1073748085 astOperand2 (@expr1073748086 ) ;
453: if (@expr1073748087 !@expr1073748088 cond1@var2574 ) {
454: continue ; }
455: if (@expr1073748089 cond1@var2574 .@expr1073748090 hasKnownIntValue (@expr1073748091 ) ) {
456: continue ; }
457:
458: tok2@var2572 =@expr1073748092 tok2@var2572 .@expr1073748093 link (@expr1073748094 ) ;
459: if (@expr1073748095 !@expr1073748096 Token ::@expr6273 simpleMatch (@expr1073748098 tok2@var2572 , ") {" ) ) {
460: continue ; }
461: tok2@var2572 =@expr1073748099 tok2@var2572 .@expr1073748100 linkAt (@expr1073748101 1 ) ;
462: if (@expr1073748102 !@expr1073748103 Token ::@expr6273 simpleMatch (@expr1073748105 tok2@var2572 , "} if (" ) ) {
463: continue ; }
464: const Token * cond2@var2575 ; cond2@var2575 =@expr1073748106 tok2@var2572 .@expr1073748107 tokAt (@expr1073748108 2 ) .@expr1073748109 astOperand2 (@expr1073748110 ) ;
465: if (@expr1073748111 !@expr1073748112 cond2@var2575 ) {
466: continue ; }
467:
468: std ::@expr1073748113 list < std ::@expr6290 pair < const Token *@expr1073748115 , std ::@expr6290 string > > errorPath@var2576 ;
469: if (@expr1073748117 !@expr1073748118 isExpressionChanged (@expr1073748119 cond1@var2574 , scope@var2569 .@expr6255 classDef@var2573 .@expr6256 next (@expr6257 ) , cond2@var2575 , mSettings@var29 , mTokenizer@var28 .@expr6299 isCPP (@expr6300 ) ) &&@expr1073748125
470: isSameExpression (@expr1073748126 mTokenizer@var28 .@expr6299 isCPP (@expr6300 ) , true , cond1@var2574 , cond2@var2575 , mSettings@var29 .@expr1073748129 library@var2952 , true , true , &@expr1073748130 errorPath@var2576 ) ) {
471: duplicateConditionError (@expr1073748131 cond1@var2574 , cond2@var2575 , errorPath@var2576 ) ; }
472: }
473: }
474:
475: void CheckCondition :: duplicateConditionError ( const Token * tok1@var2577 , const Token * tok2@var2578 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2579 )
476: {
477: if (@expr1073748132 diag (@expr1073748133 tok1@var2577 ) &@expr1073748134 diag (@expr1073748135 tok2@var2578 ) ) {
478: return ; }
479: errorPath@var2579 .@expr6312 emplace_back (@expr1073748137 tok1@var2577 , "First condition" ) ;
480: errorPath@var2579 .@expr6312 emplace_back (@expr1073748139 tok2@var2578 , "Second condition" ) ;
481:
482: std ::@expr1073748140 string msg@var2580 ; msg@var2580 =@expr1073748141 "The if condition is the same as the previous if condition" ;
483:
484: reportError (@expr1073748142 errorPath@var2579 , Severity ::@expr1073748143 style , "duplicateCondition" , msg@var2580 , CWE398@var2474 , Certainty ::@expr1073748144 normal ) ;
485: }
486:
487: void CheckCondition :: multiCondition ( )
488: {
489: if (@expr1073748145 !@expr1073748146 mSettings@var29 .@expr1073748147 severity@var2951 .@expr1073748148 isEnabled (@expr1073748149 Severity ::@expr1073748150 style ) ) {
490: return ; }
491:
492: const SymbolDatabase * const symbolDatabase@var2581 ; symbolDatabase@var2581 =@expr1073748151 mTokenizer@var28 .@expr1073748152 getSymbolDatabase (@expr1073748153 ) ;
493:
494: for (@expr1073748154 const Scope &@expr1073748155 scope@var2582 :@expr1073748156 symbolDatabase@var2581 .@expr1073748157 scopeList@var2583 ) {
495: if (@expr1073748158 scope@var2582 .@expr1073748159 type@var2584 !=@expr1073748160 Scope ::@expr1073748161 eIf ) {
496: continue ; }
497:
498: const Token * const cond1@var2585 ; cond1@var2585 =@expr1073748162 scope@var2582 .@expr6339 classDef@var2586 .@expr6340 next (@expr6341 ) .@expr1073748166 astOperand2 (@expr1073748167 ) ;
499: if (@expr1073748168 !@expr1073748169 cond1@var2585 ) {
500: continue ; }
501:
502: const Token * tok2@var2587 ; tok2@var2587 =@expr1073748170 scope@var2582 .@expr6339 classDef@var2586 .@expr6340 next (@expr6341 ) ;
503:
504:
505: for (@expr1073748174 ; ; ) {
506: tok2@var2587 =@expr1073748175 tok2@var2587 .@expr1073748176 link (@expr1073748177 ) ;
507: if (@expr1073748178 !@expr1073748179 Token ::@expr6356 simpleMatch (@expr1073748181 tok2@var2587 , ") {" ) ) {
508: break ; }
509: tok2@var2587 =@expr1073748182 tok2@var2587 .@expr1073748183 linkAt (@expr1073748184 1 ) ;
510: if (@expr1073748185 !@expr1073748186 Token ::@expr6356 simpleMatch (@expr1073748188 tok2@var2587 , "} else { if (" ) ) {
511: break ; }
512: tok2@var2587 =@expr1073748189 tok2@var2587 .@expr1073748190 tokAt (@expr1073748191 4 ) ;
513:
514: if (@expr1073748192 tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) ) {
515: std ::@expr1073748195 list < std ::@expr6372 pair < const Token *@expr1073748197 , std ::@expr6372 string > > errorPath@var2588 ;
516: if (@expr1073748199 isOverlappingCond (@expr1073748200 cond1@var2585 , tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , true ) &&@expr1073748203 !@expr6380 isExpressionChanged (@expr6381 cond1@var2585 , cond1@var2585 , tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , mSettings@var29 , mTokenizer@var28 .@expr6384 isCPP (@expr6385 ) ) ) {
517: overlappingElseIfConditionError (@expr1073748210 tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , cond1@var2585 .@expr1073748213 linenr (@expr1073748214 ) ) ; }
518: else { if (@expr1073748215 isOppositeCond (@expr1073748216 true , mTokenizer@var28 .@expr6384 isCPP (@expr6385 ) , cond1@var2585 , tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , mSettings@var29 .@expr1073748221 library@var2952 , true , true , &@expr1073748222 errorPath@var2588 ) &&@expr1073748223
519: !@expr6380 isExpressionChanged (@expr6381 cond1@var2585 , cond1@var2585 , tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , mSettings@var29 , mTokenizer@var28 .@expr6384 isCPP (@expr6385 ) ) ) {
520: oppositeElseIfConditionError (@expr1073748230 cond1@var2585 , tok2@var2587 .@expr6369 astOperand2 (@expr6370 ) , errorPath@var2588 ) ; } }
521: }
522: }
523: }
524: }
525:
526: void CheckCondition :: overlappingElseIfConditionError ( const Token * tok@var2589 , int line1@var2590 )
527: {
528: if (@expr1073748233 diag (@expr1073748234 tok@var2589 ) ) {
529: return ; }
530: std ::@expr1073748235 ostringstream errmsg@var2591 ;
531: errmsg@var2591 <<@expr1073748236 "Expression is always false because 'else if' condition matches previous condition at line "
532: <<@expr1073748237 line1@var2590 <<@expr1073748238 "." ;
533:
534: reportError (@expr1073748239 tok@var2589 , Severity ::@expr1073748240 style , "multiCondition" , errmsg@var2591 .@expr1073748241 str (@expr1073748242 ) , CWE398@var2474 , Certainty ::@expr1073748243 normal ) ;
535: }
536:
537: void CheckCondition :: oppositeElseIfConditionError ( const Token * ifCond@var2592 , const Token * elseIfCond@var2593 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2594 )
538: {
539: if (@expr1073748244 diag (@expr1073748245 ifCond@var2592 ) &@expr1073748246 diag (@expr1073748247 elseIfCond@var2593 ) ) {
540: return ; }
541: std ::@expr1073748248 ostringstream errmsg@var2595 ;
542: errmsg@var2595 <<@expr1073748249 "Expression is always true because 'else if' condition is opposite to previous condition at line "
543: <<@expr1073748250 ifCond@var2592 .@expr1073748251 linenr (@expr1073748252 ) <<@expr1073748253 "." ;
544:
545: errorPath@var2594 .@expr6430 emplace_back (@expr1073748255 ifCond@var2592 , "first condition" ) ;
546: errorPath@var2594 .@expr6430 emplace_back (@expr1073748257 elseIfCond@var2593 , "else if condition is opposite to first condition" ) ;
547:
548: reportError (@expr1073748258 errorPath@var2594 , Severity ::@expr1073748259 style , "multiCondition" , errmsg@var2595 .@expr1073748260 str (@expr1073748261 ) , CWE398@var2474 , Certainty ::@expr1073748262 normal ) ;
549: }
550:
|
556:
557: static bool isNonConstFunctionCall ( const Token * ftok@var2596 , const Library & library@var2597 )
558: {
559: if (@expr1073748263 library@var2597 .@expr1073748264 isFunctionConst (@expr1073748265 ftok@var2596 ) ) {
560: return false ; }
561: const Token * obj@var2598 ; obj@var2598 =@expr1073748266 ftok@var2596 .@expr1073748267 next (@expr1073748268 ) .@expr1073748269 astOperand1 (@expr1073748270 ) ;
562: while (@expr1073748271 obj@var2598 &&@expr1073748272 obj@var2598 .@expr1073748273 str (@expr1073748274 ) ==@expr1073748275 "." ) {
563: obj@var2598 =@expr1073748276 obj@var2598 .@expr1073748277 astOperand1 (@expr1073748278 ) ; }
564: if (@expr1073748279 !@expr1073748280 obj@var2598 ) {
565: return true ; }
566: else { if (@expr1073748281 obj@var2598 .@expr6458 variable (@expr6459 ) &&@expr1073748284 obj@var2598 .@expr6458 variable (@expr6459 ) .@expr1073748287 isConst (@expr1073748288 ) ) {
567: return false ; }
568: else { if (@expr1073748289 ftok@var2596 .@expr6466 function (@expr6467 ) &&@expr1073748292 ftok@var2596 .@expr6466 function (@expr6467 ) .@expr1073748295 isConst (@expr1073748296 ) ) {
569: return false ; } } }
570: return true ;
571: }
572:
573: void CheckCondition :: multiCondition2 ( )
574: {
575: if (@expr1073748298 !@expr1073748299 mSettings@var29 .@expr1073748300 severity@var2951 .@expr1073748301 isEnabled (@expr1073748302 Severity ::@expr1073748303 warning ) ) {
576: return ; }
577:
578: const SymbolDatabase * symbolDatabase@var2599 ; symbolDatabase@var2599 =@expr1073748304 mTokenizer@var28 .@expr1073748305 getSymbolDatabase (@expr1073748306 ) ;
579:
580: for (@expr1073748307 const Scope &@expr6484 scope@var2600 :@expr1073748309 symbolDatabase@var2599 .@expr1073748310 scopeList@var2601 ) {
581: const Token * condTok@var2602 ; condTok@var2602 =@expr1073748311 nullptr ;
582: if (@expr1073748312 scope@var2600 .@expr6489 type@var2603 ==@expr1073748314 Scope ::@expr1073748315 eIf ||@expr1073748316 scope@var2600 .@expr6489 type@var2603 ==@expr1073748318 Scope ::@expr1073748319 eWhile ) {
583: condTok@var2602 =@expr1073748320 scope@var2600 .@expr6497 classDef@var2604 .@expr6498 next (@expr6499 ) .@expr6500 astOperand2 (@expr6501 ) ; }
584: else { if (@expr1073748326 scope@var2600 .@expr6489 type@var2603 ==@expr1073748328 Scope ::@expr1073748329 eFor ) {
585: condTok@var2602 =@expr1073748330 scope@var2600 .@expr6497 classDef@var2604 .@expr6498 next (@expr6499 ) .@expr6500 astOperand2 (@expr6501 ) ;
586: if (@expr6512 !@expr6513 condTok@var2602 ||@expr6514 condTok@var2602 .@expr6515 str (@expr6516 ) !=@expr6517 ";" ) {
587: continue ; }
588: condTok@var2602 =@expr1073748342 condTok@var2602 .@expr1073748343 astOperand2 (@expr1073748344 ) ;
589: if (@expr6512 !@expr6513 condTok@var2602 ||@expr6514 condTok@var2602 .@expr6515 str (@expr6516 ) !=@expr6517 ";" ) {
590: continue ; }
591: condTok@var2602 =@expr1073748351 condTok@var2602 .@expr1073748352 astOperand1 (@expr1073748353 ) ;
592: } }
593: if (@expr1073748354 !@expr6513 condTok@var2602 ) {
594: continue ; }
595: const Token * const cond1@var2605 ; cond1@var2605 =@expr1073748356 condTok@var2602 ;
596:
597: if (@expr1073748357 !@expr1073748358 Token ::@expr6535 simpleMatch (@expr1073748360 scope@var2600 .@expr6497 classDef@var2604 .@expr1073748362 linkAt (@expr1073748363 1 ) , ") {" ) ) {
598: continue ; }
599:
600: bool functionCall@var2606 ; functionCall@var2606 =@expr1073748364 false ;
601: bool nonConstFunctionCall@var2607 ; nonConstFunctionCall@var2607 =@expr1073748365 false ;
602: bool nonlocal@var2608 ; nonlocal@var2608 =@expr1073748366 false ;
603: std ::@expr1073748367 set < int > vars@var2609 ;
604: visitAstNodes (@expr1073748368 condTok@var2602 ,
605: [@expr1073748369 &@expr6484 ] (@expr1073748371 const Token *@expr6548 cond@var2610 ) {
606: if (@expr1073748373 Token ::@expr6550 Match (@expr1073748375 cond@var2610 , "%name% (" ) ) {
607: functionCall@var2606 =@expr1073748376 true ;
608: nonConstFunctionCall@var2607 =@expr1073748377 isNonConstFunctionCall (@expr1073748378 cond@var2610 , mSettings@var29 .@expr6555 library@var2952 ) ;
609: if (@expr6556 nonConstFunctionCall@var2607 ) {
610: return ChildrenToVisit ::@expr6557 done ; }
611: }
612:
613: if (@expr1073748382 cond@var2610 .@expr6559 varId (@expr6560 ) ) {
614: vars@var2609 .@expr1073748385 insert (@expr1073748386 cond@var2610 .@expr6559 varId (@expr6560 ) ) ;
615: const Variable * var@var2611 ; var@var2611 =@expr1073748389 cond@var2610 .@expr1073748390 variable (@expr1073748391 ) ;
616: if (@expr1073748392 !@expr6569 nonlocal@var2608 &&@expr1073748394 var@var2611 ) {
617: if (@expr1073748395 !@expr1073748396 (@expr1073748397 var@var2611 .@expr1073748398 isLocal (@expr1073748399 ) ||@expr1073748400 var@var2611 .@expr1073748401 isArgument (@expr1073748402 ) ) ) {
618: nonlocal@var2608 =@expr1073748403 true ; }
619: else { if (@expr1073748404 (@expr1073748405 var@var2611 .@expr1073748406 isPointer (@expr1073748407 ) ||@expr1073748408 var@var2611 .@expr1073748409 isReference (@expr1073748410 ) ) &&@expr1073748411 !@expr1073748412 Token ::@expr6550 Match (@expr1073748414 cond@var2610 .@expr6591 astParent (@expr6592 ) , "%oror%|&&|!" ) ) {
620:
621: nonlocal@var2608 =@expr1073748417 true ; } }
622: }
623: } else { if (@expr1073748418 !@expr6569 nonlocal@var2608 &&@expr1073748420 cond@var2610 .@expr1073748421 isName (@expr1073748422 ) ) {
624:
625: nonlocal@var2608 =@expr1073748423 Token ::@expr6550 Match (@expr1073748425 cond@var2610 .@expr6591 astParent (@expr6592 ) , "%cop%|(|[" ) ||@expr1073748428 Token ::@expr6550 Match (@expr1073748430 cond@var2610 , "%name% ." ) ||@expr1073748431 (@expr1073748432 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) &&@expr1073748435 cond@var2610 .@expr1073748436 str (@expr1073748437 ) ==@expr1073748438 "this" ) ;
626: } else {
627: return ChildrenToVisit ::@expr6615 op1_and_op2 ;
628: } }
629: return ChildrenToVisit ::@expr6616 none ;
630: } ) ;
631:
632: if (@expr6556 nonConstFunctionCall@var2607 ) {
633: continue ; }
634:
635: std ::@expr1073748442 vector < const Variable *@expr6548 > varsInCond@var2612 ;
636: visitAstNodes (@expr1073748444 condTok@var2602 ,
637: [@expr1073748445 &@expr1073748446 varsInCond@var2612 ] (@expr1073748447 const Token *@expr6548 cond@var2613 ) {
638: if (@expr1073748449 cond@var2613 .@expr6626 variable (@expr6627 ) ) {
639: const Variable * var@var2614 ; var@var2614 =@expr1073748452 cond@var2613 .@expr6626 variable (@expr6627 ) ;
640: if (@expr1073748455 std ::@expr1073748456 find (@expr1073748457 varsInCond@var2612 .@expr1073748458 begin (@expr1073748459 ) , varsInCond@var2612 .@expr6636 end (@expr6637 ) , var@var2614 ) ==@expr1073748462 varsInCond@var2612 .@expr6636 end (@expr6637 ) ) {
641: varsInCond@var2612 .@expr1073748465 push_back (@expr1073748466 var@var2614 ) ; }
642: }
643: return ChildrenToVisit ::@expr6615 op1_and_op2 ;
644: } ) ;
645:
646:
647: enum MULTICONDITIONTYPE { INNER , AFTER } ;
648: const Token * tok@var2615 ;
649:
650:
651: std ::@expr1073748468 vector < MULTICONDITIONTYPE > types@var2616 ; types@var2616 =@expr1073748469 {@expr1073748470 MULTICONDITIONTYPE ::@expr6647 INNER@expr6473 } ;
652: if (@expr1073748472 Token ::@expr6550 Match (@expr1073748474 scope@var2600 .@expr6651 bodyStart@var2617 , "{ return|throw|continue|break" ) ) {
653: types@var2616 .@expr1073748476 push_back (@expr1073748477 MULTICONDITIONTYPE ::@expr6654 AFTER ) ; }
654: for (@expr1073748479 MULTICONDITIONTYPE type@var2618 :@expr1073748480 types@var2616 ) {
655: if (@expr1073748481 type@var2618 ==@expr1073748482 MULTICONDITIONTYPE ::@expr6654 AFTER ) {
656: tok@var2615 =@expr1073748484 scope@var2600 .@expr1073748485 bodyEnd@var2619 .@expr1073748486 next (@expr1073748487 ) ;
657: } else {
658: tok@var2615 =@expr1073748488 scope@var2600 .@expr6651 bodyStart@var2617 ;
659: }
660: const Token * const endToken@var2620 ; endToken@var2620 =@expr1073748490 tok@var2615 .@expr6667 scope (@expr6668 ) .@expr1073748493 bodyEnd@var2969 ;
661:
662: for (@expr1073748494 ; tok@var2615 &&@expr1073748495 tok@var2615 !=@expr1073748496 endToken@var2620 ; tok@var2615 =@expr1073748497 tok@var2615 .@expr6674 next (@expr6675 ) ) {
663: if (@expr1073748500 isExpressionChangedAt (@expr1073748501 cond1@var2605 , tok@var2615 , 0 , false , mSettings@var29 , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) ) ) {
664: break ; }
665: if (@expr1073748504 Token ::@expr6550 Match (@expr1073748506 tok@var2615 , "if|return" ) ) {
666: const Token * condStartToken@var2621 ; condStartToken@var2621 =@expr1073748507 tok@var2615 .@expr6684 str (@expr6685 ) ==@expr6686 "if" ?@expr1073748511 tok@var2615 .@expr6674 next (@expr6675 ) :@expr1073748514 tok@var2615 ;
667: const Token * condEndToken@var2622 ; condEndToken@var2622 =@expr1073748515 tok@var2615 .@expr6684 str (@expr6685 ) ==@expr6686 "if" ?@expr1073748519 condStartToken@var2621 .@expr1073748520 link (@expr1073748521 ) :@expr1073748522 Token ::@expr1073748523 findsimplematch (@expr1073748524 condStartToken@var2621 , ";" ) ;
668:
669: if (@expr1073748525 isExpressionChanged (@expr1073748526 cond1@var2605 , condStartToken@var2621 , condEndToken@var2622 , mSettings@var29 , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) ) ) {
670: break ; }
671:
672:
673: const Token * cond2@var2623 ; cond2@var2623 =@expr1073748529 tok@var2615 .@expr6684 str (@expr6685 ) ==@expr6686 "if" ?@expr1073748533 condStartToken@var2621 .@expr1073748534 astOperand2 (@expr1073748535 ) :@expr1073748536 condStartToken@var2621 .@expr1073748537 astOperand1 (@expr1073748538 ) ;
674: const bool isReturnVar@var2624 =@expr1073748539 tok@var2615 .@expr6684 str (@expr6685 ) ==@expr1073748542 "return" &&@expr1073748543 !@expr1073748544 Token ::@expr6550 Match (@expr1073748546 cond2@var2623 , "%cop%" ) ;
675:
676: std ::@expr1073748547 list < std ::@expr6724 pair < const Token *@expr6548 , std ::@expr6724 string > > errorPath@var2625 ;
677:
678: if (@expr1073748551 type@var2618 ==@expr1073748552 MULTICONDITIONTYPE ::@expr6647 INNER@expr6473 ) {
679: visitAstNodes (@expr1073748554 cond1@var2605 , [@expr1073748555 &@expr6484 ] (@expr1073748557 const Token *@expr6548 firstCondition@var2626 ) {
680: if (@expr1073748559 !@expr1073748560 firstCondition@var2626 ) {
681: return ChildrenToVisit ::@expr6616 none ; }
682: if (@expr1073748562 firstCondition@var2626 .@expr1073748563 str (@expr1073748564 ) ==@expr1073748565 "&&" ) {
683: if (@expr1073748566 !@expr1073748567 isOppositeCond (@expr1073748568 false , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , firstCondition@var2626 , cond2@var2623 , mSettings@var29 .@expr6555 library@var2952 , true , true ) ) {
684: return ChildrenToVisit ::@expr6615 op1_and_op2 ; }
685: }
686: if (@expr1073748573 !@expr1073748574 firstCondition@var2626 .@expr1073748575 hasKnownIntValue (@expr1073748576 ) ) {
687: if (@expr1073748577 !@expr6754 isReturnVar@var2624 &&@expr1073748579 isOppositeCond (@expr1073748580 false , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , firstCondition@var2626 , cond2@var2623 , mSettings@var29 .@expr6555 library@var2952 , true , true , &@expr6760 errorPath@var2625 ) ) {
688: if (@expr1073748585 !@expr6762 isAliased (@expr6763 vars@var2609 ) ) {
689: oppositeInnerConditionError (@expr1073748588 firstCondition@var2626 , cond2@var2623 , errorPath@var2625 ) ; }
690: } else { if (@expr1073748589 !@expr6754 isReturnVar@var2624 &&@expr1073748591 isSameExpression (@expr1073748592 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , true , firstCondition@var2626 , cond2@var2623 , mSettings@var29 .@expr6555 library@var2952 , true , true , &@expr6760 errorPath@var2625 ) ) {
691: identicalInnerConditionError (@expr1073748597 firstCondition@var2626 , cond2@var2623 , errorPath@var2625 ) ;
692: } }
693: }
694: return ChildrenToVisit ::@expr6616 none ;
695: } ) ;
696: } else {
697: visitAstNodes (@expr1073748599 cond2@var2623 , [@expr1073748600 &@expr6484 ] (@expr1073748602 const Token *@expr6548 secondCondition@var2627 ) {
698: if (@expr1073748604 secondCondition@var2627 .@expr6781 str (@expr6782 ) ==@expr1073748607 "||" ||@expr1073748608 secondCondition@var2627 .@expr6781 str (@expr6782 ) ==@expr1073748611 "&&" ) {
699: return ChildrenToVisit ::@expr6615 op1_and_op2 ; }
700:
701: if (@expr1073748613 (@expr1073748614 !@expr1073748615 cond1@var2605 .@expr1073748616 hasKnownIntValue (@expr1073748617 ) ||@expr1073748618 !@expr1073748619 secondCondition@var2627 .@expr1073748620 hasKnownIntValue (@expr1073748621 ) ) &&@expr1073748622
702: isSameExpression (@expr1073748623 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , true , cond1@var2605 , secondCondition@var2627 , mSettings@var29 .@expr6555 library@var2952 , true , true , &@expr6760 errorPath@var2625 ) ) {
703: if (@expr1073748628 !@expr6762 isAliased (@expr6763 vars@var2609 ) &&@expr1073748631 !@expr1073748632 mTokenizer@var28 .@expr1073748633 hasIfdef (@expr1073748634 cond1@var2605 , secondCondition@var2627 ) ) {
704: identicalConditionAfterEarlyExitError (@expr1073748635 cond1@var2605 , secondCondition@var2627 , errorPath@var2625 ) ;
705: return ChildrenToVisit ::@expr6557 done ;
706: }
707: }
708: return ChildrenToVisit ::@expr6616 none ;
709: } ) ;
710: }
711: }
712: if (@expr1073748638 Token ::@expr6550 Match (@expr1073748640 tok@var2615 , "%name% (" ) &&@expr1073748641
713: isVariablesChanged (@expr1073748642 tok@var2615 , tok@var2615 .@expr6819 linkAt (@expr6820 1 ) , 0 , varsInCond@var2612 , mSettings@var29 , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) ) ) {
714: break ;
715: }
716: if (@expr1073748647 Token ::@expr6550 Match (@expr1073748649 tok@var2615 , "%type% (" ) &&@expr1073748650 nonlocal@var2608 &&@expr1073748651 isNonConstFunctionCall (@expr1073748652 tok@var2615 , mSettings@var29 .@expr6555 library@var2952 ) ) {
717: break ; }
718: if (@expr1073748654 Token ::@expr6550 Match (@expr1073748656 tok@var2615 , "case|break|continue|return|throw" ) &&@expr1073748657 tok@var2615 .@expr6667 scope (@expr6668 ) ==@expr1073748660 endToken@var2620 .@expr1073748661 scope (@expr1073748662 ) ) {
719: break ; }
720: if (@expr1073748663 Token ::@expr6550 Match (@expr1073748665 tok@var2615 , "[;{}] %name% :" ) ) {
721: break ; }
722:
723:
724: if (@expr1073748666 Token ::@expr6550 Match (@expr1073748668 tok@var2615 , "for|while|do" ) ) {
725: const Token * tok1@var2628 ; tok1@var2628 =@expr1073748669 tok@var2615 .@expr6674 next (@expr6675 ) ;
726: const Token * tok2@var2629 ;
727: if (@expr1073748672 Token ::@expr6535 simpleMatch (@expr1073748674 tok@var2615 , "do {" ) ) {
728: if (@expr1073748675 !@expr1073748676 Token ::@expr6535 simpleMatch (@expr1073748678 tok@var2615 .@expr6819 linkAt (@expr6820 1 ) , "} while (" ) ) {
729: break ; }
730: tok2@var2629 =@expr1073748681 tok@var2615 .@expr6819 linkAt (@expr6820 1 ) .@expr1073748684 linkAt (@expr1073748685 2 ) ;
731: } else { if (@expr1073748686 Token ::@expr6550 Match (@expr1073748688 tok@var2615 , "if|while (" ) ) {
732: tok2@var2629 =@expr1073748689 tok@var2615 .@expr6819 linkAt (@expr6820 1 ) ;
733: if (@expr1073748692 Token ::@expr6535 simpleMatch (@expr1073748694 tok2@var2629 , ") {" ) ) {
734: tok2@var2629 =@expr1073748695 tok2@var2629 .@expr1073748696 linkAt (@expr1073748697 1 ) ; }
735: if (@expr1073748698 !@expr1073748699 tok2@var2629 ) {
736: break ; }
737: } else {
738:
739: break ;
740: } }
741: bool changed@var2630 ; changed@var2630 =@expr1073748700 false ;
742: for (@expr1073748701 int varid@var2631 :@expr1073748702 vars@var2609 ) {
743: if (@expr1073748703 isVariableChanged (@expr1073748704 tok1@var2628 , tok2@var2629 , varid@var2631 , nonlocal@var2608 , mSettings@var29 , mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) ) ) {
744: changed@var2630 =@expr1073748707 true ;
745: break ;
746: }
747: }
748: if (@expr1073748708 changed@var2630 ) {
749: break ; }
750: }
751: if (@expr1073748709 (@expr1073748710 tok@var2615 .@expr6887 varId (@expr6888 ) &&@expr1073748713 vars@var2609 .@expr1073748714 find (@expr1073748715 tok@var2615 .@expr6887 varId (@expr6888 ) ) !=@expr1073748718 vars@var2609 .@expr1073748719 end (@expr1073748720 ) ) ||@expr1073748721
752: (@expr1073748722 !@expr1073748723 tok@var2615 .@expr6887 varId (@expr6888 ) &&@expr1073748726 nonlocal@var2608 ) ||@expr1073748727
753: (@expr1073748728 functionCall@var2606 &&@expr1073748729 tok@var2615 .@expr6906 variable (@expr6907 ) &&@expr1073748732 !@expr1073748733 tok@var2615 .@expr6906 variable (@expr6907 ) .@expr1073748736 isLocal (@expr1073748737 ) ) ) {
754: if (@expr1073748738 Token ::@expr6550 Match (@expr1073748740 tok@var2615 , "%name% %assign%|++|--" ) ) {
755: break ; }
756: if (@expr1073748741 Token ::@expr6550 Match (@expr1073748743 tok@var2615 .@expr1073748744 astParent (@expr1073748745 ) , "*|.|[" ) ) {
757: const Token * parent@var2632 ; parent@var2632 =@expr1073748746 tok@var2615 ;
758: while (@expr1073748747 Token ::@expr6550 Match (@expr1073748749 parent@var2632 .@expr6926 astParent (@expr6927 ) , ".|[" ) ||@expr1073748752 (@expr1073748753 parent@var2632 .@expr6926 astParent (@expr6927 ) &&@expr1073748756 parent@var2632 .@expr6926 astParent (@expr6927 ) .@expr1073748759 isUnaryOp (@expr1073748760 "*" ) ) ) {
759: parent@var2632 =@expr1073748761 parent@var2632 .@expr6926 astParent (@expr6927 ) ; }
760: if (@expr1073748764 Token ::@expr6550 Match (@expr1073748766 parent@var2632 .@expr6926 astParent (@expr6927 ) , "%assign%|++|--" ) ) {
761: break ; }
762: }
763: if (@expr1073748769 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) &&@expr1073748772 Token ::@expr6550 Match (@expr1073748774 tok@var2615 , "%name% <<" ) &&@expr1073748775 (@expr1073748776 !@expr1073748777 tok@var2615 .@expr6954 valueType (@expr6955 ) ||@expr1073748780 !@expr1073748781 tok@var2615 .@expr6954 valueType (@expr6955 ) .@expr1073748784 isIntegral (@expr1073748785 ) ) ) {
764: break ; }
765: if (@expr1073748786 isLikelyStreamRead (@expr1073748787 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , tok@var2615 .@expr6674 next (@expr6675 ) ) ||@expr1073748792 isLikelyStreamRead (@expr1073748793 mTokenizer@var28 .@expr6609 isCPP (@expr6610 ) , tok@var2615 .@expr6972 previous (@expr6973 ) ) ) {
766: break ; }
767: if (@expr1073748798 Token ::@expr6550 Match (@expr1073748800 tok@var2615 , "%name% [" ) ) {
768: const Token * tok2@var2633 ; tok2@var2633 =@expr1073748801 tok@var2615 .@expr6819 linkAt (@expr6820 1 ) ;
769: while (@expr1073748804 Token ::@expr6535 simpleMatch (@expr1073748806 tok2@var2633 , "] [" ) ) {
770: tok2@var2633 =@expr1073748807 tok2@var2633 .@expr1073748808 linkAt (@expr1073748809 1 ) ; }
771: if (@expr1073748810 Token ::@expr6550 Match (@expr1073748812 tok2@var2633 , "] %assign%|++|--" ) ) {
772: break ; }
773: }
774: if (@expr1073748813 Token ::@expr6550 Match (@expr1073748815 tok@var2615 .@expr6972 previous (@expr6973 ) , "++|--|& %name%" ) ) {
775: break ; }
776: if (@expr1073748818 tok@var2615 .@expr6906 variable (@expr6907 ) &&@expr1073748821
777: !@expr1073748822 tok@var2615 .@expr6906 variable (@expr6907 ) .@expr1073748825 isConst (@expr1073748826 ) &&@expr1073748827
778: Token ::@expr6550 Match (@expr1073748829 tok@var2615 , "%name% . %name% (" ) ) {
779: const Function * function@var2634 ; function@var2634 =@expr1073748830 tok@var2615 .@expr1073748831 tokAt (@expr1073748832 2 ) .@expr1073748833 function (@expr1073748834 ) ;
780: if (@expr1073748835 !@expr1073748836 function@var2634 ||@expr1073748837 !@expr1073748838 function@var2634 .@expr1073748839 isConst (@expr1073748840 ) ) {
781: break ; }
782: }
783: if (@expr1073748841 Token ::@expr6550 Match (@expr1073748843 tok@var2615 .@expr6972 previous (@expr6973 ) , "[(,] %name% [,)]" ) &&@expr1073748846 isParameterChanged (@expr1073748847 tok@var2615 ) ) {
784: break ; }
785: }
786: }
787: }
788: }
789: }
790:
791: static std :: string innerSmtString ( const Token * tok@var2635 )
792: {
793: if (@expr1073748848 !@expr1073748849 tok@var2635 ) {
794: return "if" ; }
795: if (@expr1073748850 !@expr1073748851 tok@var2635 .@expr7028 astTop (@expr7029 ) ) {
796: return "if" ; }
797: const Token * top@var2636 ; top@var2636 =@expr1073748854 tok@var2635 .@expr7028 astTop (@expr7029 ) ;
798: if (@expr1073748857 top@var2636 .@expr7034 str (@expr7035 ) ==@expr1073748860 "(" &&@expr1073748861 top@var2636 .@expr7038 astOperand1 (@expr7039 ) ) {
799: return top@var2636 .@expr7038 astOperand1 (@expr7039 ) .@expr1073748866 str (@expr1073748867 ) ; }
800: return top@var2636 .@expr7034 str (@expr7035 ) ;
801: }
802:
803: void CheckCondition :: oppositeInnerConditionError ( const Token * tok1@var2637 , const Token * tok2@var2638 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2639 )
804: {
805: if (@expr1073748870 diag (@expr1073748871 tok1@var2637 ) &@expr1073748872 diag (@expr1073748873 tok2@var2638 ) ) {
806: return ; }
807: const std ::@expr1073748874 string s1@var2640 (@expr1073748875 tok1@var2637 ?@expr1073748876 tok1@var2637 .@expr1073748877 expressionString (@expr1073748878 ) :@expr1073748879 "x" ) ;
808: const std ::@expr1073748880 string s2@var2641 (@expr1073748881 tok2@var2638 ?@expr1073748882 tok2@var2638 .@expr1073748883 expressionString (@expr1073748884 ) :@expr1073748885 "!x" ) ;
809: const std ::@expr7062 string innerSmt@var2642 =@expr1073748887 innerSmtString (@expr1073748888 tok2@var2638 ) ;
810: errorPath@var2639 .@expr7065 emplace_back (@expr1073748890 std ::@expr7067 pair < const Token *@expr7068 , std ::@expr7062 string > (@expr1073748894 tok1@var2637 , "outer condition: " +@expr1073748895 s1@var2640 ) ) ;
811: errorPath@var2639 .@expr7065 emplace_back (@expr1073748897 std ::@expr7067 pair < const Token *@expr7068 , std ::@expr7062 string > (@expr1073748901 tok2@var2638 , "opposite inner condition: " +@expr1073748902 s2@var2641 ) ) ;
812:
813: const std ::@expr1073748903 string msg@var2643 (@expr1073748904 "Opposite inner '" +@expr1073748905 innerSmt@var2642 +@expr1073748906 "' condition leads to a dead code block.\nOpposite inner '"
814: +@expr1073748907 innerSmt@var2642 +@expr1073748908 "' condition leads to a dead code block (outer condition is '" +@expr1073748909 s1@var2640 +@expr1073748910 "' and inner condition is '" +@expr1073748911 s2@var2641 +@expr1073748912 "')." ) ;
815: reportError (@expr1073748913 errorPath@var2639 , Severity ::@expr1073748914 warning , "oppositeInnerCondition" , msg@var2643 , CWE398@var2474 , Certainty ::@expr1073748915 normal ) ;
816: }
817:
818: void CheckCondition :: identicalInnerConditionError ( const Token * tok1@var2644 , const Token * tok2@var2645 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2646 )
819: {
820: if (@expr1073748916 diag (@expr1073748917 tok1@var2644 ) &@expr1073748918 diag (@expr1073748919 tok2@var2645 ) ) {
821: return ; }
822: const std ::@expr1073748920 string s1@var2647 (@expr1073748921 tok1@var2644 ?@expr1073748922 tok1@var2644 .@expr1073748923 expressionString (@expr1073748924 ) :@expr1073748925 "x" ) ;
823: const std ::@expr1073748926 string s2@var2648 (@expr1073748927 tok2@var2645 ?@expr1073748928 tok2@var2645 .@expr1073748929 expressionString (@expr1073748930 ) :@expr1073748931 "x" ) ;
824: const std ::@expr7108 string innerSmt@var2649 =@expr1073748933 innerSmtString (@expr1073748934 tok2@var2645 ) ;
825: errorPath@var2646 .@expr7111 emplace_back (@expr1073748936 std ::@expr7113 pair < const Token *@expr7114 , std ::@expr7108 string > (@expr1073748940 tok1@var2644 , "outer condition: " +@expr1073748941 s1@var2647 ) ) ;
826: errorPath@var2646 .@expr7111 emplace_back (@expr1073748943 std ::@expr7113 pair < const Token *@expr7114 , std ::@expr7108 string > (@expr1073748947 tok2@var2645 , "identical inner condition: " +@expr1073748948 s2@var2648 ) ) ;
827:
828: const std ::@expr1073748949 string msg@var2650 (@expr1073748950 "Identical inner '" +@expr1073748951 innerSmt@var2649 +@expr1073748952 "' condition is always true.\nIdentical inner '"
829: +@expr1073748953 innerSmt@var2649 +@expr1073748954 "' condition is always true (outer condition is '" +@expr1073748955 s1@var2647 +@expr1073748956 "' and inner condition is '" +@expr1073748957 s2@var2648 +@expr1073748958 "')." ) ;
830: reportError (@expr1073748959 errorPath@var2646 , Severity ::@expr1073748960 warning , "identicalInnerCondition" , msg@var2650 , CWE398@var2474 , Certainty ::@expr1073748961 normal ) ;
831: }
832:
833: void CheckCondition :: identicalConditionAfterEarlyExitError ( const Token * cond1@var2651 , const Token * cond2@var2652 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2653 )
834: {
835: if (@expr1073748962 diag (@expr1073748963 cond1@var2651 ) &@expr1073748964 diag (@expr1073748965 cond2@var2652 ) ) {
836: return ; }
837:
838: const bool isReturnValue@var2654 =@expr1073748966 cond2@var2652 &&@expr1073748967 Token ::@expr1073748968 simpleMatch (@expr1073748969 cond2@var2652 .@expr1073748970 astParent (@expr1073748971 ) , "return" ) ;
839:
840: const std ::@expr1073748972 string cond@var2655 (@expr1073748973 cond1@var2651 ?@expr1073748974 cond1@var2651 .@expr1073748975 expressionString (@expr1073748976 ) :@expr1073748977 "x" ) ;
841: const std ::@expr7154 string value@var2656 =@expr1073748979 (@expr1073748980 cond2@var2652 &&@expr1073748981 cond2@var2652 .@expr7158 valueType (@expr7159 ) &&@expr1073748984 cond2@var2652 .@expr7158 valueType (@expr7159 ) .@expr1073748987 type@var2970 ==@expr1073748988 ValueType ::@expr1073748989 Type ::@expr1073748990 BOOL ) ?@expr1073748991 "false" :@expr1073748992 "0" ;
842:
843: errorPath@var2653 .@expr7169 emplace_back (@expr1073748994 std ::@expr7171 pair < const Token *@expr7172 , std ::@expr7154 string > (@expr1073748998 cond1@var2651 , "If condition '" +@expr1073748999 cond@var2655 +@expr1073749000 "' is true, the function will return/exit" ) ) ;
844: errorPath@var2653 .@expr7169 emplace_back (@expr1073749002 std ::@expr7171 pair < const Token *@expr7172 , std ::@expr7154 string > (@expr1073749006 cond2@var2652 , (@expr1073749007 isReturnValue@var2654 ?@expr1073749008 "Returning identical expression '" :@expr1073749009 "Testing identical condition '" ) +@expr1073749010 cond@var2655 +@expr1073749011 "'" ) ) ;
845:
846: reportError (@expr1073749012 errorPath@var2653 ,
847: Severity ::@expr1073749013 warning ,
848: "identicalConditionAfterEarlyExit" ,
849: isReturnValue@var2654
850: ?@expr1073749014 (@expr1073749015 "Identical condition and return expression '" +@expr1073749016 cond@var2655 +@expr1073749017 "', return value is always " +@expr1073749018 value@var2656 )
851: :@expr1073749019 (@expr1073749020 "Identical condition '" +@expr1073749021 cond@var2655 +@expr1073749022 "', second condition is always false" ) ,
852: CWE398@var2474 ,
853: Certainty ::@expr1073749023 normal ) ;
854: }
855:
|
872:
873: static std :: string invertOperatorForOperandSwap ( std :: string s@var2657 )
874: {
875: if (@expr1073749024 s@var2657 [@expr7201 0 ] ==@expr1073749026 '<' ) {
876: s@var2657 [@expr7201 0 ] =@expr1073749028 '>' ; }
877: else { if (@expr1073749029 s@var2657 [@expr7201 0 ] ==@expr1073749031 '>' ) {
878: s@var2657 [@expr7201 0 ] =@expr1073749033 '<' ; } }
879: return s@var2657 ;
880: }
881:
882: template < typename T >
883: static bool checkIntRelation ( const std :: string & op@var2658 , const T value1@var2659 , const T value2@var2660 )
884: {
885: return (@expr7210 op@var2658 ==@expr1073749035 "==" &&@expr1073749036 value1@var2659 ==@expr1073749037 value2@var2660 ) ||@expr1073749038
886: (@expr7210 op@var2658 ==@expr1073749040 "!=" &&@expr1073749041 value1@var2659 !=@expr1073749042 value2@var2660 ) ||@expr1073749043
887: (@expr7210 op@var2658 ==@expr1073749045 ">" &&@expr1073749046 value1@var2659 >@expr1073749047 value2@var2660 ) ||@expr1073749048
888: (@expr7210 op@var2658 ==@expr1073749050 ">=" &&@expr1073749051 value1@var2659 >=@expr1073749052 value2@var2660 ) ||@expr1073749053
889: (@expr7210 op@var2658 ==@expr1073749055 "<" &&@expr1073749056 value1@var2659 <@expr1073749057 value2@var2660 ) ||@expr1073749058
890: (@expr7210 op@var2658 ==@expr1073749060 "<=" &&@expr1073749061 value1@var2659 <=@expr1073749062 value2@var2660 ) ;
891: }
892:
893: static bool checkFloatRelation ( const std :: string & op@var2661 , const double value1@var2662 , const double value2@var2663 )
894: {
895: return (@expr7239 op@var2661 ==@expr1073749064 ">" &&@expr1073749065 value1@var2662 >@expr1073749066 value2@var2663 ) ||@expr1073749067
896: (@expr7239 op@var2661 ==@expr1073749069 ">=" &&@expr1073749070 value1@var2662 >=@expr1073749071 value2@var2663 ) ||@expr1073749072
897: (@expr7239 op@var2661 ==@expr1073749074 "<" &&@expr1073749075 value1@var2662 <@expr1073749076 value2@var2663 ) ||@expr1073749077
898: (@expr7239 op@var2661 ==@expr1073749079 "<=" &&@expr1073749080 value1@var2662 <=@expr1073749081 value2@var2663 ) ;
899: }
900:
|
911:
912: double getvalue3<double> ( const double value1@var2664 , const double value2@var2665 ) ;
902: unsigned long long getvalue3<unsignedlonglong> ( const unsigned long long value1@var2666 , const unsigned long long value2@var2667 ) ; long long getvalue3<longlong> ( const long long value1@var2668 , const long long value2@var2669 ) ;
903:
|
911:
912: double getvalue3<double> ( const double value1@var2670 , const double value2@var2671 )
913: {
914: return (@expr1073749082 value1@var2670 +@expr1073749083 value2@var2671 ) /@expr1073749084 2.0f ;
915: }
916:
917:
918:
919: static double getvalue<double> ( const int test@var2672 , const double value1@var2673 , const double value2@var2674 ) ; static unsigned long long getvalue<unsignedlonglong> ( const int test@var2675 , const unsigned long long value1@var2676 , const unsigned long long value2@var2677 ) ; static long long getvalue<longlong> ( const int test@var2678 , const long long value1@var2679 , const long long value2@var2680 ) ;
920:
|
941:
942: static bool parseComparison ( const Token * comp@var2681 , bool * not1@var2682 , std :: string * op@var2683 , std :: string * value@var2684 , const Token * * expr@var2685 , bool * inconclusive@var2686 )
943: {
944: *@expr7261 not1@var2682 =@expr1073749086 false ;
945: while (@expr1073749087 comp@var2681 &&@expr1073749088 comp@var2681 .@expr7265 str (@expr7266 ) ==@expr1073749091 "!" ) {
946: *@expr7261 not1@var2682 =@expr1073749093 !@expr1073749094 (@expr1073749095 *@expr7261 not1@var2682 ) ;
947: comp@var2681 =@expr1073749097 comp@var2681 .@expr7274 astOperand1 (@expr7275 ) ;
948: }
949:
950: if (@expr1073749100 !@expr1073749101 comp@var2681 ) {
951: return false ; }
952:
953: const Token * op1@var2687 ; op1@var2687 =@expr1073749102 comp@var2681 .@expr7274 astOperand1 (@expr7275 ) ;
954: const Token * op2@var2688 ; op2@var2688 =@expr1073749105 comp@var2681 .@expr7282 astOperand2 (@expr7283 ) ;
955: if (@expr1073749108 !@expr1073749109 comp@var2681 .@expr1073749110 isComparisonOp (@expr1073749111 ) ||@expr1073749112 !@expr1073749113 op1@var2687 ||@expr1073749114 !@expr1073749115 op2@var2688 ) {
956: *@expr7292 op@var2683 =@expr1073749117 "!=" ;
957: *@expr7294 value@var2684 =@expr1073749119 "0" ;
958: *@expr7296 expr@var2685 =@expr1073749121 comp@var2681 ;
959: } else { if (@expr1073749122 op1@var2687 .@expr1073749123 isLiteral (@expr1073749124 ) ) {
960: if (@expr1073749125 op1@var2687 .@expr1073749126 isExpandedMacro (@expr1073749127 ) ) {
961: return false ; }
962: *@expr7292 op@var2683 =@expr1073749129 invertOperatorForOperandSwap (@expr1073749130 comp@var2681 .@expr7265 str (@expr7266 ) ) ;
963: if (@expr1073749133 op1@var2687 .@expr7310 enumerator (@expr7311 ) &&@expr1073749136 op1@var2687 .@expr7310 enumerator (@expr7311 ) .@expr1073749139 value_known@var2971 ) {
964: *@expr7294 value@var2684 =@expr1073749141 MathLib ::@expr7318 toString (@expr1073749143 op1@var2687 .@expr7310 enumerator (@expr7311 ) .@expr1073749146 value@var2972 ) ; }
965: else {
966: *@expr7294 value@var2684 =@expr1073749148 op1@var2687 .@expr1073749149 str (@expr1073749150 ) ; }
967: *@expr7296 expr@var2685 =@expr1073749152 op2@var2688 ;
968: } else { if (@expr1073749153 comp@var2681 .@expr7282 astOperand2 (@expr7283 ) .@expr1073749156 isLiteral (@expr1073749157 ) ) {
969: if (@expr1073749158 op2@var2688 .@expr1073749159 isExpandedMacro (@expr1073749160 ) ) {
970: return false ; }
971: *@expr7292 op@var2683 =@expr1073749162 comp@var2681 .@expr7265 str (@expr7266 ) ;
972: if (@expr1073749165 op2@var2688 .@expr7342 enumerator (@expr7343 ) &&@expr1073749168 op2@var2688 .@expr7342 enumerator (@expr7343 ) .@expr1073749171 value_known@var2971 ) {
973: *@expr7294 value@var2684 =@expr1073749173 MathLib ::@expr7318 toString (@expr1073749175 op2@var2688 .@expr7342 enumerator (@expr7343 ) .@expr1073749178 value@var2972 ) ; }
974: else {
975: *@expr7294 value@var2684 =@expr1073749180 op2@var2688 .@expr1073749181 str (@expr1073749182 ) ; }
976: *@expr7296 expr@var2685 =@expr1073749184 op1@var2687 ;
977: } else {
978: *@expr7292 op@var2683 =@expr1073749186 "!=" ;
979: *@expr7294 value@var2684 =@expr1073749188 "0" ;
980: *@expr7296 expr@var2685 =@expr1073749190 comp@var2681 ;
981: } } }
982:
983: *@expr7367 inconclusive@var2686 =@expr1073749192 *@expr7367 inconclusive@var2686 ||@expr1073749194 (@expr1073749195 (@expr7372 *@expr7294 value@var2684 ) [@expr7374 0 ] ==@expr1073749199 '\'' &&@expr1073749200 !@expr1073749201 (@expr1073749202 *@expr7292 op@var2683 ==@expr1073749204 "!=" ||@expr1073749205 *@expr7292 op@var2683 ==@expr1073749207 "==" ) ) ;
984:
985:
986: if (@expr1073749208 !@expr1073749209 MathLib ::@expr1073749210 isInt (@expr1073749211 *@expr7294 value@var2684 ) &&@expr1073749213 !@expr1073749214 MathLib ::@expr1073749215 isFloat (@expr1073749216 *@expr7294 value@var2684 ) &&@expr1073749218 (@expr7372 *@expr7294 value@var2684 ) [@expr7374 0 ] !=@expr1073749222 '\'' ) {
987: return false ; }
988:
989: return true ;
990: }
991:
992: static std :: string conditionString ( bool not1@var2689 , const Token * expr1@var2690 , const std :: string & op@var2691 , const std :: string & value1@var2692 )
993: {
994: if (@expr1073749223 expr1@var2690 .@expr1073749224 astParent (@expr1073749225 ) .@expr1073749226 isComparisonOp (@expr1073749227 ) ) {
995: return std ::@expr7404 string (@expr1073749229 not1@var2689 ?@expr1073749230 "!(" :@expr1073749231 "" ) +@expr1073749232
996: (@expr1073749233 expr1@var2690 .@expr7410 isName (@expr7411 ) ?@expr7412 expr1@var2690 .@expr7413 str (@expr7414 ) :@expr7415 std ::@expr7404 string (@expr7417 "EXPR" ) ) +@expr1073749242
997: " " +@expr1073749243
998: op@var2691 +@expr1073749244
999: " " +@expr1073749245
1000: value1@var2692 +@expr1073749246
1001: (@expr1073749247 not1@var2689 ?@expr1073749248 ")" :@expr1073749249 "" ) ; }
1002:
1003: return std ::@expr7404 string (@expr1073749251 not1@var2689 ?@expr1073749252 "!" :@expr1073749253 "" ) +@expr1073749254
1004: (@expr1073749255 expr1@var2690 .@expr7410 isName (@expr7411 ) ?@expr7412 expr1@var2690 .@expr7413 str (@expr7414 ) :@expr7415 std ::@expr7404 string (@expr7417 "EXPR" ) ) ;
1005: }
1006:
1007: static std :: string conditionString ( const Token * tok@var2693 )
1008: {
1009: if (@expr1073749264 !@expr1073749265 tok@var2693 ) {
1010: return "" ; }
1011: if (@expr1073749266 tok@var2693 .@expr1073749267 isComparisonOp (@expr1073749268 ) ) {
1012: bool inconclusive@var2694 ; inconclusive@var2694 =@expr1073749269 false ;
1013: bool not_@var2695 ;
1014: std ::@expr1073749270 string op@var2696 ; std ::@expr1073749271 string value@var2697 ;
1015: const Token * expr@var2698 ;
1016: if (@expr1073749272 parseComparison (@expr1073749273 tok@var2693 , &@expr1073749274 not_@var2695 , &@expr1073749275 op@var2696 , &@expr1073749276 value@var2697 , &@expr1073749277 expr@var2698 , &@expr1073749278 inconclusive@var2694 ) &&@expr1073749279 expr@var2698 .@expr1073749280 isName (@expr1073749281 ) ) {
1017: return conditionString (@expr1073749282 not_@var2695 , expr@var2698 , op@var2696 , value@var2697 ) ;
1018: }
1019: }
1020: if (@expr1073749283 Token ::@expr1073749284 Match (@expr1073749285 tok@var2693 , "%cop%|&&|%oror%" ) ) {
1021: if (@expr1073749286 tok@var2693 .@expr7463 astOperand2 (@expr7464 ) ) {
1022: return conditionString (@expr7465 tok@var2693 .@expr7466 astOperand1 (@expr7467 ) ) +@expr1073749292 " " +@expr1073749293 tok@var2693 .@expr7470 str (@expr7471 ) +@expr1073749296 " " +@expr1073749297 conditionString (@expr1073749298 tok@var2693 .@expr7463 astOperand2 (@expr7464 ) ) ; }
1023: return tok@var2693 .@expr7470 str (@expr7471 ) +@expr1073749303 "(" +@expr1073749304 conditionString (@expr7465 tok@var2693 .@expr7466 astOperand1 (@expr7467 ) ) +@expr1073749308 ")" ;
1024:
1025: }
1026: return tok@var2693 .@expr1073749309 expressionString (@expr1073749310 ) ;
1027: }
1028:
1029: static bool isIfConstexpr ( const Token * tok@var2699 ) {
1030: const Token * const top@var2700 ; top@var2700 =@expr1073749311 tok@var2699 .@expr1073749312 astTop (@expr1073749313 ) ;
1031: return top@var2700 &&@expr1073749314 Token ::@expr1073749315 simpleMatch (@expr1073749316 top@var2700 .@expr7493 astOperand1 (@expr7494 ) , "if" ) &&@expr1073749319 top@var2700 .@expr7493 astOperand1 (@expr7494 ) .@expr1073749322 isConstexpr (@expr1073749323 ) ;
1032: }
1033:
1034: void CheckCondition :: checkIncorrectLogicOperator ( )
1035: {
1036: const bool printStyle@var2701 =@expr1073749325 mSettings@var29 .@expr7502 severity@var2951 .@expr7503 isEnabled (@expr1073749328 Severity ::@expr1073749329 style ) ;
1037: const bool printWarning@var2702 =@expr1073749330 mSettings@var29 .@expr7502 severity@var2951 .@expr7503 isEnabled (@expr1073749333 Severity ::@expr1073749334 warning ) ;
1038: if (@expr1073749335 !@expr1073749336 printWarning@var2702 &&@expr1073749337 !@expr1073749338 printStyle@var2701 ) {
1039: return ; }
1040: const bool printInconclusive@var2703 =@expr1073749339 mSettings@var29 .@expr1073749340 certainty@var2953 .@expr1073749341 isEnabled (@expr1073749342 Certainty ::@expr1073749343 inconclusive@expr1073749324 ) ;
1041:
1042: const SymbolDatabase * symbolDatabase@var2704 ; symbolDatabase@var2704 =@expr1073749344 mTokenizer@var28 .@expr1073749345 getSymbolDatabase (@expr1073749346 ) ;
1043: for (@expr1073749347 const Scope *@expr7524 scope@var2705 :@expr1073749349 symbolDatabase@var2704 .@expr1073749350 functionScopes@var2706 ) {
1044:
1045: for (@expr1073749351 const Token *@expr7524 tok@var2707 =@expr1073749353 scope@var2705 .@expr1073749354 bodyStart@var2708 .@expr1073749355 next (@expr1073749356 ) ; tok@var2707 !=@expr1073749357 scope@var2705 .@expr1073749358 bodyEnd@var2709 ; tok@var2707 =@expr1073749359 tok@var2707 .@expr1073749360 next (@expr1073749361 ) ) {
1046: if (@expr1073749362 !@expr1073749363 Token ::@expr1073749364 Match (@expr1073749365 tok@var2707 , "%oror%|&&" ) ||@expr1073749366 !@expr1073749367 tok@var2707 .@expr7544 astOperand1 (@expr7545 ) ||@expr1073749370 !@expr1073749371 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) ) {
1047: continue ; }
1048:
|
1053:
1054: if (@expr1073749374 printStyle@var2701 &&@expr1073749375
1055: (@expr1073749376 (@expr1073749377 tok@var2707 .@expr7554 str (@expr7555 ) ==@expr7556 "||" &&@expr1073749381 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) ==@expr1073749386 "&&" ) ||@expr1073749387
1056: (@expr1073749388 tok@var2707 .@expr7554 str (@expr7555 ) ==@expr7567 "&&" &&@expr1073749392 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) ==@expr1073749397 "||" ) ) ) {
1057: const Token * tok2@var2710 ; tok2@var2710 =@expr1073749398 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7577 astOperand1 (@expr7578 ) ;
1058: if (@expr1073749403 isOppositeCond (@expr1073749404 true , mTokenizer@var28 .@expr7581 isCPP (@expr7582 ) , tok@var2707 .@expr7544 astOperand1 (@expr7545 ) , tok2@var2710 , mSettings@var29 .@expr7585 library@var2952 , true , false ) ) {
1059: std ::@expr1073749410 string expr1@var2711 (@expr1073749411 tok@var2707 .@expr7544 astOperand1 (@expr7545 ) .@expr7590 expressionString (@expr7591 ) ) ;
1060: std ::@expr1073749416 string expr2@var2712 (@expr1073749417 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7577 astOperand1 (@expr7578 ) .@expr7598 expressionString (@expr7599 ) ) ;
1061: std ::@expr1073749424 string expr3@var2713 (@expr1073749425 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7604 astOperand2 (@expr7605 ) .@expr7606 expressionString (@expr7607 ) ) ;
1062:
1063: const std ::@expr7608 string expr1VerboseMsg@var2714 =@expr1073749433 expr1@var2711 ;
1064: const std ::@expr7608 string expr2VerboseMsg@var2715 =@expr1073749435 expr2@var2712 ;
1065: const std ::@expr7608 string expr3VerboseMsg@var2716 =@expr1073749437 expr3@var2713 ;
1066:
1067: if (@expr1073749438 expr1@var2711 .@expr1073749439 length (@expr1073749440 ) +@expr1073749441 expr2@var2712 .@expr1073749442 length (@expr1073749443 ) +@expr1073749444 expr3@var2713 .@expr1073749445 length (@expr1073749446 ) >@expr1073749447 50U ) {
1068: if (@expr1073749448 expr1@var2711 [@expr1073749449 0 ] ==@expr1073749450 '!' &&@expr1073749451 expr2@var2712 [@expr1073749452 0 ] !=@expr1073749453 '!' ) {
1069: expr1@var2711 =@expr1073749454 "!A" ;
1070: expr2@var2712 =@expr1073749455 "A" ;
1071: } else {
1072: expr1@var2711 =@expr1073749456 "A" ;
1073: expr2@var2712 =@expr1073749457 "!A" ;
1074: }
1075:
1076: expr3@var2713 =@expr1073749458 "B" ;
1077: }
1078:
1079: const std ::@expr7608 string cond1@var2717 =@expr1073749460 expr1@var2711 +@expr7637 " " +@expr7638 tok@var2707 .@expr7554 str (@expr7555 ) +@expr1073749465 " (" +@expr1073749466 expr2@var2712 +@expr1073749467 " " +@expr1073749468 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) +@expr1073749473 " " +@expr1073749474 expr3@var2713 +@expr1073749475 ")" ;
1080: const std ::@expr7608 string cond2@var2718 =@expr1073749477 expr1@var2711 +@expr7637 " " +@expr7638 tok@var2707 .@expr7554 str (@expr7555 ) +@expr1073749482 " " +@expr1073749483 expr3@var2713 ;
1081:
1082: const std ::@expr7608 string cond1VerboseMsg@var2719 =@expr1073749485 expr1VerboseMsg@var2714 +@expr7662 " " +@expr7663 tok@var2707 .@expr7554 str (@expr7555 ) +@expr7666 " " +@expr1073749491 expr2VerboseMsg@var2715 +@expr1073749492 " " +@expr1073749493 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) +@expr1073749498 " " +@expr1073749499 expr3VerboseMsg@var2716 ;
1083: const std ::@expr7608 string cond2VerboseMsg@var2720 =@expr1073749501 expr1VerboseMsg@var2714 +@expr7662 " " +@expr7663 tok@var2707 .@expr7554 str (@expr7555 ) +@expr7666 " " +@expr1073749507 expr3VerboseMsg@var2716 ;
1084:
1085: const std ::@expr7608 string msg@var2721 =@expr1073749509 tok2@var2710 .@expr7686 expressionString (@expr7687 ) +@expr7688 ". '" +@expr1073749513 cond1@var2717 +@expr1073749514 "' is equivalent to '" +@expr1073749515 cond2@var2718 +@expr1073749516 "'\nThe condition '"
1086: +@expr1073749517 cond1VerboseMsg@var2719 +@expr1073749518 "' is equivalent to '" +@expr1073749519 cond2VerboseMsg@var2720 +@expr1073749520 "'." ;
1087: redundantConditionError (@expr1073749521 tok@var2707 , msg@var2721 , false ) ;
1088: continue ;
1089: } else { if (@expr1073749522 isSameExpression (@expr1073749523 mTokenizer@var28 .@expr7581 isCPP (@expr7582 ) , false , tok@var2707 .@expr7544 astOperand1 (@expr7545 ) , tok2@var2710 , mSettings@var29 .@expr7585 library@var2952 , true , true ) ) {
1090: std ::@expr1073749529 string expr1@var2722 (@expr1073749530 tok@var2707 .@expr7544 astOperand1 (@expr7545 ) .@expr7590 expressionString (@expr7591 ) ) ;
1091: std ::@expr1073749535 string expr2@var2723 (@expr1073749536 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7577 astOperand1 (@expr7578 ) .@expr7598 expressionString (@expr7599 ) ) ;
1092: std ::@expr1073749543 string expr3@var2724 (@expr1073749544 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7604 astOperand2 (@expr7605 ) .@expr7606 expressionString (@expr7607 ) ) ;
1093:
1094: const std ::@expr7608 string expr1VerboseMsg@var2725 =@expr1073749552 expr1@var2722 ;
1095: const std ::@expr7608 string expr2VerboseMsg@var2726 =@expr1073749554 expr2@var2723 ;
1096: const std ::@expr7608 string expr3VerboseMsg@var2727 =@expr1073749556 expr3@var2724 ;
1097:
1098: if (@expr1073749557 expr1@var2722 .@expr1073749558 length (@expr1073749559 ) +@expr1073749560 expr2@var2723 .@expr1073749561 length (@expr1073749562 ) +@expr1073749563 expr3@var2724 .@expr1073749564 length (@expr1073749565 ) >@expr1073749566 50U ) {
1099: expr1@var2722 =@expr1073749567 "A" ;
1100: expr2@var2723 =@expr1073749568 "A" ;
1101: expr3@var2724 =@expr1073749569 "B" ;
1102: }
1103:
1104: const std ::@expr7608 string cond1@var2728 =@expr1073749571 expr1@var2722 +@expr1073749572 " " +@expr1073749573 tok@var2707 .@expr7554 str (@expr7555 ) +@expr1073749576 " (" +@expr1073749577 expr2@var2723 +@expr1073749578 " " +@expr1073749579 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) +@expr1073749584 " " +@expr1073749585 expr3@var2724 +@expr1073749586 ")" ;
1105: const std ::@expr7608 string cond2@var2729 =@expr1073749588 expr1@var2722 ;
1106:
1107: const std ::@expr7608 string cond1VerboseMsg@var2730 =@expr1073749590 expr1VerboseMsg@var2725 +@expr1073749591 " " +@expr1073749592 tok@var2707 .@expr7554 str (@expr7555 ) +@expr1073749595 " " +@expr1073749596 expr2VerboseMsg@var2726 +@expr1073749597 " " +@expr1073749598 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) .@expr7560 str (@expr7561 ) +@expr1073749603 " " +@expr1073749604 expr3VerboseMsg@var2727 ;
1108: const std ::@expr7608 string &@expr1073749606 cond2VerboseMsg@var2731 =@expr1073749607 expr1VerboseMsg@var2725 ;
1109:
1110: const std ::@expr7608 string msg@var2732 =@expr1073749609 tok2@var2710 .@expr7686 expressionString (@expr7687 ) +@expr7688 ". '" +@expr1073749613 cond1@var2728 +@expr1073749614 "' is equivalent to '" +@expr1073749615 cond2@var2729 +@expr1073749616 "'\nThe condition '"
1111: +@expr1073749617 cond1VerboseMsg@var2730 +@expr1073749618 "' is equivalent to '" +@expr1073749619 cond2VerboseMsg@var2731 +@expr1073749620 "'." ;
1112: redundantConditionError (@expr1073749621 tok@var2707 , msg@var2732 , false ) ;
1113: continue ;
1114: } }
1115: }
1116:
1117:
1118: const Token * comp1@var2733 ; comp1@var2733 =@expr1073749622 tok@var2707 .@expr7544 astOperand1 (@expr7545 ) ;
1119: if (@expr1073749625 comp1@var2733 .@expr1073749626 str (@expr1073749627 ) ==@expr1073749628 tok@var2707 .@expr7554 str (@expr7555 ) ) {
1120: comp1@var2733 =@expr1073749631 comp1@var2733 .@expr1073749632 astOperand2 (@expr1073749633 ) ; }
1121:
1122:
1123: const Token * comp2@var2734 ; comp2@var2734 =@expr1073749634 tok@var2707 .@expr7548 astOperand2 (@expr7549 ) ;
1124:
1125: bool inconclusive@var2735 ; inconclusive@var2735 =@expr1073749637 false ;
1126: bool parseable@var2736 ; parseable@var2736 =@expr1073749638 true ;
1127:
1128:
1129: bool not1@var2737 ;
1130: std ::@expr1073749639 string op1@var2738 ; std ::@expr1073749640 string value1@var2739 ;
1131: const Token * expr1@var2740 ; expr1@var2740 =@expr1073749641 nullptr ;
1132: parseable@var2736 &=@expr1073749642 (@expr1073749643 parseComparison (@expr1073749644 comp1@var2733 , &@expr1073749645 not1@var2737 , &@expr1073749646 op1@var2738 , &@expr1073749647 value1@var2739 , &@expr1073749648 expr1@var2740 , &@expr7825 inconclusive@var2735 ) ) ;
1133:
1134:
1135: bool not2@var2741 ;
1136: std ::@expr1073749650 string op2@var2742 ; std ::@expr1073749651 string value2@var2743 ;
1137: const Token * expr2@var2744 ; expr2@var2744 =@expr1073749652 nullptr ;
1138: parseable@var2736 &=@expr1073749653 (@expr1073749654 parseComparison (@expr1073749655 comp2@var2734 , &@expr1073749656 not2@var2741 , &@expr1073749657 op2@var2742 , &@expr1073749658 value2@var2743 , &@expr1073749659 expr2@var2744 , &@expr7825 inconclusive@var2735 ) ) ;
1139:
1140: if (@expr1073749661 inconclusive@var2735 &&@expr1073749662 !@expr1073749663 printInconclusive@var2703 ) {
1141: continue ; }
1142:
1143: const bool isUnknown@var2745 =@expr1073749664 (@expr1073749665 expr1@var2740 &&@expr1073749666 expr1@var2740 .@expr7843 valueType (@expr7844 ) &&@expr1073749669 expr1@var2740 .@expr7843 valueType (@expr7844 ) .@expr1073749672 type@var2970 ==@expr1073749673 ValueType ::@expr7850 UNKNOWN_TYPE ) ||@expr1073749675
1144: (@expr1073749676 expr2@var2744 &&@expr1073749677 expr2@var2744 .@expr7854 valueType (@expr7855 ) &&@expr1073749680 expr2@var2744 .@expr7854 valueType (@expr7855 ) .@expr1073749683 type@var2970 ==@expr1073749684 ValueType ::@expr7850 UNKNOWN_TYPE ) ;
1145: if (@expr1073749686 isUnknown@var2745 ) {
1146: continue ; }
1147:
1148: const bool isfloat@var2746 =@expr1073749687 astIsFloat (@expr1073749688 expr1@var2740 , true ) ||@expr1073749689 MathLib ::@expr7866 isFloat (@expr1073749691 value1@var2739 ) ||@expr1073749692 astIsFloat (@expr1073749693 expr2@var2744 , true ) ||@expr1073749694 MathLib ::@expr7866 isFloat (@expr1073749696 value2@var2743 ) ;
1149:
1150: std ::@expr1073749697 list < std ::@expr7608 pair < const Token *@expr7524 , std ::@expr7608 string > > errorPath@var2747 ;
1151:
1152:
1153: const bool isLogicalOr@var2748 (@expr1073749701 tok@var2707 .@expr7554 str (@expr7555 ) ==@expr7556 "||" ) ;
1154: if (@expr1073749705 !@expr1073749706 isfloat@var2746 &&@expr1073749707 isOppositeCond (@expr1073749708 isLogicalOr@var2748 , mTokenizer@var28 .@expr7581 isCPP (@expr7582 ) , tok@var2707 .@expr7544 astOperand1 (@expr7545 ) , tok@var2707 .@expr7548 astOperand2 (@expr7549 ) , mSettings@var29 .@expr7585 library@var2952 , true , true , &@expr1073749716 errorPath@var2747 ) ) {
1155: if (@expr1073749717 !@expr1073749718 isIfConstexpr (@expr1073749719 tok@var2707 ) ) {
1156: const bool alwaysTrue@var2749 (@expr1073749720 isLogicalOr@var2748 ) ;
1157: incorrectLogicOperatorError (@expr1073749721 tok@var2707 , conditionString (@expr1073749722 tok@var2707 ) , alwaysTrue@var2749 , inconclusive@var2735 , errorPath@var2747 ) ;
1158: }
1159: continue ;
1160: }
1161:
1162: if (@expr1073749723 !@expr1073749724 parseable@var2736 ) {
1163: continue ; }
1164:
1165: if (@expr1073749725 isSameExpression (@expr1073749726 mTokenizer@var28 .@expr7581 isCPP (@expr7582 ) , true , comp1@var2733 , comp2@var2734 , mSettings@var29 .@expr7585 library@var2952 , true , true ) ) {
1166: continue ; }
1167: if (@expr1073749730 !@expr1073749731 isSameExpression (@expr1073749732 mTokenizer@var28 .@expr7581 isCPP (@expr7582 ) , true , expr1@var2740 , expr2@var2744 , mSettings@var29 .@expr7585 library@var2952 , true , true ) ) {
1168: continue ; }
1169:
|
1172:
1173: if (@expr1073749736 isfloat@var2746 &&@expr1073749737 (@expr1073749738 op1@var2738 ==@expr1073749739 "==" ||@expr1073749740 op1@var2738 ==@expr1073749741 "!=" ||@expr1073749742 op2@var2742 ==@expr1073749743 "==" ||@expr1073749744 op2@var2742 ==@expr1073749745 "!=" ) ) {
1174: continue ; }
1175:
1176:
1177: const double d1@var2750 =@expr1073749746 (@expr7923 isfloat@var2746 ) ?@expr1073749748 MathLib ::@expr7925 toDoubleNumber (@expr1073749750 value1@var2739 ) :@expr1073749751 0 ;
1178: const double d2@var2751 =@expr1073749752 (@expr7923 isfloat@var2746 ) ?@expr1073749754 MathLib ::@expr7925 toDoubleNumber (@expr1073749756 value2@var2743 ) :@expr1073749757 0 ;
1179: const long long i1@var2752 =@expr1073749758 (@expr7923 isfloat@var2746 ) ?@expr1073749760 0 :@expr1073749761 MathLib ::@expr7938 toLongNumber (@expr7939 value1@var2739 ) ;
1180: const long long i2@var2753 =@expr1073749764 (@expr7923 isfloat@var2746 ) ?@expr1073749766 0 :@expr1073749767 MathLib ::@expr7938 toLongNumber (@expr7945 value2@var2743 ) ;
1181: const bool useUnsignedInt@var2754 =@expr1073749770 (@expr1073749771 std ::@expr7948 numeric_limits < long long > ::@expr7949 max (@expr7950 ) ==@expr1073749775 i1@var2752 ) ||@expr1073749776 (@expr1073749777 std ::@expr7948 numeric_limits < long long > ::@expr7949 max (@expr7950 ) ==@expr1073749781 i2@var2753 ) ;
1182: const unsigned long long u1@var2755 =@expr1073749782 (@expr7959 useUnsignedInt@var2754 ) ?@expr1073749784 MathLib ::@expr7938 toLongNumber (@expr7939 value1@var2739 ) :@expr1073749787 0 ;
1183: const unsigned long long u2@var2756 =@expr1073749788 (@expr7959 useUnsignedInt@var2754 ) ?@expr1073749790 MathLib ::@expr7938 toLongNumber (@expr7945 value2@var2743 ) :@expr1073749793 0 ;
1184:
1185: bool alwaysTrue@var2757 ; alwaysTrue@var2757 =@expr1073749794 true ; bool alwaysFalse@var2758 ; alwaysFalse@var2758 =@expr1073749795 true ;
1186: bool firstTrue@var2759 ; firstTrue@var2759 =@expr1073749796 true ; bool secondTrue@var2760 ; secondTrue@var2760 =@expr1073749797 true ;
1187: for (@expr1073749798 int test@var2761 =@expr1073749799 1 ; test@var2761 <=@expr1073749800 5 ; ++@expr1073749801 test@var2761 ) {
1188:
|
1193:
1194: bool result1@var2762 ; bool result2@var2763 ;
1195: if (@expr1073749802 isfloat@var2746 ) {
1196: const double testvalue@var2764 =@expr1073749803 getvalue<double> (@expr1073749804 test@var2761 , d1@var2750 , d2@var2751 ) ;
1197: result1@var2762 =@expr1073749805 checkFloatRelation (@expr1073749806 op1@var2738 , testvalue@var2764 , d1@var2750 ) ;
1198: result2@var2763 =@expr1073749807 checkFloatRelation (@expr1073749808 op2@var2742 , testvalue@var2764 , d2@var2751 ) ;
1199: } else { if (@expr1073749809 useUnsignedInt@var2754 ) {
1200: const unsigned long long testvalue@var2765 =@expr1073749810 getvalue<unsignedlonglong> (@expr1073749811 test@var2761 , u1@var2755 , u2@var2756 ) ;
1201: result1@var2762 =@expr1073749812 checkIntRelation (@expr1073749813 op1@var2738 , testvalue@var2765 , u1@var2755 ) ;
1202: result2@var2763 =@expr1073749814 checkIntRelation (@expr1073749815 op2@var2742 , testvalue@var2765 , u2@var2756 ) ;
1203: } else {
1204: const long long testvalue@var2766 =@expr1073749816 getvalue<longlong> (@expr1073749817 test@var2761 , i1@var2752 , i2@var2753 ) ;
1205: result1@var2762 =@expr1073749818 checkIntRelation (@expr1073749819 op1@var2738 , testvalue@var2766 , i1@var2752 ) ;
1206: result2@var2763 =@expr1073749820 checkIntRelation (@expr1073749821 op2@var2742 , testvalue@var2766 , i2@var2753 ) ;
1207: } }
1208: if (@expr1073749822 not1@var2737 ) {
1209: result1@var2762 =@expr1073749823 !@expr8000 result1@var2762 ; }
1210: if (@expr1073749825 not2@var2741 ) {
1211: result2@var2763 =@expr1073749826 !@expr8003 result2@var2763 ; }
1212: if (@expr1073749828 tok@var2707 .@expr7554 str (@expr7555 ) ==@expr7567 "&&" ) {
1213: alwaysTrue@var2757 &=@expr1073749832 (@expr1073749833 result1@var2762 &&@expr8010 result2@var2763 ) ;
1214: alwaysFalse@var2758 &=@expr1073749835 !@expr1073749836 (@expr1073749837 result1@var2762 &&@expr8010 result2@var2763 ) ;
1215: } else {
1216: alwaysTrue@var2757 &=@expr1073749839 (@expr1073749840 result1@var2762 ||@expr8017 result2@var2763 ) ;
1217: alwaysFalse@var2758 &=@expr1073749842 !@expr1073749843 (@expr1073749844 result1@var2762 ||@expr8017 result2@var2763 ) ;
1218: }
1219: firstTrue@var2759 &=@expr1073749846 !@expr1073749847 (@expr1073749848 !@expr8000 result1@var2762 &&@expr1073749850 result2@var2763 ) ;
1220: secondTrue@var2760 &=@expr1073749851 !@expr1073749852 (@expr1073749853 result1@var2762 &&@expr1073749854 !@expr8003 result2@var2763 ) ;
1221: }
1222:
1223: const std ::@expr7608 string cond1str@var2767 =@expr1073749857 conditionString (@expr1073749858 not1@var2737 , expr1@var2740 , op1@var2738 , value1@var2739 ) ;
1224: const std ::@expr7608 string cond2str@var2768 =@expr1073749860 conditionString (@expr1073749861 not2@var2741 , expr2@var2744 , op2@var2742 , value2@var2743 ) ;
1225: if (@expr1073749862 printWarning@var2702 &&@expr1073749863 (@expr1073749864 alwaysTrue@var2757 ||@expr1073749865 alwaysFalse@var2758 ) ) {
1226: const std ::@expr7608 string text@var2769 =@expr1073749867 cond1str@var2767 +@expr1073749868 " " +@expr1073749869 tok@var2707 .@expr7554 str (@expr7555 ) +@expr1073749872 " " +@expr1073749873 cond2str@var2768 ;
1227: incorrectLogicOperatorError (@expr1073749874 tok@var2707 , text@var2769 , alwaysTrue@var2757 , inconclusive@var2735 , errorPath@var2747 ) ;
1228: } else { if (@expr1073749875 printStyle@var2701 &&@expr1073749876 secondTrue@var2760 ) {
1229: const std ::@expr7608 string text@var2770 =@expr1073749878 "If '" +@expr1073749879 cond1str@var2767 +@expr1073749880 "', the comparison '" +@expr1073749881 cond2str@var2768 +@expr1073749882
1230: "' is always true." ;
1231: redundantConditionError (@expr1073749883 tok@var2707 , text@var2770 , inconclusive@var2735 ) ;
1232: } else { if (@expr1073749884 printStyle@var2701 &&@expr1073749885 firstTrue@var2759 ) {
1233:
1234:
1235:
1236: const std ::@expr7608 string text@var2771 =@expr1073749887 "If '" +@expr1073749888 cond2str@var2768 +@expr1073749889 "', the comparison '" +@expr1073749890 cond1str@var2767 +@expr1073749891
1237: "' is always true." ;
1238: redundantConditionError (@expr1073749892 tok@var2707 , text@var2771 , inconclusive@var2735 ) ;
1239: } } }
1240: }
1241: }
1242: }
1243:
1244: void CheckCondition :: incorrectLogicOperatorError ( const Token * tok@var2772 , const std :: string & condition@var2773 , bool always@var2774 , bool inconclusive@var2775 , std :: list < std :: pair < const Token * , std :: string > > errors@var2776 )
1245: {
1246: if (@expr1073749893 diag (@expr1073749894 tok@var2772 ) ) {
1247: return ; }
1248: errors@var2776 .@expr1073749895 emplace_back (@expr1073749896 tok@var2772 , "" ) ;
1249: if (@expr1073749897 always@var2774 ) {
1250: reportError (@expr1073749898 errors@var2776 , Severity ::@expr8075 warning , "incorrectLogicOperator" ,
1251: "Logical disjunction always evaluates to true: " +@expr1073749900 condition@var2773 +@expr1073749901 ".\nLogical disjunction always evaluates to true: "
1252: +@expr1073749902 condition@var2773 +@expr1073749903 ". Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables?"
1253: , CWE571@var2476 , inconclusive@var2775 ?@expr8080 Certainty ::@expr8081 inconclusive :@expr8082 Certainty ::@expr8083 normal ) ; }
1254: else {
1255: reportError (@expr1073749908 errors@var2776 , Severity ::@expr8075 warning , "incorrectLogicOperator" ,
1256: "Logical conjunction always evaluates to false: " +@expr1073749910 condition@var2773 +@expr1073749911 ".\nLogical conjunction always evaluates to false: "
1257: +@expr1073749912 condition@var2773 +@expr1073749913 ". Are these conditions necessary? Did you intend to use || instead? Are the numbers correct? Are you comparing the correct variables?"
1258: , CWE570@var2475 , inconclusive@var2775 ?@expr8080 Certainty ::@expr8081 inconclusive :@expr8082 Certainty ::@expr8083 normal ) ; }
1259: }
1260:
1261: void CheckCondition :: redundantConditionError ( const Token * tok@var2777 , const std :: string & text@var2778 , bool inconclusive@var2779 )
1262: {
1263: if (@expr1073749918 diag (@expr1073749919 tok@var2777 ) ) {
1264: return ; }
1265: reportError (@expr1073749920 tok@var2777 , Severity ::@expr1073749921 style , "redundantCondition" , "Redundant condition: " +@expr1073749922 text@var2778 , CWE398@var2474 , inconclusive@var2779 ?@expr1073749923 Certainty ::@expr1073749924 inconclusive :@expr1073749925 Certainty ::@expr1073749926 normal ) ;
1266: }
1267:
|
1270:
1271: void CheckCondition :: checkModuloAlwaysTrueFalse ( )
1272: {
1273: if (@expr1073749927 !@expr1073749928 mSettings@var29 .@expr1073749929 severity@var2951 .@expr1073749930 isEnabled (@expr1073749931 Severity ::@expr1073749932 warning ) ) {
1274: return ; }
1275:
1276: const SymbolDatabase * symbolDatabase@var2780 ; symbolDatabase@var2780 =@expr1073749933 mTokenizer@var28 .@expr1073749934 getSymbolDatabase (@expr1073749935 ) ;
1277: for (@expr1073749936 const Scope *@expr8113 scope@var2781 :@expr1073749938 symbolDatabase@var2780 .@expr1073749939 functionScopes@var2782 ) {
1278: for (@expr1073749940 const Token *@expr8113 tok@var2783 =@expr1073749942 scope@var2781 .@expr1073749943 bodyStart@var2784 .@expr1073749944 next (@expr1073749945 ) ; tok@var2783 !=@expr1073749946 scope@var2781 .@expr1073749947 bodyEnd@var2785 ; tok@var2783 =@expr1073749948 tok@var2783 .@expr1073749949 next (@expr1073749950 ) ) {
1279: if (@expr1073749951 !@expr1073749952 tok@var2783 .@expr1073749953 isComparisonOp (@expr1073749954 ) ) {
1280: continue ; }
1281: const Token * num@var2786 ; const Token * modulo@var2787 ;
1282: if (@expr1073749955 Token ::@expr8132 simpleMatch (@expr1073749957 tok@var2783 .@expr8134 astOperand1 (@expr8135 ) , "%" ) &&@expr1073749960 Token ::@expr8137 Match (@expr1073749962 tok@var2783 .@expr8139 astOperand2 (@expr8140 ) , "%num%" ) ) {
1283: modulo@var2787 =@expr1073749965 tok@var2783 .@expr8134 astOperand1 (@expr8135 ) ;
1284: num@var2786 =@expr1073749968 tok@var2783 .@expr8139 astOperand2 (@expr8140 ) ;
1285: } else { if (@expr1073749971 Token ::@expr8137 Match (@expr1073749973 tok@var2783 .@expr8134 astOperand1 (@expr8135 ) , "%num%" ) &&@expr1073749976 Token ::@expr8132 simpleMatch (@expr1073749978 tok@var2783 .@expr8139 astOperand2 (@expr8140 ) , "%" ) ) {
1286: num@var2786 =@expr1073749981 tok@var2783 .@expr8134 astOperand1 (@expr8135 ) ;
1287: modulo@var2787 =@expr1073749984 tok@var2783 .@expr8139 astOperand2 (@expr8140 ) ;
1288: } else {
1289: continue ;
1290: } }
1291:
1292: if (@expr1073749987 Token ::@expr8137 Match (@expr1073749989 modulo@var2787 .@expr8166 astOperand2 (@expr8167 ) , "%num%" ) &&@expr1073749992
1293: MathLib ::@expr1073749993 isLessEqual (@expr1073749994 modulo@var2787 .@expr8166 astOperand2 (@expr8167 ) .@expr8173 str (@expr8174 ) , num@var2786 .@expr1073749999 str (@expr1073750000 ) ) ) {
1294: moduloAlwaysTrueFalseError (@expr1073750001 tok@var2783 , modulo@var2787 .@expr8166 astOperand2 (@expr8167 ) .@expr8173 str (@expr8174 ) ) ; }
1295: }
1296: }
1297: }
1298:
1299: void CheckCondition :: moduloAlwaysTrueFalseError ( const Token * tok@var2788 , const std :: string & maxVal@var2789 )
1300: {
1301: reportError (@expr1073750006 tok@var2788 , Severity ::@expr1073750007 warning , "moduloAlwaysTrueFalse" ,
1302: "Comparison of modulo result is predetermined, because it is always less than " +@expr1073750008 maxVal@var2789 +@expr1073750009 "." , CWE398@var2474 , Certainty ::@expr1073750010 normal ) ;
1303: }
1304:
1305: static int countPar ( const Token * tok1@var2790 , const Token * tok2@var2791 )
1306: {
1307: int par@var2792 ; par@var2792 =@expr1073750011 0 ;
1308: for (@expr1073750012 const Token *@expr1073750013 tok@var2793 =@expr1073750014 tok1@var2790 ; tok@var2793 &&@expr1073750015 tok@var2793 !=@expr1073750016 tok2@var2791 ; tok@var2793 =@expr1073750017 tok@var2793 .@expr1073750018 next (@expr1073750019 ) ) {
1309: if (@expr1073750020 tok@var2793 .@expr8197 str (@expr8198 ) ==@expr1073750023 "(" ) {
1310: ++@expr1073750024 par@var2792 ; }
1311: else { if (@expr1073750025 tok@var2793 .@expr8197 str (@expr8198 ) ==@expr1073750028 ")" ) {
1312: --@expr1073750029 par@var2792 ; }
1313: else { if (@expr1073750030 tok@var2793 .@expr8197 str (@expr8198 ) ==@expr1073750033 ";" ) {
1314: return -1 ; } } }
1315: }
1316: return par@var2792 ;
1317: }
1318:
|
1322:
1323: void CheckCondition :: clarifyCondition ( )
1324: {
1325: if (@expr1073750034 !@expr1073750035 mSettings@var29 .@expr1073750036 severity@var2951 .@expr1073750037 isEnabled (@expr1073750038 Severity ::@expr1073750039 style ) ) {
1326: return ; }
1327:
1328: const bool isC@var2794 =@expr1073750040 mTokenizer@var28 .@expr1073750041 isC (@expr1073750042 ) ;
1329:
1330: const SymbolDatabase * symbolDatabase@var2795 ; symbolDatabase@var2795 =@expr1073750043 mTokenizer@var28 .@expr1073750044 getSymbolDatabase (@expr1073750045 ) ;
1331: for (@expr1073750046 const Scope *@expr8223 scope@var2796 :@expr1073750048 symbolDatabase@var2795 .@expr1073750049 functionScopes@var2797 ) {
1332: for (@expr1073750050 const Token *@expr8223 tok@var2798 =@expr1073750052 scope@var2796 .@expr1073750053 bodyStart@var2799 .@expr1073750054 next (@expr1073750055 ) ; tok@var2798 !=@expr1073750056 scope@var2796 .@expr1073750057 bodyEnd@var2800 ; tok@var2798 =@expr1073750058 tok@var2798 .@expr1073750059 next (@expr1073750060 ) ) {
1333: if (@expr1073750061 Token ::@expr8238 Match (@expr1073750063 tok@var2798 , "( %name% [=&|^]" ) ) {
1334: for (@expr1073750064 const Token *@expr8223 tok2@var2801 =@expr1073750066 tok@var2798 .@expr1073750067 tokAt (@expr1073750068 3 ) ; tok2@var2801 ; tok2@var2801 =@expr1073750069 tok2@var2801 .@expr1073750070 next (@expr1073750071 ) ) {
1335: if (@expr1073750072 tok2@var2801 .@expr8249 str (@expr8250 ) ==@expr1073750075 "(" ||@expr1073750076 tok2@var2801 .@expr8249 str (@expr8250 ) ==@expr1073750079 "[" ) {
1336: tok2@var2801 =@expr1073750080 tok2@var2801 .@expr8257 link (@expr8258 ) ; }
1337: else { if (@expr1073750083 tok2@var2801 .@expr1073750084 isComparisonOp (@expr1073750085 ) ) {
1338:
1339: if (@expr1073750086 !@expr1073750087 isC@var2794 &&@expr1073750088 tok2@var2801 .@expr8257 link (@expr8258 ) ) {
1340: break ; }
1341: if (@expr1073750091 Token ::@expr1073750092 simpleMatch (@expr1073750093 tok2@var2801 .@expr1073750094 astParent (@expr1073750095 ) , "?" ) ) {
1342: break ; }
1343: clarifyConditionError (@expr1073750096 tok@var2798 , tok@var2798 .@expr1073750097 strAt (@expr1073750098 2 ) ==@expr1073750099 "=" , false ) ;
1344: break ;
1345: } else { if (@expr1073750100 !@expr1073750101 tok2@var2801 .@expr1073750102 isName (@expr1073750103 ) &&@expr1073750104 !@expr1073750105 tok2@var2801 .@expr1073750106 isNumber (@expr1073750107 ) &&@expr1073750108 tok2@var2801 .@expr8249 str (@expr8250 ) !=@expr1073750111 "." ) {
1346: break ; } } }
1347: }
1348: } else { if (@expr1073750112 tok@var2798 .@expr1073750113 tokType (@expr1073750114 ) ==@expr1073750115 Token ::@expr1073750116 eBitOp &&@expr1073750117 !@expr1073750118 tok@var2798 .@expr1073750119 isUnaryOp (@expr1073750120 "&" ) ) {
1349: if (@expr1073750121 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) &&@expr1073750124 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) .@expr8303 variable (@expr8304 ) &&@expr1073750129 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) .@expr8303 variable (@expr8304 ) .@expr1073750134 nameToken (@expr1073750135 ) ==@expr1073750136 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) ) {
1350: continue ; }
1351:
1352:
1353: const ValueType * vt1@var2802 ; vt1@var2802 =@expr1073750139 tok@var2798 .@expr8316 astOperand1 (@expr8317 ) ?@expr1073750142 tok@var2798 .@expr8316 astOperand1 (@expr8317 ) .@expr1073750145 valueType (@expr1073750146 ) :@expr1073750147 nullptr ;
1354: const ValueType * vt2@var2803 ; vt2@var2803 =@expr1073750148 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) ?@expr1073750151 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) .@expr1073750154 valueType (@expr1073750155 ) :@expr1073750156 nullptr ;
1355: if (@expr1073750157 vt1@var2802 &&@expr1073750158 vt1@var2802 .@expr1073750159 type@var2804 ==@expr1073750160 ValueType ::@expr8337 BOOL &&@expr1073750162 !@expr1073750163 Token ::@expr8238 Match (@expr1073750165 tok@var2798 .@expr8316 astOperand1 (@expr8317 ) , "%name%|(|[|::|." ) &&@expr1073750168 countPar (@expr1073750169 tok@var2798 .@expr8316 astOperand1 (@expr8317 ) , tok@var2798 ) ==@expr1073750172 0 ) {
1356: clarifyConditionError (@expr8349 tok@var2798 , false , true ) ; }
1357: else { if (@expr1073750174 vt2@var2803 &&@expr1073750175 vt2@var2803 .@expr1073750176 type@var2805 ==@expr1073750177 ValueType ::@expr8337 BOOL &&@expr1073750179 !@expr1073750180 Token ::@expr8238 Match (@expr1073750182 tok@var2798 .@expr8298 astOperand2 (@expr8299 ) , "%name%|(|[|::|." ) &&@expr1073750185 countPar (@expr1073750186 tok@var2798 , tok@var2798 .@expr8298 astOperand2 (@expr8299 ) ) ==@expr1073750189 0 ) {
1358: clarifyConditionError (@expr8349 tok@var2798 , false , true ) ; } }
1359: } }
1360: }
1361: }
1362: }
1363:
1364: void CheckCondition :: clarifyConditionError ( const Token * tok@var2806 , bool assign@var2807 , bool boolop@var2808 )
1365: {
1366: std ::@expr1073750191 string errmsg@var2809 ;
1367:
1368: if (@expr1073750192 assign@var2807 ) {
1369: errmsg@var2809 =@expr1073750193 "Suspicious condition (assignment + comparison); Clarify expression with parentheses." ; }
1370:
1371: else { if (@expr1073750194 boolop@var2808 ) {
1372: errmsg@var2809 =@expr1073750195 "Boolean result is used in bitwise operation. Clarify expression with parentheses.\nSuspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses."
1373:
1374:
1375: ; }
1376: else {
1377: errmsg@var2809 =@expr1073750196 "Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\nSuspicious condition. Comparison operators have higher precedence than bitwise operators. Please clarify the condition with parentheses."
1378:
1379: ; } }
1380:
1381: reportError (@expr1073750197 tok@var2806 ,
1382: Severity ::@expr1073750198 style ,
1383: "clarifyCondition" ,
1384: errmsg@var2809 , CWE398@var2474 , Certainty ::@expr1073750199 normal ) ;
1385: }
1386:
1387: void CheckCondition :: alwaysTrueFalse ( )
1388: {
1389: if (@expr1073750200 !@expr1073750201 mSettings@var29 .@expr1073750202 severity@var2951 .@expr1073750203 isEnabled (@expr1073750204 Severity ::@expr1073750205 style ) ) {
1390: return ; }
1391:
1392: const SymbolDatabase * symbolDatabase@var2810 ; symbolDatabase@var2810 =@expr1073750206 mTokenizer@var28 .@expr1073750207 getSymbolDatabase (@expr1073750208 ) ;
1393: for (@expr1073750209 const Scope *@expr8386 scope@var2811 :@expr1073750211 symbolDatabase@var2810 .@expr1073750212 functionScopes@var2812 ) {
1394: for (@expr1073750213 const Token *@expr8386 tok@var2813 =@expr1073750215 scope@var2811 .@expr1073750216 bodyStart@var2814 .@expr1073750217 next (@expr1073750218 ) ; tok@var2813 !=@expr1073750219 scope@var2811 .@expr1073750220 bodyEnd@var2815 ; tok@var2813 =@expr1073750221 tok@var2813 .@expr1073750222 next (@expr1073750223 ) ) {
1395: if (@expr1073750224 Token ::@expr8401 simpleMatch (@expr1073750226 tok@var2813 , "<" ) &&@expr1073750227 tok@var2813 .@expr1073750228 link (@expr1073750229 ) ) {
1396: continue ; }
1397: if (@expr1073750230 !@expr1073750231 tok@var2813 .@expr1073750232 hasKnownIntValue (@expr1073750233 ) ) {
1398: continue ; }
1399: if (@expr1073750234 Token ::@expr8411 Match (@expr1073750236 tok@var2813 .@expr8413 previous (@expr8414 ) , "%name% (" ) &&@expr1073750239 tok@var2813 .@expr8413 previous (@expr8414 ) .@expr8418 function (@expr8419 ) ) {
1400: const Function * f@var2816 ; f@var2816 =@expr1073750244 tok@var2813 .@expr8413 previous (@expr8414 ) .@expr8418 function (@expr8419 ) ;
1401: if (@expr1073750249 f@var2816 .@expr8426 functionScope@var2817 &&@expr1073750251 Token ::@expr8411 Match (@expr1073750253 f@var2816 .@expr8426 functionScope@var2817 .@expr1073750255 bodyStart@var2818 , "{ return true|false ;" ) ) {
1402: continue ; }
1403: }
1404: {
1405:
1406: const Token * parent@var2819 ; parent@var2819 =@expr1073750256 tok@var2813 .@expr8433 astParent (@expr8434 ) ;
1407: while (@expr1073750259 Token ::@expr8411 Match (@expr1073750261 parent@var2819 , "%oror%|&&" ) ) {
1408: parent@var2819 =@expr1073750262 parent@var2819 .@expr8439 astParent (@expr8440 ) ; }
1409: if (@expr1073750265 !@expr1073750266 parent@var2819 ) {
1410: continue ; }
1411: const Token * condition@var2820 ; condition@var2820 =@expr1073750267 nullptr ;
1412: if (@expr1073750268 parent@var2819 .@expr8445 str (@expr8446 ) ==@expr1073750271 "?" &&@expr1073750272 precedes (@expr1073750273 tok@var2813 , parent@var2819 ) ) {
1413: condition@var2820 =@expr1073750274 parent@var2819 .@expr8451 astOperand1 (@expr8452 ) ; }
1414: else { if (@expr1073750277 Token ::@expr8411 Match (@expr1073750279 parent@var2819 .@expr1073750280 previous (@expr1073750281 ) , "if|while (" ) ) {
1415: condition@var2820 =@expr1073750282 parent@var2819 .@expr1073750283 astOperand2 (@expr1073750284 ) ; }
1416: else { if (@expr1073750285 Token ::@expr8401 simpleMatch (@expr1073750287 parent@var2819 , "return" ) ) {
1417: condition@var2820 =@expr1073750288 parent@var2819 .@expr8451 astOperand1 (@expr8452 ) ; }
1418: else { if (@expr1073750291 parent@var2819 .@expr8445 str (@expr8446 ) ==@expr1073750294 ";" &&@expr1073750295 parent@var2819 .@expr8439 astParent (@expr8440 ) &&@expr1073750298 parent@var2819 .@expr8439 astParent (@expr8440 ) .@expr8477 astParent (@expr8478 ) &&@expr1073750303 Token ::@expr8401 simpleMatch (@expr1073750305 parent@var2819 .@expr8439 astParent (@expr8440 ) .@expr8477 astParent (@expr8478 ) .@expr1073750310 previous (@expr1073750311 ) , "for (" ) ) {
1419: condition@var2820 =@expr1073750312 parent@var2819 .@expr8451 astOperand1 (@expr8452 ) ; }
1420: else {
1421: continue ; } } } }
1422: (@expr1073750315 void ) condition@var2820 ;
1423: }
1424:
1425: if (@expr1073750316 diag (@expr1073750317 tok@var2813 , false ) ) {
1426: continue ; }
1427: if (@expr1073750318 Token ::@expr8411 Match (@expr1073750320 tok@var2813 , "%num%|%bool%|%char%" ) ) {
1428: continue ; }
1429: if (@expr1073750321 Token ::@expr8411 Match (@expr1073750323 tok@var2813 , "! %num%|%bool%|%char%" ) ) {
1430: continue ; }
1431: if (@expr1073750324 Token ::@expr8411 Match (@expr1073750326 tok@var2813 , "%oror%|&&|:" ) ) {
1432: continue ; }
1433: if (@expr1073750327 Token ::@expr8411 Match (@expr1073750329 tok@var2813 , "%comp%" ) &&@expr1073750330 isSameExpression (@expr1073750331 mTokenizer@var28 .@expr1073750332 isCPP (@expr1073750333 ) , true , tok@var2813 .@expr8510 astOperand1 (@expr8511 ) , tok@var2813 .@expr8512 astOperand2 (@expr8513 ) , mSettings@var29 .@expr1073750338 library@var2952 , true , true ) ) {
1434: continue ; }
1435: if (@expr1073750339 isConstVarExpression (@expr1073750340 tok@var2813 , "[|(|&|+|-|*|/|%|^|>>|<<" ) ) {
1436: continue ; }
1437:
1438:
1439:
1440: {
1441: const ValueFlow ::@expr1073750341 Value * zeroValue@var2821 ; zeroValue@var2821 =@expr1073750342 nullptr ;
1442: const Token * nonZeroExpr@var2822 ; nonZeroExpr@var2822 =@expr1073750343 nullptr ;
1443: if (@expr1073750344 CheckOther ::@expr1073750345 comparisonNonZeroExpressionLessThanZero (@expr1073750346 tok@var2813 , &@expr8523 zeroValue@var2821 , &@expr8524 nonZeroExpr@var2822 ) ||@expr1073750349 CheckOther ::@expr1073750350 testIfNonZeroExpressionIsPositive (@expr1073750351 tok@var2813 , &@expr8523 zeroValue@var2821 , &@expr8524 nonZeroExpr@var2822 ) ) {
1444: continue ; }
1445: }
1446:
1447: const bool constIfWhileExpression@var2823 =@expr1073750354
1448: tok@var2813 .@expr8433 astParent (@expr8434 ) &&@expr1073750357 Token ::@expr8411 Match (@expr1073750359 tok@var2813 .@expr8536 astTop (@expr8537 ) .@expr8538 astOperand1 (@expr8539 ) , "if|while" ) &&@expr1073750364 !@expr1073750365 tok@var2813 .@expr8536 astTop (@expr8537 ) .@expr8538 astOperand1 (@expr8539 ) .@expr1073750370 isConstexpr (@expr1073750371 ) &&@expr1073750372
1449: (@expr1073750373 Token ::@expr8411 Match (@expr1073750375 tok@var2813 .@expr8433 astParent (@expr8434 ) , "%oror%|&&" ) ||@expr1073750378 Token ::@expr8411 Match (@expr1073750380 tok@var2813 .@expr8433 astParent (@expr8434 ) .@expr1073750383 astOperand1 (@expr1073750384 ) , "if|while" ) ) ;
1450: const bool constValExpr@var2824 =@expr1073750385 tok@var2813 .@expr1073750386 isNumber (@expr1073750387 ) &&@expr1073750388 Token ::@expr8411 Match (@expr1073750390 tok@var2813 .@expr8433 astParent (@expr8434 ) , "%oror%|&&|?" ) ;
1451: const bool compExpr@var2825 =@expr1073750393 Token ::@expr8411 Match (@expr1073750395 tok@var2813 , "%comp%|!" ) ;
1452: const bool ternaryExpression@var2826 =@expr1073750396 Token ::@expr8401 simpleMatch (@expr1073750398 tok@var2813 .@expr8433 astParent (@expr8434 ) , "?" ) ;
1453: const bool returnExpression@var2827 =@expr1073750401 Token ::@expr8401 simpleMatch (@expr1073750403 tok@var2813 .@expr8536 astTop (@expr8537 ) , "return" ) &&@expr1073750406 (@expr1073750407 tok@var2813 .@expr1073750408 isComparisonOp (@expr1073750409 ) ||@expr1073750410 Token ::@expr8411 Match (@expr1073750412 tok@var2813 , "&&|%oror%" ) ) ;
1454:
1455: if (@expr1073750413 !@expr1073750414 (@expr1073750415 constIfWhileExpression@var2823 ||@expr1073750416 constValExpr@var2824 ||@expr1073750417 compExpr@var2825 ||@expr1073750418 ternaryExpression@var2826 ||@expr1073750419 returnExpression@var2827 ) ) {
1456: continue ; }
1457:
1458: const Token * expr1@var2828 ; expr1@var2828 =@expr1073750420 tok@var2813 .@expr8510 astOperand1 (@expr8511 ) ; const Token * expr2@var2829 ; expr2@var2829 =@expr1073750423 tok@var2813 .@expr8512 astOperand2 (@expr8513 ) ;
1459: const bool isUnknown@var2830 =@expr1073750426 (@expr1073750427 expr1@var2828 &&@expr1073750428 expr1@var2828 .@expr8605 valueType (@expr8606 ) &&@expr1073750431 expr1@var2828 .@expr8605 valueType (@expr8606 ) .@expr1073750434 type@var2970 ==@expr1073750435 ValueType ::@expr8612 UNKNOWN_TYPE ) ||@expr1073750437
1460: (@expr1073750438 expr2@var2829 &&@expr1073750439 expr2@var2829 .@expr8616 valueType (@expr8617 ) &&@expr1073750442 expr2@var2829 .@expr8616 valueType (@expr8617 ) .@expr1073750445 type@var2970 ==@expr1073750446 ValueType ::@expr8612 UNKNOWN_TYPE ) ;
1461: if (@expr1073750448 isUnknown@var2830 ) {
1462: continue ; }
1463:
1464:
1465: bool isExpandedMacro@var2831 ; isExpandedMacro@var2831 =@expr1073750449 false ;
1466: visitAstNodes (@expr1073750450 tok@var2813 , [@expr1073750451 &@expr8628 ] (@expr1073750453 const Token *@expr8386 tok2@var2832 ) {
1467: if (@expr1073750455 !@expr1073750456 tok2@var2832 ) {
1468: return ChildrenToVisit ::@expr8633 none ; }
1469: if (@expr1073750458 tok2@var2832 .@expr1073750459 isExpandedMacro (@expr1073750460 ) ) {
1470: isExpandedMacro@var2831 =@expr1073750461 true ;
1471: return ChildrenToVisit ::@expr1073750462 done ;
1472: }
1473: return ChildrenToVisit ::@expr8639 op1_and_op2 ;
1474: } ) ;
1475: if (@expr8640 isExpandedMacro@var2831 ) {
1476: continue ; }
1477: for (@expr1073750465 const Token *@expr8386 parent@var2833 =@expr1073750467 tok@var2813 ; parent@var2833 ; parent@var2833 =@expr1073750468 parent@var2833 .@expr1073750469 astParent (@expr1073750470 ) ) {
1478: if (@expr1073750471 parent@var2833 .@expr1073750472 isExpandedMacro (@expr1073750473 ) ) {
1479: isExpandedMacro@var2831 =@expr1073750474 true ;
1480: break ;
1481: }
1482: }
1483: if (@expr8640 isExpandedMacro@var2831 ) {
1484: continue ; }
1485:
1486:
1487: bool hasSizeof@var2834 ; hasSizeof@var2834 =@expr1073750476 false ;
1488: visitAstNodes (@expr1073750477 tok@var2813 , [@expr1073750478 &@expr8628 ] (@expr1073750480 const Token *@expr8386 tok2@var2835 ) {
1489: if (@expr1073750482 !@expr1073750483 tok2@var2835 ) {
1490: return ChildrenToVisit ::@expr8633 none ; }
1491: if (@expr1073750485 tok2@var2835 .@expr1073750486 isNumber (@expr1073750487 ) ) {
1492: return ChildrenToVisit ::@expr8633 none ; }
1493: if (@expr1073750489 Token ::@expr8401 simpleMatch (@expr1073750491 tok2@var2835 .@expr1073750492 previous (@expr1073750493 ) , "sizeof (" ) ) {
1494: hasSizeof@var2834 =@expr1073750494 true ;
1495: return ChildrenToVisit ::@expr8633 none ;
1496: }
1497: if (@expr1073750496 tok2@var2835 .@expr1073750497 isComparisonOp (@expr1073750498 ) ||@expr1073750499 tok2@var2835 .@expr1073750500 isArithmeticalOp (@expr1073750501 ) ) {
1498: return ChildrenToVisit ::@expr8639 op1_and_op2 ;
1499: }
1500: return ChildrenToVisit ::@expr8633 none ;
1501: } ) ;
1502: if (@expr1073750504 hasSizeof@var2834 ) {
1503: continue ; }
1504:
1505: if (@expr1073750505 isIfConstexpr (@expr1073750506 tok@var2813 ) ) {
1506: continue ; }
1507:
1508: alwaysTrueFalseError (@expr1073750507 tok@var2813 , &@expr1073750508 tok@var2813 .@expr1073750509 values (@expr1073750510 ) .@expr1073750511 front (@expr1073750512 ) ) ;
1509: }
1510: }
1511: }
1512:
1513: void CheckCondition :: alwaysTrueFalseError ( const Token * tok@var2836 , const ValueFlow :: Value * value@var2837 )
1514: {
1515: const bool alwaysTrue@var2838 =@expr1073750513 value@var2837 &&@expr1073750514 (@expr1073750515 value@var2837 .@expr1073750516 intvalue@var2839 !=@expr1073750517 0 ) ;
1516: const std ::@expr8694 string expr@var2840 =@expr1073750519 tok@var2836 ?@expr1073750520 tok@var2836 .@expr1073750521 expressionString (@expr1073750522 ) :@expr1073750523 std ::@expr1073750524 string (@expr1073750525 "x" ) ;
1517: const std ::@expr8694 string errmsg@var2841 =@expr1073750527 "Condition '" +@expr1073750528 expr@var2840 +@expr1073750529 "' is always " +@expr1073750530 (@expr1073750531 alwaysTrue@var2838 ?@expr1073750532 "true" :@expr1073750533 "false" ) ;
1518: const std ::@expr1073750534 list < std ::@expr8694 pair < const Token *@expr1073750536 , std ::@expr8694 string > > errorPath@var2842 =@expr1073750538 getErrorPath (@expr1073750539 tok@var2836 , value@var2837 , errmsg@var2841 ) ;
1519: reportError (@expr1073750540 errorPath@var2842 ,
1520: Severity ::@expr1073750541 style ,
1521: "knownConditionTrueFalse" ,
1522: errmsg@var2841 ,
1523: alwaysTrue@var2838 ?@expr1073750542 CWE571@var2476 :@expr1073750543 CWE570@var2475 , Certainty ::@expr1073750544 normal ) ;
1524: }
1525:
1526: void CheckCondition :: checkInvalidTestForOverflow ( )
1527: {
1528:
|
1540:
1541: if (@expr1073750545 !@expr1073750546 mSettings@var29 .@expr1073750547 severity@var2951 .@expr1073750548 isEnabled (@expr1073750549 Severity ::@expr1073750550 warning ) ) {
1542: return ; }
1543:
1544: for (@expr1073750551 const Token *@expr8728 tok@var2843 =@expr1073750553 mTokenizer@var28 .@expr1073750554 tokens (@expr1073750555 ) ; tok@var2843 ; tok@var2843 =@expr1073750556 tok@var2843 .@expr1073750557 next (@expr1073750558 ) ) {
1545: if (@expr1073750559 !@expr1073750560 Token ::@expr8737 Match (@expr1073750562 tok@var2843 , "<|<=|>=|>" ) ||@expr1073750563 !@expr1073750564 tok@var2843 .@expr1073750565 isBinaryOp (@expr1073750566 ) ) {
1546: continue ; }
1547:
1548: const Token * lhsTokens@var2844 [@expr1073750567 2 ] =@expr1073750568 {@expr1073750569 tok@var2843 .@expr1073750570 astOperand1 (@expr1073750571 ) , tok@var2843 .@expr8748 astOperand2 (@expr8749 ) } ;
1549: for (@expr1073750574 const Token *@expr8728 lhs@var2845 :@expr1073750576 lhsTokens@var2844 ) {
1550: std ::@expr1073750577 string cmp@var2846 ; cmp@var2846 =@expr1073750578 tok@var2843 .@expr1073750579 str (@expr1073750580 ) ;
1551: if (@expr1073750581 lhs@var2845 ==@expr1073750582 tok@var2843 .@expr8748 astOperand2 (@expr8749 ) ) {
1552: cmp@var2846 [@expr8761 0 ] =@expr1073750586 (@expr1073750587 cmp@var2846 [@expr8761 0 ] ==@expr8765 '<' ) ?@expr8766 '>' :@expr8767 '<' ; }
1553:
1554: if (@expr1073750592 !@expr1073750593 Token ::@expr8737 Match (@expr1073750595 lhs@var2845 , "[+-]" ) ||@expr1073750596 !@expr1073750597 lhs@var2845 .@expr1073750598 isBinaryOp (@expr1073750599 ) ) {
1555: continue ; }
1556:
1557: const bool isSignedInteger@var2847 =@expr1073750600 lhs@var2845 .@expr8777 valueType (@expr8778 ) &&@expr1073750603 lhs@var2845 .@expr8777 valueType (@expr8778 ) .@expr1073750606 isIntegral (@expr1073750607 ) &&@expr1073750608 lhs@var2845 .@expr8777 valueType (@expr8778 ) .@expr1073750611 sign@var2973 ==@expr1073750612 ValueType ::@expr8789 Sign ::@expr1073750614 SIGNED ;
1558: const bool isPointer@var2848 =@expr1073750615 lhs@var2845 .@expr8777 valueType (@expr8778 ) &&@expr1073750618 lhs@var2845 .@expr8777 valueType (@expr8778 ) .@expr1073750621 pointer@var2974 >@expr1073750622 0 ;
1559: if (@expr1073750623 !@expr1073750624 isSignedInteger@var2847 &&@expr1073750625 !@expr1073750626 isPointer@var2848 ) {
1560: continue ; }
1561:
1562: const Token * exprTokens@var2849 [@expr1073750627 2 ] =@expr1073750628 {@expr1073750629 lhs@var2845 .@expr1073750630 astOperand1 (@expr1073750631 ) , lhs@var2845 .@expr8808 astOperand2 (@expr8809 ) } ;
1563: for (@expr1073750634 const Token *@expr8728 expr@var2850 :@expr1073750636 exprTokens@var2849 ) {
1564: if (@expr1073750637 lhs@var2845 .@expr8814 str (@expr8815 ) ==@expr8816 "-" &&@expr1073750641 expr@var2850 ==@expr1073750642 lhs@var2845 .@expr8808 astOperand2 (@expr8809 ) ) {
1565: continue ; }
1566:
1567: if (@expr1073750645 expr@var2850 .@expr1073750646 hasKnownIntValue (@expr1073750647 ) ) {
1568: continue ; }
1569:
1570: if (@expr1073750648 !@expr1073750649 isSameExpression (@expr1073750650 mTokenizer@var28 .@expr1073750651 isCPP (@expr1073750652 ) ,
1571: true ,
1572: expr@var2850 ,
1573: lhs@var2845 .@expr1073750653 astSibling (@expr1073750654 ) ,
1574: mSettings@var29 .@expr1073750655 library@var2952 ,
1575: true ,
1576: false ) ) {
1577: continue ; }
1578:
1579: const Token * const other@var2851 ; other@var2851 =@expr1073750656 expr@var2850 .@expr1073750657 astSibling (@expr1073750658 ) ;
1580:
1581:
1582: if (@expr1073750659 (@expr1073750660 other@var2851 .@expr8837 isNumber (@expr8838 ) &&@expr1073750663 other@var2851 .@expr1073750664 getKnownIntValue (@expr1073750665 ) >@expr1073750666 0 ) ||@expr1073750667
1583: (@expr1073750668 !@expr1073750669 other@var2851 .@expr8837 isNumber (@expr8838 ) &&@expr1073750672 other@var2851 .@expr8849 valueType (@expr8850 ) &&@expr1073750675 other@var2851 .@expr8849 valueType (@expr8850 ) .@expr1073750678 isIntegral (@expr1073750679 ) &&@expr1073750680 other@var2851 .@expr8849 valueType (@expr8850 ) .@expr1073750683 sign@var2973 ==@expr1073750684 ValueType ::@expr8789 Sign ::@expr1073750686 UNSIGNED ) ) {
1584: bool result@var2852 ;
1585: if (@expr1073750687 lhs@var2845 .@expr8814 str (@expr8815 ) ==@expr8866 "+" ) {
1586: result@var2852 =@expr1073750691 cmp@var2846 ==@expr1073750692 ">" ||@expr1073750693 cmp@var2846 ==@expr1073750694 ">=" ; }
1587: else {
1588: result@var2852 =@expr1073750695 cmp@var2846 ==@expr1073750696 "<" ||@expr1073750697 cmp@var2846 ==@expr1073750698 "<=" ; }
1589: invalidTestForOverflow (@expr1073750699 tok@var2843 , lhs@var2845 .@expr8777 valueType (@expr8778 ) , result@var2852 ?@expr1073750702 "true" :@expr1073750703 "false" ) ;
1590: continue ;
1591: }
1592:
1593:
1594: if (@expr1073750704 lhs@var2845 .@expr8814 str (@expr8815 ) ==@expr8866 "+" &&@expr1073750708 other@var2851 .@expr8885 varId (@expr8886 ) >@expr8887 0 ) {
1595: const std ::@expr8888 string result@var2853 =@expr1073750713 other@var2851 .@expr8890 str (@expr8891 ) +@expr1073750716 cmp@var2846 +@expr1073750717 "0" ;
1596: invalidTestForOverflow (@expr1073750718 tok@var2843 , lhs@var2845 .@expr8777 valueType (@expr8778 ) , result@var2853 ) ;
1597: continue ;
1598: }
1599:
1600:
1601: if (@expr1073750721 lhs@var2845 .@expr8814 str (@expr8815 ) ==@expr8816 "-" &&@expr1073750725 other@var2851 .@expr8885 varId (@expr8886 ) >@expr8887 0 ) {
1602: std ::@expr1073750729 string cmp2@var2854 ; cmp2@var2854 =@expr1073750730 cmp@var2846 ;
1603: cmp2@var2854 [@expr1073750731 0 ] =@expr1073750732 (@expr1073750733 cmp@var2846 [@expr8761 0 ] ==@expr8765 '<' ) ?@expr8766 '>' :@expr8767 '<' ;
1604: const std ::@expr8888 string result@var2855 =@expr1073750739 other@var2851 .@expr8890 str (@expr8891 ) +@expr1073750742 cmp2@var2854 +@expr1073750743 "0" ;
1605: invalidTestForOverflow (@expr1073750744 tok@var2843 , lhs@var2845 .@expr8777 valueType (@expr8778 ) , result@var2855 ) ;
1606: continue ;
1607: }
1608: }
1609: }
1610: }
1611: }
1612:
1613: void CheckCondition :: invalidTestForOverflow ( const Token * tok@var2856 , const ValueType * valueType@var2857 , const std :: string & replace@var2858 )
1614: {
1615: const std ::@expr8923 string expr@var2859 =@expr1073750748 tok@var2856 ?@expr1073750749 tok@var2856 .@expr1073750750 expressionString (@expr1073750751 ) :@expr1073750752 std ::@expr1073750753 string (@expr1073750754 "x + c < x" ) ;
1616: const std ::@expr8923 string overflow@var2860 =@expr1073750756 (@expr1073750757 valueType@var2857 &&@expr1073750758 valueType@var2857 .@expr1073750759 pointer@var2861 ) ?@expr1073750760 "pointer overflow" :@expr1073750761 "signed integer overflow" ;
1617:
1618: std ::@expr1073750762 string errmsg@var2862 ; errmsg@var2862 =@expr1073750763
1619: "Invalid test for overflow '" +@expr1073750764 expr@var2859 +@expr1073750765 "'; " +@expr1073750766 overflow@var2860 +@expr1073750767 " is undefined behavior." ;
1620: if (@expr1073750768 replace@var2858 ==@expr1073750769 "false" ||@expr1073750770 replace@var2858 ==@expr1073750771 "true" ) {
1621: errmsg@var2862 +=@expr1073750772 " Some mainstream compilers remove such overflow tests when optimising the code and assume it's always " +@expr1073750773 replace@var2858 +@expr1073750774 "." ; }
1622: else {
1623: errmsg@var2862 +=@expr1073750775 " Some mainstream compilers removes handling of overflows when optimising the code and change the code to '" +@expr1073750776 replace@var2858 +@expr1073750777 "'." ; }
1624: reportError (@expr1073750778 tok@var2856 , Severity ::@expr1073750779 warning , "invalidTestForOverflow" , errmsg@var2862 , uncheckedErrorConditionCWE@var2473 , Certainty ::@expr1073750780 normal ) ;
1625: }
1626:
1627:
1628: void CheckCondition :: checkPointerAdditionResultNotNull ( )
1629: {
1630: if (@expr1073750781 !@expr1073750782 mSettings@var29 .@expr1073750783 severity@var2951 .@expr1073750784 isEnabled (@expr1073750785 Severity ::@expr1073750786 warning ) ) {
1631: return ; }
1632:
1633: const SymbolDatabase * symbolDatabase@var2863 ; symbolDatabase@var2863 =@expr1073750787 mTokenizer@var28 .@expr1073750788 getSymbolDatabase (@expr1073750789 ) ;
1634: for (@expr1073750790 const Scope *@expr8967 scope@var2864 :@expr1073750792 symbolDatabase@var2863 .@expr1073750793 functionScopes@var2865 ) {
1635:
1636: for (@expr1073750794 const Token *@expr8967 tok@var2866 =@expr1073750796 scope@var2864 .@expr1073750797 bodyStart@var2867 ; tok@var2866 !=@expr1073750798 scope@var2864 .@expr1073750799 bodyEnd@var2868 ; tok@var2866 =@expr1073750800 tok@var2866 .@expr1073750801 next (@expr1073750802 ) ) {
1637: if (@expr1073750803 !@expr1073750804 tok@var2866 .@expr1073750805 isComparisonOp (@expr1073750806 ) ||@expr1073750807 !@expr1073750808 tok@var2866 .@expr8985 astOperand1 (@expr8986 ) ||@expr1073750811 !@expr1073750812 tok@var2866 .@expr8989 astOperand2 (@expr8990 ) ) {
1638: continue ; }
1639:
1640:
1641: if (@expr1073750815 tok@var2866 .@expr1073750816 isExpandedMacro (@expr1073750817 ) ) {
1642: continue ; }
1643:
1644: const Token * calcToken@var2869 ; const Token * exprToken@var2870 ;
1645: if (@expr1073750818 tok@var2866 .@expr8985 astOperand1 (@expr8986 ) .@expr1073750821 str (@expr1073750822 ) ==@expr1073750823 "+" ) {
1646: calcToken@var2869 =@expr1073750824 tok@var2866 .@expr8985 astOperand1 (@expr8986 ) ;
1647: exprToken@var2870 =@expr1073750827 tok@var2866 .@expr8989 astOperand2 (@expr8990 ) ;
1648: } else { if (@expr1073750830 tok@var2866 .@expr8989 astOperand2 (@expr8990 ) .@expr1073750833 str (@expr1073750834 ) ==@expr1073750835 "+" ) {
1649: calcToken@var2869 =@expr1073750836 tok@var2866 .@expr8989 astOperand2 (@expr8990 ) ;
1650: exprToken@var2870 =@expr1073750839 tok@var2866 .@expr8985 astOperand1 (@expr8986 ) ;
1651: } else {
1652: continue ; } }
1653:
1654:
1655: if (@expr1073750842 calcToken@var2869 .@expr1073750843 hasKnownIntValue (@expr1073750844 ) ) {
1656: continue ; }
1657: if (@expr1073750845 !@expr1073750846 calcToken@var2869 .@expr9023 valueType (@expr9024 ) ||@expr1073750849 calcToken@var2869 .@expr9023 valueType (@expr9024 ) .@expr1073750852 pointer@var2974 ==@expr1073750853 0 ) {
1658: continue ; }
1659: if (@expr1073750854 !@expr1073750855 exprToken@var2870 .@expr1073750856 hasKnownIntValue (@expr1073750857 ) ||@expr1073750858 !@expr1073750859 exprToken@var2870 .@expr1073750860 getValue (@expr1073750861 0 ) ) {
1660: continue ; }
1661:
1662: pointerAdditionResultNotNullError (@expr1073750862 tok@var2866 , calcToken@var2869 ) ;
1663: }
1664: }
1665: }
1666:
1667: void CheckCondition :: pointerAdditionResultNotNullError ( const Token * tok@var2871 , const Token * calc@var2872 )
1668: {
1669: const std ::@expr1073750863 string s@var2873 =@expr1073750864 calc@var2872 ?@expr1073750865 calc@var2872 .@expr1073750866 expressionString (@expr1073750867 ) :@expr1073750868 "ptr+1" ;
1670: reportError (@expr1073750869 tok@var2871 , Severity ::@expr1073750870 warning , "pointerAdditionResultNotNull" , "Comparison is wrong. Result of '" +@expr1073750871 s@var2873 +@expr1073750872 "' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour." ) ;
1671: }
1672:
1673: void CheckCondition :: checkDuplicateConditionalAssign ( )
1674: {
1675: if (@expr1073750873 !@expr1073750874 mSettings@var29 .@expr1073750875 severity@var2951 .@expr1073750876 isEnabled (@expr1073750877 Severity ::@expr1073750878 style ) ) {
1676: return ; }
1677:
1678: const SymbolDatabase * symbolDatabase@var2874 ; symbolDatabase@var2874 =@expr1073750879 mTokenizer@var28 .@expr1073750880 getSymbolDatabase (@expr1073750881 ) ;
1679: for (@expr1073750882 const Scope *@expr9059 scope@var2875 :@expr1073750884 symbolDatabase@var2874 .@expr1073750885 functionScopes@var2876 ) {
1680: for (@expr1073750886 const Token *@expr9059 tok@var2877 =@expr1073750888 scope@var2875 .@expr1073750889 bodyStart@var2878 ; tok@var2877 !=@expr1073750890 scope@var2875 .@expr1073750891 bodyEnd@var2879 ; tok@var2877 =@expr1073750892 tok@var2877 .@expr9069 next (@expr9070 ) ) {
1681: if (@expr1073750895 !@expr1073750896 Token ::@expr9073 simpleMatch (@expr1073750898 tok@var2877 , "if (" ) ) {
1682: continue ; }
1683: if (@expr1073750899 !@expr1073750900 Token ::@expr9073 simpleMatch (@expr1073750902 tok@var2877 .@expr9069 next (@expr9070 ) .@expr9081 link (@expr9082 ) , ") {" ) ) {
1684: continue ; }
1685: const Token * blockTok@var2880 ; blockTok@var2880 =@expr1073750907 tok@var2877 .@expr9069 next (@expr9070 ) .@expr9081 link (@expr9082 ) .@expr1073750912 next (@expr1073750913 ) ;
1686: const Token * condTok@var2881 ; condTok@var2881 =@expr1073750914 tok@var2877 .@expr9069 next (@expr9070 ) .@expr1073750917 astOperand2 (@expr1073750918 ) ;
1687: if (@expr1073750919 !@expr1073750920 Token ::@expr1073750921 Match (@expr1073750922 condTok@var2881 , "==|!=" ) ) {
1688: continue ; }
1689: if (@expr1073750923 condTok@var2881 .@expr1073750924 str (@expr1073750925 ) ==@expr1073750926 "!=" &&@expr1073750927 Token ::@expr9073 simpleMatch (@expr1073750929 blockTok@var2880 .@expr9106 link (@expr9107 ) , "} else {" ) ) {
1690: continue ; }
1691: if (@expr1073750932 !@expr1073750933 blockTok@var2880 .@expr9110 next (@expr9111 ) ) {
1692: continue ; }
1693: const Token * assignTok@var2882 ; assignTok@var2882 =@expr1073750936 blockTok@var2880 .@expr9110 next (@expr9111 ) .@expr1073750939 astTop (@expr1073750940 ) ;
1694: if (@expr1073750941 !@expr1073750942 Token ::@expr9073 simpleMatch (@expr1073750944 assignTok@var2882 , "=" ) ) {
1695: continue ; }
1696: if (@expr1073750945 nextAfterAstRightmostLeaf (@expr1073750946 assignTok@var2882 ) !=@expr1073750947 blockTok@var2880 .@expr9106 link (@expr9107 ) .@expr1073750950 previous (@expr1073750951 ) ) {
1697: continue ; }
1698: if (@expr1073750952 !@expr1073750953 isSameExpression (@expr1073750954
1699: mTokenizer@var28 .@expr9131 isCPP (@expr9132 ) , true , condTok@var2881 .@expr1073750957 astOperand1 (@expr1073750958 ) , assignTok@var2882 .@expr1073750959 astOperand1 (@expr1073750960 ) , mSettings@var29 .@expr9137 library@var2952 , true , true ) ) {
1700: continue ; }
1701: if (@expr1073750962 !@expr1073750963 isSameExpression (@expr1073750964
1702: mTokenizer@var28 .@expr9131 isCPP (@expr9132 ) , true , condTok@var2881 .@expr1073750967 astOperand2 (@expr1073750968 ) , assignTok@var2882 .@expr1073750969 astOperand2 (@expr1073750970 ) , mSettings@var29 .@expr9137 library@var2952 , true , true ) ) {
1703: continue ; }
1704: duplicateConditionalAssignError (@expr1073750972 condTok@var2881 , assignTok@var2882 ) ;
1705: }
1706: }
1707: }
1708:
1709: void CheckCondition :: duplicateConditionalAssignError ( const Token * condTok@var2883 , const Token * assignTok@var2884 )
1710: {
1711: std ::@expr1073750973 list < std ::@expr9150 pair < const Token *@expr1073750975 , std ::@expr9150 string > > errors@var2885 ;
1712: std ::@expr1073750977 string msg@var2886 ; msg@var2886 =@expr1073750978 "Duplicate expression for the condition and assignment." ;
1713: if (@expr1073750979 condTok@var2883 &&@expr1073750980 assignTok@var2884 ) {
1714: if (@expr1073750981 condTok@var2883 .@expr1073750982 str (@expr1073750983 ) ==@expr1073750984 "==" ) {
1715: msg@var2886 =@expr1073750985 "Assignment '" +@expr9162 assignTok@var2884 .@expr9163 expressionString (@expr9164 ) +@expr1073750989 "' is redundant with condition '" +@expr1073750990 condTok@var2883 .@expr9167 expressionString (@expr9168 ) +@expr1073750993 "'." ;
1716: errors@var2885 .@expr9170 emplace_back (@expr1073750995 condTok@var2883 , "Condition '" +@expr9172 condTok@var2883 .@expr9167 expressionString (@expr9168 ) +@expr1073750999 "'" ) ;
1717: errors@var2885 .@expr9170 emplace_back (@expr1073751001 assignTok@var2884 , "Assignment '" +@expr9162 assignTok@var2884 .@expr9163 expressionString (@expr9164 ) +@expr1073751005 "' is redundant" ) ;
1718: } else {
1719: msg@var2886 =@expr1073751006 "The statement 'if (" +@expr1073751007 condTok@var2883 .@expr9167 expressionString (@expr9168 ) +@expr1073751010 ") " +@expr1073751011 assignTok@var2884 .@expr9163 expressionString (@expr9164 ) +@expr1073751014 "' is logically equivalent to '" +@expr1073751015 assignTok@var2884 .@expr9163 expressionString (@expr9164 ) +@expr1073751018 "'." ;
1720: errors@var2885 .@expr9170 emplace_back (@expr1073751020 assignTok@var2884 , "Assignment '" +@expr9162 assignTok@var2884 .@expr9163 expressionString (@expr9164 ) +@expr1073751024 "'" ) ;
1721: errors@var2885 .@expr9170 emplace_back (@expr1073751026 condTok@var2883 , "Condition '" +@expr9172 condTok@var2883 .@expr9167 expressionString (@expr9168 ) +@expr1073751030 "' is redundant" ) ;
1722: }
1723: }
1724:
1725: reportError (@expr1073751031
1726: errors@var2885 , Severity ::@expr1073751032 style , "duplicateConditionalAssign" , msg@var2886 , CWE398@var2474 , Certainty ::@expr1073751033 normal ) ;
1727: }
1728:
1729:
1730: void CheckCondition :: checkAssignmentInCondition ( )
1731: {
1732: if (@expr1073751034 !@expr1073751035 mSettings@var29 .@expr1073751036 severity@var2951 .@expr1073751037 isEnabled (@expr1073751038 Severity ::@expr1073751039 style ) ) {
1733: return ; }
1734:
1735: const SymbolDatabase * symbolDatabase@var2887 ; symbolDatabase@var2887 =@expr1073751040 mTokenizer@var28 .@expr1073751041 getSymbolDatabase (@expr1073751042 ) ;
1736: for (@expr1073751043 const Scope *@expr9220 scope@var2888 :@expr1073751045 symbolDatabase@var2887 .@expr1073751046 functionScopes@var2889 ) {
1737: for (@expr1073751047 const Token *@expr9220 tok@var2890 =@expr1073751049 scope@var2888 .@expr1073751050 bodyStart@var2891 ; tok@var2890 !=@expr1073751051 scope@var2888 .@expr1073751052 bodyEnd@var2892 ; tok@var2890 =@expr1073751053 tok@var2890 .@expr1073751054 next (@expr1073751055 ) ) {
1738: if (@expr1073751056 tok@var2890 .@expr1073751057 str (@expr1073751058 ) !=@expr1073751059 "=" ) {
1739: continue ; }
1740: if (@expr1073751060 !@expr1073751061 tok@var2890 .@expr9238 astParent (@expr9239 ) ) {
1741: continue ; }
1742:
1743:
1744: if (@expr1073751064 !@expr1073751065 tok@var2890 .@expr9242 valueType (@expr9243 ) ) {
1745: continue ; }
1746: if (@expr1073751068 tok@var2890 .@expr9242 valueType (@expr9243 ) .@expr1073751071 pointer@var2974 >@expr1073751072 0 ) {
1747: continue ; }
1748: if (@expr1073751073 tok@var2890 .@expr9242 valueType (@expr9243 ) .@expr9252 type@var2970 !=@expr1073751077 ValueType ::@expr9254 Type ::@expr1073751079 CONTAINER &&@expr1073751080 tok@var2890 .@expr9242 valueType (@expr9243 ) .@expr9252 type@var2970 !=@expr1073751084 ValueType ::@expr9254 Type ::@expr1073751086 ITERATOR ) {
1749: continue ; }
1750:
1751:
1752: if (@expr1073751087 Token ::@expr9264 Match (@expr1073751089 tok@var2890 .@expr9238 astParent (@expr9239 ) .@expr1073751092 previous (@expr1073751093 ) , "if|while (" ) ) {
1753: assignmentInCondition (@expr9270 tok@var2890 ) ; }
1754: else { if (@expr1073751095 Token ::@expr9264 Match (@expr1073751097 tok@var2890 .@expr9238 astParent (@expr9239 ) , "%oror%|&&" ) ) {
1755: assignmentInCondition (@expr9270 tok@var2890 ) ; }
1756: else { if (@expr1073751101 Token ::@expr1073751102 simpleMatch (@expr1073751103 tok@var2890 .@expr9238 astParent (@expr9239 ) , "?" ) &&@expr1073751106 tok@var2890 ==@expr1073751107 tok@var2890 .@expr9238 astParent (@expr9239 ) .@expr1073751110 astOperand1 (@expr1073751111 ) ) {
1757: assignmentInCondition (@expr9270 tok@var2890 ) ; } } }
1758: }
1759: }
1760: }
1761:
1762: void CheckCondition :: assignmentInCondition ( const Token * eq@var2893 )
1763: {
1764: std ::@expr1073751113 string expr@var2894 ; expr@var2894 =@expr1073751114 eq@var2893 ?@expr1073751115 eq@var2893 .@expr1073751116 expressionString (@expr1073751117 ) :@expr1073751118 "x=y" ;
1765:
1766: reportError (@expr1073751119
1767: eq@var2893 ,
1768: Severity ::@expr1073751120 style ,
1769: "assignmentInCondition" ,
1770: "Suspicious assignment in condition. Condition '" +@expr1073751121 expr@var2894 +@expr1073751122 "' is always true." ,
1771: CWE571@var2476 ,
1772: Certainty ::@expr1073751123 normal ) ;
1773: }
1774:
1775: void CheckCondition :: checkCompareValueOutOfTypeRange ( )
1776: {
1777: if (@expr1073751124 !@expr1073751125 mSettings@var29 .@expr1073751126 severity@var2951 .@expr1073751127 isEnabled (@expr1073751128 Severity ::@expr1073751129 style ) ) {
1778: return ; }
1779:
1780: if (@expr1073751130 mSettings@var29 .@expr9307 platformType@var2954 ==@expr1073751132 cppcheck ::@expr9309 Platform ::@expr9310 PlatformType ::@expr1073751135 Native ||@expr1073751136
1781: mSettings@var29 .@expr9307 platformType@var2954 ==@expr1073751138 cppcheck ::@expr9309 Platform ::@expr9310 PlatformType ::@expr1073751141 Unspecified ) {
1782: return ; }
1783:
1784: const SymbolDatabase * symbolDatabase@var2895 ; symbolDatabase@var2895 =@expr1073751142 mTokenizer@var28 .@expr1073751143 getSymbolDatabase (@expr1073751144 ) ;
1785: for (@expr1073751145 const Scope *@expr9322 scope@var2896 :@expr1073751147 symbolDatabase@var2895 .@expr1073751148 functionScopes@var2897 ) {
1786: for (@expr1073751149 const Token *@expr9322 tok@var2898 =@expr1073751151 scope@var2896 .@expr1073751152 bodyStart@var2899 ; tok@var2898 !=@expr1073751153 scope@var2896 .@expr1073751154 bodyEnd@var2900 ; tok@var2898 =@expr1073751155 tok@var2898 .@expr1073751156 next (@expr1073751157 ) ) {
1787: if (@expr1073751158 !@expr1073751159 tok@var2898 .@expr1073751160 isComparisonOp (@expr1073751161 ) ||@expr1073751162 !@expr1073751163 tok@var2898 .@expr1073751164 isBinaryOp (@expr1073751165 ) ) {
1788: continue ; }
1789:
1790: for (@expr1073751166 int i@var2901 =@expr1073751167 0 ; i@var2901 <@expr1073751168 2 ; ++@expr1073751169 i@var2901 ) {
1791: const Token * const valueTok@var2902 ; valueTok@var2902 =@expr1073751170 (@expr1073751171 i@var2901 ==@expr9348 0 ) ?@expr1073751173 tok@var2898 .@expr1073751174 astOperand1 (@expr1073751175 ) :@expr1073751176 tok@var2898 .@expr1073751177 astOperand2 (@expr1073751178 ) ;
1792: const Token * const typeTok@var2903 ; typeTok@var2903 =@expr1073751179 valueTok@var2902 .@expr1073751180 astSibling (@expr1073751181 ) ;
1793: if (@expr1073751182 !@expr1073751183 valueTok@var2902 .@expr1073751184 hasKnownIntValue (@expr1073751185 ) ||@expr1073751186 !@expr1073751187 typeTok@var2903 .@expr9364 valueType (@expr9365 ) ||@expr1073751190 typeTok@var2903 .@expr9364 valueType (@expr9365 ) .@expr1073751193 pointer@var2974 ) {
1794: continue ; }
1795: if (@expr1073751194 valueTok@var2902 .@expr9371 getKnownIntValue (@expr9372 ) <@expr1073751197 0 &&@expr1073751198 valueTok@var2902 .@expr9375 valueType (@expr9376 ) &&@expr1073751201 valueTok@var2902 .@expr9375 valueType (@expr9376 ) .@expr9380 sign@var2973 !=@expr9381 ValueType ::@expr9382 Sign ::@expr9383 SIGNED ) {
1796: continue ; }
1797: int bits@var2904 ; bits@var2904 =@expr1073751208 0 ;
1798: switch (@expr1073751209 typeTok@var2903 .@expr9364 valueType (@expr9365 ) .@expr1073751212 type@var2970 ) {
1799: case ValueType ::@expr9389 Type ::@expr1073751214 BOOL :@expr9391 ;
1800: bits@var2904 =@expr1073751216 1 ;
1801: break ;
1802: case ValueType ::@expr9389 Type ::@expr1073751218 CHAR :@expr9391 ;
1803: bits@var2904 =@expr1073751220 mSettings@var29 .@expr1073751221 char_bit@var2955 ;
1804: break ;
1805: case ValueType ::@expr9389 Type ::@expr1073751223 SHORT :@expr9391 ;
1806: bits@var2904 =@expr1073751225 mSettings@var29 .@expr1073751226 short_bit@var2956 ;
1807: break ;
1808: case ValueType ::@expr9389 Type ::@expr1073751228 INT :@expr9391 ;
1809: bits@var2904 =@expr1073751230 mSettings@var29 .@expr9407 int_bit@var2957 ;
1810: break ;
1811: case ValueType ::@expr9389 Type ::@expr1073751233 LONG :@expr9391 ;
1812: bits@var2904 =@expr1073751235 mSettings@var29 .@expr1073751236 long_bit@var2958 ;
1813: break ;
1814: case ValueType ::@expr9389 Type ::@expr1073751238 LONGLONG :@expr9391 ;
1815: bits@var2904 =@expr1073751240 mSettings@var29 .@expr1073751241 long_long_bit@var2959 ;
1816: break ;
1817: default :@expr9391 ;
1818: break ;
1819: }
1820: if (@expr1073751243 bits@var2904 ==@expr1073751244 0 ||@expr1073751245 bits@var2904 >=@expr1073751246 64 ) {
1821: continue ; }
1822:
1823: const auto typeMinValue@var2905 =@expr1073751247 (@expr1073751248 typeTok@var2903 .@expr9364 valueType (@expr9365 ) .@expr9427 sign@var2973 ==@expr1073751252 ValueType ::@expr9382 Sign ::@expr1073751254 UNSIGNED ) ?@expr1073751255 0 :@expr1073751256 (@expr1073751257 -@expr1073751258 (@expr1073751259 1LL <<@expr1073751260 (@expr1073751261 bits@var2904 -@expr1073751262 1 ) ) ) ;
1824: const auto unsignedTypeMaxValue@var2906 =@expr1073751263 (@expr1073751264 1LL <<@expr1073751265 bits@var2904 ) -@expr1073751266 1LL ;
1825: long long typeMaxValue@var2907 ;
1826: if (@expr1073751267 typeTok@var2903 .@expr9364 valueType (@expr9365 ) .@expr9427 sign@var2973 !=@expr1073751271 ValueType ::@expr9382 Sign ::@expr9383 SIGNED ) {
1827: typeMaxValue@var2907 =@expr1073751274 unsignedTypeMaxValue@var2906 ; }
1828: else { if (@expr1073751275 bits@var2904 >=@expr1073751276 mSettings@var29 .@expr9407 int_bit@var2957 &&@expr1073751278 (@expr1073751279 !@expr1073751280 valueTok@var2902 .@expr9375 valueType (@expr9376 ) ||@expr1073751283 valueTok@var2902 .@expr9375 valueType (@expr9376 ) .@expr9380 sign@var2973 !=@expr9381 ValueType ::@expr9382 Sign ::@expr9383 SIGNED ) ) {
1829: typeMaxValue@var2907 =@expr1073751290 unsignedTypeMaxValue@var2906 ; }
1830: else {
1831: typeMaxValue@var2907 =@expr1073751291 unsignedTypeMaxValue@var2906 /@expr1073751292 2 ; } }
1832:
1833: bool result@var2908 {@expr1073751293 } ;
1834: const auto kiv@var2909 =@expr1073751294 valueTok@var2902 .@expr9371 getKnownIntValue (@expr9372 ) ;
1835: if (@expr1073751297 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr1073751300 "==" ) {
1836: result@var2908 =@expr1073751301 false ; }
1837: else { if (@expr1073751302 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr1073751305 "!=" ) {
1838: result@var2908 =@expr1073751306 true ; }
1839: else { if (@expr1073751307 tok@var2898 .@expr9474 str (@expr9475 ) [@expr9486 0 ] ==@expr9487 '>' &&@expr1073751312 i@var2901 ==@expr9348 0 ) {
1840:
1841: result@var2908 =@expr1073751314 kiv@var2909 >@expr9491 0 ; }
1842: else { if (@expr1073751316 tok@var2898 .@expr9474 str (@expr9475 ) [@expr9486 0 ] ==@expr9487 '>' &&@expr1073751321 i@var2901 ==@expr9498 1 ) {
1843:
1844: result@var2908 =@expr1073751323 kiv@var2909 <@expr9500 0 ; }
1845: else { if (@expr1073751325 tok@var2898 .@expr9474 str (@expr9475 ) [@expr9486 0 ] ==@expr9505 '<' &&@expr1073751330 i@var2901 ==@expr9348 0 ) {
1846:
1847: result@var2908 =@expr1073751332 kiv@var2909 <@expr9500 0 ; }
1848: else { if (@expr1073751334 tok@var2898 .@expr9474 str (@expr9475 ) [@expr9486 0 ] ==@expr9505 '<' &&@expr1073751339 i@var2901 ==@expr9498 1 ) {
1849:
1850: result@var2908 =@expr1073751341 kiv@var2909 >@expr9491 0 ; } } } } } }
1851:
1852: bool error@var2910 ; error@var2910 =@expr1073751343 false ;
1853: if (@expr1073751344 kiv@var2909 <@expr1073751345 typeMinValue@var2905 ||@expr1073751346 kiv@var2909 >@expr1073751347 typeMaxValue@var2907 ) {
1854: error@var2910 =@expr1073751348 true ;
1855: } else {
1856: switch (@expr1073751349 i@var2901 ) {
1857: case 0 :@expr9391 ;
1858: if (@expr9527 kiv@var2909 ==@expr9528 typeMinValue@var2905 ) {
1859: if (@expr1073751353 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9532 "<=" ) {
1860: result@var2908 =@expr1073751357 true ;
1861: error@var2910 =@expr1073751358 true ;
1862: } else { if (@expr1073751359 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9538 ">" ) {
1863: error@var2910 =@expr1073751363 true ; } }
1864: }
1865: else { if (@expr1073751364 kiv@var2909 ==@expr9541 typeMaxValue@var2907 &&@expr1073751366 (@expr1073751367 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9546 ">=" ||@expr1073751371 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9550 "<" ) ) {
1866: error@var2910 =@expr1073751375 true ;
1867: } }
1868: break ;
1869: case 1 :@expr9391 ;
1870: if (@expr9527 kiv@var2909 ==@expr9528 typeMinValue@var2905 ) {
1871: if (@expr1073751379 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9546 ">=" ) {
1872: result@var2908 =@expr1073751383 true ;
1873: error@var2910 =@expr1073751384 true ;
1874: } else { if (@expr1073751385 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9550 "<" ) {
1875: error@var2910 =@expr1073751389 true ; } }
1876: }
1877: else { if (@expr1073751390 kiv@var2909 ==@expr9541 typeMaxValue@var2907 &&@expr1073751392 (@expr1073751393 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9532 "<=" ||@expr1073751397 tok@var2898 .@expr9474 str (@expr9475 ) ==@expr9538 ">" ) ) {
1878: error@var2910 =@expr1073751401 true ;
1879: } }
1880: break ;
1881: }
1882: }
1883: if (@expr1073751402 error@var2910 ) {
1884: compareValueOutOfTypeRangeError (@expr1073751403 valueTok@var2902 , typeTok@var2903 .@expr9364 valueType (@expr9365 ) .@expr1073751406 str (@expr1073751407 ) , kiv@var2909 , result@var2908 ) ; }
1885: }
1886: }
1887: }
1888: }
1889:
1890: void CheckCondition :: compareValueOutOfTypeRangeError ( const Token * comparison@var2911 , const std :: string & type@var2912 , long long value@var2913 , bool result@var2914 )
1891: {
1892: reportError (@expr1073751408
1893: comparison@var2911 ,
1894: Severity ::@expr1073751409 style ,
1895: "compareValueOutOfTypeRangeError" ,
1896: "Comparing expression of type '" +@expr1073751410 type@var2912 +@expr1073751411 "' against value " +@expr1073751412 std ::@expr1073751413 to_string (@expr1073751414 value@var2913 ) +@expr1073751415 ". Condition is always " +@expr1073751416 (@expr1073751417 result@var2914 ?@expr1073751418 "true" :@expr1073751419 "false" ) +@expr1073751420 "." ,
1897: CWE398@var2474 ,
1898: Certainty ::@expr1073751421 normal ) ;
1899: }
919: double getvalue<double> ( const int test@var2915 , const double value1@var2916 , const double value2@var2917 )
920: {
921:
|
926:
927: switch (@expr1073751422 test@var2915 ) {
928: case 1 :@expr9599 ;
929: return std ::@expr1073751424 numeric_limits < double > ::@expr1073751425 lowest (@expr1073751426 ) ;
930: case 2 :@expr9599 ;
931: return value1@var2916 ;
932: case 3 :@expr9599 ;
933: return getvalue3<double> (@expr1073751429 value1@var2916 , value2@var2917 ) ;
934: case 4 :@expr9599 ;
935: return value2@var2917 ;
936: case 5 :@expr9599 ;
937: return std ::@expr1073751432 numeric_limits < double > ::@expr1073751433 max (@expr1073751434 ) ;
938: }
939: return 0 ;
940: }
919: unsigned long long getvalue<unsignedlonglong> ( const int test@var2918 , const unsigned long long value1@var2919 , const unsigned long long value2@var2920 )
920: {
921:
|
926:
927: switch (@expr1073751435 test@var2918 ) {
928: case 1 :@expr9612 ;
929: return std ::@expr1073751437 numeric_limits < unsigned long long > ::@expr1073751438 lowest (@expr1073751439 ) ;
930: case 2 :@expr9612 ;
931: return value1@var2919 ;
932: case 3 :@expr9612 ;
933: return getvalue3<unsignedlonglong> (@expr1073751442 value1@var2919 , value2@var2920 ) ;
934: case 4 :@expr9612 ;
935: return value2@var2920 ;
936: case 5 :@expr9612 ;
937: return std ::@expr1073751445 numeric_limits < unsigned long long > ::@expr1073751446 max (@expr1073751447 ) ;
938: }
939: return 0 ;
940: }
919: long long getvalue<longlong> ( const int test@var2921 , const long long value1@var2922 , const long long value2@var2923 )
920: {
921:
|
926:
927: switch (@expr1073751448 test@var2921 ) {
928: case 1 :@expr9625 ;
929: return std ::@expr1073751450 numeric_limits < long long > ::@expr1073751451 lowest (@expr1073751452 ) ;
930: case 2 :@expr9625 ;
931: return value1@var2922 ;
932: case 3 :@expr9625 ;
933: return getvalue3<longlong> (@expr1073751455 value1@var2922 , value2@var2923 ) ;
934: case 4 :@expr9625 ;
935: return value2@var2923 ;
936: case 5 :@expr9625 ;
937: return std ::@expr1073751458 numeric_limits < long long > ::@expr1073751459 max (@expr1073751460 ) ;
938: }
939: return 0 ;
940: }
902: unsigned long long getvalue3<unsignedlonglong> ( const unsigned long long value1@var2924 , const unsigned long long value2@var2925 )
903: {
904: const unsigned long long min@var2926 =@expr1073751461 std ::@expr1073751462 min (@expr1073751463 value1@var2924 , value2@var2925 ) ;
905: if (@expr1073751464 min@var2926 ==@expr1073751465 std ::@expr1073751466 numeric_limits < unsigned long long > ::@expr1073751467 max (@expr1073751468 ) ) {
906: return min@var2926 ; }
907: else {
908: return min@var2926 +@expr1073751469 1 ; }
909: }
902: long long getvalue3<longlong> ( const long long value1@var2927 , const long long value2@var2928 )
903: {
904: const long long min@var2929 =@expr1073751470 std ::@expr1073751471 min (@expr1073751472 value1@var2927 , value2@var2928 ) ;
905: if (@expr1073751473 min@var2929 ==@expr1073751474 std ::@expr1073751475 numeric_limits < long long > ::@expr1073751476 max (@expr1073751477 ) ) {
906: return min@var2929 ; }
907: else {
908: return min@var2929 +@expr1073751478 1 ; }
909: }

##file cppcheck-2.8/lib/settings.h

16:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2930 ; mFlags@var2930 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2930 ;
54: }
55: void clear ( ) {
56: mFlags@var2930 =@expr1073751479 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2930 =@expr1073751480 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2931 ) {
62: if (@expr1073751481 enabled@var2931 ) {
63: fill (@expr1073751482 ) ; }
64: else {
65: clear (@expr1073751483 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2932 ) const {
68: return (@expr9660 mFlags@var2930 &@expr1073751485 (@expr9660 1U <<@expr1073751487 (@expr1073751488 uint32_t ) flag@var2932 ) ) !=@expr1073751489 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2933 ) {
71: mFlags@var2930 |=@expr1073751490 (@expr1073751491 1U <<@expr1073751492 (@expr1073751493 uint32_t ) flag@var2933 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2934 ) {
74: mFlags@var2930 &=@expr1073751494 ~@expr1073751495 (@expr1073751496 1U <<@expr1073751497 (@expr1073751498 uint32_t ) flag@var2934 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2935 , bool enabled@var2936 ) {
77: if (@expr1073751499 enabled@var2936 ) {
78: enable (@expr1073751500 flag@var2935 ) ; }
79: else {
80: disable (@expr1073751501 flag@var2935 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2937 ; mFlags@var2937 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2937 ;
54: }
55: void clear ( ) {
56: mFlags@var2937 =@expr1073751502 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2937 =@expr1073751503 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2938 ) {
62: if (@expr1073751504 enabled@var2938 ) {
63: fill (@expr1073751505 ) ; }
64: else {
65: clear (@expr1073751506 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2939 ) const {
68: return (@expr9683 mFlags@var2937 &@expr1073751508 (@expr9683 1U <<@expr1073751510 (@expr1073751511 uint32_t ) flag@var2939 ) ) !=@expr1073751512 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2940 ) {
71: mFlags@var2937 |=@expr1073751513 (@expr1073751514 1U <<@expr1073751515 (@expr1073751516 uint32_t ) flag@var2940 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2941 ) {
74: mFlags@var2937 &=@expr1073751517 ~@expr1073751518 (@expr1073751519 1U <<@expr1073751520 (@expr1073751521 uint32_t ) flag@var2941 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2942 , bool enabled@var2943 ) {
77: if (@expr1073751522 enabled@var2943 ) {
78: enable (@expr1073751523 flag@var2942 ) ; }
79: else {
80: disable (@expr1073751524 flag@var2942 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2944 ; mFlags@var2944 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2944 ;
54: }
55: void clear ( ) {
56: mFlags@var2944 =@expr1073751525 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2944 =@expr1073751526 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2945 ) {
62: if (@expr1073751527 enabled@var2945 ) {
63: fill (@expr1073751528 ) ; }
64: else {
65: clear (@expr1073751529 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2946 ) const {
68: return (@expr9706 mFlags@var2944 &@expr1073751531 (@expr9706 1U <<@expr1073751533 (@expr1073751534 uint32_t ) flag@var2946 ) ) !=@expr1073751535 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2947 ) {
71: mFlags@var2944 |=@expr1073751536 (@expr1073751537 1U <<@expr1073751538 (@expr1073751539 uint32_t ) flag@var2947 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2948 ) {
74: mFlags@var2944 &=@expr1073751540 ~@expr1073751541 (@expr1073751542 1U <<@expr1073751543 (@expr1073751544 uint32_t ) flag@var2948 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2949 , bool enabled@var2950 ) {
77: if (@expr1073751545 enabled@var2950 ) {
78: enable (@expr1073751546 flag@var2949 ) ; }
79: else {
80: disable (@expr1073751547 flag@var2949 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  severity possible 2@101
  id possible "pointerAdditionResultNotNull"@101
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  severity possible {3@16,2@120}
  id possible {"compareValueOutOfTypeRangeError"@16,"assignmentInCondition"@52,"invalidTestForOverflow"@120,"clarifyCondition"@230,"moduloAlwaysTrueFalse"@19,"multiCondition"@45,"comparisonError"@102,"badBitmaskCheck"@134}
  msg possible "Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'?"@134
  certainty possible 0@16
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 53
  ( always "Condition"
Line 57
  ( always "Condition"
Line 82
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
  , always 1
  = always 1
  true always 1
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 176
  nullptr always 0
Line 180
  nullptr always 0
  nullptr always 0
  false always 0
Line 181
  nullptr always 0
Line 182
  nullptr always 0
  "&" always "&"
  6 always 6
  "==" always "=="
  1 always 1
  false always 0
Line 183
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 184
  nullptr always 0
  1 always 1
Line 185
  nullptr always 0
  0xf0 always 240
  nullptr always 0
  1 always 1
Line 186
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 187
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 188
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 189
  nullptr always 0
  "foo > 3 && foo < 4" always "foo > 3 && foo < 4"
  true always 1
  false always 0
  errorPath always size=0
Line 190
  nullptr always 0
  "If x > 11 the condition x > 10 is always true." always "If x > 11 the condition x > 10 is always true."
  false always 0
Line 191
  nullptr always 0
  "1" always "1"
Line 192
  nullptr always 0
  true always 1
  false always 0
Line 193
  nullptr always 0
  nullptr always 0
Line 194
  nullptr always 0
  nullptr always 0
  "false" always "false"
Line 195
  nullptr always 0
  nullptr always 0
Line 196
  nullptr always 0
  nullptr always 0
Line 197
  nullptr always 0
Line 198
  nullptr always 0
  "unsigned char" always "unsigned char"
  256 always 256
  true always 1
Line 202
  "Condition" always "Condition"
Line 206
  "Match conditions with assignments and other conditions:\n- Mismatching assignment and comparison => comparison is always true/false\n- Mismatching lhs and rhs in comparison => comparison is always true/false\n- Detect usage of | where & should be used\n- Duplicate condition and assignment\n- Detect matching 'if' and 'else if' conditions\n- Mismatching bitand (a &= 0xf0; a &= 1; => a = 0)\n- Opposite inner condition is always false\n- Identical condition after early exit is always false\n- Condition that is always true/false\n- Mutual exclusion over || always evaluating to true\n- Comparisons of modulo results that are always true/false.\n- Known variable values => condition is always true/false\n- Invalid test for overflow. Some mainstream compilers remove such overflow tests when optimising code.\n- Suspicious assignment of container/iterator in condition => condition is always true.\n" always "Match conditions with assignments and other conditions:\n- Mismatching assignment and comparison => comparison is always true/false\n- Mismatching lhs and rhs in comparison => comparison is always true/false\n- Detect usage of | where & should be used\n- Duplicate condition and assignment\n- Detect matching 'if' and 'else if' conditions\n- Mismatching bitand (a &= 0xf0; a &= 1; => a = 0)\n- Opposite inner condition is always false\n- Identical condition after early exit is always false\n- Condition that is always true/false\n- Mutual exclusion over || always evaluating to true\n- Comparisons of modulo results that are always true/false.\n- Known variable values => condition is always true/false\n- Invalid test for overflow. Some mainstream compilers remove such overflow tests when optimising code.\n- Suspicious assignment of container/iterator in condition => condition is always true.\n"
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@36373,34@36629}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@142,34@143}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@142,""@143,""@144,"U"@145,"U"@146,"u"@147,"u"@148,"u8"@149,"u8"@150}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@18,34@19}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@15,34@17}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@232,128@233,64@234,32@235,16@236,8@237,4@238,2@239,1@240}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@241,128@242,64@243,32@244,16@245,8@246,4@247,2@248,1@249}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@241,4294967167@242,4294967231@243,4294967263@244,4294967279@245,4294967287@246,4294967291@247,4294967293@248,4294967294@249}
  flag {!<=-1,256@241,128@242,64@243,32@244,16@245,8@246,4@247,2@248,1@249}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {2@215,3@222}
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(blockTok->next()->astTop())@91
  pattern possible {"?"@67,"if ("@76,") {"@77,"} else {"@86,"="@91,"<"@167,"return"@180,"for ("@186,"?"@206,"return"@208}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@131,4@132,0@133}
  t possible {10@131,4@132,0@133}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@131,4@132,0@133}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@131,0@133}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@131,0@133}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@131}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@131}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@131}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@131}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@131}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"&"@249,"*"@11}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@139}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  startTok possible symbolic=(tok->str()=="if"?tok->next():tok)@228
  pattern {";"@228,";"@244}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@141,17179869184@152,8589934592@154,34359738368@156,4294967296@158,2147483648@160,1073741824@162,536870912@164,268435456@166}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@228,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@229}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@140,17179869184@151,8589934592@153,34359738368@155,4294967296@157,2147483648@159,1073741824@161,536870912@163,268435456@165}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@140,17179869184@151,8589934592@153,34359738368@155,4294967296@157,2147483648@159,1073741824@161,536870912@163,268435456@165}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@74,4096@77,16384@80,2048@81,1024@82,65536@83,512@84,256@85,128@86}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@39,4194304@41,8388608@42,2097152@44,1048576@45,524288@46,262144@47,131072@48,65536@49}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@17,4292870143@18,4293918719@19,4294443007@20,4294705151@21,4294836223@22,4294901759@23,4294934527@24,4294950911@25}
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
  ast possible {symbolic=(cond1)@203,symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())@242}
Line 57
  = {!0,symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())@242}
  ast {!0,symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())@242}
Line 59
  visitor possible {lifetime[Lambda]=(isExpandedMacro)@217,lifetime[Lambda]=(hasSizeof)@221,lifetime[Lambda]=(varsInCond)@217,lifetime[Lambda]=(cond2)@234,lifetime[Lambda]=(vars)@234,lifetime[Lambda]=(cond1)@242,lifetime[Lambda]=(errorPath)@242}
  tok inconclusive {symbolic=(ast),symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())@242}
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 52
  ( always "Other"
Line 56
  ( always "Other"
Line 107
  ( always {!<=-1,!>=2}
Line 110
  ( always {!<=-1,!>=2}
Line 127
  ( always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
Line 179
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 235
  , always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 241
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  toIsInt always {!<=-1,!>=2}
Line 242
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 244
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 251
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 252
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 261
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 263
  , always 0
  hasMultipleExpr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 266
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 267
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 275
  , always {!<=-1,!>=2}
  boolean always {!<=-1,!>=2}
Line 278
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  addressOfDeref always {!<=-1,!>=2}
Line 280
  , always {!<=-1,!>=2}
  inSwitch always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  hasIfdef always {!<=-1,!>=2}
Line 282
  ( always {!<=-1,!>=2}
Line 283
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 287
  , always {!<=-1,!>=2}
  isVariableExpressionHidden always {!<=-1,!>=2}
Line 292
  nullptr always 0
Line 297
  nullptr always 0
  nullptr always 0
Line 298
  nullptr always 0
  "varname" always "varname"
Line 299
  nullptr always 0
  "float *" always "float *"
  "double *" always "double *"
  false always 0
  false always 0
Line 300
  nullptr always 0
  1 always 1
Line 301
  nullptr always 0
  2 always 2
Line 302
  nullptr always 0
  "varname" always "varname"
  "dimension" always "dimension"
Line 303
  nullptr always 0
Line 304
  nullptr always 0
  "malloc" always "malloc"
  false always 0
Line 305
  nullptr always 0
Line 306
  nullptr always 0
Line 309
  nullptr always 0
  "varname" always "varname"
Line 310
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 313
  nullptr always 0
  "isless" always "isless"
  "varName" always "varName"
  false always 0
Line 314
  nullptr always 0
  "func_name" always "func_name"
Line 315
  nullptr always 0
Line 316
  nullptr always 0
  "parametername" always "parametername"
  false always 0
Line 317
  nullptr always 0
  nullptr always 0
Line 318
  nullptr always 0
  "type" always "type"
  false always 0
Line 319
  nullptr always 0
Line 320
  nullptr always 0
Line 321
  nullptr always 0
Line 322
  nullptr always 0
  "varname" always "varname"
Line 323
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 324
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 325
  nullptr always 0
  "||" always "||"
Line 326
  nullptr always 0
  "varname" always "varname"
Line 327
  nullptr always 0
  "+" always "+"
Line 328
  nullptr always 0
Line 329
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 330
  nullptr always 0
  nullptr always 0
  true always 1
Line 331
  nullptr always 0
  errorPath always size=0
Line 332
  nullptr always 0
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 333
  nullptr always 0
Line 334
  nullptr always 0
  errorPath always size=0
Line 335
  nullptr always 0
  false always 0
Line 336
  nullptr always 0
  false always 0
Line 337
  nullptr always 0
  nullptr always 0
  "varname" always "varname"
Line 338
  nullptr always 0
  nullptr always 0
  "varname" always "varname"
Line 339
  nullptr always 0
  nullptr always 0
Line 340
  nullptr always 0
  nullptr always 0
Line 341
  nullptr always 0
Line 342
  nullptr always 0
  "buffer" always "buffer"
  "memset" always "memset"
  false always 0
Line 343
  nullptr always 0
Line 344
  nullptr always 0
Line 345
  nullptr always 0
Line 346
  nullptr always 0
  "varname" always "varname"
  false always 0
  true always 1
Line 347
  nullptr always 0
  false always 0
  false always 0
Line 348
  nullptr always 0
  false always 0
  true always 1
Line 349
  nullptr always 0
  true always 1
  false always 0
Line 350
  nullptr always 0
  true always 1
  true always 1
Line 351
  nullptr always 0
Line 352
  nullptr always 0
  "v" always "v"
  nullptr always 0
  false always 0
Line 353
  "function" always "function"
  1 always 1
  nullptr always 0
  nullptr always 0
Line 354
  nullptr always 0
  "varname" always "varname"
Line 355
  nullptr always 0
  nullptr always 0
  "variable" always "variable"
Line 356
  nullptr always 0
  nullptr always 0
  "function" always "function"
Line 357
  nullptr always 0
  nullptr always 0
  "argument" always "argument"
Line 358
  nullptr always 0
  nullptr always 0
  nullptr always 0
  "x" always "x"
  false always 0
Line 359
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 360
  nullptr always 0
  nullptr always 0
  "var" always "var"
  false always 0
Line 361
  nullptr always 0
  nullptr always 0
  "var" always "var"
  false always 0
Line 364
  "function" always "function"
  nullptr always 0
  nullptr always 0
  nullvec always size=0
  nullvec always size=0
Line 365
  nullptr always 0
Line 369
  "Other" always "Other"
Line 373
  "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n" always "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n"
Line 46
  391U always 391
Line 47
  398U always 398
Line 48
  570U always 570
Line 49
  571U always 571
Line 58
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  insert always {!<=-1,!>=2}
Line 60
  ! {!<=-1,!>=2,1@173}
  tok possible 0@173
Line 61
  return always {!<=-1,!>=2}
  false always 0
Line 62
  tok always !0
Line 63
  hasParent always {!<=-1,!>=2}
  hasParent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 64
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  "&&|%oror%" always "&&|%oror%"
Line 65
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 66
  hasParent always {!<=-1,!>=2}
  = always 1
  true always 1
Line 71
  ( always !<=-1
  tok always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  hasParent {!<=-1,!>=2,1}
Line 72
  insert always {!<=-1,!>=2}
Line 73
  mCondDiags possible lifetime[Object]=(tok)
  tok always !0
Line 74
  return always {!<=-1,!>=2}
  false always 0
Line 76
  return always {!<=-1,!>=2}
  true always 1
Line 79
  ( always {!<=-1,!>=2}
Line 82
  ( always {!<=-1,!>=2}
  "= & %var% ;" always "= & %var% ;"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(vars)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 83
  return always {!<=-1,!>=2}
  true always 1
Line 85
  return always {!<=-1,!>=2}
  false always 0
Line 90
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 94
  != always {!<=-1,!>=2}
  "=" always "="
Line 97
  ( always {!<=-1,!>=2}
  -2 always -2
  "[;{}] %var% =" always "[;{}] %var% ="
Line 99
  var always symbolic=(tok->previous()->variable())
  == always {!<=-1,!>=2}
  nullptr always 0
Line 102
  = always 0
  '\0' always 0
Line 103
  = always 0
  0 always 0
Line 105
  ( always {!<=-1,!>=2}
  "%num% [&|]" always "%num% [&|]"
Line 106
  2 always 2
  0 always 0
Line 109
  ";" always ";"
Line 112
  endToken always symbolic=(Token::findsimplematch(tok,";"))
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endToken {symbolic=(Token::findsimplematch(tok,";")),!0}
  -4 always -4
  "* ) & %any% ;" always "* ) & %any% ;"
Line 113
  = always 0
  nullptr always 0
Line 115
  endToken possible {symbolic=(Token::findsimplematch(tok,";")),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endToken always !0
  -2 always -2
  "[&|] %num% ;" always "[&|] %num% ;"
Line 116
  endToken always !0
  -2 always -2
  0 always 0
Line 117
  endToken always !0
Line 121
  bitop possible 124
  == {!<=-1,!>=2,0}
  '\0' always 0
Line 124
  < always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  bitop always !0
  == always {!<=-1,!>=2}
  '|' always 124
Line 127
  ( always {!<=-1,!>=2}
  4 always 4
  ( always {!<=-1,!>=2}
  bitop always !0
  num possible >=0
Line 132
  ( always {!<=-1,!>=2}
Line 134
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,] &" always "[(,] &"
Line 135
  = always 0
  0 always 0
Line 137
  ftok possible 0
  && always {!<=-1,!>=2}
  ftok always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 138
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 140
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 141
  addressOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 142
  == always {!<=-1,!>=2}
  "," always ","
Line 145
  = possible 0
  ftok possible 0
  ? possible 0
  ftok always !0
  : always 0
  nullptr always 0
Line 146
  ! always {!<=-1,!>=2}
  ftok possible 0
  && always {!<=-1,!>=2}
  ftok always !0
Line 147
  return always {!<=-1,!>=2}
  true always 1
Line 148
  ftok always !0
  ( always !0
Line 149
  ! always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  true always 1
Line 151
  par always !0
  ( always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 153
  addressOf always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  par always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  par always !0
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  true always 1
Line 155
  return always {!<=-1,!>=2}
  false always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  , always {!<=-1,!>=2}
Line 162
  islocal always {!<=-1,!>=2}
Line 166
  ret always {!<=-1,!>=2}
  ret always {!<=-1,!>=2}
  = always 0
  false always 0
Line 169
  bitop possible 38
  == {!<=-1,!>=2,1}
  '&' always 38
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "%varid% %cop% %num% ;" always "%varid% %cop% %num% ;"
  && always {!<=-1,!>=2}
  3 always 3
  == always {!<=-1,!>=2}
  1U always 1
  bitop always 38
Line 170
  4 always 4
Line 171
  0 always 0
  == always {!<=-1,!>=2}
Line 174
  ( always {!<=-1,!>=2}
  "%varid% =" always "%varid% ="
Line 175
  return always {!<=-1,!>=2}
  true always 1
Line 177
  bitop possible 38
  == {!<=-1,!>=2,1}
  '&' always 38
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% &= %num% ;" always "%varid% &= %num% ;"
Line 178
  2 always 2
Line 179
  0 always 0
  == always {!<=-1,!>=2}
Line 182
  ( always {!<=-1,!>=2}
  "++|-- %varid%" always "++|-- %varid%"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% ++|--" always "%varid% ++|--"
Line 183
  return always {!<=-1,!>=2}
  true always 1
Line 184
  ( always {!<=-1,!>=2}
  "[(,] &| %varid% [,)]" always "[(,] &| %varid% [,)]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 185
  return always {!<=-1,!>=2}
  true always 1
Line 186
  ( possible {size=1,size=5}
  == {!<=-1,!>=2,0}
  "}" always "}"
Line 187
  return always {!<=-1,!>=2}
  false always 0
Line 188
  ( always {!<=-1,!>=2}
  "break|continue|return" always "break|continue|return"
Line 189
  ret always {!<=-1,!>=2}
  = always 1
  true always 1
Line 190
  ret {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ";" always ";"
Line 191
  return always {!<=-1,!>=2}
  false always 0
Line 192
  ! {!<=-1,!>=2,1}
  islocal {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 193
  return always {!<=-1,!>=2}
  true always 1
Line 194
  ( always {!<=-1,!>=2}
  "if|while (" always "if|while ("
Line 195
  ! {!<=-1,!>=2,1}
  islocal {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "while" always "while"
Line 197
  == always {!<=-1,!>=2}
  "while" always "while"
Line 199
  1 always 1
Line 200
  = possible 0
  ? possible 0
  bodyStart always !0
  : always 0
  nullptr always 0
Line 201
  ! {!<=-1,!>=2,1}
  bodyEnd {symbolic=(bodyStart?bodyStart->link():nullptr),0}
  || always {!<=-1,!>=2}
  bodyEnd {symbolic=(bodyStart?bodyStart->link():nullptr),!0}
  != always {!<=-1,!>=2}
  "}" always "}"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bodyEnd {symbolic=(bodyStart?bodyStart->link():nullptr),!0}
  ! always {!<=-1,!>=2}
  islocal always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 207
  != always {!<=-1,!>=2}
  end possible symbolic=(tok2->next()->link())
Line 208
  ( always {!<=-1,!>=2}
  "[(,] &| %varid% [,)]" always "[(,] &| %varid% [,)]"
Line 209
  return always {!<=-1,!>=2}
  true always 1
Line 211
  ( always {!<=-1,!>=2}
  "&&|%oror%|( %varid% ==|!= %num% &&|%oror%|)" always "&&|%oror%|( %varid% ==|!= %num% &&|%oror%|)"
Line 213
  vartok always symbolic=(tok2->next())
  2 always 2
Line 214
  != always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '&' always 38
Line 215
  vartok always symbolic=(tok2->next())
  1 always 1
Line 216
  alwaysTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 217
  vartok always symbolic=(tok2->next())
  vartok always symbolic=(tok2->next())
  2 always 2
Line 218
  alwaysTrue always {!<=-1,!>=2}
Line 221
  ( always {!<=-1,!>=2}
  "%varid% %op%" always "%varid% %op%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 222
  return always {!<=-1,!>=2}
  true always 1
Line 226
  ret1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end possible symbolic=(tok2->next()->link())
  2 always 2
  islocal always {!<=-1,!>=2}
Line 227
  ret2 always {!<=-1,!>=2}
  ret2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 228
  ( always {!<=-1,!>=2}
  end possible symbolic=(tok2->next()->link())
  "} else {" always "} else {"
Line 229
  ret2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  islocal always {!<=-1,!>=2}
Line 230
  ret1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ret2 always {!<=-1,!>=2}
Line 231
  return always {!<=-1,!>=2}
  true always 1
Line 234
  return always {!<=-1,!>=2}
  false always 0
Line 237
  , always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 239
  tok2 possible 0@23
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  2 always 2
Line 241
  tok1 possible 0@23
  tok2 possible 0
Line 242
  locations always {{,size=2}
Line 243
  :: always 3
  style always 3
Line 244
  "assignIfError" always "assignIfError"
Line 245
  "Mismatching assignment and comparison, comparison '" always "Mismatching assignment and comparison, comparison '"
  "' is always " always "' is always "
  result {!<=-1,!>=2,0@23}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
  "." always "."
  :: always 0
  normal always 0
Line 251
  tok1 possible 0@28
  tok2 inconclusive 0@28
Line 254
  "Mismatching bitmasks. Result is always 0 (" always "Mismatching bitmasks. Result is always 0 ("
Line 255
  "X = Y & 0x" always "X = Y & 0x"
  num1 inconclusive 240@28
  "; Z = X & 0x" always "; Z = X & 0x"
  num2 inconclusive 1@28
  "; => Z=0)." always "; => Z=0)."
Line 257
  locations always {{,size=2}
Line 258
  :: always 3
  style always 3
Line 259
  "mismatchingBitAnd" always "mismatchingBitAnd"
Line 260
  :: always 0
  normal always 0
Line 266
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 267
  ( always !0
Line 268
  ( possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 269
  ( always !0
Line 270
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 271
  ( always !0
Line 272
  ( possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
Line 273
  ( always !0
Line 277
  ( always {!<=-1,!>=2}
Line 279
  = possible 0
  tok possible symbolic=(parent->astOperand1())@157
  ? possible 0
  tok always !0
  : always 0
  nullptr always 0
Line 280
  scope possible {symbolic=(tok?tok->scope():nullptr),0}
  && always {!<=-1,!>=2}
  scope {symbolic=(tok?tok->scope():nullptr),!0}
  ( always {!<=-1,!>=2}
Line 281
  scope always !0
Line 282
  scope possible {symbolic=(tok?tok->scope():nullptr),0}
  && always {!<=-1,!>=2}
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 283
  scope always !0
Line 284
  func always symbolic=(scope->function)
Line 285
  func {symbolic=(scope->function),!0}
Line 286
  ( always {!<=-1,!>=2}
  ret possible symbolic=(func->retDef)
  "static|const" always "static|const"
Line 288
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ret possible symbolic=(func->retDef)
  "bool|_Bool" always "bool|_Bool"
Line 291
  return always {!<=-1,!>=2}
  false always 0
Line 296
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 300
  == always {!<=-1,!>=2}
  "|" always "|"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 301
  = always !0
  ( always !0
Line 302
  isBoolean always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "&&|%oror%" always "&&|%oror%"
  || always {!<=-1,!>=2}
Line 303
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 304
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  ( always !0
  ( always !0
  "bool|_Bool" always "bool|_Bool"
  || always {!<=-1,!>=2}
Line 305
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "if|while" always "if|while"
  || always {!<=-1,!>=2}
Line 306
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(parent->astOperand1())
Line 308
  isTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 309
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  0 always 0
Line 311
  isBoolean always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isTrue always {!<=-1,!>=2}
Line 319
  tok possible 0@24
  :: always 2
  warning always 2
  "badBitmaskCheck" always "badBitmaskCheck"
  "Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'?" always "Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'?"
  :: always 0
  normal always 0
Line 324
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 328
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  ! always {!<=-1,!>=2}
  expr1 always symbolic=(tok->astOperand1())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  expr2 always symbolic=(tok->astOperand2())
Line 335
  expr1 {symbolic=(tok->astOperand1()),!0}
  ( always {!<=-1,!>=2}
Line 336
  expr1 {symbolic=(tok->astOperand1()),!0}
  expr2 {symbolic=(tok->astOperand2()),!0}
Line 337
  ! always {!<=-1,!>=2}
  expr2 {symbolic=(tok->astOperand2()),symbolic=(tok->astOperand1())}
  ( always {!<=-1,!>=2}
Line 340
  num2 {symbolic=(MathLib::toLongNumber(expr2->str())),symbolic=(num1&num2),symbolic=(num1|num2),>=symbolic=(num1),<=symbolic=(num1-1)}
  < always {!<=-1,!>=2}
  0 always 0
Line 342
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[&|]" always "[&|]"
Line 345
  numbers always size=0
Line 346
  num1 possible {<=symbolic=(num2),>=symbolic=(num2+1)}
  : possible {<=symbolic=(num2),>=symbolic=(num2+1)}
Line 347
  num1 possible {<=symbolic=(num2),>=symbolic=(num2+1)}
  < always {!<=-1,!>=2}
  0 always 0
Line 349
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 350
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 351
  == always {!<=-1,!>=2}
  "|" always "|"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  != always {!<=-1,!>=2}
Line 353
  num1 always !<=-1
  op possible size=2
  == always {!<=-1,!>=2}
  "==" always "=="
  ? {0,1,!<=-1,!>=2}
  false always 0
  : always 1
  true always 1
Line 355
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 356
  or_equal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">=|<=" always ">=|<="
Line 358
  ( always {!<=-1,!>=2}
  ">=|<" always ">=|<"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  < always {!<=-1,!>=2}
Line 359
  ( always size=1
  num1 {<=symbolic=(num2-1),!>=symbolic=(num2),!<=-1}
  num2 {>=symbolic=(num1+1),!<=symbolic=(num1)}
  or_equal {!<=-1,!>=2,0}
  ? {0,1,!<=-1,!>=2}
  false always 0
  : always 1
  true always 1
Line 360
  ( always {!<=-1,!>=2}
  "<=|>" always "<=|>"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  <= always {!<=-1,!>=2}
Line 361
  ( always size=1
  num1 {<=symbolic=(num2),!>=symbolic=(num2+1),!<=-1}
  num2 {>=symbolic=(num1),!<=symbolic=(num1-1)}
  or_equal {!<=-1,!>=2,0}
  ? {1,0,!<=-1,!>=2}
  true always 1
  : always 0
  false always 0
Line 363
  == always {!<=-1,!>=2}
  "|" always "|"
Line 364
  && always {!<=-1,!>=2}
Line 365
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 366
  or_equal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">=|<=" always ">=|<="
Line 368
  ( always {!<=-1,!>=2}
  ">=|<" always ">=|<"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  >= always {!<=-1,!>=2}
Line 371
  ( always size=1
  num1 {>=symbolic=(num2),!<=symbolic=(num2-1),!<=-1}
  num2 {<=symbolic=(num1),!>=symbolic=(num1+1)}
  or_equal {!<=-1,!>=2,0}
  ? {1,0,!<=-1,!>=2}
  true always 1
  : always 0
  false always 0
Line 372
  ( always {!<=-1,!>=2}
  "<=|>" always "<=|>"
  && always {!<=-1,!>=2}
  num1 always !<=-1
  > always {!<=-1,!>=2}
Line 375
  ( always size=1
  num1 {>=symbolic=(num2+1),!<=symbolic=(num2),!<=-1}
  num2 {<=symbolic=(num1-1),!>=symbolic=(num1)}
  or_equal {!<=-1,!>=2,0}
  ? {0,1,!<=-1,!>=2}
  false always 0
  : always 1
  true always 1
Line 383
  , always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 386
  "(X " always "(X "
  bitop possible {"&"@25,size=1@120}
  " 0x" always " 0x"
  value1 possible {<=symbolic=(num2)@122,>=symbolic=(num2+1)@132,6@25}
  ") " always ") "
  op possible {"=="@25,size=2@116}
  " 0x" always " 0x"
  value2 possible {>=symbolic=(num1)@122,<=symbolic=(num1-1)@132,1@25}
Line 388
  "Expression '" always "Expression '"
  "' is always " always "' is always "
  result {!<=-1,!>=2,0@116,1@116}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
  ".\nThe expression '" always ".\nThe expression '"
Line 389
  "' is always " always "' is always "
  result {!<=-1,!>=2,0@116,1@116}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 390
  ". Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions." always ". Check carefully constants and operators used, these errors might be hard to spot sometimes. In case of complex expression it might help to split it to separate expressions."
Line 394
  tok possible 0@25
  :: always 3
  style always 3
  "comparisonError" always "comparisonError"
  :: always 0
  normal always 0
Line 397
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 399
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 400
  return always {!<=-1,!>=2}
  false always 0
Line 403
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  cond1 always !0
  cond2 always !0
  pure {!<=-1,!>=2,1@55}
  false always 0
Line 404
  return always {!<=-1,!>=2}
  true always 1
Line 407
  cond1 always !0
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  cond1 always !0
  && always {!<=-1,!>=2}
  cond2 always !0
Line 408
  = always !0
  cond1 always !0
  ( always !0
Line 409
  cond1 always !0
Line 410
  ! always {!<=-1,!>=2}
  num1 always symbolic=(cond1->astOperand2())
Line 411
  return always {!<=-1,!>=2}
  false always 0
Line 412
  ! always {!<=-1,!>=2}
  num1 {symbolic=(cond1->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 413
  expr1 {symbolic=(cond1->astOperand1()),!0}
  num1 {symbolic=(cond1->astOperand2()),!0}
Line 414
  ! always {!<=-1,!>=2}
  num1 {symbolic=(cond1->astOperand2()),symbolic=(cond1->astOperand1())}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 415
  return always {!<=-1,!>=2}
  false always 0
Line 417
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&|==" always "&|=="
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  false always 0
Line 419
  = always !0
  ( always !0
Line 420
  = always !0
  ( always !0
Line 421
  ! always {!<=-1,!>=2}
  num2 {symbolic=(cond2->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 422
  expr2 {symbolic=(cond2->astOperand1()),!0}
  num2 {symbolic=(cond2->astOperand2()),!0}
Line 423
  ! always {!<=-1,!>=2}
  num2 {symbolic=(cond2->astOperand2()),symbolic=(cond2->astOperand1())}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  num2 inconclusive symbolic=(cond2->astOperand2())
Line 424
  return always {!<=-1,!>=2}
  false always 0
Line 426
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  expr2 inconclusive symbolic=(cond2->astOperand1())
  pure always {!<=-1,!>=2}
  false always 0
Line 427
  return always {!<=-1,!>=2}
  false always 0
Line 431
  == always {!<=-1,!>=2}
  "&" always "&"
Line 432
  return always {!<=-1,!>=2}
  value1 always symbolic=(MathLib::toLongNumber(num1->str()))
  value2 always symbolic=(MathLib::toLongNumber(num2->str()))
  == always {!<=-1,!>=2}
  value2 always symbolic=(MathLib::toLongNumber(num2->str()))
Line 433
  return always {!<=-1,!>=2}
  value1 always symbolic=(MathLib::toLongNumber(num1->str()))
  value2 always symbolic=(MathLib::toLongNumber(num2->str()))
  > always {!<=-1,!>=2}
  0 always 0
Line 435
  return always {!<=-1,!>=2}
  false always 0
Line 440
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 445
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 446
  != always {!<=-1,!>=2}
  :: always 6
  eIf always 6
Line 450
  ! {!<=-1,!>=2,1}
  tok2 {symbolic=(scope.classDef->next()),0}
Line 452
  tok2 {symbolic=(scope.classDef->next()),!0}
Line 453
  ! always {!<=-1,!>=2}
  cond1 always symbolic=(tok2->astOperand2())
Line 455
  cond1 {symbolic=(tok2->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 459
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 461
  1 always 1
Line 462
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} if (" always "} if ("
Line 464
  2 always 2
Line 465
  ! always {!<=-1,!>=2}
Line 469
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cond2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 470
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  cond2 always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 471
  cond2 always !0
Line 477
  ( always {!<=-1,!>=2}
  tok1 possible 0@26
  ( always {!<=-1,!>=2}
  tok2 possible 0@26
Line 479
  errorPath possible size=0@26
  tok1 possible 0@26
  "First condition" always "First condition"
Line 480
  tok2 inconclusive 0@26
  "Second condition" always "Second condition"
Line 482
  = always "The if condition is the same as the previous if condition"
  "The if condition is the same as the previous if condition" always "The if condition is the same as the previous if condition"
Line 484
  :: always 3
  style always 3
  "duplicateCondition" always "duplicateCondition"
  msg always {"The if condition is the same as the previous if condition",size=57}
  :: always 0
  normal always 0
Line 489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 494
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 495
  != always {!<=-1,!>=2}
  :: always 6
  eIf always 6
Line 499
  ! always {!<=-1,!>=2}
  cond1 always symbolic=(scope.classDef->next()->astOperand2())
Line 506
  tok2 possible symbolic=(scope.classDef->next())
Line 507
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 509
  1 always 1
Line 510
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} else { if (" always "} else { if ("
Line 512
  4 always 4
Line 516
  ( always {!<=-1,!>=2}
  ( always !0
  true always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 517
  ( always !0
Line 518
  ( always {!<=-1,!>=2}
  true always 1
  ( always {!<=-1,!>=2}
  ( always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
  && always {!<=-1,!>=2}
Line 519
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 520
  ( always !0
Line 528
  ( always {!<=-1,!>=2}
  tok possible 0@27
Line 531
  "Expression is always false because 'else if' condition matches previous condition at line " always "Expression is always false because 'else if' condition matches previous condition at line "
Line 532
  line1 possible 1@27
  "." always "."
Line 534
  tok possible 0@27
  :: always 3
  style always 3
  "multiCondition" always "multiCondition"
  :: always 0
  normal always 0
Line 539
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 542
  "Expression is always true because 'else if' condition is opposite to previous condition at line " always "Expression is always true because 'else if' condition is opposite to previous condition at line "
Line 543
  "." always "."
Line 545
  "first condition" always "first condition"
Line 546
  "else if condition is opposite to first condition" always "else if condition is opposite to first condition"
Line 548
  :: always 3
  style always 3
  "multiCondition" always "multiCondition"
  :: always 0
  normal always 0
Line 557
  ( always {!<=-1,!>=2}
Line 559
  ( always {!<=-1,!>=2}
Line 560
  return always {!<=-1,!>=2}
  false always 0
Line 562
  obj possible {symbolic=(ftok->next()->astOperand1()),0}
  && always {!<=-1,!>=2}
  obj {symbolic=(ftok->next()->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "." always "."
Line 563
  obj always !0
Line 564
  ! {!<=-1,!>=2,1}
  obj possible {symbolic=(ftok->next()->astOperand1()),0}
Line 565
  return always {!<=-1,!>=2}
  true always 1
Line 566
  obj always !0
  && always {!<=-1,!>=2}
  obj always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 567
  return always {!<=-1,!>=2}
  false always 0
Line 568
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  false always 0
Line 570
  return always {!<=-1,!>=2}
  true always 1
Line 575
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 580
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 581
  = always 0
  nullptr always 0
Line 582
  . possible {9,8}
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  || {!<=-1,!>=2,0}
  . {8,!6}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
Line 584
  . always {!6,!9}
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 586
  ! {!<=-1,!>=2,1}
  condTok {symbolic=(scope.classDef->next()->astOperand2()),0}
  || always {!<=-1,!>=2}
  condTok {symbolic=(scope.classDef->next()->astOperand2()),!0}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 588
  condTok {symbolic=(scope.classDef->next()->astOperand2()),!0}
Line 589
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  condTok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 591
  condTok always !0
Line 593
  ! always {!<=-1,!>=2}
  condTok possible symbolic=(scope.classDef->next()->astOperand2())
Line 595
  = always !0
  condTok always !0
Line 597
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 600
  functionCall always {!<=-1,!>=2}
  functionCall always {!<=-1,!>=2}
  = always 0
  false always 0
Line 601
  nonConstFunctionCall {!<=-1,!>=2,0}
  nonConstFunctionCall always {!<=-1,!>=2}
  = always 0
  false always 0
Line 602
  nonlocal always {!<=-1,!>=2}
  nonlocal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 604
  condTok {symbolic=(cond1),!0}
Line 605
  [ possible {lifetime[Lambda]=(functionCall),lifetime[Lambda]=(isNonConstFunctionCall(cond,mSettings->library))}
Line 606
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 607
  functionCall always {!<=-1,!>=2}
  = always 1
  true always 1
Line 608
  nonConstFunctionCall always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 609
  nonConstFunctionCall always {!<=-1,!>=2}
Line 610
  :: always 4
  done always 4
Line 614
  ( always !0
Line 616
  ! always {!<=-1,!>=2}
  nonlocal always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always symbolic=(cond->variable())
Line 617
  ! always {!<=-1,!>=2}
  var {symbolic=(cond->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(cond->variable()),!0}
  ( always {!<=-1,!>=2}
Line 618
  nonlocal always {!<=-1,!>=2}
  = always 1
  true always 1
Line 619
  var {symbolic=(cond->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(cond->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%oror%|&&|!" always "%oror%|&&|!"
Line 621
  nonlocal always {!<=-1,!>=2}
  = always 1
  true always 1
Line 623
  ! always {!<=-1,!>=2}
  nonlocal always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 625
  nonlocal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%cop%|(|[" always "%cop%|(|["
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ." always "%name% ."
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "this" always "this"
Line 627
  :: always 3
  op1_and_op2 always 3
Line 629
  :: always 0
  none always 0
Line 632
  nonConstFunctionCall always {!<=-1,!>=2}
Line 637
  [ possible lifetime[Lambda]=(varsInCond)
  & {lifetime[Address]=(varsInCond),!0}
Line 639
  = always !0
  ( always !0
Line 640
  ( possible lifetime[Iterator]=(varsInCond)
  ( {lifetime[Iterator]=(varsInCond),start=0}
  ( {lifetime[Iterator]=(varsInCond),end=0}
  var {symbolic=(cond->variable()),!0}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varsInCond),end=0}
Line 643
  :: always 3
  op1_and_op2 always 3
Line 647
  INNER always 0
  AFTER always 1
Line 652
  ( always {!<=-1,!>=2}
  "{ return|throw|continue|break" always "{ return|throw|continue|break"
Line 653
  types always {{,size=1}
  :: always 1
  AFTER always 1
Line 654
  : possible {
  types possible {{,size=1}
Line 655
  == always {!<=-1,!>=2}
  :: always 1
  AFTER always 1
Line 660
  tok possible {symbolic=(scope.bodyEnd->next()),symbolic=(scope.bodyStart)}
Line 662
  tok possible {symbolic=(scope.bodyEnd->next()),symbolic=(scope.bodyStart)}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  endToken possible symbolic=(tok->scope()->bodyEnd)
Line 663
  ( always {!<=-1,!>=2}
  0 always 0
  false always 0
  ( always {!<=-1,!>=2}
Line 665
  ( always {!<=-1,!>=2}
  "if|return" always "if|return"
Line 666
  == always {!<=-1,!>=2}
  "if" always "if"
Line 667
  == always {!<=-1,!>=2}
  "if" always "if"
  condStartToken always symbolic=(tok->str()=="if"?tok->next():tok)
  condStartToken always symbolic=(tok->str()=="if"?tok->next():tok)
  ";" always ";"
Line 669
  ( always {!<=-1,!>=2}
  condStartToken always symbolic=(tok->str()=="if"?tok->next():tok)
  condEndToken always symbolic=(tok->str()=="if"?condStartToken->link():Token::findsimplematch(condStartToken,";"))
  ( always {!<=-1,!>=2}
Line 673
  == always {!<=-1,!>=2}
  "if" always "if"
  condStartToken always symbolic=(tok->str()=="if"?tok->next():tok)
  condStartToken always symbolic=(tok->str()=="if"?tok->next():tok)
Line 674
  isReturnVar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cond2 always symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())
  "%cop%" always "%cop%"
Line 678
  == always {!<=-1,!>=2}
Line 679
  [ possible {lifetime[Lambda]=(if(!isOppositeCond(false,mTokenizer->isCPP(),firstCondition,cond2,mSettings->library,true,true))),lifetime[Lambda]=(cond2),lifetime[Lambda]=(vars)}
Line 680
  ! always {!<=-1,!>=2}
Line 681
  :: always 0
  none always 0
Line 682
  firstCondition always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 683
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  ( always {!<=-1,!>=2}
  firstCondition always !0
  true always 1
  true always 1
Line 684
  :: always 3
  op1_and_op2 always 3
Line 686
  ! always {!<=-1,!>=2}
  firstCondition always !0
  ( always {!<=-1,!>=2}
Line 687
  ! {!<=-1,!>=2,1}
  isReturnVar {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  ( always {!<=-1,!>=2}
  firstCondition always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 688
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 689
  firstCondition always !0
Line 690
  ! always {!<=-1,!>=2}
  isReturnVar always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  firstCondition always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 691
  firstCondition always !0
Line 694
  :: always 0
  none always 0
Line 697
  cond2 always symbolic=(tok->str()=="if"?condStartToken->astOperand2():condStartToken->astOperand1())
  [ possible {lifetime[Lambda]=(if((!cond1->hasKnownIntValue()||!secondCondition->hasKnownIntValue())&&isSameExpression(mTokenizer->isCPP(),true,cond1,secondCondition,mSettings->library,true,true,&errorPath))),lifetime[Lambda]=(cond1),lifetime[Lambda]=(errorPath)}
Line 698
  ( possible size=2
  == always {!<=-1,!>=2}
  "||" always "||"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 699
  :: always 3
  op1_and_op2 always 3
Line 701
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 702
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 703
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 705
  :: always 4
  done always 4
Line 708
  :: always 0
  none always 0
Line 712
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 713
  ( always {!<=-1,!>=2}
  1 always 1
  0 always 0
  ( always {!<=-1,!>=2}
Line 716
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  nonlocal always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 718
  ( always {!<=-1,!>=2}
  "case|break|continue|return|throw" always "case|break|continue|return|throw"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 720
  ( always {!<=-1,!>=2}
  "[;{}] %name% :" always "[;{}] %name% :"
Line 724
  ( always {!<=-1,!>=2}
  "for|while|do" always "for|while|do"
Line 727
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 728
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "} while (" always "} while ("
Line 730
  1 always 1
  2 always 2
Line 731
  ( always {!<=-1,!>=2}
  "if|while (" always "if|while ("
Line 732
  1 always 1
Line 733
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 734
  1 always 1
Line 735
  ! always {!<=-1,!>=2}
Line 741
  changed always {!<=-1,!>=2}
  changed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 743
  ( always {!<=-1,!>=2}
  tok1 always symbolic=(tok->next())
  nonlocal always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 744
  changed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 748
  changed {!<=-1,!>=2,1}
Line 751
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(vars)
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
  || always {!<=-1,!>=2}
Line 752
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  nonlocal always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 753
  functionCall always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 754
  ( always {!<=-1,!>=2}
  "%name% %assign%|++|--" always "%name% %assign%|++|--"
Line 756
  ( always {!<=-1,!>=2}
  "*|.|[" always "*|.|["
Line 758
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  ".|[" always ".|["
  || always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  && always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 760
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  "%assign%|++|--" always "%assign%|++|--"
Line 763
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% <<" always "%name% <<"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 765
  ( always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 767
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
Line 768
  1 always 1
Line 769
  ( always {!<=-1,!>=2}
  "] [" always "] ["
Line 770
  1 always 1
Line 771
  ( always {!<=-1,!>=2}
  "] %assign%|++|--" always "] %assign%|++|--"
Line 774
  ( always {!<=-1,!>=2}
  "++|--|& %name%" always "++|--|& %name%"
Line 776
  && always {!<=-1,!>=2}
Line 777
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 778
  ( always {!<=-1,!>=2}
  "%name% . %name% (" always "%name% . %name% ("
Line 779
  2 always 2
Line 780
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  function always !0
  ( always {!<=-1,!>=2}
Line 783
  ( always {!<=-1,!>=2}
  "[(,] %name% [,)]" always "[(,] %name% [,)]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 793
  ! {!<=-1,!>=2,1@7861}
  tok possible 0@7861
Line 794
  "if" always "if"
Line 795
  ! always {!<=-1,!>=2}
  tok always !0
Line 796
  "if" always "if"
Line 797
  = always !0
  tok always !0
  ( always !0
Line 798
  top {symbolic=(tok->astTop()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  top {symbolic=(tok->astTop()),!0}
Line 799
  top {symbolic=(tok->astTop()),!0}
  ( always !0
Line 800
  top {symbolic=(tok->astTop()),!0}
Line 805
  ( always {!<=-1,!>=2}
  tok1 possible 0
  ( always {!<=-1,!>=2}
  tok2 possible 0
Line 807
  tok1 possible 0@29
  ? possible "x"
  tok1 always !0
  : always "x"
  "x" always "x"
Line 808
  tok2 possible 0@29
  ? possible "!x"
  tok2 always !0
  : always "!x"
  "!x" always "!x"
Line 809
  tok2 possible 0@29
Line 810
  errorPath possible size=0@29
  tok1 possible 0@29
  "outer condition: " always "outer condition: "
Line 811
  errorPath always !size=0
  tok2 inconclusive 0@29
  "opposite inner condition: " always "opposite inner condition: "
Line 813
  "Opposite inner '" always "Opposite inner '"
  "' condition leads to a dead code block.\nOpposite inner '" always "' condition leads to a dead code block.\nOpposite inner '"
Line 814
  "' condition leads to a dead code block (outer condition is '" always "' condition leads to a dead code block (outer condition is '"
  "' and inner condition is '" always "' and inner condition is '"
  "')." always "')."
Line 815
  errorPath always {!size=1,!size=0}
  :: always 2
  warning always 2
  "oppositeInnerCondition" always "oppositeInnerCondition"
  :: always 0
  normal always 0
Line 820
  ( always {!<=-1,!>=2}
  tok1 possible 0
  ( always {!<=-1,!>=2}
  tok2 possible 0
Line 822
  tok1 possible 0@30
  ? possible "x"
  tok1 always !0
  : always "x"
  "x" always "x"
Line 823
  tok2 possible 0@30
  ? possible "x"
  tok2 always !0
  : always "x"
  "x" always "x"
Line 824
  tok2 possible 0@30
Line 825
  errorPath possible size=0@30
  tok1 possible 0@30
  "outer condition: " always "outer condition: "
Line 826
  errorPath always !size=0
  tok2 inconclusive 0@30
  "identical inner condition: " always "identical inner condition: "
Line 828
  "Identical inner '" always "Identical inner '"
  "' condition is always true.\nIdentical inner '" always "' condition is always true.\nIdentical inner '"
Line 829
  "' condition is always true (outer condition is '" always "' condition is always true (outer condition is '"
  "' and inner condition is '" always "' and inner condition is '"
  "')." always "')."
Line 830
  errorPath always {!size=1,!size=0}
  :: always 2
  warning always 2
  "identicalInnerCondition" always "identicalInnerCondition"
  :: always 0
  normal always 0
Line 835
  ( always {!<=-1,!>=2}
  cond1 possible 0
  ( always {!<=-1,!>=2}
  cond2 possible 0@31
Line 838
  isReturnValue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  cond2 possible 0@31
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cond2 always !0
  "return" always "return"
Line 840
  cond1 possible 0@31
  ? possible "x"
  cond1 always !0
  : always "x"
  "x" always "x"
Line 841
  cond2 possible 0@31
  && always {!<=-1,!>=2}
  cond2 always !0
  && always {!<=-1,!>=2}
  cond2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  "false" always "false"
  : always "0"
  "0" always "0"
Line 843
  errorPath possible size=0@31
  cond1 possible 0@31
  "If condition '" always "If condition '"
  "' is true, the function will return/exit" always "' is true, the function will return/exit"
Line 844
  errorPath always !size=0
  cond2 inconclusive 0@31
  isReturnValue {!<=-1,!>=2,0}
  ? possible {"Returning identical expression '","Testing identical condition '"}
  "Returning identical expression '" always "Returning identical expression '"
  : always "Testing identical condition '"
  "Testing identical condition '" always "Testing identical condition '"
  "'" always "'"
Line 846
  errorPath always {!size=1,!size=0}
Line 847
  :: always 2
  warning always 2
Line 848
  "identicalConditionAfterEarlyExit" always "identicalConditionAfterEarlyExit"
Line 849
  isReturnValue always {!<=-1,!>=2}
Line 850
  "Identical condition and return expression '" always "Identical condition and return expression '"
  "', return value is always " always "', return value is always "
Line 851
  "Identical condition '" always "Identical condition '"
  "', second condition is always false" always "', second condition is always false"
Line 853
  :: always 0
  normal always 0
Line 875
  [ possible 62
  0 always 0
  == {!<=-1,!>=2,0}
  '<' always 60
Line 876
  0 always 0
  = always 62
  '>' always 62
Line 877
  [ always !60
  0 always 0
  == always {!<=-1,!>=2}
  '>' always 62
Line 878
  0 always 0
  = always 60
  '<' always 60
Line 883
  ( always {!<=-1,!>=2}
Line 885
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
  || always {!<=-1,!>=2}
Line 886
  == always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
  || always {!<=-1,!>=2}
Line 887
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
  || always {!<=-1,!>=2}
Line 888
  == always {!<=-1,!>=2}
  ">=" always ">="
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
  || always {!<=-1,!>=2}
Line 889
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
  || always {!<=-1,!>=2}
Line 890
  == always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?0:MathLib::toLongNumber(value1))@117,symbolic=((isfloat)?0:MathLib::toLongNumber(value2))@118}
Line 893
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)@111,symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)@112}
  || always {!<=-1,!>=2}
Line 896
  == always {!<=-1,!>=2}
  ">=" always ">="
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)@111,symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)@112}
  || always {!<=-1,!>=2}
Line 897
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)@111,symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)@112}
  || always {!<=-1,!>=2}
Line 898
  == always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  value2 possible {symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)@111,symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)@112}
Line 902
  ( always !<=-1
Line 914
  2.0f always 2
Line 919
  ( always !<=-1
Line 942
  ( always {!<=-1,!>=2}
Line 944
  * {!<=-1,!>=2,Uninit@95}
  not1 possible {lifetime[Address]=(not1)@95,lifetime[Address]=(not2)@96,lifetime[Address]=(not_)@132,Uninit*@95}
  = always 0
  false always 0
Line 945
  comp possible {0,symbolic=(tok->astOperand1())@95,symbolic=(tok->astOperand2())@96}
  && always {!<=-1,!>=2}
  comp {!0,symbolic=(tok->astOperand2())@96}
  == always {!<=-1,!>=2}
  "!" always "!"
Line 946
  * always {!<=-1,!>=2}
  not1 possible lifetime[Address]=(not_)@132
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
  not1 possible lifetime[Address]=(not_)@132
Line 947
  comp always !0
Line 950
  ! {!<=-1,!>=2,1}
  comp possible {0,symbolic=(tok->astOperand2())@96}
Line 951
  return always {!<=-1,!>=2}
  false always 0
Line 953
  comp always !0
Line 954
  comp always !0
Line 955
  ! always {!<=-1,!>=2}
  comp always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op1 always symbolic=(comp->astOperand1())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  op2 always symbolic=(comp->astOperand2())
Line 956
  = always "!="
  "!=" always "!="
Line 957
  = always "0"
  "0" always "0"
Line 958
  = always !0
  comp always !0
Line 959
  op1 {symbolic=(comp->astOperand1()),!0}
  ( always {!<=-1,!>=2}
Line 960
  op1 {symbolic=(comp->astOperand1()),!0}
  ( always {!<=-1,!>=2}
Line 961
  return always {!<=-1,!>=2}
  false always 0
Line 962
  comp always !0
Line 963
  op1 {symbolic=(comp->astOperand1()),!0}
  && always {!<=-1,!>=2}
  op1 {symbolic=(comp->astOperand1()),!0}
  ( always !0
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
Line 964
  op1 {symbolic=(comp->astOperand1()),!0}
  ( always !0
Line 966
  op1 {symbolic=(comp->astOperand1()),!0}
Line 967
  = {symbolic=(comp->astOperand2()),!0}
  op2 {symbolic=(comp->astOperand2()),!0}
Line 968
  comp always !0
  ( {symbolic=(op2),!0}
  ( always {!<=-1,!>=2}
Line 969
  op2 {symbolic=(comp->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 970
  return always {!<=-1,!>=2}
  false always 0
Line 971
  comp always !0
Line 972
  op2 {symbolic=(comp->astOperand2()),!0}
  && always {!<=-1,!>=2}
  op2 {symbolic=(comp->astOperand2()),!0}
  ( always !0
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
Line 973
  op2 {symbolic=(comp->astOperand2()),!0}
  ( always !0
Line 975
  op2 {symbolic=(comp->astOperand2()),!0}
Line 976
  = {symbolic=(comp->astOperand1()),!0}
  op1 {symbolic=(comp->astOperand1()),!0}
Line 978
  = always "!="
  "!=" always "!="
Line 979
  = always "0"
  "0" always "0"
Line 980
  = always !0
  comp always !0
Line 983
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
Line 986
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 987
  return always {!<=-1,!>=2}
  false always 0
Line 989
  return always {!<=-1,!>=2}
  true always 1
Line 992
  not1 always {!<=-1,!>=2}
Line 994
  ( always {!<=-1,!>=2}
Line 995
  not1 {!<=-1,!>=2,0}
  ? possible {"!(",""}
  "!(" always "!("
  : always ""
  "" always ""
Line 996
  ( always {!<=-1,!>=2}
  "EXPR" always "EXPR"
Line 997
  " " always " "
Line 999
  " " always " "
Line 1001
  not1 always {!<=-1,!>=2}
  ? possible {")",""}
  ")" always ")"
  : always ""
  "" always ""
Line 1003
  not1 always {!<=-1,!>=2}
  ? possible {"!",""}
  "!" always "!"
  : always ""
  "" always ""
Line 1004
  ( always {!<=-1,!>=2}
  "EXPR" always "EXPR"
Line 1009
  ! always {!<=-1,!>=2}
Line 1010
  "" always ""
Line 1011
  tok always !0
  ( always {!<=-1,!>=2}
Line 1012
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1013
  not_ always {!<=-1,!>=2}
Line 1016
  ( always {!<=-1,!>=2}
  tok always !0
  & {lifetime[Address]=(not_),!0,Uninit*}
  not_ {!<=-1,!>=2,Uninit}
  & {lifetime[Address]=(op),!0}
  op always size=0
  & {lifetime[Address]=(value),!0}
  value always size=0
  & {lifetime[Address]=(expr),!0,Uninit*}
  expr always Uninit
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1017
  not_ always {!<=-1,!>=2}
Line 1020
  ( always {!<=-1,!>=2}
  tok always !0
  "%cop%|&&|%oror%" always "%cop%|&&|%oror%"
Line 1021
  tok always !0
Line 1022
  tok always !0
  " " always " "
  tok always !0
  " " always " "
  tok always !0
  ( always !0
Line 1023
  tok always !0
  "(" always "("
  tok always !0
  ")" always ")"
Line 1026
  tok always !0
Line 1029
  ( always {!<=-1,!>=2}
Line 1031
  return always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(tok->astTop()),!0}
  "if" always "if"
  && always {!<=-1,!>=2}
  top {symbolic=(tok->astTop()),!0}
  ( always {!<=-1,!>=2}
Line 1036
  printStyle always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1037
  printWarning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1038
  ! {!<=-1,!>=2,1}
  printWarning {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printStyle always {!<=-1,!>=2}
Line 1040
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1043
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1045
  != always {!<=-1,!>=2}
Line 1046
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1054
  printStyle {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 1055
  == always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
  || always {!<=-1,!>=2}
Line 1056
  == always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "||" always "||"
Line 1057
  ( always !0
Line 1058
  ( always {!<=-1,!>=2}
  true always 1
  ( always {!<=-1,!>=2}
  ( always !0
  tok2 always symbolic=(tok->astOperand2()->astOperand1())
  true always 1
  false always 0
Line 1059
  ( always !0
Line 1060
  ( always !0
  ( always symbolic=(tok2)
Line 1061
  ( always !0
Line 1067
  expr1 always symbolic=(expr1VerboseMsg)
  ( always !<=-1
  + always !<=-1
  expr2 always symbolic=(expr2VerboseMsg)
  ( always !<=-1
  + always !<=-1
  expr3 always symbolic=(expr3VerboseMsg)
  ( always !<=-1
  > always {!<=-1,!>=2}
  50U always 50
Line 1068
  expr1 always symbolic=(expr1VerboseMsg)
  0 always 0
  == always {!<=-1,!>=2}
  '!' always 33
  && always {!<=-1,!>=2}
  expr2 always symbolic=(expr2VerboseMsg)
  0 always 0
  != always {!<=-1,!>=2}
  '!' always 33
Line 1069
  = always "!A"
  "!A" always "!A"
Line 1070
  = always "A"
  "A" always "A"
Line 1072
  = always "A"
  "A" always "A"
Line 1073
  = always "!A"
  "!A" always "!A"
Line 1076
  = always "B"
  "B" always "B"
Line 1079
  expr1 possible {symbolic=(expr1VerboseMsg),"!A",size=2,"A",size=1}
  + possible {size=3,size=2}
  " " always " "
  " (" always " ("
  expr2 possible {symbolic=(expr2VerboseMsg),"A",size=1,"!A",size=2}
  " " always " "
  ( always !0
  " " always " "
  expr3 possible {symbolic=(expr3VerboseMsg),"B",size=1}
  ")" always ")"
Line 1080
  expr1 possible {symbolic=(expr1VerboseMsg),"!A",size=2,"A",size=1}
  + possible {size=3,size=2}
  " " always " "
  " " always " "
  expr3 possible {symbolic=(expr3VerboseMsg),"B",size=1}
Line 1082
  expr1VerboseMsg possible symbolic=(expr1)
  " " always " "
  " " always " "
  expr2VerboseMsg possible symbolic=(expr2)
  " " always " "
  ( always !0
  " " always " "
  expr3VerboseMsg possible symbolic=(expr3)
Line 1083
  expr1VerboseMsg possible symbolic=(expr1)
  " " always " "
  " " always " "
  expr3VerboseMsg possible symbolic=(expr3)
Line 1085
  tok2 always symbolic=(tok->astOperand2()->astOperand1())
  ". '" always ". '"
  cond1 always symbolic=(expr1+" "+tok->str()+" ("+expr2+" "+tok->astOperand2()->str()+" "+expr3+")")
  "' is equivalent to '" always "' is equivalent to '"
  cond2 always symbolic=(expr1+" "+tok->str()+" "+expr3)
  "'\nThe condition '" always "'\nThe condition '"
Line 1086
  cond1VerboseMsg always symbolic=(expr1VerboseMsg+" "+tok->str()+" "+expr2VerboseMsg+" "+tok->astOperand2()->str()+" "+expr3VerboseMsg)
  "' is equivalent to '" always "' is equivalent to '"
  cond2VerboseMsg always symbolic=(expr1VerboseMsg+" "+tok->str()+" "+expr3VerboseMsg)
  "'." always "'."
Line 1087
  msg always symbolic=(tok2->expressionString()+". '"+cond1+"' is equivalent to '"+cond2+"'\nThe condition '"+cond1VerboseMsg+"' is equivalent to '"+cond2VerboseMsg+"'.")
  false always 0
Line 1089
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  ( always !0
  tok2 always symbolic=(tok->astOperand2()->astOperand1())
  true always 1
  true always 1
Line 1090
  ( always !0
Line 1091
  ( always !0
  ( always symbolic=(tok2)
Line 1092
  ( always !0
Line 1098
  expr1 always symbolic=(expr1VerboseMsg)
  ( always !<=-1
  + always !<=-1
  expr2 always symbolic=(expr2VerboseMsg)
  ( always !<=-1
  + always !<=-1
  expr3 always symbolic=(expr3VerboseMsg)
  ( always !<=-1
  > always {!<=-1,!>=2}
  50U always 50
Line 1099
  = always "A"
  "A" always "A"
Line 1100
  = always "A"
  "A" always "A"
Line 1101
  = always "B"
  "B" always "B"
Line 1104
  expr1 possible {symbolic=(expr1VerboseMsg),"A",size=1}
  + possible size=2
  " " always " "
  " (" always " ("
  expr2 possible {symbolic=(expr2VerboseMsg),"A",size=1}
  " " always " "
  ( always !0
  " " always " "
  expr3 possible {symbolic=(expr3VerboseMsg),"B",size=1}
  ")" always ")"
Line 1105
  = possible {symbolic=(expr1VerboseMsg),"A",size=1}
  expr1 possible {symbolic=(expr1VerboseMsg),"A",size=1}
Line 1107
  expr1VerboseMsg possible {symbolic=(expr1),symbolic=(cond2)}
  " " always " "
  " " always " "
  expr2VerboseMsg possible symbolic=(expr2)
  " " always " "
  ( always !0
  " " always " "
  expr3VerboseMsg possible symbolic=(expr3)
Line 1108
  = possible {symbolic=(expr1),symbolic=(cond2)}
  expr1VerboseMsg possible {symbolic=(expr1),symbolic=(cond2)}
Line 1110
  tok2 always symbolic=(tok->astOperand2()->astOperand1())
  ". '" always ". '"
  cond1 always symbolic=(expr1+" "+tok->str()+" ("+expr2+" "+tok->astOperand2()->str()+" "+expr3+")")
  "' is equivalent to '" always "' is equivalent to '"
  cond2 {symbolic=(expr1),symbolic=(expr1VerboseMsg),symbolic=(cond2VerboseMsg),"A",size=1}
  "'\nThe condition '" always "'\nThe condition '"
Line 1111
  cond1VerboseMsg always symbolic=(expr1VerboseMsg+" "+tok->str()+" "+expr2VerboseMsg+" "+tok->astOperand2()->str()+" "+expr3VerboseMsg)
  "' is equivalent to '" always "' is equivalent to '"
  cond2VerboseMsg {symbolic=(expr1),symbolic=(expr1VerboseMsg),symbolic=(cond2VerboseMsg),symbolic=(cond2)}
  "'." always "'."
Line 1112
  msg always symbolic=(tok2->expressionString()+". '"+cond1+"' is equivalent to '"+cond2+"'\nThe condition '"+cond1VerboseMsg+"' is equivalent to '"+cond2VerboseMsg+"'.")
  false always 0
Line 1118
  = always !0
  ( always !0
Line 1119
  comp1 {symbolic=(tok->astOperand1()),!0}
  == always {!<=-1,!>=2}
  ( possible size=2
Line 1120
  comp1 {symbolic=(tok->astOperand1()),!0}
Line 1123
  = always !0
  ( always !0
Line 1125
  inconclusive {!<=-1,!>=2,0}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1126
  parseable always {!<=-1,!>=2}
  parseable always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1129
  not1 {!<=-1,!>=2,0}
Line 1130
  op1 possible size=2
Line 1131
  = always 0
  nullptr always 0
Line 1132
  parseable always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  comp1 possible symbolic=(tok->astOperand1())
  & {lifetime[Address]=(not1),!0,Uninit*}
  not1 {!<=-1,!>=2,Uninit}
  & {lifetime[Address]=(op1),!0}
  op1 always size=0
  & {lifetime[Address]=(value1),!0}
  value1 always size=0
  & {lifetime[Address]=(expr1),!0}
  expr1 always 0
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
Line 1135
  not2 {!<=-1,!>=2,0}
Line 1136
  op2 possible size=2
Line 1137
  = always 0
  nullptr always 0
Line 1138
  parseable always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  comp2 {symbolic=(tok->astOperand2()),!0}
  & {lifetime[Address]=(not2),!0,Uninit*}
  not2 {!<=-1,!>=2,Uninit}
  & {lifetime[Address]=(op2),!0}
  op2 always size=0
  & {lifetime[Address]=(value2),!0}
  value2 always size=0
  & {lifetime[Address]=(expr2),!0}
  expr2 always 0
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always {!<=-1,!>=2}
Line 1140
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
Line 1143
  isUnknown always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  expr1 always !0
  && always {!<=-1,!>=2}
  expr1 always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  || always {!<=-1,!>=2}
Line 1144
  && always {!<=-1,!>=2}
  expr2 always !0
  && always {!<=-1,!>=2}
  expr2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 1145
  isUnknown {symbolic=((expr1&&expr1->valueType()&&expr1->valueType()->type==ValueType::UNKNOWN_TYPE)||(expr2&&expr2->valueType()&&expr2->valueType()->type==ValueType::UNKNOWN_TYPE)),!<=-1,!>=2}
Line 1148
  isfloat always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1153
  isLogicalOr always {!<=-1,!>=2}
  ( possible size=2
  == always {!<=-1,!>=2}
  "||" always "||"
Line 1154
  ! {!<=-1,!>=2,1}
  isfloat {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  isLogicalOr always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 1155
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1156
  alwaysTrue always {!<=-1,!>=2}
  isLogicalOr always {!<=-1,!>=2}
Line 1157
  alwaysTrue always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1162
  ! always {!<=-1,!>=2}
  parseable always {!<=-1,!>=2}
Line 1165
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
Line 1167
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
Line 1173
  isfloat {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 1177
  = possible 0
  isfloat {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  0 always 0
Line 1178
  = possible 0
  isfloat {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  0 always 0
Line 1179
  = possible 0
  isfloat {!<=-1,!>=2,0}
  ? possible 0
  0 always 0
  : always 0
Line 1180
  = possible 0
  isfloat {!<=-1,!>=2,0}
  ? possible 0
  0 always 0
  : always 0
Line 1181
  useUnsignedInt always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  i1 always symbolic=((isfloat)?0:MathLib::toLongNumber(value1))
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  i2 always symbolic=((isfloat)?0:MathLib::toLongNumber(value2))
Line 1182
  u1 always !<=-1
  = {0,!<=-1}
  useUnsignedInt {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  0 always 0
Line 1183
  u2 always !<=-1
  = {0,!<=-1}
  useUnsignedInt {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  0 always 0
Line 1185
  alwaysTrue always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  = always 1
  true always 1
  alwaysFalse always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1186
  firstTrue always {!<=-1,!>=2}
  firstTrue always {!<=-1,!>=2}
  = always 1
  true always 1
  secondTrue always {!<=-1,!>=2}
  secondTrue always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1187
  = always 1
  1 always 1
  test possible 1
  <= {!<=-1,!>=2,1}
  5 always 5
Line 1194
  result1 always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1195
  isfloat always {!<=-1,!>=2}
Line 1196
  test always {!>=6,!<=0}
  d1 always symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)
  d2 always symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)
Line 1197
  result1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  d1 always symbolic=((isfloat)?MathLib::toDoubleNumber(value1):0)
Line 1198
  result2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  d2 always symbolic=((isfloat)?MathLib::toDoubleNumber(value2):0)
Line 1199
  useUnsignedInt always {!<=-1,!>=2}
Line 1200
  testvalue always !<=-1
  = always !<=-1
  ( always !<=-1
  test always {!>=6,!<=0}
  u1 always !<=-1
  u2 always !<=-1
Line 1201
  result1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  testvalue always !<=-1
  u1 always !<=-1
Line 1202
  result2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  testvalue always !<=-1
  u2 always !<=-1
Line 1204
  test always {!>=6,!<=0}
  i1 always symbolic=((isfloat)?0:MathLib::toLongNumber(value1))
  i2 always symbolic=((isfloat)?0:MathLib::toLongNumber(value2))
Line 1205
  result1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i1 always symbolic=((isfloat)?0:MathLib::toLongNumber(value1))
Line 1206
  result2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i2 always symbolic=((isfloat)?0:MathLib::toLongNumber(value2))
Line 1208
  not1 always {!<=-1,!>=2}
Line 1209
  result1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
Line 1210
  not2 always {!<=-1,!>=2}
Line 1211
  result2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1212
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 1213
  alwaysTrue always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1214
  alwaysFalse always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1216
  alwaysTrue always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1217
  alwaysFalse always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1219
  firstTrue always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1220
  secondTrue always {!<=-1,!>=2}
  &= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  result2 always {!<=-1,!>=2}
Line 1223
  not1 always {!<=-1,!>=2}
Line 1224
  not2 always {!<=-1,!>=2}
Line 1225
  printWarning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
Line 1226
  " " always " "
  " " always " "
Line 1227
  text always symbolic=(cond1str+" "+tok->str()+" "+cond2str)
  alwaysTrue always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1228
  printStyle {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  secondTrue always {!<=-1,!>=2}
Line 1229
  "If '" always "If '"
  "', the comparison '" always "', the comparison '"
Line 1230
  "' is always true." always "' is always true."
Line 1231
  text always symbolic=("If '"+cond1str+"', the comparison '"+cond2str+"' is always true.")
  inconclusive always {!<=-1,!>=2}
Line 1232
  printStyle {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  firstTrue always {!<=-1,!>=2}
Line 1236
  "If '" always "If '"
  "', the comparison '" always "', the comparison '"
Line 1237
  "' is always true." always "' is always true."
Line 1238
  text always symbolic=("If '"+cond2str+"', the comparison '"+cond1str+"' is always true.")
  inconclusive always {!<=-1,!>=2}
Line 1244
  , always {!<=-1,!>=2}
  always always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1246
  ( always {!<=-1,!>=2}
  tok possible 0@32
Line 1248
  errors possible size=0@32
  tok possible 0@32
  "" always ""
Line 1249
  always {!<=-1,!>=2,1@32}
Line 1250
  :: always 2
  warning always 2
  "incorrectLogicOperator" always "incorrectLogicOperator"
Line 1251
  "Logical disjunction always evaluates to true: " always "Logical disjunction always evaluates to true: "
  condition inconclusive "foo > 3 && foo < 4"@32
  ".\nLogical disjunction always evaluates to true: " always ".\nLogical disjunction always evaluates to true: "
Line 1252
  condition inconclusive "foo > 3 && foo < 4"@32
  ". Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables?" always ". Are these conditions necessary? Did you intend to use && instead? Are the numbers correct? Are you comparing the correct variables?"
Line 1253
  inconclusive {!<=-1,!>=2,0@32}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1255
  :: always 2
  warning always 2
  "incorrectLogicOperator" always "incorrectLogicOperator"
Line 1256
  "Logical conjunction always evaluates to false: " always "Logical conjunction always evaluates to false: "
  ".\nLogical conjunction always evaluates to false: " always ".\nLogical conjunction always evaluates to false: "
Line 1257
  ". Are these conditions necessary? Did you intend to use || instead? Are the numbers correct? Are you comparing the correct variables?" always ". Are these conditions necessary? Did you intend to use || instead? Are the numbers correct? Are you comparing the correct variables?"
Line 1258
  inconclusive always {!<=-1,!>=2}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1261
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1263
  ( always {!<=-1,!>=2}
  tok possible 0@33
Line 1265
  tok possible 0@33
  :: always 3
  style always 3
  "redundantCondition" always "redundantCondition"
  "Redundant condition: " always "Redundant condition: "
  text {symbolic=(tok2->expressionString()+". '"+cond1+"' is equivalent to '"+cond2+"'\nThe condition '"+cond1VerboseMsg+"' is equivalent to '"+cond2VerboseMsg+"'.")@75,symbolic=(tok2->expressionString()+". '"+cond1+"' is equivalent to '"+cond2+"'\nThe condition '"+cond1VerboseMsg+"' is equivalent to '"+cond2VerboseMsg+"'.")@89,symbolic=("If '"+cond1str+"', the comparison '"+cond2str+"' is always true.")@124,symbolic=("If '"+cond2str+"', the comparison '"+cond1str+"' is always true.")@125,"If x > 11 the condition x > 10 is always true."@33}
  inconclusive {!<=-1,!>=2,0@75}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1273
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1277
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1278
  != always {!<=-1,!>=2}
Line 1279
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1282
  ( always {!<=-1,!>=2}
  "%" always "%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
Line 1285
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%" always "%"
Line 1292
  ( always {!<=-1,!>=2}
  modulo possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
  "%num%" always "%num%"
  && always {!<=-1,!>=2}
Line 1293
  ( always {!<=-1,!>=2}
Line 1301
  tok possible 0@34
  :: always 2
  warning always 2
  "moduloAlwaysTrueFalse" always "moduloAlwaysTrueFalse"
Line 1302
  "Comparison of modulo result is predetermined, because it is always less than " always "Comparison of modulo result is predetermined, because it is always less than "
  maxVal possible "1"@34
  "." always "."
  :: always 0
  normal always 0
Line 1307
  = always 0
  0 always 0
Line 1308
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1309
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1311
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1313
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1314
  -1 always -1
Line 1325
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1328
  isC always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1331
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1332
  != always {!<=-1,!>=2}
Line 1333
  ( always {!<=-1,!>=2}
  "( %name% [=&|^]" always "( %name% [=&|^]"
Line 1334
  3 always 3
Line 1335
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1337
  ( always {!<=-1,!>=2}
Line 1339
  ! always {!<=-1,!>=2}
  isC always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1341
  ( always {!<=-1,!>=2}
  "?" always "?"
Line 1343
  2 always 2
  == always {!<=-1,!>=2}
  "=" always "="
  false always 0
Line 1345
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "." always "."
Line 1348
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1349
  ( possible symbolic=(tok->astOperand2()->variable()->nameToken())
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  == always {!<=-1,!>=2}
  ( always !0
Line 1353
  ( always !0
  : always 0
  nullptr always 0
Line 1354
  ( always !0
  : always 0
  nullptr always 0
Line 1355
  vt1 always symbolic=(tok->astOperand1()?tok->astOperand1()->valueType():nullptr)
  && always {!<=-1,!>=2}
  vt1 {symbolic=(tok->astOperand1()?tok->astOperand1()->valueType():nullptr),!0}
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|(|[|::|." always "%name%|(|[|::|."
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1356
  false always 0
  true always 1
Line 1357
  vt2 always symbolic=(tok->astOperand2()?tok->astOperand2()->valueType():nullptr)
  && always {!<=-1,!>=2}
  vt2 {symbolic=(tok->astOperand2()?tok->astOperand2()->valueType():nullptr),!0}
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|(|[|::|." always "%name%|(|[|::|."
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1358
  false always 0
  true always 1
Line 1364
  , always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  boolop always {!<=-1,!>=2}
Line 1368
  assign {!<=-1,!>=2,0@244,1@244}
Line 1369
  = always "Suspicious condition (assignment + comparison); Clarify expression with parentheses."
  "Suspicious condition (assignment + comparison); Clarify expression with parentheses." always "Suspicious condition (assignment + comparison); Clarify expression with parentheses."
Line 1371
  boolop {!<=-1,!>=2,0@244,1@10}
Line 1372
  = always "Boolean result is used in bitwise operation. Clarify expression with parentheses.\nSuspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses."
  "Boolean result is used in bitwise operation. Clarify expression with parentheses.\nSuspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses." always "Boolean result is used in bitwise operation. Clarify expression with parentheses.\nSuspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses."
Line 1377
  = always "Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\nSuspicious condition. Comparison operators have higher precedence than bitwise operators. Please clarify the condition with parentheses."
  "Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\nSuspicious condition. Comparison operators have higher precedence than bitwise operators. Please clarify the condition with parentheses." always "Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\nSuspicious condition. Comparison operators have higher precedence than bitwise operators. Please clarify the condition with parentheses."
Line 1381
  tok possible 0@35
Line 1382
  :: always 3
  style always 3
Line 1383
  "clarifyCondition" always "clarifyCondition"
Line 1384
  errmsg possible {"Suspicious condition (assignment + comparison); Clarify expression with parentheses.",size=84,"Boolean result is used in bitwise operation. Clarify expression with parentheses.\nSuspicious expression. Boolean result is used in bitwise operation. The operator '!' and the comparison operators have higher precedence than bitwise operators. It is recommended that the expression is clarified with parentheses.",size=311,"Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses.\nSuspicious condition. Comparison operators have higher precedence than bitwise operators. Please clarify the condition with parentheses.",size=227}
  :: always 0
  normal always 0
Line 1389
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1393
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1394
  != always {!<=-1,!>=2}
Line 1395
  ( always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1397
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1399
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 1400
  = always !0
  ( always !0
Line 1401
  f {symbolic=(tok->previous()->function()),!0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  f {symbolic=(tok->previous()->function()),!0}
  . always !0
  "{ return true|false ;" always "{ return true|false ;"
Line 1407
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok->astParent()),0}
  "%oror%|&&" always "%oror%|&&"
Line 1409
  ! always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
Line 1411
  = always 0
  nullptr always 0
Line 1412
  parent always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
Line 1413
  parent always !0
Line 1414
  ( always {!<=-1,!>=2}
  parent always !0
  "if|while (" always "if|while ("
Line 1415
  parent always !0
Line 1416
  ( always {!<=-1,!>=2}
  parent always !0
  "return" always "return"
Line 1417
  parent always !0
Line 1418
  parent always !0
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  parent always !0
  ( always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  ( always !0
  ( always !0
  "for (" always "for ("
Line 1419
  parent always !0
Line 1422
  condition possible {symbolic=(parent->astOperand1()),symbolic=(parent->astOperand2())}
Line 1425
  ( always {!<=-1,!>=2}
  false always 0
Line 1427
  ( always {!<=-1,!>=2}
  "%num%|%bool%|%char%" always "%num%|%bool%|%char%"
Line 1429
  ( always {!<=-1,!>=2}
  "! %num%|%bool%|%char%" always "! %num%|%bool%|%char%"
Line 1431
  ( always {!<=-1,!>=2}
  "%oror%|&&|:" always "%oror%|&&|:"
Line 1433
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
Line 1435
  ( always {!<=-1,!>=2}
  "[|(|&|+|-|*|/|%|^|>>|<<" always "[|(|&|+|-|*|/|%|^|>>|<<"
Line 1441
  = always 0
  nullptr always 0
Line 1442
  = always 0
  nullptr always 0
Line 1443
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(zeroValue),!0}
  zeroValue always 0
  & {lifetime[Address]=(nonZeroExpr),!0}
  nonZeroExpr always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(zeroValue),!0}
  & {lifetime[Address]=(nonZeroExpr),!0}
Line 1447
  constIfWhileExpression always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 1448
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while" always "if|while"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1449
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while" always "if|while"
Line 1450
  constValExpr always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%oror%|&&|?" always "%oror%|&&|?"
Line 1451
  compExpr always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%|!" always "%comp%|!"
Line 1452
  ternaryExpression always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?" always "?"
Line 1453
  returnExpression always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return" always "return"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&&|%oror%" always "&&|%oror%"
Line 1455
  ! always {!<=-1,!>=2}
  constIfWhileExpression always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  constValExpr always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  compExpr always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ternaryExpression always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  returnExpression always {!<=-1,!>=2}
Line 1459
  isUnknown always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  expr1 always symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  expr1 {symbolic=(tok->astOperand1()),!0}
  && always {!<=-1,!>=2}
  expr1 {symbolic=(tok->astOperand1()),!0}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  || always {!<=-1,!>=2}
Line 1460
  expr2 always symbolic=(tok->astOperand2())
  && always {!<=-1,!>=2}
  expr2 {symbolic=(tok->astOperand2()),!0}
  && always {!<=-1,!>=2}
  expr2 {symbolic=(tok->astOperand2()),!0}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 1461
  isUnknown {symbolic=((expr1&&expr1->valueType()&&expr1->valueType()->type==ValueType::UNKNOWN_TYPE)||(expr2&&expr2->valueType()&&expr2->valueType()->type==ValueType::UNKNOWN_TYPE)),!<=-1,!>=2}
Line 1465
  isExpandedMacro {!<=-1,!>=2,0}
  isExpandedMacro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1466
  [ possible lifetime[Lambda]=(isExpandedMacro)
Line 1467
  ! always {!<=-1,!>=2}
Line 1468
  :: always 0
  none always 0
Line 1469
  tok2 always !0
  ( always {!<=-1,!>=2}
Line 1470
  isExpandedMacro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1471
  :: always 4
  done always 4
Line 1473
  :: always 3
  op1_and_op2 always 3
Line 1475
  isExpandedMacro always {!<=-1,!>=2}
Line 1478
  ( always {!<=-1,!>=2}
Line 1479
  isExpandedMacro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1483
  isExpandedMacro {!<=-1,!>=2,1}
Line 1487
  hasSizeof {!<=-1,!>=2,0}
  hasSizeof always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1488
  [ possible lifetime[Lambda]=(hasSizeof)
Line 1489
  ! always {!<=-1,!>=2}
Line 1490
  :: always 0
  none always 0
Line 1491
  tok2 always !0
  ( always {!<=-1,!>=2}
Line 1492
  :: always 0
  none always 0
Line 1493
  ( always {!<=-1,!>=2}
  tok2 always !0
  "sizeof (" always "sizeof ("
Line 1494
  hasSizeof always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1495
  :: always 0
  none always 0
Line 1497
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1498
  :: always 3
  op1_and_op2 always 3
Line 1500
  :: always 0
  none always 0
Line 1502
  hasSizeof always {!<=-1,!>=2}
Line 1505
  ( always {!<=-1,!>=2}
Line 1508
  & always !0
Line 1515
  alwaysTrue always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  value possible 0@36
  && always {!<=-1,!>=2}
  value always !0
  != always {!<=-1,!>=2}
  0 always 0
Line 1516
  tok possible 0@36
  tok always !0
  "x" always "x"
Line 1517
  "Condition '" always "Condition '"
  "' is always " always "' is always "
  alwaysTrue {symbolic=(value&&(value->intvalue!=0)),!<=-1,!>=2,0}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 1518
  tok possible 0@36
  value possible 0@36
  errmsg always symbolic=("Condition '"+expr+"' is always "+(alwaysTrue?"true":"false"))
Line 1520
  :: always 3
  style always 3
Line 1521
  "knownConditionTrueFalse" always "knownConditionTrueFalse"
Line 1522
  errmsg always symbolic=("Condition '"+expr+"' is always "+(alwaysTrue?"true":"false"))
Line 1523
  alwaysTrue {symbolic=(value&&(value->intvalue!=0)),!<=-1,!>=2}
  :: always 0
  normal always 0
Line 1541
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1545
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|<=|>=|>" always "<|<=|>=|>"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1548
  2 always 2
Line 1551
  == always {!<=-1,!>=2}
Line 1552
  cmp always symbolic=(tok->str())
  0 always 0
  = possible {62,60}
  cmp always symbolic=(tok->str())
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
  ? possible {62,60}
  '>' always 62
  : always 60
  '<' always 60
Line 1554
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  lhs possible symbolic=(tok->astOperand2())
  "[+-]" always "[+-]"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1557
  isSignedInteger always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 1558
  isPointer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 1559
  ! always {!<=-1,!>=2}
  isSignedInteger {symbolic=(lhs->valueType()&&lhs->valueType()->isIntegral()&&lhs->valueType()->sign==ValueType::Sign::SIGNED),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isPointer {symbolic=(lhs->valueType()&&lhs->valueType()->pointer>0),!<=-1,!>=2}
Line 1562
  2 always 2
Line 1564
  ( possible size=1
  == always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1567
  ( always {!<=-1,!>=2}
Line 1570
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1571
  true always 1
Line 1575
  true always 1
Line 1576
  false always 0
Line 1582
  other always symbolic=(expr->astSibling())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 1583
  ! always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  && always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 1584
  result always {!<=-1,!>=2}
Line 1585
  == always {!<=-1,!>=2}
  "+" always "+"
Line 1586
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">=" always ">="
Line 1588
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<=" always "<="
Line 1589
  result {symbolic=(cmp==">"||cmp==">="),symbolic=(cmp=="<"||cmp=="<="),!<=-1,!>=2,0}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 1594
  ( possible size=1
  == always {!<=-1,!>=2}
  "+" always "+"
  && always {!<=-1,!>=2}
  other always symbolic=(expr->astSibling())
  > always {!<=-1,!>=2}
  0 always 0
Line 1595
  other always symbolic=(expr->astSibling())
  "0" always "0"
Line 1596
  result always symbolic=(other->str()+cmp+"0")
Line 1601
  == always {!<=-1,!>=2}
  "-" always "-"
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 1603
  cmp2 always symbolic=(cmp)
  0 always 0
  = possible {62,60}
  cmp always symbolic=(cmp2)
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
  ? possible {62,60}
  '>' always 62
  : always 60
  '<' always 60
Line 1604
  "0" always "0"
Line 1605
  result always symbolic=(other->str()+cmp2+"0")
Line 1615
  tok possible 0@37
  tok always !0
  "x + c < x" always "x + c < x"
Line 1616
  valueType possible 0@37
  && always {!<=-1,!>=2}
  valueType always !0
  "pointer overflow" always "pointer overflow"
  : always "signed integer overflow"
  "signed integer overflow" always "signed integer overflow"
Line 1619
  "Invalid test for overflow '" always "Invalid test for overflow '"
  "'; " always "'; "
  " is undefined behavior." always " is undefined behavior."
Line 1620
  replace possible {symbolic=(other->str()+cmp+"0")@156,symbolic=(other->str()+cmp2+"0")@161,"false"@37,size=4}
  == {!<=-1,!>=2,0}
  "false" always "false"
  || always {!<=-1,!>=2}
  replace possible {symbolic=(other->str()+cmp+"0")@156,symbolic=(other->str()+cmp2+"0")@161,"false"@37}
  == always {!<=-1,!>=2}
  "true" always "true"
Line 1621
  " Some mainstream compilers remove such overflow tests when optimising the code and assume it's always " always " Some mainstream compilers remove such overflow tests when optimising the code and assume it's always "
  + possible {size=107,size=106}
  replace possible {size=5,size=4}
  + possible {size=108,size=107}
  "." always "."
Line 1623
  " Some mainstream compilers removes handling of overflows when optimising the code and change the code to '" always " Some mainstream compilers removes handling of overflows when optimising the code and change the code to '"
  "'." always "'."
Line 1624
  tok possible 0@37
  :: always 2
  warning always 2
  "invalidTestForOverflow" always "invalidTestForOverflow"
  :: always 0
  normal always 0
Line 1630
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1634
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1636
  != always {!<=-1,!>=2}
Line 1637
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1641
  ( always {!<=-1,!>=2}
Line 1645
  ( always !0
  == always {!<=-1,!>=2}
  "+" always "+"
Line 1646
  = always !0
  ( always !0
Line 1647
  = always !0
  ( always !0
Line 1648
  ( always !0
  == always {!<=-1,!>=2}
  "+" always "+"
Line 1649
  = always !0
  ( always !0
Line 1650
  = always !0
  ( always !0
Line 1655
  calcToken possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
  ( always {!<=-1,!>=2}
Line 1657
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1659
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 1669
  = possible "ptr+1"
  calc possible 0@38
  ? possible "ptr+1"
  calc always !0
  : always "ptr+1"
  "ptr+1" always "ptr+1"
Line 1670
  tok possible 0@38
  :: always 2
  warning always 2
  "pointerAdditionResultNotNull" always "pointerAdditionResultNotNull"
  "Comparison is wrong. Result of '" always "Comparison is wrong. Result of '"
  s always symbolic=(calc?calc->expressionString():"ptr+1")
  "' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour." always "' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour."
Line 1675
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1679
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1680
  != always {!<=-1,!>=2}
Line 1681
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 1683
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 1687
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always symbolic=(tok->next()->astOperand2())
  "==|!=" always "==|!="
Line 1689
  condTok always symbolic=(tok->next()->astOperand2())
  == always {!<=-1,!>=2}
  "!=" always "!="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  blockTok always symbolic=(tok->next()->link()->next())
  "} else {" always "} else {"
Line 1691
  ! always {!<=-1,!>=2}
Line 1693
  ( always !0
Line 1694
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  assignTok always symbolic=(blockTok->next()->astTop())
  "=" always "="
Line 1696
  assignTok always symbolic=(blockTok->next()->astTop())
  != always {!<=-1,!>=2}
Line 1698
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1699
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
Line 1701
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1702
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
Line 1712
  = always "Duplicate expression for the condition and assignment."
  "Duplicate expression for the condition and assignment." always "Duplicate expression for the condition and assignment."
Line 1713
  condTok possible 0@39
  && always {!<=-1,!>=2}
Line 1714
  condTok always !0
  == always {!<=-1,!>=2}
  "==" always "=="
Line 1715
  "Assignment '" always "Assignment '"
  assignTok always !0
  "' is redundant with condition '" always "' is redundant with condition '"
  condTok always !0
  "'." always "'."
Line 1716
  errors always size=0
  condTok always !0
  "Condition '" always "Condition '"
  "'" always "'"
Line 1717
  errors always !size=0
  assignTok always !0
  "Assignment '" always "Assignment '"
  "' is redundant" always "' is redundant"
Line 1719
  "The statement 'if (" always "The statement 'if ("
  condTok always !0
  ") " always ") "
  assignTok always !0
  "' is logically equivalent to '" always "' is logically equivalent to '"
  assignTok always !0
  "'." always "'."
Line 1720
  errors always size=0
  assignTok always !0
  "Assignment '" always "Assignment '"
  "'" always "'"
Line 1721
  errors always !size=0
  condTok always !0
  "Condition '" always "Condition '"
  "' is redundant" always "' is redundant"
Line 1726
  errors possible size=0
  :: always 3
  style always 3
  "duplicateConditionalAssign" always "duplicateConditionalAssign"
  msg possible {"Duplicate expression for the condition and assignment.",size=54}
  :: always 0
  normal always 0
Line 1732
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1736
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1737
  tok possible symbolic=(tok->astParent()->astOperand1())
  != always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
Line 1738
  tok possible symbolic=(tok->astParent()->astOperand1())
  != always {!<=-1,!>=2}
  "=" always "="
Line 1740
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
Line 1744
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
Line 1746
  tok possible symbolic=(tok->astParent()->astOperand1())
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 1748
  tok possible symbolic=(tok->astParent()->astOperand1())
  ( always !0
  . possible 6
  != {!<=-1,!>=2,1}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
  ( always !0
  . always !5
  != always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 1752
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  "if|while (" always "if|while ("
Line 1754
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  "%oror%|&&" always "%oror%|&&"
Line 1756
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  "?" always "?"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1757
  tok always symbolic=(tok->astParent()->astOperand1())
Line 1764
  = possible "x=y"
  eq possible {symbolic=(tok->astParent()->astOperand1())@71,0@40}
  ? possible "x=y"
  eq always !0
  : always "x=y"
  "x=y" always "x=y"
Line 1767
  eq possible 0@40
Line 1768
  :: always 3
  style always 3
Line 1769
  "assignmentInCondition" always "assignmentInCondition"
Line 1770
  "Suspicious assignment in condition. Condition '" always "Suspicious assignment in condition. Condition '"
  expr always symbolic=(eq?eq->expressionString():"x=y")
  "' is always true." always "' is always true."
Line 1772
  :: always 0
  normal always 0
Line 1777
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1780
  . possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Native always 1
  || always {!<=-1,!>=2}
Line 1781
  . always !1
  == always {!<=-1,!>=2}
  :: always 0
  Unspecified always 0
Line 1785
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1786
  != always {!<=-1,!>=2}
Line 1787
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1790
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  2 always 2
Line 1791
  i {0,<=1,!>=2,!<=-1}
  == {!<=-1,!>=2,<=1}
  0 always 0
Line 1792
  valueTok always symbolic=((i==0)?tok->astOperand1():tok->astOperand2())
Line 1793
  ! always {!<=-1,!>=2}
  valueTok always symbolic=((i==0)?tok->astOperand1():tok->astOperand2())
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  typeTok always symbolic=(valueTok->astSibling())
  || always {!<=-1,!>=2}
  typeTok always symbolic=(valueTok->astSibling())
  ( always !0
Line 1795
  valueTok always symbolic=((i==0)?tok->astOperand1():tok->astOperand2())
  < always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  valueTok always symbolic=((i==0)?tok->astOperand1():tok->astOperand2())
  && always {!<=-1,!>=2}
  valueTok always symbolic=((i==0)?tok->astOperand1():tok->astOperand2())
  ( always !0
  != always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 1797
  bits possible 0
  = always 0
  0 always 0
Line 1798
  ( always !0
Line 1799
  :: always 8
  BOOL always 8
Line 1800
  = always 1
  1 always 1
Line 1802
  :: always 9
  CHAR always 9
Line 1805
  :: always 10
  SHORT always 10
Line 1808
  :: always 12
  INT always 12
Line 1811
  :: always 13
  LONG always 13
Line 1814
  :: always 14
  LONGLONG always 14
Line 1820
  bits possible {symbolic=(mSettings->char_bit),symbolic=(mSettings->short_bit),<=symbolic=(mSettings->int_bit),symbolic=(mSettings->long_bit),symbolic=(mSettings->long_long_bit),1,>=64,<=63}
  == {!<=-1,!>=2,0}
  0 always 0
  || {!<=-1,!>=2,0}
  bits {symbolic=(mSettings->char_bit),symbolic=(mSettings->short_bit),symbolic=(mSettings->int_bit),symbolic=(mSettings->long_bit),symbolic=(mSettings->long_long_bit),1,!0}
  >= {!<=-1,!>=2,0}
  64 always 64
Line 1823
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
  0 always 0
  : always 0
  - possible -1
  1LL always 1
  << possible 1
  bits {>=symbolic=(mSettings->int_bit),<=symbolic=(mSettings->int_bit-1),1,!0,!>=64}
  - {0,!-1,!>=63}
  1 always 1
Line 1824
  = possible 1
  1LL always 1
  << possible 2
  bits {>=symbolic=(mSettings->int_bit),<=symbolic=(mSettings->int_bit-1),1,!0,!>=64}
  - possible 1
  1LL always 1
Line 1826
  != always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 1827
  = always symbolic=((1LL<<bits)-1LL)
  unsignedTypeMaxValue always symbolic=((1LL<<bits)-1LL)
Line 1828
  bits always {!0,!>=64}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 1829
  = always symbolic=((1LL<<bits)-1LL)
  unsignedTypeMaxValue always symbolic=((1LL<<bits)-1LL)
Line 1831
  unsignedTypeMaxValue always symbolic=((1LL<<bits)-1LL)
  2 always 2
Line 1833
  result always {!<=-1,!>=2}
  { always 0
Line 1835
  ( possible size=2
  == always {!<=-1,!>=2}
  "==" always "=="
Line 1836
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1837
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 1838
  result always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1839
  [ possible {62,60}
  0 always 0
  == {!<=-1,!>=2,1,0}
  '>' always 62
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1841
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  kiv always symbolic=(valueTok->getKnownIntValue())
  > always {!<=-1,!>=2}
  0 always 0
Line 1842
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,0}
  '>' always 62
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 1844
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  kiv always symbolic=(valueTok->getKnownIntValue())
  < always {!<=-1,!>=2}
  0 always 0
Line 1845
  [ possible 60
  0 always 0
  == {!<=-1,!>=2,1}
  '<' always 60
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1847
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  kiv always symbolic=(valueTok->getKnownIntValue())
  < always {!<=-1,!>=2}
  0 always 0
Line 1848
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  1 always 1
Line 1850
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  kiv always symbolic=(valueTok->getKnownIntValue())
  > always {!<=-1,!>=2}
  0 always 0
Line 1852
  error {!<=-1,!>=2,0}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1853
  kiv {symbolic=(valueTok->getKnownIntValue()),symbolic=(typeMinValue),symbolic=(typeMaxValue)}
  < {!<=-1,!>=2,0}
  typeMinValue {symbolic=((typeTok->valueType()->sign==ValueType::Sign::UNSIGNED)?0:(-(1LL<<(bits-1)))),symbolic=(kiv)}
  || always {!<=-1,!>=2}
  kiv {symbolic=(valueTok->getKnownIntValue()),!<=symbolic=(typeMinValue-1),>=symbolic=(typeMinValue)}
  > always {!<=-1,!>=2}
Line 1854
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1857
  0 always 0
Line 1858
  kiv possible symbolic=(typeMaxValue)
  == always {!<=-1,!>=2}
Line 1859
  ( possible size=1
  == {!<=-1,!>=2,0}
  "<=" always "<="
Line 1860
  result always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1861
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1862
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1863
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1865
  kiv always !symbolic=(typeMinValue)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">=" always ">="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1866
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1869
  1 always 1
Line 1870
  kiv possible symbolic=(typeMaxValue)
  == always {!<=-1,!>=2}
Line 1871
  ( possible size=1
  == {!<=-1,!>=2,0}
  ">=" always ">="
Line 1872
  result always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1873
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1874
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1875
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1877
  kiv always !symbolic=(typeMinValue)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<=" always "<="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1878
  error always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1883
  error {!<=-1,!>=2,1}
Line 1884
  kiv always symbolic=(valueTok->getKnownIntValue())
  result always {!<=-1,!>=2}
Line 1890
  , always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 1893
  comparison possible 0@41
Line 1894
  :: always 3
  style always 3
Line 1895
  "compareValueOutOfTypeRangeError" always "compareValueOutOfTypeRangeError"
Line 1896
  "Comparing expression of type '" always "Comparing expression of type '"
  type possible "unsigned char"@41
  "' against value " always "' against value "
  value possible {symbolic=(valueTok->getKnownIntValue())@50,256@41}
  ". Condition is always " always ". Condition is always "
  result {!<=-1,!>=2,1@41}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
  "." always "."
Line 1898
  :: always 0
  normal always 0
Line 928
  1 always 1
Line 930
  2 always 2
Line 932
  3 always 3
Line 934
  4 always 4
Line 936
  5 always 5
Line 939
  0 always 0
Line 919
  ( always !<=-1
  value1 always !<=-1
  value2 always !<=-1
Line 928
  1 always 1
Line 929
  return always !<=-1
Line 930
  2 always 2
Line 931
  return always !<=-1
  value1 always !<=-1
Line 932
  3 always 3
Line 933
  return always !<=-1
  ( always !<=-1
  value1 always !<=-1
  value2 always !<=-1
Line 934
  4 always 4
Line 935
  return always !<=-1
  value2 always !<=-1
Line 936
  5 always 5
Line 937
  return always !<=-1
Line 939
  return always !<=-1
  0 always 0
Line 928
  1 always 1
Line 930
  2 always 2
Line 932
  3 always 3
Line 934
  4 always 4
Line 936
  5 always 5
Line 939
  0 always 0
Line 902
  ( always !<=-1
  value1 always !<=-1
  value2 always !<=-1
Line 904
  min always !<=-1
  = always !<=-1
  value1 always !<=-1
  value2 always !<=-1
Line 905
  min {symbolic=(std::min(value1,value2)),!<=-1}
  == always {!<=-1,!>=2}
Line 906
  return always !<=-1
  min {symbolic=(std::min(value1,value2)),!<=-1}
Line 908
  return always !<=-1
  min {symbolic=(std::min(value1,value2)),!<=-1}
  + always !<=0
  1 always 1
Line 905
  min always symbolic=(std::min(value1,value2))
  == always {!<=-1,!>=2}
Line 906
  min always symbolic=(std::min(value1,value2))
Line 908
  min always symbolic=(std::min(value1,value2))
  1 always 1
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,3@17,2@102}
  flag possible {3@17,2@102}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
