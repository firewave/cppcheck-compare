

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073744173 !@expr1073744174 mTokenizer@var28 ) {
69: instances (@expr1073744175 ) .@expr1073744176 remove (@expr1073744177 this@expr1073744178 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073744179 string (@expr1073744180 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073744181 void ) tokenizer@var21 ;
108: (@expr1073744182 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073744183 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073744184 void ) ctu@var24 ;
120: (@expr1073744185 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073744186 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073744187 0U ) , Certainty ::@expr1073744188 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073744189 list < const Token *@expr1073744190 > callstack@var41 (@expr1073744191 1 , tok@var35 ) ;
141: reportError (@expr1073744192 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073744193 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073744194 0U ) , Certainty ::@expr1073744195 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/checkio.h

1:
|
30:
31: class Function ;
32: class Settings ;
33: class Token ;
34: class Tokenizer ;
35: class Variable ;
36: class ErrorLogger ;
37:
|
41:
42: class CheckIO : public Check {
43: public:
44:
45: CheckIO ( ) : Check ( myName ( ) ) { }
46:
47:
48: CheckIO ( const Tokenizer * tokenizer@var64 , const Settings * settings@var65 , ErrorLogger * errorLogger@var66 )
49: : Check ( myName ( ) , tokenizer@var64 , settings@var65 , errorLogger@var66 ) { }
50:
51:
52: void runChecks ( const Tokenizer * tokenizer@var67 , const Settings * settings@var68 , ErrorLogger * errorLogger@var69 ) override {
53: CheckIO checkIO@var70 (@expr1073744196 tokenizer@var67 , settings@var68 , errorLogger@var69 ) ;
54:
55: checkIO@var70 .@expr1073744197 checkWrongPrintfScanfArguments (@expr1073744198 ) ;
56: checkIO@var70 .@expr1073744199 checkCoutCerrMisusage (@expr1073744200 ) ;
57: checkIO@var70 .@expr1073744201 checkFileUsage (@expr1073744202 ) ;
58: checkIO@var70 .@expr1073744203 invalidScanf (@expr1073744204 ) ;
59: }
60:
61:
62: void checkCoutCerrMisusage ( ) ;
63:
64:
65: void checkFileUsage ( ) ;
66:
67:
68: void invalidScanf ( ) ;
69:
70:
71: void checkWrongPrintfScanfArguments ( ) ;
72:
73: private:
74: class ArgumentInfo {
75: public:
76: ArgumentInfo ( const Token * arg@var71 , const Settings * settings@var72 , bool _isCPP@var73 ) ;
77: ~ ArgumentInfo ( ) ;
78:
79: bool isArrayOrPointer ( ) const ;
80: bool isComplexType ( ) const ;
81: bool isKnownType ( ) const ;
82: bool isStdVectorOrString ( ) ;
83: bool isStdContainer ( const Token * tok@var74 ) ;
84: bool isLibraryType ( const Settings * settings@var75 ) const ;
85:
86: const Variable * variableInfo@var76 ;
87: const Token * typeToken@var77 ;
88: const Function * functionInfo@var78 ;
89: Token * tempToken@var79 ;
90: bool element@var80 ;
91: bool _template@var81 ;
92: bool address@var82 ;
93: bool isCPP@var83 ;
94:
95: private:
96: ArgumentInfo ( const ArgumentInfo & ) ;
97: ArgumentInfo operator= ( const ArgumentInfo & ) ;
98: } ;
99:
100: void checkFormatString ( const Token * const tok@var84 ,
101: const Token * const formatStringTok@var85 ,
102: const Token * argListTok@var86 ,
103: const bool scan@var87 ,
104: const bool scanf_s@var88 ) ;
105:
106:
107: void coutCerrMisusageError ( const Token * tok@var89 , const std :: string & streamName@var90 ) ;
108: void fflushOnInputStreamError ( const Token * tok@var91 , const std :: string & varname@var92 ) ;
109: void ioWithoutPositioningError ( const Token * tok@var93 ) ;
110: void readWriteOnlyFileError ( const Token * tok@var94 ) ;
111: void writeReadOnlyFileError ( const Token * tok@var95 ) ;
112: void useClosedFileError ( const Token * tok@var96 ) ;
113: void seekOnAppendedFileError ( const Token * tok@var97 ) ;
114: void incompatibleFileOpenError ( const Token * tok@var98 , const std :: string & filename@var99 ) ;
115: void invalidScanfError ( const Token * tok@var100 ) ;
116: void wrongPrintfScanfArgumentsError ( const Token * tok@var101 ,
117: const std :: string & functionName@var102 ,
118: int numFormat@var103 ,
119: int numFunction@var104 ) ;
120: void wrongPrintfScanfPosixParameterPositionError ( const Token * tok@var105 , const std :: string & functionName@var106 ,
121: int index@var107 , int numFunction@var108 ) ;
122: void invalidScanfArgTypeError_s ( const Token * tok@var109 , int numFormat@var110 , const std :: string & specifier@var111 , const ArgumentInfo * argInfo@var112 ) ;
123: void invalidScanfArgTypeError_int ( const Token * tok@var113 , int numFormat@var114 , const std :: string & specifier@var115 , const ArgumentInfo * argInfo@var116 , bool isUnsigned@var117 ) ;
124: void invalidScanfArgTypeError_float ( const Token * tok@var118 , int numFormat@var119 , const std :: string & specifier@var120 , const ArgumentInfo * argInfo@var121 ) ;
125: void invalidPrintfArgTypeError_s ( const Token * tok@var122 , int numFormat@var123 , const ArgumentInfo * argInfo@var124 ) ;
126: void invalidPrintfArgTypeError_n ( const Token * tok@var125 , int numFormat@var126 , const ArgumentInfo * argInfo@var127 ) ;
127: void invalidPrintfArgTypeError_p ( const Token * tok@var128 , int numFormat@var129 , const ArgumentInfo * argInfo@var130 ) ;
128: void invalidPrintfArgTypeError_uint ( const Token * tok@var131 , int numFormat@var132 , const std :: string & specifier@var133 , const ArgumentInfo * argInfo@var134 ) ;
129: void invalidPrintfArgTypeError_sint ( const Token * tok@var135 , int numFormat@var136 , const std :: string & specifier@var137 , const ArgumentInfo * argInfo@var138 ) ;
130: void invalidPrintfArgTypeError_float ( const Token * tok@var139 , int numFormat@var140 , const std :: string & specifier@var141 , const ArgumentInfo * argInfo@var142 ) ;
131: void invalidLengthModifierError ( const Token * tok@var143 , int numFormat@var144 , const std :: string & modifier@var145 ) ;
132: void invalidScanfFormatWidthError ( const Token * tok@var146 , int numFormat@var147 , int width@var148 , const Variable * var@var149 , const std :: string & specifier@var150 ) ;
133: static void argumentType ( std :: ostream & os@var151 , const ArgumentInfo * argInfo@var152 ) ;
134: static Severity :: SeverityType getSeverity ( const ArgumentInfo * argInfo@var153 ) ;
135:
136: void getErrorMessages ( ErrorLogger * errorLogger@var154 , const Settings * settings@var155 ) const override {
137: CheckIO c@var156 (@expr1073744205 nullptr , settings@var155 , errorLogger@var154 ) ;
138:
139: c@var156 .@expr1073744206 coutCerrMisusageError (@expr1073744207 nullptr , "cout" ) ;
140: c@var156 .@expr1073744208 fflushOnInputStreamError (@expr1073744209 nullptr , "stdin" ) ;
141: c@var156 .@expr1073744210 ioWithoutPositioningError (@expr1073744211 nullptr ) ;
142: c@var156 .@expr1073744212 readWriteOnlyFileError (@expr1073744213 nullptr ) ;
143: c@var156 .@expr1073744214 writeReadOnlyFileError (@expr1073744215 nullptr ) ;
144: c@var156 .@expr1073744216 useClosedFileError (@expr1073744217 nullptr ) ;
145: c@var156 .@expr1073744218 seekOnAppendedFileError (@expr1073744219 nullptr ) ;
146: c@var156 .@expr1073744220 incompatibleFileOpenError (@expr1073744221 nullptr , "tmp" ) ;
147: c@var156 .@expr1073744222 invalidScanfError (@expr1073744223 nullptr ) ;
148: c@var156 .@expr1073744224 wrongPrintfScanfArgumentsError (@expr1073744225 nullptr , "printf" , 3 , 2 ) ;
149: c@var156 .@expr1073744226 invalidScanfArgTypeError_s (@expr1073744227 nullptr , 1 , "s" , nullptr ) ;
150: c@var156 .@expr1073744228 invalidScanfArgTypeError_int (@expr1073744229 nullptr , 1 , "d" , nullptr , false ) ;
151: c@var156 .@expr1073744230 invalidScanfArgTypeError_float (@expr1073744231 nullptr , 1 , "f" , nullptr ) ;
152: c@var156 .@expr1073744232 invalidPrintfArgTypeError_s (@expr1073744233 nullptr , 1 , nullptr ) ;
153: c@var156 .@expr1073744234 invalidPrintfArgTypeError_n (@expr1073744235 nullptr , 1 , nullptr ) ;
154: c@var156 .@expr1073744236 invalidPrintfArgTypeError_p (@expr1073744237 nullptr , 1 , nullptr ) ;
155: c@var156 .@expr1073744238 invalidPrintfArgTypeError_uint (@expr1073744239 nullptr , 1 , "u" , nullptr ) ;
156: c@var156 .@expr1073744240 invalidPrintfArgTypeError_sint (@expr1073744241 nullptr , 1 , "i" , nullptr ) ;
157: c@var156 .@expr1073744242 invalidPrintfArgTypeError_float (@expr1073744243 nullptr , 1 , "f" , nullptr ) ;
158: c@var156 .@expr1073744244 invalidLengthModifierError (@expr1073744245 nullptr , 1 , "I" ) ;
159: c@var156 .@expr2422 invalidScanfFormatWidthError (@expr1073744247 nullptr , 10 , 5 , nullptr , "s" ) ;
160: c@var156 .@expr2422 invalidScanfFormatWidthError (@expr1073744249 nullptr , 99 , -1 , nullptr , "s" ) ;
161: c@var156 .@expr1073744250 wrongPrintfScanfPosixParameterPositionError (@expr1073744251 nullptr , "printf" , 2 , 1 ) ;
162: }
163:
164: static std :: string myName ( ) {
165: return "IO using format string" ;
166: }
167:
168: std :: string classInfo ( ) const override {
169: return "Check format string input/output operations.\n- Bad usage of the function 'sprintf' (overlapping data)\n- Missing or wrong width specifiers in 'scanf' format string\n- Use a file that has been closed\n- File input/output without positioning results in undefined behaviour\n- Read to a file that has only been opened for writing (or vice versa)\n- Repositioning operation on a file opened in append mode\n- The same file can't be open for read and write at the same time on different streams\n- Using fflush() on an input stream\n- Invalid usage of output stream. For example: 'std::cout << std::cout;'\n- Wrong number of arguments given to 'printf' or 'scanf;'\n"
170:
|
178:
179: ;
180: }
181: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var157 ;
42: double mDoubleValue@var158 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var159 ;
44: bool mIsUnsigned@var160 ;
45:
46: void promote ( const value & v@var161 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var162 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var159 !=@expr1073744252 Type ::@expr1073744253 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var159 ==@expr1073744254 Type ::@expr1073744255 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744256 ) ?@expr1073744257 mDoubleValue@var158 :@expr1073744258 (@expr1073744259 double ) mIntValue@var157 ;
60: }
61:
62: static value calc ( char op@var163 , const value & v1@var164 , const value & v2@var165 ) ;
63: int compare ( const value & v@var166 ) const ;
64: value add ( int v@var167 ) const ;
65: value shiftLeft ( const value & v@var168 ) const ;
66: value shiftRight ( const value & v@var169 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var170 ;
72:
73: static long long toLongNumber ( const std :: string & str@var171 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var172 ) ;
75:
76: template < class T > static std :: string toString ( T value@var173 ) {
77: std ::@expr1073744260 ostringstream result@var174 ;
78: result@var174 <<@expr1073744261 value@var173 ;
79: return result@var174 .@expr1073744262 str (@expr1073744263 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var175 ) ;
82:
83: static bool isInt ( const std :: string & str@var176 ) ;
84: static bool isFloat ( const std :: string & str@var177 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var178 ) ;
86: static bool isNegative ( const std :: string & str@var179 ) ;
87: static bool isPositive ( const std :: string & str@var180 ) ;
88: static bool isDec ( const std :: string & str@var181 ) ;
89: static bool isFloatHex ( const std :: string & str@var182 ) ;
90: static bool isIntHex ( const std :: string & str@var183 ) ;
91: static bool isOct ( const std :: string & str@var184 ) ;
92: static bool isBin ( const std :: string & str@var185 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var186 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var187 , bool supportMicrosoftExtensions@var188 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var189 , const std :: string & second@var190 ) ;
105: static std :: string subtract ( const std :: string & first@var191 , const std :: string & second@var192 ) ;
106: static std :: string multiply ( const std :: string & first@var193 , const std :: string & second@var194 ) ;
107: static std :: string divide ( const std :: string & first@var195 , const std :: string & second@var196 ) ;
108: static std :: string mod ( const std :: string & first@var197 , const std :: string & second@var198 ) ;
109: static std :: string incdec ( const std :: string & var@var199 , const std :: string & op@var200 ) ;
110: static std :: string calculate ( const std :: string & first@var201 , const std :: string & second@var202 , char action@var203 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var204 ) ;
113: static std :: string cos ( const std :: string & tok@var205 ) ;
114: static std :: string tan ( const std :: string & tok@var206 ) ;
115: static std :: string abs ( const std :: string & tok@var207 ) ;
116: static bool isEqual ( const std :: string & first@var208 , const std :: string & second@var209 ) ;
117: static bool isNotEqual ( const std :: string & first@var210 , const std :: string & second@var211 ) ;
118: static bool isGreater ( const std :: string & first@var212 , const std :: string & second@var213 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var214 , const std :: string & second@var215 ) ;
120: static bool isLess ( const std :: string & first@var216 , const std :: string & second@var217 ) ;
121: static bool isLessEqual ( const std :: string & first@var218 , const std :: string & second@var219 ) ;
122: static bool isNullValue ( const std :: string & str@var220 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var221 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var222 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var223 , std :: string :: size_type iPos@var224 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var225 , const MathLib :: value & v2@var226 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var227 , const MathLib :: value & v2@var228 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var229 , const MathLib :: value & v2@var230 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var231 , const MathLib :: value & v2@var232 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var233 , const MathLib :: value & v2@var234 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var235 , const MathLib :: value & v2@var236 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var237 , const MathLib :: value & v2@var238 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var239 , const MathLib :: value & v2@var240 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var241 , const MathLib :: value & v2@var242 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var243 , const MathLib :: value & v2@var244 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var245 ) ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var246 ) const {
35: return p@var246 .@expr1073744264 first@var247 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var248 ) const {
42: return p@var248 .@expr1073744265 second@var249 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var250 , const T & x@var251 )
48: {
49: return std ::@expr1073744266 find (@expr1073744267 r@var250 .@expr1073744268 begin (@expr1073744269 ) , r@var250 .@expr2446 end (@expr2447 ) , x@var251 ) !=@expr1073744272 r@var250 .@expr2446 end (@expr2447 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var252 , const T & x@var253 )
54: {
55: return std ::@expr1073744275 find (@expr1073744276 r@var252 .@expr1073744277 begin (@expr1073744278 ) , r@var252 .@expr2455 end (@expr2456 ) , x@var253 ) !=@expr1073744281 r@var252 .@expr2455 end (@expr2456 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var254 , const U & x@var255 )
60: {
61: return std ::@expr1073744284 find (@expr1073744285 r@var254 .@expr1073744286 begin (@expr1073744287 ) , r@var254 .@expr2464 end (@expr2465 ) , x@var255 ) !=@expr1073744290 r@var254 .@expr2464 end (@expr2465 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var256 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744293 t@var256 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var257 , char c@var258 )
74: {
75: return !@expr1073744294 str@var257 .@expr1073744295 empty (@expr1073744296 ) &&@expr1073744297 str@var257 .@expr1073744298 back (@expr1073744299 ) ==@expr1073744300 c@var258 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var259 , const char end@var260 [ ] , unsigned long endlen@var261 )
79: {
80: return (@expr2477 str@var259 .@expr2478 size (@expr2479 ) >=@expr1073744304 endlen@var261 ) &&@expr1073744305 (@expr2477 str@var259 .@expr1073744307 compare (@expr1073744308 str@var259 .@expr2478 size (@expr2479 ) -@expr1073744311 endlen@var261 , endlen@var261 , end@var260 ) ==@expr1073744312 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var262 , const char ( & end@var263 ) [ N ] )
85: {
86: return endsWith (@expr1073744314 str@var262 , end@var263 , N@expr1073744313 -@expr1073744315 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var264 , char q@var265 , const std :: string & p@var266 )
90: {
91: if (@expr1073744316 !@expr1073744317 endsWith (@expr1073744318 str@var264 , q@var265 ) ) {
92: return false ; }
93: if (@expr1073744319 (@expr1073744320 str@var264 .@expr1073744321 length (@expr1073744322 ) +@expr1073744323 1 ) >@expr1073744324 p@var266 .@expr1073744325 length (@expr1073744326 ) &&@expr1073744327 (@expr1073744328 str@var264 .@expr1073744329 compare (@expr1073744330 0 , p@var266 .@expr1073744331 size (@expr1073744332 ) +@expr1073744333 1 , p@var266 +@expr1073744334 q@var265 ) ==@expr1073744335 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var267 , char q@var268 )
99: {
100: static const std ::@expr2512 vector < std ::@expr2512 string > suffixes@var269 {@expr1073744338 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744339 const std ::@expr2512 string &@expr1073744341 p@var270 :@expr1073744342 suffixes@var269 ) {
102: if (@expr1073744343 isPrefixStringCharLiteral (@expr1073744344 str@var267 , q@var268 , p@var270 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var271 )
109: {
110: return isStringCharLiteral (@expr1073744345 str@var271 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var272 )
114: {
115: return isStringCharLiteral (@expr1073744346 str@var272 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var273 , char q@var274 )
119: {
120: const unsigned long quotePos@var275 =@expr1073744347 str@var273 .@expr1073744348 find (@expr1073744349 q@var274 ) ;
121: return str@var273 .@expr1073744350 substr (@expr1073744351 quotePos@var275 +@expr1073744352 1U , str@var273 .@expr1073744353 size (@expr1073744354 ) -@expr1073744355 quotePos@var275 -@expr1073744356 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var276 )
125: {
126: if (@expr1073744357 isStringLiteral (@expr1073744358 str@var276 ) ) {
127: return getStringCharLiteral (@expr1073744359 str@var276 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var277 )
132: {
133: if (@expr1073744360 isCharLiteral (@expr1073744361 str@var277 ) ) {
134: return getStringCharLiteral (@expr1073744362 str@var277 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var278 )
139: {
140: if (@expr1073744363 i@var278 ==@expr1073744364 1 ) {
141: return "st" ; }
142: if (@expr1073744365 i@var278 ==@expr1073744366 2 ) {
143: return "nd" ; }
144: if (@expr1073744367 i@var278 ==@expr1073744368 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var279 , const std :: string & rhs@var280 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var281 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var282 , const std :: string & name@var283 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var284 , const std :: string & name@var285 ) ;
156:
157: void strTolower ( std :: string & str@var286 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var287 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var288 ;
42:
43:
44: std :: string stdValue@var289 ;
45:
46:
47: Standards ( ) : c@var287 ( CLatest ) , cpp@var288 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var290 ) {
50: stdValue@var289 =@expr1073744369 str@var290 ;
51: if (@expr1073744370 str@var290 ==@expr1073744371 "c89" ||@expr1073744372 str@var290 ==@expr1073744373 "C89" ) {
52: c@var287 =@expr1073744374 C89 ;
53: return true ;
54: }
55: if (@expr1073744375 str@var290 ==@expr1073744376 "c99" ||@expr1073744377 str@var290 ==@expr1073744378 "C99" ) {
56: c@var287 =@expr1073744379 C99 ;
57: return true ;
58: }
59: if (@expr1073744380 str@var290 ==@expr1073744381 "c11" ||@expr1073744382 str@var290 ==@expr1073744383 "C11" ) {
60: c@var287 =@expr1073744384 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744385 c@var287 ) {
67: case C89 :@expr2562 ;
68: return "c89" ;
69: case C99 :@expr2562 ;
70: return "c99" ;
71: case C11 :@expr2562 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var291 ) {
77: if (@expr1073744389 std@var291 ==@expr1073744390 "c89" ) {
78: return Standards ::@expr1073744391 C89 ;
79: }
80: if (@expr1073744392 std@var291 ==@expr1073744393 "c99" ) {
81: return Standards ::@expr1073744394 C99 ;
82: }
83: if (@expr1073744395 std@var291 ==@expr1073744396 "c11" ) {
84: return Standards ::@expr1073744397 C11 ;
85: }
86: return Standards ::@expr1073744398 CLatest ;
87: }
88: bool setCPP ( std :: string str@var292 ) {
89: stdValue@var289 =@expr1073744399 str@var292 ;
90: strTolower (@expr1073744400 str@var292 ) ;
91: cpp@var288 =@expr1073744401 getCPP (@expr1073744402 str@var292 ) ;
92: return !@expr1073744403 stdValue@var289 .@expr1073744404 empty (@expr1073744405 ) &&@expr1073744406 str@var292 ==@expr1073744407 getCPP (@expr1073744408 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744409 cpp@var288 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var293 ) {
98: switch (@expr1073744410 std@var293 ) {
99: case CPP03 :@expr2587 ;
100: return "c++03" ;
101: case CPP11 :@expr2587 ;
102: return "c++11" ;
103: case CPP14 :@expr2587 ;
104: return "c++14" ;
105: case CPP17 :@expr2587 ;
106: return "c++17" ;
107: case CPP20 :@expr2587 ;
108: return "c++20" ;
109: case CPP23 :@expr2587 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var294 ) {
115: if (@expr1073744417 std@var294 ==@expr1073744418 "c++03" ) {
116: return Standards ::@expr1073744419 CPP03 ;
117: }
118: if (@expr1073744420 std@var294 ==@expr1073744421 "c++11" ) {
119: return Standards ::@expr1073744422 CPP11 ;
120: }
121: if (@expr1073744423 std@var294 ==@expr1073744424 "c++14" ) {
122: return Standards ::@expr1073744425 CPP14 ;
123: }
124: if (@expr1073744426 std@var294 ==@expr1073744427 "c++17" ) {
125: return Standards ::@expr1073744428 CPP17 ;
126: }
127: if (@expr1073744429 std@var294 ==@expr1073744430 "c++20" ) {
128: return Standards ::@expr1073744431 CPP20 ;
129: }
130: if (@expr1073744432 std@var294 ==@expr1073744433 "c++23" ) {
131: return Standards ::@expr1073744434 CPP23 ;
132: }
133: return Standards ::@expr1073744435 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var298 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var295 ) : errorcode@var298 ( e@var295 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var296 , T && r@var297 ) : errorcode@var298 ( e@var296 ) , reason@var299 ( r@var297 ) { }
66: ErrorCode errorcode@var298 ;
67: std :: string reason@var299 ;
68: } ;
69:
70: Error load ( const char exename@var300 [ ] , const char path@var301 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var302 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var303 [ ] , unsigned long len@var304 ) ;
75:
76: struct AllocFunc {
77: int groupId@var305 ;
78: int arg@var306 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var307 ;
81: int bufferSizeArg1@var308 ;
82: int bufferSizeArg2@var309 ;
83: int reallocArg@var310 ;
84: bool initData@var311 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var312 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var313 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var314 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var315 , int arg@var316 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var317 , int arg@var318 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var319 , int arg@var320 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var321 [ ] ) const {
107: return getAllocDealloc (@expr1073744436 mAlloc@var587 , name@var321 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var322 [ ] ) const {
112: return getAllocDealloc (@expr1073744437 mDealloc@var588 , name@var322 ) ;
113: }
114:
115:
116: int allocId ( const char name@var323 [ ] ) const {
117: const AllocFunc * af@var324 ; af@var324 =@expr1073744438 getAllocDealloc (@expr1073744439 mAlloc@var587 , name@var323 ) ;
118: return af@var324 ?@expr1073744440 af@var324 .@expr1073744441 groupId@var325 :@expr1073744442 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var326 [ ] ) const {
123: const AllocFunc * af@var327 ; af@var327 =@expr1073744443 getAllocDealloc (@expr1073744444 mDealloc@var588 , name@var326 ) ;
124: return af@var327 ?@expr1073744445 af@var327 .@expr1073744446 groupId@var328 :@expr1073744447 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var329 , int id@var330 , int arg@var331 ) {
129: mAlloc@var587 [@expr2624 functionname@var329 ] .@expr1073744449 groupId@var2353 =@expr1073744450 id@var330 ;
130: mAlloc@var587 [@expr2624 functionname@var329 ] .@expr1073744452 arg@var2354 =@expr1073744453 arg@var331 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var332 , int id@var333 , int arg@var334 ) {
134: mDealloc@var588 [@expr2630 functionname@var332 ] .@expr1073744455 groupId@var2355 =@expr1073744456 id@var333 ;
135: mDealloc@var588 [@expr2630 functionname@var332 ] .@expr1073744458 arg@var2356 =@expr1073744459 arg@var334 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var335 , int id@var336 , int arg@var337 , int reallocArg@var338 = 1 ) {
139: mRealloc@var589 [@expr2636 functionname@var335 ] .@expr1073744461 groupId@var2357 =@expr1073744462 id@var336 ;
140: mRealloc@var589 [@expr2636 functionname@var335 ] .@expr1073744464 arg@var2358 =@expr1073744465 arg@var337 ;
141: mRealloc@var589 [@expr2636 functionname@var335 ] .@expr1073744467 reallocArg@var2359 =@expr1073744468 reallocArg@var338 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var339 , bool noreturn@var340 ) {
146: mNoReturn@var590 [@expr1073744469 funcname@var339 ] =@expr1073744470 noreturn@var340 ?@expr1073744471 FalseTrueMaybe ::@expr1073744472 True :@expr1073744473 FalseTrueMaybe ::@expr1073744474 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var341 ) ;
150:
151:
152: static bool ismemory ( const int id@var342 ) {
153: return (@expr2651 (@expr2651 id@var342 >@expr1073744477 0 ) &&@expr1073744478 (@expr2651 (@expr2651 id@var342 &@expr1073744481 1 ) ==@expr1073744482 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var343 ) {
156: return (@expr2659 (@expr2659 func@var343 .@expr2661 groupId@var344 >@expr1073744486 0 ) &&@expr1073744487 (@expr2659 (@expr2659 func@var343 .@expr2661 groupId@var344 &@expr1073744491 1 ) ==@expr1073744492 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var345 ) {
161: return (@expr2669 (@expr2669 id@var345 >@expr1073744495 0 ) &&@expr1073744496 (@expr2669 (@expr2669 id@var345 &@expr1073744499 1 ) ==@expr1073744500 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var346 ) {
164: return (@expr2677 (@expr2677 func@var346 .@expr2679 groupId@var347 >@expr1073744504 0 ) &&@expr1073744505 (@expr2677 (@expr2677 func@var346 .@expr2679 groupId@var347 &@expr1073744509 1 ) ==@expr1073744510 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var348 ) const ;
168: int formatstr_argno ( const Token * ftok@var349 ) const ;
169: bool formatstr_scan ( const Token * ftok@var350 ) const ;
170: bool formatstr_secure ( const Token * ftok@var351 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var352 ;
174: int ptr2Arg@var353 ;
175: int sizeArg@var354 ;
176: int strlenArg@var355 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var356 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var357 ;
182: Standards standards@var358 ;
183: Severity :: SeverityType severity@var359 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var360 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var361 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var362 ) const ;
191: bool matchArguments ( const Token * ftok@var363 , const std :: string & functionName@var364 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var365 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var366 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var367 ) const ;
198: int returnValueContainer ( const Token * ftok@var368 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var369 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var370 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var371 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var372 , std :: string * unknownFunc@var373 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var383 ( -1 ) ,
210: size_templateArgNo@var385 ( -1 ) ,
211: arrayLike_indexOp@var386 ( false ) ,
212: stdStringLike@var387 ( false ) ,
213: stdAssociativeLike@var388 ( false ) ,
214: opLessAllowed@var389 ( true ) ,
215: hasInitializerListConstructor@var390 ( false ) ,
216: unstableErase@var391 ( false ) ,
217: unstableInsert@var392 ( false ) ,
218: view@var393 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var374 ;
248: Yield yield@var375 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var376 ;
252: int templateParameter@var377 ;
253: } ;
254: std :: string startPattern@var378 ; std :: string startPattern2@var379 ; std :: string endPattern@var380 ; std :: string itEndPattern@var381 ;
255: std :: map < std :: string , Function > functions@var382 ;
256: int type_templateArgNo@var383 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var384 ;
258: int size_templateArgNo@var385 ;
259: bool arrayLike_indexOp@var386 ;
260: bool stdStringLike@var387 ;
261: bool stdAssociativeLike@var388 ;
262: bool opLessAllowed@var389 ;
263: bool hasInitializerListConstructor@var390 ;
264: bool unstableErase@var391 ;
265: bool unstableInsert@var392 ;
266: bool view@var393 ;
267:
268: Action getAction ( const std :: string & function@var394 ) const {
269: const std ::@expr1073744511 map < std ::@expr1073744512 string , Function > ::@expr1073744513 const_iterator i@var395 =@expr1073744514 functions@var382 .@expr1073744515 find (@expr1073744516 function@var394 ) ;
270: if (@expr1073744517 i@var395 !=@expr1073744518 functions@var382 .@expr1073744519 end (@expr1073744520 ) ) {
271: return i@var395 .@expr1073744521 second@var396 .@expr1073744522 action@var397 ; }
272: return Action ::@expr1073744523 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var398 ) const {
276: const std ::@expr1073744524 map < std ::@expr1073744525 string , Function > ::@expr1073744526 const_iterator i@var399 =@expr1073744527 functions@var382 .@expr1073744528 find (@expr1073744529 function@var398 ) ;
277: if (@expr1073744530 i@var399 !=@expr1073744531 functions@var382 .@expr1073744532 end (@expr1073744533 ) ) {
278: return i@var399 .@expr1073744534 second@var400 .@expr1073744535 yield@var401 ; }
279: return Yield ::@expr1073744536 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var402 ) ;
283: static Action actionFrom ( const std :: string & actionName@var403 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var404 ;
286: const Container * detectContainer ( const Token * typeStart@var405 , bool iterator@var406 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var407 , bool * isIterator@var408 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var409 ( false ) ,
293: notnull@var410 ( false ) ,
294: notuninit@var411 ( -1 ) ,
295: formatstr@var412 ( false ) ,
296: strz@var413 ( false ) ,
297: optional@var414 ( false ) ,
298: variadic@var415 ( false ) ,
299: iteratorInfo@var421 ( ) ,
300: direction@var429 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var409 ;
303: bool notnull@var410 ;
304: int notuninit@var411 ;
305: bool formatstr@var412 ;
306: bool strz@var413 ;
307: bool optional@var414 ;
308: bool variadic@var415 ;
309: std :: string valid@var416 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var417 ( 0 ) , it@var418 ( false ) , first@var419 ( false ) , last@var420 ( false ) { }
314:
315: int container@var417 ;
316: bool it@var418 ;
317: bool first@var419 ;
318: bool last@var420 ;
319: } ;
320: IteratorInfo iteratorInfo@var421 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var422 , int a@var423 ) : type@var424 ( t@var422 ) , arg@var425 ( a@var423 ) , arg2@var426 ( 0 ) , value@var427 ( 0 ) { }
326: Type type@var424 ;
327: int arg@var425 ;
328: int arg2@var426 ;
329: long long value@var427 ;
330: } ;
331: std :: vector < MinSize > minsizes@var428 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var429 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var430 ;
344: bool use@var431 ;
345: bool leakignore@var432 ;
346: bool isconst@var433 ;
347: bool ispure@var434 ;
348: UseRetValType useretval@var435 ;
349: bool ignore@var436 ;
350: bool formatstr@var437 ;
351: bool formatstr_scan@var438 ;
352: bool formatstr_secure@var439 ;
353: Container :: Action containerAction@var440 ;
354: Container :: Yield containerYield@var441 ;
355: Function ( )
356: : use@var431 ( false ) ,
357: leakignore@var432 ( false ) ,
358: isconst@var433 ( false ) ,
359: ispure@var434 ( false ) ,
360: useretval@var435 ( UseRetValType :: NONE ) ,
361: ignore@var436 ( false ) ,
362: formatstr@var437 ( false ) ,
363: formatstr_scan@var438 ( false ) ,
364: formatstr_secure@var439 ( false ) ,
365: containerAction@var440 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var441 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var442 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var443 ;
372: bool isUse ( const std :: string & functionName@var444 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var445 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var446 , bool pure@var447 ) const ;
375: bool isFunctionConst ( const Token * ftok@var448 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var449 , int argnr@var450 ) const {
378: const ArgumentChecks * arg@var451 ; arg@var451 =@expr1073744537 getarg (@expr1073744538 ftok@var449 , argnr@var450 ) ;
379: return arg@var451 &&@expr1073744539 arg@var451 .@expr1073744540 notbool@var452 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var453 , int argnr@var454 ) const ;
383: bool isuninitargbad ( const Token * ftok@var455 , int argnr@var456 , int indirect@var457 = 0 , bool * hasIndirect@var458 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var459 , int argnr@var460 ) const {
386: const ArgumentChecks * arg@var461 ; arg@var461 =@expr1073744541 getarg (@expr1073744542 ftok@var459 , argnr@var460 ) ;
387: return arg@var461 &&@expr1073744543 arg@var461 .@expr1073744544 formatstr@var462 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var463 , int argnr@var464 ) const {
391: const ArgumentChecks * arg@var465 ; arg@var465 =@expr1073744545 getarg (@expr1073744546 ftok@var463 , argnr@var464 ) ;
392: return arg@var465 &&@expr1073744547 arg@var465 .@expr1073744548 strz@var466 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var467 , int argnr@var468 , const long long argvalue@var469 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var470 , int argnr@var471 , double argvalue@var472 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var473 , int argnr@var474 ) const {
399: const ArgumentChecks * arg@var475 ; arg@var475 =@expr1073744549 getarg (@expr1073744550 ftok@var473 , argnr@var474 ) ;
400: return arg@var475 ?@expr1073744551 arg@var475 .@expr1073744552 valid@var476 :@expr1073744553 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var477 ;
405: std :: string op1@var478 ;
406: std :: string op2@var479 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744554 isInt (@expr1073744555 op1@var478 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var480 , int argnr@var481 ) const {
413: const ArgumentChecks * arg@var482 ; arg@var482 =@expr1073744556 getarg (@expr1073744557 ftok@var480 , argnr@var481 ) ;
414: return arg@var482 &&@expr1073744558 arg@var482 .@expr2735 iteratorInfo@var483 .@expr1073744560 it@var484 ?@expr1073744561 &@expr1073744562 arg@var482 .@expr2735 iteratorInfo@var483 :@expr1073744564 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var485 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var486 , int argnr@var487 ) const {
420: const ArgumentChecks * arg@var488 ; arg@var488 =@expr1073744565 getarg (@expr1073744566 ftok@var486 , argnr@var487 ) ;
421: return arg@var488 ?@expr1073744567 &@expr1073744568 arg@var488 .@expr1073744569 minsizes@var489 :@expr1073744570 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var490 , int argnr@var491 ) const ;
425:
426: bool markupFile ( const std :: string & path@var492 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var493 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var597 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var494 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var495 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var496 , const std :: string & token@var497 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var498 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var499 ) const ;
443: const std :: string & blockend ( const std :: string & file@var500 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var501 , const std :: string & keyword@var502 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var503 ) const {
448: return mExporters@var600 .@expr1073744571 find (@expr1073744572 prefix@var503 ) !=@expr1073744573 mExporters@var600 .@expr1073744574 end (@expr1073744575 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var504 , const std :: string & token@var505 ) const {
452: const std ::@expr1073744576 map < std ::@expr1073744577 string , ExportedFunctions > ::@expr1073744578 const_iterator it@var506 =@expr1073744579 mExporters@var600 .@expr1073744580 find (@expr1073744581 prefix@var504 ) ;
453: return (@expr1073744582 it@var506 !=@expr1073744583 mExporters@var600 .@expr1073744584 end (@expr1073744585 ) &&@expr1073744586 it@var506 .@expr1073744587 second@var507 .@expr1073744588 isPrefix (@expr1073744589 token@var505 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var508 , const std :: string & token@var509 ) const {
457: const std ::@expr1073744590 map < std ::@expr1073744591 string , ExportedFunctions > ::@expr1073744592 const_iterator it@var510 =@expr1073744593 mExporters@var600 .@expr1073744594 find (@expr1073744595 prefix@var508 ) ;
458: return (@expr1073744596 it@var510 !=@expr1073744597 mExporters@var600 .@expr1073744598 end (@expr1073744599 ) &&@expr1073744600 it@var510 .@expr1073744601 second@var511 .@expr1073744602 isSuffix (@expr1073744603 token@var509 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var512 , const std :: string & importer@var513 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var514 , Container :: Yield yield@var515 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var516 , Container :: Action action@var517 ) const ;
465:
466: bool isreflection ( const std :: string & token@var518 ) const {
467: return mReflection@var602 .@expr1073744604 find (@expr1073744605 token@var518 ) !=@expr1073744606 mReflection@var602 .@expr1073744607 end (@expr1073744608 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var519 ) const {
471: const std ::@expr1073744609 map < std ::@expr1073744610 string , int > ::@expr1073744611 const_iterator it@var520 =@expr1073744612 mReflection@var602 .@expr1073744613 find (@expr1073744614 token@var519 ) ;
472: if (@expr1073744615 it@var520 !=@expr1073744616 mReflection@var602 .@expr1073744617 end (@expr1073744618 ) ) {
473: return it@var520 .@expr1073744619 second@var521 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var522 ;
478:
479: struct SmartPointer {
480: std :: string name@var523 ; name@var523 = "" ;
481: bool unique@var524 ; unique@var524 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var525 ;
485: bool isSmartPointer ( const Token * tok@var526 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var527 ) const ;
487:
488: struct PodType {
489: unsigned int size@var528 ;
490: char sign@var529 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var530 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var531 ) const {
494: const std ::@expr1073744620 unordered_map < std ::@expr1073744621 string , PodType > ::@expr1073744622 const_iterator it@var532 =@expr1073744623 mPodTypes@var603 .@expr1073744624 find (@expr1073744625 name@var531 ) ;
495: return (@expr2802 it@var532 !=@expr1073744627 mPodTypes@var603 .@expr1073744628 end (@expr1073744629 ) ) ?@expr1073744630 &@expr1073744631 (@expr2802 it@var532 .@expr1073744633 second@var533 ) :@expr1073744634 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var544 ( false )
501: , mUnsigned@var545 ( false )
502: , mLong@var546 ( false )
503: , mPointer@var547 ( false )
504: , mPtrPtr@var548 ( false )
505: , mConstPtr@var549 ( false ) { }
506: bool operator== ( const PlatformType & type@var534 ) const {
507: return (@expr1073744635 mSigned@var544 ==@expr1073744636 type@var534 .@expr1073744637 mSigned@var535 &&@expr1073744638
508: mUnsigned@var545 ==@expr1073744639 type@var534 .@expr1073744640 mUnsigned@var536 &&@expr1073744641
509: mLong@var546 ==@expr1073744642 type@var534 .@expr1073744643 mLong@var537 &&@expr1073744644
510: mPointer@var547 ==@expr1073744645 type@var534 .@expr1073744646 mPointer@var538 &&@expr1073744647
511: mPtrPtr@var548 ==@expr1073744648 type@var534 .@expr1073744649 mPtrPtr@var539 &&@expr1073744650
512: mConstPtr@var549 ==@expr1073744651 type@var534 .@expr1073744652 mConstPtr@var540 &&@expr1073744653
513: mType@var543 ==@expr1073744654 type@var534 .@expr1073744655 mType@var541 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var542 ) const {
516: return !@expr1073744656 (@expr1073744657 *@expr1073744658 this@expr1073744659 ==@expr1073744660 type@var542 ) ;
517: }
518: std :: string mType@var543 ;
519: bool mSigned@var544 ;
520: bool mUnsigned@var545 ;
521: bool mLong@var546 ;
522: bool mPointer@var547 ;
523: bool mPtrPtr@var548 ;
524: bool mConstPtr@var549 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var550 ) const {
529: const std ::@expr1073744661 map < std ::@expr1073744662 string , PlatformType > ::@expr1073744663 const_iterator it@var551 =@expr1073744664 mPlatformTypes@var553 .@expr1073744665 find (@expr1073744666 name@var550 ) ;
530: return (@expr2843 it@var551 !=@expr1073744668 mPlatformTypes@var553 .@expr1073744669 end (@expr1073744670 ) ) ?@expr1073744671 &@expr1073744672 (@expr2843 it@var551 .@expr1073744674 second@var552 ) :@expr1073744675 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var553 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var554 , const std :: string & platform@var555 ) const {
536: const std ::@expr1073744676 map < std ::@expr2853 string , Platform > ::@expr1073744678 const_iterator it@var556 =@expr1073744679 mPlatforms@var605 .@expr1073744680 find (@expr1073744681 platform@var555 ) ;
537: if (@expr1073744682 it@var556 !=@expr1073744683 mPlatforms@var605 .@expr1073744684 end (@expr1073744685 ) ) {
538: const PlatformType * const type@var557 ; type@var557 =@expr1073744686 it@var556 .@expr1073744687 second@var558 .@expr1073744688 platform_type (@expr1073744689 name@var554 ) ;
539: if (@expr1073744690 type@var557 ) {
540: return type@var557 ; }
541: }
542:
543: const std ::@expr1073744691 map < std ::@expr2853 string , PlatformType > ::@expr1073744693 const_iterator it2@var559 =@expr1073744694 mPlatformTypes@var604 .@expr1073744695 find (@expr1073744696 name@var554 ) ;
544: return (@expr2873 it2@var559 !=@expr1073744698 mPlatformTypes@var604 .@expr1073744699 end (@expr1073744700 ) ) ?@expr1073744701 &@expr1073744702 (@expr2873 it2@var559 .@expr1073744704 second@var560 ) :@expr1073744705 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var561 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var562 , Library :: Container :: Yield y@var563 , const std :: string & fallback@var564 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var565 , const std :: string & typeName@var566 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var567 , const std :: string & name@var568 , std :: set < std :: string > & unknown_elements@var569 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var570 ) {
565: mPrefixes@var574 .@expr1073744706 insert (@expr1073744707 prefix@var570 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var571 ) {
568: mSuffixes@var575 .@expr1073744708 insert (@expr1073744709 suffix@var571 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var572 ) const {
571: return (@expr1073744710 mPrefixes@var574 .@expr1073744711 find (@expr1073744712 prefix@var572 ) !=@expr1073744713 mPrefixes@var574 .@expr1073744714 end (@expr1073744715 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var573 ) const {
574: return (@expr1073744716 mSuffixes@var575 .@expr1073744717 find (@expr1073744718 suffix@var573 ) !=@expr1073744719 mSuffixes@var575 .@expr1073744720 end (@expr1073744721 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var574 ;
579: std :: set < std :: string > mSuffixes@var575 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var583 ( 0 ) { }
584:
585: void setStart ( const char * s@var576 ) {
586: mStart@var581 =@expr1073744722 s@var576 ;
587: }
588: void setEnd ( const char * e@var577 ) {
589: mEnd@var582 =@expr1073744723 e@var577 ;
590: }
591: void setOffset ( const int o@var578 ) {
592: mOffset@var583 =@expr1073744724 o@var578 ;
593: }
594: void addBlock ( const char * blockName@var579 ) {
595: mBlocks@var584 .@expr1073744725 insert (@expr1073744726 blockName@var579 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var581 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var582 ;
602: }
603: int offset ( ) const {
604: return mOffset@var583 ;
605: }
606: bool isBlock ( const std :: string & blockName@var580 ) const {
607: return mBlocks@var584 .@expr1073744727 find (@expr1073744728 blockName@var580 ) !=@expr1073744729 mBlocks@var584 .@expr1073744730 end (@expr1073744731 ) ;
608: }
609:
610: private:
611: std :: string mStart@var581 ;
612: std :: string mEnd@var582 ;
613: int mOffset@var583 ;
614: std :: set < std :: string > mBlocks@var584 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var585 ;
618: std :: set < std :: string > mFiles@var586 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var587 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var588 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var589 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var590 ;
623: std :: map < std :: string , std :: string > mReturnValue@var591 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var592 ;
625: std :: map < std :: string , int > mReturnValueContainer@var593 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var594 ;
627: std :: map < std :: string , bool > mReportErrors@var595 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var596 ;
629: std :: set < std :: string > mMarkupExtensions@var597 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var598 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var599 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var600 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var601 ;
634: std :: map < std :: string , int > mReflection@var602 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var603 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var604 ;
637: std :: map < std :: string , Platform > mPlatforms@var605 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var606 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var607 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var608 , int argnr@var609 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var610 , bool * error@var611 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var612 , const std :: string & name@var613 ) {
646: const std ::@expr1073744732 map < std ::@expr1073744733 string , AllocFunc > ::@expr1073744734 const_iterator it@var614 =@expr1073744735 data@var612 .@expr1073744736 find (@expr1073744737 name@var613 ) ;
647: return (@expr1073744738 it@var614 ==@expr1073744739 data@var612 .@expr1073744740 end (@expr1073744741 ) ) ?@expr1073744742 nullptr :@expr1073744743 &@expr1073744744 it@var614 .@expr1073744745 second@var615 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var616 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var617 ,
654: const Settings * settings@var618 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var619 = nullptr ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var620 ) {
44: if (@expr1073744746 bit@var620 >=@expr1073744747 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073744748 (@expr1073744749 1LL <<@expr1073744750 (@expr1073744751 bit@var620 -@expr1073744752 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var621 ) {
50: if (@expr1073744753 bit@var621 >=@expr1073744754 64 ) {
51: return (@expr2931 ~@expr1073744756 0ULL ) >>@expr1073744757 1 ; }
52: return (@expr2931 1LL <<@expr1073744759 (@expr2931 bit@var621 -@expr1073744761 1 ) ) -@expr1073744762 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var622 ) const {
59: return value@var622 >=@expr1073744763 min_value (@expr1073744764 int_bit@var632 ) &&@expr1073744765 value@var622 <=@expr1073744766 max_value (@expr1073744767 int_bit@var632 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var623 ) const {
63: unsigned long long intMax@var624 ; intMax@var624 =@expr1073744768 max_value (@expr1073744769 int_bit@var632 ) ;
64: return value@var623 <=@expr1073744770 intMax@var624 ;
65: }
66:
67: bool isLongValue ( long long value@var625 ) const {
68: return value@var625 >=@expr1073744771 min_value (@expr1073744772 long_bit@var633 ) &&@expr1073744773 value@var625 <=@expr1073744774 max_value (@expr1073744775 long_bit@var633 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var626 ) const {
72: unsigned long long longMax@var627 ; longMax@var627 =@expr1073744776 max_value (@expr1073744777 long_bit@var633 ) ;
73: return value@var626 <=@expr1073744778 longMax@var627 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var628 ) const {
77: unsigned long long longLongMax@var629 ; longLongMax@var629 =@expr1073744779 max_value (@expr1073744780 long_long_bit@var634 ) ;
78: return value@var628 <=@expr1073744781 longLongMax@var629 ;
79: }
80:
81: int char_bit@var630 ;
82: int short_bit@var631 ;
83: int int_bit@var632 ;
84: int long_bit@var633 ;
85: int long_long_bit@var634 ;
86:
87:
88: int sizeof_bool@var635 ;
89: int sizeof_short@var636 ;
90: int sizeof_int@var637 ;
91: int sizeof_long@var638 ;
92: int sizeof_long_long@var639 ;
93: int sizeof_float@var640 ;
94: int sizeof_double@var641 ;
95: int sizeof_long_double@var642 ;
96: int sizeof_wchar_t@var643 ;
97: int sizeof_size_t@var644 ;
98: int sizeof_pointer@var645 ;
99:
100: char defaultSign@var646 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var647 ;
115:
116:
117: bool platform ( PlatformType type@var648 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var649 [ ] , const std :: string & filename@var650 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var651 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var647 ==@expr1073744782 Win32A ||@expr1073744783
136: platformType@var647 ==@expr1073744784 Win32W ||@expr1073744785
137: platformType@var647 ==@expr1073744786 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073744787 platformType@var647 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var652 ) {
145: switch (@expr1073744788 pt@var652 ) {
146: case Unspecified :@expr2965 ;
147: return "Unspecified" ;
148: case Native :@expr2965 ;
149: return "Native" ;
150: case Win32A :@expr2965 ;
151: return "win32A" ;
152: case Win32W :@expr2965 ;
153: return "win32W" ;
154: case Win64 :@expr2965 ;
155: return "win64" ;
156: case Unix32 :@expr2965 ;
157: return "unix32" ;
158: case Unix64 :@expr2965 ;
159: return "unix64" ;
160: case PlatformFile :@expr2965 ;
161: return "platformFile" ;
162: default :@expr2965 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073744798 char_bit@var630 +@expr1073744799 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073744800 char_bit@var630 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073744801 char_bit@var630 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var653 , const std :: string & rhs@var654 ) const {
41: return caseInsensitiveStringCompare (@expr1073744802 lhs@var653 , rhs@var654 ) <@expr1073744803 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var662 ( cppcheck :: Platform :: Unspecified ) , msc@var663 ( false ) , useMfc@var664 ( false ) { }
67: std :: string cfg@var655 ;
68: std :: string filename@var656 ;
69: std :: string defines@var657 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var657 +@expr1073744804 (@expr1073744805 msc@var663 ?@expr1073744806 ";_MSC_VER=1900" :@expr1073744807 "" ) +@expr1073744808 (@expr1073744809 useMfc@var664 ?@expr1073744810 ";__AFXWIN_H__=1" :@expr1073744811 "" ) ;
72: }
73: std :: set < std :: string > undefs@var658 ;
74: std :: list < std :: string > includePaths@var659 ;
75: std :: list < std :: string > systemIncludePaths@var660 ;
76: std :: string standard@var661 ;
77: cppcheck :: Platform :: PlatformType platformType@var662 ;
78: bool msc@var663 ;
79: bool useMfc@var664 ;
80:
81: void parseCommand ( std :: string command@var665 ) ;
82: void setDefines ( std :: string defs@var666 ) ;
83: void setIncludePaths ( const std :: string & basepath@var667 , const std :: list < std :: string > & in@var668 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var669 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var670 ;
86: Type projectType@var671 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var672 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous0 {
96: std :: string analyzeAllVsConfigs@var673 ;
97: std :: vector < std :: string > pathNames@var674 ;
98: std :: list < std :: string > libraries@var675 ;
99: std :: list < std :: string > excludedPaths@var676 ;
100: std :: list < std :: string > checkVsConfigs@var677 ;
101: std :: string projectFile@var678 ;
102: std :: string platform@var679 ;
103: } ; struct Anonymous0 guiProject@var680 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var681 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var682 ) ;
107:
108: Type import ( const std :: string & filename@var683 , Settings * settings@var684 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var685 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var686 , Settings * settings@var687 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var688 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var689 , const std :: string & path@var690 , const std :: vector < std :: string > & fileFilters@var691 ) ;
115: bool importVcxproj ( const std :: string & filename@var692 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var693 , const std :: string & additionalIncludeDirectories@var694 , const std :: vector < std :: string > & fileFilters@var695 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var696 ) ;
117:
118: static void printError ( const std :: string & message@var697 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var698 ) ;
121:
122: std :: string mPath@var699 ;
123: std :: set < std :: string > mAllVSConfigs@var700 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var701 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var702 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var703 [ 2 ] = "1" ;
131: const char BuildDirElementName@var704 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var705 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var706 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var707 [ 7 ] = "parser" ;
135: const char BugHunting@var708 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var709 [ 11 ] = "includedir" ;
137: const char DirElementName@var710 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var711 [ 5 ] = "name" ;
139: const char DefinesElementName@var712 [ 8 ] = "defines" ;
140: const char DefineName@var713 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var714 [ 5 ] = "name" ;
142: const char UndefinesElementName@var715 [ 10 ] = "undefines" ;
143: const char UndefineName@var716 [ 9 ] = "undefine" ;
144: const char PathsElementName@var717 [ 6 ] = "paths" ;
145: const char PathName@var718 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var719 [ 5 ] = "name" ;
147: const char RootPathName@var720 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var721 [ 5 ] = "name" ;
149: const char IgnoreElementName@var722 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var723 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var724 [ 5 ] = "name" ;
152: const char ExcludeElementName@var725 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var726 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var727 [ 5 ] = "name" ;
155: const char FunctionContracts@var728 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var729 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var730 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var731 [ 8 ] = "library" ;
159: const char PlatformElementName@var732 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var733 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var734 [ 12 ] = "suppression" ;
162: const char AddonElementName@var735 [ 6 ] = "addon" ;
163: const char AddonsElementName@var736 [ 7 ] = "addons" ;
164: const char ToolElementName@var737 [ 5 ] = "tool" ;
165: const char ToolsElementName@var738 [ 6 ] = "tools" ;
166: const char TagsElementName@var739 [ 5 ] = "tags" ;
167: const char TagElementName@var740 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var741 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var742 [ 4 ] = "tag" ;
170: const char WarningElementName@var743 [ 8 ] = "warning" ;
171: const char HashAttributeName@var744 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var745 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var746 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var747 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var748 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var749 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var750 [ 11 ] = "clang-tidy" ;
178: const char Name@var751 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var752 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var753 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var754 ;
43: std :: string errorId@var755 ;
44: void setFileName ( const std :: string & s@var756 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var760 ;
47: }
48: int lineNumber@var757 ;
49: Certainty :: CertaintyLevel certainty@var758 ;
50: std :: string symbolNames@var759 ;
51: private:
52: std :: string mFileName@var760 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var794 ( NO_LINE ) , hash@var796 ( 0 ) , thisAndNextLine@var797 ( false ) , matched@var798 ( false ) , checked@var799 ( false ) { }
57: Suppression ( const Suppression & other@var761 ) {
58: *@expr1073744812 this@expr1073744813 =@expr1073744814 other@var761 ;
59: }
60: Suppression ( const std :: string & id@var762 , const std :: string & file@var763 , int line@var764 = NO_LINE ) : errorId@var792 ( id@var762 ) , fileName@var793 ( file@var763 ) , lineNumber@var794 ( line@var764 ) , hash@var796 ( 0 ) , thisAndNextLine@var797 ( false ) , matched@var798 ( false ) , checked@var799 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var765 ) {
63: errorId@var792 =@expr1073744815 other@var765 .@expr1073744816 errorId@var766 ;
64: fileName@var793 =@expr1073744817 other@var765 .@expr1073744818 fileName@var767 ;
65: lineNumber@var794 =@expr1073744819 other@var765 .@expr1073744820 lineNumber@var768 ;
66: symbolName@var795 =@expr1073744821 other@var765 .@expr1073744822 symbolName@var769 ;
67: hash@var796 =@expr1073744823 other@var765 .@expr1073744824 hash@var770 ;
68: thisAndNextLine@var797 =@expr1073744825 other@var765 .@expr1073744826 thisAndNextLine@var771 ;
69: matched@var798 =@expr1073744827 other@var765 .@expr1073744828 matched@var772 ;
70: checked@var799 =@expr1073744829 other@var765 .@expr1073744830 checked@var773 ;
71: return *@expr1073744831 this@expr1073744832 ;
72: }
73:
74: bool operator< ( const Suppression & other@var774 ) const {
75: if (@expr1073744833 errorId@var792 !=@expr1073744834 other@var774 .@expr3011 errorId@var775 ) {
76: return errorId@var792 <@expr1073744836 other@var774 .@expr3011 errorId@var775 ; }
77: if (@expr1073744838 lineNumber@var794 <@expr1073744839 other@var774 .@expr1073744840 lineNumber@var776 ) {
78: return true ; }
79: if (@expr1073744841 fileName@var793 !=@expr1073744842 other@var774 .@expr3019 fileName@var777 ) {
80: return fileName@var793 <@expr1073744844 other@var774 .@expr3019 fileName@var777 ; }
81: if (@expr1073744846 symbolName@var795 !=@expr1073744847 other@var774 .@expr3024 symbolName@var778 ) {
82: return symbolName@var795 <@expr1073744849 other@var774 .@expr3024 symbolName@var778 ; }
83: if (@expr1073744851 hash@var796 !=@expr1073744852 other@var774 .@expr3029 hash@var779 ) {
84: return hash@var796 <@expr1073744854 other@var774 .@expr3029 hash@var779 ; }
85: if (@expr1073744856 thisAndNextLine@var797 !=@expr1073744857 other@var774 .@expr1073744858 thisAndNextLine@var780 ) {
86: return thisAndNextLine@var797 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var781 , std :: string * errorMessage@var782 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var783 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var784 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073744860 fileName@var793 .@expr1073744861 empty (@expr1073744862 ) &&@expr1073744863 fileName@var793 .@expr1073744864 find_first_of (@expr1073744865 "?*" ) ==@expr1073744866 std ::@expr1073744867 string ::@expr1073744868 npos@expr1073744859 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var785 ) const {
109: return errorId@var792 ==@expr1073744869 other@var785 .@expr1073744870 errorId@var786 &&@expr1073744871
110: fileName@var793 ==@expr1073744872 other@var785 .@expr1073744873 fileName@var787 &&@expr1073744874
111: lineNumber@var794 ==@expr1073744875 other@var785 .@expr1073744876 lineNumber@var788 &&@expr1073744877
112: symbolName@var795 ==@expr1073744878 other@var785 .@expr1073744879 symbolName@var789 &&@expr1073744880
113: hash@var796 ==@expr1073744881 other@var785 .@expr1073744882 hash@var790 &&@expr1073744883
114: thisAndNextLine@var797 ==@expr1073744884 other@var785 .@expr1073744885 thisAndNextLine@var791 ;
115: }
116:
117: std :: string errorId@var792 ;
118: std :: string fileName@var793 ;
119: int lineNumber@var794 ;
120: std :: string symbolName@var795 ;
121: unsigned long hash@var796 ;
122: bool thisAndNextLine@var797 ;
123: bool matched@var798 ;
124: bool checked@var799 ;
125:
126: enum Anonymous1 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var800 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var801 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var802 , std :: string * errorMessage@var803 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var804 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var805 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var806 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var807 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var808 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var809 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var810 , const bool unusedFunctionChecking@var811 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var812 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var813 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var814 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var815 , std :: clock_t clocks@var816 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var817 ;
45: long mNumberOfResults@var818 ;
46:
47: TimerResultsData ( )
48: : mClocks@var817 ( 0 )
49: , mNumberOfResults@var818 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var819 =@expr1073744887 (@expr1073744888 double ) (@expr1073744889 (@expr1073744890 unsigned long ) mClocks@var817 ) /@expr1073744891 (@expr1073744892 double ) CLOCKS_PER_SEC@expr1073744886 ;
53: return ret@var819 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var820 ) const ;
62: void addResults ( const std :: string & str@var821 , std :: clock_t clocks@var822 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var823 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var824 , SHOWTIME_MODES showtimeMode@var825 , TimerResultsIntf * timerResults@var826 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var827 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var828 ;
79: TimerResultsIntf * mTimerResults@var829 ;
80: std :: clock_t mStart@var830 ;
81: const SHOWTIME_MODES mShowTimeMode@var831 ;
82: bool mStopped@var832 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var833 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var834 ;
103:
104:
105: std :: string addonPython@var835 ;
106:
107:
108: std :: vector < std :: string > basePaths@var836 ;
109:
110:
111: std :: string buildDir@var837 ;
112:
113:
114: bool checkAllConfigurations@var838 ;
115:
116:
117: bool checkConfiguration@var839 ;
118:
|
121:
122: bool checkHeaders@var840 ;
123:
124:
125: bool checkLibrary@var841 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var842 ;
129:
130:
131: bool checkUnusedTemplates@var843 ;
132:
133:
134: bool clang@var844 ;
135:
136:
137: std :: string clangExecutable@var845 ;
138:
139:
140: bool clangTidy@var846 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var847 ;
144:
145:
146: std :: string cppcheckCfgProductName@var848 ;
147:
148:
149: std :: string cppcheckCfgAbout@var849 ;
150:
151:
152: bool daca@var850 ;
153:
154:
155: bool debugnormal@var851 ;
156:
157:
158: bool debugSimplified@var852 ;
159:
160:
161: bool debugtemplate@var853 ;
162:
163:
164: bool debugwarnings@var854 ;
165:
166:
167: bool dump@var855 ;
168: std :: string dumpFile@var856 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var857 ;
176:
177:
178: bool exceptionHandling@var858 ;
179:
180:
181: std :: string exename@var859 ;
182:
183:
184:
185: int exitCode@var860 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var861 ;
189:
190:
191: bool force@var862 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var863 ;
196:
197:
198: bool inlineSuppressions@var864 ;
199:
200:
201:
202: unsigned int jobs@var865 ;
203:
|
206:
207: bool jointSuppressionReport@var866 ;
208:
209:
210: std :: list < std :: string > libraries@var867 ;
211:
212:
213: Library library@var868 ;
214:
215:
216:
217: int loadAverage@var869 ;
218:
|
221:
222: int maxConfigs@var870 ;
223:
224:
225: int maxCtuDepth@var871 ;
226:
227:
228: int maxTemplateRecursion@var872 ;
229:
230:
231: Suppressions nofail@var873 ;
232:
233:
234: Suppressions nomsg@var874 ;
235:
236:
237: std :: string outputFile@var875 ;
238:
239:
240: std :: string plistOutput@var876 ;
241:
242:
243: bool preprocessOnly@var877 ;
244:
245: ImportProject project@var878 ;
246:
247:
248: bool quiet@var879 ;
249:
250:
251: bool relativePaths@var880 ;
252:
253:
254: bool reportProgress@var881 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var882 ( "simple" )
261: , id@var884 ( "rule" )
262: , severity@var886 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var882 ;
266: std :: string pattern@var883 ;
267: std :: string id@var884 ;
268: std :: string summary@var885 ;
269: Severity :: SeverityType severity@var886 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var887 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var893 ( false ) , externalFunctions@var894 ( false ) , internalFunctions@var895 ( false ) , externalVariables@var896 ( false ) { }
281:
282: static const char XmlRootName@var888 [ ] ;
283: static const char XmlClasses@var889 [ ] ;
284: static const char XmlExternalFunctions@var890 [ ] ;
285: static const char XmlInternalFunctions@var891 [ ] ;
286: static const char XmlExternalVariables@var892 [ ] ;
287:
288: void clear ( ) {
289: classes@var893 =@expr1073744893 externalFunctions@var894 =@expr1073744894 internalFunctions@var895 =@expr1073744895 externalVariables@var896 =@expr1073744896 false ;
290: }
291:
|
297:
298: bool classes@var893 ;
299:
|
304:
305: bool externalFunctions@var894 ;
306:
|
310:
311: bool internalFunctions@var895 ;
312:
|
316:
317: bool externalVariables@var896 ;
318: } ;
319:
320: SafeChecks safeChecks@var897 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var898 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var899 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var900 ;
325:
326:
327: SHOWTIME_MODES showtime@var901 ;
328:
329:
330: Standards standards@var902 ;
331:
332:
333:
334: std :: string templateFormat@var903 ;
335:
336:
337:
338: std :: string templateLocation@var904 ;
339:
340:
341: std :: string userDefines@var905 ;
342:
343:
344: std :: set < std :: string > userUndefs@var906 ;
345:
346:
347: std :: list < std :: string > userIncludes@var907 ;
348:
349:
350: bool verbose@var908 ;
351:
352:
353: bool xml@var909 ;
354:
355:
356: int xml_version@var910 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var911 ) const {
363: for (@expr1073744897 const std ::@expr1073744898 string &@expr1073744899 configExcludePath@var912 :@expr1073744900 configExcludePaths@var847 ) {
364: if (@expr1073744901 file@var911 .@expr1073744902 length (@expr1073744903 ) >=@expr1073744904 configExcludePath@var912 .@expr3081 length (@expr3082 ) &&@expr1073744907 file@var911 .@expr1073744908 compare (@expr1073744909 0 , configExcludePath@var912 .@expr3081 length (@expr3082 ) , configExcludePath@var912 ) ==@expr1073744912 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var913 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var914 , bool inconclusiveCheck@var915 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073744913 find (@expr1073744914 libraries@var867 .@expr1073744915 begin (@expr1073744916 ) , libraries@var867 .@expr3093 end (@expr3094 ) , "posix" ) !=@expr1073744919 libraries@var867 .@expr3093 end (@expr3094 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var916 = true ) {
392: Settings ::@expr1073744922 mTerminated@var833 =@expr1073744923 t@var916 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073744924 mTerminated@var833 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var917 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var918 ) const {
54: x@var918 ++@expr1073744925 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var919 ) const {
60: x@var919 --@expr1073744926 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var920 , const U & y@var921 ) const {
67: return x@var920 <@expr1073744927 y@var921 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var922 , const U & y@var923 ) const {
74: return std ::@expr1073744928 abs (@expr1073744929 x@var922 -@expr1073744930 y@var923 ) ==@expr1073744931 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var924 , T x@var925 , U y@var926 ) const {
81: result@var924 =@expr1073744932 !@expr1073744933 (@expr1073744934 x@var925 >@expr1073744935 y@var926 ||@expr1073744936 x@var925 <@expr1073744937 y@var926 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var927 = 0 , Bound b@var928 = Bound :: Point )
91: : valueType@var968 ( ValueType :: INT ) ,
92: bound@var969 ( b@var928 ) ,
93: intvalue@var970 ( val@var927 ) ,
94: tokvalue@var971 ( nullptr ) ,
95: floatValue@var972 ( 0.0 ) ,
96: moveKind@var973 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var974 ( val@var927 ) ,
98: condition@var975 ( nullptr ) ,
99: varId@var977 ( 0U ) ,
100: safe@var978 ( false ) ,
101: conditional@var979 ( false ) ,
102: macro@var980 ( false ) ,
103: defaultArg@var981 ( false ) ,
104: indirect@var982 ( 0 ) ,
105: path@var983 ( 0 ) ,
106: wideintvalue@var984 ( val@var927 ) ,
107: subexpressions@var985 ( ) ,
108: capturetok@var986 ( nullptr ) ,
109: lifetimeKind@var987 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var988 ( LifetimeScope :: Local ) ,
111: valueKind@var993 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var929 , long long val@var930 , Bound b@var931 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var932 ) const {
118: if (@expr1073744938 valueType@var968 !=@expr1073744939 rhs@var932 .@expr1073744940 valueType@var933 ) {
119: return false ; }
120: switch (@expr1073744941 valueType@var968 ) {
121: case ValueType ::@expr1073744942 INT :@expr3119
122: case ValueType ::@expr1073744944 CONTAINER_SIZE :@expr3119
123: case ValueType ::@expr1073744946 BUFFER_SIZE :@expr3119
124: case ValueType ::@expr1073744948 ITERATOR_START :@expr3119
125: case ValueType ::@expr1073744950 ITERATOR_END :@expr3119 ;
126: if (@expr3128 intvalue@var970 !=@expr3129 rhs@var932 .@expr3130 intvalue@var934 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744955 TOK :@expr3119 ;
130: if (@expr3133 tokvalue@var971 !=@expr3134 rhs@var932 .@expr3135 tokvalue@var935 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744960 FLOAT :@expr3119 ;
134:
135: if (@expr1073744962 floatValue@var972 >@expr1073744963 rhs@var932 .@expr3140 floatValue@var936 ||@expr1073744965 floatValue@var972 <@expr1073744966 rhs@var932 .@expr3140 floatValue@var936 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744968 MOVED :@expr3119 ;
139: if (@expr1073744970 moveKind@var973 !=@expr1073744971 rhs@var932 .@expr1073744972 moveKind@var937 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744973 UNINIT :@expr3119 ;
143: break ;
144: case ValueType ::@expr1073744975 LIFETIME :@expr3119 ;
145: if (@expr3133 tokvalue@var971 !=@expr3134 rhs@var932 .@expr3135 tokvalue@var935 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744980 SYMBOLIC :@expr3119 ;
149: if (@expr1073744982 !@expr1073744983 sameToken (@expr1073744984 tokvalue@var971 , rhs@var932 .@expr3135 tokvalue@var935 ) ) {
150: return false ; }
151: if (@expr3128 intvalue@var970 !=@expr3129 rhs@var932 .@expr3130 intvalue@var934 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var938 , F f@var939 ) {
160: switch (@expr1073744989 self@var938 .@expr1073744990 valueType@var940 ) {
161: case ValueType ::@expr1073744991 INT :@expr3168
162: case ValueType ::@expr1073744993 SYMBOLIC :@expr3168
163: case ValueType ::@expr1073744995 BUFFER_SIZE :@expr3168
164: case ValueType ::@expr1073744997 CONTAINER_SIZE :@expr3168
165: case ValueType ::@expr1073744999 ITERATOR_START :@expr3168
166: case ValueType ::@expr1073745001 ITERATOR_END :@expr3168 ; {
167: f@var939 (@expr1073745003 self@var938 .@expr1073745004 intvalue@var941 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745005 FLOAT :@expr3168 ; {
171: f@var939 (@expr1073745007 self@var938 .@expr1073745008 floatValue@var942 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745009 UNINIT :@expr3168
175: case ValueType ::@expr1073745011 TOK :@expr3168
176: case ValueType ::@expr1073745013 LIFETIME :@expr3168
177: case ValueType ::@expr1073745015 MOVED :@expr3168 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var943 , Compare compare@var944 , T x@var945 , U y@var946 ) const {
186: result@var943 =@expr1073745017 compare@var944 (@expr1073745018 x@var945 , y@var946 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var947 , const Value & rhs@var948 , Compare compare@var949 , T x@var950 ) const {
191: visitValue (@expr1073745020 rhs@var948 ,
192: std ::@expr1073745021 bind (@expr1073745022 innerVisitor {@expr1073745023 } , std ::@expr1073745024 ref (@expr1073745025 result@var947 ) , std ::@expr1073745026 move (@expr1073745027 compare@var949 ) , x@var950 , std ::@expr1073745028 placeholders ::@expr1073745029 _1@expr1073745019 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var951 , Compare compare@var952 ) const {
198: assert (@expr1073745031 (@expr1073745032 !@expr1073745033 this@expr3210 .@expr1073745035 isSymbolicValue (@expr1073745036 ) &&@expr1073745037 !@expr1073745038 rhs@var951 .@expr1073745039 isSymbolicValue (@expr1073745040 ) ) ||@expr1073745041
199: (@expr1073745042 this@expr3210 .@expr1073745043 valueType@var968 ==@expr1073745044 rhs@var951 .@expr1073745045 valueType@var953 &&@expr1073745046 sameToken (@expr1073745047 this@expr3210 .@expr1073745048 tokvalue@var971 , rhs@var951 .@expr1073745049 tokvalue@var954 ) ) ) ;
200: bool result@var955 ; result@var955 =@expr1073745050 false ;
201: visitValue (@expr1073745051
202: *@expr1073745052 this@expr3210 ,
203: std ::@expr1073745053 bind (@expr1073745054 compareVisitor {@expr1073745055 } , std ::@expr3232 ref (@expr1073745057 result@var955 ) , std ::@expr3232 ref (@expr1073745059 rhs@var951 ) , std ::@expr1073745060 move (@expr1073745061 compare@var952 ) , std ::@expr1073745062 placeholders ::@expr1073745063 _1@expr1073745030 ) ) ;
204: return result@var955 ;
205: }
206:
207: bool operator== ( const Value & rhs@var956 ) const {
208: if (@expr1073745064 !@expr1073745065 equalValue (@expr1073745066 rhs@var956 ) ) {
209: return false ; }
210:
211: return varvalue@var974 ==@expr1073745067 rhs@var956 .@expr1073745068 varvalue@var957 &&@expr1073745069
212: condition@var975 ==@expr1073745070 rhs@var956 .@expr1073745071 condition@var958 &&@expr1073745072
213: varId@var977 ==@expr1073745073 rhs@var956 .@expr1073745074 varId@var959 &&@expr1073745075
214: conditional@var979 ==@expr1073745076 rhs@var956 .@expr1073745077 conditional@var960 &&@expr1073745078
215: defaultArg@var981 ==@expr1073745079 rhs@var956 .@expr1073745080 defaultArg@var961 &&@expr1073745081
216: indirect@var982 ==@expr1073745082 rhs@var956 .@expr1073745083 indirect@var962 &&@expr1073745084
217: valueKind@var993 ==@expr1073745085 rhs@var956 .@expr1073745086 valueKind@var963 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var964 ) const {
221: return !@expr1073745087 (@expr1073745088 *@expr1073745089 this@expr1073745090 ==@expr1073745091 rhs@var964 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var965 ) const {
226: bool result@var966 ; result@var966 =@expr1073745093 false ;
227: visitValue (@expr1073745094 *@expr1073745095 this@expr1073745096 , std ::@expr1073745097 bind (@expr1073745098 equalVisitor {@expr1073745099 } , std ::@expr1073745100 ref (@expr1073745101 result@var966 ) , x@var965 , std ::@expr1073745102 placeholders ::@expr1073745103 _1@expr1073745092 ) ) ;
228: return result@var966 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745104 bound@var969 ==@expr1073745105 Bound ::@expr1073745106 Lower ) {
233: visitValue (@expr1073745107 *@expr3284 this@expr3285 , increment {@expr1073745110 } ) ; }
234: else { if (@expr1073745111 bound@var969 ==@expr1073745112 Bound ::@expr1073745113 Upper ) {
235: visitValue (@expr1073745114 *@expr3284 this@expr3285 , decrement {@expr1073745116 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745117 bound@var969 ==@expr1073745118 Bound ::@expr3295 Lower ) {
240: bound@var969 =@expr1073745120 Bound ::@expr3297 Upper ; }
241: else { if (@expr1073745122 bound@var969 ==@expr1073745123 Bound ::@expr3297 Upper ) {
242: bound@var969 =@expr1073745125 Bound ::@expr3295 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745127 ) ;
247: decreaseRange (@expr1073745128 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var967 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var968 ;
267: bool isIntValue ( ) const {
268: return valueType@var968 ==@expr1073745129 ValueType ::@expr1073745130 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var968 ==@expr1073745131 ValueType ::@expr1073745132 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var968 ==@expr1073745133 ValueType ::@expr1073745134 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var968 ==@expr1073745135 ValueType ::@expr1073745136 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var968 ==@expr1073745137 ValueType ::@expr1073745138 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var968 ==@expr1073745139 ValueType ::@expr1073745140 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var968 ==@expr1073745141 ValueType ::@expr1073745142 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var968 ==@expr1073745143 ValueType ::@expr1073745144 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var968 ==@expr1073745145 ValueType ::@expr1073745146 ITERATOR_START ||@expr1073745147 valueType@var968 ==@expr1073745148 ValueType ::@expr1073745149 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var968 ==@expr1073745150 ValueType ::@expr1073745151 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var968 ==@expr1073745152 ValueType ::@expr1073745153 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var968 ==@expr1073745154 ValueType ::@expr1073745155 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var968 ==@expr1073745157 ValueType ::@expr1073745158 LIFETIME &&@expr1073745159 lifetimeScope@var988 ==@expr1073745160 LifetimeScope ::@expr1073745161 Local@expr1073745156 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var968 ==@expr1073745162 ValueType ::@expr1073745163 LIFETIME &&@expr1073745164 lifetimeScope@var988 ==@expr1073745165 LifetimeScope ::@expr1073745166 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var968 ==@expr1073745167 ValueType ::@expr1073745168 LIFETIME &&@expr1073745169 lifetimeScope@var988 ==@expr1073745170 LifetimeScope ::@expr1073745171 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745172 ) ||@expr1073745173 isUninitValue (@expr1073745174 ) ||@expr1073745175 isLifetimeValue (@expr1073745176 ) ;
318: }
319:
320:
321: Bound bound@var969 ;
322:
323:
324: long long intvalue@var970 ;
325:
326:
327: const Token * tokvalue@var971 ;
328:
329:
330: double floatValue@var972 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var973 ;
334:
335:
336: long long varvalue@var974 ;
337:
338:
339: const Token * condition@var975 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var976 ;
342:
343:
344: int varId@var977 ;
345:
346:
347: bool safe@var978 ;
348:
349:
350: bool conditional@var979 ;
351:
352:
353: bool macro@var980 ;
354:
355:
356: bool defaultArg@var981 ;
357:
358: int indirect@var982 ;
359:
360:
361: long long path@var983 ;
362:
363:
364: long long wideintvalue@var984 ;
365:
366: std :: vector < std :: string > subexpressions@var985 ;
367:
368:
369: const Token * capturetok@var986 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var987 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var988 ;
385:
386: static const char * toString ( MoveKind moveKind@var989 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var990 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var991 ) ;
389: static const char * toString ( Bound bound@var992 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var993 ;
402:
403: void setKnown ( ) {
404: valueKind@var993 =@expr1073745177 ValueKind ::@expr1073745178 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var993 ==@expr1073745179 ValueKind ::@expr1073745180 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var993 =@expr1073745182 ValueKind ::@expr1073745183 Possible@expr1073745181 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var993 ==@expr1073745185 ValueKind ::@expr1073745186 Possible@expr1073745184 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var993 ==@expr1073745187 ValueKind ::@expr1073745188 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var993 =@expr1073745189 ValueKind ::@expr1073745190 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var994 = true ) {
428: if (@expr1073745191 inconclusive@var994 ) {
429: valueKind@var993 =@expr1073745192 ValueKind ::@expr1073745193 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var993 ==@expr1073745194 ValueKind ::@expr1073745195 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745197 isKnown (@expr1073745198 ) ) {
438: valueKind@var993 =@expr1073745199 ValueKind ::@expr1073745200 Possible@expr1073745196 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745201 condition@var975 &&@expr1073745202 !@expr1073745203 defaultArg@var981 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var995 , const Token * tok2@var996 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var997 , const Settings * settings@var998 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var999 , SymbolDatabase * symboldatabase@var1000 , ErrorLogger * errorLogger@var1001 , const Settings * settings@var1002 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var1003 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var1004 , const Settings * settings@var1005 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var1006 ,
459: const Settings * settings@var1007 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var1008 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var1009 , const Token * indexTok@var1010 , bool possible@var1011 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var1012 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var1013 , const Settings * settings@var1014 = nullptr , int depth@var1015 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var1016 ;
471: bool addressOf@var1017 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1018 ;
473: bool inconclusive@var1019 ;
474:
475: LifetimeToken ( ) : token@var1016 ( nullptr ) , addressOf@var1017 ( false ) , errorPath@var1018 ( ) , inconclusive@var1019 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var1020 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1021 )
478: : token@var1016 ( token@var1020 ) , addressOf@var1017 ( false ) , errorPath@var1018 ( std :: move ( errorPath@var1021 ) ) , inconclusive@var1019 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var1022 , bool addressOf@var1023 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1024 )
482: : token@var1016 ( token@var1022 ) , addressOf@var1017 ( addressOf@var1023 ) , errorPath@var1018 ( std :: move ( errorPath@var1024 ) ) , inconclusive@var1019 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var1025 , bool b@var1026 ) {
486: for (@expr1073745204 LifetimeToken &@expr1073745205 x@var1027 :@expr1073745206 v@var1025 ) {
487: x@var1027 .@expr1073745207 addressOf@var1028 =@expr1073745208 b@var1026 ; }
488: return v@var1025 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var1029 , bool b@var1030 ) {
492: for (@expr1073745209 LifetimeToken &@expr1073745210 x@var1031 :@expr1073745211 v@var1029 ) {
493: x@var1031 .@expr1073745212 inconclusive@var1032 =@expr1073745213 b@var1030 ; }
494: return v@var1029 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var1033 , ValueFlow :: Value & true_value@var1034 , ValueFlow :: Value & false_value@var1035 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var1036 ) ;
499: const Token * parseCompareInt ( const Token * tok@var1037 , ValueFlow :: Value & true_value@var1038 , ValueFlow :: Value & false_value@var1039 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var1040 , long long val@var1041 , const Token * varTok@var1042 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var1043 , const Token * varTok@var1044 , long long val@var1045 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var1046 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var1047 ,
508: ValueFlow :: Value & value@var1048 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var1049 ,
511: bool escape@var1050 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1051 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var1052 , const Token * lifetime@var1053 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var1054 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1055 , bool * addressOf@var1056 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var1057 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var1058 , const Settings * settings@var1059 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var1060 , const ValueFlow :: Value * val@var1061 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var1062 , const ValueFlow :: Value * val@var1063 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1064 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var1065 , bool inconclusive@var1066 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var1067 ,
529: bool inconclusive@var1068 = false ,
530: long long path@var1069 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var1070 , const Scope * defaultScope@var1071 = nullptr , bool smallest@var1072 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var1073 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var1074 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var1075 ;
69: std :: string mScope@var1076 ;
70: std :: string mName@var1077 ;
71: std :: string mFullName@var1078 ;
72: const Token * mNameToken@var1079 ;
73: const Token * mParamEnd@var1080 ;
74: unsigned int mFlags@var1081 ;
75:
76: enum Anonymous2 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var1082 ) {
90: setFlag (@expr1073745214 fIsClass , state@var1082 ) ;
91: }
92: void isFunction ( bool state@var1083 ) {
93: setFlag (@expr1073745215 fIsFunction , state@var1083 ) ;
94: }
95: void isVariable ( bool state@var1084 ) {
96: setFlag (@expr1073745216 fIsVariable , state@var1084 ) ;
97: }
98: void isAlias ( bool state@var1085 ) {
99: setFlag (@expr1073745217 fIsAlias , state@var1085 ) ;
100: }
101: void isSpecialization ( bool state@var1086 ) {
102: setFlag (@expr1073745218 fIsSpecialization , state@var1086 ) ;
103: }
104: void isPartialSpecialization ( bool state@var1087 ) {
105: setFlag (@expr1073745219 fIsPartialSpecialization , state@var1087 ) ;
106: }
107: void isForwardDeclaration ( bool state@var1088 ) {
108: setFlag (@expr1073745220 fIsForwardDeclaration , state@var1088 ) ;
109: }
110: void isVariadic ( bool state@var1089 ) {
111: setFlag (@expr1073745221 fIsVariadic , state@var1089 ) ;
112: }
113: void isFriend ( bool state@var1090 ) {
114: setFlag (@expr1073745222 fIsFriend , state@var1090 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var1091 ) const {
123: return (@expr3399 (@expr3399 mFlags@var1081 &@expr1073745225 flag@var1091 ) !=@expr1073745226 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var1092 , bool state@var1093 ) {
132: mFlags@var1081 =@expr1073745227 state@var1093 ?@expr1073745228 mFlags@var1081 |@expr1073745229 flag@var1092 :@expr1073745230 mFlags@var1081 &@expr1073745231 ~@expr1073745232 flag@var1092 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var1094 , const std :: string & scope@var1095 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var1096 , const std :: string & scope@var1097 , const Token * nameToken@var1098 , const Token * paramEnd@var1099 ) ;
150: TokenAndName ( const TokenAndName & other@var1100 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var1101 ) const {
154: return mToken@var1075 ==@expr1073745233 rhs@var1101 .@expr1073745234 mToken@var1102 &&@expr1073745235 mScope@var1076 ==@expr1073745236 rhs@var1101 .@expr1073745237 mScope@var1103 &&@expr1073745238 mName@var1077 ==@expr1073745239 rhs@var1101 .@expr1073745240 mName@var1104 &&@expr1073745241 mFullName@var1078 ==@expr1073745242 rhs@var1101 .@expr1073745243 mFullName@var1105 &&@expr1073745244
155: mNameToken@var1079 ==@expr1073745245 rhs@var1101 .@expr1073745246 mNameToken@var1106 &&@expr1073745247 mParamEnd@var1080 ==@expr1073745248 rhs@var1101 .@expr1073745249 mParamEnd@var1107 &&@expr1073745250 mFlags@var1081 ==@expr1073745251 rhs@var1101 .@expr1073745252 mFlags@var1108 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var1075 ;
160: }
161: void token ( Token * token@var1109 ) {
162: mToken@var1075 =@expr1073745253 token@var1109 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var1076 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var1077 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var1078 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var1079 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var1080 ;
178: }
179: void paramEnd ( const Token * end@var1110 ) {
180: mParamEnd@var1080 =@expr1073745254 end@var1110 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745255 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745256 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745257 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745258 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745259 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745260 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745261 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745262 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745263 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var1111 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var1112 ) const {
243:
244:
245: return (@expr3440 (@expr3440 mFlags@var1081 &@expr1073745266 fFamilyMask ) &@expr1073745267 (@expr3440 decl@var1112 .@expr1073745269 mFlags@var1113 &@expr1073745270 fFamilyMask ) ) !=@expr1073745271 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var1114 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var1115 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var1116 , const unsigned long numberOfArguments@var1117 , bool variadic@var1118 , const char patternAfter@var1119 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var1120 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var1121 , int & namepos@var1122 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var1123 , int & namepos@var1124 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var1125 , int & namepos@var1126 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var1127 ,
306: bool & codeWithTemplates@var1128 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var1129 , bool isTemplate@var1130 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var1131 = nullptr , Token * backToken@var1132 = nullptr , bool isTemplate@var1133 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var1134 , Token * end@var1135 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var1136 , const std :: string & scope@var1137 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var1138 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var1139 ,
393: const std :: list < const Token * > & specializations@var1140 ,
394: const std :: time_t maxtime@var1141 ,
395: std :: set < std :: string > & expandedtemplates@var1142 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var1143 , const Token * tok@var1144 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1145 , const Token * tok@var1146 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var1147 ,
422: const TokenAndName & templateInstantiation@var1148 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var1149 ,
424: const std :: string & newName@var1150 ,
425: bool copy@var1151 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var1152 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1153 ,
435: const std :: string & newName@var1154 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var1155 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var1156 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var1157 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var1158 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var1159 ,
458: const Token * templateInstantiationNameToken@var1160 ,
459: const std :: list < const Token * > & specializations@var1161 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var1162 , const Token * end@var1163 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var1164 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var1165 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1166 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var1167 ,
487: const std :: string & indent@var1168 = "    " ) const ;
488: void printOut ( const std :: string & text@var1169 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var1170 ;
491: TokenList & mTokenList@var1171 ;
492: const Settings * mSettings@var1172 ;
493: ErrorLogger * mErrorLogger@var1173 ;
494: bool mChanged@var1174 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var1175 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var1176 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var1177 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var1178 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var1179 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var1180 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var1181 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var1182 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var1183 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var1184 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var1185 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1186 ;
57: Token * back@var1187 ;
58: const TokenList * list@var1188 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1189 , const Token * bodyEnd_@var1190 , const std :: set < std :: string > & usingNamespaces_@var1191 = std :: set < std :: string > ( ) ) : name@var1192 ( name_@var1189 ) , bodyEnd@var1193 ( bodyEnd_@var1190 ) , usingNamespaces@var1194 ( usingNamespaces_@var1191 ) { }
63: std :: string name@var1192 ;
64: const Token * const bodyEnd@var1193 ;
65: std :: set < std :: string > usingNamespaces@var1194 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1195 ;
70: int mFileIndex@var1196 ;
71: int mLineNumber@var1197 ;
72: int mColumn@var1198 ;
73: int mExprId@var1199 ;
74:
75:
76: Token * mAstOperand1@var1200 ;
77: Token * mAstOperand2@var1201 ;
78: Token * mAstParent@var1202 ;
79:
80:
81: const Scope * mScope@var1203 ;
82: union {
83: const Function * mFunction@var1204 ;
84: const Variable * mVariable@var1205 ;
85: const :: Type * mType@var1206 ;
86: const Enumerator * mEnumerator@var1207 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1208 ;
94:
|
97:
98: int mIndex@var1209 ;
99:
100:
101: std :: string * mOriginalName@var1210 ;
102:
103:
104: ValueType * mValueType@var1211 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1212 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1213 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1214 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1215 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1216 ;
119: long long value@var1217 ;
120: struct CppcheckAttributes * next@var1218 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1219 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1220 ;
126:
127:
128: unsigned char mBits@var1221 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1222 , long long value@var1223 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1224 , long long * value@var1225 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1195 ( 0 )
135: , mFileIndex@var1196 ( 0 )
136: , mLineNumber@var1197 ( 0 )
137: , mColumn@var1198 ( 0 )
138: , mExprId@var1199 ( 0 )
139: , mAstOperand1@var1200 ( nullptr )
140: , mAstOperand2@var1201 ( nullptr )
141: , mAstParent@var1202 ( nullptr )
142: , mScope@var1203 ( nullptr )
143: , mFunction@var1204 ( nullptr )
144: , mProgressValue@var1208 ( 0 )
145: , mIndex@var1209 ( 0 )
146: , mOriginalName@var1210 ( nullptr )
147: , mValueType@var1211 ( nullptr )
148: , mValues@var1212 ( nullptr )
149: , mTemplateSimplifierPointers@var1214 ( nullptr )
150: , mScopeInfo@var1215 ( nullptr )
151: , mCppcheckAttributes@var1219 ( nullptr )
152: , mCpp11init@var1220 ( Cpp11init :: UNKNOWN )
153: , mBits@var1221 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1226 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1227 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1228 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1229 ) {
199: mStr@var1441 =@expr1073745272 s@var1229 ;
200: mImpl@var1447 .@expr1073745273 mVarId@var1478 =@expr1073745274 0 ;
201:
202: update_property_info (@expr1073745275 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1230 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1441 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1231 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1232 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1233 ) const ;
236: Token * tokAt ( int index@var1234 ) {
237: return const_cast < Token *@expr3452 > (@expr1073745277 const_cast < const Token *@expr3452 > (@expr1073745279 this@expr1073745280 ) .@expr1073745281 tokAt (@expr1073745282 index@var1234 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1235 ) const ;
245: Token * linkAt ( int index@var1236 ) {
246: return const_cast < Token *@expr3459 > (@expr1073745284 const_cast < const Token *@expr3459 > (@expr1073745286 this@expr1073745287 ) .@expr1073745288 linkAt (@expr1073745289 index@var1236 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1237 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1238 , const char ( & pattern@var1239 ) [ count ] ) {
276: return simpleMatch (@expr1073745291 tok@var1238 , pattern@var1239 , count@expr1073745290 -@expr1073745292 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1240 , const char pattern@var1241 [ ] , unsigned long pattern_len@var1242 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1243 , const char pattern@var1244 [ ] , int varid@var1245 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1246 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1247 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1248 , const Settings * const settings@var1249 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1250 , long long index@var1251 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1447 .@expr1073745293 mValueType@var1479 ;
366: }
367: void setValueType ( ValueType * vt@var1252 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1253 ; top@var1253 =@expr1073745294 this@expr1073745295 ;
371: while (@expr1073745296 top@var1253 &&@expr1073745297 !@expr1073745298 Token ::@expr1073745299 Match (@expr1073745300 top@var1253 .@expr3477 astParent (@expr3478 ) , ",|(" ) ) {
372: top@var1253 =@expr1073745303 top@var1253 .@expr3477 astParent (@expr3478 ) ; }
373: return top@var1253 ?@expr1073745306 top@var1253 .@expr1073745307 mImpl@var1254 .@expr1073745308 mValueType@var1255 :@expr1073745309 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1445 ;
378: }
379: void tokType ( Token :: Type t@var1256 ) {
380: mTokType@var1445 =@expr1073745310 t@var1256 ;
381:
382: const bool memoizedIsName@var1257 =@expr1073745311 mTokType@var1445 ==@expr1073745312 eName ||@expr1073745313 mTokType@var1445 ==@expr1073745314 eType ||@expr1073745315 mTokType@var1445 ==@expr1073745316 eVariable ||@expr1073745317
383: mTokType@var1445 ==@expr1073745318 eFunction ||@expr1073745319 mTokType@var1445 ==@expr1073745320 eKeyword ||@expr1073745321 mTokType@var1445 ==@expr3498 eBoolean ||@expr1073745323
384: mTokType@var1445 ==@expr3500 eEnumerator ;
385: setFlag (@expr1073745325 fIsName , memoizedIsName@var1257 ) ;
386:
387: const bool memoizedIsLiteral@var1258 =@expr1073745326 mTokType@var1445 ==@expr1073745327 eNumber ||@expr1073745328 mTokType@var1445 ==@expr1073745329 eString ||@expr1073745330 mTokType@var1445 ==@expr1073745331 eChar ||@expr1073745332
388: mTokType@var1445 ==@expr3498 eBoolean ||@expr1073745334 mTokType@var1445 ==@expr1073745335 eLiteral ||@expr1073745336 mTokType@var1445 ==@expr3500 eEnumerator ;
389: setFlag (@expr1073745338 fIsLiteral , memoizedIsLiteral@var1258 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1445 ==@expr1073745339 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745340 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1446 ==@expr1073745341 fIsName &&@expr1073745342 mTokType@var1445 ==@expr1073745343 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745344 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1445 ==@expr1073745345 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1445 ==@expr1073745346 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745347 isConstOp (@expr1073745348 ) ||@expr1073745349
412: isAssignmentOp (@expr1073745350 ) ||@expr1073745351
413: mTokType@var1445 ==@expr1073745352 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745353 isArithmeticalOp (@expr1073745354 ) ||@expr1073745355
417: mTokType@var1445 ==@expr1073745356 eLogicalOp ||@expr1073745357
418: mTokType@var1445 ==@expr1073745358 eComparisonOp ||@expr1073745359
419: mTokType@var1445 ==@expr1073745360 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745361 ) ||@expr1073745362
423: mTokType@var1445 ==@expr1073745363 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1445 ==@expr1073745364 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1445 ==@expr1073745365 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1445 ==@expr1073745366 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1445 ==@expr1073745367 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1445 ==@expr1073745368 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745369 ) !=@expr1073745370 nullptr &&@expr1073745371 astOperand2 (@expr1073745372 ) !=@expr1073745373 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1259 ) const {
444: return s@var1259 ==@expr1073745374 mStr@var1441 &&@expr1073745375 astOperand1 (@expr1073745376 ) !=@expr1073745377 nullptr &&@expr1073745378 astOperand2 (@expr1073745379 ) ==@expr1073745380 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1446 ;
450: }
451: void flags ( const unsigned int flags_@var1260 ) {
452: mFlags@var1446 =@expr1073745381 flags_@var1260 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745382 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1261 ) {
458: setFlag (@expr1073745383 fIsUnsigned , sign@var1261 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745384 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1262 ) {
464: setFlag (@expr1073745385 fIsSigned , sign@var1262 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745386 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1263 ) {
470: setFlag (@expr1073745387 fIsPointerCompare , b@var1263 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745388 fIsLong ) ;
474: }
475: void isLong ( bool size@var1264 ) {
476: setFlag (@expr1073745389 fIsLong , size@var1264 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745390 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1265 ) {
482: setFlag (@expr1073745391 fIsStandardType , b@var1265 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745392 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1266 ) {
488: setFlag (@expr1073745393 fIsExpandedMacro , m@var1266 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745394 fIsCast ) ;
492: }
493: void isCast ( bool c@var1267 ) {
494: setFlag (@expr1073745395 fIsCast , c@var1267 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745396 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1268 ) {
500: setFlag (@expr1073745397 fIsAttributeConstructor , ac@var1268 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745398 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1269 ) {
506: setFlag (@expr1073745399 fIsAttributeDestructor , value@var1269 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745400 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1270 ) {
512: setFlag (@expr1073745401 fIsAttributeUnused , unused@var1270 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745402 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1271 ) {
518: setFlag (@expr1073745403 fIsAttributeUsed , unused@var1271 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745404 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1272 ) {
524: setFlag (@expr1073745405 fIsAttributePure , value@var1272 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745406 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1273 ) {
530: setFlag (@expr1073745407 fIsAttributeConst , value@var1273 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745408 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1274 ) {
536: setFlag (@expr1073745409 fIsAttributeNoreturn , value@var1274 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745410 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1275 ) {
542: setFlag (@expr1073745411 fIsAttributeNothrow , value@var1275 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745412 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1276 ) {
548: setFlag (@expr1073745413 fIsAttributePacked , value@var1276 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745414 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1277 ) {
554: setFlag (@expr1073745415 fIsAttributeNodiscard , value@var1277 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745416 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1278 ) {
560: setFlag (@expr1073745417 fIsAttributeMaybeUnused , value@var1278 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1279 , long long value@var1280 ) {
563: mImpl@var1447 .@expr1073745418 setCppcheckAttribute (@expr1073745419 type@var1279 , value@var1280 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1281 , long long * value@var1282 ) const {
566: return mImpl@var1447 .@expr1073745420 getCppcheckAttribute (@expr1073745421 type@var1281 , value@var1282 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745422 mImpl@var1447 .@expr1073745423 mCppcheckAttributes@var1480 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745424 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745425 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1283 ) {
578: setFlag (@expr1073745426 fIsOperatorKeyword , value@var1283 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745427 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1284 ) {
584: setFlag (@expr1073745428 fIsComplex , value@var1284 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745429 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1285 ) {
590: setFlag (@expr1073745430 fIsEnumType , value@var1285 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745431 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1286 ) {
596: setFlag (@expr1073745432 fAtAddress , b@var1286 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745433 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1287 ) {
602: setFlag (@expr1073745434 fIncompleteVar , b@var1287 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745435 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1288 ) {
609: setFlag (@expr1073745436 fIsIncompleteConstant , b@var1288 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745437 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1289 ) {
616: setFlag (@expr1073745438 fConstexpr , b@var1289 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745439 fExternC ) ;
621: }
622: void isExternC ( bool b@var1290 ) {
623: setFlag (@expr1073745440 fExternC , b@var1290 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745441 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1291 ) {
630: setFlag (@expr1073745442 fIsSplitVarDeclComma , b@var1291 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745443 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1292 ) {
637: setFlag (@expr1073745444 fIsSplitVarDeclEq , b@var1292 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745445 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1293 ) {
644: setFlag (@expr1073745446 fIsImplicitInt , b@var1293 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745447 fIsInline ) ;
649: }
650: void isInline ( bool b@var1294 ) {
651: setFlag (@expr1073745448 fIsInline , b@var1294 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745449 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1295 ) {
658: setFlag (@expr1073745450 fIsRemovedVoidParameter , b@var1295 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745451 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1296 ) {
665: setFlag (@expr1073745452 fIsTemplate , b@var1296 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745453 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1297 ) {
672: setFlag (@expr1073745454 fIsSimplifedScope , b@var1297 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1447 .@expr1073745455 mBits@var1481 >@expr1073745456 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1447 .@expr1073745457 mBits@var1481 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1447 .@expr1073745458 mTemplateSimplifierPointers@var1482 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1298 ) {
685: if (@expr1073745459 !@expr1073745460 mImpl@var1447 .@expr3637 mTemplateSimplifierPointers@var1482 ) {
686: mImpl@var1447 .@expr3637 mTemplateSimplifierPointers@var1482 =@expr1073745463 new std ::@expr1073745464 set < TemplateSimplifier ::@expr1073745465 TokenAndName *@expr1073745466 > ; }
687: mImpl@var1447 .@expr3637 mTemplateSimplifierPointers@var1482 .@expr1073745468 insert (@expr1073745469 tokenAndName@var1298 ) ;
688: }
689: void setBits ( const unsigned char b@var1299 ) {
690: mImpl@var1447 .@expr1073745470 mBits@var1481 =@expr1073745471 b@var1299 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3648 (@expr3648 (@expr3648 mTokType@var1445 ==@expr1073745475 eString ) &&@expr1073745476 isPrefixStringCharLiteral (@expr1073745477 mStr@var1441 , '"' , "u8" ) ) ||@expr1073745478
695: (@expr3648 (@expr3648 mTokType@var1445 ==@expr1073745481 eChar ) &&@expr1073745482 isPrefixStringCharLiteral (@expr1073745483 mStr@var1441 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3660 (@expr3660 (@expr3660 mTokType@var1445 ==@expr1073745487 eString ) &&@expr1073745488 isPrefixStringCharLiteral (@expr1073745489 mStr@var1441 , '"' , "u" ) ) ||@expr1073745490
700: (@expr3660 (@expr3660 mTokType@var1445 ==@expr1073745493 eChar ) &&@expr1073745494 isPrefixStringCharLiteral (@expr1073745495 mStr@var1441 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3672 (@expr3672 (@expr3672 mTokType@var1445 ==@expr1073745499 eString ) &&@expr1073745500 isPrefixStringCharLiteral (@expr1073745501 mStr@var1441 , '"' , "U" ) ) ||@expr1073745502
705: (@expr3672 (@expr3672 mTokType@var1445 ==@expr1073745505 eChar ) &&@expr1073745506 isPrefixStringCharLiteral (@expr1073745507 mStr@var1441 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3684 (@expr3684 (@expr3684 mTokType@var1445 ==@expr1073745511 eString ) &&@expr1073745512 isPrefixStringCharLiteral (@expr1073745513 mStr@var1441 , '"' , "" ) ) ||@expr1073745514
710: (@expr3684 (@expr3684 mTokType@var1445 ==@expr1073745517 eChar ) &&@expr1073745518 isPrefixStringCharLiteral (@expr1073745519 mStr@var1441 , '\'' , "" ) &&@expr1073745520 mStr@var1441 .@expr1073745521 length (@expr1073745522 ) ==@expr1073745523 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3700 (@expr3700 (@expr3700 mTokType@var1445 ==@expr1073745527 eChar ) &&@expr1073745528 isPrefixStringCharLiteral (@expr1073745529 mStr@var1441 , '\'' , "" ) ) &&@expr1073745530
715: (@expr3700 mStr@var1441 .@expr1073745532 length (@expr1073745533 ) >@expr1073745534 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745535 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1300 ) {
738: setFlag (@expr1073745536 fIsTemplateArg , value@var1300 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1301 , const char ( & pattern@var1302 ) [ count ] ) {
743: return findsimplematch (@expr1073745538 startTok@var1301 , pattern@var1302 , count@expr1073745537 -@expr1073745539 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1303 , const char pattern@var1304 [ ] , unsigned long pattern_len@var1305 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1306 , const char ( & pattern@var1307 ) [ count ] , const Token * const end@var1308 ) {
749: return findsimplematch (@expr1073745541 startTok@var1306 , pattern@var1307 , count@expr1073745540 -@expr1073745542 1 , end@var1308 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1309 , const char pattern@var1310 [ ] , unsigned long pattern_len@var1311 , const Token * const end@var1312 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1313 , const char pattern@var1314 [ ] , const int varId@var1315 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1316 , const char pattern@var1317 [ ] , const Token * const end@var1318 , const int varId@var1319 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1320 , const char ( & pattern@var1321 ) [ count ] ) {
758: return findsimplematch (@expr1073745544 startTok@var1320 , pattern@var1321 , count@expr1073745543 -@expr1073745545 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1322 , const char pattern@var1323 [ ] , unsigned long pattern_len@var1324 ) {
761: return const_cast < Token *@expr3722 > (@expr1073745547 findsimplematch (@expr1073745548 const_cast < const Token *@expr3722 > (@expr1073745550 startTok@var1322 ) , pattern@var1323 , pattern_len@var1324 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1325 , const char ( & pattern@var1326 ) [ count ] , const Token * const end@var1327 ) {
765: return findsimplematch (@expr1073745552 startTok@var1325 , pattern@var1326 , count@expr1073745551 -@expr1073745553 1 , end@var1327 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1328 , const char pattern@var1329 [ ] , unsigned long pattern_len@var1330 , const Token * const end@var1331 ) {
768: return const_cast < Token *@expr3730 > (@expr1073745555 findsimplematch (@expr1073745556 const_cast < const Token *@expr3730 > (@expr1073745558 startTok@var1328 ) , pattern@var1329 , pattern_len@var1330 , end@var1331 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1332 , const char pattern@var1333 [ ] , const int varId@var1334 = 0 ) {
772: return const_cast < Token *@expr3735 > (@expr1073745560 findmatch (@expr1073745561 const_cast < const Token *@expr3735 > (@expr1073745563 startTok@var1332 ) , pattern@var1333 , varId@var1334 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1335 , const char pattern@var1336 [ ] , const Token * const end@var1337 , const int varId@var1338 = 0 ) {
775: return const_cast < Token *@expr3740 > (@expr1073745565 findmatch (@expr1073745566 const_cast < const Token *@expr3740 > (@expr1073745568 startTok@var1335 ) , pattern@var1336 , end@var1337 , varId@var1338 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1339 , const char * haystack@var1340 , int varid@var1341 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1447 .@expr1073745569 mFileIndex@var1483 ;
796: }
797: void fileIndex ( int indexOfFile@var1342 ) {
798: mImpl@var1447 .@expr1073745570 mFileIndex@var1483 =@expr1073745571 indexOfFile@var1342 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1447 .@expr1073745572 mLineNumber@var1484 ;
803: }
804: void linenr ( int lineNumber@var1343 ) {
805: mImpl@var1447 .@expr1073745573 mLineNumber@var1484 =@expr1073745574 lineNumber@var1343 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1447 .@expr1073745575 mColumn@var1485 ;
810: }
811: void column ( int c@var1344 ) {
812: mImpl@var1447 .@expr1073745576 mColumn@var1485 =@expr1073745577 c@var1344 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1442 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1345 , const Token * end@var1346 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1347 , const std :: string & originalNameStr@var1348 = emptyString@var1 , bool prepend@var1349 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1350 , const std :: string & originalNameStr@var1351 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745578 tokenStr@var1350 , originalNameStr@var1351 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1443 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1447 .@expr1073745579 mVarId@var1478 ;
851: }
852: void varId ( int id@var1352 ) {
853: mImpl@var1447 .@expr1073745580 mVarId@var1478 =@expr1073745581 id@var1352 ;
854: if (@expr1073745582 id@var1352 !=@expr1073745583 0 ) {
855: tokType (@expr1073745584 eVariable ) ;
856: isStandardType (@expr1073745585 false ) ;
857: } else {
858: update_property_info (@expr1073745586 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745587 mImpl@var1447 .@expr3764 mExprId@var1486 ) {
864: return mImpl@var1447 .@expr3764 mExprId@var1486 ; }
865: return mImpl@var1447 .@expr1073745590 mVarId@var1478 ;
866: }
867: void exprId ( int id@var1353 ) {
868: mImpl@var1447 .@expr1073745591 mExprId@var1486 =@expr1073745592 id@var1353 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1354 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1355 , const std :: vector < std :: string > & fileNames@var1356 ) const ;
888:
|
891:
892: void printLines ( int lines@var1357 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1358 , Token * start@var1359 , Token * end@var1360 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1361 ; varid@var1361 = false ;
905: bool exprid@var1362 ; exprid@var1362 = false ;
906: bool idtype@var1363 ; idtype@var1363 = false ;
907: bool attributes@var1364 ; attributes@var1364 = false ;
908: bool macro@var1365 ; macro@var1365 = false ;
909: bool linenumbers@var1366 ; linenumbers@var1366 = false ;
910: bool linebreaks@var1367 ; linebreaks@var1367 = false ;
911: bool files@var1368 ; files@var1368 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1369 ;
914: options@var1369 .@expr1073745593 attributes@var1370 =@expr1073745594 true ;
915: options@var1369 .@expr1073745595 macro@var1371 =@expr1073745596 true ;
916: options@var1369 .@expr1073745597 linenumbers@var1372 =@expr1073745598 true ;
917: options@var1369 .@expr1073745599 linebreaks@var1373 =@expr1073745600 true ;
918: options@var1369 .@expr1073745601 files@var1374 =@expr1073745602 true ;
919: return options@var1369 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1375 ; options@var1375 =@expr1073745603 forDebug (@expr1073745604 ) ;
923: options@var1375 .@expr1073745605 varid@var1376 =@expr1073745606 true ;
924: return options@var1375 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1377 ; options@var1377 =@expr1073745607 forDebug (@expr1073745608 ) ;
928: options@var1377 .@expr1073745609 exprid@var1378 =@expr1073745610 true ;
929: return options@var1377 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1379 ; options@var1379 =@expr1073745611 forDebug (@expr1073745612 ) ;
933: options@var1379 .@expr1073745613 exprid@var1380 =@expr1073745614 true ;
934: options@var1379 .@expr1073745615 varid@var1381 =@expr1073745616 true ;
935: options@var1379 .@expr1073745617 idtype@var1382 =@expr1073745618 true ;
936: return options@var1379 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1383 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1384 , bool attributes@var1385 , bool macro@var1386 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1387 , const std :: vector < std :: string > * fileNames@var1388 = nullptr , const Token * end@var1389 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1390 , bool attributes@var1391 = true ) const ;
952: std :: string stringifyList ( bool varid@var1392 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1393 , bool attributes@var1394 , bool linenumbers@var1395 , bool linebreaks@var1396 , bool files@var1397 , const std :: vector < std :: string > * fileNames@var1398 = nullptr , const Token * end@var1399 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1400 ) {
983: mLink@var1444 =@expr1073745619 linkToToken@var1400 ;
984: if (@expr1073745620 mStr@var1441 ==@expr1073745621 "<" ||@expr1073745622 mStr@var1441 ==@expr1073745623 ">" ) {
985: update_property_info (@expr1073745624 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1444 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1401 ) {
1006: mImpl@var1447 .@expr1073745625 mScope@var1487 =@expr1073745626 s@var1401 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1447 .@expr1073745627 mScope@var1487 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1402 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1445 ==@expr1073745628 eFunction ||@expr1073745629 mTokType@var1445 ==@expr1073745630 eLambda ?@expr1073745631 mImpl@var1447 .@expr1073745632 mFunction@var1488 :@expr1073745633 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1403 ) {
1034: mImpl@var1447 .@expr1073745634 mVariable@var1489 =@expr1073745635 v@var1403 ;
1035: if (@expr1073745636 v@var1403 ||@expr1073745637 mImpl@var1447 .@expr1073745638 mVarId@var1478 ) {
1036: tokType (@expr1073745639 eVariable ) ; }
1037: else { if (@expr1073745640 mTokType@var1445 ==@expr1073745641 eVariable ) {
1038: tokType (@expr1073745642 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1445 ==@expr1073745643 eVariable ?@expr1073745644 mImpl@var1447 .@expr1073745645 mVariable@var1489 :@expr1073745646 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1404 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1445 ==@expr1073745647 eType ?@expr1073745648 mImpl@var1447 .@expr1073745649 mType@var1490 :@expr1073745650 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1405 , const Token * * typeTok@var1406 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1407 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1408 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1445 ==@expr1073745651 eEnumerator ?@expr1073745652 mImpl@var1447 .@expr1073745653 mEnumerator@var1491 :@expr1073745654 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1409 ) {
1079: mImpl@var1447 .@expr1073745655 mEnumerator@var1491 =@expr1073745656 e@var1409 ;
1080: if (@expr1073745657 e@var1409 ) {
1081: tokType (@expr1073745658 eEnumerator ) ; }
1082: else { if (@expr1073745659 mTokType@var1445 ==@expr1073745660 eEnumerator ) {
1083: tokType (@expr1073745661 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1410 , Token * end@var1411 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1412 , Token * srcEnd@var1413 , Token * newLocation@var1414 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1447 .@expr1073745662 mProgressValue@var1492 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1415 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1447 .@expr3839 mOriginalName@var1493 ?@expr1073745664 *@expr1073745665 mImpl@var1447 .@expr3839 mOriginalName@var1493 :@expr1073745667 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1447 .@expr3844 mValues@var1466 ?@expr1073745669 *@expr1073745670 mImpl@var1447 .@expr3844 mValues@var1466 :@expr1073745672 TokenImpl ::@expr1073745673 mEmptyValueList@var1213 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1416 ) {
1164: if (@expr1073745674 !@expr1073745675 mImpl@var1447 .@expr3852 mOriginalName@var1493 ) {
1165: mImpl@var1447 .@expr3852 mOriginalName@var1493 =@expr1073745678 new std ::@expr1073745679 string (@expr1073745680 name@var1416 ) ; }
1166: else {
1167: *@expr1073745681 mImpl@var1447 .@expr3852 mOriginalName@var1493 =@expr1073745683 name@var1416 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1417 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1418 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1419 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1447 .@expr1073745685 mValues@var1466 .@expr1073745686 front (@expr1073745687 ) .@expr1073745688 intvalue@expr1073745684 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1420 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1421 , long long path@var1422 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1423 , const Settings * settings@var1424 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1425 , const Settings * settings@var1426 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1427 , int argnr@var1428 , const Settings * settings@var1429 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1430 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1431 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1432 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1433 ) {
1200: if (@expr1073745689 mImpl@var1447 .@expr3866 mValues@var1466 ) {
1201: mImpl@var1447 .@expr3866 mValues@var1466 .@expr1073745692 remove_if (@expr1073745693 pred@var1433 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1447 .@expr1073745694 mIndex@var1494 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1434 ) {
1213: mNext@var1442 =@expr1073745695 nextToken@var1434 ;
1214: }
1215: void previous ( Token * previousToken@var1435 ) {
1216: mPrevious@var1443 =@expr1073745696 previousToken@var1435 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1436 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1437 , const char * word@var1438 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1439 , char c@var1440 ) ;
1235:
1236: std :: string mStr@var1441 ;
1237:
1238: Token * mNext@var1442 ;
1239: Token * mPrevious@var1443 ;
1240: Token * mLink@var1444 ;
1241:
1242: enum Anonymous3 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1445 ;
1283:
1284: uint64_t mFlags@var1446 ;
1285:
1286: TokenImpl * mImpl@var1447 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1448 ) const {
1294: return (@expr3873 (@expr3873 mFlags@var1446 &@expr1073745699 flag_@var1448 ) !=@expr1073745700 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1449 , bool state_@var1450 ) {
1303: mFlags@var1446 =@expr1073745701 state_@var1450 ?@expr1073745702 mFlags@var1446 |@expr1073745703 flag_@var1449 :@expr1073745704 mFlags@var1446 &@expr1073745705 ~@expr1073745706 flag_@var1449 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1451 , const int indent1@var1452 = 0 , const int indent2@var1453 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1454 ) ;
1321: void astOperand2 ( Token * tok@var1455 ) ;
1322: void astParent ( Token * tok@var1456 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1447 .@expr1073745707 mAstOperand1@var1457 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1447 .@expr1073745708 mAstOperand1@var1457 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1447 .@expr1073745709 mAstOperand2@var1458 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1447 .@expr1073745710 mAstOperand2@var1458 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1447 .@expr1073745711 mAstParent@var1459 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1447 .@expr1073745712 mAstParent@var1459 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745713 !@expr1073745714 astParent (@expr3891 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745716 this@expr3893 ==@expr1073745718 astParent (@expr3891 ) .@expr3896 astOperand1 (@expr3897 ) ) {
1346: return astParent (@expr3891 ) .@expr3899 astOperand2 (@expr3900 ) ; }
1347: else { if (@expr1073745725 this@expr3893 ==@expr1073745726 astParent (@expr3891 ) .@expr3899 astOperand2 (@expr3900 ) ) {
1348: return astParent (@expr3891 ) .@expr3896 astOperand1 (@expr3897 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745733 !@expr1073745734 astParent (@expr3911 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745736 this@expr3913 ==@expr1073745738 astParent (@expr3911 ) .@expr3916 astOperand1 (@expr3917 ) ) {
1356: return astParent (@expr3911 ) .@expr3919 astOperand2 (@expr3920 ) ; }
1357: else { if (@expr1073745745 this@expr3913 ==@expr1073745746 astParent (@expr3911 ) .@expr3919 astOperand2 (@expr3920 ) ) {
1358: return astParent (@expr3911 ) .@expr3916 astOperand1 (@expr3917 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1460 ; ret@var1460 =@expr1073745753 this@expr1073745754 ;
1364: while (@expr1073745755 ret@var1460 .@expr3932 mImpl@var1461 .@expr3933 mAstParent@var1462 ) {
1365: ret@var1460 =@expr1073745758 ret@var1460 .@expr3932 mImpl@var1461 .@expr3933 mAstParent@var1462 ; }
1366: return ret@var1460 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1463 ; ret@var1463 =@expr1073745761 this@expr1073745762 ;
1371: while (@expr1073745763 ret@var1463 .@expr3940 mImpl@var1464 .@expr3941 mAstParent@var1465 ) {
1372: ret@var1463 =@expr1073745766 ret@var1463 .@expr3940 mImpl@var1464 .@expr3941 mAstParent@var1465 ; }
1373: return ret@var1463 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1447 .@expr1073745769 mAstOperand1@var1457 =@expr1073745770 mImpl@var1447 .@expr1073745771 mAstOperand2@var1458 =@expr1073745772 mImpl@var1447 .@expr1073745773 mAstParent@var1459 =@expr1073745774 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1447 .@expr3951 mValues@var1466 ;
1393: mImpl@var1447 .@expr3951 mValues@var1466 =@expr1073745777 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1467 = "" ) const {
1397: std ::@expr1073745778 string ret@var1468 ;
1398: if (@expr1073745779 mImpl@var1447 .@expr3956 mAstOperand1@var1457 ) {
1399: ret@var1468 =@expr1073745781 mImpl@var1447 .@expr3956 mAstOperand1@var1457 .@expr1073745783 astString (@expr1073745784 sep@var1467 ) ; }
1400: if (@expr1073745785 mImpl@var1447 .@expr3962 mAstOperand2@var1458 ) {
1401: ret@var1468 +=@expr1073745787 mImpl@var1447 .@expr3962 mAstOperand2@var1458 .@expr1073745789 astString (@expr1073745790 sep@var1467 ) ; }
1402: return ret@var1468 +@expr1073745791 sep@var1467 +@expr1073745792 mStr@var1441 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1469 , bool xml@var1470 , const std :: vector < std :: string > & fileNames@var1471 , std :: ostream & out@var1472 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1473 , std :: ostream & out@var1474 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1475 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1476 ) const {
1419: mImpl@var1447 .@expr1073745793 mCpp11init@var1477 =@expr1073745794 cpp11init@var1476 ?@expr1073745795 TokenImpl ::@expr3972 Cpp11init ::@expr1073745797 CPP11INIT :@expr1073745798 TokenImpl ::@expr3972 Cpp11init ::@expr1073745800 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1447 .@expr1073745801 mCpp11init@var1477 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1495 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1496 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1497 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1498 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1499 ( nullptr ) , num@var1500 ( 0 ) , known@var1501 ( true ) { }
62:
63: const Token * tok@var1499 ;
64: long long num@var1500 ;
65: bool known@var1501 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1502 ;
72: const Scope * classScope@var1503 ;
73: const Scope * enclosingScope@var1504 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1505 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1507 ( nullptr ) , nameTok@var1508 ( nullptr ) , access@var1509 ( AccessControl :: Public ) , isVirtual@var1510 ( false ) { }
82:
83: std :: string name@var1506 ;
84: const Type * type@var1507 ;
85: const Token * nameTok@var1508 ;
86: AccessControl access@var1509 ;
87: bool isVirtual@var1510 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1511 ) const {
90: return this@expr1073745802 .@expr1073745803 type@var1507 <@expr1073745804 rhs@var1511 .@expr1073745805 type@var1512 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1513 ( nullptr ) , nameEnd@var1514 ( nullptr ) , type@var1515 ( nullptr ) { }
97:
98: const Token * nameStart@var1513 ;
99: const Token * nameEnd@var1514 ;
100: const Type * type@var1515 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1516 ;
104: std :: vector < FriendInfo > friendList@var1517 ;
105:
106: const Token * typeStart@var1518 ;
107: const Token * typeEnd@var1519 ;
108: long long sizeOf@var1520 ;
109:
110: Type ( const Token * classDef_@var1521 = nullptr , const Scope * classScope_@var1522 = nullptr , const Scope * enclosingScope_@var1523 = nullptr ) :
111: classDef@var1502 ( classDef_@var1521 ) ,
112: classScope@var1503 ( classScope_@var1522 ) ,
113: enclosingScope@var1504 ( enclosingScope_@var1523 ) ,
114: needInitialization@var1505 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1518 ( nullptr ) ,
116: typeEnd@var1519 ( nullptr ) ,
117: sizeOf@var1520 ( 0 ) {
118: if (@expr1073745806 classDef_@var1521 &&@expr1073745807 classDef_@var1521 .@expr3984 str (@expr3985 ) ==@expr1073745810 "enum" ) {
119: needInitialization@var1505 =@expr1073745811 NeedInitialization ::@expr1073745812 True ; }
120: else { if (@expr1073745813 classDef_@var1521 &&@expr1073745814 classDef_@var1521 .@expr3984 str (@expr3985 ) ==@expr1073745817 "using" ) {
121: typeStart@var1518 =@expr1073745818 classDef@var1502 .@expr1073745819 tokAt (@expr1073745820 3 ) ;
122: typeEnd@var1519 =@expr1073745821 typeStart@var1518 ;
123: while (@expr1073745822 typeEnd@var1519 .@expr3999 next (@expr4000 ) &&@expr1073745825 typeEnd@var1519 .@expr3999 next (@expr4000 ) .@expr1073745828 str (@expr1073745829 ) !=@expr1073745830 ";" ) {
124: typeEnd@var1519 =@expr1073745831 typeEnd@var1519 .@expr3999 next (@expr4000 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1502 ?@expr1073745834 classDef@var1502 .@expr1073745835 str (@expr1073745836 ) :@expr1073745837 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1502 &&@expr1073745838 classDef@var1502 .@expr1073745839 str (@expr1073745840 ) ==@expr1073745841 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1524 , const Token * tok1@var1525 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1526 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1527 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1528 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1529 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1530 ) : scope@var1531 ( scope_@var1530 ) , name@var1532 ( nullptr ) , value@var1533 ( 0 ) , start@var1534 ( nullptr ) , end@var1535 ( nullptr ) , value_known@var1536 ( false ) { }
167: const Scope * scope@var1531 ;
168: const Token * name@var1532 ;
169: long long value@var1533 ;
170: const Token * start@var1534 ;
171: const Token * end@var1535 ;
172: bool value_known@var1536 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous4 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1537 ) const {
204: return (@expr4018 (@expr4018 mFlags@var1573 &@expr1073745844 flag_@var1537 ) !=@expr1073745845 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1538 , bool state_@var1539 ) {
213: mFlags@var1573 =@expr1073745846 state_@var1539 ?@expr1073745847 mFlags@var1573 |@expr1073745848 flag_@var1538 :@expr1073745849 mFlags@var1573 &@expr1073745850 ~@expr1073745851 flag_@var1538 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1540 , bool * isContainer@var1541 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1542 , const Token * start_@var1543 , const Token * end_@var1544 ,
226: int index_@var1545 , AccessControl access_@var1546 , const Type * type_@var1547 ,
227: const Scope * scope_@var1548 , const Settings * settings@var1549 )
228: : mNameToken@var1568 ( name_@var1542 ) ,
229: mTypeStartToken@var1569 ( start_@var1543 ) ,
230: mTypeEndToken@var1570 ( end_@var1544 ) ,
231: mIndex@var1571 ( index_@var1545 ) ,
232: mAccess@var1572 ( access_@var1546 ) ,
233: mFlags@var1573 ( 0 ) ,
234: mType@var1574 ( type_@var1547 ) ,
235: mScope@var1575 ( scope_@var1548 ) ,
236: mValueType@var1576 ( nullptr ) {
237: evaluate (@expr1073745852 settings@var1549 ) ;
238: }
239:
240: Variable ( const Token * name_@var1550 , const std :: string & clangType@var1551 , const Token * typeStart@var1552 ,
241: const Token * typeEnd@var1553 , int index_@var1554 , AccessControl access_@var1555 ,
242: const Type * type_@var1556 , const Scope * scope_@var1557 ) ;
243:
244: Variable ( const Variable & var@var1558 , const Scope * scope@var1559 ) ;
245:
246: Variable ( const Variable & var@var1560 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1561 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1568 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1569 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1570 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745853 mNameToken@var1568 ) {
300: return mNameToken@var1568 .@expr1073745854 str (@expr1073745855 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745856 mNameToken@var1568 ) {
312: return mNameToken@var1568 .@expr1073745857 varId (@expr1073745858 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1571 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1572 ==@expr1073745859 AccessControl ::@expr1073745860 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1572 ==@expr1073745861 AccessControl ::@expr1073745862 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1572 ==@expr1073745863 AccessControl ::@expr1073745864 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1572 ==@expr1073745865 AccessControl ::@expr1073745866 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1572 ==@expr1073745867 AccessControl ::@expr1073745868 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1572 ==@expr1073745869 AccessControl ::@expr1073745870 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745872 mAccess@var1572 ==@expr1073745873 AccessControl ::@expr1073745874 Local@expr1073745871 ) &&@expr1073745875 !@expr1073745876 isExtern (@expr1073745877 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745878 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745879 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745880 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745881 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745882 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1572 ==@expr1073745883 AccessControl ::@expr1073745884 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745885 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745886 fIsArray ) &&@expr1073745887 !@expr1073745888 getFlag (@expr1073745889 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745890 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745891 ) &&@expr1073745892 getFlag (@expr1073745893 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745894 fIsArray ) ||@expr1073745895 getFlag (@expr1073745896 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745897 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745898 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745899 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745900 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1574 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1574 ?@expr1073745901 mType@var1574 .@expr1073745902 classScope@var1579 :@expr1073745903 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1575 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1577 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1562 ) const {
550: return mDimensions@var1577 [@expr1073745904 index_@var1562 ] .@expr1073745905 num@var2360 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1563 ) const {
558: return mDimensions@var1577 [@expr1073745906 index_@var1563 ] .@expr1073745907 known@var2361 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745908 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745909 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745910 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1564 ) const {
602: return isStlType (@expr1073745911 ) &&@expr1073745912 stlType@var1564 ==@expr1073745913 mTypeStartToken@var1569 .@expr1073745914 strAt (@expr1073745915 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1565 ) const {
616: return isStlType (@expr1073745916 ) &&@expr1073745917 stlTypes@var1565 .@expr1073745918 find (@expr1073745919 mTypeStartToken@var1569 .@expr1073745920 strAt (@expr1073745921 2 ) ) !=@expr1073745922 stlTypes@var1565 .@expr1073745923 end (@expr1073745924 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745925 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4102 ) &&@expr1073745927 type (@expr4102 ) .@expr1073745929 isEnumType (@expr1073745930 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745931 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1576 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1566 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1572 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1567 ) {
660: mType@var1574 =@expr1073745932 t@var1567 ;
661: }
662:
663:
664: const Token * mNameToken@var1568 ;
665:
666:
667: const Token * mTypeStartToken@var1569 ;
668:
669:
670: const Token * mTypeEndToken@var1570 ;
671:
672:
673: int mIndex@var1571 ;
674:
675:
676: AccessControl mAccess@var1572 ;
677:
678:
679: unsigned int mFlags@var1573 ;
680:
681:
682: const Type * mType@var1574 ;
683:
684:
685: const Scope * mScope@var1575 ;
686:
687: ValueType * mValueType@var1576 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1577 ;
691:
692:
693: void evaluate ( const Settings * settings@var1578 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous5 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1580 ) const {
735: return (@expr4109 (@expr4109 mFlags@var1629 &@expr1073745935 flag@var1580 ) !=@expr1073745936 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1581 , bool state@var1582 ) {
744: mFlags@var1629 =@expr1073745937 state@var1582 ?@expr1073745938 mFlags@var1629 |@expr1073745939 flag@var1581 :@expr1073745940 mFlags@var1629 &@expr1073745941 ~@expr1073745942 flag@var1581 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1583 , const Token * tok@var1584 , const Scope * scope@var1585 , const Token * tokDef@var1586 , const Token * tokArgDef@var1587 ) ;
751: Function ( const Token * tokenDef@var1588 , const std :: string & clangType@var1589 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1599 .@expr1073745943 str (@expr1073745944 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1607 .@expr1073745945 size (@expr1073745946 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1607 .@expr1073745947 size (@expr1073745948 ) -@expr1073745949 initArgCount@var1608 ;
764: }
765: const Variable * getArgumentVar ( int num@var1590 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1608 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1591 , const Scope * scope@var1592 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1593 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1594 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1609 ==@expr1073745950 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1609 ==@expr1073745951 eConstructor ||@expr1073745952
785: type@var1609 ==@expr1073745953 eCopyConstructor ||@expr1073745954
786: type@var1609 ==@expr1073745955 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1609 ==@expr1073745956 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1599 .@expr1073745957 isAttributeConstructor (@expr1073745958 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1599 .@expr1073745959 isAttributeDestructor (@expr1073745960 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1599 .@expr1073745961 isAttributePure (@expr1073745962 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1599 .@expr1073745963 isAttributeConst (@expr1073745964 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1599 .@expr1073745965 isAttributeNoreturn (@expr1073745966 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1599 .@expr1073745967 isAttributeNothrow (@expr1073745968 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1599 .@expr1073745969 isAttributeNodiscard (@expr1073745970 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745971 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745972 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745973 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745974 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745975 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745976 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745977 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745978 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745979 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745980 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745981 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745982 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745983 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745984 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745985 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745986 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745987 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745988 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745989 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745990 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745991 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745992 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1595 ) {
881: setFlag (@expr1073745993 fHasBody , state@var1595 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745994 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745995 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1596 ) {
891: setFlag (@expr1073745996 fIsEscapeFunction , state@var1596 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745997 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1597 ) {
898: setFlag (@expr1073745998 fIsConstexpr , state@var1597 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1598 ) const ;
901:
902: const Token * tokenDef@var1599 ;
903: const Token * argDef@var1600 ;
904: const Token * token@var1601 ;
905: const Token * arg@var1602 ;
906: const Token * retDef@var1603 ;
907: const :: Type * retType@var1604 ;
908: const Scope * functionScope@var1605 ;
909: const Scope * nestedIn@var1606 ;
910: std :: list < Variable > argumentList@var1607 ;
911: int initArgCount@var1608 ;
912: Type type@var1609 ;
913: AccessControl access@var1610 ;
914: const Token * noexceptArg@var1611 ;
915: const Token * throwArg@var1612 ;
916: const Token * templateDef@var1613 ;
917: const Token * functionPointerUsage@var1614 ;
918:
919: bool argsMatch ( const Scope * scope@var1615 , const Token * first@var1616 , const Token * second@var1617 , const std :: string & path@var1618 , int path_length@var1619 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1620 , bool unknown@var1621 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1622 , bool unknown@var1623 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1624 , bool unknown@var1625 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1626 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745999 this@expr1073746000 .@expr1073746001 hasTrailingReturnType (@expr1073746002 ) ) {
931: return Token ::@expr1073746003 findmatch (@expr1073746004 retDef@var1603 , "{|;" ) ;
932: } else {
933: return tokenDef@var1599 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1627 , bool * foundAllBaseClasses@var1628 ) const ;
946:
947: unsigned int mFlags@var1629 ;
948:
949: void isInline ( bool state@var1630 ) {
950: setFlag (@expr1073746005 fIsInline , state@var1630 ) ;
951: }
952: void isConst ( bool state@var1631 ) {
953: setFlag (@expr1073746006 fIsConst , state@var1631 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1632 ) {
956: setFlag (@expr1073746007 fHasVirtualSpecifier , state@var1632 ) ;
957: }
958: void isPure ( bool state@var1633 ) {
959: setFlag (@expr1073746008 fIsPure , state@var1633 ) ;
960: }
961: void isStatic ( bool state@var1634 ) {
962: setFlag (@expr1073746009 fIsStatic , state@var1634 ) ;
963: }
964: void isStaticLocal ( bool state@var1635 ) {
965: setFlag (@expr1073746010 fIsStaticLocal , state@var1635 ) ;
966: }
967: void isExtern ( bool state@var1636 ) {
968: setFlag (@expr1073746011 fIsExtern , state@var1636 ) ;
969: }
970: void isFriend ( bool state@var1637 ) {
971: setFlag (@expr1073746012 fIsFriend , state@var1637 ) ;
972: }
973: void isExplicit ( bool state@var1638 ) {
974: setFlag (@expr1073746013 fIsExplicit , state@var1638 ) ;
975: }
976: void isDefault ( bool state@var1639 ) {
977: setFlag (@expr1073746014 fIsDefault , state@var1639 ) ;
978: }
979: void isDelete ( bool state@var1640 ) {
980: setFlag (@expr1073746015 fIsDelete , state@var1640 ) ;
981: }
982: void isNoExcept ( bool state@var1641 ) {
983: setFlag (@expr1073746016 fIsNoExcept , state@var1641 ) ;
984: }
985: void isThrow ( bool state@var1642 ) {
986: setFlag (@expr1073746017 fIsThrow , state@var1642 ) ;
987: }
988: void isOperator ( bool state@var1643 ) {
989: setFlag (@expr1073746018 fIsOperator , state@var1643 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1644 ) {
992: setFlag (@expr1073746019 fHasLvalRefQual , state@var1644 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1645 ) {
995: setFlag (@expr1073746020 fHasRvalRefQual , state@var1645 ) ;
996: }
997: void isVariadic ( bool state@var1646 ) {
998: setFlag (@expr1073746021 fIsVariadic , state@var1646 ) ;
999: }
1000: void isVolatile ( bool state@var1647 ) {
1001: setFlag (@expr1073746022 fIsVolatile , state@var1647 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1648 ) {
1004: return setFlag (@expr1073746023 fHasTrailingReturnType , state@var1648 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1649 ) {
1007: setFlag (@expr1073746024 fIsInlineKeyword , state@var1649 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1650 , const Scope * scope@var1651 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1652 ;
1019: const Scope * scope@var1653 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1654 , const Token * classDef_@var1655 , const Scope * nestedIn_@var1656 ) ;
1025: Scope ( const SymbolDatabase * check_@var1657 , const Token * classDef_@var1658 , const Scope * nestedIn_@var1659 , ScopeType type_@var1660 , const Token * start_@var1661 ) ;
1026:
1027: const SymbolDatabase * check@var1662 ;
1028: std :: string className@var1663 ;
1029: const Token * classDef@var1664 ;
1030: const Token * bodyStart@var1665 ;
1031: const Token * bodyEnd@var1666 ;
1032: std :: list < Function > functionList@var1667 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1668 ;
1034: std :: list < Variable > varlist@var1669 ;
1035: const Scope * nestedIn@var1670 ;
1036: std :: list < Scope * > nestedList@var1671 ;
1037: int numConstructors@var1672 ;
1038: int numCopyOrMoveConstructors@var1673 ;
1039: std :: list < UsingInfo > usingList@var1674 ;
1040: ScopeType type@var1675 ;
1041: Type * definedType@var1676 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1677 ;
1043: std :: vector < const Token * > bodyStartList@var1678 ;
1044:
1045:
1046: const Scope * functionOf@var1679 ;
1047: Function * function@var1680 ;
1048:
1049:
1050: const Token * enumType@var1681 ;
1051: bool enumClass@var1682 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1683 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1684 ) {
1056: bodyStart@var1665 =@expr1073746025 start@var1684 ;
1057: bodyEnd@var1666 =@expr1073746026 start@var1684 ?@expr1073746027 start@var1684 .@expr1073746028 link (@expr1073746029 ) :@expr1073746030 nullptr ;
1058: if (@expr1073746031 start@var1684 ) {
1059: bodyStartList@var1678 .@expr1073746032 push_back (@expr1073746033 start@var1684 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1663 .@expr1073746034 size (@expr1073746035 ) >@expr1073746036 9 &&@expr1073746037 className@var1663 .@expr1073746038 compare (@expr1073746039 0 , 9 , "Anonymous" ) ==@expr1073746040 0 &&@expr1073746041 std ::@expr1073746042 isdigit (@expr1073746043 className@var1663 [@expr1073746044 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1685 ) const {
1068: for (@expr1073746045 const Enumerator &@expr1073746046 i@var1686 :@expr1073746047 enumeratorList@var1683 ) {
1069: if (@expr1073746048 i@var1686 .@expr1073746049 name@var1687 .@expr1073746050 str (@expr1073746051 ) ==@expr1073746052 name@var1685 ) {
1070: return &@expr1073746053 i@var1686 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1688 ) const {
1076: if (@expr1073746054 !@expr1073746055 outer@var1688 ) {
1077: return false ; }
1078: if (@expr1073746056 outer@var1688 ==@expr1073746057 this@expr1073746058 ) {
1079: return true ; }
1080: const Scope * parent@var1689 ; parent@var1689 =@expr1073746059 nestedIn@var1670 ;
1081: while (@expr1073746060 outer@var1688 !=@expr1073746061 parent@var1689 &&@expr1073746062 parent@var1689 ) {
1082: parent@var1689 =@expr1073746063 parent@var1689 .@expr1073746064 nestedIn@var1690 ; }
1083: if (@expr1073746065 parent@var1689 &&@expr1073746066 parent@var1689 ==@expr1073746067 outer@var1688 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1691 ) {
1089: while (@expr1073746068 scope@var1691 ) {
1090: if (@expr1073746069 scope@var1691 .@expr1073746070 type@var1692 ==@expr1073746071 Scope ::@expr1073746072 eFunction ) {
1091: break ; }
1092: scope@var1691 =@expr1073746073 scope@var1691 .@expr1073746074 nestedIn@var1693 ;
1093: }
1094: if (@expr1073746075 !@expr1073746076 scope@var1691 ) {
1095: return nullptr ; }
1096: return scope@var1691 .@expr1073746077 function@var1694 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746078 type@var1675 ==@expr1073746079 eClass ||@expr1073746080 type@var1675 ==@expr1073746081 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746082 type@var1675 ==@expr1073746083 eClass ||@expr1073746084 type@var1675 ==@expr1073746085 eStruct ||@expr1073746086 type@var1675 ==@expr1073746087 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1675 !=@expr1073746088 eClass &&@expr1073746089 type@var1675 !=@expr1073746090 eStruct &&@expr1073746091 type@var1675 !=@expr1073746092 eUnion &&@expr1073746093 type@var1675 !=@expr1073746094 eGlobal &&@expr1073746095 type@var1675 !=@expr1073746096 eNamespace &&@expr1073746097 type@var1675 !=@expr1073746098 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1675 ==@expr1073746099 Scope ::@expr4276 ScopeType ::@expr1073746101 eFor ||@expr1073746102 type@var1675 ==@expr1073746103 Scope ::@expr4276 ScopeType ::@expr1073746105 eWhile ||@expr1073746106 type@var1675 ==@expr1073746107 Scope ::@expr4276 ScopeType ::@expr1073746109 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746110 type@var1675 ==@expr1073746111 eIf ||@expr1073746112 type@var1675 ==@expr1073746113 eElse ||@expr1073746114
1117: type@var1675 ==@expr1073746115 eFor ||@expr1073746116 type@var1675 ==@expr1073746117 eWhile ||@expr1073746118 type@var1675 ==@expr1073746119 eDo ||@expr1073746120
1118: type@var1675 ==@expr1073746121 eSwitch ||@expr1073746122 type@var1675 ==@expr1073746123 eUnconditional ||@expr1073746124
1119: type@var1675 ==@expr1073746125 eTry ||@expr1073746126 type@var1675 ==@expr1073746127 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1695 , bool requireConst@var1696 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1697 , bool isC@var1698 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1699 ) {
1135: return const_cast < Scope *@expr4304 > (@expr1073746129 const_cast < const Scope *@expr4304 > (@expr1073746131 this@expr1073746132 ) .@expr1073746133 findRecordInNestedList (@expr1073746134 name@var1699 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1700 ) const ;
1139: Type * findType ( const std :: string & name@var1701 ) {
1140: return const_cast < Type *@expr4311 > (@expr1073746136 const_cast < const Scope *@expr4311 > (@expr1073746138 this@expr1073746139 ) .@expr1073746140 findType (@expr1073746141 name@var1701 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1702 ) ;
1148:
1149: void addVariable ( const Token * token_@var1703 , const Token * start_@var1704 ,
1150: const Token * end_@var1705 , AccessControl access_@var1706 , const Type * type_@var1707 ,
1151: const Scope * scope_@var1708 , const Settings * settings@var1709 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1710 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1711 ) {
1159: functionList@var1667 .@expr1073746142 push_back (@expr1073746143 func@var1711 ) ;
1160:
1161: const Function * back@var1712 ; back@var1712 =@expr1073746144 &@expr1073746145 functionList@var1667 .@expr1073746146 back (@expr1073746147 ) ;
1162:
1163: functionMap@var1668 .@expr1073746148 insert (@expr1073746149 make_pair (@expr1073746150 back@var1712 .@expr1073746151 tokenDef@var1713 .@expr1073746152 str (@expr1073746153 ) , back@var1712 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1714 , AccessControl varaccess@var1715 , const Settings * settings@var1716 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1717 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1718 , bool isCpp@var1719 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1720 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1721 , const Token * & vartok@var1722 , const Token * & typetok@var1723 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1724 , int args@var1725 , std :: vector < const Function * > & matches@var1726 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1727 , const Token * start@var1728 , const Token * end@var1729 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1730 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1731 ;
1239: int bits@var1732 ;
1240: int pointer@var1733 ;
1241: int constness@var1734 ;
1242: Reference reference@var1735 ; reference@var1735 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1736 ;
1245: const :: Type * smartPointerType@var1737 ;
1246: const Token * smartPointerTypeToken@var1738 ;
1247: const Library :: SmartPointer * smartPointer@var1739 ;
1248: const Library :: Container * container@var1740 ;
1249:
1250: const Token * containerTypeToken@var1741 ;
1251:
1252: std :: string originalTypeName@var1742 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1730 ( UNKNOWN_SIGN ) ,
1257: type@var1731 ( UNKNOWN_TYPE ) ,
1258: bits@var1732 ( 0 ) ,
1259: pointer@var1733 ( 0U ) ,
1260: constness@var1734 ( 0U ) ,
1261: typeScope@var1736 ( nullptr ) ,
1262: smartPointerType@var1737 ( nullptr ) ,
1263: smartPointerTypeToken@var1738 ( nullptr ) ,
1264: smartPointer@var1739 ( nullptr ) ,
1265: container@var1740 ( nullptr ) ,
1266: containerTypeToken@var1741 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1743 , enum Type t@var1744 , int p@var1745 )
1269: : sign@var1730 ( s@var1743 ) ,
1270: type@var1731 ( t@var1744 ) ,
1271: bits@var1732 ( 0 ) ,
1272: pointer@var1733 ( p@var1745 ) ,
1273: constness@var1734 ( 0U ) ,
1274: typeScope@var1736 ( nullptr ) ,
1275: smartPointerType@var1737 ( nullptr ) ,
1276: smartPointerTypeToken@var1738 ( nullptr ) ,
1277: smartPointer@var1739 ( nullptr ) ,
1278: container@var1740 ( nullptr ) ,
1279: containerTypeToken@var1741 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1746 , enum Type t@var1747 , int p@var1748 , int c@var1749 )
1282: : sign@var1730 ( s@var1746 ) ,
1283: type@var1731 ( t@var1747 ) ,
1284: bits@var1732 ( 0 ) ,
1285: pointer@var1733 ( p@var1748 ) ,
1286: constness@var1734 ( c@var1749 ) ,
1287: typeScope@var1736 ( nullptr ) ,
1288: smartPointerType@var1737 ( nullptr ) ,
1289: smartPointerTypeToken@var1738 ( nullptr ) ,
1290: smartPointer@var1739 ( nullptr ) ,
1291: container@var1740 ( nullptr ) ,
1292: containerTypeToken@var1741 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1750 , enum Type t@var1751 , int p@var1752 , int c@var1753 , const std :: string & otn@var1754 )
1295: : sign@var1730 ( s@var1750 ) ,
1296: type@var1731 ( t@var1751 ) ,
1297: bits@var1732 ( 0 ) ,
1298: pointer@var1733 ( p@var1752 ) ,
1299: constness@var1734 ( c@var1753 ) ,
1300: typeScope@var1736 ( nullptr ) ,
1301: smartPointerType@var1737 ( nullptr ) ,
1302: smartPointerTypeToken@var1738 ( nullptr ) ,
1303: smartPointer@var1739 ( nullptr ) ,
1304: container@var1740 ( nullptr ) ,
1305: containerTypeToken@var1741 ( nullptr ) ,
1306: originalTypeName@var1742 ( otn@var1754 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1755 , const Settings * settings@var1756 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1757 , bool longType@var1758 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1759 , const ValueType * func@var1760 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1761 , const Variable * callVar@var1762 , const Variable * funcVar@var1763 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746154 type@var1731 >=@expr1073746155 ValueType ::@expr1073746156 Type ::@expr1073746157 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746158 type@var1731 >=@expr1073746159 ValueType ::@expr4336 Type ::@expr1073746161 BOOL &&@expr1073746162 type@var1731 <=@expr1073746163 ValueType ::@expr4336 Type ::@expr1073746165 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746166 type@var1731 >=@expr1073746167 ValueType ::@expr4344 Type ::@expr1073746169 FLOAT &&@expr1073746170 type@var1731 <=@expr1073746171 ValueType ::@expr4344 Type ::@expr1073746173 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1764 , const Settings * settings@var1765 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1736 &&@expr1073746174 typeScope@var1736 .@expr1073746175 type@var1766 ==@expr1073746176 Scope ::@expr1073746177 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1767 , bool p@var1768 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1769 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1770 , const Settings * settings@var1771 , ErrorLogger * errorLogger@var1772 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1773 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1774 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1775 ;
1359:
1360:
1361: std :: list < Type > typeList@var1776 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1777 , const Token * typeTok@var1778 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1779 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1780 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1781 , const Scope * startScope@var1782 , bool lookOutside@var1783 = false ) const ;
1382: Type * findType ( const Token * startTok@var1784 , Scope * startScope@var1785 , bool lookOutside@var1786 = false ) const {
1383: return const_cast < Type *@expr4354 > (@expr1073746179 this@expr1073746180 .@expr1073746181 findType (@expr1073746182 startTok@var1784 , const_cast < const Scope *@expr4354 > (@expr1073746184 startScope@var1785 ) , lookOutside@var1786 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1787 , const Scope * startScope@var1788 ) const ;
1387: Scope * findScope ( const Token * tok@var1789 , Scope * startScope@var1790 ) const {
1388: return const_cast < Scope *@expr4361 > (@expr1073746186 this@expr1073746187 .@expr1073746188 findScope (@expr1073746189 tok@var1789 , const_cast < const Scope *@expr4361 > (@expr1073746191 startScope@var1790 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1791 ) const {
1392: return varid@var1791 <@expr1073746192 mVariableList@var1848 .@expr1073746193 size (@expr1073746194 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1792 ) const {
1396: return mVariableList@var1848 .@expr1073746195 at (@expr1073746196 varId@var1792 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1848 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1793 , const std :: string & type@var1794 , const std :: string & msg@var1795 ) const ;
1407:
1408: void printOut ( const char * title@var1796 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1797 , const char * indent@var1798 ) const ;
1410: void printXml ( std :: ostream & out@var1799 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1800 , Token * tokens@var1801 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1802 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1803 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1804 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1805 , const Token * * tok@var1806 , const Token * argStart@var1807 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1808 , const Token * tok@var1809 , const Token * argStart@var1810 , const Token * funcStart@var1811 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1812 , const Token * & tok@var1813 , const Token * argStart@var1814 , const Token * funcStart@var1815 ) ;
1469: void addNewFunction ( Scope * * scope@var1816 , const Token * * tok@var1817 ) ;
1470: bool isFunction ( const Token * tok@var1818 , const Scope * outerScope@var1819 , const Token * * funcStart@var1820 , const Token * * argStart@var1821 , const Token * * declEnd@var1822 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1823 , const Scope * startScope@var1824 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1825 , const Scope * scope@var1826 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1827 , const Scope * ns@var1828 , const std :: string & path@var1829 , int path_length@var1830 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1831 , const Token * typeTok@var1832 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1833 , const Token * vartok@var1834 , Token * membertok@var1835 , const Variable * membervar@var1836 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1837 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1838 ) const ;
1485:
1486: void setValueType ( Token * tok@var1839 , const ValueType & valuetype@var1840 ) ;
1487: void setValueType ( Token * tok@var1841 , const Variable & var@var1842 ) ;
1488: void setValueType ( Token * tok@var1843 , const Enumerator & enumerator@var1844 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1845 ;
1491: const Settings * mSettings@var1846 ;
1492: ErrorLogger * mErrorLogger@var1847 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1848 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1849 ;
1499:
1500: bool mIsCpp@var1850 ;
1501: ValueType :: Sign mDefaultSignedness@var1851 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1852 ;
1505: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1853 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1854 ) {
47: mSettings@var1889 =@expr1073746197 settings@var1854 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1889 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1891 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1892 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1855 ) ;
72:
73: void addtoken ( const std :: string & str@var1856 , const int lineno@var1857 , const int column@var1858 , const int fileno@var1859 , bool split@var1860 = false ) ;
74: void addtoken ( const std :: string & str@var1861 , const Token * locationTok@var1862 ) ;
75:
76: void addtoken ( const Token * tok@var1863 , const int lineno@var1864 , const int column@var1865 , const int fileno@var1866 ) ;
77: void addtoken ( const Token * tok@var1867 , const Token * locationTok@var1868 ) ;
78: void addtoken ( const Token * tok@var1869 ) ;
79:
80: static void insertTokens ( Token * dest@var1870 , const Token * src@var1871 , int n@var1872 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1873 , const Token * first@var1874 , const Token * last@var1875 , bool one_line@var1876 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1877 , const std :: string & file0@var1878 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1879 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1880 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1886 .@expr1073746198 front@var1893 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1886 .@expr1073746199 front@var1893 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1886 .@expr1073746200 back@var1894 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1886 .@expr1073746201 back@var1894 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1887 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1881 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1882 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1883 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1884 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1885 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1886 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1887 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1888 ;
212:
213:
214: const Settings * mSettings@var1889 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1890 ;
217:
218:
219: bool mIsC@var1891 ;
220: bool mIsCpp@var1892 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var1895 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var1896 ;
67: mutable int mVarId@var1897 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var1898 ) ;
73: bool hasVariable ( const std :: string & varname@var1899 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var1900 ) const {
75: return mVariableId@var1895 .@expr1073746202 find (@expr1073746203 varname@var1900 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var1895 .@expr1073746204 end (@expr1073746205 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var1895 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746206 mVarId@var1897 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var1901 , ErrorLogger * errorLogger@var1902 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var1903 ) {
95: mTimerResults@var2023 =@expr1073746207 tr@var1903 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2001 .@expr1073746208 isC (@expr1073746209 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2001 .@expr1073746210 isCPP (@expr1073746211 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var1904 , bool * unknown@var1905 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var1906 , const std :: string & FileName@var1907 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var1908 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var1909 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var1910 ,
142: const char FileName@var1911 [ ] ,
143: const std :: string & configuration@var1912 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var1913 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var1914 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var1915 , const Token * end@var1916 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var1917 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var1918 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var1919 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var1920 , const Token * const tokEnd@var1921 , const bool only_k_r_fpar@var1922 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var1923 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var1924 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var1925 , bool commandWithCondition@var1926 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var1927 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var1928 , Token * * _tok2@var1929 , Token * * _tok3@var1930 , std :: string & value@var1931 , int & valueVarId@var1932 , bool & valueIsPointer@var1933 , bool floatvar@var1934 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var1935 , Token * tok3@var1936 , int varid@var1937 , const std :: string & structname@var1938 , std :: string & value@var1939 , int valueVarId@var1940 , bool valueIsPointer@var1941 , const Token * const valueToken@var1942 , int indentlevel@var1943 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var1944 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var1945 , const std :: string & endsWith@var1946 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1947 , const std :: string & endsWith@var1948 , bool cpp@var1949 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1950 ) {
585: mPreprocessor@var2024 =@expr1073746212 preprocessor@var1950 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2024 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1951 , const Token * end@var1952 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1953 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1954 , const std :: string & code@var1955 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1956 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1957 , const std :: string & what@var1958 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1959 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1960 , const std :: string & msg@var1961 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1962 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1963 , const std :: string & macroName@var1964 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1965 , const Token * end@var1966 , bool allowSemicolon@var1967 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1968 , const Severity :: SeverityType severity@var1969 , const std :: string & id@var1970 , const std :: string & msg@var1971 , bool inconclusive@var1972 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1973 , Severity :: SeverityType severity@var1974 , const std :: string & id@var1975 , const std :: string & msg@var1976 , bool inconclusive@var1977 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1978 , const Token * name@var1979 , const Token * typeDef@var1980 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1981 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1982 ,
821: const VariableMap & variableMap@var1983 ,
822: const int scopeStartVarId@var1984 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1985 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1986 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1987 ,
827: int * varId@var1988 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1989 ,
830: Token * const startToken@var1990 ,
831: const Token * const endToken@var1991 ,
832: const std :: map < std :: string , int > & varlist@var1992 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1993 ,
834: int * varId_@var1994 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1995 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1996 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2022 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1997 ) {
861: mSettings@var2008 =@expr1073746213 settings@var1997 ;
862: list@var2001 .@expr1073746214 setSettings (@expr1073746215 settings@var1997 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2010 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1998 ) const ;
877:
878: void dump ( std :: ostream & out@var1999 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2000 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2020 ;
888: }
889:
|
892:
893: TokenList list@var2001 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2001 .@expr1073746216 front (@expr1073746217 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2002 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2003 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2004 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2005 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2008 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2006 , bool inOperator@var2007 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746218 mVarId@var2020 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2008 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2009 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2010 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2011 ;
973:
974:
975:
976: std :: string mConfiguration@var2012 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2013 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2014 ;
983: std :: string filename@var2015 ;
984: int lineNumber@var2016 ;
985: int column@var2017 ;
986: bool used@var2018 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2019 ;
989:
990:
991: int mVarId@var2020 ;
992:
993:
994: int mUnnamedCount@var2021 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2022 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2023 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2024 ;
1013: } ;

##file cppcheck-2.8/lib/checkio.cpp

1:
|
44:
45: namespace {
46: CheckIO instance@var2025 ;
47: }
48:
49:
50: static const CWE CWE119@var2026 ( 119U ) ;
51: static const CWE CWE398@var2027 ( 398U ) ;
52: static const CWE CWE664@var2028 ( 664U ) ;
53: static const CWE CWE685@var2029 ( 685U ) ;
54: static const CWE CWE686@var2030 ( 686U ) ;
55: static const CWE CWE687@var2031 ( 687U ) ;
56: static const CWE CWE704@var2032 ( 704U ) ;
57: static const CWE CWE910@var2033 ( 910U ) ;
58:
|
61:
62: void CheckIO :: checkCoutCerrMisusage ( )
63: {
64: if (@expr1073746219 mTokenizer@var28 .@expr1073746220 isC (@expr1073746221 ) ) {
65: return ; }
66:
67: const SymbolDatabase * const symbolDatabase@var2034 ; symbolDatabase@var2034 =@expr1073746222 mTokenizer@var28 .@expr1073746223 getSymbolDatabase (@expr1073746224 ) ;
68: for (@expr1073746225 const Scope *@expr4402 scope@var2035 :@expr1073746227 symbolDatabase@var2034 .@expr1073746228 functionScopes@var2036 ) {
69: for (@expr1073746229 const Token *@expr4402 tok@var2037 =@expr1073746231 scope@var2035 .@expr1073746232 bodyStart@var2038 ; tok@var2037 &&@expr1073746233 tok@var2037 !=@expr1073746234 scope@var2035 .@expr1073746235 bodyEnd@var2039 ; tok@var2037 =@expr1073746236 tok@var2037 .@expr4413 next (@expr4414 ) ) {
70: if (@expr1073746239 Token ::@expr4416 Match (@expr1073746241 tok@var2037 , "std :: cout|cerr !!." ) &&@expr1073746242 tok@var2037 .@expr4413 next (@expr4414 ) .@expr4421 astParent (@expr4422 ) &&@expr1073746247 tok@var2037 .@expr4413 next (@expr4414 ) .@expr4421 astParent (@expr4422 ) .@expr1073746252 astOperand1 (@expr1073746253 ) ==@expr1073746254 tok@var2037 .@expr4413 next (@expr4414 ) ) {
71: const Token * tok2@var2040 ; tok2@var2040 =@expr1073746257 tok@var2037 .@expr4413 next (@expr4414 ) ;
72: while (@expr1073746260 tok2@var2040 .@expr4437 astParent (@expr4438 ) &&@expr1073746263 tok2@var2040 .@expr4437 astParent (@expr4438 ) .@expr1073746266 str (@expr1073746267 ) ==@expr1073746268 "<<" ) {
73: tok2@var2040 =@expr1073746269 tok2@var2040 .@expr4437 astParent (@expr4438 ) ;
74: if (@expr1073746272 tok2@var2040 .@expr4449 astOperand2 (@expr4450 ) &&@expr1073746275 Token ::@expr4416 Match (@expr1073746277 tok2@var2040 .@expr4449 astOperand2 (@expr4450 ) .@expr1073746280 previous (@expr1073746281 ) , "std :: cout|cerr" ) ) {
75: coutCerrMisusageError (@expr1073746282 tok@var2037 , tok2@var2040 .@expr4449 astOperand2 (@expr4450 ) .@expr1073746285 strAt (@expr1073746286 1 ) ) ; }
76: }
77: }
78: }
79: }
80: }
81:
82: void CheckIO :: coutCerrMisusageError ( const Token * tok@var2041 , const std :: string & streamName@var2042 )
83: {
84: reportError (@expr1073746287 tok@var2041 , Severity ::@expr1073746288 error , "coutCerrMisusage" , "Invalid usage of output stream: '<< std::" +@expr1073746289 streamName@var2042 +@expr1073746290 "'." , CWE398@var2027 , Certainty ::@expr1073746291 normal ) ;
85: }
86:
|
92:
93: enum class OpenMode { CLOSED , READ_MODE , WRITE_MODE , RW_MODE , UNKNOWN_OM } ;
94: static OpenMode getMode ( const std :: string & str@var2043 )
95: {
96: if (@expr1073746293 str@var2043 .@expr4470 find (@expr1073746295 '+' , 1 ) !=@expr1073746296 std ::@expr4473 string ::@expr4474 npos@expr4468 ) {
97: return OpenMode ::@expr1073746299 RW_MODE ; }
98: else { if (@expr1073746300 str@var2043 .@expr4470 find (@expr1073746302 'w' ) !=@expr1073746303 std ::@expr4473 string ::@expr4474 npos@expr4468 ||@expr1073746306 str@var2043 .@expr4470 find (@expr1073746308 'a' ) !=@expr1073746309 std ::@expr4473 string ::@expr4474 npos@expr4468 ) {
99: return OpenMode ::@expr1073746312 WRITE_MODE ; }
100: else { if (@expr1073746313 str@var2043 .@expr4470 find (@expr1073746315 'r' ) !=@expr1073746316 std ::@expr4473 string ::@expr4474 npos@expr4468 ) {
101: return OpenMode ::@expr1073746319 READ_MODE ; } } }
102: return OpenMode ::@expr1073746320 UNKNOWN_OM ;
103: }
104:
105: struct Filepointer {
106: OpenMode mode@var2044 ;
107: int mode_indent@var2045 ;
108: enum class Operation { NONE , UNIMPORTANT , READ , WRITE , POSITIONING , OPEN , CLOSE , UNKNOWN_OP } ; enum Operation lastOperation@var2046 ;
109: int op_indent@var2047 ;
110: enum class AppendMode { UNKNOWN_AM , APPEND , APPEND_EX } ;
111: AppendMode append_mode@var2048 ;
112: std :: string filename@var2049 ;
113: explicit Filepointer ( OpenMode mode_@var2050 = OpenMode :: UNKNOWN_OM )
114: : mode@var2044 ( mode_@var2050 ) , mode_indent@var2045 ( 0 ) , lastOperation@var2046 ( Operation :: NONE ) , op_indent@var2047 ( 0 ) , append_mode@var2048 ( AppendMode :: UNKNOWN_AM ) { }
115: } ;
116:
117: namespace {
118: const std :: unordered_set < std :: string > whitelist@var2051 = { "clearerr" , "feof" , "ferror" , "fgetpos" , "ftell" , "setbuf" , "setvbuf" , "ungetc" , "ungetwc" } ;
119: }
120:
121: void CheckIO :: checkFileUsage ( )
122: {
123: const bool windows@var2052 =@expr1073746324 mSettings@var29 .@expr1073746325 isWindowsPlatform (@expr1073746326 ) ;
124: const bool printPortability@var2053 =@expr1073746327 mSettings@var29 .@expr4504 severity@var2349 .@expr4505 isEnabled (@expr1073746330 Severity ::@expr1073746331 portability ) ;
125: const bool printWarnings@var2054 =@expr1073746332 mSettings@var29 .@expr4504 severity@var2349 .@expr4505 isEnabled (@expr1073746335 Severity ::@expr1073746336 warning ) ;
126:
127: std ::@expr1073746337 map < int , Filepointer > filepointers@var2055 ;
128:
129: const SymbolDatabase * symbolDatabase@var2056 ; symbolDatabase@var2056 =@expr1073746338 mTokenizer@var28 .@expr1073746339 getSymbolDatabase (@expr1073746340 ) ;
130: for (@expr1073746341 const Variable *@expr4518 var@var2057 :@expr1073746343 symbolDatabase@var2056 .@expr1073746344 variableList (@expr1073746345 ) ) {
131: if (@expr1073746346 !@expr1073746347 var@var2057 ||@expr1073746348 !@expr1073746349 var@var2057 .@expr4526 declarationId (@expr4527 ) ||@expr1073746352 var@var2057 .@expr1073746353 isArray (@expr1073746354 ) ||@expr1073746355 !@expr1073746356 Token ::@expr1073746357 simpleMatch (@expr1073746358 var@var2057 .@expr1073746359 typeStartToken (@expr1073746360 ) , "FILE *" ) ) {
132: continue ; }
133:
134: if (@expr1073746361 var@var2057 .@expr1073746362 isLocal (@expr1073746363 ) ) {
135: if (@expr1073746364 var@var2057 .@expr1073746365 nameToken (@expr1073746366 ) .@expr1073746367 strAt (@expr1073746368 1 ) ==@expr1073746369 "(" ) {
136: filepointers@var2055 .@expr4546 insert (@expr4547 std ::@expr4548 make_pair (@expr4549 var@var2057 .@expr4526 declarationId (@expr4527 ) , Filepointer (@expr4552 OpenMode ::@expr4553 UNKNOWN_OM ) ) ) ; }
137: else {
138: filepointers@var2055 .@expr4546 insert (@expr1073746379 std ::@expr4548 make_pair (@expr1073746381 var@var2057 .@expr4526 declarationId (@expr4527 ) , Filepointer (@expr1073746384 OpenMode ::@expr4561 CLOSED ) ) ) ; }
139: } else {
140: filepointers@var2055 .@expr4546 insert (@expr4547 std ::@expr4548 make_pair (@expr4549 var@var2057 .@expr4526 declarationId (@expr4527 ) , Filepointer (@expr4552 OpenMode ::@expr4553 UNKNOWN_OM ) ) ) ;
141:
142: }
143: }
144:
145: for (@expr1073746394 const Scope *@expr4518 scope@var2058 :@expr1073746396 symbolDatabase@var2056 .@expr1073746397 functionScopes@var2059 ) {
146: int indent@var2060 ; indent@var2060 =@expr1073746398 0 ;
147: for (@expr1073746399 const Token *@expr4518 tok@var2061 =@expr1073746401 scope@var2058 .@expr1073746402 bodyStart@var2062 ; tok@var2061 !=@expr1073746403 scope@var2058 .@expr1073746404 bodyEnd@var2063 ; tok@var2061 =@expr1073746405 tok@var2061 .@expr1073746406 next (@expr1073746407 ) ) {
148: if (@expr1073746408 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746411 "{" ) {
149: indent@var2060 ++@expr1073746412 ; }
150: else { if (@expr1073746413 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746416 "}" ) {
151: indent@var2060 --@expr1073746417 ;
152: for (@expr1073746418 std ::@expr4595 pair < const int , Filepointer > &@expr4596 filepointer@var2064 :@expr1073746421 filepointers@var2055 ) {
153: if (@expr1073746422 indent@var2060 <@expr1073746423 filepointer@var2064 .@expr4600 second@var2065 .@expr4601 mode_indent@var2066 ) {
154: filepointer@var2064 .@expr4600 second@var2065 .@expr4601 mode_indent@var2066 =@expr1073746428 0 ;
155: filepointer@var2064 .@expr4600 second@var2065 .@expr1073746430 mode@var2067 =@expr1073746431 OpenMode ::@expr4553 UNKNOWN_OM ;
156: }
157: if (@expr1073746433 indent@var2060 <@expr1073746434 filepointer@var2064 .@expr4600 second@var2065 .@expr4612 op_indent@var2068 ) {
158: filepointer@var2064 .@expr4600 second@var2065 .@expr4612 op_indent@var2068 =@expr1073746439 0 ;
159: filepointer@var2064 .@expr4600 second@var2065 .@expr1073746441 lastOperation@var2069 =@expr1073746442 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
160: }
161: }
162: } else { if (@expr1073746445 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746448 "return" ||@expr1073746449 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746452 "continue" ||@expr1073746453 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746456 "break" ||@expr1073746457 mSettings@var29 .@expr4634 library@var2350 .@expr1073746459 isnoreturn (@expr1073746460 tok@var2061 ) ) {
163: for (@expr1073746461 std ::@expr4595 pair < const int , Filepointer > &@expr4596 filepointer@var2070 :@expr1073746464 filepointers@var2055 ) {
164: filepointer@var2070 .@expr4641 second@var2071 .@expr1073746466 mode_indent@var2072 =@expr1073746467 0 ;
165: filepointer@var2070 .@expr4641 second@var2071 .@expr1073746469 mode@var2073 =@expr1073746470 OpenMode ::@expr4553 UNKNOWN_OM ;
166: filepointer@var2070 .@expr4641 second@var2071 .@expr1073746473 op_indent@var2074 =@expr1073746474 0 ;
167: filepointer@var2070 .@expr4641 second@var2071 .@expr1073746476 lastOperation@var2075 =@expr1073746477 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
168: }
169: } else { if (@expr1073746480 Token ::@expr4657 Match (@expr1073746482 tok@var2061 , "%var% =" ) &&@expr1073746483
170: (@expr1073746484 tok@var2061 .@expr4661 strAt (@expr4662 2 ) !=@expr1073746487 "fopen" &&@expr1073746488 tok@var2061 .@expr4661 strAt (@expr4662 2 ) !=@expr1073746491 "freopen" &&@expr1073746492 tok@var2061 .@expr4661 strAt (@expr4662 2 ) !=@expr1073746495 "tmpfile" &&@expr1073746496
171: (@expr1073746497 windows@var2052 ?@expr1073746498 (@expr1073746499 tok@var2061 .@expr4585 str (@expr4586 ) !=@expr1073746502 "_wfopen" &&@expr1073746503 tok@var2061 .@expr4585 str (@expr4586 ) !=@expr1073746506 "_wfreopen" ) :@expr1073746507 true ) ) ) {
172: std ::@expr1073746508 map < int , Filepointer > ::@expr1073746509 iterator i@var2076 ; i@var2076 =@expr1073746510 filepointers@var2055 .@expr4687 find (@expr1073746512 tok@var2061 .@expr1073746513 varId (@expr1073746514 ) ) ;
173: if (@expr1073746515 i@var2076 !=@expr1073746516 filepointers@var2055 .@expr4693 end (@expr4694 ) ) {
174: i@var2076 .@expr4695 second@var2077 .@expr1073746520 mode@var2078 =@expr1073746521 OpenMode ::@expr4553 UNKNOWN_OM ;
175: i@var2076 .@expr4695 second@var2077 .@expr1073746524 lastOperation@var2079 =@expr1073746525 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
176: }
177: } else { if (@expr1073746528 Token ::@expr4657 Match (@expr1073746530 tok@var2061 , "%name% (" ) &&@expr1073746531 tok@var2061 .@expr4708 previous (@expr4709 ) &&@expr1073746534 (@expr1073746535 !@expr1073746536 tok@var2061 .@expr4708 previous (@expr4709 ) .@expr1073746539 isName (@expr1073746540 ) ||@expr1073746541 Token ::@expr4657 Match (@expr1073746543 tok@var2061 .@expr4708 previous (@expr4709 ) , "return|throw" ) ) ) {
178: std ::@expr1073746546 string mode@var2080 ;
179: const Token * fileTok@var2081 ; fileTok@var2081 =@expr1073746547 nullptr ;
180: const Token * fileNameTok@var2082 ; fileNameTok@var2082 =@expr1073746548 nullptr ;
181: Filepointer ::@expr1073746549 Operation operation@var2083 ; operation@var2083 =@expr1073746550 Filepointer ::@expr4619 Operation ::@expr4728 NONE@expr1073746321 ;
182:
183: if (@expr1073746553 (@expr1073746554 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746557 "fopen" ||@expr1073746558 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746561 "freopen" ||@expr1073746562 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746565 "tmpfile" ||@expr1073746566
184: (@expr1073746567 windows@var2052 &&@expr1073746568 (@expr1073746569 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746572 "_wfopen" ||@expr1073746573 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746576 "_wfreopen" ) ) ) &&@expr1073746577
185: tok@var2061 .@expr4661 strAt (@expr4755 -1 ) ==@expr1073746580 "=" ) {
186: if (@expr1073746581 tok@var2061 .@expr4585 str (@expr4586 ) !=@expr1073746584 "tmpfile" ) {
187: const Token * modeTok@var2084 ; modeTok@var2084 =@expr1073746585 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) .@expr4764 nextArgument (@expr4765 ) ;
188: if (@expr1073746590 modeTok@var2084 &&@expr1073746591 modeTok@var2084 .@expr1073746592 tokType (@expr1073746593 ) ==@expr1073746594 Token ::@expr4771 eString ) {
189: mode@var2080 =@expr1073746596 modeTok@var2084 .@expr1073746597 strValue (@expr1073746598 ) ; }
190: } else {
191: mode@var2080 =@expr1073746599 "wb+" ; }
192: fileTok@var2081 =@expr1073746600 tok@var2061 .@expr4762 tokAt (@expr1073746602 -2 ) ;
193: operation@var2083 =@expr1073746603 Filepointer ::@expr4619 Operation ::@expr4781 OPEN ;
194: if (@expr1073746606 Token ::@expr4657 Match (@expr1073746608 tok@var2061 , "fopen ( %str% ," ) ) {
195: fileNameTok@var2082 =@expr1073746609 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ; }
196: } else { if (@expr1073746612 windows@var2052 &&@expr1073746613 Token ::@expr4657 Match (@expr1073746615 tok@var2061 , "fopen_s|freopen_s|_wfopen_s|_wfreopen_s ( & %name%" ) ) {
197: const Token * modeTok@var2085 ; modeTok@var2085 =@expr1073746616 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) .@expr4764 nextArgument (@expr4765 ) .@expr1073746621 nextArgument (@expr1073746622 ) ;
198: if (@expr1073746623 modeTok@var2085 &&@expr1073746624 modeTok@var2085 .@expr1073746625 tokType (@expr1073746626 ) ==@expr1073746627 Token ::@expr4771 eString ) {
199: mode@var2080 =@expr1073746629 modeTok@var2085 .@expr1073746630 strValue (@expr1073746631 ) ; }
200: fileTok@var2081 =@expr1073746632 tok@var2061 .@expr4762 tokAt (@expr1073746634 3 ) ;
201: operation@var2083 =@expr1073746635 Filepointer ::@expr4619 Operation ::@expr4781 OPEN ;
202: } else { if (@expr1073746638 (@expr1073746639 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746642 "rewind" ||@expr1073746643 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746646 "fseek" ||@expr1073746647 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746650 "fsetpos" ||@expr1073746651 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr4830 "fflush" ) ||@expr1073746655
203: (@expr1073746656 windows@var2052 &&@expr1073746657 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746660 "_fseeki64" ) ) {
204: fileTok@var2081 =@expr1073746661 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ;
205: if (@expr1073746664 printPortability@var2053 &&@expr1073746665 fileTok@var2081 &&@expr1073746666 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr4830 "fflush" ) {
206: if (@expr1073746670 fileTok@var2081 .@expr4847 str (@expr4848 ) ==@expr1073746673 "stdin" ) {
207: fflushOnInputStreamError (@expr4850 tok@var2061 , fileTok@var2081 .@expr4847 str (@expr4848 ) ) ; }
208: else {
209: const Filepointer &@expr4596 f@var2086 =@expr1073746678 filepointers@var2055 [@expr4855 fileTok@var2081 .@expr4856 varId (@expr4857 ) ] ;
210: if (@expr1073746682 f@var2086 .@expr1073746683 mode@var2087 ==@expr1073746684 OpenMode ::@expr4861 READ_MODE ) {
211: fflushOnInputStreamError (@expr4850 tok@var2061 , fileTok@var2081 .@expr4847 str (@expr4848 ) ) ; }
212: }
213: }
214: operation@var2083 =@expr1073746689 Filepointer ::@expr4619 Operation ::@expr4867 POSITIONING ;
215: } else { if (@expr1073746692 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746695 "fgetc" ||@expr1073746696 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746699 "fgetwc" ||@expr1073746700
216: tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746703 "fgets" ||@expr1073746704 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746707 "fgetws" ||@expr1073746708 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746711 "fread" ||@expr1073746712
217: tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746715 "fscanf" ||@expr1073746716 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746719 "fwscanf" ||@expr1073746720 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746723 "getc" ||@expr1073746724
218: (@expr1073746725 windows@var2052 &&@expr1073746726 (@expr1073746727 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746730 "fscanf_s" ||@expr1073746731 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746734 "fwscanf_s" ) ) ) {
219: if (@expr1073746735 tok@var2061 .@expr4585 str (@expr4586 ) .@expr4914 find (@expr1073746739 "scanf" ) !=@expr1073746740 std ::@expr4917 string ::@expr4918 npos@expr4498 ) {
220: fileTok@var2081 =@expr1073746743 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ; }
221: else {
222: fileTok@var2081 =@expr1073746746 tok@var2061 .@expr4923 linkAt (@expr4924 1 ) .@expr4925 previous (@expr4926 ) ; }
223: operation@var2083 =@expr1073746751 Filepointer ::@expr4619 Operation ::@expr4929 READ ;
224: } else { if (@expr1073746754 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746757 "fputc" ||@expr1073746758 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746761 "fputwc" ||@expr1073746762
225: tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746765 "fputs" ||@expr1073746766 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746769 "fputws" ||@expr1073746770 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746773 "fwrite" ||@expr1073746774
226: tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746777 "fprintf" ||@expr1073746778 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746781 "fwprintf" ||@expr1073746782 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746785 "putcc" ||@expr1073746786
227: (@expr1073746787 windows@var2052 &&@expr1073746788 (@expr1073746789 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746792 "fprintf_s" ||@expr1073746793 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746796 "fwprintf_s" ) ) ) {
228: if (@expr1073746797 tok@var2061 .@expr4585 str (@expr4586 ) .@expr4914 find (@expr1073746801 "printf" ) !=@expr1073746802 std ::@expr4917 string ::@expr4918 npos@expr4498 ) {
229: fileTok@var2081 =@expr1073746805 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ; }
230: else {
231: fileTok@var2081 =@expr1073746808 tok@var2061 .@expr4923 linkAt (@expr4924 1 ) .@expr4925 previous (@expr4926 ) ; }
232: operation@var2083 =@expr1073746813 Filepointer ::@expr4619 Operation ::@expr4991 WRITE ;
233: } else { if (@expr1073746816 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746819 "fclose" ) {
234: fileTok@var2081 =@expr1073746820 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ;
235: operation@var2083 =@expr1073746823 Filepointer ::@expr4619 Operation ::@expr5001 CLOSE ;
236: } else { if (@expr1073746826 whitelist@var2051 .@expr1073746827 find (@expr1073746828 tok@var2061 .@expr4585 str (@expr4586 ) ) !=@expr1073746831 whitelist@var2051 .@expr1073746832 end (@expr1073746833 ) ) {
237: fileTok@var2081 =@expr1073746834 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ;
238: if (@expr1073746837 (@expr1073746838 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746841 "ungetc" ||@expr1073746842 tok@var2061 .@expr4585 str (@expr4586 ) ==@expr1073746845 "ungetwc" ) &&@expr1073746846 fileTok@var2081 ) {
239: fileTok@var2081 =@expr1073746847 fileTok@var2081 .@expr1073746848 nextArgument (@expr1073746849 ) ; }
240: operation@var2083 =@expr1073746850 Filepointer ::@expr4619 Operation ::@expr5028 UNIMPORTANT ;
241: } else { if (@expr1073746853 !@expr1073746854 Token ::@expr4657 Match (@expr1073746856 tok@var2061 , "if|for|while|catch|switch" ) &&@expr1073746857 !@expr1073746858 mSettings@var29 .@expr4634 library@var2350 .@expr1073746860 isFunctionConst (@expr1073746861 tok@var2061 .@expr4585 str (@expr4586 ) , true ) ) {
242: const Token * const end2@var2088 ; end2@var2088 =@expr1073746864 tok@var2061 .@expr4923 linkAt (@expr4924 1 ) ;
243: if (@expr1073746867 scope@var2058 .@expr5044 functionOf@var2089 &&@expr1073746869 scope@var2058 .@expr5044 functionOf@var2089 .@expr1073746871 isClassOrStruct (@expr1073746872 ) &&@expr1073746873 !@expr1073746874 scope@var2058 .@expr1073746875 function@var2090 .@expr1073746876 isStatic (@expr1073746877 ) &&@expr1073746878 (@expr1073746879 (@expr1073746880 tok@var2061 .@expr4661 strAt (@expr4755 -1 ) !=@expr1073746883 "::" &&@expr1073746884 tok@var2061 .@expr4661 strAt (@expr4755 -1 ) !=@expr1073746887 "." ) ||@expr1073746888 tok@var2061 .@expr4661 strAt (@expr1073746890 -2 ) ==@expr1073746891 "this" ) ) {
244: if (@expr1073746892 !@expr1073746893 tok@var2061 .@expr5070 function (@expr5071 ) ||@expr1073746896 (@expr1073746897 tok@var2061 .@expr5070 function (@expr5071 ) .@expr5076 nestedIn@var2362 &&@expr1073746901 tok@var2061 .@expr5070 function (@expr5071 ) .@expr5076 nestedIn@var2362 .@expr1073746905 isClassOrStruct (@expr1073746906 ) ) ) {
245: for (@expr1073746907 std ::@expr4595 pair < const int , Filepointer > &@expr4596 filepointer@var2091 :@expr1073746910 filepointers@var2055 ) {
246: const Variable * var@var2092 ; var@var2092 =@expr1073746911 symbolDatabase@var2056 .@expr1073746912 getVariableFromVarId (@expr1073746913 filepointer@var2091 .@expr1073746914 first@var2093 ) ;
247: if (@expr1073746915 !@expr1073746916 var@var2092 ||@expr1073746917 !@expr1073746918 (@expr1073746919 var@var2092 .@expr1073746920 isLocal (@expr1073746921 ) ||@expr1073746922 var@var2092 .@expr1073746923 isGlobal (@expr1073746924 ) ||@expr1073746925 var@var2092 .@expr1073746926 isStatic (@expr1073746927 ) ) ) {
248: filepointer@var2091 .@expr5104 second@var2094 .@expr1073746929 mode@var2095 =@expr1073746930 OpenMode ::@expr4553 UNKNOWN_OM ;
249: filepointer@var2091 .@expr5104 second@var2094 .@expr1073746933 mode_indent@var2096 =@expr1073746934 0 ;
250: filepointer@var2091 .@expr5104 second@var2094 .@expr1073746936 op_indent@var2097 =@expr1073746937 indent@var2060 ;
251: filepointer@var2091 .@expr5104 second@var2094 .@expr1073746939 lastOperation@var2098 =@expr1073746940 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
252: }
253: }
254: continue ;
255: }
256: }
257: for (@expr1073746943 const Token *@expr4518 tok2@var2099 =@expr1073746945 tok@var2061 .@expr4762 tokAt (@expr4763 2 ) ; tok2@var2099 !=@expr1073746948 end2@var2088 ; tok2@var2099 =@expr1073746949 tok2@var2099 .@expr1073746950 next (@expr1073746951 ) ) {
258: if (@expr1073746952 tok2@var2099 .@expr5129 varId (@expr5130 ) &&@expr1073746955 filepointers@var2055 .@expr4687 find (@expr1073746957 tok2@var2099 .@expr5129 varId (@expr5130 ) ) !=@expr1073746960 filepointers@var2055 .@expr4693 end (@expr4694 ) ) {
259: fileTok@var2081 =@expr1073746963 tok2@var2099 ;
260: operation@var2083 =@expr1073746964 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
261: break ;
262: }
263: }
264: } } } } } } } }
265:
266: while (@expr1073746967 Token ::@expr4657 Match (@expr1073746969 fileTok@var2081 , "%name% ." ) ) {
267: fileTok@var2081 =@expr1073746970 fileTok@var2081 .@expr1073746971 tokAt (@expr1073746972 2 ) ; }
268:
269: if (@expr1073746973 !@expr1073746974 fileTok@var2081 ||@expr1073746975 !@expr1073746976 fileTok@var2081 .@expr4856 varId (@expr4857 ) ||@expr1073746979 fileTok@var2081 .@expr1073746980 strAt (@expr1073746981 1 ) ==@expr1073746982 "[" ) {
270: continue ; }
271:
272: if (@expr1073746983 filepointers@var2055 .@expr4687 find (@expr1073746985 fileTok@var2081 .@expr4856 varId (@expr4857 ) ) ==@expr1073746988 filepointers@var2055 .@expr4693 end (@expr4694 ) ) {
273: filepointers@var2055 .@expr4546 insert (@expr1073746992 std ::@expr4548 make_pair (@expr1073746994 fileTok@var2081 .@expr4856 varId (@expr4857 ) , Filepointer (@expr4552 OpenMode ::@expr4553 UNKNOWN_OM ) ) ) ;
274: }
275:
276: Filepointer &@expr4596 f@var2100 =@expr1073747000 filepointers@var2055 [@expr4855 fileTok@var2081 .@expr4856 varId (@expr4857 ) ] ;
277:
278: switch (@expr1073747004 operation@var2083 ) {
279: case Filepointer ::@expr4619 Operation ::@expr4781 OPEN :@expr5183 ;
280: if (@expr1073747008 fileNameTok@var2082 ) {
281: for (@expr1073747009 std ::@expr4595 map < int , Filepointer > ::@expr4595 const_iterator it@var2101 =@expr1073747012 filepointers@var2055 .@expr1073747013 cbegin (@expr1073747014 ) ; it@var2101 !=@expr1073747015 filepointers@var2055 .@expr1073747016 cend (@expr1073747017 ) ; ++@expr1073747018 it@var2101 ) {
282: const Filepointer &@expr4596 fptr@var2102 =@expr1073747020 it@var2101 .@expr1073747021 second@var2103 ;
283: if (@expr1073747022 fptr@var2102 .@expr1073747023 filename@var2104 ==@expr1073747024 fileNameTok@var2082 .@expr5201 str (@expr5202 ) &&@expr1073747027 (@expr1073747028 fptr@var2102 .@expr5205 mode@var2105 ==@expr1073747030 OpenMode ::@expr5207 RW_MODE ||@expr1073747032 fptr@var2102 .@expr5205 mode@var2105 ==@expr1073747034 OpenMode ::@expr5211 WRITE_MODE ) ) {
284: incompatibleFileOpenError (@expr1073747036 tok@var2061 , fileNameTok@var2082 .@expr5201 str (@expr5202 ) ) ; }
285: }
286:
287: f@var2100 .@expr1073747039 filename@var2106 =@expr1073747040 fileNameTok@var2082 .@expr5201 str (@expr5202 ) ;
288: }
289:
290: f@var2100 .@expr5219 mode@var2107 =@expr1073747044 getMode (@expr1073747045 mode@var2080 ) ;
291: if (@expr1073747046 mode@var2080 .@expr1073747047 find (@expr1073747048 'a' ) !=@expr1073747049 std ::@expr4917 string ::@expr4918 npos@expr4498 ) {
292: if (@expr1073747052 f@var2100 .@expr5219 mode@var2107 ==@expr1073747054 OpenMode ::@expr5207 RW_MODE ) {
293: f@var2100 .@expr5232 append_mode@var2108 =@expr1073747057 Filepointer ::@expr5234 AppendMode ::@expr1073747059 APPEND_EX ; }
294: else {
295: f@var2100 .@expr5232 append_mode@var2108 =@expr1073747061 Filepointer ::@expr5234 AppendMode ::@expr5239 APPEND ; }
296: } else {
297: f@var2100 .@expr5232 append_mode@var2108 =@expr1073747065 Filepointer ::@expr5234 AppendMode ::@expr1073747067 UNKNOWN_AM@expr1073746323 ; }
298: f@var2100 .@expr5244 mode_indent@var2109 =@expr1073747069 indent@var2060 ;
299: break ;
300: case Filepointer ::@expr4619 Operation ::@expr4867 POSITIONING :@expr5183 ;
301: if (@expr5249 f@var2100 .@expr5219 mode@var2107 ==@expr5251 OpenMode ::@expr4561 CLOSED ) {
302: useClosedFileError (@expr5253 tok@var2061 ) ; }
303: else { if (@expr1073747078 f@var2100 .@expr5232 append_mode@var2108 ==@expr1073747080 Filepointer ::@expr5234 AppendMode ::@expr5239 APPEND &&@expr1073747083 tok@var2061 .@expr4585 str (@expr4586 ) !=@expr1073747086 "fflush" &&@expr1073747087 printWarnings@var2054 ) {
304: seekOnAppendedFileError (@expr1073747088 tok@var2061 ) ; } }
305: break ;
306: case Filepointer ::@expr4619 Operation ::@expr4929 READ :@expr5183 ;
307: if (@expr5249 f@var2100 .@expr5219 mode@var2107 ==@expr5251 OpenMode ::@expr4561 CLOSED ) {
308: useClosedFileError (@expr5253 tok@var2061 ) ; }
309: else { if (@expr1073747097 f@var2100 .@expr5219 mode@var2107 ==@expr1073747099 OpenMode ::@expr5211 WRITE_MODE ) {
310: readWriteOnlyFileError (@expr1073747101 tok@var2061 ) ; }
311: else { if (@expr1073747102 f@var2100 .@expr5279 lastOperation@var2110 ==@expr1073747104 Filepointer ::@expr4619 Operation ::@expr4991 WRITE ) {
312: ioWithoutPositioningError (@expr5283 tok@var2061 ) ; } } }
313: break ;
314: case Filepointer ::@expr4619 Operation ::@expr4991 WRITE :@expr5183 ;
315: if (@expr5249 f@var2100 .@expr5219 mode@var2107 ==@expr5251 OpenMode ::@expr4561 CLOSED ) {
316: useClosedFileError (@expr5253 tok@var2061 ) ; }
317: else { if (@expr1073747116 f@var2100 .@expr5219 mode@var2107 ==@expr1073747118 OpenMode ::@expr4861 READ_MODE ) {
318: writeReadOnlyFileError (@expr1073747120 tok@var2061 ) ; }
319: else { if (@expr1073747121 f@var2100 .@expr5279 lastOperation@var2110 ==@expr1073747123 Filepointer ::@expr4619 Operation ::@expr4929 READ ) {
320: ioWithoutPositioningError (@expr5283 tok@var2061 ) ; } } }
321: break ;
322: case Filepointer ::@expr4619 Operation ::@expr5001 CLOSE :@expr5183 ;
323: if (@expr5249 f@var2100 .@expr5219 mode@var2107 ==@expr5251 OpenMode ::@expr4561 CLOSED ) {
324: useClosedFileError (@expr5253 tok@var2061 ) ; }
325: else {
326: f@var2100 .@expr5219 mode@var2107 =@expr1073747136 OpenMode ::@expr4561 CLOSED ; }
327: f@var2100 .@expr5244 mode_indent@var2109 =@expr1073747139 indent@var2060 ;
328: break ;
329: case Filepointer ::@expr4619 Operation ::@expr5028 UNIMPORTANT :@expr5183 ;
330: if (@expr5249 f@var2100 .@expr5219 mode@var2107 ==@expr5251 OpenMode ::@expr4561 CLOSED ) {
331: useClosedFileError (@expr5253 tok@var2061 ) ; }
332: break ;
333: case Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP :@expr5183 ;
334: f@var2100 .@expr5219 mode@var2107 =@expr1073747152 OpenMode ::@expr4553 UNKNOWN_OM ;
335: f@var2100 .@expr5244 mode_indent@var2109 =@expr1073747155 0 ;
336: break ;
337: default :@expr5183 ;
338: break ;
339: }
340: if (@expr1073747157 operation@var2083 !=@expr1073747158 Filepointer ::@expr4619 Operation ::@expr4728 NONE &&@expr1073747161 operation@var2083 !=@expr1073747162 Filepointer ::@expr4619 Operation ::@expr5028 UNIMPORTANT ) {
341: f@var2100 .@expr1073747165 op_indent@var2111 =@expr1073747166 indent@var2060 ;
342: f@var2100 .@expr5279 lastOperation@var2110 =@expr1073747168 operation@var2083 ;
343: }
344: } } } } }
345: }
346: for (@expr1073747169 std ::@expr4595 pair < const int , Filepointer > &@expr4596 filepointer@var2112 :@expr1073747172 filepointers@var2055 ) {
347: filepointer@var2112 .@expr5349 second@var2113 .@expr1073747174 op_indent@var2114 =@expr1073747175 0 ;
348: filepointer@var2112 .@expr5349 second@var2113 .@expr1073747177 mode@var2115 =@expr1073747178 OpenMode ::@expr4553 UNKNOWN_OM ;
349: filepointer@var2112 .@expr5349 second@var2113 .@expr1073747181 lastOperation@var2116 =@expr1073747182 Filepointer ::@expr4619 Operation ::@expr4620 UNKNOWN_OP ;
350: }
351: }
352: }
353:
354: void CheckIO :: fflushOnInputStreamError ( const Token * tok@var2117 , const std :: string & varname@var2118 )
355: {
356: reportError (@expr1073747185 tok@var2117 , Severity ::@expr1073747186 portability ,
357: "fflushOnInputStream" , "fflush() called on input stream '" +@expr1073747187 varname@var2118 +@expr1073747188 "' may result in undefined behaviour on non-linux systems." , CWE398@var2027 , Certainty ::@expr1073747189 normal ) ;
358: }
359:
360: void CheckIO :: ioWithoutPositioningError ( const Token * tok@var2119 )
361: {
362: reportError (@expr1073747190 tok@var2119 , Severity ::@expr1073747191 error ,
363: "IOWithoutPositioning" , "Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour." , CWE664@var2028 , Certainty ::@expr1073747192 normal ) ;
364: }
365:
366: void CheckIO :: readWriteOnlyFileError ( const Token * tok@var2120 )
367: {
368: reportError (@expr1073747193 tok@var2120 , Severity ::@expr1073747194 error ,
369: "readWriteOnlyFile" , "Read operation on a file that was opened only for writing." , CWE664@var2028 , Certainty ::@expr1073747195 normal ) ;
370: }
371:
372: void CheckIO :: writeReadOnlyFileError ( const Token * tok@var2121 )
373: {
374: reportError (@expr1073747196 tok@var2121 , Severity ::@expr1073747197 error ,
375: "writeReadOnlyFile" , "Write operation on a file that was opened only for reading." , CWE664@var2028 , Certainty ::@expr1073747198 normal ) ;
376: }
377:
378: void CheckIO :: useClosedFileError ( const Token * tok@var2122 )
379: {
380: reportError (@expr1073747199 tok@var2122 , Severity ::@expr1073747200 error ,
381: "useClosedFile" , "Used file that is not opened." , CWE910@var2033 , Certainty ::@expr1073747201 normal ) ;
382: }
383:
384: void CheckIO :: seekOnAppendedFileError ( const Token * tok@var2123 )
385: {
386: reportError (@expr1073747202 tok@var2123 , Severity ::@expr1073747203 warning ,
387: "seekOnAppendedFile" , "Repositioning operation performed on a file opened in append mode has no effect." , CWE398@var2027 , Certainty ::@expr1073747204 normal ) ;
388: }
389:
390: void CheckIO :: incompatibleFileOpenError ( const Token * tok@var2124 , const std :: string & filename@var2125 )
391: {
392: reportError (@expr1073747205 tok@var2124 , Severity ::@expr1073747206 warning ,
393: "incompatibleFileOpen" , "The file '" +@expr1073747207 filename@var2125 +@expr1073747208 "' is opened for read and write access at the same time on different streams" , CWE664@var2028 , Certainty ::@expr1073747209 normal ) ;
394: }
395:
|
399:
400: void CheckIO :: invalidScanf ( )
401: {
402: if (@expr1073747210 !@expr1073747211 mSettings@var29 .@expr1073747212 severity@var2349 .@expr1073747213 isEnabled (@expr1073747214 Severity ::@expr1073747215 warning ) ) {
403: return ; }
404:
405: const SymbolDatabase * const symbolDatabase@var2126 ; symbolDatabase@var2126 =@expr1073747216 mTokenizer@var28 .@expr1073747217 getSymbolDatabase (@expr1073747218 ) ;
406: for (@expr1073747219 const Scope *@expr5396 scope@var2127 :@expr1073747221 symbolDatabase@var2126 .@expr1073747222 functionScopes@var2128 ) {
407: for (@expr1073747223 const Token *@expr5396 tok@var2129 =@expr1073747225 scope@var2127 .@expr1073747226 bodyStart@var2130 .@expr1073747227 next (@expr1073747228 ) ; tok@var2129 !=@expr1073747229 scope@var2127 .@expr1073747230 bodyEnd@var2131 ; tok@var2129 =@expr1073747231 tok@var2129 .@expr1073747232 next (@expr1073747233 ) ) {
408: const Token * formatToken@var2132 ; formatToken@var2132 =@expr1073747234 nullptr ;
409: if (@expr1073747235 Token ::@expr5412 Match (@expr1073747237 tok@var2129 , "scanf|vscanf ( %str% ," ) ) {
410: formatToken@var2132 =@expr1073747238 tok@var2129 .@expr5415 tokAt (@expr5416 2 ) ; }
411: else { if (@expr1073747241 Token ::@expr5412 Match (@expr1073747243 tok@var2129 , "sscanf|vsscanf|fscanf|vfscanf (" ) ) {
412: const Token * nextArg@var2133 ; nextArg@var2133 =@expr1073747244 tok@var2129 .@expr5415 tokAt (@expr5416 2 ) .@expr1073747247 nextArgument (@expr1073747248 ) ;
413: if (@expr1073747249 nextArg@var2133 &&@expr1073747250 nextArg@var2133 .@expr1073747251 tokType (@expr1073747252 ) ==@expr1073747253 Token ::@expr1073747254 eString ) {
414: formatToken@var2132 =@expr1073747255 nextArg@var2133 ; }
415: else {
416: continue ; }
417: } else {
418: continue ; } }
419:
420: bool format@var2134 ; format@var2134 =@expr1073747256 false ;
421:
422:
423: const std ::@expr1073747257 string & formatstr@var2135 (@expr1073747258 formatToken@var2132 .@expr1073747259 str (@expr1073747260 ) ) ;
424: for (@expr1073747261 unsigned long i@var2136 =@expr1073747262 1 ; i@var2136 <@expr1073747263 formatstr@var2135 .@expr1073747264 length (@expr1073747265 ) ; i@var2136 ++@expr1073747266 ) {
425: if (@expr1073747267 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr1073747269 '%' ) {
426: format@var2134 =@expr1073747270 !@expr5447 format@var2134 ; }
427:
428: else { if (@expr1073747272 !@expr5447 format@var2134 ) {
429: continue ; }
430:
431: else { if (@expr1073747274 std ::@expr1073747275 isdigit (@expr1073747276 formatstr@var2135 [@expr5444 i@var2136 ] ) ||@expr1073747278 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr1073747280 '*' ) {
432: format@var2134 =@expr1073747281 false ;
433: }
434:
435: else { if (@expr1073747282 std ::@expr1073747283 isalpha (@expr1073747284 (@expr1073747285 unsigned char ) formatstr@var2135 [@expr5444 i@var2136 ] ) ||@expr1073747287 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr5465 '[' ) {
436: if (@expr1073747290 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr1073747292 's' ||@expr1073747293 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr5465 '[' ||@expr1073747296 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr1073747298 'S' ||@expr1073747299 (@expr1073747300 formatstr@var2135 [@expr5444 i@var2136 ] ==@expr1073747302 'l' &&@expr1073747303 formatstr@var2135 [@expr1073747304 i@var2136 +@expr1073747305 1 ] ==@expr1073747306 's' ) ) {
437: invalidScanfError (@expr1073747307 tok@var2129 ) ; }
438: format@var2134 =@expr1073747308 false ;
439: } } } }
440: }
441: }
442: }
443: }
444:
445: void CheckIO :: invalidScanfError ( const Token * tok@var2137 )
446: {
447: const std ::@expr1073747309 string fname@var2138 =@expr1073747310 tok@var2137 ?@expr1073747311 tok@var2137 .@expr1073747312 str (@expr1073747313 ) :@expr1073747314 std ::@expr1073747315 string (@expr1073747316 "scanf" ) ;
448: reportError (@expr1073747317 tok@var2137 , Severity ::@expr1073747318 warning ,
449: "invalidscanf" , fname@var2138 +@expr1073747319 "() without field width limits can crash with huge input data.\n" +@expr1073747320
450: fname@var2138 +@expr1073747321 "() without field width limits can crash with huge input data. Add a field width specifier to fix this problem.\n\nSample program that can crash:\n\n#include <stdio.h>\nint main()\n{\n    char c[5];\n    scanf(\"%s\", c);\n    return 0;\n}\n\nTyping in 5 or more characters may make the program crash. The correct usage here is 'scanf(\"%4s\", c);', as the maximum field width does not include the terminating null byte.\nSource: http://linux.die.net/man/3/scanf\nSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c"
451:
|
466:
467: ,
468: CWE119@var2026 , Certainty ::@expr1073747322 normal ) ;
469: }
470:
|
476:
477: static bool findFormat ( int arg@var2139 , const Token * firstArg@var2140 ,
478: const Token * * formatStringTok@var2141 , const Token * * formatArgTok@var2142 )
479: {
480: const Token * argTok@var2143 ; argTok@var2143 =@expr1073747323 firstArg@var2140 ;
481:
482: for (@expr1073747324 int i@var2144 =@expr1073747325 0 ; i@var2144 <@expr1073747326 arg@var2139 &&@expr1073747327 argTok@var2143 ; ++@expr1073747328 i@var2144 ) {
483: argTok@var2143 =@expr1073747329 argTok@var2143 .@expr5506 nextArgument (@expr5507 ) ; }
484:
485: if (@expr1073747332 Token ::@expr5509 Match (@expr1073747334 argTok@var2143 , "%str% [,)]" ) ) {
486: *@expr5511 formatArgTok@var2142 =@expr1073747336 argTok@var2143 .@expr5506 nextArgument (@expr5507 ) ;
487: *@expr5515 formatStringTok@var2141 =@expr1073747340 argTok@var2143 ;
488: return true ;
489: } else { if (@expr1073747341 Token ::@expr5509 Match (@expr1073747343 argTok@var2143 , "%var% [,)]" ) &&@expr1073747344
490: argTok@var2143 .@expr5521 variable (@expr5522 ) &&@expr1073747347
491: Token ::@expr5509 Match (@expr1073747349 argTok@var2143 .@expr5521 variable (@expr5522 ) .@expr1073747352 typeStartToken (@expr1073747353 ) , "char|wchar_t" ) &&@expr1073747354
492: (@expr1073747355 argTok@var2143 .@expr5521 variable (@expr5522 ) .@expr1073747358 isPointer (@expr1073747359 ) ||@expr1073747360
493: (@expr1073747361 argTok@var2143 .@expr5521 variable (@expr5522 ) .@expr1073747364 dimensions (@expr1073747365 ) .@expr1073747366 size (@expr1073747367 ) ==@expr1073747368 1 &&@expr1073747369
494: argTok@var2143 .@expr5521 variable (@expr5522 ) .@expr1073747372 dimensionKnown (@expr1073747373 0 ) &&@expr1073747374
495: argTok@var2143 .@expr5521 variable (@expr5522 ) .@expr1073747377 dimension (@expr1073747378 0 ) !=@expr1073747379 0 ) ) ) {
496: *@expr5511 formatArgTok@var2142 =@expr1073747381 argTok@var2143 .@expr5506 nextArgument (@expr5507 ) ;
497: if (@expr1073747384 !@expr1073747385 argTok@var2143 .@expr5562 values (@expr5563 ) .@expr1073747388 empty (@expr1073747389 ) ) {
498: std ::@expr1073747390 list < ValueFlow ::@expr1073747391 Value > ::@expr1073747392 const_iterator value@var2145 ; value@var2145 =@expr1073747393 std ::@expr1073747394 find_if (@expr1073747395
499: argTok@var2143 .@expr5562 values (@expr5563 ) .@expr1073747398 begin (@expr1073747399 ) , argTok@var2143 .@expr5562 values (@expr5563 ) .@expr5578 end (@expr5579 ) , std ::@expr1073747404 mem_fn (@expr1073747405 &@expr1073747406 ValueFlow ::@expr1073747407 Value ::@expr1073747408 isTokValue ) ) ;
500: if (@expr1073747409 value@var2145 !=@expr1073747410 argTok@var2143 .@expr5562 values (@expr5563 ) .@expr5578 end (@expr5579 ) &&@expr1073747415 value@var2145 .@expr1073747416 isTokValue (@expr1073747417 ) &&@expr1073747418 value@var2145 .@expr5595 tokvalue@var2146 &&@expr1073747420
501: value@var2145 .@expr5595 tokvalue@var2146 .@expr1073747422 tokType (@expr1073747423 ) ==@expr1073747424 Token ::@expr1073747425 eString ) {
502: *@expr5515 formatStringTok@var2141 =@expr1073747427 value@var2145 .@expr5595 tokvalue@var2146 ;
503: }
504: }
505: return true ;
506: } }
507: return false ;
508: }
509:
510:
511: static bool typesMatch ( const std :: string & iToTest@var2147 , const std :: string & iTypename@var2148 , const std :: string & iOptionalPrefix@var2149 = "std::" )
512: {
513: return (@expr5605 iToTest@var2147 ==@expr1073747430 iTypename@var2148 ) ||@expr1073747431 (@expr5605 iToTest@var2147 ==@expr1073747433 iOptionalPrefix@var2149 +@expr1073747434 iTypename@var2148 ) ;
514: }
515:
516: void CheckIO :: checkWrongPrintfScanfArguments ( )
517: {
518: const SymbolDatabase * symbolDatabase@var2150 ; symbolDatabase@var2150 =@expr1073747435 mTokenizer@var28 .@expr1073747436 getSymbolDatabase (@expr1073747437 ) ;
519: const bool isWindows@var2151 =@expr1073747438 mSettings@var29 .@expr1073747439 isWindowsPlatform (@expr1073747440 ) ;
520:
521: for (@expr1073747441 const Scope *@expr5618 scope@var2152 :@expr1073747443 symbolDatabase@var2150 .@expr1073747444 functionScopes@var2153 ) {
522: for (@expr1073747445 const Token *@expr5618 tok@var2154 =@expr1073747447 scope@var2152 .@expr1073747448 bodyStart@var2155 .@expr1073747449 next (@expr1073747450 ) ; tok@var2154 !=@expr1073747451 scope@var2152 .@expr1073747452 bodyEnd@var2156 ; tok@var2154 =@expr1073747453 tok@var2154 .@expr1073747454 next (@expr1073747455 ) ) {
523: if (@expr1073747456 !@expr1073747457 tok@var2154 .@expr1073747458 isName (@expr1073747459 ) ) { continue ; }
524:
525: const Token * argListTok@var2157 ; argListTok@var2157 =@expr1073747460 nullptr ;
526: const Token * formatStringTok@var2158 ; formatStringTok@var2158 =@expr1073747461 nullptr ;
527:
528: bool scan@var2159 ; scan@var2159 =@expr1073747462 false ;
529: bool scanf_s@var2160 ; scanf_s@var2160 =@expr1073747463 false ;
530: int formatStringArgNo@var2161 ; formatStringArgNo@var2161 =@expr1073747464 -1 ;
531:
532: if (@expr1073747465 tok@var2154 .@expr1073747466 strAt (@expr1073747467 1 ) ==@expr1073747468 "(" &&@expr1073747469 mSettings@var29 .@expr5646 library@var2350 .@expr1073747471 formatstr_function (@expr1073747472 tok@var2154 ) ) {
533: formatStringArgNo@var2161 =@expr1073747473 mSettings@var29 .@expr5646 library@var2350 .@expr1073747475 formatstr_argno (@expr1073747476 tok@var2154 ) ;
534: scan@var2159 =@expr1073747477 mSettings@var29 .@expr5646 library@var2350 .@expr1073747479 formatstr_scan (@expr1073747480 tok@var2154 ) ;
535: scanf_s@var2160 =@expr1073747481 mSettings@var29 .@expr5646 library@var2350 .@expr1073747483 formatstr_secure (@expr1073747484 tok@var2154 ) ;
536: }
537:
538: if (@expr1073747485 formatStringArgNo@var2161 >=@expr1073747486 0 ) {
539:
540: if (@expr1073747487 !@expr1073747488 findFormat (@expr1073747489 formatStringArgNo@var2161 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
541: continue ; }
542: } else { if (@expr1073747494 Token ::@expr1073747495 simpleMatch (@expr1073747496 tok@var2154 , "swprintf (" ) ) {
543: if (@expr1073747497 Token ::@expr5674 Match (@expr1073747499 tok@var2154 .@expr5666 tokAt (@expr5667 2 ) .@expr1073747502 nextArgument (@expr1073747503 ) , "%str%" ) ) {
544:
545: if (@expr1073747504 !@expr1073747505 findFormat (@expr5682 1 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
546: continue ; }
547: } else {
548:
549: if (@expr1073747511 !@expr1073747512 findFormat (@expr5689 2 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
550: continue ; }
551: }
552: } else { if (@expr1073747518 isWindows@var2151 &&@expr1073747519 Token ::@expr5674 Match (@expr1073747521 tok@var2154 , "sprintf_s|swprintf_s (" ) ) {
553:
554: if (@expr1073747522 findFormat (@expr5682 1 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
555: if (@expr5704 !@expr5705 formatStringTok@var2158 ) {
556: continue ; }
557: }
558:
559: else { if (@expr5706 findFormat (@expr5689 2 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
560: if (@expr5704 !@expr5705 formatStringTok@var2158 ) {
561: continue ; }
562: } }
563: } else { if (@expr1073747538 isWindows@var2151 &&@expr1073747539 Token ::@expr5674 Match (@expr1073747541 tok@var2154 , "_snprintf_s|_snwprintf_s (" ) ) {
564:
565: if (@expr5706 findFormat (@expr5689 2 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
566: if (@expr5704 !@expr5705 formatStringTok@var2158 ) {
567: continue ; }
568: }
569:
570: else { if (@expr1073747550 findFormat (@expr1073747551 3 , tok@var2154 .@expr5666 tokAt (@expr5667 2 ) , &@expr5668 formatStringTok@var2158 , &@expr5669 argListTok@var2157 ) ) {
571: if (@expr5704 !@expr5705 formatStringTok@var2158 ) {
572: continue ; }
573: } }
574: } else {
575: continue ;
576: } } } }
577:
578: if (@expr5704 !@expr5705 formatStringTok@var2158 ) {
579: continue ; }
580:
581: checkFormatString (@expr1073747560 tok@var2154 , formatStringTok@var2158 , argListTok@var2157 , scan@var2159 , scanf_s@var2160 ) ;
582: }
583: }
584: }
585:
586: void CheckIO :: checkFormatString ( const Token * const tok@var2162 ,
587: const Token * const formatStringTok@var2163 ,
588: const Token * argListTok@var2164 ,
589: const bool scan@var2165 ,
590: const bool scanf_s@var2166 )
591: {
592: const bool isWindows@var2167 =@expr1073747563 mSettings@var29 .@expr1073747564 isWindowsPlatform (@expr1073747565 ) ;
593: const bool printWarning@var2168 =@expr1073747566 mSettings@var29 .@expr1073747567 severity@var2349 .@expr1073747568 isEnabled (@expr1073747569 Severity ::@expr1073747570 warning ) ;
594: const std ::@expr5747 string &@expr1073747572 formatString@var2169 =@expr1073747573 formatStringTok@var2163 .@expr1073747574 str (@expr1073747575 ) ;
595:
596:
597: int numFormat@var2170 ; numFormat@var2170 =@expr1073747576 0 ;
598: int numSecure@var2171 ; numSecure@var2171 =@expr1073747577 0 ;
599: bool percent@var2172 ; percent@var2172 =@expr1073747578 false ;
600: const Token * argListTok2@var2173 ; argListTok2@var2173 =@expr1073747579 argListTok@var2164 ;
601: std ::@expr1073747580 set < int > parameterPositionsUsed@var2174 ;
602: for (@expr1073747581 std ::@expr5747 string ::@expr5747 const_iterator i@var2175 =@expr1073747584 formatString@var2169 .@expr1073747585 begin (@expr1073747586 ) ; i@var2175 !=@expr5763 formatString@var2169 .@expr5764 end (@expr5765 ) ; ++@expr1073747590 i@var2175 ) {
603: if (@expr1073747591 *@expr5768 i@var2175 ==@expr1073747593 '%' ) {
604: percent@var2172 =@expr1073747594 !@expr1073747595 percent@var2172 ;
605: } else { if (@expr1073747596 percent@var2172 &&@expr1073747597 *@expr5768 i@var2175 ==@expr5775 '[' ) {
606: while (@expr5776 i@var2175 !=@expr5763 formatString@var2169 .@expr5764 end (@expr5765 ) ) {
607: if (@expr5780 *@expr5768 i@var2175 ==@expr5782 ']' ) {
608: numFormat@var2170 ++@expr1073747607 ;
609: if (@expr5784 argListTok@var2164 ) {
610: argListTok@var2164 =@expr1073747609 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ; }
611: percent@var2172 =@expr1073747612 false ;
612: break ;
613: }
614: ++@expr1073747613 i@var2175 ;
615: }
616: if (@expr5790 scanf_s@var2166 ) {
617: numSecure@var2171 ++@expr1073747615 ;
618: if (@expr5784 argListTok@var2164 ) {
619: argListTok@var2164 =@expr1073747617 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ;
620: }
621: }
622: if (@expr5796 i@var2175 ==@expr5797 formatString@var2169 .@expr5764 end (@expr5765 ) ) {
623: break ; }
624: } else { if (@expr1073747624 percent@var2172 ) {
625: percent@var2172 =@expr1073747625 false ;
626:
627: bool _continue@var2176 ; _continue@var2176 =@expr1073747626 false ;
628: bool skip@var2177 ; skip@var2177 =@expr1073747627 false ;
629: std ::@expr1073747628 string width@var2178 ;
630: int parameterPosition@var2179 ; parameterPosition@var2179 =@expr1073747629 0 ;
631: bool hasParameterPosition@var2180 ; hasParameterPosition@var2180 =@expr1073747630 false ;
632: while (@expr1073747631 i@var2175 !=@expr5763 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073747635 *@expr5768 i@var2175 !=@expr1073747637 '[' &&@expr1073747638 !@expr1073747639 std ::@expr1073747640 isalpha (@expr1073747641 (@expr1073747642 unsigned char ) *@expr5768 i@var2175 ) ) {
633: if (@expr1073747644 *@expr5768 i@var2175 ==@expr1073747646 '*' ) {
634: skip@var2177 =@expr1073747647 true ;
635: if (@expr5824 scan@var2165 ) {
636: _continue@var2176 =@expr1073747649 true ; }
637: else {
638: numFormat@var2170 ++@expr1073747650 ;
639: if (@expr5784 argListTok@var2164 ) {
640: argListTok@var2164 =@expr1073747652 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ; }
641: }
642: } else { if (@expr1073747655 std ::@expr1073747656 isdigit (@expr1073747657 *@expr5768 i@var2175 ) ) {
643: width@var2178 +=@expr1073747659 *@expr5768 i@var2175 ;
644: } else { if (@expr1073747661 *@expr5768 i@var2175 ==@expr1073747663 '$' ) {
645: parameterPosition@var2179 =@expr1073747664 std ::@expr5841 atoi (@expr5842 width@var2178 .@expr5843 c_str (@expr5844 ) ) ;
646: hasParameterPosition@var2180 =@expr1073747669 true ;
647: width@var2178 .@expr1073747670 clear (@expr1073747671 ) ;
648: } } }
649: ++@expr1073747672 i@var2175 ;
650: }
651: auto bracketBeg@var2181 ; bracketBeg@var2181 =@expr1073747673 formatString@var2169 .@expr5764 end (@expr5765 ) ;
652: if (@expr1073747676 i@var2175 !=@expr5763 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073747680 *@expr5768 i@var2175 ==@expr5775 '[' ) {
653: bracketBeg@var2181 =@expr1073747683 i@var2175 ;
654: while (@expr5776 i@var2175 !=@expr5763 formatString@var2169 .@expr5764 end (@expr5765 ) ) {
655: if (@expr5780 *@expr5768 i@var2175 ==@expr5782 ']' ) {
656: break ; }
657:
658: ++@expr1073747691 i@var2175 ;
659: }
660: if (@expr1073747692 scanf_s@var2166 &&@expr1073747693 !@expr1073747694 skip@var2177 ) {
661: numSecure@var2171 ++@expr1073747695 ;
662: if (@expr5784 argListTok@var2164 ) {
663: argListTok@var2164 =@expr1073747697 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ;
664: }
665: }
666: }
667: if (@expr5796 i@var2175 ==@expr5797 formatString@var2169 .@expr5764 end (@expr5765 ) ) {
668: break ; }
669: if (@expr1073747704 _continue@var2176 ) {
670: continue ; }
671:
672: if (@expr1073747705 scan@var2165 ||@expr1073747706 *@expr5768 i@var2175 !=@expr1073747708 'm' ) {
673: ++@expr1073747709 numFormat@var2170 ;
674:
675:
676: if (@expr1073747710 hasParameterPosition@var2180 ) {
677: if (@expr1073747711 parameterPositionsUsed@var2174 .@expr1073747712 find (@expr1073747713 parameterPosition@var2179 ) ==@expr1073747714 parameterPositionsUsed@var2174 .@expr1073747715 end (@expr1073747716 ) ) {
678: parameterPositionsUsed@var2174 .@expr1073747717 insert (@expr1073747718 parameterPosition@var2179 ) ; }
679: else {
680: --@expr1073747719 numFormat@var2170 ; }
681: }
682:
683:
684: ArgumentInfo argInfo@var2182 (@expr1073747720 argListTok@var2164 , mSettings@var29 , mTokenizer@var28 .@expr1073747721 isCPP (@expr1073747722 ) ) ;
685:
686: if (@expr1073747723 (@expr1073747724 argInfo@var2182 .@expr5901 typeToken@var2183 &&@expr1073747726 !@expr1073747727 argInfo@var2182 .@expr1073747728 isLibraryType (@expr1073747729 mSettings@var29 ) ) ||@expr1073747730 *@expr5768 i@var2175 ==@expr5782 ']' ) {
687: if (@expr5824 scan@var2165 ) {
688: std ::@expr1073747734 string specifier@var2184 ;
689: bool done@var2185 ; done@var2185 =@expr1073747735 false ;
690: while (@expr1073747736 !@expr1073747737 done@var2185 ) {
691: switch (@expr5914 *@expr5768 i@var2175 ) {
692: case 's' :@expr5916
693: case ']' :@expr5916 ;
694: specifier@var2184 +=@expr1073747742 (@expr1073747743 *@expr5768 i@var2175 ==@expr1073747745 's' ||@expr1073747746 bracketBeg@var2181 ==@expr1073747747 formatString@var2169 .@expr5764 end (@expr5765 ) ) ?@expr1073747750 std ::@expr5927 string {@expr1073747752 's' } :@expr1073747753 std ::@expr5927 string {@expr1073747755 bracketBeg@var2181 , i@var2175 +@expr5932 1 } ;
695: if (@expr5933 argInfo@var2182 .@expr5934 variableInfo@var2186 &&@expr5935 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr5938 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5940 isArray (@expr5941 ) &&@expr5942 (@expr1073747767 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5945 dimensions (@expr5946 ) .@expr5947 size (@expr5948 ) ==@expr5949 1 ) &&@expr5950 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5945 dimensions (@expr5946 ) [@expr5954 0 ] .@expr5955 known@expr5737 ) {
696: if (@expr5956 !@expr5957 width@var2178 .@expr5958 empty (@expr5959 ) ) {
697: const int numWidth@var2187 =@expr1073747784 std ::@expr5841 atoi (@expr5842 width@var2178 .@expr5843 c_str (@expr5844 ) ) ;
698: if (@expr1073747789 numWidth@var2187 !=@expr1073747790 (@expr1073747791 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5969 dimension (@expr5970 0 ) -@expr1073747795 1 ) ) {
699: invalidScanfFormatWidthError (@expr1073747796 tok@var2162 , numFormat@var2170 , numWidth@var2187 , argInfo@var2182 .@expr5934 variableInfo@var2186 , specifier@var2184 ) ; }
700: }
701: }
702: if (@expr1073747798 argListTok@var2164 &&@expr1073747799 argListTok@var2164 .@expr5976 tokType (@expr5977 ) !=@expr5978 Token ::@expr5979 eString &&@expr1073747804 argInfo@var2182 .@expr5901 typeToken@var2183 &&@expr1073747806
703: argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr1073747809 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr1073747812
704: (@expr1073747813 !@expr5990 Token ::@expr5991 Match (@expr5992 argInfo@var2182 .@expr5901 typeToken@var2183 , "char|wchar_t" ) ||@expr1073747818
705: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr5996 strAt (@expr5997 -1 ) ==@expr5998 "const" ) ) {
706: if (@expr1073747823 !@expr1073747824 (@expr1073747825 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr1073747828 argInfo@var2182 .@expr6005 element@var2188 &&@expr1073747830 !@expr1073747831 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6009 isStandardType (@expr6010 ) ) ) {
707: invalidScanfArgTypeError_s (@expr1073747835 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
708: }
709: if (@expr1073747837 scanf_s@var2166 &&@expr1073747838 argInfo@var2182 .@expr5901 typeToken@var2183 ) {
710: numSecure@var2171 ++@expr1073747840 ;
711: if (@expr5784 argListTok@var2164 ) {
712: argListTok@var2164 =@expr1073747842 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ;
713: }
714: }
715: done@var2185 =@expr1073747845 true ;
716: break ;
717: case 'c' :@expr5916 ;
718: if (@expr5933 argInfo@var2182 .@expr5934 variableInfo@var2186 &&@expr5935 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr5938 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5940 isArray (@expr5941 ) &&@expr5942 (@expr1073747857 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5945 dimensions (@expr5946 ) .@expr5947 size (@expr5948 ) ==@expr5949 1 ) &&@expr5950 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5945 dimensions (@expr5946 ) [@expr5954 0 ] .@expr5955 known@expr5737 ) {
719: if (@expr5956 !@expr5957 width@var2178 .@expr5958 empty (@expr5959 ) ) {
720: const int numWidth@var2189 =@expr1073747874 std ::@expr5841 atoi (@expr5842 width@var2178 .@expr5843 c_str (@expr5844 ) ) ;
721: if (@expr1073747879 numWidth@var2189 >@expr1073747880 argInfo@var2182 .@expr5934 variableInfo@var2186 .@expr5969 dimension (@expr5970 0 ) ) {
722: invalidScanfFormatWidthError (@expr1073747884 tok@var2162 , numFormat@var2170 , numWidth@var2189 , argInfo@var2182 .@expr5934 variableInfo@var2186 , std ::@expr5927 string (@expr1073747887 1 , *@expr5768 i@var2175 ) ) ; }
723: }
724: }
725: if (@expr5790 scanf_s@var2166 ) {
726: numSecure@var2171 ++@expr1073747890 ;
727: if (@expr5784 argListTok@var2164 ) {
728: argListTok@var2164 =@expr1073747892 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ;
729: }
730: }
731: done@var2185 =@expr1073747895 true ;
732: break ;
733: case 'x' :@expr5916
734: case 'X' :@expr5916
735: case 'u' :@expr5916
736: case 'o' :@expr5916 ;
737: specifier@var2184 +=@expr1073747900 *@expr5768 i@var2175 ;
738: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
739: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
740: else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
741: if (@expr6089 !@expr6090 Token ::@expr5991 Match (@expr6092 argInfo@var2182 .@expr5901 typeToken@var2183 , "char|short|int|long" ) ) {
742: if (@expr6094 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6009 isStandardType (@expr6010 ) ||@expr6098 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
743: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
744: } else { if (@expr1073747927 !@expr6104 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ||@expr1073747932
745: !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ||@expr1073747936
746: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr5996 strAt (@expr5997 -1 ) ==@expr5998 "const" ) {
747: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ;
748: } else {
749: switch (@expr6119 specifier@var2184 [@expr6120 0 ] ) {
750: case 'h' :@expr5916 ;
751: if (@expr6122 specifier@var2184 [@expr6123 1 ] ==@expr6124 'h' ) {
752: if (@expr6125 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6129 "char" ) {
753: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
754: } else { if (@expr6132 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6136 "short" ) {
755: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } }
756: break ;
757: case 'l' :@expr5916 ;
758: if (@expr6140 specifier@var2184 [@expr6123 1 ] ==@expr6142 'l' ) {
759: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
760: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
761: else { if (@expr6155 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6160
762: typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6165
763: typesMatch (@expr6166 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "uintmax_t" ) ) {
764: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } }
765: } else { if (@expr6172 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6177 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
766: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
767: else { if (@expr6155 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6160
768: typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6165
769: typesMatch (@expr6166 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "uintmax_t" ) ) {
770: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } } }
771: break ;
772: case 'I' :@expr5916 ;
773: if (@expr6201 specifier@var2184 .@expr6202 find (@expr6203 "I64" ) !=@expr6204 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
774: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
775: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
776: } else { if (@expr6219 specifier@var2184 .@expr6202 find (@expr6221 "I32" ) !=@expr6222 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
777: if (@expr6225 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ||@expr6230 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
778: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
779: } else { if (@expr6236 !@expr6237 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ) {
780: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } } }
781: break ;
782: case 'j' :@expr5916 ;
783: if (@expr1073748069 !@expr1073748070 typesMatch (@expr6166 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "uintmax_t" ) ) {
784: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
785: break ;
786: case 'z' :@expr5916 ;
787: if (@expr6236 !@expr6237 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ) {
788: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
789: break ;
790: case 't' :@expr5916 ;
791: if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
792: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
793: break ;
794: case 'L' :@expr5916 ;
795: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
796: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
797: else { if (@expr1073748108 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr1073748113
798: typesMatch (@expr6166 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "uintmax_t" ) ) {
799: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } }
800: break ;
801: default :@expr5916 ;
802: if (@expr6297 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ) {
803: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; }
804: else { if (@expr6155 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6160
805: typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6165
806: typesMatch (@expr6166 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "uintmax_t" ) ) {
807: invalidScanfArgTypeError_int (@expr6084 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , true ) ; } }
808: break ;
809: }
810: } }
811: } }
812: done@var2185 =@expr1073748145 true ;
813: break ;
814: case 'n' :@expr5916
815: case 'd' :@expr5916
816: case 'i' :@expr5916 ;
817: specifier@var2184 +=@expr1073748149 *@expr5768 i@var2175 ;
818: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
819: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
820: else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
821: if (@expr6089 !@expr6090 Token ::@expr5991 Match (@expr6092 argInfo@var2182 .@expr5901 typeToken@var2183 , "char|short|int|long" ) ) {
822: if (@expr6094 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6009 isStandardType (@expr6010 ) ||@expr6098 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
823: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
824: } else { if (@expr1073748176 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ||@expr1073748180
825: !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ||@expr1073748184
826: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr5996 strAt (@expr5997 -1 ) ==@expr5998 "const" ) {
827: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ;
828: } else {
829: switch (@expr6119 specifier@var2184 [@expr6120 0 ] ) {
830: case 'h' :@expr5916 ;
831: if (@expr6122 specifier@var2184 [@expr6123 1 ] ==@expr6124 'h' ) {
832: if (@expr6125 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6129 "char" ) {
833: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
834: } else { if (@expr6132 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6136 "short" ) {
835: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; } }
836: break ;
837: case 'l' :@expr5916 ;
838: if (@expr6140 specifier@var2184 [@expr6123 1 ] ==@expr6142 'l' ) {
839: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
840: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
841: else { if (@expr6403 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6408
842: typesMatch (@expr6409 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "intmax_t" ) ) {
843: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; } }
844: } else { if (@expr6172 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6177 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
845: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
846: else { if (@expr6403 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6408
847: typesMatch (@expr6409 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "intmax_t" ) ) {
848: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; } } }
849: break ;
850: case 'I' :@expr5916 ;
851: if (@expr6201 specifier@var2184 .@expr6202 find (@expr6203 "I64" ) !=@expr6204 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
852: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
853: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
854: } else { if (@expr6219 specifier@var2184 .@expr6202 find (@expr6221 "I32" ) !=@expr6222 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
855: if (@expr6225 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ||@expr6230 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
856: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
857: } else { if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
858: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; } } }
859: break ;
860: case 'j' :@expr5916 ;
861: if (@expr1073748307 !@expr1073748308 typesMatch (@expr6409 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "intmax_t" ) ) {
862: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
863: break ;
864: case 'z' :@expr5916 ;
865: if (@expr6492 !@expr6493 (@expr1073748318 typesMatch (@expr6495 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ssize_t" ) ||@expr6499
866: (@expr1073748324 isWindows@var2167 &&@expr6501 typesMatch (@expr6502 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "SSIZE_T" ) ) ) ) {
867: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
868: break ;
869: case 't' :@expr5916 ;
870: if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
871: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
872: break ;
873: case 'L' :@expr5916 ;
874: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
875: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
876: break ;
877: default :@expr5916 ;
878: if (@expr6297 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ) {
879: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; }
880: else { if (@expr6538 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6543
881: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6547 "intmax_t" ) {
882: invalidScanfArgTypeError_int (@expr6333 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 , false ) ; } }
883: break ;
884: }
885: } }
886: } }
887: done@var2185 =@expr1073748374 true ;
888: break ;
889: case 'e' :@expr5916
890: case 'E' :@expr5916
891: case 'f' :@expr5916
892: case 'g' :@expr5916
893: case 'G' :@expr5916
894: case 'a' :@expr5916 ;
895: specifier@var2184 +=@expr1073748381 *@expr5768 i@var2175 ;
896: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
897: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
898: else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
899: if (@expr6570 !@expr6571 Token ::@expr5991 Match (@expr6573 argInfo@var2182 .@expr5901 typeToken@var2183 , "float|double" ) ) {
900: if (@expr1073748399 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6009 isStandardType (@expr6010 ) ) {
901: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
902: } else { if (@expr1073748405 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ||@expr6585
903: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr5996 strAt (@expr5997 -1 ) ==@expr5998 "const" ) {
904: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ;
905: } else {
906: switch (@expr6119 specifier@var2184 [@expr6120 0 ] ) {
907: case 'l' :@expr5916 ;
908: if (@expr1073748419 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6599 "double" ||@expr1073748424 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
909: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
910: break ;
911: case 'L' :@expr5916 ;
912: if (@expr1073748431 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6599 "double" ||@expr6612 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
913: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
914: break ;
915: default :@expr5916 ;
916: if (@expr1073748444 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr1073748448 "float" ) {
917: invalidScanfArgTypeError_float (@expr6565 tok@var2162 , numFormat@var2170 , specifier@var2184 , &@expr6012 argInfo@var2182 ) ; }
918: break ;
919: }
920: } }
921: } }
922: done@var2185 =@expr1073748451 true ;
923: break ;
924: case 'I' :@expr5916 ;
925: if (@expr1073748453 (@expr1073748454 i@var2175 +@expr5932 1 !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073748459 *@expr6636 (@expr1073748461 i@var2175 +@expr5932 1 ) ==@expr6639 '6' &&@expr1073748464
926: i@var2175 +@expr6641 2 !=@expr6642 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073748469 *@expr6646 (@expr1073748471 i@var2175 +@expr6641 2 ) ==@expr6649 '4' ) ||@expr1073748474
927: (@expr1073748475 i@var2175 +@expr5932 1 !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073748480 *@expr6636 (@expr1073748482 i@var2175 +@expr5932 1 ) ==@expr6660 '3' &&@expr1073748485
928: i@var2175 +@expr6641 2 !=@expr6642 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073748490 *@expr6646 (@expr1073748492 i@var2175 +@expr6641 2 ) ==@expr6670 '2' ) ) {
929: specifier@var2184 +=@expr1073748495 *@expr1073748496 i@var2175 ++@expr1073748497 ;
930: specifier@var2184 +=@expr1073748498 *@expr1073748499 i@var2175 ++@expr1073748500 ;
931: if (@expr6677 (@expr1073748502 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6683 !@expr6684 isalpha (@expr6685 *@expr6636 (@expr1073748511 i@var2175 +@expr5932 1 ) ) ) {
932: specifier@var2184 +=@expr1073748513 *@expr5768 i@var2175 ;
933: invalidLengthModifierError (@expr6691 tok@var2162 , numFormat@var2170 , specifier@var2184 ) ;
934: done@var2185 =@expr1073748516 true ;
935: } else {
936: specifier@var2184 +=@expr1073748517 *@expr1073748518 i@var2175 ++@expr1073748519 ;
937: }
938: } else {
939: if (@expr6677 (@expr1073748521 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6683 !@expr6684 isalpha (@expr6685 *@expr6636 (@expr1073748530 i@var2175 +@expr5932 1 ) ) ) {
940: specifier@var2184 +=@expr1073748532 *@expr5768 i@var2175 ;
941: invalidLengthModifierError (@expr6691 tok@var2162 , numFormat@var2170 , specifier@var2184 ) ;
942: done@var2185 =@expr1073748535 true ;
943: } else {
944: specifier@var2184 +=@expr1073748536 *@expr1073748537 i@var2175 ++@expr1073748538 ;
945: }
946: }
947: break ;
948: case 'h' :@expr5916
949: case 'l' :@expr5916 ;
950: if (@expr6717 i@var2175 +@expr5932 1 !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6722 *@expr6636 (@expr1073748548 i@var2175 +@expr5932 1 ) ==@expr6726 *@expr5768 i@var2175 ) {
951: specifier@var2184 +=@expr1073748552 *@expr1073748553 i@var2175 ++@expr1073748554 ; }
952: ;
953: case 'j' :@expr5916
954: case 'q' :@expr5916
955: case 't' :@expr5916
956: case 'z' :@expr5916
957: case 'L' :@expr5916 ;
958:
959: if (@expr6677 (@expr1073748561 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6683 !@expr6684 isalpha (@expr6685 *@expr6636 (@expr1073748570 i@var2175 +@expr5932 1 ) ) ) {
960: specifier@var2184 +=@expr1073748572 *@expr5768 i@var2175 ;
961: invalidLengthModifierError (@expr6691 tok@var2162 , numFormat@var2170 , specifier@var2184 ) ;
962: done@var2185 =@expr1073748575 true ;
963: } else {
964: specifier@var2184 +=@expr1073748576 *@expr1073748577 i@var2175 ++@expr1073748578 ;
965: }
966: break ;
967: default :@expr5916 ;
968: done@var2185 =@expr1073748580 true ;
969: break ;
970: }
971: }
972: } else { if (@expr6757 printWarning@var2168 ) {
973: std ::@expr1073748582 string specifier@var2190 ;
974: bool done@var2191 ; done@var2191 =@expr1073748583 false ;
975: while (@expr1073748584 !@expr1073748585 done@var2191 ) {
976: if (@expr5796 i@var2175 ==@expr5797 formatString@var2169 .@expr5764 end (@expr5765 ) ) {
977: break ;
978: }
979: switch (@expr5914 *@expr5768 i@var2175 ) {
980: case 's' :@expr5916 ;
981: if (@expr1073748593 argListTok@var2164 .@expr5976 tokType (@expr5977 ) !=@expr5978 Token ::@expr5979 eString &&@expr1073748598
982: argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr1073748601 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ) {
983: if (@expr1073748605 !@expr5990 Token ::@expr5991 Match (@expr5992 argInfo@var2182 .@expr5901 typeToken@var2183 , "char|wchar_t" ) ) {
984: if (@expr1073748610 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
985: invalidPrintfArgTypeError_s (@expr1073748613 tok@var2162 , numFormat@var2170 , &@expr6012 argInfo@var2182 ) ; }
986: }
987: }
988: done@var2191 =@expr1073748615 true ;
989: break ;
990: case 'n' :@expr5916 ;
991: if (@expr1073748617 (@expr1073748618 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr1073748621 (@expr1073748622 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ||@expr6585 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr5996 strAt (@expr5997 -1 ) ==@expr5998 "const" ) ) ||@expr1073748631 argListTok@var2164 .@expr5976 tokType (@expr5977 ) ==@expr1073748634 Token ::@expr5979 eString ) {
992: invalidPrintfArgTypeError_n (@expr1073748636 tok@var2162 , numFormat@var2170 , &@expr6012 argInfo@var2182 ) ; }
993: done@var2191 =@expr1073748638 true ;
994: break ;
995: case 'c' :@expr5916
996: case 'x' :@expr5916
997: case 'X' :@expr5916
998: case 'o' :@expr5916 ;
999: specifier@var2190 +=@expr1073748643 *@expr5768 i@var2175 ;
1000: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
1001: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1002: else { if (@expr6829 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6832 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
1003:
1004: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1005: } else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
1006: if (@expr1073748664 !@expr1073748665 Token ::@expr5991 Match (@expr1073748667 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|short|long|int|char|wchar_t" ) ) {
1007: if (@expr6845 !@expr6846 (@expr1073748671 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1008: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1009: } else {
1010: switch (@expr6855 specifier@var2190 [@expr6856 0 ] ) {
1011: case 'h' :@expr5916 ;
1012: if (@expr6858 specifier@var2190 [@expr6859 1 ] ==@expr6860 'h' ) {
1013: if (@expr6861 !@expr6862 (@expr1073748687 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6867 "char" &&@expr6868 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1014: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1015: } else { if (@expr6874 !@expr6875 (@expr1073748700 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6880 "short" &&@expr6881 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1016: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1017: break ;
1018: case 'l' :@expr5916 ;
1019: if (@expr6888 specifier@var2190 [@expr6859 1 ] ==@expr6890 'l' ) {
1020: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1021: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1022: else { if (@expr6903 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6908
1023: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6912 "uintmax_t" ) {
1024: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1025: } else { if (@expr6172 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6177 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1026: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1027: else { if (@expr6903 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6908
1028: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6912 "uintmax_t" ) {
1029: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1030: break ;
1031: case 'j' :@expr5916 ;
1032: if (@expr6939 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) !=@expr6943 "uintmax_t" ) {
1033: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1034: break ;
1035: case 'z' :@expr5916 ;
1036: if (@expr6236 !@expr6237 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ) {
1037: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1038: break ;
1039: case 't' :@expr5916 ;
1040: if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
1041: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1042: break ;
1043: case 'I' :@expr5916 ;
1044: if (@expr6965 specifier@var2190 .@expr6966 find (@expr6967 "I64" ) !=@expr6968 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1045: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1046: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1047: } else { if (@expr6983 specifier@var2190 .@expr6966 find (@expr6985 "I32" ) !=@expr6986 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1048: if (@expr6225 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ||@expr6230 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1049: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1050: } else { if (@expr1073748824 !@expr1073748825 (@expr1073748826 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr1073748831
1051: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr1073748835 "WPARAM" ||@expr1073748836
1052: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr1073748840 "UINT_PTR" ||@expr1073748841
1053: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr1073748845 "LONG_PTR" ||@expr1073748846
1054: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr1073748850 "LPARAM" ||@expr1073748851
1055: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr1073748855 "LRESULT" ) ) {
1056: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1057: break ;
1058: default :@expr5916 ;
1059: if (@expr1073748859 !@expr1073748860 Token ::@expr5991 Match (@expr1073748862 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|char|short|wchar_t|int" ) ) {
1060: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1061: break ;
1062: }
1063: }
1064: } } }
1065: done@var2191 =@expr1073748866 true ;
1066: break ;
1067: case 'd' :@expr5916
1068: case 'i' :@expr5916 ;
1069: specifier@var2190 +=@expr1073748869 *@expr5768 i@var2175 ;
1070: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
1071: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1072: } else { if (@expr6829 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6832 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
1073:
1074: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1075: } else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
1076: if (@expr1073748890 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) &&@expr1073748894 !@expr1073748895 Token ::@expr5991 Match (@expr1073748897 argInfo@var2182 .@expr5901 typeToken@var2183 , "char|short" ) ) {
1077: if (@expr6845 !@expr6846 (@expr1073748901 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1078: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1079: } else { if (@expr1073748909 !@expr1073748910 Token ::@expr5991 Match (@expr1073748912 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|char|short|int|long" ) ) {
1080: if (@expr6845 !@expr6846 (@expr1073748916 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1081: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1082: } else {
1083: switch (@expr6855 specifier@var2190 [@expr6856 0 ] ) {
1084: case 'h' :@expr5916 ;
1085: if (@expr6858 specifier@var2190 [@expr6859 1 ] ==@expr6860 'h' ) {
1086: if (@expr1073748930 !@expr1073748931 (@expr1073748932 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6867 "char" &&@expr1073748937 !@expr6104 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1087: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1088: } else { if (@expr1073748944 !@expr1073748945 (@expr1073748946 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6880 "short" &&@expr1073748951 !@expr6104 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1089: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1090: break ;
1091: case 'l' :@expr5916 ;
1092: if (@expr6888 specifier@var2190 [@expr6859 1 ] ==@expr6890 'l' ) {
1093: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1094: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1095: else { if (@expr6538 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6543
1096: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6547 "intmax_t" ) {
1097: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1098: } else { if (@expr6172 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6177 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1099: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1100: else { if (@expr6538 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6543
1101: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6547 "intmax_t" ) {
1102: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1103: break ;
1104: case 'j' :@expr5916 ;
1105: if (@expr1073749010 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) !=@expr1073749014 "intmax_t" ) {
1106: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1107: break ;
1108: case 't' :@expr5916 ;
1109: if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
1110: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1111: break ;
1112: case 'I' :@expr5916 ;
1113: if (@expr6965 specifier@var2190 .@expr6966 find (@expr6967 "I64" ) !=@expr6968 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1114: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1115: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1116: } else { if (@expr6983 specifier@var2190 .@expr6966 find (@expr6985 "I32" ) !=@expr6986 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1117: if (@expr6225 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ||@expr6230 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1118: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1119: } else { if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
1120: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1121: break ;
1122: case 'z' :@expr5916 ;
1123: if (@expr6492 !@expr6493 (@expr1073749073 typesMatch (@expr6495 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ssize_t" ) ||@expr6499
1124: (@expr1073749079 isWindows@var2167 &&@expr6501 typesMatch (@expr6502 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "SSIZE_T" ) ) ) ) {
1125: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1126: break ;
1127: case 'L' :@expr5916 ;
1128: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1129: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1130: break ;
1131: default :@expr5916 ;
1132: if (@expr7277 !@expr7278 Token ::@expr5991 Match (@expr7280 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|char|short|int" ) ) {
1133: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1134: else { if (@expr6538 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ||@expr6543
1135: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6547 "intmax_t" ) {
1136: invalidPrintfArgTypeError_sint (@expr7053 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1137: break ;
1138: }
1139: } }
1140: } } }
1141: done@var2191 =@expr1073749120 true ;
1142: break ;
1143: case 'u' :@expr5916 ;
1144: specifier@var2190 +=@expr1073749122 *@expr5768 i@var2175 ;
1145: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
1146: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1147: } else { if (@expr6829 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6832 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
1148:
1149: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1150: } else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
1151: if (@expr1073749143 !@expr6104 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) &&@expr1073749148 !@expr1073749149 Token ::@expr5991 Match (@expr1073749151 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|_Bool" ) ) {
1152: if (@expr6845 !@expr6846 (@expr1073749155 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1153: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1154: } else { if (@expr1073749163 !@expr1073749164 Token ::@expr5991 Match (@expr1073749166 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|char|short|long|int" ) ) {
1155: if (@expr6845 !@expr6846 (@expr1073749170 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1156: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1157: } else {
1158: switch (@expr6855 specifier@var2190 [@expr6856 0 ] ) {
1159: case 'h' :@expr5916 ;
1160: if (@expr6858 specifier@var2190 [@expr6859 1 ] ==@expr6860 'h' ) {
1161: if (@expr6861 !@expr6862 (@expr1073749186 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6867 "char" &&@expr6868 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1162: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1163: } else { if (@expr6874 !@expr6875 (@expr1073749199 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) ==@expr6880 "short" &&@expr6881 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6106 isUnsigned (@expr6107 ) ) ) {
1164: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1165: break ;
1166: case 'l' :@expr5916 ;
1167: if (@expr6888 specifier@var2190 [@expr6859 1 ] ==@expr6890 'l' ) {
1168: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1169: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1170: else { if (@expr6903 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6908
1171: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6912 "uintmax_t" ) {
1172: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1173: } else { if (@expr6172 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6177 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1174: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1175: else { if (@expr6903 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr6908
1176: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6912 "uintmax_t" ) {
1177: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1178: break ;
1179: case 'j' :@expr5916 ;
1180: if (@expr6939 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) !=@expr6943 "uintmax_t" ) {
1181: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1182: break ;
1183: case 'z' :@expr5916 ;
1184: if (@expr6236 !@expr6237 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ) {
1185: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1186: break ;
1187: case 't' :@expr5916 ;
1188: if (@expr6263 !@expr6264 typesMatch (@expr6161 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "ptrdiff_t" ) ) {
1189: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1190: break ;
1191: case 'I' :@expr5916 ;
1192: if (@expr6965 specifier@var2190 .@expr6966 find (@expr6967 "I64" ) !=@expr6968 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1193: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1194: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1195: } else { if (@expr6983 specifier@var2190 .@expr6966 find (@expr6985 "I32" ) !=@expr6986 std ::@expr5927 string ::@expr6206 npos@expr5738 ) {
1196: if (@expr6225 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6229 "int" ||@expr6230 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1197: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1198: } else { if (@expr6236 !@expr6237 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ) {
1199: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } } }
1200: break ;
1201: case 'L' :@expr5916 ;
1202: if (@expr6143 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6147 "long" ||@expr6148 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) {
1203: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1204: break ;
1205: default :@expr5916 ;
1206: if (@expr7277 !@expr7278 Token ::@expr5991 Match (@expr7280 argInfo@var2182 .@expr5901 typeToken@var2183 , "bool|char|short|int" ) ) {
1207: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1208: else { if (@expr1073749352 typesMatch (@expr6156 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) , "size_t" ) ||@expr1073749357
1209: argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6158 originalName (@expr6159 ) ==@expr6547 "intmax_t" ) {
1210: invalidPrintfArgTypeError_uint (@expr6827 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1211: break ;
1212: }
1213: } }
1214: } } }
1215: done@var2191 =@expr1073749364 true ;
1216: break ;
1217: case 'p' :@expr5916 ;
1218: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
1219: ; }
1220: else { if (@expr1073749372 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) &&@expr1073749375 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) ) {
1221: invalidPrintfArgTypeError_p (@expr1073749379 tok@var2162 , numFormat@var2170 , &@expr6012 argInfo@var2182 ) ; } }
1222: done@var2191 =@expr1073749381 true ;
1223: break ;
1224: case 'e' :@expr5916
1225: case 'E' :@expr5916
1226: case 'f' :@expr5916
1227: case 'g' :@expr5916
1228: case 'G' :@expr5916 ;
1229: specifier@var2190 +=@expr1073749387 *@expr5768 i@var2175 ;
1230: if (@expr6078 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6080 tokType (@expr6081 ) ==@expr6082 Token ::@expr5979 eString ) {
1231: invalidPrintfArgTypeError_float (@expr7571 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1232: else { if (@expr6829 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6832 !@expr6099 argInfo@var2182 .@expr6005 element@var2188 ) {
1233:
1234: invalidPrintfArgTypeError_float (@expr7571 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ;
1235: } else { if (@expr6086 argInfo@var2182 .@expr5936 isKnownType (@expr5937 ) ) {
1236: if (@expr6570 !@expr6571 Token ::@expr5991 Match (@expr6573 argInfo@var2182 .@expr5901 typeToken@var2183 , "float|double" ) ) {
1237: if (@expr6845 !@expr6846 (@expr1073749415 !@expr6109 argInfo@var2182 .@expr5986 isArrayOrPointer (@expr5987 ) &&@expr6851 argInfo@var2182 .@expr6005 element@var2188 ) ) {
1238: invalidPrintfArgTypeError_float (@expr7571 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; }
1239: } else { if (@expr1073749423 (@expr1073749424 specifier@var2190 [@expr6856 0 ] ==@expr1073749426 'L' &&@expr1073749427 (@expr1073749428 !@expr6149 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ||@expr6612 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6127 str (@expr6128 ) !=@expr6599 "double" ) ) ||@expr1073749438
1240: (@expr1073749439 specifier@var2190 [@expr6856 0 ] !=@expr1073749441 'L' &&@expr1073749442 argInfo@var2182 .@expr5901 typeToken@var2183 .@expr6151 isLong (@expr6152 ) ) ) {
1241: invalidPrintfArgTypeError_float (@expr7571 tok@var2162 , numFormat@var2170 , specifier@var2190 , &@expr6012 argInfo@var2182 ) ; } }
1242: } } }
1243: done@var2191 =@expr1073749448 true ;
1244: break ;
1245: case 'h' :@expr5916
1246: case 'l' :@expr5916 ; {
1247:
1248: if (@expr6717 (@expr1073749452 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6722 *@expr6636 (@expr1073749459 i@var2175 +@expr5932 1 ) ==@expr6726 *@expr5768 i@var2175 ) {
1249: if (@expr1073749463 (@expr1073749464 i@var2175 +@expr6641 2 ) !=@expr6642 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr1073749469 !@expr1073749470 isalpha (@expr1073749471 *@expr6646 (@expr1073749473 i@var2175 +@expr6641 2 ) ) ) {
1250: std ::@expr1073749475 string modifier@var2192 ;
1251: modifier@var2192 +=@expr1073749476 *@expr5768 i@var2175 ;
1252: modifier@var2192 +=@expr1073749478 *@expr6636 (@expr1073749480 i@var2175 +@expr5932 1 ) ;
1253: invalidLengthModifierError (@expr1073749482 tok@var2162 , numFormat@var2170 , modifier@var2192 ) ;
1254: done@var2191 =@expr1073749483 true ;
1255: } else {
1256: specifier@var2190 =@expr1073749484 *@expr1073749485 i@var2175 ++@expr1073749486 ;
1257: specifier@var2190 +=@expr1073749487 *@expr1073749488 i@var2175 ++@expr1073749489 ;
1258: }
1259: } else {
1260: if (@expr6677 (@expr1073749491 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6683 !@expr6684 isalpha (@expr6685 *@expr6636 (@expr1073749500 i@var2175 +@expr5932 1 ) ) ) {
1261: std ::@expr1073749502 string modifier@var2193 ;
1262: modifier@var2193 +=@expr1073749503 *@expr5768 i@var2175 ;
1263: invalidLengthModifierError (@expr1073749505 tok@var2162 , numFormat@var2170 , modifier@var2193 ) ;
1264: done@var2191 =@expr1073749506 true ;
1265: } else {
1266: specifier@var2190 =@expr1073749507 *@expr1073749508 i@var2175 ++@expr1073749509 ;
1267: }
1268: }
1269: }
1270: break ;
1271: case 'I' :@expr5916 ;
1272: if (@expr1073749511 (@expr1073749512 *@expr6636 (@expr1073749514 i@var2175 +@expr5932 1 ) ==@expr6660 '3' &&@expr1073749517 *@expr6646 (@expr1073749519 i@var2175 +@expr6641 2 ) ==@expr6670 '2' ) ||@expr1073749522
1273: (@expr1073749523 *@expr6636 (@expr1073749525 i@var2175 +@expr5932 1 ) ==@expr6639 '6' &&@expr1073749528 *@expr6646 (@expr1073749530 i@var2175 +@expr6641 2 ) ==@expr6649 '4' ) ) {
1274: specifier@var2190 +=@expr1073749533 *@expr1073749534 i@var2175 ++@expr1073749535 ;
1275: specifier@var2190 +=@expr1073749536 *@expr1073749537 i@var2175 ++@expr1073749538 ;
1276: }
1277: ;
1278: case 'j' :@expr5916
1279: case 'z' :@expr5916
1280: case 't' :@expr5916
1281: case 'L' :@expr5916 ;
1282:
1283: if (@expr6677 (@expr1073749544 i@var2175 +@expr5932 1 ) !=@expr6632 formatString@var2169 .@expr5764 end (@expr5765 ) &&@expr6683 !@expr6684 isalpha (@expr6685 *@expr6636 (@expr1073749553 i@var2175 +@expr5932 1 ) ) ) {
1284: specifier@var2190 +=@expr1073749555 *@expr5768 i@var2175 ;
1285: invalidLengthModifierError (@expr1073749557 tok@var2162 , numFormat@var2170 , specifier@var2190 ) ;
1286: done@var2191 =@expr1073749558 true ;
1287: } else {
1288: specifier@var2190 +=@expr1073749559 *@expr1073749560 i@var2175 ++@expr1073749561 ;
1289: }
1290: break ;
1291: default :@expr5916 ;
1292: done@var2191 =@expr1073749563 true ;
1293: break ;
1294: }
1295: }
1296: } }
1297: }
1298:
1299: if (@expr5784 argListTok@var2164 ) {
1300: argListTok@var2164 =@expr1073749565 argListTok@var2164 .@expr5786 nextArgument (@expr5787 ) ; }
1301: }
1302: } } }
1303: }
1304:
1305:
1306: int numFunction@var2194 ; numFunction@var2194 =@expr1073749568 0 ;
1307: while (@expr1073749569 argListTok2@var2173 ) {
1308: numFunction@var2194 ++@expr1073749570 ;
1309: argListTok2@var2173 =@expr1073749571 argListTok2@var2173 .@expr1073749572 nextArgument (@expr1073749573 ) ;
1310: }
1311:
1312: if (@expr6757 printWarning@var2168 ) {
1313:
1314: for (@expr1073749575 int i@var2195 :@expr1073749576 parameterPositionsUsed@var2174 ) {
1315: if (@expr1073749577 (@expr1073749578 i@var2195 ==@expr1073749579 0 ) ||@expr1073749580 (@expr1073749581 i@var2195 >@expr1073749582 numFormat@var2170 ) ) {
1316: wrongPrintfScanfPosixParameterPositionError (@expr1073749583 tok@var2162 , tok@var2162 .@expr7760 str (@expr7761 ) , i@var2195 , numFormat@var2170 ) ; }
1317: }
1318: }
1319:
1320:
1321: if (@expr1073749586 (@expr1073749587 numFormat@var2170 +@expr7764 numSecure@var2171 ) !=@expr1073749589 numFunction@var2194 ) {
1322: wrongPrintfScanfArgumentsError (@expr1073749590 tok@var2162 , tok@var2162 .@expr7767 originalName (@expr7768 ) .@expr1073749593 empty (@expr1073749594 ) ?@expr1073749595 tok@var2162 .@expr7760 str (@expr7761 ) :@expr1073749598 tok@var2162 .@expr7767 originalName (@expr7768 ) , numFormat@var2170 +@expr7764 numSecure@var2171 , numFunction@var2194 ) ; }
1323: }
1324:
|
1327:
1328: CheckIO :: ArgumentInfo :: ArgumentInfo ( const Token * arg@var2196 , const Settings * settings@var2197 , bool _isCPP@var2198 )
1329: : variableInfo@var76 ( nullptr )
1330: , typeToken@var77 ( nullptr )
1331: , functionInfo@var78 ( nullptr )
1332: , tempToken@var79 ( nullptr )
1333: , element@var80 ( false )
1334: , _template@var81 ( false )
1335: , address@var82 ( false )
1336: , isCPP@var83 ( _isCPP@var2198 )
1337: {
1338: if (@expr1073749602 !@expr7779 arg@var2196 ) {
1339: return ; }
1340:
1341:
1342:
1343: if (@expr1073749604 !@expr1073749605 Token ::@expr7782 Match (@expr1073749607 arg@var2196 , "%str% ,|)" ) &&@expr1073749608 !@expr1073749609 (@expr1073749610 Token ::@expr7782 Match (@expr1073749612 arg@var2196 , "%var%" ) &&@expr1073749613 arg@var2196 .@expr7790 variable (@expr7791 ) &&@expr1073749616 arg@var2196 .@expr7790 variable (@expr7791 ) .@expr1073749619 isArray (@expr1073749620 ) ) ) {
1344: const Token * top@var2199 ; top@var2199 =@expr1073749621 arg@var2196 ;
1345: while (@expr1073749622 top@var2199 .@expr1073749623 str (@expr1073749624 ) ==@expr1073749625 "(" &&@expr1073749626 !@expr1073749627 top@var2199 .@expr1073749628 isCast (@expr1073749629 ) ) {
1346: top@var2199 =@expr1073749630 top@var2199 .@expr1073749631 next (@expr1073749632 ) ; }
1347: while (@expr1073749633 top@var2199 .@expr7810 astParent (@expr7811 ) &&@expr1073749636 top@var2199 .@expr7810 astParent (@expr7811 ) .@expr1073749639 str (@expr1073749640 ) !=@expr1073749641 "," &&@expr1073749642 top@var2199 .@expr7810 astParent (@expr7811 ) !=@expr1073749645 arg@var2196 .@expr1073749646 previous (@expr1073749647 ) ) {
1348: top@var2199 =@expr1073749648 top@var2199 .@expr7810 astParent (@expr7811 ) ; }
1349: const ValueType * valuetype@var2200 ; valuetype@var2200 =@expr1073749651 top@var2199 .@expr1073749652 argumentType (@expr1073749653 ) ;
1350: if (@expr1073749654 valuetype@var2200 &&@expr1073749655 valuetype@var2200 .@expr7832 type@var2201 >=@expr1073749657 ValueType ::@expr1073749658 Type ::@expr1073749659 BOOL ) {
1351: typeToken@var77 =@expr1073749660 tempToken@var79 =@expr1073749661 new Token (@expr7838 ) ;
1352: if (@expr1073749663 valuetype@var2200 .@expr7840 pointer@var2202 &&@expr1073749665 valuetype@var2200 .@expr1073749666 constness@var2203 &@expr1073749667 1 ) {
1353: tempToken@var79 .@expr7844 str (@expr7845 "const" ) ;
1354: tempToken@var79 .@expr7846 insertToken (@expr1073749671 "a" ) ;
1355: tempToken@var79 =@expr1073749672 tempToken@var79 .@expr1073749673 next (@expr1073749674 ) ;
1356: }
1357: if (@expr1073749675 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749677 ValueType ::@expr1073749678 BOOL ) {
1358: tempToken@var79 .@expr7844 str (@expr7856 "bool" ) ; }
1359: else { if (@expr1073749681 valuetype@var2200 .@expr7832 type@var2201 ==@expr7859 ValueType ::@expr7860 CHAR ) {
1360: tempToken@var79 .@expr7844 str (@expr1073749686 "char" ) ; }
1361: else { if (@expr1073749687 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749689 ValueType ::@expr1073749690 SHORT ) {
1362: tempToken@var79 .@expr7844 str (@expr1073749692 "short" ) ; }
1363: else { if (@expr1073749693 valuetype@var2200 .@expr7832 type@var2201 ==@expr7871 ValueType ::@expr7872 WCHAR_T ) {
1364: tempToken@var79 .@expr7844 str (@expr1073749698 "wchar_t" ) ; }
1365: else { if (@expr1073749699 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749701 ValueType ::@expr1073749702 INT ) {
1366: tempToken@var79 .@expr7844 str (@expr7880 "int" ) ; }
1367: else { if (@expr1073749705 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749707 ValueType ::@expr1073749708 LONG ) {
1368: tempToken@var79 .@expr7844 str (@expr7886 "long" ) ; }
1369: else { if (@expr1073749711 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749713 ValueType ::@expr1073749714 LONGLONG ) {
1370: tempToken@var79 .@expr7844 str (@expr7886 "long" ) ;
1371: tempToken@var79 .@expr7893 isLong (@expr7894 true ) ;
1372: } else { if (@expr1073749719 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749721 ValueType ::@expr1073749722 FLOAT ) {
1373: tempToken@var79 .@expr7844 str (@expr1073749724 "float" ) ; }
1374: else { if (@expr1073749725 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749727 ValueType ::@expr1073749728 DOUBLE ) {
1375: tempToken@var79 .@expr7844 str (@expr7906 "double" ) ; }
1376: else { if (@expr1073749731 valuetype@var2200 .@expr7832 type@var2201 ==@expr1073749733 ValueType ::@expr1073749734 LONGDOUBLE ) {
1377: tempToken@var79 .@expr7844 str (@expr7906 "double" ) ;
1378: tempToken@var79 .@expr7893 isLong (@expr7894 true ) ;
1379: } } } } } } } } } }
1380: if (@expr1073749739 valuetype@var2200 .@expr1073749740 isIntegral (@expr1073749741 ) ) {
1381: if (@expr1073749742 valuetype@var2200 .@expr7919 sign@var2204 ==@expr1073749744 ValueType ::@expr7921 Sign ::@expr1073749746 UNSIGNED ) {
1382: tempToken@var79 .@expr7923 isUnsigned (@expr7924 true ) ; }
1383: else { if (@expr1073749749 valuetype@var2200 .@expr7919 sign@var2204 ==@expr1073749751 ValueType ::@expr7921 Sign ::@expr1073749753 SIGNED ) {
1384: tempToken@var79 .@expr1073749754 isSigned (@expr1073749755 true ) ; } }
1385: }
1386: if (@expr1073749756 !@expr1073749757 valuetype@var2200 .@expr7934 originalTypeName@var2205 .@expr1073749759 empty (@expr1073749760 ) ) {
1387: tempToken@var79 .@expr7937 originalName (@expr1073749762 valuetype@var2200 .@expr7934 originalTypeName@var2205 ) ; }
1388: for (@expr1073749764 int p@var2206 =@expr1073749765 0 ; p@var2206 <@expr1073749766 valuetype@var2200 .@expr7840 pointer@var2202 ; p@var2206 ++@expr1073749768 ) {
1389: tempToken@var79 .@expr7846 insertToken (@expr7946 "*" ) ; }
1390: tempToken@var79 =@expr1073749771 const_cast < Token *@expr1073749772 > (@expr1073749773 typeToken@var77 ) ;
1391: if (@expr1073749774 top@var2199 .@expr1073749775 isBinaryOp (@expr1073749776 ) &&@expr1073749777 valuetype@var2200 .@expr7840 pointer@var2202 ==@expr1073749779 1 &&@expr1073749780 (@expr1073749781 valuetype@var2200 .@expr7832 type@var2201 ==@expr7859 ValueType ::@expr7860 CHAR ||@expr1073749785 valuetype@var2200 .@expr7832 type@var2201 ==@expr7871 ValueType ::@expr7872 WCHAR_T ) ) {
1392: tempToken@var79 .@expr1073749789 tokType (@expr1073749790 Token ::@expr7967 eString ) ; }
1393: return ;
1394: }
1395: }
1396:
1397:
1398: if (@expr1073749792 arg@var2196 .@expr7969 tokType (@expr7970 ) ==@expr1073749795 Token ::@expr7967 eString ) {
1399: typeToken@var77 =@expr1073749797 arg@var2196 ;
1400: return ;
1401: } else { if (@expr1073749798 arg@var2196 .@expr7975 str (@expr7976 ) ==@expr7977 "&" ||@expr1073749802 arg@var2196 .@expr7969 tokType (@expr7970 ) ==@expr7981 Token ::@expr7982 eVariable ||@expr1073749807
1402: arg@var2196 .@expr7969 tokType (@expr7970 ) ==@expr7986 Token ::@expr7987 eFunction ||@expr1073749812 Token ::@expr7782 Match (@expr7990 arg@var2196 , "%type% ::" ) ||@expr1073749815
1403: (@expr1073749816 Token ::@expr7782 Match (@expr1073749818 arg@var2196 , "static_cast|reinterpret_cast|const_cast <" ) &&@expr1073749819
1404: Token ::@expr1073749820 simpleMatch (@expr1073749821 arg@var2196 .@expr7998 linkAt (@expr7999 1 ) , "> (" ) &&@expr1073749824
1405: Token ::@expr7782 Match (@expr1073749826 arg@var2196 .@expr7998 linkAt (@expr7999 1 ) .@expr1073749829 linkAt (@expr1073749830 1 ) , ") ,|)" ) ) ) {
1406: if (@expr1073749831 Token ::@expr7782 Match (@expr1073749833 arg@var2196 , "static_cast|reinterpret_cast|const_cast" ) ) {
1407: typeToken@var77 =@expr1073749834 arg@var2196 .@expr8011 tokAt (@expr8012 2 ) ;
1408: while (@expr8013 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8016 "const" ||@expr8017 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8020 "extern" ) {
1409: typeToken@var77 =@expr1073749845 typeToken@var77 .@expr8022 next (@expr8023 ) ; }
1410: return ;
1411: }
1412: if (@expr1073749848 arg@var2196 .@expr7975 str (@expr7976 ) ==@expr7977 "&" ) {
1413: address@var82 =@expr1073749852 true ;
1414: arg@var2196 =@expr1073749853 arg@var2196 .@expr8030 next (@expr8031 ) ;
1415: }
1416: while (@expr1073749856 Token ::@expr7782 Match (@expr7990 arg@var2196 , "%type% ::" ) ) {
1417: arg@var2196 =@expr1073749859 arg@var2196 .@expr8011 tokAt (@expr8012 2 ) ; }
1418: if (@expr1073749862 !@expr7779 arg@var2196 ||@expr1073749864 !@expr1073749865 (@expr1073749866 arg@var2196 .@expr7969 tokType (@expr7970 ) ==@expr7981 Token ::@expr7982 eVariable ||@expr1073749871 arg@var2196 .@expr7969 tokType (@expr7970 ) ==@expr7986 Token ::@expr7987 eFunction ) ) {
1419: return ; }
1420: const Token * varTok@var2207 ; varTok@var2207 =@expr1073749876 nullptr ;
1421: const Token * tok1@var2208 ; tok1@var2208 =@expr1073749877 arg@var2196 .@expr8030 next (@expr8031 ) ;
1422: for (@expr1073749880 ; tok1@var2208 ; tok1@var2208 =@expr1073749881 tok1@var2208 .@expr8058 next (@expr8059 ) ) {
1423: if (@expr1073749884 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073749887 "," ||@expr1073749888 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073749891 ")" ) {
1424: if (@expr1073749892 tok1@var2208 .@expr8069 previous (@expr8070 ) .@expr8071 str (@expr8072 ) ==@expr8073 "]" ) {
1425: varTok@var2207 =@expr1073749898 tok1@var2208 .@expr8075 linkAt (@expr8076 -1 ) .@expr8077 previous (@expr8078 ) ;
1426: if (@expr1073749903 varTok@var2207 .@expr1073749904 str (@expr1073749905 ) ==@expr1073749906 ")" &&@expr1073749907 varTok@var2207 .@expr8084 link (@expr8085 ) .@expr8086 previous (@expr8087 ) .@expr1073749912 tokType (@expr1073749913 ) ==@expr1073749914 Token ::@expr7987 eFunction ) {
1427: const Function * function@var2209 ; function@var2209 =@expr1073749916 varTok@var2207 .@expr8084 link (@expr8085 ) .@expr8086 previous (@expr8087 ) .@expr1073749921 function (@expr1073749922 ) ;
1428: if (@expr1073749923 function@var2209 &&@expr1073749924 function@var2209 .@expr8101 retType@var2210 &&@expr1073749926 function@var2209 .@expr8101 retType@var2210 .@expr1073749928 isEnumType (@expr1073749929 ) ) {
1429: if (@expr1073749930 function@var2209 .@expr8101 retType@var2210 .@expr8108 classScope@var2211 .@expr8109 enumType@var2212 ) {
1430: typeToken@var77 =@expr1073749934 function@var2209 .@expr8101 retType@var2210 .@expr8108 classScope@var2211 .@expr8109 enumType@var2212 ; }
1431: else {
1432: tempToken@var79 =@expr1073749938 new Token (@expr7838 ) ;
1433: tempToken@var79 .@expr8116 fileIndex (@expr8117 tok1@var2208 .@expr8118 fileIndex (@expr8119 ) ) ;
1434: tempToken@var79 .@expr8120 linenr (@expr8121 tok1@var2208 .@expr8122 linenr (@expr8123 ) ) ;
1435: tempToken@var79 .@expr7844 str (@expr7880 "int" ) ;
1436: typeToken@var77 =@expr1073749950 tempToken@var79 ;
1437: }
1438: } else { if (@expr1073749951 function@var2209 &&@expr1073749952 function@var2209 .@expr8129 retDef@var2213 ) {
1439: typeToken@var77 =@expr1073749954 function@var2209 .@expr8129 retDef@var2213 ;
1440: while (@expr8013 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8016 "const" ||@expr8017 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8020 "extern" ) {
1441: typeToken@var77 =@expr1073749964 typeToken@var77 .@expr8022 next (@expr8023 ) ; }
1442: functionInfo@var78 =@expr1073749967 function@var2209 ;
1443: element@var80 =@expr1073749968 true ;
1444: } }
1445: return ;
1446: }
1447: } else { if (@expr1073749969 tok1@var2208 .@expr8069 previous (@expr8070 ) .@expr8071 str (@expr8072 ) ==@expr1073749974 ")" &&@expr1073749975 tok1@var2208 .@expr8075 linkAt (@expr8076 -1 ) .@expr8077 previous (@expr8078 ) .@expr1073749980 tokType (@expr1073749981 ) ==@expr1073749982 Token ::@expr7987 eFunction ) {
1448: const Function * function@var2214 ; function@var2214 =@expr1073749984 tok1@var2208 .@expr8075 linkAt (@expr8076 -1 ) .@expr8077 previous (@expr8078 ) .@expr1073749989 function (@expr1073749990 ) ;
1449: if (@expr1073749991 function@var2214 &&@expr1073749992 function@var2214 .@expr8169 retType@var2215 &&@expr1073749994 function@var2214 .@expr8169 retType@var2215 .@expr1073749996 isEnumType (@expr1073749997 ) ) {
1450: if (@expr1073749998 function@var2214 .@expr8169 retType@var2215 .@expr8176 classScope@var2216 .@expr8177 enumType@var2217 ) {
1451: typeToken@var77 =@expr1073750002 function@var2214 .@expr8169 retType@var2215 .@expr8176 classScope@var2216 .@expr8177 enumType@var2217 ; }
1452: else {
1453: tempToken@var79 =@expr1073750006 new Token (@expr7838 ) ;
1454: tempToken@var79 .@expr8116 fileIndex (@expr8117 tok1@var2208 .@expr8118 fileIndex (@expr8119 ) ) ;
1455: tempToken@var79 .@expr8120 linenr (@expr8121 tok1@var2208 .@expr8122 linenr (@expr8123 ) ) ;
1456: tempToken@var79 .@expr7844 str (@expr7880 "int" ) ;
1457: typeToken@var77 =@expr1073750018 tempToken@var79 ;
1458: }
1459: } else { if (@expr1073750019 function@var2214 &&@expr1073750020 function@var2214 .@expr8197 retDef@var2218 ) {
1460: typeToken@var77 =@expr1073750022 function@var2214 .@expr8197 retDef@var2218 ;
1461: while (@expr8013 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8016 "const" ||@expr8017 typeToken@var77 .@expr8014 str (@expr8015 ) ==@expr8020 "extern" ) {
1462: typeToken@var77 =@expr1073750032 typeToken@var77 .@expr8022 next (@expr8023 ) ; }
1463: functionInfo@var78 =@expr1073750035 function@var2214 ;
1464: element@var80 =@expr1073750036 false ;
1465: } }
1466: return ;
1467: } else {
1468: varTok@var2207 =@expr1073750037 tok1@var2208 .@expr8069 previous (@expr8070 ) ; } }
1469: break ;
1470: } else { if (@expr1073750040 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073750043 "(" ||@expr1073750044 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073750047 "{" ||@expr1073750048 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073750051 "[" ) {
1471: tok1@var2208 =@expr1073750052 tok1@var2208 .@expr8229 link (@expr8230 ) ; }
1472: else { if (@expr1073750055 tok1@var2208 .@expr8229 link (@expr8230 ) &&@expr1073750058 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073750061 "<" ) {
1473: tok1@var2208 =@expr1073750062 tok1@var2208 .@expr8229 link (@expr8230 ) ; }
1474:
1475:
1476: else { if (@expr1073750065 isCPP@var83 &&@expr1073750066 (@expr1073750067 (@expr1073750068 Token ::@expr7782 Match (@expr1073750070 tok1@var2208 .@expr8069 previous (@expr8070 ) , "%var% . size|empty|c_str ( ) [,)]" ) &&@expr1073750073 isStdContainer (@expr1073750074 tok1@var2208 .@expr8069 previous (@expr8070 ) ) ) ||@expr1073750077
1477: (@expr1073750078 Token ::@expr7782 Match (@expr1073750080 tok1@var2208 .@expr8069 previous (@expr8070 ) , "] . size|empty|c_str ( ) [,)]" ) &&@expr1073750083 isStdContainer (@expr1073750084 tok1@var2208 .@expr8069 previous (@expr8070 ) .@expr1073750087 link (@expr1073750088 ) .@expr1073750089 previous (@expr1073750090 ) ) ) ) ) {
1478: tempToken@var79 =@expr1073750091 new Token (@expr7838 ) ;
1479: tempToken@var79 .@expr8116 fileIndex (@expr8117 tok1@var2208 .@expr8118 fileIndex (@expr8119 ) ) ;
1480: tempToken@var79 .@expr8120 linenr (@expr8121 tok1@var2208 .@expr8122 linenr (@expr8123 ) ) ;
1481: if (@expr1073750101 tok1@var2208 .@expr8058 next (@expr8059 ) .@expr8280 str (@expr8281 ) ==@expr1073750106 "size" ) {
1482:
1483: if (@expr1073750107 settings@var2197 .@expr8284 sizeof_size_t@var2219 ==@expr1073750109 8 ) {
1484: tempToken@var79 .@expr7844 str (@expr7886 "long" ) ;
1485: if (@expr1073750112 settings@var2197 .@expr8289 sizeof_long@var2220 !=@expr1073750114 8 ) {
1486: tempToken@var79 .@expr7893 isLong (@expr7894 true ) ; }
1487: } else { if (@expr1073750117 settings@var2197 .@expr8284 sizeof_size_t@var2219 ==@expr1073750119 4 ) {
1488: if (@expr1073750120 settings@var2197 .@expr8289 sizeof_long@var2220 ==@expr1073750122 4 ) {
1489: tempToken@var79 .@expr7844 str (@expr7886 "long" ) ;
1490: } else {
1491: tempToken@var79 .@expr7844 str (@expr7880 "int" ) ;
1492: }
1493: } }
1494:
1495: tempToken@var79 .@expr7937 originalName (@expr1073750128 "size_t" ) ;
1496: tempToken@var79 .@expr7923 isUnsigned (@expr7924 true ) ;
1497: } else { if (@expr1073750131 tok1@var2208 .@expr8058 next (@expr8059 ) .@expr8280 str (@expr8281 ) ==@expr1073750136 "empty" ) {
1498: tempToken@var79 .@expr7844 str (@expr7856 "bool" ) ;
1499: } else { if (@expr1073750139 tok1@var2208 .@expr8058 next (@expr8059 ) .@expr8280 str (@expr8281 ) ==@expr1073750144 "c_str" ) {
1500: tempToken@var79 .@expr7844 str (@expr7845 "const" ) ;
1501: tempToken@var79 .@expr7846 insertToken (@expr7946 "*" ) ;
1502: if (@expr1073750149 typeToken@var77 .@expr1073750150 strAt (@expr1073750151 2 ) ==@expr1073750152 "string" ) {
1503: tempToken@var79 .@expr7846 insertToken (@expr1073750154 "char" ) ; }
1504: else {
1505: tempToken@var79 .@expr7846 insertToken (@expr1073750156 "wchar_t" ) ; }
1506: } } }
1507: typeToken@var77 =@expr1073750157 tempToken@var79 ;
1508: return ;
1509: }
1510:
1511:
1512: else { if (@expr1073750158 Token ::@expr7782 Match (@expr1073750160 tok1@var2208 .@expr8069 previous (@expr8070 ) , "%var% . at (" ) &&@expr1073750163
1513: Token ::@expr7782 Match (@expr1073750165 tok1@var2208 .@expr8075 linkAt (@expr1073750167 2 ) , ") [,)]" ) ) {
1514: varTok@var2207 =@expr1073750168 tok1@var2208 .@expr8069 previous (@expr8070 ) ;
1515: variableInfo@var76 =@expr1073750171 varTok@var2207 .@expr8348 variable (@expr8349 ) ;
1516:
1517: if (@expr1073750174 !@expr1073750175 variableInfo@var76 ||@expr1073750176 !@expr1073750177 isStdVectorOrString (@expr8354 ) ) {
1518: variableInfo@var76 =@expr1073750179 nullptr ;
1519: typeToken@var77 =@expr1073750180 nullptr ;
1520: }
1521:
1522: return ;
1523: } else { if (@expr1073750181 !@expr1073750182 (@expr1073750183 tok1@var2208 .@expr8061 str (@expr8062 ) ==@expr1073750186 "." ||@expr1073750187 tok1@var2208 .@expr8364 tokType (@expr8365 ) ==@expr1073750190 Token ::@expr7982 eVariable ||@expr1073750192 tok1@var2208 .@expr8364 tokType (@expr8365 ) ==@expr1073750195 Token ::@expr7987 eFunction ) ) {
1524: return ; } } } } } }
1525: }
1526:
1527: if (@expr1073750197 varTok@var2207 ) {
1528: variableInfo@var76 =@expr1073750198 varTok@var2207 .@expr8348 variable (@expr8349 ) ;
1529: element@var80 =@expr1073750201 tok1@var2208 .@expr8069 previous (@expr8070 ) .@expr8071 str (@expr8072 ) ==@expr8073 "]" ;
1530:
1531:
1532: if (@expr1073750207 variableInfo@var76 ) {
1533: if (@expr1073750208 element@var80 &&@expr1073750209 isStdVectorOrString (@expr8354 ) ) {
1534: element@var80 =@expr1073750211 false ;
1535: } else { if (@expr1073750212 variableInfo@var76 .@expr1073750213 isEnumType (@expr1073750214 ) ) {
1536: if (@expr1073750215 variableInfo@var76 .@expr8392 type (@expr8393 ) &&@expr1073750218 variableInfo@var76 .@expr8392 type (@expr8393 ) .@expr8397 classScope@var2363 &&@expr1073750222 variableInfo@var76 .@expr8392 type (@expr8393 ) .@expr8397 classScope@var2363 .@expr8402 enumType@var2364 ) {
1537: typeToken@var77 =@expr1073750227 variableInfo@var76 .@expr8392 type (@expr8393 ) .@expr8397 classScope@var2363 .@expr8402 enumType@var2364 ; }
1538: else {
1539: tempToken@var79 =@expr1073750232 new Token (@expr7838 ) ;
1540: tempToken@var79 .@expr8116 fileIndex (@expr8117 tok1@var2208 .@expr8118 fileIndex (@expr8119 ) ) ;
1541: tempToken@var79 .@expr8120 linenr (@expr8121 tok1@var2208 .@expr8122 linenr (@expr8123 ) ) ;
1542: tempToken@var79 .@expr7844 str (@expr7880 "int" ) ;
1543: typeToken@var77 =@expr1073750244 tempToken@var79 ;
1544: }
1545: } else {
1546: typeToken@var77 =@expr1073750245 variableInfo@var76 .@expr1073750246 typeStartToken (@expr1073750247 ) ; } }
1547: }
1548:
1549: return ;
1550: }
1551: } }
1552: }
1553:
1554: CheckIO :: ArgumentInfo :: ~ ArgumentInfo ( )
1555: {
1556: if (@expr1073750248 tempToken@var79 ) {
1557: while (@expr1073750249 tempToken@var79 .@expr1073750250 next (@expr1073750251 ) ) {
1558: tempToken@var79 .@expr1073750252 deleteNext (@expr1073750253 ) ; }
1559:
1560: delete tempToken@var79 ;
1561: }
1562: }
1563:
1564: namespace {
1565: const std :: set < std :: string > stl_vector@var2221 = { "array" , "vector" } ;
1566: const std :: set < std :: string > stl_string@var2222 = { "string" , "u16string" , "u32string" , "wstring" } ;
1567: }
1568:
1569: bool CheckIO :: ArgumentInfo :: isStdVectorOrString ( )
1570: {
1571: if (@expr1073750254 !@expr1073750255 isCPP@var83 ) {
1572: return false ; }
1573: if (@expr1073750256 variableInfo@var76 .@expr8433 isStlType (@expr1073750258 stl_vector@var2221 ) ) {
1574: typeToken@var77 =@expr1073750259 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr1073750262 tokAt (@expr1073750263 4 ) ;
1575: _template@var81 =@expr1073750264 true ;
1576: return true ;
1577: } else { if (@expr1073750265 variableInfo@var76 .@expr8433 isStlType (@expr1073750267 stl_string@var2222 ) ) {
1578: tempToken@var79 =@expr1073750268 new Token (@expr8445 ) ;
1579: tempToken@var79 .@expr8446 fileIndex (@expr8447 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr8450 fileIndex (@expr8451 ) ) ;
1580: tempToken@var79 .@expr8452 linenr (@expr8453 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr8456 linenr (@expr8457 ) ) ;
1581: if (@expr1073750282 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr1073750285 strAt (@expr1073750286 2 ) ==@expr1073750287 "string" ) {
1582: tempToken@var79 .@expr8464 str (@expr8465 "char" ) ; }
1583: else {
1584: tempToken@var79 .@expr8464 str (@expr8467 "wchar_t" ) ; }
1585: typeToken@var77 =@expr1073750292 tempToken@var79 ;
1586: return true ;
1587: } else { if (@expr1073750293 variableInfo@var76 .@expr8470 type (@expr8471 ) &&@expr1073750296 !@expr1073750297 variableInfo@var76 .@expr8470 type (@expr8471 ) .@expr8476 derivedFrom@var2365 .@expr1073750301 empty (@expr1073750302 ) ) {
1588: const std ::@expr1073750303 vector < Type ::@expr8480 BaseInfo > & derivedFrom@var2223 =@expr1073750305 variableInfo@var76 .@expr8470 type (@expr8471 ) .@expr8476 derivedFrom@var2365 ;
1589: for (@expr1073750309 const Type ::@expr8480 BaseInfo &@expr8487 i@var2224 :@expr1073750312 derivedFrom@var2223 ) {
1590: const Token * nameTok@var2225 ; nameTok@var2225 =@expr1073750313 i@var2224 .@expr1073750314 nameTok@var2226 ;
1591: if (@expr1073750315 Token ::@expr8492 Match (@expr1073750317 nameTok@var2225 , "std :: vector|array <" ) ) {
1592: typeToken@var77 =@expr1073750318 nameTok@var2225 .@expr1073750319 tokAt (@expr1073750320 4 ) ;
1593: _template@var81 =@expr1073750321 true ;
1594: return true ;
1595: } else { if (@expr1073750322 Token ::@expr8492 Match (@expr1073750324 nameTok@var2225 , "std :: string|wstring" ) ) {
1596: tempToken@var79 =@expr1073750325 new Token (@expr8445 ) ;
1597: tempToken@var79 .@expr8446 fileIndex (@expr8447 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr8450 fileIndex (@expr8451 ) ) ;
1598: tempToken@var79 .@expr8452 linenr (@expr8453 variableInfo@var76 .@expr8436 typeStartToken (@expr8437 ) .@expr8456 linenr (@expr8457 ) ) ;
1599: if (@expr1073750339 nameTok@var2225 .@expr1073750340 strAt (@expr1073750341 2 ) ==@expr1073750342 "string" ) {
1600: tempToken@var79 .@expr8464 str (@expr8465 "char" ) ; }
1601: else {
1602: tempToken@var79 .@expr8464 str (@expr8467 "wchar_t" ) ; }
1603: typeToken@var77 =@expr1073750347 tempToken@var79 ;
1604: return true ;
1605: } }
1606: }
1607: } else { if (@expr1073750348 variableInfo@var76 .@expr8470 type (@expr8471 ) ) {
1608: const Scope * classScope@var2227 ; classScope@var2227 =@expr1073750351 variableInfo@var76 .@expr8470 type (@expr8471 ) .@expr1073750354 classScope@var2363 ;
1609: if (@expr1073750355 classScope@var2227 ) {
1610: for (@expr1073750356 const Function &@expr8487 func@var2228 :@expr1073750358 classScope@var2227 .@expr1073750359 functionList@var2229 ) {
1611: if (@expr1073750360 func@var2228 .@expr1073750361 name (@expr1073750362 ) ==@expr1073750363 "operator[]" ) {
1612: if (@expr1073750364 Token ::@expr8492 Match (@expr1073750366 func@var2228 .@expr8543 retDef@var2230 , "%type% &" ) ) {
1613: typeToken@var77 =@expr1073750368 func@var2228 .@expr8543 retDef@var2230 ;
1614: return true ;
1615: }
1616: }
1617: }
1618: }
1619: } } } }
1620:
1621: return false ;
1622: }
1623:
1624: static const std :: set < std :: string > stl_container@var2231 = {
1625: "array" , "bitset" , "deque" , "forward_list" ,
1626: "hash_map" , "hash_multimap" , "hash_set" ,
1627: "list" , "map" , "multimap" , "multiset" ,
1628: "priority_queue" , "queue" , "set" , "stack" ,
1629: "unordered_map" , "unordered_multimap" , "unordered_multiset" , "unordered_set" , "vector"
1630: } ;
1631:
1632: bool CheckIO :: ArgumentInfo :: isStdContainer ( const Token * tok@var2232 )
1633: {
1634: if (@expr1073750370 !@expr1073750371 isCPP@var83 ) {
1635: return false ; }
1636: if (@expr1073750372 tok@var2232 &&@expr1073750373 tok@var2232 .@expr8550 variable (@expr8551 ) ) {
1637: const Variable * variable@var2233 ; variable@var2233 =@expr1073750376 tok@var2232 .@expr8550 variable (@expr8551 ) ;
1638: if (@expr1073750379 variable@var2233 .@expr8556 isStlType (@expr1073750381 stl_container@var2231 ) ) {
1639: typeToken@var77 =@expr1073750382 variable@var2233 .@expr8559 typeStartToken (@expr8560 ) .@expr1073750385 tokAt (@expr1073750386 4 ) ;
1640: return true ;
1641: } else { if (@expr1073750387 variable@var2233 .@expr8556 isStlType (@expr1073750389 stl_string@var2222 ) ) {
1642: typeToken@var77 =@expr1073750390 variable@var2233 .@expr8559 typeStartToken (@expr8560 ) ;
1643: return true ;
1644: } else { if (@expr1073750393 variable@var2233 .@expr8570 type (@expr8571 ) &&@expr1073750396 !@expr1073750397 variable@var2233 .@expr8570 type (@expr8571 ) .@expr8576 derivedFrom@var2365 .@expr1073750401 empty (@expr1073750402 ) ) {
1645: for (@expr1073750403 const Type ::@expr1073750404 BaseInfo &@expr1073750405 baseInfo@var2234 :@expr1073750406 variable@var2233 .@expr8570 type (@expr8571 ) .@expr8576 derivedFrom@var2365 ) {
1646: const Token * nameTok@var2235 ; nameTok@var2235 =@expr1073750410 baseInfo@var2234 .@expr1073750411 nameTok@var2236 ;
1647: if (@expr1073750412 Token ::@expr8589 Match (@expr1073750414 nameTok@var2235 , "std :: vector|array|bitset|deque|list|forward_list|map|multimap|multiset|priority_queue|queue|set|stack|hash_map|hash_multimap|hash_set|unordered_map|unordered_multimap|unordered_set|unordered_multiset <" ) ) {
1648: typeToken@var77 =@expr1073750415 nameTok@var2235 .@expr1073750416 tokAt (@expr1073750417 4 ) ;
1649: return true ;
1650: } else { if (@expr1073750418 Token ::@expr8589 Match (@expr1073750420 nameTok@var2235 , "std :: string|wstring" ) ) {
1651: typeToken@var77 =@expr1073750421 nameTok@var2235 ;
1652: return true ;
1653: } }
1654: }
1655: } } }
1656: }
1657:
1658: return false ;
1659: }
1660:
1661: bool CheckIO :: ArgumentInfo :: isArrayOrPointer ( ) const
1662: {
1663: if (@expr1073750422 address@var82 ) {
1664: return true ; }
1665: else { if (@expr1073750423 variableInfo@var76 &&@expr1073750424 !@expr1073750425 _template@var81 ) {
1666: return variableInfo@var76 .@expr1073750426 isArrayOrPointer (@expr1073750427 ) ;
1667: } else {
1668: const Token * tok@var2237 ; tok@var2237 =@expr1073750428 typeToken@var77 ;
1669: while (@expr1073750429 Token ::@expr1073750430 Match (@expr1073750431 tok@var2237 , "const|struct" ) ) {
1670: tok@var2237 =@expr1073750432 tok@var2237 .@expr1073750433 next (@expr1073750434 ) ; }
1671: if (@expr1073750435 tok@var2237 &&@expr1073750436 tok@var2237 .@expr1073750437 strAt (@expr1073750438 1 ) ==@expr1073750439 "*" ) {
1672: return true ; }
1673: } }
1674: return false ;
1675: }
1676:
1677: bool CheckIO :: ArgumentInfo :: isComplexType ( ) const
1678: {
1679: if (@expr1073750440 variableInfo@var76 .@expr1073750441 type (@expr1073750442 ) ) {
1680: return (@expr8619 true ) ; }
1681:
1682: const Token * varTypeTok@var2238 ; varTypeTok@var2238 =@expr1073750444 typeToken@var77 ;
1683: if (@expr1073750445 varTypeTok@var2238 .@expr1073750446 str (@expr1073750447 ) ==@expr1073750448 "std" ) {
1684: varTypeTok@var2238 =@expr1073750449 varTypeTok@var2238 .@expr1073750450 tokAt (@expr1073750451 2 ) ; }
1685:
1686: return (@expr8619 (@expr8619 variableInfo@var76 .@expr1073750454 isStlStringType (@expr1073750455 ) ||@expr1073750456 (@expr8619 varTypeTok@var2238 .@expr1073750458 strAt (@expr1073750459 1 ) ==@expr1073750460 "<" &&@expr1073750461 varTypeTok@var2238 .@expr8638 linkAt (@expr8639 1 ) &&@expr1073750464 varTypeTok@var2238 .@expr8638 linkAt (@expr8639 1 ) .@expr1073750467 strAt (@expr1073750468 1 ) !=@expr1073750469 "::" ) ) &&@expr1073750470 !@expr1073750471 variableInfo@var76 .@expr1073750472 isArrayOrPointer (@expr1073750473 ) ) ;
1687: }
1688:
1689: bool CheckIO :: ArgumentInfo :: isKnownType ( ) const
1690: {
1691: if (@expr1073750474 variableInfo@var76 ) {
1692: return (@expr8651 typeToken@var77 .@expr8652 isStandardType (@expr8653 ) ||@expr1073750478 typeToken@var77 .@expr1073750479 next (@expr1073750480 ) .@expr1073750481 isStandardType (@expr1073750482 ) ||@expr1073750483 isComplexType (@expr1073750484 ) ) ; }
1693: else { if (@expr1073750485 functionInfo@var78 ) {
1694: return (@expr8651 typeToken@var77 .@expr8652 isStandardType (@expr8653 ) ||@expr1073750489 functionInfo@var78 .@expr1073750490 retType@var2352 ||@expr1073750491 Token ::@expr8668 Match (@expr8669 typeToken@var77 , "std :: string|wstring" ) ) ; } }
1695:
1696: return typeToken@var77 .@expr8652 isStandardType (@expr8653 ) ||@expr1073750496 Token ::@expr8668 Match (@expr8669 typeToken@var77 , "std :: string|wstring" ) ;
1697: }
1698:
1699: bool CheckIO :: ArgumentInfo :: isLibraryType ( const Settings * settings@var2239 ) const
1700: {
1701: return typeToken@var77 &&@expr1073750499 typeToken@var77 .@expr1073750500 isStandardType (@expr1073750501 ) &&@expr1073750502 settings@var2239 .@expr1073750503 library@var2240 .@expr1073750504 podtype (@expr1073750505 typeToken@var77 .@expr1073750506 str (@expr1073750507 ) ) ;
1702: }
1703:
1704: void CheckIO :: wrongPrintfScanfArgumentsError ( const Token * tok@var2241 ,
1705: const std :: string & functionName@var2242 ,
1706: int numFormat@var2243 ,
1707: int numFunction@var2244 )
1708: {
1709: const Severity ::@expr1073750508 SeverityType severity@var2245 =@expr1073750509 numFormat@var2243 >@expr8686 numFunction@var2244 ?@expr1073750511 Severity ::@expr8688 error :@expr1073750513 Severity ::@expr8690 warning ;
1710: if (@expr1073750515 severity@var2245 !=@expr1073750516 Severity ::@expr8688 error &&@expr1073750518 !@expr1073750519 mSettings@var29 .@expr1073750520 severity@var2349 .@expr1073750521 isEnabled (@expr1073750522 Severity ::@expr8690 warning ) ) {
1711: return ; }
1712:
1713: std ::@expr1073750524 ostringstream errmsg@var2246 ;
1714: errmsg@var2246 <<@expr1073750525 functionName@var2242
1715: <<@expr1073750526 " format string requires "
1716: <<@expr1073750527 numFormat@var2243
1717: <<@expr1073750528 " parameter" <<@expr1073750529 (@expr1073750530 numFormat@var2243 !=@expr1073750531 1 ?@expr1073750532 "s" :@expr1073750533 "" ) <<@expr1073750534 " but "
1718: <<@expr1073750535 (@expr1073750536 numFormat@var2243 >@expr8686 numFunction@var2244 ?@expr1073750538 "only " :@expr1073750539 "" )
1719: <<@expr1073750540 numFunction@var2244
1720: <<@expr1073750541 (@expr1073750542 numFunction@var2244 !=@expr1073750543 1 ?@expr1073750544 " are" :@expr1073750545 " is" )
1721: <<@expr1073750546 " given." ;
1722:
1723: reportError (@expr1073750547 tok@var2241 , severity@var2245 , "wrongPrintfScanfArgNum" , errmsg@var2246 .@expr1073750548 str (@expr1073750549 ) , CWE685@var2029 , Certainty ::@expr1073750550 normal ) ;
1724: }
1725:
1726: void CheckIO :: wrongPrintfScanfPosixParameterPositionError ( const Token * tok@var2247 , const std :: string & functionName@var2248 ,
1727: int index@var2249 , int numFunction@var2250 )
1728: {
1729: if (@expr1073750551 !@expr1073750552 mSettings@var29 .@expr1073750553 severity@var2349 .@expr1073750554 isEnabled (@expr1073750555 Severity ::@expr8732 warning ) ) {
1730: return ; }
1731: std ::@expr1073750557 ostringstream errmsg@var2251 ;
1732: errmsg@var2251 <<@expr1073750558 functionName@var2248 <<@expr1073750559 ": " ;
1733: if (@expr1073750560 index@var2249 ==@expr1073750561 0 ) {
1734: errmsg@var2251 <<@expr1073750562 "parameter positions start at 1, not 0" ;
1735: } else {
1736: errmsg@var2251 <<@expr1073750563 "referencing parameter " <<@expr1073750564 index@var2249 <<@expr1073750565 " while " <<@expr1073750566 numFunction@var2250 <<@expr1073750567 " arguments given" ;
1737: }
1738: reportError (@expr1073750568 tok@var2247 , Severity ::@expr8732 warning , "wrongPrintfScanfParameterPositionError" , errmsg@var2251 .@expr1073750570 str (@expr1073750571 ) , CWE685@var2029 , Certainty ::@expr1073750572 normal ) ;
1739: }
1740:
1741: void CheckIO :: invalidScanfArgTypeError_s ( const Token * tok@var2252 , int numFormat@var2253 , const std :: string & specifier@var2254 , const ArgumentInfo * argInfo@var2255 )
1742: {
1743: const Severity ::@expr1073750573 SeverityType severity@var2256 =@expr1073750574 getSeverity (@expr1073750575 argInfo@var2255 ) ;
1744: if (@expr1073750576 !@expr1073750577 mSettings@var29 .@expr1073750578 severity@var2349 .@expr1073750579 isEnabled (@expr1073750580 severity@var2256 ) ) {
1745: return ; }
1746: std ::@expr1073750581 ostringstream errmsg@var2257 ;
1747: errmsg@var2257 <<@expr1073750582 "%" <<@expr1073750583 specifier@var2254 <<@expr1073750584 " in format string (no. " <<@expr1073750585 numFormat@var2253 <<@expr1073750586 ") requires a \'" ;
1748: if (@expr1073750587 specifier@var2254 [@expr8764 0 ] ==@expr1073750589 's' ) {
1749: errmsg@var2257 <<@expr1073750590 "char" ; }
1750: else { if (@expr1073750591 specifier@var2254 [@expr8764 0 ] ==@expr1073750593 'S' ) {
1751: errmsg@var2257 <<@expr1073750594 "wchar_t" ; } }
1752: errmsg@var2257 <<@expr1073750595 " *\' but the argument type is " ;
1753: argumentType (@expr1073750596 errmsg@var2257 , argInfo@var2255 ) ;
1754: errmsg@var2257 <<@expr1073750597 "." ;
1755: reportError (@expr1073750598 tok@var2252 , severity@var2256 , "invalidScanfArgType_s" , errmsg@var2257 .@expr1073750599 str (@expr1073750600 ) , CWE686@var2030 , Certainty ::@expr1073750601 normal ) ;
1756: }
1757: void CheckIO :: invalidScanfArgTypeError_int ( const Token * tok@var2258 , int numFormat@var2259 , const std :: string & specifier@var2260 , const ArgumentInfo * argInfo@var2261 , bool isUnsigned@var2262 )
1758: {
1759: const Severity ::@expr1073750603 SeverityType severity@var2263 =@expr1073750604 getSeverity (@expr1073750605 argInfo@var2261 ) ;
1760: if (@expr1073750606 !@expr1073750607 mSettings@var29 .@expr1073750608 severity@var2349 .@expr1073750609 isEnabled (@expr1073750610 severity@var2263 ) ) {
1761: return ; }
1762: std ::@expr1073750611 ostringstream errmsg@var2264 ;
1763: errmsg@var2264 <<@expr1073750612 "%" <<@expr1073750613 specifier@var2260 <<@expr1073750614 " in format string (no. " <<@expr1073750615 numFormat@var2259 <<@expr1073750616 ") requires \'" ;
1764: if (@expr1073750617 specifier@var2260 [@expr8794 0 ] ==@expr1073750619 'h' ) {
1765: if (@expr1073750620 specifier@var2260 [@expr8797 1 ] ==@expr1073750622 'h' ) {
1766: errmsg@var2264 <<@expr8799 (@expr1073750624 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750627 "char" ; }
1767: else {
1768: errmsg@var2264 <<@expr8799 (@expr1073750629 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750632 "short" ; }
1769: } else { if (@expr1073750633 specifier@var2260 [@expr8794 0 ] ==@expr1073750635 'l' ) {
1770: if (@expr1073750636 specifier@var2260 [@expr8797 1 ] ==@expr1073750638 'l' ) {
1771: errmsg@var2264 <<@expr8799 (@expr1073750640 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr8819 "long long" ; }
1772: else {
1773: errmsg@var2264 <<@expr8799 (@expr1073750645 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750648 "long" ; }
1774: } else { if (@expr1073750649 specifier@var2260 .@expr8826 find (@expr1073750651 "I32" ) !=@expr1073750652 std ::@expr8829 string ::@expr8830 npos@expr8778 ) {
1775: errmsg@var2264 <<@expr8799 (@expr1073750656 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750659 "__int32" ;
1776: } else { if (@expr1073750660 specifier@var2260 .@expr8826 find (@expr1073750662 "I64" ) !=@expr1073750663 std ::@expr8829 string ::@expr8830 npos@expr8778 ) {
1777: errmsg@var2264 <<@expr8799 (@expr1073750667 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750670 "__int64" ;
1778: } else { if (@expr1073750671 specifier@var2260 [@expr8794 0 ] ==@expr1073750673 'I' ) {
1779: errmsg@var2264 <<@expr1073750674 (@expr1073750675 isUnsigned@var2262 ?@expr1073750676 "size_t" :@expr1073750677 "ptrdiff_t" ) ;
1780: } else { if (@expr1073750678 specifier@var2260 [@expr8794 0 ] ==@expr1073750680 'j' ) {
1781: if (@expr1073750681 isUnsigned@var2262 ) {
1782: errmsg@var2264 <<@expr1073750682 "uintmax_t" ; }
1783: else {
1784: errmsg@var2264 <<@expr1073750683 "intmax_t" ; }
1785: } else { if (@expr1073750684 specifier@var2260 [@expr8794 0 ] ==@expr1073750686 'z' ) {
1786: if (@expr1073750687 specifier@var2260 [@expr8797 1 ] ==@expr1073750689 'd' ||@expr1073750690 specifier@var2260 [@expr8797 1 ] ==@expr1073750692 'i' ) {
1787: errmsg@var2264 <<@expr1073750693 "ssize_t" ; }
1788: else {
1789: errmsg@var2264 <<@expr1073750694 "size_t" ; }
1790: } else { if (@expr1073750695 specifier@var2260 [@expr8794 0 ] ==@expr1073750697 't' ) {
1791: errmsg@var2264 <<@expr8799 (@expr1073750699 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750702 "ptrdiff_t" ;
1792: } else { if (@expr1073750703 specifier@var2260 [@expr8794 0 ] ==@expr1073750705 'L' ) {
1793: errmsg@var2264 <<@expr8799 (@expr1073750707 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr8819 "long long" ;
1794: } else {
1795: errmsg@var2264 <<@expr8799 (@expr1073750712 isUnsigned@var2262 ?@expr8801 "unsigned " :@expr8802 "" ) <<@expr1073750715 "int" ;
1796: } } } } } } } } }
1797: errmsg@var2264 <<@expr1073750716 " *\' but the argument type is " ;
1798: argumentType (@expr1073750717 errmsg@var2264 , argInfo@var2261 ) ;
1799: errmsg@var2264 <<@expr1073750718 "." ;
1800: reportError (@expr1073750719 tok@var2258 , severity@var2263 , "invalidScanfArgType_int" , errmsg@var2264 .@expr1073750720 str (@expr1073750721 ) , CWE686@var2030 , Certainty ::@expr1073750722 normal ) ;
1801: }
1802: void CheckIO :: invalidScanfArgTypeError_float ( const Token * tok@var2265 , int numFormat@var2266 , const std :: string & specifier@var2267 , const ArgumentInfo * argInfo@var2268 )
1803: {
1804: const Severity ::@expr1073750723 SeverityType severity@var2269 =@expr1073750724 getSeverity (@expr1073750725 argInfo@var2268 ) ;
1805: if (@expr1073750726 !@expr1073750727 mSettings@var29 .@expr1073750728 severity@var2349 .@expr1073750729 isEnabled (@expr1073750730 severity@var2269 ) ) {
1806: return ; }
1807: std ::@expr1073750731 ostringstream errmsg@var2270 ;
1808: errmsg@var2270 <<@expr1073750732 "%" <<@expr1073750733 specifier@var2267 <<@expr1073750734 " in format string (no. " <<@expr1073750735 numFormat@var2266 <<@expr1073750736 ") requires \'" ;
1809: if (@expr1073750737 specifier@var2267 [@expr8914 0 ] ==@expr1073750739 'l' &&@expr1073750740 specifier@var2267 [@expr1073750741 1 ] !=@expr1073750742 'l' ) {
1810: errmsg@var2270 <<@expr1073750743 "double" ; }
1811: else { if (@expr1073750744 specifier@var2267 [@expr8914 0 ] ==@expr1073750746 'L' ) {
1812: errmsg@var2270 <<@expr1073750747 "long double" ; }
1813: else {
1814: errmsg@var2270 <<@expr1073750748 "float" ; } }
1815: errmsg@var2270 <<@expr1073750749 " *\' but the argument type is " ;
1816: argumentType (@expr1073750750 errmsg@var2270 , argInfo@var2268 ) ;
1817: errmsg@var2270 <<@expr1073750751 "." ;
1818: reportError (@expr1073750752 tok@var2265 , severity@var2269 , "invalidScanfArgType_float" , errmsg@var2270 .@expr1073750753 str (@expr1073750754 ) , CWE686@var2030 , Certainty ::@expr1073750755 normal ) ;
1819: }
1820:
1821: void CheckIO :: invalidPrintfArgTypeError_s ( const Token * tok@var2271 , int numFormat@var2272 , const ArgumentInfo * argInfo@var2273 )
1822: {
1823: const Severity ::@expr1073750756 SeverityType severity@var2274 =@expr1073750757 getSeverity (@expr1073750758 argInfo@var2273 ) ;
1824: if (@expr1073750759 !@expr1073750760 mSettings@var29 .@expr1073750761 severity@var2349 .@expr1073750762 isEnabled (@expr1073750763 severity@var2274 ) ) {
1825: return ; }
1826: std ::@expr1073750764 ostringstream errmsg@var2275 ;
1827: errmsg@var2275 <<@expr1073750765 "%s in format string (no. " <<@expr1073750766 numFormat@var2272 <<@expr1073750767 ") requires \'char *\' but the argument type is " ;
1828: argumentType (@expr1073750768 errmsg@var2275 , argInfo@var2273 ) ;
1829: errmsg@var2275 <<@expr1073750769 "." ;
1830: reportError (@expr1073750770 tok@var2271 , severity@var2274 , "invalidPrintfArgType_s" , errmsg@var2275 .@expr1073750771 str (@expr1073750772 ) , CWE686@var2030 , Certainty ::@expr1073750773 normal ) ;
1831: }
1832: void CheckIO :: invalidPrintfArgTypeError_n ( const Token * tok@var2276 , int numFormat@var2277 , const ArgumentInfo * argInfo@var2278 )
1833: {
1834: const Severity ::@expr1073750774 SeverityType severity@var2279 =@expr1073750775 getSeverity (@expr1073750776 argInfo@var2278 ) ;
1835: if (@expr1073750777 !@expr1073750778 mSettings@var29 .@expr1073750779 severity@var2349 .@expr1073750780 isEnabled (@expr1073750781 severity@var2279 ) ) {
1836: return ; }
1837: std ::@expr1073750782 ostringstream errmsg@var2280 ;
1838: errmsg@var2280 <<@expr1073750783 "%n in format string (no. " <<@expr1073750784 numFormat@var2277 <<@expr1073750785 ") requires \'int *\' but the argument type is " ;
1839: argumentType (@expr1073750786 errmsg@var2280 , argInfo@var2278 ) ;
1840: errmsg@var2280 <<@expr1073750787 "." ;
1841: reportError (@expr1073750788 tok@var2276 , severity@var2279 , "invalidPrintfArgType_n" , errmsg@var2280 .@expr1073750789 str (@expr1073750790 ) , CWE686@var2030 , Certainty ::@expr1073750791 normal ) ;
1842: }
1843: void CheckIO :: invalidPrintfArgTypeError_p ( const Token * tok@var2281 , int numFormat@var2282 , const ArgumentInfo * argInfo@var2283 )
1844: {
1845: const Severity ::@expr1073750792 SeverityType severity@var2284 =@expr1073750793 getSeverity (@expr1073750794 argInfo@var2283 ) ;
1846: if (@expr1073750795 !@expr1073750796 mSettings@var29 .@expr1073750797 severity@var2349 .@expr1073750798 isEnabled (@expr1073750799 severity@var2284 ) ) {
1847: return ; }
1848: std ::@expr1073750800 ostringstream errmsg@var2285 ;
1849: errmsg@var2285 <<@expr1073750801 "%p in format string (no. " <<@expr1073750802 numFormat@var2282 <<@expr1073750803 ") requires an address but the argument type is " ;
1850: argumentType (@expr1073750804 errmsg@var2285 , argInfo@var2283 ) ;
1851: errmsg@var2285 <<@expr1073750805 "." ;
1852: reportError (@expr1073750806 tok@var2281 , severity@var2284 , "invalidPrintfArgType_p" , errmsg@var2285 .@expr1073750807 str (@expr1073750808 ) , CWE686@var2030 , Certainty ::@expr1073750809 normal ) ;
1853: }
1854: static void printfFormatType ( std :: ostream & os@var2286 , const std :: string & specifier@var2287 , bool isUnsigned@var2288 )
1855: {
1856: os@var2286 <<@expr8987 "\'" ;
1857: if (@expr1073750812 specifier@var2287 [@expr8989 0 ] ==@expr1073750814 'l' ) {
1858: if (@expr1073750815 specifier@var2287 [@expr8992 1 ] ==@expr1073750817 'l' ) {
1859: os@var2286 <<@expr8994 (@expr1073750819 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr8998 "long long" ; }
1860: else {
1861: os@var2286 <<@expr8994 (@expr1073750824 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750827 "long" ; }
1862: } else { if (@expr1073750828 specifier@var2287 [@expr8989 0 ] ==@expr1073750830 'h' ) {
1863: if (@expr1073750831 specifier@var2287 [@expr8992 1 ] ==@expr1073750833 'h' ) {
1864: os@var2286 <<@expr8994 (@expr1073750835 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750838 "char" ; }
1865: else {
1866: os@var2286 <<@expr8994 (@expr1073750840 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750843 "short" ; }
1867: } else { if (@expr1073750844 specifier@var2287 .@expr9021 find (@expr1073750846 "I32" ) !=@expr1073750847 std ::@expr9024 string ::@expr9025 npos@expr8986 ) {
1868: os@var2286 <<@expr8994 (@expr1073750851 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750854 "__int32" ;
1869: } else { if (@expr1073750855 specifier@var2287 .@expr9021 find (@expr1073750857 "I64" ) !=@expr1073750858 std ::@expr9024 string ::@expr9025 npos@expr8986 ) {
1870: os@var2286 <<@expr8994 (@expr1073750862 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750865 "__int64" ;
1871: } else { if (@expr1073750866 specifier@var2287 [@expr8989 0 ] ==@expr1073750868 'I' ) {
1872: os@var2286 <<@expr1073750869 (@expr1073750870 isUnsigned@var2288 ?@expr1073750871 "size_t" :@expr1073750872 "ptrdiff_t" ) ;
1873: } else { if (@expr1073750873 specifier@var2287 [@expr8989 0 ] ==@expr1073750875 'j' ) {
1874: if (@expr1073750876 isUnsigned@var2288 ) {
1875: os@var2286 <<@expr1073750877 "uintmax_t" ; }
1876: else {
1877: os@var2286 <<@expr1073750878 "intmax_t" ; }
1878: } else { if (@expr1073750879 specifier@var2287 [@expr8989 0 ] ==@expr1073750881 'z' ) {
1879: if (@expr1073750882 specifier@var2287 [@expr8992 1 ] ==@expr1073750884 'd' ||@expr1073750885 specifier@var2287 [@expr8992 1 ] ==@expr1073750887 'i' ) {
1880: os@var2286 <<@expr1073750888 "ssize_t" ; }
1881: else {
1882: os@var2286 <<@expr1073750889 "size_t" ; }
1883: } else { if (@expr1073750890 specifier@var2287 [@expr8989 0 ] ==@expr1073750892 't' ) {
1884: os@var2286 <<@expr8994 (@expr1073750894 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750897 "ptrdiff_t" ;
1885: } else { if (@expr1073750898 specifier@var2287 [@expr8989 0 ] ==@expr1073750900 'L' ) {
1886: os@var2286 <<@expr8994 (@expr1073750902 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr8998 "long long" ;
1887: } else {
1888: os@var2286 <<@expr8994 (@expr1073750907 isUnsigned@var2288 ?@expr8996 "unsigned " :@expr8997 "" ) <<@expr1073750910 "int" ;
1889: } } } } } } } } }
1890: os@var2286 <<@expr8987 "\'" ;
1891: }
1892:
1893: void CheckIO :: invalidPrintfArgTypeError_uint ( const Token * tok@var2289 , int numFormat@var2290 , const std :: string & specifier@var2291 , const ArgumentInfo * argInfo@var2292 )
1894: {
1895: const Severity ::@expr1073750912 SeverityType severity@var2293 =@expr1073750913 getSeverity (@expr1073750914 argInfo@var2292 ) ;
1896: if (@expr1073750915 !@expr1073750916 mSettings@var29 .@expr1073750917 severity@var2349 .@expr1073750918 isEnabled (@expr1073750919 severity@var2293 ) ) {
1897: return ; }
1898: std ::@expr1073750920 ostringstream errmsg@var2294 ;
1899: errmsg@var2294 <<@expr1073750921 "%" <<@expr1073750922 specifier@var2291 <<@expr1073750923 " in format string (no. " <<@expr1073750924 numFormat@var2290 <<@expr1073750925 ") requires " ;
1900: printfFormatType (@expr1073750926 errmsg@var2294 , specifier@var2291 , true ) ;
1901: errmsg@var2294 <<@expr1073750927 " but the argument type is " ;
1902: argumentType (@expr1073750928 errmsg@var2294 , argInfo@var2292 ) ;
1903: errmsg@var2294 <<@expr1073750929 "." ;
1904: reportError (@expr1073750930 tok@var2289 , severity@var2293 , "invalidPrintfArgType_uint" , errmsg@var2294 .@expr1073750931 str (@expr1073750932 ) , CWE686@var2030 , Certainty ::@expr1073750933 normal ) ;
1905: }
1906:
1907: void CheckIO :: invalidPrintfArgTypeError_sint ( const Token * tok@var2295 , int numFormat@var2296 , const std :: string & specifier@var2297 , const ArgumentInfo * argInfo@var2298 )
1908: {
1909: const Severity ::@expr1073750934 SeverityType severity@var2299 =@expr1073750935 getSeverity (@expr1073750936 argInfo@var2298 ) ;
1910: if (@expr1073750937 !@expr1073750938 mSettings@var29 .@expr1073750939 severity@var2349 .@expr1073750940 isEnabled (@expr1073750941 severity@var2299 ) ) {
1911: return ; }
1912: std ::@expr1073750942 ostringstream errmsg@var2300 ;
1913: errmsg@var2300 <<@expr1073750943 "%" <<@expr1073750944 specifier@var2297 <<@expr1073750945 " in format string (no. " <<@expr1073750946 numFormat@var2296 <<@expr1073750947 ") requires " ;
1914: printfFormatType (@expr1073750948 errmsg@var2300 , specifier@var2297 , false ) ;
1915: errmsg@var2300 <<@expr1073750949 " but the argument type is " ;
1916: argumentType (@expr1073750950 errmsg@var2300 , argInfo@var2298 ) ;
1917: errmsg@var2300 <<@expr1073750951 "." ;
1918: reportError (@expr1073750952 tok@var2295 , severity@var2299 , "invalidPrintfArgType_sint" , errmsg@var2300 .@expr1073750953 str (@expr1073750954 ) , CWE686@var2030 , Certainty ::@expr1073750955 normal ) ;
1919: }
1920: void CheckIO :: invalidPrintfArgTypeError_float ( const Token * tok@var2301 , int numFormat@var2302 , const std :: string & specifier@var2303 , const ArgumentInfo * argInfo@var2304 )
1921: {
1922: const Severity ::@expr1073750956 SeverityType severity@var2305 =@expr1073750957 getSeverity (@expr1073750958 argInfo@var2304 ) ;
1923: if (@expr1073750959 !@expr1073750960 mSettings@var29 .@expr1073750961 severity@var2349 .@expr1073750962 isEnabled (@expr1073750963 severity@var2305 ) ) {
1924: return ; }
1925: std ::@expr1073750964 ostringstream errmsg@var2306 ;
1926: errmsg@var2306 <<@expr1073750965 "%" <<@expr1073750966 specifier@var2303 <<@expr1073750967 " in format string (no. " <<@expr1073750968 numFormat@var2302 <<@expr1073750969 ") requires \'" ;
1927: if (@expr1073750970 specifier@var2303 [@expr1073750971 0 ] ==@expr1073750972 'L' ) {
1928: errmsg@var2306 <<@expr1073750973 "long " ; }
1929: errmsg@var2306 <<@expr1073750974 "double\' but the argument type is " ;
1930: argumentType (@expr1073750975 errmsg@var2306 , argInfo@var2304 ) ;
1931: errmsg@var2306 <<@expr1073750976 "." ;
1932: reportError (@expr1073750977 tok@var2301 , severity@var2305 , "invalidPrintfArgType_float" , errmsg@var2306 .@expr1073750978 str (@expr1073750979 ) , CWE686@var2030 , Certainty ::@expr1073750980 normal ) ;
1933: }
1934:
1935: Severity :: SeverityType CheckIO :: getSeverity ( const CheckIO :: ArgumentInfo * argInfo@var2307 )
1936: {
1937: return (@expr1073750981 argInfo@var2307 &&@expr1073750982 argInfo@var2307 .@expr9159 typeToken@var2308 &&@expr1073750984 !@expr1073750985 argInfo@var2307 .@expr9159 typeToken@var2308 .@expr1073750987 originalName (@expr1073750988 ) .@expr1073750989 empty (@expr1073750990 ) ) ?@expr1073750991 Severity ::@expr1073750992 portability :@expr1073750993 Severity ::@expr1073750994 warning ;
1938: }
1939:
1940: void CheckIO :: argumentType ( std :: ostream & os@var2309 , const ArgumentInfo * argInfo@var2310 )
1941: {
1942: if (@expr1073750995 argInfo@var2310 ) {
1943: os@var2309 <<@expr9172 "\'" ;
1944: const Token * type@var2311 ; type@var2311 =@expr1073750997 argInfo@var2310 .@expr1073750998 typeToken@var2312 ;
1945: if (@expr1073750999 type@var2311 .@expr1073751000 tokType (@expr1073751001 ) ==@expr1073751002 Token ::@expr1073751003 eString ) {
1946: if (@expr1073751004 type@var2311 .@expr1073751005 isLong (@expr1073751006 ) ) {
1947: os@var2309 <<@expr1073751007 "const wchar_t *" ; }
1948: else {
1949: os@var2309 <<@expr1073751008 "const char *" ; }
1950: } else {
1951: if (@expr1073751009 type@var2311 .@expr9186 originalName (@expr9187 ) .@expr1073751012 empty (@expr1073751013 ) ) {
1952: if (@expr1073751014 type@var2311 .@expr9191 strAt (@expr1073751016 -1 ) ==@expr1073751017 "const" ) {
1953: os@var2309 <<@expr1073751018 "const " ; }
1954: while (@expr1073751019 Token ::@expr9196 Match (@expr1073751021 type@var2311 , "const|struct" ) ) {
1955: os@var2309 <<@expr9198 type@var2311 .@expr9199 str (@expr9200 ) <<@expr1073751025 " " ;
1956: type@var2311 =@expr1073751026 type@var2311 .@expr1073751027 next (@expr1073751028 ) ;
1957: }
1958: while (@expr1073751029 Token ::@expr9196 Match (@expr1073751031 type@var2311 , "%any% ::" ) ) {
1959: os@var2309 <<@expr9198 type@var2311 .@expr9199 str (@expr9200 ) <<@expr1073751035 "::" ;
1960: type@var2311 =@expr1073751036 type@var2311 .@expr1073751037 tokAt (@expr1073751038 2 ) ;
1961: }
1962: os@var2309 <<@expr1073751039 type@var2311 .@expr9216 stringify (@expr9217 false , true , false ) ;
1963: if (@expr1073751042 type@var2311 .@expr9191 strAt (@expr9220 1 ) ==@expr9221 "*" &&@expr1073751046 !@expr9223 argInfo@var2310 .@expr9224 element@var2313 ) {
1964: os@var2309 <<@expr9225 " *" ; }
1965: else { if (@expr1073751050 argInfo@var2310 .@expr9227 variableInfo@var2314 &&@expr1073751052 !@expr9223 argInfo@var2310 .@expr9224 element@var2313 &&@expr1073751055 argInfo@var2310 .@expr9227 variableInfo@var2314 .@expr9233 isArray (@expr9234 ) ) {
1966: os@var2309 <<@expr9225 " *" ; }
1967: else { if (@expr1073751060 type@var2311 .@expr9191 strAt (@expr9220 1 ) ==@expr9221 "*" &&@expr1073751064 argInfo@var2310 .@expr9227 variableInfo@var2314 &&@expr1073751066 argInfo@var2310 .@expr9224 element@var2313 &&@expr1073751068 argInfo@var2310 .@expr9227 variableInfo@var2314 .@expr9233 isArray (@expr9234 ) ) {
1968: os@var2309 <<@expr9225 " *" ; } } }
1969: if (@expr1073751073 argInfo@var2310 .@expr9250 address@var2315 ) {
1970: os@var2309 <<@expr9225 " *" ; }
1971: } else {
1972: if (@expr1073751076 type@var2311 .@expr1073751077 isUnsigned (@expr1073751078 ) ) {
1973: if (@expr1073751079 type@var2311 .@expr9186 originalName (@expr9187 ) ==@expr1073751082 "__int64" ||@expr1073751083 type@var2311 .@expr9186 originalName (@expr9187 ) ==@expr1073751086 "__int32" ||@expr1073751087 type@var2311 .@expr9186 originalName (@expr9187 ) ==@expr1073751090 "ptrdiff_t" ) {
1974: os@var2309 <<@expr1073751091 "unsigned " ; }
1975: }
1976: os@var2309 <<@expr1073751092 type@var2311 .@expr9186 originalName (@expr9187 ) ;
1977: if (@expr9271 type@var2311 .@expr9191 strAt (@expr9220 1 ) ==@expr9221 "*" ||@expr9275 argInfo@var2310 .@expr9250 address@var2315 ) {
1978: os@var2309 <<@expr9225 " *" ; }
1979: os@var2309 <<@expr1073751102 " {aka " <<@expr1073751103 type@var2311 .@expr9216 stringify (@expr9217 false , true , false ) ;
1980: if (@expr9271 type@var2311 .@expr9191 strAt (@expr9220 1 ) ==@expr9221 "*" ||@expr9275 argInfo@var2310 .@expr9250 address@var2315 ) {
1981: os@var2309 <<@expr9225 " *" ; }
1982: os@var2309 <<@expr1073751113 "}" ;
1983: }
1984: }
1985: os@var2309 <<@expr9172 "\'" ;
1986: } else {
1987: os@var2309 <<@expr1073751115 "Unknown" ; }
1988: }
1989:
1990: void CheckIO :: invalidLengthModifierError ( const Token * tok@var2316 , int numFormat@var2317 , const std :: string & modifier@var2318 )
1991: {
1992: if (@expr1073751116 !@expr1073751117 mSettings@var29 .@expr1073751118 severity@var2349 .@expr1073751119 isEnabled (@expr1073751120 Severity ::@expr9297 warning ) ) {
1993: return ; }
1994: std ::@expr1073751122 ostringstream errmsg@var2319 ;
1995: errmsg@var2319 <<@expr1073751123 "'" <<@expr1073751124 modifier@var2318 <<@expr1073751125 "' in format string (no. " <<@expr1073751126 numFormat@var2317 <<@expr1073751127 ") is a length modifier and cannot be used without a conversion specifier." ;
1996: reportError (@expr1073751128 tok@var2316 , Severity ::@expr9297 warning , "invalidLengthModifierError" , errmsg@var2319 .@expr1073751130 str (@expr1073751131 ) , CWE704@var2032 , Certainty ::@expr1073751132 normal ) ;
1997: }
1998:
1999: void CheckIO :: invalidScanfFormatWidthError ( const Token * tok@var2320 , int numFormat@var2321 , int width@var2322 , const Variable * var@var2323 , const std :: string & specifier@var2324 )
2000: {
2001: long long arrlen@var2325 ; arrlen@var2325 =@expr1073751133 0 ;
2002: std ::@expr1073751134 string varname@var2326 ;
2003:
2004: if (@expr1073751135 var@var2323 ) {
2005: arrlen@var2325 =@expr1073751136 var@var2323 .@expr1073751137 dimension (@expr1073751138 0 ) ;
2006: varname@var2326 =@expr1073751139 var@var2323 .@expr1073751140 name (@expr1073751141 ) ;
2007: }
2008:
2009: std ::@expr1073751142 ostringstream errmsg@var2327 ;
2010: if (@expr1073751143 arrlen@var2325 >@expr1073751144 width@var2322 ) {
2011: if (@expr1073751145 tok@var2320 !=@expr1073751146 nullptr &&@expr1073751147 (@expr1073751148 !@expr1073751149 mSettings@var29 .@expr1073751150 certainty@var2351 .@expr1073751151 isEnabled (@expr1073751152 Certainty ::@expr9329 inconclusive ) ||@expr1073751154 !@expr1073751155 mSettings@var29 .@expr1073751156 severity@var2349 .@expr1073751157 isEnabled (@expr1073751158 Severity ::@expr9335 warning ) ) ) {
2012: return ; }
2013: errmsg@var2327 <<@expr9336 "Width " <<@expr9337 width@var2322 <<@expr9338 " given in format string (no. " <<@expr9339 numFormat@var2321 <<@expr1073751164 ") is smaller than destination buffer"
2014: <<@expr1073751165 " '" <<@expr1073751166 varname@var2326 <<@expr1073751167 "[" <<@expr1073751168 arrlen@var2325 <<@expr1073751169 "]'." ;
2015: reportError (@expr1073751170 tok@var2320 , Severity ::@expr9335 warning , "invalidScanfFormatWidth_smaller" , errmsg@var2327 .@expr9348 str (@expr9349 ) , CWE (@expr1073751174 0U ) , Certainty ::@expr9329 inconclusive ) ;
2016: } else {
2017: errmsg@var2327 <<@expr9336 "Width " <<@expr9337 width@var2322 <<@expr9338 " given in format string (no. " <<@expr9339 numFormat@var2321 <<@expr1073751180 ") is larger than destination buffer '"
2018: <<@expr1073751181 varname@var2326 <<@expr1073751182 "[" <<@expr1073751183 arrlen@var2325 <<@expr1073751184 "]', use %" <<@expr1073751185 (@expr1073751186 specifier@var2324 ==@expr1073751187 "c" ?@expr1073751188 arrlen@var2325 :@expr1073751189 (@expr1073751190 arrlen@var2325 -@expr1073751191 1 ) ) <<@expr1073751192 specifier@var2324 <<@expr1073751193 " to prevent overflowing it." ;
2019: reportError (@expr1073751194 tok@var2320 , Severity ::@expr1073751195 error , "invalidScanfFormatWidth" , errmsg@var2327 .@expr9348 str (@expr9349 ) , CWE687@var2031 , Certainty ::@expr1073751198 normal ) ;
2020: }
2021: }

##file cppcheck-2.8/lib/settings.h

9:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2328 ; mFlags@var2328 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2328 ;
54: }
55: void clear ( ) {
56: mFlags@var2328 =@expr1073751199 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2328 =@expr1073751200 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2329 ) {
62: if (@expr1073751201 enabled@var2329 ) {
63: fill (@expr1073751202 ) ; }
64: else {
65: clear (@expr1073751203 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2330 ) const {
68: return (@expr9380 mFlags@var2328 &@expr1073751205 (@expr9380 1U <<@expr1073751207 (@expr1073751208 uint32_t ) flag@var2330 ) ) !=@expr1073751209 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2331 ) {
71: mFlags@var2328 |=@expr1073751210 (@expr1073751211 1U <<@expr1073751212 (@expr1073751213 uint32_t ) flag@var2331 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2332 ) {
74: mFlags@var2328 &=@expr1073751214 ~@expr1073751215 (@expr1073751216 1U <<@expr1073751217 (@expr1073751218 uint32_t ) flag@var2332 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2333 , bool enabled@var2334 ) {
77: if (@expr1073751219 enabled@var2334 ) {
78: enable (@expr1073751220 flag@var2333 ) ; }
79: else {
80: disable (@expr1073751221 flag@var2333 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2335 ; mFlags@var2335 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2335 ;
54: }
55: void clear ( ) {
56: mFlags@var2335 =@expr1073751222 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2335 =@expr1073751223 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2336 ) {
62: if (@expr1073751224 enabled@var2336 ) {
63: fill (@expr1073751225 ) ; }
64: else {
65: clear (@expr1073751226 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2337 ) const {
68: return (@expr9403 mFlags@var2335 &@expr1073751228 (@expr9403 1U <<@expr1073751230 (@expr1073751231 uint32_t ) flag@var2337 ) ) !=@expr1073751232 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2338 ) {
71: mFlags@var2335 |=@expr1073751233 (@expr1073751234 1U <<@expr1073751235 (@expr1073751236 uint32_t ) flag@var2338 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2339 ) {
74: mFlags@var2335 &=@expr1073751237 ~@expr1073751238 (@expr1073751239 1U <<@expr1073751240 (@expr1073751241 uint32_t ) flag@var2339 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2340 , bool enabled@var2341 ) {
77: if (@expr1073751242 enabled@var2341 ) {
78: enable (@expr1073751243 flag@var2340 ) ; }
79: else {
80: disable (@expr1073751244 flag@var2340 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2342 ; mFlags@var2342 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2342 ;
54: }
55: void clear ( ) {
56: mFlags@var2342 =@expr1073751245 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2342 =@expr1073751246 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2343 ) {
62: if (@expr1073751247 enabled@var2343 ) {
63: fill (@expr1073751248 ) ; }
64: else {
65: clear (@expr1073751249 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2344 ) const {
68: return (@expr9426 mFlags@var2342 &@expr1073751251 (@expr9426 1U <<@expr1073751253 (@expr1073751254 uint32_t ) flag@var2344 ) ) !=@expr1073751255 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2345 ) {
71: mFlags@var2342 |=@expr1073751256 (@expr1073751257 1U <<@expr1073751258 (@expr1073751259 uint32_t ) flag@var2345 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2346 ) {
74: mFlags@var2342 &=@expr1073751260 ~@expr1073751261 (@expr1073751262 1U <<@expr1073751263 (@expr1073751264 uint32_t ) flag@var2346 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2347 , bool enabled@var2348 ) {
77: if (@expr1073751265 enabled@var2348 ) {
78: enable (@expr1073751266 flag@var2347 ) ; }
79: else {
80: disable (@expr1073751267 flag@var2347 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
  tok possible 0@17
Line 141
  callstack always size=1
  severity possible {2@21,1@19,symbolic=(numFormat>numFunction?Severity::error:Severity::warning)@77,5@133}
  id {"invalidScanfFormatWidth_smaller"@17,"invalidScanfFormatWidth"@19,"invalidLengthModifierError"@21,"invalidPrintfArgType_float"@39,"invalidPrintfArgType_sint"@44,"invalidPrintfArgType_uint"@49,"invalidPrintfArgType_p"@53,"invalidPrintfArgType_n"@57,"invalidPrintfArgType_s"@61,"invalidScanfArgType_float"@65}
  msg possible {"Repositioning operation performed on a file opened in append mode has no effect."@128,"Used file that is not opened."@129,"Write operation on a file that was opened only for reading."@130,"Read operation on a file that was opened only for writing."@131,"Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour."@132}
  certainty {1@17,0@19}
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 45
  ( always "IO using format string"
Line 49
  ( always "IO using format string"
Line 79
  ( always {!<=-1,!>=2}
Line 80
  ( always {!<=-1,!>=2}
Line 81
  ( always {!<=-1,!>=2}
Line 82
  ( always {!<=-1,!>=2}
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 90
  element always {!<=-1,!>=2}
Line 91
  _template always {!<=-1,!>=2}
Line 92
  address always {!<=-1,!>=2}
Line 93
  isCPP always {!<=-1,!>=2}
Line 137
  nullptr always 0
Line 139
  nullptr always 0
  "cout" always "cout"
Line 140
  nullptr always 0
  "stdin" always "stdin"
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  nullptr always 0
Line 145
  nullptr always 0
Line 146
  nullptr always 0
  "tmp" always "tmp"
Line 147
  nullptr always 0
Line 148
  nullptr always 0
  "printf" always "printf"
  3 always 3
  2 always 2
Line 149
  nullptr always 0
  1 always 1
  "s" always "s"
  nullptr always 0
Line 150
  nullptr always 0
  1 always 1
  "d" always "d"
  nullptr always 0
  false always 0
Line 151
  nullptr always 0
  1 always 1
  "f" always "f"
  nullptr always 0
Line 152
  nullptr always 0
  1 always 1
  nullptr always 0
Line 153
  nullptr always 0
  1 always 1
  nullptr always 0
Line 154
  nullptr always 0
  1 always 1
  nullptr always 0
Line 155
  nullptr always 0
  1 always 1
  "u" always "u"
  nullptr always 0
Line 156
  nullptr always 0
  1 always 1
  "i" always "i"
  nullptr always 0
Line 157
  nullptr always 0
  1 always 1
  "f" always "f"
  nullptr always 0
Line 158
  nullptr always 0
  1 always 1
  "I" always "I"
Line 159
  nullptr always 0
  10 always 10
  5 always 5
  nullptr always 0
  "s" always "s"
Line 160
  nullptr always 0
  99 always 99
  -1 always -1
  nullptr always 0
  "s" always "s"
Line 161
  nullptr always 0
  "printf" always "printf"
  2 always 2
  1 always 1
Line 165
  "IO using format string" always "IO using format string"
Line 169
  "Check format string input/output operations.\n- Bad usage of the function 'sprintf' (overlapping data)\n- Missing or wrong width specifiers in 'scanf' format string\n- Use a file that has been closed\n- File input/output without positioning results in undefined behaviour\n- Read to a file that has only been opened for writing (or vice versa)\n- Repositioning operation on a file opened in append mode\n- The same file can't be open for read and write at the same time on different streams\n- Using fflush() on an input stream\n- Invalid usage of output stream. For example: 'std::cout << std::cout;'\n- Wrong number of arguments given to 'printf' or 'scanf;'\n" always "Check format string input/output operations.\n- Bad usage of the function 'sprintf' (overlapping data)\n- Missing or wrong width specifiers in 'scanf' format string\n- Use a file that has been closed\n- File input/output without positioning results in undefined behaviour\n- Read to a file that has only been opened for writing (or vice versa)\n- Repositioning operation on a file opened in append mode\n- The same file can't be open for read and write at the same time on different streams\n- Using fflush() on an input stream\n- Invalid usage of output stream. For example: 'std::cout << std::cout;'\n- Wrong number of arguments given to 'printf' or 'scanf;'\n"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@36641,34@36897}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@143,34@144}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@143,""@144,""@145,"U"@146,"U"@147,"u"@148,"u"@149,"u8"@150,"u8"@151}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@30,34@31}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@27,34@29}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@233,128@234,64@235,32@236,16@237,8@238,4@239,2@240,1@241}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@242,128@243,64@244,32@245,16@246,8@247,4@248,2@249,1@250}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@242,4294967167@243,4294967231@244,4294967263@245,4294967279@246,4294967287@247,4294967291@248,4294967293@249,4294967294@250}
  flag {!<=-1,256@242,128@243,64@244,32@245,16@246,8@247,4@248,2@249,1@250}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pattern possible {"> ("@151,"swprintf ("@95,"FILE *"@141}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {6@146,10@132,4@133,0@134}
  t possible {6@146,10@132,4@133,0@134}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {6@146,10@132,4@133,0@134}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,6@146,10@132,0@134}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,6@146,10@132,0@134}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,6@146,10@132}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,6@146,10@132}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,6@146,10@132}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,6@146,10@132}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,0@146,1@132}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign {!<=-1,!>=2,1@142}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign {!<=-1,!>=2,1@143}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size {!<=-1,!>=2,1@139}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@140}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@142,17179869184@153,8589934592@155,34359738368@157,4294967296@159,2147483648@161,1073741824@163,536870912@165,268435456@167}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@229,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@230}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@141,17179869184@152,8589934592@154,34359738368@156,4294967296@158,2147483648@160,1073741824@162,536870912@164,268435456@166}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@141,17179869184@152,8589934592@154,34359738368@156,4294967296@158,2147483648@160,1073741824@162,536870912@164,268435456@166}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@75,4096@78,16384@81,2048@82,1024@83,65536@84,512@85,256@86,128@87}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 550
  index_ possible 0@13
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  index_ possible 0@111
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@40,4194304@42,8388608@43,2097152@45,1048576@46,524288@47,262144@48,131072@49,65536@50}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@18,2097152@19,1048576@20,524288@21,262144@22,131072@23,65536@24,32768@25,16384@26}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@18,4292870143@19,4293918719@20,4294443007@21,4294705151@22,4294836223@23,4294901759@24,4294934527@25,4294950911@26}
  flag {!<=-1,8388608@18,2097152@19,1048576@20,524288@21,262144@22,131072@23,65536@24,32768@25,16384@26}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 50
  119U always 119
Line 51
  398U always 398
Line 52
  664U always 664
Line 53
  685U always 685
Line 54
  686U always 686
Line 55
  687U always 687
Line 56
  704U always 704
Line 57
  910U always 910
Line 64
  ( always {!<=-1,!>=2}
Line 68
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 69
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  = possible symbolic=(tok->next()->astParent()->astOperand1())
  ( possible symbolic=(tok->next()->astParent()->astOperand1())
Line 70
  ( always {!<=-1,!>=2}
  "std :: cout|cerr !!." always "std :: cout|cerr !!."
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 71
  = always symbolic=(tok->next()->astParent()->astOperand1())
  ( always symbolic=(tok->next()->astParent()->astOperand1())
Line 72
  tok2 possible {symbolic=(tok->next()),symbolic=(tok->next()->astParent()->astOperand1())}
  && always {!<=-1,!>=2}
  tok2 possible symbolic=(tok->next())
  ( always !0
  == always {!<=-1,!>=2}
  "<<" always "<<"
Line 73
  = always !0
  ( always !0
Line 74
  tok2 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  "std :: cout|cerr" always "std :: cout|cerr"
Line 75
  tok2 always !0
  ( always !0
  1 always 1
Line 84
  tok possible 0@36
  :: always 1
  error always 1
  "coutCerrMisusage" always "coutCerrMisusage"
  "Invalid usage of output stream: '<< std::" always "Invalid usage of output stream: '<< std::"
  streamName possible "cout"@36
  "'." always "'."
  :: always 0
  normal always 0
Line 93
  CLOSED always 0
  READ_MODE always 1
  WRITE_MODE always 2
  RW_MODE always 3
  UNKNOWN_OM always 4
Line 96
  ( always !<=-1
  '+' always 43
  1 always 1
  != always {!<=-1,!>=2}
Line 97
  :: always 3
  RW_MODE always 3
Line 98
  ( always !<=-1
  'w' always 119
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !<=-1
  'a' always 97
  != always {!<=-1,!>=2}
Line 99
  :: always 2
  WRITE_MODE always 2
Line 100
  ( always !<=-1
  'r' always 114
  != always {!<=-1,!>=2}
Line 101
  :: always 1
  READ_MODE always 1
Line 102
  :: always 4
  UNKNOWN_OM always 4
Line 108
  NONE always 0
  UNIMPORTANT always 1
  READ always 2
  WRITE always 3
  POSITIONING always 4
  OPEN always 5
  CLOSE always 6
  UNKNOWN_OP always 7
Line 110
  UNKNOWN_AM always 0
  APPEND always 1
  APPEND_EX always 2
Line 113
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 114
  0 always 0
  0 always 0
Line 118
  "clearerr" always "clearerr"
  "feof" always "feof"
  "ferror" always "ferror"
  "fgetpos" always "fgetpos"
  "ftell" always "ftell"
  "setbuf" always "setbuf"
  "setvbuf" always "setvbuf"
  "ungetc" always "ungetc"
  "ungetwc" always "ungetwc"
Line 123
  windows always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 124
  printPortability always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 125
  printWarnings always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 130
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 131
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "FILE *" always "FILE *"
Line 134
  var always !0
  ( always {!<=-1,!>=2}
Line 135
  var always !0
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
Line 136
  var always !0
  ( always !0
  :: always 4
  UNKNOWN_OM always 4
Line 138
  var always !0
  ( always !0
  :: always 0
  CLOSED always 0
Line 140
  var always !0
  ( always !0
  :: always 4
  UNKNOWN_OM always 4
Line 146
  = always 0
  0 always 0
Line 147
  != always {!<=-1,!>=2}
Line 148
  ( possible {size=1,size=6,size=8,size=5,size=7,size=9,size=4,size=10}
  == {!<=-1,!>=2,0}
  "{" always "{"
Line 150
  ( possible {size=6,size=8,size=5,size=7,size=9,size=4,size=10}
  == {!<=-1,!>=2,0}
  "}" always "}"
Line 153
  < always {!<=-1,!>=2}
Line 154
  = always 0
  0 always 0
Line 155
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 157
  < always {!<=-1,!>=2}
Line 158
  = always 0
  0 always 0
Line 159
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 162
  ( possible {size=8,size=5,size=7,size=9,size=6,size=4,size=10}
  == {!<=-1,!>=2,0}
  "return" always "return"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "continue" always "continue"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "break" always "break"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 164
  = always 0
  0 always 0
Line 165
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 166
  = always 0
  0 always 0
Line 167
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 169
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
  && always {!<=-1,!>=2}
Line 170
  2 always 2
  != always {!<=-1,!>=2}
  "fopen" always "fopen"
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  "freopen" always "freopen"
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  "tmpfile" always "tmpfile"
  && always {!<=-1,!>=2}
Line 171
  windows always {!<=-1,!>=2}
  ? {1,!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "_wfopen" always "_wfopen"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "_wfreopen" always "_wfreopen"
  : always 1
  true always 1
Line 172
  = possible lifetime[Iterator]=(filepointers)
  ( possible lifetime[Iterator]=(filepointers)
Line 173
  i {lifetime[Iterator]=(filepointers),symbolic=(filepointers.find(tok->varId()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filepointers),end=0}
Line 174
  i {lifetime[Iterator]=(filepointers),symbolic=(filepointers.find(tok->varId())),!symbolic=(filepointers.end()),!end=0}
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 175
  i {lifetime[Iterator]=(filepointers),symbolic=(filepointers.find(tok->varId())),!symbolic=(filepointers.end()),!end=0}
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 177
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "return|throw" always "return|throw"
Line 179
  = always 0
  nullptr always 0
Line 180
  = always 0
  nullptr always 0
Line 183
  ( possible {size=7,size=9,size=6,size=5,size=4,size=8,size=10}
  == {!<=-1,!>=2,0}
  "fopen" always "fopen"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "freopen" always "freopen"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "tmpfile" always "tmpfile"
  || always {!<=-1,!>=2}
Line 184
  windows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "_wfopen" always "_wfopen"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "_wfreopen" always "_wfreopen"
  && always {!<=-1,!>=2}
Line 185
  -1 always -1
  == always {!<=-1,!>=2}
  "=" always "="
Line 186
  != always {!<=-1,!>=2}
  "tmpfile" always "tmpfile"
Line 187
  2 always 2
Line 188
  && always {!<=-1,!>=2}
  modeTok always !0
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 189
  modeTok always !0
Line 191
  = always "wb+"
  "wb+" always "wb+"
Line 192
  -2 always -2
Line 193
  = always 5
  :: always 5
  OPEN always 5
Line 194
  ( always {!<=-1,!>=2}
  "fopen ( %str% ," always "fopen ( %str% ,"
Line 195
  2 always 2
Line 196
  windows {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "fopen_s|freopen_s|_wfopen_s|_wfreopen_s ( & %name%" always "fopen_s|freopen_s|_wfopen_s|_wfreopen_s ( & %name%"
Line 197
  2 always 2
Line 198
  && always {!<=-1,!>=2}
  modeTok always !0
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 199
  modeTok always !0
Line 200
  3 always 3
Line 201
  = always 5
  :: always 5
  OPEN always 5
Line 202
  ( possible {size=5,size=7,size=6,size=4,size=8,size=9,size=10}
  == {!<=-1,!>=2,0}
  "rewind" always "rewind"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fseek" always "fseek"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fsetpos" always "fsetpos"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fflush" always "fflush"
  || always {!<=-1,!>=2}
Line 203
  windows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "_fseeki64" always "_fseeki64"
Line 204
  2 always 2
Line 205
  printPortability always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fflush" always "fflush"
Line 206
  fileTok always !0
  == always {!<=-1,!>=2}
  "stdin" always "stdin"
Line 207
  fileTok always !0
  ( always size=5
Line 209
  fileTok always !0
Line 210
  f always {symbolic=(filepointers[fileTok->varId()]),symbolic=(f)}
  == always {!<=-1,!>=2}
  :: always 1
  READ_MODE always 1
Line 211
  fileTok always !0
Line 214
  = always 4
  :: always 4
  POSITIONING always 4
Line 215
  ( possible {size=6,size=5,size=7,size=4,size=8,size=9,size=10}
  == {!<=-1,!>=2,0}
  "fgetc" always "fgetc"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fgetwc" always "fgetwc"
  || always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  "fgets" always "fgets"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fgetws" always "fgetws"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fread" always "fread"
  || always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
  "fscanf" always "fscanf"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fwscanf" always "fwscanf"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "getc" always "getc"
  || always {!<=-1,!>=2}
Line 218
  windows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fscanf_s" always "fscanf_s"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fwscanf_s" always "fwscanf_s"
Line 219
  ( possible {size=5,size=6,size=7,size=4}
  ( always !<=-1
  "scanf" always "scanf"
  != always {!<=-1,!>=2}
Line 220
  2 always 2
Line 222
  1 always 1
Line 223
  = always 2
  :: always 2
  READ always 2
Line 224
  ( possible {size=6,size=5,size=7,size=8,size=9,size=10}
  == {!<=-1,!>=2,0}
  "fputc" always "fputc"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fputwc" always "fputwc"
  || always {!<=-1,!>=2}
Line 225
  == always {!<=-1,!>=2}
  "fputs" always "fputs"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fputws" always "fputws"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fwrite" always "fwrite"
  || always {!<=-1,!>=2}
Line 226
  == always {!<=-1,!>=2}
  "fprintf" always "fprintf"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fwprintf" always "fwprintf"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "putcc" always "putcc"
  || always {!<=-1,!>=2}
Line 227
  windows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fprintf_s" always "fprintf_s"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "fwprintf_s" always "fwprintf_s"
Line 228
  ( possible {size=5,size=6,size=7,size=8}
  ( always !<=-1
  "printf" always "printf"
  != always {!<=-1,!>=2}
Line 229
  2 always 2
Line 231
  1 always 1
Line 232
  = always 3
  :: always 3
  WRITE always 3
Line 233
  == always {!<=-1,!>=2}
  "fclose" always "fclose"
Line 234
  2 always 2
Line 235
  = always 6
  :: always 6
  CLOSE always 6
Line 236
  ( possible lifetime[Iterator]=(whitelist)
  ( possible {size=6,size=7}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(whitelist),end=0}
Line 237
  2 always 2
Line 238
  ( possible size=7
  == {!<=-1,!>=2,0}
  "ungetc" always "ungetc"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "ungetwc" always "ungetwc"
  && always {!<=-1,!>=2}
Line 239
  fileTok always !0
Line 240
  = always 1
  :: always 1
  UNIMPORTANT always 1
Line 241
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|for|while|catch|switch" always "if|for|while|catch|switch"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 242
  1 always 1
Line 243
  && always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "this" always "this"
Line 244
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 247
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 248
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 249
  = always 0
  0 always 0
Line 251
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 257
  2 always 2
  != always {!<=-1,!>=2}
Line 258
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(filepointers)
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filepointers),end=0}
Line 260
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 266
  ( always {!<=-1,!>=2}
  fileTok possible {symbolic=(tok2),0}
  "%name% ." always "%name% ."
Line 267
  2 always 2
Line 269
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  fileTok always !0
  || always {!<=-1,!>=2}
  fileTok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 272
  ( possible lifetime[Iterator]=(filepointers)
  fileTok always !0
  ( always !0
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filepointers),end=0}
Line 273
  fileTok always !0
  :: always 4
  UNKNOWN_OM always 4
Line 276
  fileTok always !0
Line 278
  operation possible {symbolic=(Filepointer::Operation::NONE),1}
Line 279
  :: always 5
  OPEN always 5
Line 281
  = {lifetime[Iterator]=(filepointers),start=0}
  ( {lifetime[Iterator]=(filepointers),start=0}
  it possible {lifetime[Iterator]=(filepointers),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filepointers),end=0}
  it possible lifetime[Iterator]=(filepointers)
Line 282
  it {lifetime[Iterator]=(filepointers),!symbolic=(filepointers.cend()),!end=0}
Line 283
  fptr always symbolic=(it->second)
  == always {!<=-1,!>=2}
  fileNameTok always !0
  && always {!<=-1,!>=2}
  fptr always symbolic=(it->second)
  == always {!<=-1,!>=2}
  :: always 3
  RW_MODE always 3
  || always {!<=-1,!>=2}
  fptr always symbolic=(it->second)
  . always !3
  == always {!<=-1,!>=2}
  :: always 2
  WRITE_MODE always 2
Line 284
  fileNameTok always !0
Line 287
  fileNameTok always !0
Line 291
  ( always !<=-1
  'a' always 97
  != always {!<=-1,!>=2}
Line 292
  == always {!<=-1,!>=2}
  :: always 3
  RW_MODE always 3
Line 293
  = always 2
  :: always 2
  APPEND_EX always 2
Line 295
  = always 1
  :: always 1
  APPEND always 1
Line 300
  :: always 4
  POSITIONING always 4
Line 301
  == always {!<=-1,!>=2}
  :: always 0
  CLOSED always 0
Line 303
  == always {!<=-1,!>=2}
  :: always 1
  APPEND always 1
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "fflush" always "fflush"
  && always {!<=-1,!>=2}
  printWarnings always {!<=-1,!>=2}
Line 306
  :: always 2
  READ always 2
Line 307
  . possible 2
  == {!<=-1,!>=2,0}
  :: always 0
  CLOSED always 0
Line 309
  . always !0
  == always {!<=-1,!>=2}
  :: always 2
  WRITE_MODE always 2
Line 311
  == always {!<=-1,!>=2}
  :: always 3
  WRITE always 3
Line 314
  :: always 3
  WRITE always 3
Line 315
  . possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  CLOSED always 0
Line 317
  . always !0
  == always {!<=-1,!>=2}
  :: always 1
  READ_MODE always 1
Line 319
  == always {!<=-1,!>=2}
  :: always 2
  READ always 2
Line 322
  :: always 6
  CLOSE always 6
Line 323
  == always {!<=-1,!>=2}
  :: always 0
  CLOSED always 0
Line 326
  = always 0
  :: always 0
  CLOSED always 0
Line 329
  :: always 1
  UNIMPORTANT always 1
Line 330
  == always {!<=-1,!>=2}
  :: always 0
  CLOSED always 0
Line 333
  :: always 7
  UNKNOWN_OP always 7
Line 334
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 335
  = always 0
  0 always 0
Line 340
  operation possible 1
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  operation always !symbolic=(Filepointer::Operation::NONE)
  != always {!<=-1,!>=2}
  :: always 1
  UNIMPORTANT always 1
Line 342
  = always {!symbolic=(Filepointer::Operation::NONE),!1}
  operation always {!symbolic=(Filepointer::Operation::NONE),!1}
Line 347
  = always 0
  0 always 0
Line 348
  = always 4
  :: always 4
  UNKNOWN_OM always 4
Line 349
  = always 7
  :: always 7
  UNKNOWN_OP always 7
Line 356
  tok possible 0@37
  :: always 5
  portability always 5
Line 357
  "fflushOnInputStream" always "fflushOnInputStream"
  "fflush() called on input stream '" always "fflush() called on input stream '"
  varname possible {"stdin"@37,size=5@179}
  "' may result in undefined behaviour on non-linux systems." always "' may result in undefined behaviour on non-linux systems."
  :: always 0
  normal always 0
Line 362
  tok possible 0@38
  :: always 1
  error always 1
Line 363
  "IOWithoutPositioning" always "IOWithoutPositioning"
  "Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour." always "Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour."
  :: always 0
  normal always 0
Line 368
  tok possible 0@39
  :: always 1
  error always 1
Line 369
  "readWriteOnlyFile" always "readWriteOnlyFile"
  "Read operation on a file that was opened only for writing." always "Read operation on a file that was opened only for writing."
  :: always 0
  normal always 0
Line 374
  tok possible 0@40
  :: always 1
  error always 1
Line 375
  "writeReadOnlyFile" always "writeReadOnlyFile"
  "Write operation on a file that was opened only for reading." always "Write operation on a file that was opened only for reading."
  :: always 0
  normal always 0
Line 380
  tok possible 0@41
  :: always 1
  error always 1
Line 381
  "useClosedFile" always "useClosedFile"
  "Used file that is not opened." always "Used file that is not opened."
  :: always 0
  normal always 0
Line 386
  tok possible 0@42
  :: always 2
  warning always 2
Line 387
  "seekOnAppendedFile" always "seekOnAppendedFile"
  "Repositioning operation performed on a file opened in append mode has no effect." always "Repositioning operation performed on a file opened in append mode has no effect."
  :: always 0
  normal always 0
Line 392
  tok possible 0@43
  :: always 2
  warning always 2
Line 393
  "incompatibleFileOpen" always "incompatibleFileOpen"
  "The file '" always "The file '"
  filename possible "tmp"@43
  "' is opened for read and write access at the same time on different streams" always "' is opened for read and write access at the same time on different streams"
  :: always 0
  normal always 0
Line 402
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 406
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 407
  != always {!<=-1,!>=2}
Line 408
  = always 0
  nullptr always 0
Line 409
  ( always {!<=-1,!>=2}
  "scanf|vscanf ( %str% ," always "scanf|vscanf ( %str% ,"
Line 410
  2 always 2
Line 411
  ( always {!<=-1,!>=2}
  "sscanf|vsscanf|fscanf|vfscanf (" always "sscanf|vsscanf|fscanf|vfscanf ("
Line 412
  2 always 2
Line 413
  && always {!<=-1,!>=2}
  nextArg always !0
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 414
  = always !0
  nextArg always !0
Line 420
  format always {!<=-1,!>=2}
  format always {!<=-1,!>=2}
  = always 0
  false always 0
Line 423
  formatToken possible symbolic=(nextArg)
Line 424
  i always !<=-1
  = always 1
  1 always 1
  i {!<=-1,1}
  < always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 425
  [ possible {42,91,115,83,108}
  i {!<=-1,<=symbolic=(formatstr.length()-1),!>=symbolic=(formatstr.length()),1}
  == {!<=-1,!>=2,0}
  '%' always 37
Line 426
  format always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  format always {!<=-1,!>=2}
Line 428
  ! always {!<=-1,!>=2}
  format always {!<=-1,!>=2}
Line 431
  ( possible 0
  [ {42,91,115,83,108,!37}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  || always {!<=-1,!>=2}
  [ always !37
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == always {!<=-1,!>=2}
  '*' always 42
Line 432
  format always {!<=-1,!>=2}
  = always 0
  false always 0
Line 435
  ( possible {0,1}
  ( {!<=-1,91,115,83,108,!37,!42}
  [ {91,115,83,108,!37,!42}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  || always {!<=-1,!>=2}
  [ always {!37,!42}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == always {!<=-1,!>=2}
  '[' always 91
Line 436
  [ {91,83,108,!37,!42}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == {!<=-1,!>=2,0}
  's' always 115
  || {!<=-1,!>=2,0,1}
  [ {83,108,!37,!42,91}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == {!<=-1,!>=2,0,1}
  '[' always 91
  || {!<=-1,!>=2,0,1}
  [ {108,!37,!42}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == {!<=-1,!>=2,0}
  'S' always 83
  || always {!<=-1,!>=2}
  [ always {!37,!42}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  == always {!<=-1,!>=2}
  'l' always 108
  && always {!<=-1,!>=2}
  i always {!<=-1,!>=symbolic=(formatstr.length())}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  's' always 115
Line 438
  format always {!<=-1,!>=2}
  = always 0
  false always 0
Line 447
  tok possible 0@44
  tok always !0
  "scanf" always "scanf"
Line 448
  tok possible 0@44
  :: always 2
  warning always 2
Line 449
  "invalidscanf" always "invalidscanf"
  "() without field width limits can crash with huge input data.\n" always "() without field width limits can crash with huge input data.\n"
Line 450
  "() without field width limits can crash with huge input data. Add a field width specifier to fix this problem.\n\nSample program that can crash:\n\n#include <stdio.h>\nint main()\n{\n    char c[5];\n    scanf(\"%s\", c);\n    return 0;\n}\n\nTyping in 5 or more characters may make the program crash. The correct usage here is 'scanf(\"%4s\", c);', as the maximum field width does not include the terminating null byte.\nSource: http://linux.die.net/man/3/scanf\nSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c" always "() without field width limits can crash with huge input data. Add a field width specifier to fix this problem.\n\nSample program that can crash:\n\n#include <stdio.h>\nint main()\n{\n    char c[5];\n    scanf(\"%s\", c);\n    return 0;\n}\n\nTyping in 5 or more characters may make the program crash. The correct usage here is 'scanf(\"%4s\", c);', as the maximum field width does not include the terminating null byte.\nSource: http://linux.die.net/man/3/scanf\nSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c"
Line 468
  :: always 0
  normal always 0
Line 477
  ( always {!<=-1,!>=2}
Line 482
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  arg possible {>=0@94,1@96,2@97,3@101}
  && always {!<=-1,!>=2}
  argTok possible symbolic=(firstArg)
Line 483
  argTok possible symbolic=(firstArg)
Line 485
  ( always {!<=-1,!>=2}
  argTok possible symbolic=(firstArg)
  "%str% [,)]" always "%str% [,)]"
Line 488
  return always {!<=-1,!>=2}
  true always 1
Line 489
  ( always {!<=-1,!>=2}
  "%var% [,)]" always "%var% [,)]"
  && always {!<=-1,!>=2}
Line 490
  && always {!<=-1,!>=2}
Line 491
  ( always {!<=-1,!>=2}
  ( always !0
  "char|wchar_t" always "char|wchar_t"
  && always {!<=-1,!>=2}
Line 492
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 493
  ( always !0
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
Line 494
  ( always !0
  ( always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 495
  ( always !0
  0 always 0
  != always {!<=-1,!>=2}
  0 always 0
Line 497
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 498
  = possible lifetime[Iterator]=(argTok->values())
  ( possible lifetime[Iterator]=(argTok->values())
Line 499
  ( always !size=0
  ( {lifetime[Iterator]=(argTok->values()),start=0}
  ( always !size=0
  ( {lifetime[Iterator]=(argTok->values()),end=0}
  & {lifetime[Address]=(isTokValue),!0}
Line 500
  != always {!<=-1,!>=2}
  ( always !size=0
  ( {lifetime[Iterator]=(argTok->values()),end=0}
  && always {!<=-1,!>=2}
  value always {!symbolic=(argTok->values().end()),!end=0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 501
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 502
  = always !0
  . always !0
Line 505
  return always {!<=-1,!>=2}
  true always 1
Line 507
  return always {!<=-1,!>=2}
  false always 0
Line 511
  ( always {!<=-1,!>=2}
  , always "std::"
  = always "std::"
  "std::" always "std::"
Line 513
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  iTypename possible {"size_t"@24,"ptrdiff_t"@26,"uintmax_t"@28,"size_t"@34,"ptrdiff_t"@36,"uintmax_t"@38,"size_t"@47,"uintmax_t"@50,"size_t"@53,"ptrdiff_t"@56}
  || always {!<=-1,!>=2}
  iToTest always !symbolic=(iTypename)
  == always {!<=-1,!>=2}
  iOptionalPrefix possible "std::"
  iTypename {!symbolic=(iToTest),"size_t"@24,"ptrdiff_t"@26,"uintmax_t"@28,"size_t"@34,"ptrdiff_t"@36,"uintmax_t"@38,"size_t"@47,"uintmax_t"@50,"size_t"@53}
Line 519
  isWindows always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 521
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 522
  != always {!<=-1,!>=2}
Line 523
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 525
  = always 0
  nullptr always 0
Line 526
  = always 0
  nullptr always 0
Line 528
  scan always {!<=-1,!>=2}
  scan always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  scanf_s always {!<=-1,!>=2}
  scanf_s always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always -1
  -1 always -1
Line 532
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 534
  scan always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 535
  scanf_s always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 538
  formatStringArgNo possible -1
  >= {!<=-1,!>=2,0}
  0 always 0
Line 540
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  formatStringArgNo {>=0,!<=-1}
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok always 0
  & {lifetime[Address]=(argListTok),!0}
  argListTok always 0
Line 542
  ( always {!<=-1,!>=2}
  "swprintf (" always "swprintf ("
Line 543
  ( always {!<=-1,!>=2}
  2 always 2
  "%str%" always "%str%"
Line 545
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok always 0
  & {lifetime[Address]=(argListTok),!0}
  argListTok always 0
Line 549
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok always 0
  & {lifetime[Address]=(argListTok),!0}
  argListTok always 0
Line 552
  isWindows {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "sprintf_s|swprintf_s (" always "sprintf_s|swprintf_s ("
Line 554
  ( always {!<=-1,!>=2}
  1 always 1
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok always 0
  & {lifetime[Address]=(argListTok),!0}
  argListTok always 0
Line 555
  ! always {!<=-1,!>=2}
Line 559
  ( always {!<=-1,!>=2}
  2 always 2
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok possible 0
  & {lifetime[Address]=(argListTok),!0}
Line 560
  ! always {!<=-1,!>=2}
Line 563
  isWindows {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "_snprintf_s|_snwprintf_s (" always "_snprintf_s|_snwprintf_s ("
Line 565
  ( always {!<=-1,!>=2}
  2 always 2
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok always 0
  & {lifetime[Address]=(argListTok),!0}
  argListTok always 0
Line 566
  ! always {!<=-1,!>=2}
Line 570
  ( always {!<=-1,!>=2}
  3 always 3
  2 always 2
  & {lifetime[Address]=(formatStringTok),!0}
  formatStringTok possible 0
  & {lifetime[Address]=(argListTok),!0}
Line 571
  ! always {!<=-1,!>=2}
Line 578
  ! always {!<=-1,!>=2}
Line 581
  formatStringTok always !0
  scan always {!<=-1,!>=2}
  scanf_s always {!<=-1,!>=2}
Line 588
  , always {!<=-1,!>=2}
Line 589
  scan always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
Line 590
  scanf_s always {!<=-1,!>=2}
Line 592
  isWindows always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 593
  printWarning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 597
  = always 0
  0 always 0
Line 598
  = always 0
  0 always 0
Line 599
  percent always {!<=-1,!>=2}
  percent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 602
  = {lifetime[Iterator]=(formatStringTok->str()),start=0}
  formatString always symbolic=(formatStringTok->str())
  ( {lifetime[Iterator]=(formatStringTok->str()),start=0}
  i possible lifetime[Iterator]=(formatStringTok->str())
  != always {!<=-1,!>=2}
  formatString possible symbolic=(formatStringTok->str())
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  i possible lifetime[Iterator]=(formatStringTok->str())
Line 603
  i possible lifetime[Iterator]=(formatStringTok->str())
  == always {!<=-1,!>=2}
  '%' always 37
Line 604
  percent always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  percent always {!<=-1,!>=2}
Line 605
  percent always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '[' always 91
Line 606
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
Line 607
  == always {!<=-1,!>=2}
  ']' always 93
Line 611
  percent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 616
  scanf_s always {!<=-1,!>=2}
Line 622
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
Line 624
  percent always {!<=-1,!>=2}
Line 625
  percent always {!<=-1,!>=2}
  = always 0
  false always 0
Line 627
  _continue always {!<=-1,!>=2}
  _continue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 628
  skip always {!<=-1,!>=2}
  skip always {!<=-1,!>=2}
  = always 0
  false always 0
Line 630
  = always 0
  0 always 0
Line 631
  hasParameterPosition always {!<=-1,!>=2}
  hasParameterPosition always {!<=-1,!>=2}
  = always 0
  false always 0
Line 632
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '[' always 91
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !<=-1
Line 633
  == always {!<=-1,!>=2}
  '*' always 42
Line 634
  skip always {!<=-1,!>=2}
  = always 1
  true always 1
Line 635
  scan always {!<=-1,!>=2}
Line 636
  _continue always {!<=-1,!>=2}
  = always 1
  true always 1
Line 644
  == always {!<=-1,!>=2}
  '$' always 36
Line 645
  ( {lifetime[Object]=(width),!0}
Line 646
  hasParameterPosition always {!<=-1,!>=2}
  = always 1
  true always 1
Line 647
  width always NonMovedVariable
Line 651
  = {lifetime[Iterator]=(formatStringTok->str()),end=0}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
Line 652
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),symbolic=(bracketBeg),end=0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '[' always 91
Line 654
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
Line 655
  == always {!<=-1,!>=2}
  ']' always 93
Line 660
  scanf_s always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  skip always {!<=-1,!>=2}
Line 667
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),symbolic=(bracketBeg),end=0}
Line 669
  _continue always {!<=-1,!>=2}
Line 672
  scan always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  'm' always 109
Line 676
  hasParameterPosition always {!<=-1,!>=2}
Line 677
  ( possible lifetime[Iterator]=(parameterPositionsUsed)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(parameterPositionsUsed),end=0}
Line 684
  ( always {!<=-1,!>=2}
Line 686
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ']' always 93
Line 687
  scan always {!<=-1,!>=2}
Line 689
  done always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 690
  ! always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
Line 692
  's' always 115
Line 693
  ']' always 93
Line 694
  == always {!<=-1,!>=2}
  's' always 115
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  's' always 115
  1 always 1
Line 695
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  0 always 0
  . always {!<=-1,!>=2}
Line 696
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 697
  ( {lifetime[Object]=(width),!0}
Line 698
  numWidth always symbolic=(std::atoi(width.c_str()))
  != always {!<=-1,!>=2}
  0 always 0
  1 always 1
Line 699
  numWidth always symbolic=(std::atoi(width.c_str()))
Line 702
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 6
  eString always 6
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 703
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 704
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|wchar_t" always "char|wchar_t"
  || always {!<=-1,!>=2}
Line 705
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 706
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 707
  & {lifetime[Address]=(argInfo),!0}
Line 709
  scanf_s always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 715
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 717
  'c' always 99
Line 718
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  0 always 0
  . always {!<=-1,!>=2}
Line 719
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 720
  ( {lifetime[Object]=(width),!0}
Line 721
  numWidth always symbolic=(std::atoi(width.c_str()))
  > always {!<=-1,!>=2}
  0 always 0
Line 722
  numWidth always symbolic=(std::atoi(width.c_str()))
  1 always 1
Line 725
  scanf_s always {!<=-1,!>=2}
Line 731
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 733
  'x' always 120
Line 734
  'X' always 88
Line 735
  'u' always 117
Line 736
  'o' always 111
Line 738
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 739
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 740
  ( always {!<=-1,!>=2}
Line 741
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|short|int|long" always "char|short|int|long"
Line 742
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 743
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 744
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 745
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 746
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 747
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 749
  0 always 0
Line 750
  'h' always 104
Line 751
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 752
  != always {!<=-1,!>=2}
  "char" always "char"
Line 753
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 754
  != always {!<=-1,!>=2}
  "short" always "short"
Line 755
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 757
  'l' always 108
Line 758
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 759
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 760
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 761
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 762
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 763
  ( always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 764
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 765
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 766
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 767
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 768
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 769
  ( always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 770
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 772
  'I' always 73
Line 773
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 774
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 775
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 776
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 777
  != always {!<=-1,!>=2}
  "int" always "int"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 778
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 779
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
Line 780
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 782
  'j' always 106
Line 783
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 784
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 786
  'z' always 122
Line 787
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
Line 788
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 790
  't' always 116
Line 791
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 792
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 794
  'L' always 76
Line 795
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 796
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 797
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 799
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 802
  != always {!<=-1,!>=2}
  "int" always "int"
Line 803
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 804
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 805
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 806
  ( always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 807
  & {lifetime[Address]=(argInfo),!0}
  true always 1
Line 812
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 814
  'n' always 110
Line 815
  'd' always 100
Line 816
  'i' always 105
Line 818
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 819
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 820
  ( always {!<=-1,!>=2}
Line 821
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|short|int|long" always "char|short|int|long"
Line 822
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 823
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 824
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 825
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 826
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 827
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 829
  0 always 0
Line 830
  'h' always 104
Line 831
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 832
  != always {!<=-1,!>=2}
  "char" always "char"
Line 833
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 834
  != always {!<=-1,!>=2}
  "short" always "short"
Line 835
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 837
  'l' always 108
Line 838
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 839
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 840
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 841
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 842
  ( always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 843
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 844
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 845
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 846
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 847
  ( always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 848
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 850
  'I' always 73
Line 851
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 852
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 853
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 854
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 855
  != always {!<=-1,!>=2}
  "int" always "int"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 856
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 857
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 858
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 860
  'j' always 106
Line 861
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 862
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 864
  'z' always 122
Line 865
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ssize_t" always "ssize_t"
  || always {!<=-1,!>=2}
Line 866
  isWindows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "SSIZE_T" always "SSIZE_T"
Line 867
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 869
  't' always 116
Line 870
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 871
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 873
  'L' always 76
Line 874
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 875
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 878
  != always {!<=-1,!>=2}
  "int" always "int"
Line 879
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 880
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 881
  == always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 882
  & {lifetime[Address]=(argInfo),!0}
  false always 0
Line 887
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 889
  'e' always 101
Line 890
  'E' always 69
Line 891
  'f' always 102
Line 892
  'g' always 103
Line 893
  'G' always 71
Line 894
  'a' always 97
Line 896
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 897
  & {lifetime[Address]=(argInfo),!0}
Line 898
  ( always {!<=-1,!>=2}
Line 899
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 900
  ( always {!<=-1,!>=2}
Line 901
  & {lifetime[Address]=(argInfo),!0}
Line 902
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 903
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 904
  & {lifetime[Address]=(argInfo),!0}
Line 906
  0 always 0
Line 907
  'l' always 108
Line 908
  != always {!<=-1,!>=2}
  "double" always "double"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 909
  & {lifetime[Address]=(argInfo),!0}
Line 911
  'L' always 76
Line 912
  != always {!<=-1,!>=2}
  "double" always "double"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 913
  & {lifetime[Address]=(argInfo),!0}
Line 916
  != always {!<=-1,!>=2}
  "float" always "float"
Line 917
  & {lifetime[Address]=(argInfo),!0}
Line 922
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 924
  'I' always 73
Line 925
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '6' always 54
  && always {!<=-1,!>=2}
Line 926
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  '4' always 52
  || always {!<=-1,!>=2}
Line 927
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '3' always 51
  && always {!<=-1,!>=2}
Line 928
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  '2' always 50
Line 931
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 934
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 939
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 942
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  'h' always 104
Line 949
  'l' always 108
Line 950
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
Line 953
  'j' always 106
Line 954
  'q' always 113
Line 955
  't' always 116
Line 956
  'z' always 122
Line 957
  'L' always 76
Line 959
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 962
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 968
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 972
  printWarning always {!<=-1,!>=2}
Line 974
  done always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
  = always 0
  false always 0
Line 975
  ! always {!<=-1,!>=2}
  done always {!<=-1,!>=2}
Line 976
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
Line 980
  's' always 115
Line 981
  != always {!<=-1,!>=2}
  :: always 6
  eString always 6
  && always {!<=-1,!>=2}
Line 982
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 983
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|wchar_t" always "char|wchar_t"
Line 984
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 985
  & {lifetime[Address]=(argInfo),!0}
Line 988
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 990
  'n' always 110
Line 991
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 992
  & {lifetime[Address]=(argInfo),!0}
Line 993
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 995
  'c' always 99
Line 996
  'x' always 120
Line 997
  'X' always 88
Line 998
  'o' always 111
Line 1000
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1001
  & {lifetime[Address]=(argInfo),!0}
Line 1002
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1004
  & {lifetime[Address]=(argInfo),!0}
Line 1005
  ( always {!<=-1,!>=2}
Line 1006
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|short|long|int|char|wchar_t" always "bool|short|long|int|char|wchar_t"
Line 1007
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1008
  & {lifetime[Address]=(argInfo),!0}
Line 1010
  0 always 0
Line 1011
  'h' always 104
Line 1012
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 1013
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1014
  & {lifetime[Address]=(argInfo),!0}
Line 1015
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "short" always "short"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1016
  & {lifetime[Address]=(argInfo),!0}
Line 1018
  'l' always 108
Line 1019
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 1020
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1021
  & {lifetime[Address]=(argInfo),!0}
Line 1022
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1023
  == always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1024
  & {lifetime[Address]=(argInfo),!0}
Line 1025
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1026
  & {lifetime[Address]=(argInfo),!0}
Line 1027
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1028
  == always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1029
  & {lifetime[Address]=(argInfo),!0}
Line 1031
  'j' always 106
Line 1032
  != always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1033
  & {lifetime[Address]=(argInfo),!0}
Line 1035
  'z' always 122
Line 1036
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
Line 1037
  & {lifetime[Address]=(argInfo),!0}
Line 1039
  't' always 116
Line 1040
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 1041
  & {lifetime[Address]=(argInfo),!0}
Line 1043
  'I' always 73
Line 1044
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 1045
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1046
  & {lifetime[Address]=(argInfo),!0}
Line 1047
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 1048
  != always {!<=-1,!>=2}
  "int" always "int"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1049
  & {lifetime[Address]=(argInfo),!0}
Line 1050
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1051
  == always {!<=-1,!>=2}
  "WPARAM" always "WPARAM"
  || always {!<=-1,!>=2}
Line 1052
  == always {!<=-1,!>=2}
  "UINT_PTR" always "UINT_PTR"
  || always {!<=-1,!>=2}
Line 1053
  == always {!<=-1,!>=2}
  "LONG_PTR" always "LONG_PTR"
  || always {!<=-1,!>=2}
Line 1054
  == always {!<=-1,!>=2}
  "LPARAM" always "LPARAM"
  || always {!<=-1,!>=2}
Line 1055
  == always {!<=-1,!>=2}
  "LRESULT" always "LRESULT"
Line 1056
  & {lifetime[Address]=(argInfo),!0}
Line 1059
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|char|short|wchar_t|int" always "bool|char|short|wchar_t|int"
Line 1060
  & {lifetime[Address]=(argInfo),!0}
Line 1065
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1067
  'd' always 100
Line 1068
  'i' always 105
Line 1070
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1071
  & {lifetime[Address]=(argInfo),!0}
Line 1072
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1074
  & {lifetime[Address]=(argInfo),!0}
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "char|short" always "char|short"
Line 1077
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1078
  & {lifetime[Address]=(argInfo),!0}
Line 1079
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|char|short|int|long" always "bool|char|short|int|long"
Line 1080
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1081
  & {lifetime[Address]=(argInfo),!0}
Line 1083
  0 always 0
Line 1084
  'h' always 104
Line 1085
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 1086
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1087
  & {lifetime[Address]=(argInfo),!0}
Line 1088
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "short" always "short"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1089
  & {lifetime[Address]=(argInfo),!0}
Line 1091
  'l' always 108
Line 1092
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 1093
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1094
  & {lifetime[Address]=(argInfo),!0}
Line 1095
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 1096
  == always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 1097
  & {lifetime[Address]=(argInfo),!0}
Line 1098
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1099
  & {lifetime[Address]=(argInfo),!0}
Line 1100
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 1101
  == always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 1102
  & {lifetime[Address]=(argInfo),!0}
Line 1104
  'j' always 106
Line 1105
  != always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 1106
  & {lifetime[Address]=(argInfo),!0}
Line 1108
  't' always 116
Line 1109
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 1110
  & {lifetime[Address]=(argInfo),!0}
Line 1112
  'I' always 73
Line 1113
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 1114
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1115
  & {lifetime[Address]=(argInfo),!0}
Line 1116
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 1117
  != always {!<=-1,!>=2}
  "int" always "int"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1118
  & {lifetime[Address]=(argInfo),!0}
Line 1119
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 1120
  & {lifetime[Address]=(argInfo),!0}
Line 1122
  'z' always 122
Line 1123
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ssize_t" always "ssize_t"
  || always {!<=-1,!>=2}
Line 1124
  isWindows always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "SSIZE_T" always "SSIZE_T"
Line 1125
  & {lifetime[Address]=(argInfo),!0}
Line 1127
  'L' always 76
Line 1128
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1129
  & {lifetime[Address]=(argInfo),!0}
Line 1132
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|char|short|int" always "bool|char|short|int"
Line 1133
  & {lifetime[Address]=(argInfo),!0}
Line 1134
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
  || always {!<=-1,!>=2}
Line 1135
  == always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 1136
  & {lifetime[Address]=(argInfo),!0}
Line 1141
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1143
  'u' always 117
Line 1145
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1146
  & {lifetime[Address]=(argInfo),!0}
Line 1147
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1149
  & {lifetime[Address]=(argInfo),!0}
Line 1150
  ( always {!<=-1,!>=2}
Line 1151
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|_Bool" always "bool|_Bool"
Line 1152
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1153
  & {lifetime[Address]=(argInfo),!0}
Line 1154
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|char|short|long|int" always "bool|char|short|long|int"
Line 1155
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1156
  & {lifetime[Address]=(argInfo),!0}
Line 1158
  0 always 0
Line 1159
  'h' always 104
Line 1160
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 1161
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1162
  & {lifetime[Address]=(argInfo),!0}
Line 1163
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "short" always "short"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1164
  & {lifetime[Address]=(argInfo),!0}
Line 1166
  'l' always 108
Line 1167
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 1168
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1169
  & {lifetime[Address]=(argInfo),!0}
Line 1170
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1171
  == always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1172
  & {lifetime[Address]=(argInfo),!0}
Line 1173
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1174
  & {lifetime[Address]=(argInfo),!0}
Line 1175
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1176
  == always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1177
  & {lifetime[Address]=(argInfo),!0}
Line 1179
  'j' always 106
Line 1180
  != always {!<=-1,!>=2}
  "uintmax_t" always "uintmax_t"
Line 1181
  & {lifetime[Address]=(argInfo),!0}
Line 1183
  'z' always 122
Line 1184
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
Line 1185
  & {lifetime[Address]=(argInfo),!0}
Line 1187
  't' always 116
Line 1188
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 1189
  & {lifetime[Address]=(argInfo),!0}
Line 1191
  'I' always 73
Line 1192
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 1193
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1194
  & {lifetime[Address]=(argInfo),!0}
Line 1195
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 1196
  != always {!<=-1,!>=2}
  "int" always "int"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1197
  & {lifetime[Address]=(argInfo),!0}
Line 1198
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
Line 1199
  & {lifetime[Address]=(argInfo),!0}
Line 1201
  'L' always 76
Line 1202
  != always {!<=-1,!>=2}
  "long" always "long"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1203
  & {lifetime[Address]=(argInfo),!0}
Line 1206
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "bool|char|short|int" always "bool|char|short|int"
Line 1207
  & {lifetime[Address]=(argInfo),!0}
Line 1208
  ( always {!<=-1,!>=2}
  "size_t" always "size_t"
  || always {!<=-1,!>=2}
Line 1209
  == always {!<=-1,!>=2}
  "intmax_t" always "intmax_t"
Line 1210
  & {lifetime[Address]=(argInfo),!0}
Line 1215
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1217
  'p' always 112
Line 1218
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1220
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1221
  & {lifetime[Address]=(argInfo),!0}
Line 1222
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1224
  'e' always 101
Line 1225
  'E' always 69
Line 1226
  'f' always 102
Line 1227
  'g' always 103
Line 1228
  'G' always 71
Line 1230
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1231
  & {lifetime[Address]=(argInfo),!0}
Line 1232
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1234
  & {lifetime[Address]=(argInfo),!0}
Line 1235
  ( always {!<=-1,!>=2}
Line 1236
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "float|double" always "float|double"
Line 1237
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1238
  & {lifetime[Address]=(argInfo),!0}
Line 1239
  0 always 0
  == always {!<=-1,!>=2}
  'L' always 76
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "double" always "double"
  || always {!<=-1,!>=2}
Line 1240
  0 always 0
  != always {!<=-1,!>=2}
  'L' always 76
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1241
  & {lifetime[Address]=(argInfo),!0}
Line 1243
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1245
  'h' always 104
Line 1246
  'l' always 108
Line 1248
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
Line 1249
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  2 always 2
Line 1252
  1 always 1
Line 1254
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1260
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 1264
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1271
  'I' always 73
Line 1272
  1 always 1
  == always {!<=-1,!>=2}
  '3' always 51
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  '2' always 50
  || always {!<=-1,!>=2}
Line 1273
  1 always 1
  == always {!<=-1,!>=2}
  '6' always 54
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  '4' always 52
Line 1278
  'j' always 106
Line 1279
  'z' always 122
Line 1280
  't' always 116
Line 1281
  'L' always 76
Line 1283
  1 always 1
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(formatStringTok->str()),end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 1286
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1292
  done always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1306
  = always 0
  0 always 0
Line 1307
  argListTok2 possible symbolic=(argListTok)
Line 1312
  printWarning always {!<=-1,!>=2}
Line 1315
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 1321
  != always {!<=-1,!>=2}
Line 1322
  ( always {!<=-1,!>=2}
Line 1328
  _isCPP always {!<=-1,!>=2}
Line 1329
  nullptr always 0
Line 1330
  nullptr always 0
Line 1331
  nullptr always 0
Line 1332
  nullptr always 0
Line 1333
  element always {!<=-1,!>=2}
  false always 0
Line 1334
  _template always {!<=-1,!>=2}
  false always 0
Line 1335
  address always {!<=-1,!>=2}
  false always 0
Line 1336
  isCPP always {!<=-1,!>=2}
  _isCPP always {!<=-1,!>=2}
Line 1338
  ! always {!<=-1,!>=2}
Line 1343
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  arg always !0
  "%str% ,|)" always "%str% ,|)"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  arg always !0
  "%var%" always "%var%"
  && always {!<=-1,!>=2}
  arg always !0
  && always {!<=-1,!>=2}
  arg always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1344
  = always !0
  arg always !0
Line 1345
  top possible symbolic=(arg)
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  top possible symbolic=(arg)
  ( always {!<=-1,!>=2}
Line 1347
  top possible symbolic=(arg)
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  arg always !0
Line 1348
  = always {!symbolic=(arg->previous()),!0}
  ( always {!symbolic=(arg->previous()),!0}
Line 1350
  valuetype always symbolic=(top->argumentType())
  && always {!<=-1,!>=2}
  valuetype {symbolic=(top->argumentType()),!0}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1352
  valuetype {symbolic=(top->argumentType()),!0}
  && always {!<=-1,!>=2}
  valuetype {symbolic=(top->argumentType()),!0}
  & possible {0,1}
  1 always 1
Line 1353
  "const" always "const"
Line 1354
  "a" always "a"
Line 1357
  valuetype {symbolic=(top->argumentType()),!0}
  . {9,10,11,12,13,14,16,17,18,!<=7}
  == {!<=-1,!>=2,0}
  :: always 8
  BOOL always 8
Line 1358
  "bool" always "bool"
Line 1359
  valuetype {symbolic=(top->argumentType()),!0}
  . {10,11,12,13,14,16,17,18,!<=8}
  == {!<=-1,!>=2,0}
  :: always 9
  CHAR always 9
Line 1360
  "char" always "char"
Line 1361
  valuetype {symbolic=(top->argumentType()),!0}
  . {11,12,13,14,16,17,18,!<=9,!8}
  == {!<=-1,!>=2,0}
  :: always 10
  SHORT always 10
Line 1362
  "short" always "short"
Line 1363
  valuetype {symbolic=(top->argumentType()),!0}
  . {12,13,14,16,17,18,!<=10,!8,!9}
  == {!<=-1,!>=2,0}
  :: always 11
  WCHAR_T always 11
Line 1364
  "wchar_t" always "wchar_t"
Line 1365
  valuetype {symbolic=(top->argumentType()),!0}
  . {13,14,16,17,18,!<=11,!8,!9,!10}
  == {!<=-1,!>=2,0}
  :: always 12
  INT always 12
Line 1366
  "int" always "int"
Line 1367
  valuetype {symbolic=(top->argumentType()),!0}
  . {14,16,17,18,!<=12,!8,!9,!10,!11}
  == {!<=-1,!>=2,0}
  :: always 13
  LONG always 13
Line 1368
  "long" always "long"
Line 1369
  valuetype {symbolic=(top->argumentType()),!0}
  . {16,17,18,!<=13,!8,!9,!10,!11,!12}
  == {!<=-1,!>=2,0}
  :: always 14
  LONGLONG always 14
Line 1370
  "long" always "long"
Line 1371
  true always 1
Line 1372
  valuetype {symbolic=(top->argumentType()),!0}
  . {17,18,!<=14,!8,!9,!10,!11,!12,!13}
  == {!<=-1,!>=2,0}
  :: always 16
  FLOAT always 16
Line 1373
  "float" always "float"
Line 1374
  valuetype {symbolic=(top->argumentType()),!0}
  . {18,!<=14,!16,!8,!9,!10,!11,!12,!13}
  == {!<=-1,!>=2,0}
  :: always 17
  DOUBLE always 17
Line 1375
  "double" always "double"
Line 1376
  valuetype {symbolic=(top->argumentType()),!0}
  . always {!<=14,!16,!17,!8,!9,!10,!11,!12,!13}
  == always {!<=-1,!>=2}
  :: always 18
  LONGDOUBLE always 18
Line 1377
  "double" always "double"
Line 1378
  true always 1
Line 1380
  valuetype {symbolic=(top->argumentType()),!0}
  ( always {!<=-1,!>=2}
Line 1381
  valuetype {symbolic=(top->argumentType()),!0}
  . possible 1
  == {!<=-1,!>=2,0}
  :: always 2
  UNSIGNED always 2
Line 1382
  true always 1
Line 1383
  valuetype {symbolic=(top->argumentType()),!0}
  . always !2
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
Line 1384
  true always 1
Line 1386
  ! {!<=-1,!>=2,0}
  valuetype {symbolic=(top->argumentType()),!0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 1387
  valuetype {symbolic=(top->argumentType()),!0}
Line 1388
  = always 0
  0 always 0
  p possible 0
  < {!<=-1,!>=2,1}
  valuetype {symbolic=(top->argumentType()),!0}
  . possible 1
Line 1389
  "*" always "*"
Line 1391
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  valuetype {symbolic=(top->argumentType()),!0}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  valuetype {symbolic=(top->argumentType()),!0}
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  || always {!<=-1,!>=2}
  valuetype {symbolic=(top->argumentType()),!0}
  . always !9
  == always {!<=-1,!>=2}
  :: always 11
  WCHAR_T always 11
Line 1392
  :: always 6
  eString always 6
Line 1398
  arg always !0
  ( possible {0,2}
  == {!<=-1,!>=2,0}
  :: always 6
  eString always 6
Line 1399
  = always !0
  arg always !0
Line 1401
  arg always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
  arg always !0
  ( always !6
  == always {!<=-1,!>=2}
  :: always 0
  eVariable always 0
  || always {!<=-1,!>=2}
Line 1402
  arg always !0
  ( always {!6,!0}
  == always {!<=-1,!>=2}
  :: always 2
  eFunction always 2
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  arg always !0
  "%type% ::" always "%type% ::"
  || always {!<=-1,!>=2}
Line 1403
  ( always {!<=-1,!>=2}
  arg always !0
  "static_cast|reinterpret_cast|const_cast <" always "static_cast|reinterpret_cast|const_cast <"
  && always {!<=-1,!>=2}
Line 1404
  ( always {!<=-1,!>=2}
  arg always !0
  1 always 1
  "> (" always "> ("
  && always {!<=-1,!>=2}
Line 1405
  ( always {!<=-1,!>=2}
  arg always !0
  1 always 1
  1 always 1
  ") ,|)" always ") ,|)"
Line 1406
  ( always {!<=-1,!>=2}
  arg always !0
  "static_cast|reinterpret_cast|const_cast" always "static_cast|reinterpret_cast|const_cast"
Line 1407
  arg always !0
  2 always 2
Line 1408
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "extern" always "extern"
Line 1412
  arg always !0
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1413
  address always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1414
  arg always !0
Line 1416
  ( always {!<=-1,!>=2}
  arg possible 0
  "%type% ::" always "%type% ::"
Line 1417
  2 always 2
Line 1418
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  arg always !0
  == always {!<=-1,!>=2}
  :: always 0
  eVariable always 0
  || always {!<=-1,!>=2}
  arg always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  eFunction always 2
Line 1420
  = always 0
  nullptr always 0
Line 1421
  arg always !0
Line 1422
  tok1 possible symbolic=(arg->next())
Line 1423
  tok1 possible symbolic=(arg->next())
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1424
  ( possible size=1
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1425
  -1 always -1
Line 1426
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  eFunction always 2
Line 1428
  function {symbolic=(varTok->link()->previous()->function()),0}
  && always {!<=-1,!>=2}
  function {symbolic=(varTok->link()->previous()->function()),!0}
  && always {!<=-1,!>=2}
  function {symbolic=(varTok->link()->previous()->function()),!0}
  . always !0
  ( always {!<=-1,!>=2}
Line 1429
  function {symbolic=(varTok->link()->previous()->function()),!0}
  . always !0
Line 1430
  = always !0
  function {symbolic=(varTok->link()->previous()->function()),!0}
  . always !0
  . always !0
Line 1433
  tempToken always size=0
Line 1434
  tempToken always size=0
Line 1435
  tempToken always size=0
  "int" always "int"
Line 1436
  = always size=0
  tempToken always size=0
Line 1438
  function {symbolic=(varTok->link()->previous()->function()),0}
  && always {!<=-1,!>=2}
  function {symbolic=(varTok->link()->previous()->function()),!0}
Line 1439
  = always !0
  function {symbolic=(varTok->link()->previous()->function()),!0}
  . always !0
Line 1440
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "extern" always "extern"
Line 1442
  = {symbolic=(varTok->link()->previous()->function()),!0}
  function {symbolic=(varTok->link()->previous()->function()),!0}
Line 1443
  element always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1447
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  :: always 2
  eFunction always 2
Line 1448
  -1 always -1
Line 1449
  function possible 0
  && always {!<=-1,!>=2}
  function always !0
  && always {!<=-1,!>=2}
  function always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 1450
  function always !0
  . always !0
Line 1451
  = always !0
  function always !0
  . always !0
  . always !0
Line 1454
  tempToken always size=0
Line 1455
  tempToken always size=0
Line 1456
  tempToken always size=0
  "int" always "int"
Line 1457
  = always size=0
  tempToken always size=0
Line 1459
  function possible 0
  && always {!<=-1,!>=2}
  function always !0
Line 1460
  = always !0
  function always !0
  . always !0
Line 1461
  == always {!<=-1,!>=2}
  "const" always "const"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "extern" always "extern"
Line 1463
  = always !0
  function always !0
Line 1464
  element always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1470
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "[" always "["
Line 1472
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "<" always "<"
Line 1473
  = always !0
  ( always !0
Line 1476
  isCPP always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . size|empty|c_str ( ) [,)]" always "%var% . size|empty|c_str ( ) [,)]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1477
  ( always {!<=-1,!>=2}
  "] . size|empty|c_str ( ) [,)]" always "] . size|empty|c_str ( ) [,)]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1479
  tempToken always size=0
Line 1480
  tempToken always size=0
Line 1481
  ( possible size=5
  == {!<=-1,!>=2,0}
  "size" always "size"
Line 1483
  . possible 4
  == {!<=-1,!>=2,0}
  8 always 8
Line 1484
  tempToken always size=0
  "long" always "long"
Line 1485
  != always {!<=-1,!>=2}
  8 always 8
Line 1486
  tempToken always size=0
  true always 1
Line 1487
  . always !8
  == always {!<=-1,!>=2}
  4 always 4
Line 1488
  == always {!<=-1,!>=2}
  4 always 4
Line 1489
  tempToken always size=0
  "long" always "long"
Line 1491
  tempToken always size=0
  "int" always "int"
Line 1495
  tempToken always size=0
  "size_t" always "size_t"
Line 1496
  tempToken always size=0
  true always 1
Line 1497
  ( possible size=5
  == always {!<=-1,!>=2}
  "empty" always "empty"
Line 1498
  tempToken always size=0
  "bool" always "bool"
Line 1499
  == always {!<=-1,!>=2}
  "c_str" always "c_str"
Line 1500
  tempToken always size=0
  "const" always "const"
Line 1501
  tempToken always size=0
  "*" always "*"
Line 1502
  2 always 2
  == always {!<=-1,!>=2}
  "string" always "string"
Line 1503
  tempToken always size=0
  "char" always "char"
Line 1505
  tempToken always size=0
  "wchar_t" always "wchar_t"
Line 1507
  = always size=0
  tempToken always size=0
Line 1512
  ( always {!<=-1,!>=2}
  "%var% . at (" always "%var% . at ("
  && always {!<=-1,!>=2}
Line 1513
  ( always {!<=-1,!>=2}
  2 always 2
  ") [,)]" always ") [,)]"
Line 1515
  varTok always symbolic=(tok1->previous())
Line 1517
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1518
  = always 0
  nullptr always 0
Line 1519
  = always 0
  nullptr always 0
Line 1523
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  eVariable always 0
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 2
  eFunction always 2
Line 1527
  varTok possible {symbolic=(tok1->previous()),0}
Line 1528
  varTok always !0
Line 1529
  element always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "]" always "]"
Line 1533
  element always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1534
  element always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1535
  ( always {!<=-1,!>=2}
Line 1536
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
Line 1537
  = always !0
  ( always !0
  . always !0
  . always !0
Line 1540
  tempToken always size=0
Line 1541
  tempToken always size=0
Line 1542
  tempToken always size=0
  "int" always "int"
Line 1543
  = always size=0
  tempToken always size=0
Line 1557
  tempToken always !0
Line 1558
  tempToken always !0
Line 1560
  tempToken always !0
Line 1565
  "array" always "array"
  "vector" always "vector"
Line 1566
  "string" always "string"
  "u16string" always "u16string"
  "u32string" always "u32string"
  "wstring" always "wstring"
Line 1569
  ( always {!<=-1,!>=2}
Line 1571
  ! always {!<=-1,!>=2}
  isCPP always {!<=-1,!>=2}
Line 1572
  return always {!<=-1,!>=2}
  false always 0
Line 1573
  ( always {!<=-1,!>=2}
Line 1574
  4 always 4
Line 1575
  _template always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1576
  return always {!<=-1,!>=2}
  true always 1
Line 1577
  ( always {!<=-1,!>=2}
Line 1579
  tempToken always size=0
Line 1580
  tempToken always size=0
Line 1581
  2 always 2
  == always {!<=-1,!>=2}
  "string" always "string"
Line 1582
  tempToken always size=0
  "char" always "char"
Line 1584
  tempToken always size=0
  "wchar_t" always "wchar_t"
Line 1586
  return always {!<=-1,!>=2}
  true always 1
Line 1587
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1588
  = always !size=0
  ( always !0
  . always !size=0
Line 1589
  derivedFrom always !size=0
Line 1591
  ( always {!<=-1,!>=2}
  nameTok always symbolic=(i.nameTok)
  "std :: vector|array <" always "std :: vector|array <"
Line 1592
  4 always 4
Line 1593
  _template always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1594
  return always {!<=-1,!>=2}
  true always 1
Line 1595
  ( always {!<=-1,!>=2}
  "std :: string|wstring" always "std :: string|wstring"
Line 1597
  tempToken always size=0
Line 1598
  tempToken always size=0
Line 1599
  2 always 2
  == always {!<=-1,!>=2}
  "string" always "string"
Line 1600
  tempToken always size=0
  "char" always "char"
Line 1602
  tempToken always size=0
  "wchar_t" always "wchar_t"
Line 1604
  return always {!<=-1,!>=2}
  true always 1
Line 1607
  ( possible 0
Line 1608
  ( always !0
Line 1609
  classScope always symbolic=(variableInfo->type()->classScope)
Line 1610
  classScope {symbolic=(variableInfo->type()->classScope),!0}
Line 1611
  == always {!<=-1,!>=2}
  "operator[]" always "operator[]"
Line 1612
  ( always {!<=-1,!>=2}
  "%type% &" always "%type% &"
Line 1614
  return always {!<=-1,!>=2}
  true always 1
Line 1621
  return always {!<=-1,!>=2}
  false always 0
Line 1625
  "array" always "array"
  "bitset" always "bitset"
  "deque" always "deque"
  "forward_list" always "forward_list"
Line 1626
  "hash_map" always "hash_map"
  "hash_multimap" always "hash_multimap"
  "hash_set" always "hash_set"
Line 1627
  "list" always "list"
  "map" always "map"
  "multimap" always "multimap"
  "multiset" always "multiset"
Line 1628
  "priority_queue" always "priority_queue"
  "queue" always "queue"
  "set" always "set"
  "stack" always "stack"
Line 1629
  "unordered_map" always "unordered_map"
  "unordered_multimap" always "unordered_multimap"
  "unordered_multiset" always "unordered_multiset"
  "unordered_set" always "unordered_set"
  "vector" always "vector"
Line 1632
  ( always {!<=-1,!>=2}
Line 1634
  ! always {!<=-1,!>=2}
  isCPP always {!<=-1,!>=2}
Line 1635
  return always {!<=-1,!>=2}
  false always 0
Line 1636
  && always {!<=-1,!>=2}
  tok always !0
Line 1637
  = always !0
  tok always !0
  ( always !0
Line 1638
  variable {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1639
  variable {symbolic=(tok->variable()),!0}
  4 always 4
Line 1640
  return always {!<=-1,!>=2}
  true always 1
Line 1641
  variable {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1642
  variable {symbolic=(tok->variable()),!0}
Line 1643
  return always {!<=-1,!>=2}
  true always 1
Line 1644
  variable {symbolic=(tok->variable()),!0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  variable {symbolic=(tok->variable()),!0}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1645
  variable {symbolic=(tok->variable()),!0}
  ( always !0
  . always !size=0
Line 1647
  ( always {!<=-1,!>=2}
  nameTok always symbolic=(baseInfo.nameTok)
  "std :: vector|array|bitset|deque|list|forward_list|map|multimap|multiset|priority_queue|queue|set|stack|hash_map|hash_multimap|hash_set|unordered_map|unordered_multimap|unordered_set|unordered_multiset <" always "std :: vector|array|bitset|deque|list|forward_list|map|multimap|multiset|priority_queue|queue|set|stack|hash_map|hash_multimap|hash_set|unordered_map|unordered_multimap|unordered_set|unordered_multiset <"
Line 1648
  4 always 4
Line 1649
  return always {!<=-1,!>=2}
  true always 1
Line 1650
  ( always {!<=-1,!>=2}
  "std :: string|wstring" always "std :: string|wstring"
Line 1652
  return always {!<=-1,!>=2}
  true always 1
Line 1658
  return always {!<=-1,!>=2}
  false always 0
Line 1661
  ( always {!<=-1,!>=2}
Line 1663
  address always {!<=-1,!>=2}
Line 1664
  return always {!<=-1,!>=2}
  true always 1
Line 1665
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  _template always {!<=-1,!>=2}
Line 1666
  return always {!<=-1,!>=2}
  variableInfo always !0
  ( always {!<=-1,!>=2}
Line 1669
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(typeToken),0}
  "const|struct" always "const|struct"
Line 1671
  tok possible symbolic=(typeToken)
  && always {!<=-1,!>=2}
  tok always !0
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1672
  return always {!<=-1,!>=2}
  true always 1
Line 1674
  return always {!<=-1,!>=2}
  false always 0
Line 1677
  ( always {!<=-1,!>=2}
Line 1680
  return always {!<=-1,!>=2}
  true always 1
Line 1683
  varTypeTok always symbolic=(typeToken)
  == always {!<=-1,!>=2}
  "std" always "std"
Line 1684
  varTypeTok always symbolic=(typeToken)
  2 always 2
Line 1686
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  1 always 1
  1 always 1
  != always {!<=-1,!>=2}
  "::" always "::"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1689
  ( always {!<=-1,!>=2}
Line 1692
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1694
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  functionInfo always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: string|wstring" always "std :: string|wstring"
Line 1696
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: string|wstring" always "std :: string|wstring"
Line 1699
  ( always {!<=-1,!>=2}
Line 1701
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeToken always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeToken always !0
Line 1709
  numFormat possible {1,3@45}
  > {!<=-1,!>=2,0}
  numFunction possible {1,2@45}
  :: always 1
  error always 1
  : always 2
  :: always 2
  warning always 2
Line 1710
  severity always symbolic=(numFormat>numFunction?Severity::error:Severity::warning)
  != always {!<=-1,!>=2}
  :: always 1
  error always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1714
  functionName possible "printf"@45
Line 1715
  " format string requires " always " format string requires "
Line 1716
  numFormat possible {1,3@45}
Line 1717
  " parameter" always " parameter"
  numFormat possible 3@45
  != {!<=-1,!>=2,1}
  1 always 1
  ? possible {"s",""}
  "s" always "s"
  : always ""
  "" always ""
  " but " always " but "
Line 1718
  numFormat possible 3@45
  > {!<=-1,!>=2,1}
  numFunction possible 2@45
  "only " always "only "
  : always ""
  "" always ""
Line 1719
  numFunction possible {1,2@45}
Line 1720
  numFunction possible 2@45
  != {!<=-1,!>=2,1}
  1 always 1
  ? possible {" are"," is"}
  " are" always " are"
  : always " is"
  " is" always " is"
Line 1721
  " given." always " given."
Line 1723
  tok possible 0@45
  severity always symbolic=(numFormat>numFunction?Severity::error:Severity::warning)
  "wrongPrintfScanfArgNum" always "wrongPrintfScanfArgNum"
  :: always 0
  normal always 0
Line 1729
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1732
  functionName possible "printf"@58
  ": " always ": "
Line 1733
  index possible 2@58
  == {!<=-1,!>=2,0}
  0 always 0
Line 1734
  "parameter positions start at 1, not 0" always "parameter positions start at 1, not 0"
Line 1736
  "referencing parameter " always "referencing parameter "
  index {!0,2@58}
  " while " always " while "
  numFunction possible 1@58
  " arguments given" always " arguments given"
Line 1738
  tok possible 0@58
  :: always 2
  warning always 2
  "wrongPrintfScanfParameterPositionError" always "wrongPrintfScanfParameterPositionError"
  :: always 0
  normal always 0
Line 1743
  argInfo possible {lifetime[Address]=(argInfo)@2,0@46}
Line 1744
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1747
  "%" always "%"
  specifier possible "s"@46
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@46
  ") requires a \'" always ") requires a \'"
Line 1748
  specifier possible "s"@46
  [ possible {83,115}
  0 always 0
  == {!<=-1,!>=2,0,1}
  's' always 115
Line 1749
  "char" always "char"
Line 1750
  [ always !115
  0 always 0
  == always {!<=-1,!>=2}
  'S' always 83
Line 1751
  "wchar_t" always "wchar_t"
Line 1752
  " *\' but the argument type is " always " *\' but the argument type is "
Line 1753
  argInfo possible 0@46
Line 1754
  "." always "."
Line 1755
  tok possible 0@46
  "invalidScanfArgType_s" always "invalidScanfArgType_s"
  :: always 0
  normal always 0
Line 1757
  , always {!<=-1,!>=2}
  isUnsigned always {!<=-1,!>=2}
Line 1759
  argInfo possible {lifetime[Address]=(argInfo)@10,lifetime[Address]=(argInfo)@13,lifetime[Address]=(argInfo)@16,lifetime[Address]=(argInfo)@18,lifetime[Address]=(argInfo)@20,lifetime[Address]=(argInfo)@23,lifetime[Address]=(argInfo)@30,lifetime[Address]=(argInfo)@33,lifetime[Address]=(argInfo)@40,lifetime[Address]=(argInfo)@43}
Line 1760
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1763
  "%" always "%"
  specifier possible "d"@47
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@47
  ") requires \'" always ") requires \'"
Line 1764
  specifier possible "d"@47
  [ possible {108,73,106,122,116,76,100}
  0 always 0
  == {!<=-1,!>=2,0}
  'h' always 104
Line 1765
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 1766
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "char" always "char"
Line 1768
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "short" always "short"
Line 1769
  specifier possible "d"@47
  [ {73,106,122,116,76,!104,100}
  0 always 0
  == {!<=-1,!>=2,0}
  'l' always 108
Line 1770
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 1771
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long long" always "long long"
Line 1773
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long" always "long"
Line 1774
  specifier possible "d"@47
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 1775
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "__int32" always "__int32"
Line 1776
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 1777
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "__int64" always "__int64"
Line 1778
  [ {106,122,116,76,!104,!108}
  0 always 0
  == {!<=-1,!>=2,0}
  'I' always 73
Line 1779
  isUnsigned always {!<=-1,!>=2}
  ? possible {"size_t","ptrdiff_t"}
  "size_t" always "size_t"
  : always "ptrdiff_t"
  "ptrdiff_t" always "ptrdiff_t"
Line 1780
  [ {122,116,76,!104,!108,!73}
  0 always 0
  == {!<=-1,!>=2,0}
  'j' always 106
Line 1781
  isUnsigned always {!<=-1,!>=2}
Line 1782
  "uintmax_t" always "uintmax_t"
Line 1784
  "intmax_t" always "intmax_t"
Line 1785
  [ {116,76,!104,!108,!73,!106}
  0 always 0
  == {!<=-1,!>=2,0}
  'z' always 122
Line 1786
  [ possible 105
  1 always 1
  == {!<=-1,!>=2,0}
  'd' always 100
  || always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  'i' always 105
Line 1787
  "ssize_t" always "ssize_t"
Line 1789
  "size_t" always "size_t"
Line 1790
  [ {76,!104,!108,!73,!106,!122}
  0 always 0
  == {!<=-1,!>=2,0}
  't' always 116
Line 1791
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "ptrdiff_t" always "ptrdiff_t"
Line 1792
  [ always {!104,!108,!73,!106,!122,!116}
  0 always 0
  == always {!<=-1,!>=2}
  'L' always 76
Line 1793
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long long" always "long long"
Line 1795
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "int" always "int"
Line 1797
  " *\' but the argument type is " always " *\' but the argument type is "
Line 1799
  "." always "."
Line 1800
  "invalidScanfArgType_int" always "invalidScanfArgType_int"
  :: always 0
  normal always 0
Line 1804
  argInfo possible {lifetime[Address]=(argInfo)@134,lifetime[Address]=(argInfo)@137,lifetime[Address]=(argInfo)@139,lifetime[Address]=(argInfo)@142,lifetime[Address]=(argInfo)@145,lifetime[Address]=(argInfo)@147,0@48}
Line 1805
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1808
  "%" always "%"
  specifier possible "f"@48
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@48
  ") requires \'" always ") requires \'"
Line 1809
  specifier possible "f"@48
  [ possible {76,102}
  0 always 0
  == {!<=-1,!>=2,0}
  'l' always 108
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  'l' always 108
Line 1810
  "double" always "double"
Line 1811
  specifier possible "f"@48
  [ possible 102
  0 always 0
  == {!<=-1,!>=2,0}
  'L' always 76
Line 1812
  "long double" always "long double"
Line 1814
  "float" always "float"
Line 1815
  " *\' but the argument type is " always " *\' but the argument type is "
Line 1816
  argInfo possible 0@48
Line 1817
  "." always "."
Line 1818
  tok possible 0@48
  "invalidScanfArgType_float" always "invalidScanfArgType_float"
  :: always 0
  normal always 0
Line 1823
  argInfo possible {lifetime[Address]=(argInfo)@154,0@49}
Line 1824
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1827
  "%s in format string (no. " always "%s in format string (no. "
  numFormat possible 1@49
  ") requires \'char *\' but the argument type is " always ") requires \'char *\' but the argument type is "
Line 1828
  argInfo possible {lifetime[Address]=(argInfo)@154,0@49}
Line 1829
  "." always "."
Line 1830
  tok possible 0@49
  "invalidPrintfArgType_s" always "invalidPrintfArgType_s"
  :: always 0
  normal always 0
Line 1834
  argInfo possible {lifetime[Address]=(argInfo)@158,0@50}
Line 1835
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1838
  "%n in format string (no. " always "%n in format string (no. "
  numFormat possible 1@50
  ") requires \'int *\' but the argument type is " always ") requires \'int *\' but the argument type is "
Line 1839
  argInfo possible {lifetime[Address]=(argInfo)@158,0@50}
Line 1840
  "." always "."
Line 1841
  tok possible 0@50
  "invalidPrintfArgType_n" always "invalidPrintfArgType_n"
  :: always 0
  normal always 0
Line 1845
  argInfo possible {lifetime[Address]=(argInfo)@68,0@51}
Line 1846
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1849
  "%p in format string (no. " always "%p in format string (no. "
  numFormat possible 1@51
  ") requires an address but the argument type is " always ") requires an address but the argument type is "
Line 1850
  argInfo possible {lifetime[Address]=(argInfo)@68,0@51}
Line 1851
  "." always "."
Line 1852
  tok possible 0@51
  "invalidPrintfArgType_p" always "invalidPrintfArgType_p"
  :: always 0
  normal always 0
Line 1854
  , always {!<=-1,!>=2}
  isUnsigned always {!<=-1,!>=2}
Line 1856
  "\'" always "\'"
Line 1857
  [ possible {104,73,106,122,116,76}
  0 always 0
  == {!<=-1,!>=2,0}
  'l' always 108
Line 1858
  1 always 1
  == always {!<=-1,!>=2}
  'l' always 108
Line 1859
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long long" always "long long"
Line 1861
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long" always "long"
Line 1862
  [ {73,106,122,116,76,!108}
  0 always 0
  == {!<=-1,!>=2,0}
  'h' always 104
Line 1863
  1 always 1
  == always {!<=-1,!>=2}
  'h' always 104
Line 1864
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "char" always "char"
Line 1866
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "short" always "short"
Line 1867
  ( always !<=-1
  "I32" always "I32"
  != always {!<=-1,!>=2}
Line 1868
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "__int32" always "__int32"
Line 1869
  ( always !<=-1
  "I64" always "I64"
  != always {!<=-1,!>=2}
Line 1870
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "__int64" always "__int64"
Line 1871
  [ {106,122,116,76,!108,!104}
  0 always 0
  == {!<=-1,!>=2,0}
  'I' always 73
Line 1872
  isUnsigned always {!<=-1,!>=2}
  ? possible {"size_t","ptrdiff_t"}
  "size_t" always "size_t"
  : always "ptrdiff_t"
  "ptrdiff_t" always "ptrdiff_t"
Line 1873
  [ {122,116,76,!108,!104,!73}
  0 always 0
  == {!<=-1,!>=2,0}
  'j' always 106
Line 1874
  isUnsigned always {!<=-1,!>=2}
Line 1875
  "uintmax_t" always "uintmax_t"
Line 1877
  "intmax_t" always "intmax_t"
Line 1878
  [ {116,76,!108,!104,!73,!106}
  0 always 0
  == {!<=-1,!>=2,0}
  'z' always 122
Line 1879
  [ possible 105
  1 always 1
  == {!<=-1,!>=2,0}
  'd' always 100
  || always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  'i' always 105
Line 1880
  "ssize_t" always "ssize_t"
Line 1882
  "size_t" always "size_t"
Line 1883
  [ {76,!108,!104,!73,!106,!122}
  0 always 0
  == {!<=-1,!>=2,0}
  't' always 116
Line 1884
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "ptrdiff_t" always "ptrdiff_t"
Line 1885
  [ always {!108,!104,!73,!106,!122,!116}
  0 always 0
  == always {!<=-1,!>=2}
  'L' always 76
Line 1886
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "long long" always "long long"
Line 1888
  isUnsigned always {!<=-1,!>=2}
  ? possible {"unsigned ",""}
  "unsigned " always "unsigned "
  : always ""
  "" always ""
  "int" always "int"
Line 1890
  "\'" always "\'"
Line 1895
  argInfo possible {lifetime[Address]=(argInfo)@160,lifetime[Address]=(argInfo)@162,lifetime[Address]=(argInfo)@165,lifetime[Address]=(argInfo)@168,lifetime[Address]=(argInfo)@171,lifetime[Address]=(argInfo)@174,lifetime[Address]=(argInfo)@178,lifetime[Address]=(argInfo)@181,lifetime[Address]=(argInfo)@185,lifetime[Address]=(argInfo)@187}
Line 1896
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1899
  "%" always "%"
  specifier possible "u"@52
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@52
  ") requires " always ") requires "
Line 1900
  specifier possible "u"@52
  true always 1
Line 1901
  " but the argument type is " always " but the argument type is "
Line 1902
  argInfo possible {lifetime[Address]=(argInfo)@160,lifetime[Address]=(argInfo)@162,lifetime[Address]=(argInfo)@165,lifetime[Address]=(argInfo)@168,lifetime[Address]=(argInfo)@171,lifetime[Address]=(argInfo)@174,lifetime[Address]=(argInfo)@178,lifetime[Address]=(argInfo)@181,lifetime[Address]=(argInfo)@185,lifetime[Address]=(argInfo)@187}
Line 1903
  "." always "."
Line 1904
  tok possible 0@52
  "invalidPrintfArgType_uint" always "invalidPrintfArgType_uint"
  :: always 0
  normal always 0
Line 1909
  argInfo possible {lifetime[Address]=(argInfo)@210,lifetime[Address]=(argInfo)@212,lifetime[Address]=(argInfo)@216,lifetime[Address]=(argInfo)@218,lifetime[Address]=(argInfo)@221,lifetime[Address]=(argInfo)@224,lifetime[Address]=(argInfo)@227,lifetime[Address]=(argInfo)@231,lifetime[Address]=(argInfo)@234,lifetime[Address]=(argInfo)@238}
Line 1910
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1913
  "%" always "%"
  specifier possible "i"@53
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@53
  ") requires " always ") requires "
Line 1914
  specifier possible "i"@53
  false always 0
Line 1915
  " but the argument type is " always " but the argument type is "
Line 1916
  argInfo possible {lifetime[Address]=(argInfo)@210,lifetime[Address]=(argInfo)@212,lifetime[Address]=(argInfo)@216,lifetime[Address]=(argInfo)@218,lifetime[Address]=(argInfo)@221,lifetime[Address]=(argInfo)@224,lifetime[Address]=(argInfo)@227,lifetime[Address]=(argInfo)@231,lifetime[Address]=(argInfo)@234,lifetime[Address]=(argInfo)@238}
Line 1917
  "." always "."
Line 1918
  tok possible 0@53
  "invalidPrintfArgType_sint" always "invalidPrintfArgType_sint"
  :: always 0
  normal always 0
Line 1922
  argInfo possible {lifetime[Address]=(argInfo)@70,lifetime[Address]=(argInfo)@72,lifetime[Address]=(argInfo)@75,lifetime[Address]=(argInfo)@79,0@54}
Line 1923
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1926
  "%" always "%"
  specifier possible "f"@54
  " in format string (no. " always " in format string (no. "
  numFormat possible 1@54
  ") requires \'" always ") requires \'"
Line 1927
  specifier possible "f"@54
  [ possible 102
  0 always 0
  == {!<=-1,!>=2,0}
  'L' always 76
Line 1928
  "long " always "long "
Line 1929
  "double\' but the argument type is " always "double\' but the argument type is "
Line 1930
  argInfo possible 0@54
Line 1931
  "." always "."
Line 1932
  tok possible 0@54
  "invalidPrintfArgType_float" always "invalidPrintfArgType_float"
  :: always 0
  normal always 0
Line 1937
  argInfo possible {lifetime[Address]=(argInfo)@17956,lifetime[Address]=(argInfo)@18468,lifetime[Address]=(argInfo)@19236,lifetime[Address]=(argInfo)@20260,lifetime[Address]=(argInfo)@53800,lifetime[Address]=(argInfo)@54312,lifetime[Address]=(argInfo)@55336,lifetime[Address]=(argInfo)@55848,lifetime[Address]=(argInfo)@41005,lifetime[Address]=(argInfo)@41517}
  && always {!<=-1,!>=2}
  argInfo {!0,lifetime[Address]=(argInfo)@17956,lifetime[Address]=(argInfo)@18468,lifetime[Address]=(argInfo)@19236,lifetime[Address]=(argInfo)@20260,lifetime[Address]=(argInfo)@53800,lifetime[Address]=(argInfo)@54312,lifetime[Address]=(argInfo)@55336,lifetime[Address]=(argInfo)@55848,lifetime[Address]=(argInfo)@41005}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  argInfo {!0,lifetime[Address]=(argInfo)@17956,lifetime[Address]=(argInfo)@18468,lifetime[Address]=(argInfo)@19236,lifetime[Address]=(argInfo)@20260,lifetime[Address]=(argInfo)@53800,lifetime[Address]=(argInfo)@54312,lifetime[Address]=(argInfo)@55336,lifetime[Address]=(argInfo)@55848,lifetime[Address]=(argInfo)@41005}
  . always !0
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
  : always 2
  :: always 2
  warning always 2
Line 1942
  argInfo possible {0@13862,lifetime[Address]=(argInfo)@53803,lifetime[Address]=(argInfo)@54315,lifetime[Address]=(argInfo)@55339,lifetime[Address]=(argInfo)@55851,lifetime[Address]=(argInfo)@41008,lifetime[Address]=(argInfo)@41520,lifetime[Address]=(argInfo)@42288,lifetime[Address]=(argInfo)@43056,lifetime[Address]=(argInfo)@17460}
Line 1943
  "\'" always "\'"
Line 1944
  argInfo always !0
Line 1945
  type always symbolic=(argInfo->typeToken)
  == always {!<=-1,!>=2}
  :: always 6
  eString always 6
Line 1946
  type always symbolic=(argInfo->typeToken)
  ( always {!<=-1,!>=2}
Line 1947
  "const wchar_t *" always "const wchar_t *"
Line 1949
  "const char *" always "const char *"
Line 1951
  type always symbolic=(argInfo->typeToken)
  ( possible {size=7,size=9}
  ( {!<=-1,!>=2,0}
Line 1952
  type always symbolic=(argInfo->typeToken)
  -1 always -1
  == always {!<=-1,!>=2}
  "const" always "const"
Line 1953
  "const " always "const "
Line 1954
  ( always {!<=-1,!>=2}
  type possible symbolic=(argInfo->typeToken)
  "const|struct" always "const|struct"
Line 1955
  " " always " "
Line 1958
  ( always {!<=-1,!>=2}
  type possible symbolic=(argInfo->typeToken)
  "%any% ::" always "%any% ::"
Line 1959
  "::" always "::"
Line 1960
  2 always 2
Line 1962
  false always 0
  true always 1
  false always 0
Line 1963
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  argInfo always !0
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
Line 1964
  " *" always " *"
Line 1965
  argInfo always !0
  . possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  argInfo always !0
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argInfo always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 1966
  " *" always " *"
Line 1967
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  argInfo always !0
  && always {!<=-1,!>=2}
  argInfo always !0
  . always {!<=-1,!>=2}
  element always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argInfo always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 1968
  " *" always " *"
Line 1969
  argInfo always !0
  . always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
Line 1970
  " *" always " *"
Line 1972
  type always symbolic=(argInfo->typeToken)
  ( always {!<=-1,!>=2}
Line 1973
  type always symbolic=(argInfo->typeToken)
  ( {size=7,size=9,!size=0}
  == {!<=-1,!>=2,0}
  "__int64" always "__int64"
  || always {!<=-1,!>=2}
  type always symbolic=(argInfo->typeToken)
  ( always !size=0
  == always {!<=-1,!>=2}
  "__int32" always "__int32"
  || always {!<=-1,!>=2}
  type always symbolic=(argInfo->typeToken)
  ( always !size=0
  == always {!<=-1,!>=2}
  "ptrdiff_t" always "ptrdiff_t"
Line 1974
  "unsigned " always "unsigned "
Line 1976
  type always symbolic=(argInfo->typeToken)
  ( {!size=0,size=7,size=9}
Line 1977
  type always symbolic=(argInfo->typeToken)
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  argInfo always !0
  . always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
Line 1978
  " *" always " *"
Line 1979
  " {aka " always " {aka "
  type always symbolic=(argInfo->typeToken)
  false always 0
  true always 1
  false always 0
Line 1980
  type always symbolic=(argInfo->typeToken)
  1 always 1
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  argInfo always !0
  . always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
Line 1981
  " *" always " *"
Line 1982
  "}" always "}"
Line 1985
  "\'" always "\'"
Line 1987
  "Unknown" always "Unknown"
Line 1992
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1995
  "'" always "'"
  modifier possible "I"@55
  "' in format string (no. " always "' in format string (no. "
  numFormat possible 1@55
  ") is a length modifier and cannot be used without a conversion specifier." always ") is a length modifier and cannot be used without a conversion specifier."
Line 1996
  tok possible 0@55
  :: always 2
  warning always 2
  "invalidLengthModifierError" always "invalidLengthModifierError"
  :: always 0
  normal always 0
Line 2001
  = always 0
  0 always 0
Line 2004
  var possible 0@56
Line 2005
  var always !0
  0 always 0
Line 2006
  var always !0
Line 2010
  arrlen possible 0
  > always {!<=-1,!>=2}
  width possible {symbolic=(std::atoi(width.c_str()))@252,5@56,-1@57}
Line 2011
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2013
  "Width " always "Width "
  width always !>=symbolic=(arrlen)
  " given in format string (no. " always " given in format string (no. "
  ") is smaller than destination buffer" always ") is smaller than destination buffer"
Line 2014
  " '" always " '"
  "[" always "["
  arrlen always !<=symbolic=(width)
  "]'." always "]'."
Line 2015
  tok possible 0
  :: always 2
  warning always 2
  "invalidScanfFormatWidth_smaller" always "invalidScanfFormatWidth_smaller"
  0U always 0
  :: always 1
  inconclusive always 1
Line 2017
  "Width " always "Width "
  width {!<=symbolic=(arrlen-1),>=symbolic=(arrlen)}
  " given in format string (no. " always " given in format string (no. "
  ") is larger than destination buffer '" always ") is larger than destination buffer '"
Line 2018
  "[" always "["
  arrlen {!>=symbolic=(width+1),<=symbolic=(width),<=5@56}
  "]', use %" always "]', use %"
  == always {!<=-1,!>=2}
  "c" always "c"
  arrlen always !>=symbolic=(width+1)
  : always !>=symbolic=(width+1)
  arrlen always !>=symbolic=(width+1)
  1 always 1
  " to prevent overflowing it." always " to prevent overflowing it."
Line 2019
  :: always 1
  error always 1
  "invalidScanfFormatWidth" always "invalidScanfFormatWidth"
  :: always 0
  normal always 0
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,2@16,5@135}
  flag possible {2@16,5@135}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,1@15}
  flag possible 1@15
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
