

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073744747 !@expr1073744748 mTokenizer@var28 ) {
69: instances (@expr1073744749 ) .@expr1073744750 remove (@expr1073744751 this@expr1073744752 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073744753 string (@expr1073744754 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073744755 void ) tokenizer@var21 ;
108: (@expr1073744756 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073744757 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073744758 void ) ctu@var24 ;
120: (@expr1073744759 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073744760 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073744761 0U ) , Certainty ::@expr1073744762 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073744763 list < const Token *@expr1073744764 > callstack@var41 (@expr1073744765 1 , tok@var35 ) ;
141: reportError (@expr1073744766 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073744767 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073744768 0U ) , Certainty ::@expr1073744769 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var64 ;
42: double mDoubleValue@var65 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var66 ;
44: bool mIsUnsigned@var67 ;
45:
46: void promote ( const value & v@var68 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var69 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var66 !=@expr1073744770 Type ::@expr1073744771 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var66 ==@expr1073744772 Type ::@expr1073744773 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744774 ) ?@expr1073744775 mDoubleValue@var65 :@expr1073744776 (@expr1073744777 double ) mIntValue@var64 ;
60: }
61:
62: static value calc ( char op@var70 , const value & v1@var71 , const value & v2@var72 ) ;
63: int compare ( const value & v@var73 ) const ;
64: value add ( int v@var74 ) const ;
65: value shiftLeft ( const value & v@var75 ) const ;
66: value shiftRight ( const value & v@var76 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var77 ;
72:
73: static long long toLongNumber ( const std :: string & str@var78 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var79 ) ;
75:
76: template < class T > static std :: string toString ( T value@var80 ) {
77: std ::@expr1073744778 ostringstream result@var81 ;
78: result@var81 <<@expr1073744779 value@var80 ;
79: return result@var81 .@expr1073744780 str (@expr1073744781 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var82 ) ;
82:
83: static bool isInt ( const std :: string & str@var83 ) ;
84: static bool isFloat ( const std :: string & str@var84 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var85 ) ;
86: static bool isNegative ( const std :: string & str@var86 ) ;
87: static bool isPositive ( const std :: string & str@var87 ) ;
88: static bool isDec ( const std :: string & str@var88 ) ;
89: static bool isFloatHex ( const std :: string & str@var89 ) ;
90: static bool isIntHex ( const std :: string & str@var90 ) ;
91: static bool isOct ( const std :: string & str@var91 ) ;
92: static bool isBin ( const std :: string & str@var92 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var93 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var94 , bool supportMicrosoftExtensions@var95 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var96 , const std :: string & second@var97 ) ;
105: static std :: string subtract ( const std :: string & first@var98 , const std :: string & second@var99 ) ;
106: static std :: string multiply ( const std :: string & first@var100 , const std :: string & second@var101 ) ;
107: static std :: string divide ( const std :: string & first@var102 , const std :: string & second@var103 ) ;
108: static std :: string mod ( const std :: string & first@var104 , const std :: string & second@var105 ) ;
109: static std :: string incdec ( const std :: string & var@var106 , const std :: string & op@var107 ) ;
110: static std :: string calculate ( const std :: string & first@var108 , const std :: string & second@var109 , char action@var110 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var111 ) ;
113: static std :: string cos ( const std :: string & tok@var112 ) ;
114: static std :: string tan ( const std :: string & tok@var113 ) ;
115: static std :: string abs ( const std :: string & tok@var114 ) ;
116: static bool isEqual ( const std :: string & first@var115 , const std :: string & second@var116 ) ;
117: static bool isNotEqual ( const std :: string & first@var117 , const std :: string & second@var118 ) ;
118: static bool isGreater ( const std :: string & first@var119 , const std :: string & second@var120 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var121 , const std :: string & second@var122 ) ;
120: static bool isLess ( const std :: string & first@var123 , const std :: string & second@var124 ) ;
121: static bool isLessEqual ( const std :: string & first@var125 , const std :: string & second@var126 ) ;
122: static bool isNullValue ( const std :: string & str@var127 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var128 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var129 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var130 , std :: string :: size_type iPos@var131 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var132 , const MathLib :: value & v2@var133 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var134 , const MathLib :: value & v2@var135 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var136 , const MathLib :: value & v2@var137 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var138 , const MathLib :: value & v2@var139 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var140 , const MathLib :: value & v2@var141 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var142 , const MathLib :: value & v2@var143 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var144 , const MathLib :: value & v2@var145 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var146 , const MathLib :: value & v2@var147 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var148 , const MathLib :: value & v2@var149 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var150 , const MathLib :: value & v2@var151 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var152 ) ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var153 ) const {
35: return p@var153 .@expr1073744782 first@var154 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var155 ) const {
42: return p@var155 .@expr1073744783 second@var156 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var157 , const T & x@var158 )
48: {
49: return std ::@expr1073744784 find (@expr1073744785 r@var157 .@expr1073744786 begin (@expr1073744787 ) , r@var157 .@expr2964 end (@expr2965 ) , x@var158 ) !=@expr1073744790 r@var157 .@expr2964 end (@expr2965 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var159 , const T & x@var160 )
54: {
55: return std ::@expr1073744793 find (@expr1073744794 r@var159 .@expr1073744795 begin (@expr1073744796 ) , r@var159 .@expr2973 end (@expr2974 ) , x@var160 ) !=@expr1073744799 r@var159 .@expr2973 end (@expr2974 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var161 , const U & x@var162 )
60: {
61: return std ::@expr1073744802 find (@expr1073744803 r@var161 .@expr1073744804 begin (@expr1073744805 ) , r@var161 .@expr2982 end (@expr2983 ) , x@var162 ) !=@expr1073744808 r@var161 .@expr2982 end (@expr2983 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var163 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744811 t@var163 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var164 , char c@var165 )
74: {
75: return !@expr1073744812 str@var164 .@expr1073744813 empty (@expr1073744814 ) &&@expr1073744815 str@var164 .@expr1073744816 back (@expr1073744817 ) ==@expr1073744818 c@var165 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var166 , const char end@var167 [ ] , unsigned long endlen@var168 )
79: {
80: return (@expr2995 str@var166 .@expr2996 size (@expr2997 ) >=@expr1073744822 endlen@var168 ) &&@expr1073744823 (@expr2995 str@var166 .@expr1073744825 compare (@expr1073744826 str@var166 .@expr2996 size (@expr2997 ) -@expr1073744829 endlen@var168 , endlen@var168 , end@var167 ) ==@expr1073744830 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var169 , const char ( & end@var170 ) [ N ] )
85: {
86: return endsWith (@expr1073744832 str@var169 , end@var170 , N@expr1073744831 -@expr1073744833 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var171 , char q@var172 , const std :: string & p@var173 )
90: {
91: if (@expr1073744834 !@expr1073744835 endsWith (@expr1073744836 str@var171 , q@var172 ) ) {
92: return false ; }
93: if (@expr1073744837 (@expr1073744838 str@var171 .@expr1073744839 length (@expr1073744840 ) +@expr1073744841 1 ) >@expr1073744842 p@var173 .@expr1073744843 length (@expr1073744844 ) &&@expr1073744845 (@expr1073744846 str@var171 .@expr1073744847 compare (@expr1073744848 0 , p@var173 .@expr1073744849 size (@expr1073744850 ) +@expr1073744851 1 , p@var173 +@expr1073744852 q@var172 ) ==@expr1073744853 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var174 , char q@var175 )
99: {
100: static const std ::@expr3030 vector < std ::@expr3030 string > suffixes@var176 {@expr1073744856 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744857 const std ::@expr3030 string &@expr1073744859 p@var177 :@expr1073744860 suffixes@var176 ) {
102: if (@expr1073744861 isPrefixStringCharLiteral (@expr1073744862 str@var174 , q@var175 , p@var177 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var178 )
109: {
110: return isStringCharLiteral (@expr1073744863 str@var178 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var179 )
114: {
115: return isStringCharLiteral (@expr1073744864 str@var179 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var180 , char q@var181 )
119: {
120: const unsigned long quotePos@var182 =@expr1073744865 str@var180 .@expr1073744866 find (@expr1073744867 q@var181 ) ;
121: return str@var180 .@expr1073744868 substr (@expr1073744869 quotePos@var182 +@expr1073744870 1U , str@var180 .@expr1073744871 size (@expr1073744872 ) -@expr1073744873 quotePos@var182 -@expr1073744874 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var183 )
125: {
126: if (@expr1073744875 isStringLiteral (@expr1073744876 str@var183 ) ) {
127: return getStringCharLiteral (@expr1073744877 str@var183 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var184 )
132: {
133: if (@expr1073744878 isCharLiteral (@expr1073744879 str@var184 ) ) {
134: return getStringCharLiteral (@expr1073744880 str@var184 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var185 )
139: {
140: if (@expr1073744881 i@var185 ==@expr1073744882 1 ) {
141: return "st" ; }
142: if (@expr1073744883 i@var185 ==@expr1073744884 2 ) {
143: return "nd" ; }
144: if (@expr1073744885 i@var185 ==@expr1073744886 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var186 , const std :: string & rhs@var187 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var188 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var189 , const std :: string & name@var190 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var191 , const std :: string & name@var192 ) ;
156:
157: void strTolower ( std :: string & str@var193 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var194 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var195 ;
42:
43:
44: std :: string stdValue@var196 ;
45:
46:
47: Standards ( ) : c@var194 ( CLatest ) , cpp@var195 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var197 ) {
50: stdValue@var196 =@expr1073744887 str@var197 ;
51: if (@expr1073744888 str@var197 ==@expr1073744889 "c89" ||@expr1073744890 str@var197 ==@expr1073744891 "C89" ) {
52: c@var194 =@expr1073744892 C89 ;
53: return true ;
54: }
55: if (@expr1073744893 str@var197 ==@expr1073744894 "c99" ||@expr1073744895 str@var197 ==@expr1073744896 "C99" ) {
56: c@var194 =@expr1073744897 C99 ;
57: return true ;
58: }
59: if (@expr1073744898 str@var197 ==@expr1073744899 "c11" ||@expr1073744900 str@var197 ==@expr1073744901 "C11" ) {
60: c@var194 =@expr1073744902 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744903 c@var194 ) {
67: case C89 :@expr3080 ;
68: return "c89" ;
69: case C99 :@expr3080 ;
70: return "c99" ;
71: case C11 :@expr3080 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var198 ) {
77: if (@expr1073744907 std@var198 ==@expr1073744908 "c89" ) {
78: return Standards ::@expr1073744909 C89 ;
79: }
80: if (@expr1073744910 std@var198 ==@expr1073744911 "c99" ) {
81: return Standards ::@expr1073744912 C99 ;
82: }
83: if (@expr1073744913 std@var198 ==@expr1073744914 "c11" ) {
84: return Standards ::@expr1073744915 C11 ;
85: }
86: return Standards ::@expr1073744916 CLatest ;
87: }
88: bool setCPP ( std :: string str@var199 ) {
89: stdValue@var196 =@expr1073744917 str@var199 ;
90: strTolower (@expr1073744918 str@var199 ) ;
91: cpp@var195 =@expr1073744919 getCPP (@expr1073744920 str@var199 ) ;
92: return !@expr1073744921 stdValue@var196 .@expr1073744922 empty (@expr1073744923 ) &&@expr1073744924 str@var199 ==@expr1073744925 getCPP (@expr1073744926 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744927 cpp@var195 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var200 ) {
98: switch (@expr1073744928 std@var200 ) {
99: case CPP03 :@expr3105 ;
100: return "c++03" ;
101: case CPP11 :@expr3105 ;
102: return "c++11" ;
103: case CPP14 :@expr3105 ;
104: return "c++14" ;
105: case CPP17 :@expr3105 ;
106: return "c++17" ;
107: case CPP20 :@expr3105 ;
108: return "c++20" ;
109: case CPP23 :@expr3105 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var201 ) {
115: if (@expr1073744935 std@var201 ==@expr1073744936 "c++03" ) {
116: return Standards ::@expr1073744937 CPP03 ;
117: }
118: if (@expr1073744938 std@var201 ==@expr1073744939 "c++11" ) {
119: return Standards ::@expr1073744940 CPP11 ;
120: }
121: if (@expr1073744941 std@var201 ==@expr1073744942 "c++14" ) {
122: return Standards ::@expr1073744943 CPP14 ;
123: }
124: if (@expr1073744944 std@var201 ==@expr1073744945 "c++17" ) {
125: return Standards ::@expr1073744946 CPP17 ;
126: }
127: if (@expr1073744947 std@var201 ==@expr1073744948 "c++20" ) {
128: return Standards ::@expr1073744949 CPP20 ;
129: }
130: if (@expr1073744950 std@var201 ==@expr1073744951 "c++23" ) {
131: return Standards ::@expr1073744952 CPP23 ;
132: }
133: return Standards ::@expr1073744953 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var205 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var202 ) : errorcode@var205 ( e@var202 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var203 , T && r@var204 ) : errorcode@var205 ( e@var203 ) , reason@var206 ( r@var204 ) { }
66: ErrorCode errorcode@var205 ;
67: std :: string reason@var206 ;
68: } ;
69:
70: Error load ( const char exename@var207 [ ] , const char path@var208 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var209 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var210 [ ] , unsigned long len@var211 ) ;
75:
76: struct AllocFunc {
77: int groupId@var212 ;
78: int arg@var213 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var214 ;
81: int bufferSizeArg1@var215 ;
82: int bufferSizeArg2@var216 ;
83: int reallocArg@var217 ;
84: bool initData@var218 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var219 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var220 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var221 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var222 , int arg@var223 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var224 , int arg@var225 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var226 , int arg@var227 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var228 [ ] ) const {
107: return getAllocDealloc (@expr1073744954 mAlloc@var494 , name@var228 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var229 [ ] ) const {
112: return getAllocDealloc (@expr1073744955 mDealloc@var495 , name@var229 ) ;
113: }
114:
115:
116: int allocId ( const char name@var230 [ ] ) const {
117: const AllocFunc * af@var231 ; af@var231 =@expr1073744956 getAllocDealloc (@expr1073744957 mAlloc@var494 , name@var230 ) ;
118: return af@var231 ?@expr1073744958 af@var231 .@expr1073744959 groupId@var232 :@expr1073744960 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var233 [ ] ) const {
123: const AllocFunc * af@var234 ; af@var234 =@expr1073744961 getAllocDealloc (@expr1073744962 mDealloc@var495 , name@var233 ) ;
124: return af@var234 ?@expr1073744963 af@var234 .@expr1073744964 groupId@var235 :@expr1073744965 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var236 , int id@var237 , int arg@var238 ) {
129: mAlloc@var494 [@expr3142 functionname@var236 ] .@expr1073744967 groupId@var2928 =@expr1073744968 id@var237 ;
130: mAlloc@var494 [@expr3142 functionname@var236 ] .@expr1073744970 arg@var2929 =@expr1073744971 arg@var238 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var239 , int id@var240 , int arg@var241 ) {
134: mDealloc@var495 [@expr3148 functionname@var239 ] .@expr1073744973 groupId@var2930 =@expr1073744974 id@var240 ;
135: mDealloc@var495 [@expr3148 functionname@var239 ] .@expr1073744976 arg@var2931 =@expr1073744977 arg@var241 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var242 , int id@var243 , int arg@var244 , int reallocArg@var245 = 1 ) {
139: mRealloc@var496 [@expr3154 functionname@var242 ] .@expr1073744979 groupId@var2932 =@expr1073744980 id@var243 ;
140: mRealloc@var496 [@expr3154 functionname@var242 ] .@expr1073744982 arg@var2933 =@expr1073744983 arg@var244 ;
141: mRealloc@var496 [@expr3154 functionname@var242 ] .@expr1073744985 reallocArg@var2934 =@expr1073744986 reallocArg@var245 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var246 , bool noreturn@var247 ) {
146: mNoReturn@var497 [@expr1073744987 funcname@var246 ] =@expr1073744988 noreturn@var247 ?@expr1073744989 FalseTrueMaybe ::@expr1073744990 True :@expr1073744991 FalseTrueMaybe ::@expr1073744992 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var248 ) ;
150:
151:
152: static bool ismemory ( const int id@var249 ) {
153: return (@expr3169 (@expr3169 id@var249 >@expr1073744995 0 ) &&@expr1073744996 (@expr3169 (@expr3169 id@var249 &@expr1073744999 1 ) ==@expr1073745000 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var250 ) {
156: return (@expr3177 (@expr3177 func@var250 .@expr3179 groupId@var251 >@expr1073745004 0 ) &&@expr1073745005 (@expr3177 (@expr3177 func@var250 .@expr3179 groupId@var251 &@expr1073745009 1 ) ==@expr1073745010 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var252 ) {
161: return (@expr3187 (@expr3187 id@var252 >@expr1073745013 0 ) &&@expr1073745014 (@expr3187 (@expr3187 id@var252 &@expr1073745017 1 ) ==@expr1073745018 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var253 ) {
164: return (@expr3195 (@expr3195 func@var253 .@expr3197 groupId@var254 >@expr1073745022 0 ) &&@expr1073745023 (@expr3195 (@expr3195 func@var253 .@expr3197 groupId@var254 &@expr1073745027 1 ) ==@expr1073745028 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var255 ) const ;
168: int formatstr_argno ( const Token * ftok@var256 ) const ;
169: bool formatstr_scan ( const Token * ftok@var257 ) const ;
170: bool formatstr_secure ( const Token * ftok@var258 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var259 ;
174: int ptr2Arg@var260 ;
175: int sizeArg@var261 ;
176: int strlenArg@var262 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var263 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var264 ;
182: Standards standards@var265 ;
183: Severity :: SeverityType severity@var266 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var267 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var268 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var269 ) const ;
191: bool matchArguments ( const Token * ftok@var270 , const std :: string & functionName@var271 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var272 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var273 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var274 ) const ;
198: int returnValueContainer ( const Token * ftok@var275 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var276 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var277 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var278 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var279 , std :: string * unknownFunc@var280 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var290 ( -1 ) ,
210: size_templateArgNo@var292 ( -1 ) ,
211: arrayLike_indexOp@var293 ( false ) ,
212: stdStringLike@var294 ( false ) ,
213: stdAssociativeLike@var295 ( false ) ,
214: opLessAllowed@var296 ( true ) ,
215: hasInitializerListConstructor@var297 ( false ) ,
216: unstableErase@var298 ( false ) ,
217: unstableInsert@var299 ( false ) ,
218: view@var300 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var281 ;
248: Yield yield@var282 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var283 ;
252: int templateParameter@var284 ;
253: } ;
254: std :: string startPattern@var285 ; std :: string startPattern2@var286 ; std :: string endPattern@var287 ; std :: string itEndPattern@var288 ;
255: std :: map < std :: string , Function > functions@var289 ;
256: int type_templateArgNo@var290 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var291 ;
258: int size_templateArgNo@var292 ;
259: bool arrayLike_indexOp@var293 ;
260: bool stdStringLike@var294 ;
261: bool stdAssociativeLike@var295 ;
262: bool opLessAllowed@var296 ;
263: bool hasInitializerListConstructor@var297 ;
264: bool unstableErase@var298 ;
265: bool unstableInsert@var299 ;
266: bool view@var300 ;
267:
268: Action getAction ( const std :: string & function@var301 ) const {
269: const std ::@expr1073745029 map < std ::@expr1073745030 string , Function > ::@expr1073745031 const_iterator i@var302 =@expr1073745032 functions@var289 .@expr1073745033 find (@expr1073745034 function@var301 ) ;
270: if (@expr1073745035 i@var302 !=@expr1073745036 functions@var289 .@expr1073745037 end (@expr1073745038 ) ) {
271: return i@var302 .@expr1073745039 second@var303 .@expr1073745040 action@var304 ; }
272: return Action ::@expr1073745041 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var305 ) const {
276: const std ::@expr1073745042 map < std ::@expr1073745043 string , Function > ::@expr1073745044 const_iterator i@var306 =@expr1073745045 functions@var289 .@expr1073745046 find (@expr1073745047 function@var305 ) ;
277: if (@expr1073745048 i@var306 !=@expr1073745049 functions@var289 .@expr1073745050 end (@expr1073745051 ) ) {
278: return i@var306 .@expr1073745052 second@var307 .@expr1073745053 yield@var308 ; }
279: return Yield ::@expr1073745054 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var309 ) ;
283: static Action actionFrom ( const std :: string & actionName@var310 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var311 ;
286: const Container * detectContainer ( const Token * typeStart@var312 , bool iterator@var313 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var314 , bool * isIterator@var315 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var316 ( false ) ,
293: notnull@var317 ( false ) ,
294: notuninit@var318 ( -1 ) ,
295: formatstr@var319 ( false ) ,
296: strz@var320 ( false ) ,
297: optional@var321 ( false ) ,
298: variadic@var322 ( false ) ,
299: iteratorInfo@var328 ( ) ,
300: direction@var336 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var316 ;
303: bool notnull@var317 ;
304: int notuninit@var318 ;
305: bool formatstr@var319 ;
306: bool strz@var320 ;
307: bool optional@var321 ;
308: bool variadic@var322 ;
309: std :: string valid@var323 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var324 ( 0 ) , it@var325 ( false ) , first@var326 ( false ) , last@var327 ( false ) { }
314:
315: int container@var324 ;
316: bool it@var325 ;
317: bool first@var326 ;
318: bool last@var327 ;
319: } ;
320: IteratorInfo iteratorInfo@var328 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var329 , int a@var330 ) : type@var331 ( t@var329 ) , arg@var332 ( a@var330 ) , arg2@var333 ( 0 ) , value@var334 ( 0 ) { }
326: Type type@var331 ;
327: int arg@var332 ;
328: int arg2@var333 ;
329: long long value@var334 ;
330: } ;
331: std :: vector < MinSize > minsizes@var335 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var336 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var337 ;
344: bool use@var338 ;
345: bool leakignore@var339 ;
346: bool isconst@var340 ;
347: bool ispure@var341 ;
348: UseRetValType useretval@var342 ;
349: bool ignore@var343 ;
350: bool formatstr@var344 ;
351: bool formatstr_scan@var345 ;
352: bool formatstr_secure@var346 ;
353: Container :: Action containerAction@var347 ;
354: Container :: Yield containerYield@var348 ;
355: Function ( )
356: : use@var338 ( false ) ,
357: leakignore@var339 ( false ) ,
358: isconst@var340 ( false ) ,
359: ispure@var341 ( false ) ,
360: useretval@var342 ( UseRetValType :: NONE ) ,
361: ignore@var343 ( false ) ,
362: formatstr@var344 ( false ) ,
363: formatstr_scan@var345 ( false ) ,
364: formatstr_secure@var346 ( false ) ,
365: containerAction@var347 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var348 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var349 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var350 ;
372: bool isUse ( const std :: string & functionName@var351 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var352 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var353 , bool pure@var354 ) const ;
375: bool isFunctionConst ( const Token * ftok@var355 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var356 , int argnr@var357 ) const {
378: const ArgumentChecks * arg@var358 ; arg@var358 =@expr1073745055 getarg (@expr1073745056 ftok@var356 , argnr@var357 ) ;
379: return arg@var358 &&@expr1073745057 arg@var358 .@expr1073745058 notbool@var359 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var360 , int argnr@var361 ) const ;
383: bool isuninitargbad ( const Token * ftok@var362 , int argnr@var363 , int indirect@var364 = 0 , bool * hasIndirect@var365 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var366 , int argnr@var367 ) const {
386: const ArgumentChecks * arg@var368 ; arg@var368 =@expr1073745059 getarg (@expr1073745060 ftok@var366 , argnr@var367 ) ;
387: return arg@var368 &&@expr1073745061 arg@var368 .@expr1073745062 formatstr@var369 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var370 , int argnr@var371 ) const {
391: const ArgumentChecks * arg@var372 ; arg@var372 =@expr1073745063 getarg (@expr1073745064 ftok@var370 , argnr@var371 ) ;
392: return arg@var372 &&@expr1073745065 arg@var372 .@expr1073745066 strz@var373 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var374 , int argnr@var375 , const long long argvalue@var376 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var377 , int argnr@var378 , double argvalue@var379 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var380 , int argnr@var381 ) const {
399: const ArgumentChecks * arg@var382 ; arg@var382 =@expr1073745067 getarg (@expr1073745068 ftok@var380 , argnr@var381 ) ;
400: return arg@var382 ?@expr1073745069 arg@var382 .@expr1073745070 valid@var383 :@expr1073745071 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var384 ;
405: std :: string op1@var385 ;
406: std :: string op2@var386 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745072 isInt (@expr1073745073 op1@var385 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var387 , int argnr@var388 ) const {
413: const ArgumentChecks * arg@var389 ; arg@var389 =@expr1073745074 getarg (@expr1073745075 ftok@var387 , argnr@var388 ) ;
414: return arg@var389 &&@expr1073745076 arg@var389 .@expr3253 iteratorInfo@var390 .@expr1073745078 it@var391 ?@expr1073745079 &@expr1073745080 arg@var389 .@expr3253 iteratorInfo@var390 :@expr1073745082 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var392 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var393 , int argnr@var394 ) const {
420: const ArgumentChecks * arg@var395 ; arg@var395 =@expr1073745083 getarg (@expr1073745084 ftok@var393 , argnr@var394 ) ;
421: return arg@var395 ?@expr1073745085 &@expr1073745086 arg@var395 .@expr1073745087 minsizes@var396 :@expr1073745088 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var397 , int argnr@var398 ) const ;
425:
426: bool markupFile ( const std :: string & path@var399 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var400 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var504 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var401 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var402 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var403 , const std :: string & token@var404 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var405 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var406 ) const ;
443: const std :: string & blockend ( const std :: string & file@var407 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var408 , const std :: string & keyword@var409 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var410 ) const {
448: return mExporters@var507 .@expr1073745089 find (@expr1073745090 prefix@var410 ) !=@expr1073745091 mExporters@var507 .@expr1073745092 end (@expr1073745093 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var411 , const std :: string & token@var412 ) const {
452: const std ::@expr1073745094 map < std ::@expr1073745095 string , ExportedFunctions > ::@expr1073745096 const_iterator it@var413 =@expr1073745097 mExporters@var507 .@expr1073745098 find (@expr1073745099 prefix@var411 ) ;
453: return (@expr1073745100 it@var413 !=@expr1073745101 mExporters@var507 .@expr1073745102 end (@expr1073745103 ) &&@expr1073745104 it@var413 .@expr1073745105 second@var414 .@expr1073745106 isPrefix (@expr1073745107 token@var412 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var415 , const std :: string & token@var416 ) const {
457: const std ::@expr1073745108 map < std ::@expr1073745109 string , ExportedFunctions > ::@expr1073745110 const_iterator it@var417 =@expr1073745111 mExporters@var507 .@expr1073745112 find (@expr1073745113 prefix@var415 ) ;
458: return (@expr1073745114 it@var417 !=@expr1073745115 mExporters@var507 .@expr1073745116 end (@expr1073745117 ) &&@expr1073745118 it@var417 .@expr1073745119 second@var418 .@expr1073745120 isSuffix (@expr1073745121 token@var416 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var419 , const std :: string & importer@var420 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var421 , Container :: Yield yield@var422 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var423 , Container :: Action action@var424 ) const ;
465:
466: bool isreflection ( const std :: string & token@var425 ) const {
467: return mReflection@var509 .@expr1073745122 find (@expr1073745123 token@var425 ) !=@expr1073745124 mReflection@var509 .@expr1073745125 end (@expr1073745126 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var426 ) const {
471: const std ::@expr1073745127 map < std ::@expr1073745128 string , int > ::@expr1073745129 const_iterator it@var427 =@expr1073745130 mReflection@var509 .@expr1073745131 find (@expr1073745132 token@var426 ) ;
472: if (@expr1073745133 it@var427 !=@expr1073745134 mReflection@var509 .@expr1073745135 end (@expr1073745136 ) ) {
473: return it@var427 .@expr1073745137 second@var428 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var429 ;
478:
479: struct SmartPointer {
480: std :: string name@var430 ; name@var430 = "" ;
481: bool unique@var431 ; unique@var431 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var432 ;
485: bool isSmartPointer ( const Token * tok@var433 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var434 ) const ;
487:
488: struct PodType {
489: unsigned int size@var435 ;
490: char sign@var436 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var437 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var438 ) const {
494: const std ::@expr1073745138 unordered_map < std ::@expr1073745139 string , PodType > ::@expr1073745140 const_iterator it@var439 =@expr1073745141 mPodTypes@var510 .@expr1073745142 find (@expr1073745143 name@var438 ) ;
495: return (@expr3320 it@var439 !=@expr1073745145 mPodTypes@var510 .@expr1073745146 end (@expr1073745147 ) ) ?@expr1073745148 &@expr1073745149 (@expr3320 it@var439 .@expr1073745151 second@var440 ) :@expr1073745152 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var451 ( false )
501: , mUnsigned@var452 ( false )
502: , mLong@var453 ( false )
503: , mPointer@var454 ( false )
504: , mPtrPtr@var455 ( false )
505: , mConstPtr@var456 ( false ) { }
506: bool operator== ( const PlatformType & type@var441 ) const {
507: return (@expr1073745153 mSigned@var451 ==@expr1073745154 type@var441 .@expr1073745155 mSigned@var442 &&@expr1073745156
508: mUnsigned@var452 ==@expr1073745157 type@var441 .@expr1073745158 mUnsigned@var443 &&@expr1073745159
509: mLong@var453 ==@expr1073745160 type@var441 .@expr1073745161 mLong@var444 &&@expr1073745162
510: mPointer@var454 ==@expr1073745163 type@var441 .@expr1073745164 mPointer@var445 &&@expr1073745165
511: mPtrPtr@var455 ==@expr1073745166 type@var441 .@expr1073745167 mPtrPtr@var446 &&@expr1073745168
512: mConstPtr@var456 ==@expr1073745169 type@var441 .@expr1073745170 mConstPtr@var447 &&@expr1073745171
513: mType@var450 ==@expr1073745172 type@var441 .@expr1073745173 mType@var448 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var449 ) const {
516: return !@expr1073745174 (@expr1073745175 *@expr1073745176 this@expr1073745177 ==@expr1073745178 type@var449 ) ;
517: }
518: std :: string mType@var450 ;
519: bool mSigned@var451 ;
520: bool mUnsigned@var452 ;
521: bool mLong@var453 ;
522: bool mPointer@var454 ;
523: bool mPtrPtr@var455 ;
524: bool mConstPtr@var456 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var457 ) const {
529: const std ::@expr1073745179 map < std ::@expr1073745180 string , PlatformType > ::@expr1073745181 const_iterator it@var458 =@expr1073745182 mPlatformTypes@var460 .@expr1073745183 find (@expr1073745184 name@var457 ) ;
530: return (@expr3361 it@var458 !=@expr1073745186 mPlatformTypes@var460 .@expr1073745187 end (@expr1073745188 ) ) ?@expr1073745189 &@expr1073745190 (@expr3361 it@var458 .@expr1073745192 second@var459 ) :@expr1073745193 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var460 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var461 , const std :: string & platform@var462 ) const {
536: const std ::@expr1073745194 map < std ::@expr3371 string , Platform > ::@expr1073745196 const_iterator it@var463 =@expr1073745197 mPlatforms@var512 .@expr1073745198 find (@expr1073745199 platform@var462 ) ;
537: if (@expr1073745200 it@var463 !=@expr1073745201 mPlatforms@var512 .@expr1073745202 end (@expr1073745203 ) ) {
538: const PlatformType * const type@var464 ; type@var464 =@expr1073745204 it@var463 .@expr1073745205 second@var465 .@expr1073745206 platform_type (@expr1073745207 name@var461 ) ;
539: if (@expr1073745208 type@var464 ) {
540: return type@var464 ; }
541: }
542:
543: const std ::@expr1073745209 map < std ::@expr3371 string , PlatformType > ::@expr1073745211 const_iterator it2@var466 =@expr1073745212 mPlatformTypes@var511 .@expr1073745213 find (@expr1073745214 name@var461 ) ;
544: return (@expr3391 it2@var466 !=@expr1073745216 mPlatformTypes@var511 .@expr1073745217 end (@expr1073745218 ) ) ?@expr1073745219 &@expr1073745220 (@expr3391 it2@var466 .@expr1073745222 second@var467 ) :@expr1073745223 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var468 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var469 , Library :: Container :: Yield y@var470 , const std :: string & fallback@var471 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var472 , const std :: string & typeName@var473 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var474 , const std :: string & name@var475 , std :: set < std :: string > & unknown_elements@var476 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var477 ) {
565: mPrefixes@var481 .@expr1073745224 insert (@expr1073745225 prefix@var477 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var478 ) {
568: mSuffixes@var482 .@expr1073745226 insert (@expr1073745227 suffix@var478 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var479 ) const {
571: return (@expr1073745228 mPrefixes@var481 .@expr1073745229 find (@expr1073745230 prefix@var479 ) !=@expr1073745231 mPrefixes@var481 .@expr1073745232 end (@expr1073745233 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var480 ) const {
574: return (@expr1073745234 mSuffixes@var482 .@expr1073745235 find (@expr1073745236 suffix@var480 ) !=@expr1073745237 mSuffixes@var482 .@expr1073745238 end (@expr1073745239 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var481 ;
579: std :: set < std :: string > mSuffixes@var482 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var490 ( 0 ) { }
584:
585: void setStart ( const char * s@var483 ) {
586: mStart@var488 =@expr1073745240 s@var483 ;
587: }
588: void setEnd ( const char * e@var484 ) {
589: mEnd@var489 =@expr1073745241 e@var484 ;
590: }
591: void setOffset ( const int o@var485 ) {
592: mOffset@var490 =@expr1073745242 o@var485 ;
593: }
594: void addBlock ( const char * blockName@var486 ) {
595: mBlocks@var491 .@expr1073745243 insert (@expr1073745244 blockName@var486 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var488 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var489 ;
602: }
603: int offset ( ) const {
604: return mOffset@var490 ;
605: }
606: bool isBlock ( const std :: string & blockName@var487 ) const {
607: return mBlocks@var491 .@expr1073745245 find (@expr1073745246 blockName@var487 ) !=@expr1073745247 mBlocks@var491 .@expr1073745248 end (@expr1073745249 ) ;
608: }
609:
610: private:
611: std :: string mStart@var488 ;
612: std :: string mEnd@var489 ;
613: int mOffset@var490 ;
614: std :: set < std :: string > mBlocks@var491 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var492 ;
618: std :: set < std :: string > mFiles@var493 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var494 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var495 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var496 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var497 ;
623: std :: map < std :: string , std :: string > mReturnValue@var498 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var499 ;
625: std :: map < std :: string , int > mReturnValueContainer@var500 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var501 ;
627: std :: map < std :: string , bool > mReportErrors@var502 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var503 ;
629: std :: set < std :: string > mMarkupExtensions@var504 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var505 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var506 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var507 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var508 ;
634: std :: map < std :: string , int > mReflection@var509 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var510 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var511 ;
637: std :: map < std :: string , Platform > mPlatforms@var512 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var513 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var514 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var515 , int argnr@var516 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var517 , bool * error@var518 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var519 , const std :: string & name@var520 ) {
646: const std ::@expr1073745250 map < std ::@expr1073745251 string , AllocFunc > ::@expr1073745252 const_iterator it@var521 =@expr1073745253 data@var519 .@expr1073745254 find (@expr1073745255 name@var520 ) ;
647: return (@expr1073745256 it@var521 ==@expr1073745257 data@var519 .@expr1073745258 end (@expr1073745259 ) ) ?@expr1073745260 nullptr :@expr1073745261 &@expr1073745262 it@var521 .@expr1073745263 second@var522 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var523 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var524 ,
654: const Settings * settings@var525 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var526 = nullptr ) ;

##file cppcheck-2.8/lib/checkleakautovar.h

1:
|
33:
34: class ErrorLogger ;
35: class Settings ;
36: class Token ;
37: class Tokenizer ;
38:
39:
40: class VarInfo {
41: public:
42: enum AllocStatus { REALLOC = -3 , OWNED = -2 , DEALLOC = -1 , NOALLOC = 0 , ALLOC = 1 } ;
43: struct AllocInfo {
44: AllocStatus status@var527 ;
45:
|
48:
49: int type@var528 ;
50: int reallocedFromType@var529 ; reallocedFromType@var529 = -1 ;
51: const Token * allocTok@var530 ;
52: AllocInfo ( int type_@var531 = 0 , AllocStatus status_@var532 = NOALLOC , const Token * allocTok_@var533 = nullptr ) : status@var527 ( status_@var532 ) , type@var528 ( type_@var531 ) , allocTok@var530 ( allocTok_@var533 ) { }
53:
54: bool managed ( ) const {
55: return status@var527 <@expr1073745264 0 ;
56: }
57: } ;
58: std :: map < int , AllocInfo > alloctype@var534 ;
59: std :: map < int , std :: string > possibleUsage@var535 ;
60: std :: set < int > conditionalAlloc@var536 ;
61: std :: set < int > referenced@var537 ;
62:
63: void clear ( ) {
64: alloctype@var534 .@expr1073745265 clear (@expr1073745266 ) ;
65: possibleUsage@var535 .@expr1073745267 clear (@expr1073745268 ) ;
66: conditionalAlloc@var536 .@expr1073745269 clear (@expr1073745270 ) ;
67: referenced@var537 .@expr1073745271 clear (@expr1073745272 ) ;
68: }
69:
70: void erase ( int varid@var538 ) {
71: alloctype@var534 .@expr1073745273 erase (@expr1073745274 varid@var538 ) ;
72: possibleUsage@var535 .@expr1073745275 erase (@expr1073745276 varid@var538 ) ;
73: conditionalAlloc@var536 .@expr1073745277 erase (@expr1073745278 varid@var538 ) ;
74: referenced@var537 .@expr1073745279 erase (@expr1073745280 varid@var538 ) ;
75: }
76:
77: void swap ( VarInfo & other@var539 ) {
78: alloctype@var534 .@expr1073745281 swap (@expr1073745282 other@var539 .@expr1073745283 alloctype@var540 ) ;
79: possibleUsage@var535 .@expr1073745284 swap (@expr1073745285 other@var539 .@expr1073745286 possibleUsage@var541 ) ;
80: conditionalAlloc@var536 .@expr1073745287 swap (@expr1073745288 other@var539 .@expr1073745289 conditionalAlloc@var542 ) ;
81: referenced@var537 .@expr1073745290 swap (@expr1073745291 other@var539 .@expr1073745292 referenced@var543 ) ;
82: }
83:
84: void reallocToAlloc ( int varid@var544 ) {
85: const AllocInfo &@expr1073745293 alloc@var545 =@expr1073745294 alloctype@var534 [@expr1073745295 varid@var544 ] ;
86: if (@expr1073745296 alloc@var545 .@expr3473 reallocedFromType@var546 >=@expr1073745298 0 ) {
87: const std ::@expr1073745299 map < int , VarInfo ::@expr1073745300 AllocInfo > ::@expr1073745301 iterator it@var547 =@expr1073745302 alloctype@var534 .@expr1073745303 find (@expr1073745304 alloc@var545 .@expr3473 reallocedFromType@var546 ) ;
88: if (@expr1073745306 it@var547 !=@expr1073745307 alloctype@var534 .@expr1073745308 end (@expr1073745309 ) &&@expr1073745310 it@var547 .@expr3487 second@var548 .@expr3488 status@var549 ==@expr1073745313 REALLOC ) {
89: it@var547 .@expr3487 second@var548 .@expr3488 status@var549 =@expr1073745316 ALLOC ;
90: }
91: }
92: }
93:
94:
95: void possibleUsageAll ( const std :: string & functionName@var550 ) ;
96:
97: void print ( ) ;
98: } ;
99:
|
107:
108: class CheckLeakAutoVar : public Check {
109: public:
110:
111: CheckLeakAutoVar ( ) : Check ( myName ( ) ) { }
112:
113:
114: CheckLeakAutoVar ( const Tokenizer * tokenizer@var551 , const Settings * settings@var552 , ErrorLogger * errorLogger@var553 )
115: : Check ( myName ( ) , tokenizer@var551 , settings@var552 , errorLogger@var553 ) { }
116:
117: void runChecks ( const Tokenizer * tokenizer@var554 , const Settings * settings@var555 , ErrorLogger * errorLogger@var556 ) override {
118: CheckLeakAutoVar checkLeakAutoVar@var557 (@expr1073745317 tokenizer@var554 , settings@var555 , errorLogger@var556 ) ;
119: checkLeakAutoVar@var557 .@expr1073745318 check (@expr1073745319 ) ;
120: }
121:
122: private:
123:
124:
125: void check ( ) ;
126:
127:
128: void checkScope ( const Token * const startToken@var558 ,
129: VarInfo * varInfo@var559 ,
130: std :: set < int > notzero@var560 ,
131: int recursiveCount@var561 ) ;
132:
|
137:
138: const Token * checkTokenInsideExpression ( const Token * const tok@var562 , VarInfo * varInfo@var563 ) ;
139:
140:
141: void functionCall ( const Token * tokName@var564 , const Token * tokOpeningPar@var565 , VarInfo * varInfo@var566 , const VarInfo :: AllocInfo & allocation@var567 , const Library :: AllocFunc * af@var568 ) ;
142:
143:
144: void changeAllocStatus ( VarInfo * varInfo@var569 , const VarInfo :: AllocInfo & allocation@var570 , const Token * tok@var571 , const Token * arg@var572 ) ;
145:
146:
147: void changeAllocStatusIfRealloc ( std :: map < int , VarInfo :: AllocInfo > & alloctype@var573 , const Token * fTok@var574 , const Token * retTok@var575 ) ;
148:
149:
150: void ret ( const Token * tok@var576 , VarInfo & varInfo@var577 , const bool isEndOfScope@var578 = false ) ;
151:
152:
153: void leakIfAllocated ( const Token * vartok@var579 , const VarInfo & varInfo@var580 ) ;
154:
155: void leakError ( const Token * tok@var581 , const std :: string & varname@var582 , int type@var583 ) ;
156: void mismatchError ( const Token * deallocTok@var584 , const Token * allocTok@var585 , const std :: string & varname@var586 ) ;
157: void deallocUseError ( const Token * tok@var587 , const std :: string & varname@var588 ) ;
158: void deallocReturnError ( const Token * tok@var589 , const Token * deallocTok@var590 , const std :: string & varname@var591 ) ;
159: void doubleFreeError ( const Token * tok@var592 , const Token * prevFreeTok@var593 , const std :: string & varname@var594 , int type@var595 ) ;
160:
161:
162: void configurationInfo ( const Token * tok@var596 , const std :: string & functionName@var597 ) ;
163:
164: void getErrorMessages ( ErrorLogger * errorLogger@var598 , const Settings * settings@var599 ) const override {
165: CheckLeakAutoVar c@var600 (@expr1073745320 nullptr , settings@var599 , errorLogger@var598 ) ;
166: c@var600 .@expr1073745321 deallocReturnError (@expr1073745322 nullptr , nullptr , "p" ) ;
167: c@var600 .@expr1073745323 configurationInfo (@expr1073745324 nullptr , "f" ) ;
168: c@var600 .@expr1073745325 doubleFreeError (@expr1073745326 nullptr , nullptr , "varname" , 0 ) ;
169: }
170:
171: static std :: string myName ( ) {
172: return "Leaks (auto variables)" ;
173: }
174:
175: std :: string classInfo ( ) const override {
176: return "Detect when a auto variable is allocated but not deallocated or deallocated twice.\n" ;
177: }
178: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var601 ) const {
54: x@var601 ++@expr1073745327 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var602 ) const {
60: x@var602 --@expr1073745328 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var603 , const U & y@var604 ) const {
67: return x@var603 <@expr1073745329 y@var604 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var605 , const U & y@var606 ) const {
74: return std ::@expr1073745330 abs (@expr1073745331 x@var605 -@expr1073745332 y@var606 ) ==@expr1073745333 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var607 , T x@var608 , U y@var609 ) const {
81: result@var607 =@expr1073745334 !@expr1073745335 (@expr1073745336 x@var608 >@expr1073745337 y@var609 ||@expr1073745338 x@var608 <@expr1073745339 y@var609 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var610 = 0 , Bound b@var611 = Bound :: Point )
91: : valueType@var651 ( ValueType :: INT ) ,
92: bound@var652 ( b@var611 ) ,
93: intvalue@var653 ( val@var610 ) ,
94: tokvalue@var654 ( nullptr ) ,
95: floatValue@var655 ( 0.0 ) ,
96: moveKind@var656 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var657 ( val@var610 ) ,
98: condition@var658 ( nullptr ) ,
99: varId@var660 ( 0U ) ,
100: safe@var661 ( false ) ,
101: conditional@var662 ( false ) ,
102: macro@var663 ( false ) ,
103: defaultArg@var664 ( false ) ,
104: indirect@var665 ( 0 ) ,
105: path@var666 ( 0 ) ,
106: wideintvalue@var667 ( val@var610 ) ,
107: subexpressions@var668 ( ) ,
108: capturetok@var669 ( nullptr ) ,
109: lifetimeKind@var670 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var671 ( LifetimeScope :: Local ) ,
111: valueKind@var676 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var612 , long long val@var613 , Bound b@var614 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var615 ) const {
118: if (@expr1073745340 valueType@var651 !=@expr1073745341 rhs@var615 .@expr1073745342 valueType@var616 ) {
119: return false ; }
120: switch (@expr1073745343 valueType@var651 ) {
121: case ValueType ::@expr1073745344 INT :@expr3521
122: case ValueType ::@expr1073745346 CONTAINER_SIZE :@expr3521
123: case ValueType ::@expr1073745348 BUFFER_SIZE :@expr3521
124: case ValueType ::@expr1073745350 ITERATOR_START :@expr3521
125: case ValueType ::@expr1073745352 ITERATOR_END :@expr3521 ;
126: if (@expr3530 intvalue@var653 !=@expr3531 rhs@var615 .@expr3532 intvalue@var617 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745357 TOK :@expr3521 ;
130: if (@expr3535 tokvalue@var654 !=@expr3536 rhs@var615 .@expr3537 tokvalue@var618 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745362 FLOAT :@expr3521 ;
134:
135: if (@expr1073745364 floatValue@var655 >@expr1073745365 rhs@var615 .@expr3542 floatValue@var619 ||@expr1073745367 floatValue@var655 <@expr1073745368 rhs@var615 .@expr3542 floatValue@var619 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745370 MOVED :@expr3521 ;
139: if (@expr1073745372 moveKind@var656 !=@expr1073745373 rhs@var615 .@expr1073745374 moveKind@var620 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745375 UNINIT :@expr3521 ;
143: break ;
144: case ValueType ::@expr1073745377 LIFETIME :@expr3521 ;
145: if (@expr3535 tokvalue@var654 !=@expr3536 rhs@var615 .@expr3537 tokvalue@var618 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745382 SYMBOLIC :@expr3521 ;
149: if (@expr1073745384 !@expr1073745385 sameToken (@expr1073745386 tokvalue@var654 , rhs@var615 .@expr3537 tokvalue@var618 ) ) {
150: return false ; }
151: if (@expr3530 intvalue@var653 !=@expr3531 rhs@var615 .@expr3532 intvalue@var617 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var621 , F f@var622 ) {
160: switch (@expr1073745391 self@var621 .@expr1073745392 valueType@var623 ) {
161: case ValueType ::@expr1073745393 INT :@expr3570
162: case ValueType ::@expr1073745395 SYMBOLIC :@expr3570
163: case ValueType ::@expr1073745397 BUFFER_SIZE :@expr3570
164: case ValueType ::@expr1073745399 CONTAINER_SIZE :@expr3570
165: case ValueType ::@expr1073745401 ITERATOR_START :@expr3570
166: case ValueType ::@expr1073745403 ITERATOR_END :@expr3570 ; {
167: f@var622 (@expr1073745405 self@var621 .@expr1073745406 intvalue@var624 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745407 FLOAT :@expr3570 ; {
171: f@var622 (@expr1073745409 self@var621 .@expr1073745410 floatValue@var625 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745411 UNINIT :@expr3570
175: case ValueType ::@expr1073745413 TOK :@expr3570
176: case ValueType ::@expr1073745415 LIFETIME :@expr3570
177: case ValueType ::@expr1073745417 MOVED :@expr3570 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var626 , Compare compare@var627 , T x@var628 , U y@var629 ) const {
186: result@var626 =@expr1073745419 compare@var627 (@expr1073745420 x@var628 , y@var629 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var630 , const Value & rhs@var631 , Compare compare@var632 , T x@var633 ) const {
191: visitValue (@expr1073745422 rhs@var631 ,
192: std ::@expr1073745423 bind (@expr1073745424 innerVisitor {@expr1073745425 } , std ::@expr1073745426 ref (@expr1073745427 result@var630 ) , std ::@expr1073745428 move (@expr1073745429 compare@var632 ) , x@var633 , std ::@expr1073745430 placeholders ::@expr1073745431 _1@expr1073745421 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var634 , Compare compare@var635 ) const {
198: assert (@expr1073745433 (@expr1073745434 !@expr1073745435 this@expr3612 .@expr1073745437 isSymbolicValue (@expr1073745438 ) &&@expr1073745439 !@expr1073745440 rhs@var634 .@expr1073745441 isSymbolicValue (@expr1073745442 ) ) ||@expr1073745443
199: (@expr1073745444 this@expr3612 .@expr1073745445 valueType@var651 ==@expr1073745446 rhs@var634 .@expr1073745447 valueType@var636 &&@expr1073745448 sameToken (@expr1073745449 this@expr3612 .@expr1073745450 tokvalue@var654 , rhs@var634 .@expr1073745451 tokvalue@var637 ) ) ) ;
200: bool result@var638 ; result@var638 =@expr1073745452 false ;
201: visitValue (@expr1073745453
202: *@expr1073745454 this@expr3612 ,
203: std ::@expr1073745455 bind (@expr1073745456 compareVisitor {@expr1073745457 } , std ::@expr3634 ref (@expr1073745459 result@var638 ) , std ::@expr3634 ref (@expr1073745461 rhs@var634 ) , std ::@expr1073745462 move (@expr1073745463 compare@var635 ) , std ::@expr1073745464 placeholders ::@expr1073745465 _1@expr1073745432 ) ) ;
204: return result@var638 ;
205: }
206:
207: bool operator== ( const Value & rhs@var639 ) const {
208: if (@expr1073745466 !@expr1073745467 equalValue (@expr1073745468 rhs@var639 ) ) {
209: return false ; }
210:
211: return varvalue@var657 ==@expr1073745469 rhs@var639 .@expr1073745470 varvalue@var640 &&@expr1073745471
212: condition@var658 ==@expr1073745472 rhs@var639 .@expr1073745473 condition@var641 &&@expr1073745474
213: varId@var660 ==@expr1073745475 rhs@var639 .@expr1073745476 varId@var642 &&@expr1073745477
214: conditional@var662 ==@expr1073745478 rhs@var639 .@expr1073745479 conditional@var643 &&@expr1073745480
215: defaultArg@var664 ==@expr1073745481 rhs@var639 .@expr1073745482 defaultArg@var644 &&@expr1073745483
216: indirect@var665 ==@expr1073745484 rhs@var639 .@expr1073745485 indirect@var645 &&@expr1073745486
217: valueKind@var676 ==@expr1073745487 rhs@var639 .@expr1073745488 valueKind@var646 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var647 ) const {
221: return !@expr1073745489 (@expr1073745490 *@expr1073745491 this@expr1073745492 ==@expr1073745493 rhs@var647 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var648 ) const {
226: bool result@var649 ; result@var649 =@expr1073745495 false ;
227: visitValue (@expr1073745496 *@expr1073745497 this@expr1073745498 , std ::@expr1073745499 bind (@expr1073745500 equalVisitor {@expr1073745501 } , std ::@expr1073745502 ref (@expr1073745503 result@var649 ) , x@var648 , std ::@expr1073745504 placeholders ::@expr1073745505 _1@expr1073745494 ) ) ;
228: return result@var649 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745506 bound@var652 ==@expr1073745507 Bound ::@expr1073745508 Lower ) {
233: visitValue (@expr1073745509 *@expr3686 this@expr3687 , increment {@expr1073745512 } ) ; }
234: else { if (@expr1073745513 bound@var652 ==@expr1073745514 Bound ::@expr1073745515 Upper ) {
235: visitValue (@expr1073745516 *@expr3686 this@expr3687 , decrement {@expr1073745518 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745519 bound@var652 ==@expr1073745520 Bound ::@expr3697 Lower ) {
240: bound@var652 =@expr1073745522 Bound ::@expr3699 Upper ; }
241: else { if (@expr1073745524 bound@var652 ==@expr1073745525 Bound ::@expr3699 Upper ) {
242: bound@var652 =@expr1073745527 Bound ::@expr3697 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745529 ) ;
247: decreaseRange (@expr1073745530 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var650 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var651 ;
267: bool isIntValue ( ) const {
268: return valueType@var651 ==@expr1073745531 ValueType ::@expr1073745532 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var651 ==@expr1073745533 ValueType ::@expr1073745534 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var651 ==@expr1073745535 ValueType ::@expr1073745536 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var651 ==@expr1073745537 ValueType ::@expr1073745538 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var651 ==@expr1073745539 ValueType ::@expr1073745540 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var651 ==@expr1073745541 ValueType ::@expr1073745542 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var651 ==@expr1073745543 ValueType ::@expr1073745544 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var651 ==@expr1073745545 ValueType ::@expr1073745546 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var651 ==@expr1073745547 ValueType ::@expr1073745548 ITERATOR_START ||@expr1073745549 valueType@var651 ==@expr1073745550 ValueType ::@expr1073745551 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var651 ==@expr1073745552 ValueType ::@expr1073745553 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var651 ==@expr1073745554 ValueType ::@expr1073745555 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var651 ==@expr1073745556 ValueType ::@expr1073745557 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var651 ==@expr1073745559 ValueType ::@expr1073745560 LIFETIME &&@expr1073745561 lifetimeScope@var671 ==@expr1073745562 LifetimeScope ::@expr1073745563 Local@expr1073745558 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var651 ==@expr1073745564 ValueType ::@expr1073745565 LIFETIME &&@expr1073745566 lifetimeScope@var671 ==@expr1073745567 LifetimeScope ::@expr1073745568 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var651 ==@expr1073745569 ValueType ::@expr1073745570 LIFETIME &&@expr1073745571 lifetimeScope@var671 ==@expr1073745572 LifetimeScope ::@expr1073745573 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745574 ) ||@expr1073745575 isUninitValue (@expr1073745576 ) ||@expr1073745577 isLifetimeValue (@expr1073745578 ) ;
318: }
319:
320:
321: Bound bound@var652 ;
322:
323:
324: long long intvalue@var653 ;
325:
326:
327: const Token * tokvalue@var654 ;
328:
329:
330: double floatValue@var655 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var656 ;
334:
335:
336: long long varvalue@var657 ;
337:
338:
339: const Token * condition@var658 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var659 ;
342:
343:
344: int varId@var660 ;
345:
346:
347: bool safe@var661 ;
348:
349:
350: bool conditional@var662 ;
351:
352:
353: bool macro@var663 ;
354:
355:
356: bool defaultArg@var664 ;
357:
358: int indirect@var665 ;
359:
360:
361: long long path@var666 ;
362:
363:
364: long long wideintvalue@var667 ;
365:
366: std :: vector < std :: string > subexpressions@var668 ;
367:
368:
369: const Token * capturetok@var669 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var670 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var671 ;
385:
386: static const char * toString ( MoveKind moveKind@var672 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var673 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var674 ) ;
389: static const char * toString ( Bound bound@var675 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var676 ;
402:
403: void setKnown ( ) {
404: valueKind@var676 =@expr1073745579 ValueKind ::@expr1073745580 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var676 ==@expr1073745581 ValueKind ::@expr1073745582 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var676 =@expr1073745584 ValueKind ::@expr1073745585 Possible@expr1073745583 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var676 ==@expr1073745587 ValueKind ::@expr1073745588 Possible@expr1073745586 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var676 ==@expr1073745589 ValueKind ::@expr1073745590 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var676 =@expr1073745591 ValueKind ::@expr1073745592 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var677 = true ) {
428: if (@expr1073745593 inconclusive@var677 ) {
429: valueKind@var676 =@expr1073745594 ValueKind ::@expr1073745595 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var676 ==@expr1073745596 ValueKind ::@expr1073745597 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745599 isKnown (@expr1073745600 ) ) {
438: valueKind@var676 =@expr1073745601 ValueKind ::@expr1073745602 Possible@expr1073745598 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745603 condition@var658 &&@expr1073745604 !@expr1073745605 defaultArg@var664 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var678 , const Token * tok2@var679 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var680 , const Settings * settings@var681 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var682 , SymbolDatabase * symboldatabase@var683 , ErrorLogger * errorLogger@var684 , const Settings * settings@var685 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var686 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var687 , const Settings * settings@var688 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var689 ,
459: const Settings * settings@var690 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var691 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var692 , const Token * indexTok@var693 , bool possible@var694 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var695 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var696 , const Settings * settings@var697 = nullptr , int depth@var698 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var699 ;
471: bool addressOf@var700 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var701 ;
473: bool inconclusive@var702 ;
474:
475: LifetimeToken ( ) : token@var699 ( nullptr ) , addressOf@var700 ( false ) , errorPath@var701 ( ) , inconclusive@var702 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var703 , ValueFlow :: Value :: ErrorPath errorPath@var704 )
478: : token@var699 ( token@var703 ) , addressOf@var700 ( false ) , errorPath@var701 ( std :: move ( errorPath@var704 ) ) , inconclusive@var702 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var705 , bool addressOf@var706 , ValueFlow :: Value :: ErrorPath errorPath@var707 )
482: : token@var699 ( token@var705 ) , addressOf@var700 ( addressOf@var706 ) , errorPath@var701 ( std :: move ( errorPath@var707 ) ) , inconclusive@var702 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var708 , bool b@var709 ) {
486: for (@expr1073745606 LifetimeToken &@expr1073745607 x@var710 :@expr1073745608 v@var708 ) {
487: x@var710 .@expr1073745609 addressOf@var711 =@expr1073745610 b@var709 ; }
488: return v@var708 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var712 , bool b@var713 ) {
492: for (@expr1073745611 LifetimeToken &@expr1073745612 x@var714 :@expr1073745613 v@var712 ) {
493: x@var714 .@expr1073745614 inconclusive@var715 =@expr1073745615 b@var713 ; }
494: return v@var712 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var716 , ValueFlow :: Value & true_value@var717 , ValueFlow :: Value & false_value@var718 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var719 ) ;
499: const Token * parseCompareInt ( const Token * tok@var720 , ValueFlow :: Value & true_value@var721 , ValueFlow :: Value & false_value@var722 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var723 , long long val@var724 , const Token * varTok@var725 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var726 , const Token * varTok@var727 , long long val@var728 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var729 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var730 ,
508: ValueFlow :: Value & value@var731 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var732 ,
511: bool escape@var733 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var734 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var735 , const Token * lifetime@var736 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var737 , ValueFlow :: Value :: ErrorPath & errorPath@var738 , bool * addressOf@var739 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var740 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var741 , const Settings * settings@var742 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var743 , const ValueFlow :: Value * val@var744 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var745 , const ValueFlow :: Value * val@var746 , ValueFlow :: Value :: ErrorPath & errorPath@var747 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var748 , bool inconclusive@var749 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var750 ,
529: bool inconclusive@var751 = false ,
530: long long path@var752 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var753 , const Scope * defaultScope@var754 = nullptr , bool smallest@var755 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var756 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var757 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var758 ;
69: std :: string mScope@var759 ;
70: std :: string mName@var760 ;
71: std :: string mFullName@var761 ;
72: const Token * mNameToken@var762 ;
73: const Token * mParamEnd@var763 ;
74: unsigned int mFlags@var764 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var765 ) {
90: setFlag (@expr1073745616 fIsClass , state@var765 ) ;
91: }
92: void isFunction ( bool state@var766 ) {
93: setFlag (@expr1073745617 fIsFunction , state@var766 ) ;
94: }
95: void isVariable ( bool state@var767 ) {
96: setFlag (@expr1073745618 fIsVariable , state@var767 ) ;
97: }
98: void isAlias ( bool state@var768 ) {
99: setFlag (@expr1073745619 fIsAlias , state@var768 ) ;
100: }
101: void isSpecialization ( bool state@var769 ) {
102: setFlag (@expr1073745620 fIsSpecialization , state@var769 ) ;
103: }
104: void isPartialSpecialization ( bool state@var770 ) {
105: setFlag (@expr1073745621 fIsPartialSpecialization , state@var770 ) ;
106: }
107: void isForwardDeclaration ( bool state@var771 ) {
108: setFlag (@expr1073745622 fIsForwardDeclaration , state@var771 ) ;
109: }
110: void isVariadic ( bool state@var772 ) {
111: setFlag (@expr1073745623 fIsVariadic , state@var772 ) ;
112: }
113: void isFriend ( bool state@var773 ) {
114: setFlag (@expr1073745624 fIsFriend , state@var773 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var774 ) const {
123: return (@expr3801 (@expr3801 mFlags@var764 &@expr1073745627 flag@var774 ) !=@expr1073745628 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var775 , bool state@var776 ) {
132: mFlags@var764 =@expr1073745629 state@var776 ?@expr1073745630 mFlags@var764 |@expr1073745631 flag@var775 :@expr1073745632 mFlags@var764 &@expr1073745633 ~@expr1073745634 flag@var775 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var777 , const std :: string & scope@var778 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var779 , const std :: string & scope@var780 , const Token * nameToken@var781 , const Token * paramEnd@var782 ) ;
150: TokenAndName ( const TokenAndName & other@var783 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var784 ) const {
154: return mToken@var758 ==@expr1073745635 rhs@var784 .@expr1073745636 mToken@var785 &&@expr1073745637 mScope@var759 ==@expr1073745638 rhs@var784 .@expr1073745639 mScope@var786 &&@expr1073745640 mName@var760 ==@expr1073745641 rhs@var784 .@expr1073745642 mName@var787 &&@expr1073745643 mFullName@var761 ==@expr1073745644 rhs@var784 .@expr1073745645 mFullName@var788 &&@expr1073745646
155: mNameToken@var762 ==@expr1073745647 rhs@var784 .@expr1073745648 mNameToken@var789 &&@expr1073745649 mParamEnd@var763 ==@expr1073745650 rhs@var784 .@expr1073745651 mParamEnd@var790 &&@expr1073745652 mFlags@var764 ==@expr1073745653 rhs@var784 .@expr1073745654 mFlags@var791 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var758 ;
160: }
161: void token ( Token * token@var792 ) {
162: mToken@var758 =@expr1073745655 token@var792 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var759 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var760 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var761 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var762 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var763 ;
178: }
179: void paramEnd ( const Token * end@var793 ) {
180: mParamEnd@var763 =@expr1073745656 end@var793 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745657 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745658 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745659 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745660 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745661 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745662 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745663 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745664 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745665 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var794 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var795 ) const {
243:
244:
245: return (@expr3842 (@expr3842 mFlags@var764 &@expr1073745668 fFamilyMask ) &@expr1073745669 (@expr3842 decl@var795 .@expr1073745671 mFlags@var796 &@expr1073745672 fFamilyMask ) ) !=@expr1073745673 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var797 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var798 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var799 , const unsigned long numberOfArguments@var800 , bool variadic@var801 , const char patternAfter@var802 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var803 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var804 , int & namepos@var805 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var806 , int & namepos@var807 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var808 , int & namepos@var809 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var810 ,
306: bool & codeWithTemplates@var811 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var812 , bool isTemplate@var813 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var814 = nullptr , Token * backToken@var815 = nullptr , bool isTemplate@var816 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var817 , Token * end@var818 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var819 , const std :: string & scope@var820 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var821 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var822 ,
393: const std :: list < const Token * > & specializations@var823 ,
394: const std :: time_t maxtime@var824 ,
395: std :: set < std :: string > & expandedtemplates@var825 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var826 , const Token * tok@var827 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var828 , const Token * tok@var829 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var830 ,
422: const TokenAndName & templateInstantiation@var831 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var832 ,
424: const std :: string & newName@var833 ,
425: bool copy@var834 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var835 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var836 ,
435: const std :: string & newName@var837 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var838 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var839 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var840 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var841 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var842 ,
458: const Token * templateInstantiationNameToken@var843 ,
459: const std :: list < const Token * > & specializations@var844 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var845 , const Token * end@var846 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var847 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var848 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var849 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var850 ,
487: const std :: string & indent@var851 = "    " ) const ;
488: void printOut ( const std :: string & text@var852 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var853 ;
491: TokenList & mTokenList@var854 ;
492: const Settings * mSettings@var855 ;
493: ErrorLogger * mErrorLogger@var856 ;
494: bool mChanged@var857 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var858 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var859 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var860 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var861 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var862 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var863 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var864 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var865 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var866 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var867 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var868 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var869 ;
57: Token * back@var870 ;
58: const TokenList * list@var871 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var872 , const Token * bodyEnd_@var873 , const std :: set < std :: string > & usingNamespaces_@var874 = std :: set < std :: string > ( ) ) : name@var875 ( name_@var872 ) , bodyEnd@var876 ( bodyEnd_@var873 ) , usingNamespaces@var877 ( usingNamespaces_@var874 ) { }
63: std :: string name@var875 ;
64: const Token * const bodyEnd@var876 ;
65: std :: set < std :: string > usingNamespaces@var877 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var878 ;
70: int mFileIndex@var879 ;
71: int mLineNumber@var880 ;
72: int mColumn@var881 ;
73: int mExprId@var882 ;
74:
75:
76: Token * mAstOperand1@var883 ;
77: Token * mAstOperand2@var884 ;
78: Token * mAstParent@var885 ;
79:
80:
81: const Scope * mScope@var886 ;
82: union {
83: const Function * mFunction@var887 ;
84: const Variable * mVariable@var888 ;
85: const :: Type * mType@var889 ;
86: const Enumerator * mEnumerator@var890 ;
87: } ;
88:
|
92:
93: int mProgressValue@var891 ;
94:
|
97:
98: int mIndex@var892 ;
99:
100:
101: std :: string * mOriginalName@var893 ;
102:
103:
104: ValueType * mValueType@var894 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var895 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var896 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var897 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var898 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var899 ;
119: long long value@var900 ;
120: struct CppcheckAttributes * next@var901 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var902 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var903 ;
126:
127:
128: unsigned char mBits@var904 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var905 , long long value@var906 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var907 , long long * value@var908 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var878 ( 0 )
135: , mFileIndex@var879 ( 0 )
136: , mLineNumber@var880 ( 0 )
137: , mColumn@var881 ( 0 )
138: , mExprId@var882 ( 0 )
139: , mAstOperand1@var883 ( nullptr )
140: , mAstOperand2@var884 ( nullptr )
141: , mAstParent@var885 ( nullptr )
142: , mScope@var886 ( nullptr )
143: , mFunction@var887 ( nullptr )
144: , mProgressValue@var891 ( 0 )
145: , mIndex@var892 ( 0 )
146: , mOriginalName@var893 ( nullptr )
147: , mValueType@var894 ( nullptr )
148: , mValues@var895 ( nullptr )
149: , mTemplateSimplifierPointers@var897 ( nullptr )
150: , mScopeInfo@var898 ( nullptr )
151: , mCppcheckAttributes@var902 ( nullptr )
152: , mCpp11init@var903 ( Cpp11init :: UNKNOWN )
153: , mBits@var904 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var909 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var910 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var911 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var912 ) {
199: mStr@var1124 =@expr1073745674 s@var912 ;
200: mImpl@var1130 .@expr1073745675 mVarId@var1161 =@expr1073745676 0 ;
201:
202: update_property_info (@expr1073745677 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var913 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1124 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var914 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var915 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var916 ) const ;
236: Token * tokAt ( int index@var917 ) {
237: return const_cast < Token *@expr3854 > (@expr1073745679 const_cast < const Token *@expr3854 > (@expr1073745681 this@expr1073745682 ) .@expr1073745683 tokAt (@expr1073745684 index@var917 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var918 ) const ;
245: Token * linkAt ( int index@var919 ) {
246: return const_cast < Token *@expr3861 > (@expr1073745686 const_cast < const Token *@expr3861 > (@expr1073745688 this@expr1073745689 ) .@expr1073745690 linkAt (@expr1073745691 index@var919 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var920 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var921 , const char ( & pattern@var922 ) [ count ] ) {
276: return simpleMatch (@expr1073745693 tok@var921 , pattern@var922 , count@expr1073745692 -@expr1073745694 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var923 , const char pattern@var924 [ ] , unsigned long pattern_len@var925 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var926 , const char pattern@var927 [ ] , int varid@var928 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var929 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var930 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var931 , const Settings * const settings@var932 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var933 , long long index@var934 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1130 .@expr1073745695 mValueType@var1162 ;
366: }
367: void setValueType ( ValueType * vt@var935 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var936 ; top@var936 =@expr1073745696 this@expr1073745697 ;
371: while (@expr1073745698 top@var936 &&@expr1073745699 !@expr1073745700 Token ::@expr1073745701 Match (@expr1073745702 top@var936 .@expr3879 astParent (@expr3880 ) , ",|(" ) ) {
372: top@var936 =@expr1073745705 top@var936 .@expr3879 astParent (@expr3880 ) ; }
373: return top@var936 ?@expr1073745708 top@var936 .@expr1073745709 mImpl@var937 .@expr1073745710 mValueType@var938 :@expr1073745711 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1128 ;
378: }
379: void tokType ( Token :: Type t@var939 ) {
380: mTokType@var1128 =@expr1073745712 t@var939 ;
381:
382: const bool memoizedIsName@var940 =@expr1073745713 mTokType@var1128 ==@expr1073745714 eName ||@expr1073745715 mTokType@var1128 ==@expr1073745716 eType ||@expr1073745717 mTokType@var1128 ==@expr1073745718 eVariable ||@expr1073745719
383: mTokType@var1128 ==@expr1073745720 eFunction ||@expr1073745721 mTokType@var1128 ==@expr1073745722 eKeyword ||@expr1073745723 mTokType@var1128 ==@expr3900 eBoolean ||@expr1073745725
384: mTokType@var1128 ==@expr3902 eEnumerator ;
385: setFlag (@expr1073745727 fIsName , memoizedIsName@var940 ) ;
386:
387: const bool memoizedIsLiteral@var941 =@expr1073745728 mTokType@var1128 ==@expr1073745729 eNumber ||@expr1073745730 mTokType@var1128 ==@expr1073745731 eString ||@expr1073745732 mTokType@var1128 ==@expr1073745733 eChar ||@expr1073745734
388: mTokType@var1128 ==@expr3900 eBoolean ||@expr1073745736 mTokType@var1128 ==@expr1073745737 eLiteral ||@expr1073745738 mTokType@var1128 ==@expr3902 eEnumerator ;
389: setFlag (@expr1073745740 fIsLiteral , memoizedIsLiteral@var941 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1128 ==@expr1073745741 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745742 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1129 ==@expr1073745743 fIsName &&@expr1073745744 mTokType@var1128 ==@expr1073745745 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745746 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1128 ==@expr1073745747 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1128 ==@expr1073745748 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745749 isConstOp (@expr1073745750 ) ||@expr1073745751
412: isAssignmentOp (@expr1073745752 ) ||@expr1073745753
413: mTokType@var1128 ==@expr1073745754 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745755 isArithmeticalOp (@expr1073745756 ) ||@expr1073745757
417: mTokType@var1128 ==@expr1073745758 eLogicalOp ||@expr1073745759
418: mTokType@var1128 ==@expr1073745760 eComparisonOp ||@expr1073745761
419: mTokType@var1128 ==@expr1073745762 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745763 ) ||@expr1073745764
423: mTokType@var1128 ==@expr1073745765 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1128 ==@expr1073745766 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1128 ==@expr1073745767 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1128 ==@expr1073745768 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1128 ==@expr1073745769 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1128 ==@expr1073745770 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745771 ) !=@expr1073745772 nullptr &&@expr1073745773 astOperand2 (@expr1073745774 ) !=@expr1073745775 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var942 ) const {
444: return s@var942 ==@expr1073745776 mStr@var1124 &&@expr1073745777 astOperand1 (@expr1073745778 ) !=@expr1073745779 nullptr &&@expr1073745780 astOperand2 (@expr1073745781 ) ==@expr1073745782 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1129 ;
450: }
451: void flags ( const unsigned int flags_@var943 ) {
452: mFlags@var1129 =@expr1073745783 flags_@var943 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745784 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var944 ) {
458: setFlag (@expr1073745785 fIsUnsigned , sign@var944 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745786 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var945 ) {
464: setFlag (@expr1073745787 fIsSigned , sign@var945 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745788 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var946 ) {
470: setFlag (@expr1073745789 fIsPointerCompare , b@var946 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745790 fIsLong ) ;
474: }
475: void isLong ( bool size@var947 ) {
476: setFlag (@expr1073745791 fIsLong , size@var947 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745792 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var948 ) {
482: setFlag (@expr1073745793 fIsStandardType , b@var948 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745794 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var949 ) {
488: setFlag (@expr1073745795 fIsExpandedMacro , m@var949 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745796 fIsCast ) ;
492: }
493: void isCast ( bool c@var950 ) {
494: setFlag (@expr1073745797 fIsCast , c@var950 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745798 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var951 ) {
500: setFlag (@expr1073745799 fIsAttributeConstructor , ac@var951 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745800 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var952 ) {
506: setFlag (@expr1073745801 fIsAttributeDestructor , value@var952 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745802 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var953 ) {
512: setFlag (@expr1073745803 fIsAttributeUnused , unused@var953 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745804 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var954 ) {
518: setFlag (@expr1073745805 fIsAttributeUsed , unused@var954 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745806 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var955 ) {
524: setFlag (@expr1073745807 fIsAttributePure , value@var955 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745808 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var956 ) {
530: setFlag (@expr1073745809 fIsAttributeConst , value@var956 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745810 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var957 ) {
536: setFlag (@expr1073745811 fIsAttributeNoreturn , value@var957 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745812 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var958 ) {
542: setFlag (@expr1073745813 fIsAttributeNothrow , value@var958 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745814 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var959 ) {
548: setFlag (@expr1073745815 fIsAttributePacked , value@var959 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745816 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var960 ) {
554: setFlag (@expr1073745817 fIsAttributeNodiscard , value@var960 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745818 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var961 ) {
560: setFlag (@expr1073745819 fIsAttributeMaybeUnused , value@var961 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var962 , long long value@var963 ) {
563: mImpl@var1130 .@expr1073745820 setCppcheckAttribute (@expr1073745821 type@var962 , value@var963 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var964 , long long * value@var965 ) const {
566: return mImpl@var1130 .@expr1073745822 getCppcheckAttribute (@expr1073745823 type@var964 , value@var965 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745824 mImpl@var1130 .@expr1073745825 mCppcheckAttributes@var1163 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745826 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745827 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var966 ) {
578: setFlag (@expr1073745828 fIsOperatorKeyword , value@var966 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745829 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var967 ) {
584: setFlag (@expr1073745830 fIsComplex , value@var967 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745831 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var968 ) {
590: setFlag (@expr1073745832 fIsEnumType , value@var968 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745833 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var969 ) {
596: setFlag (@expr1073745834 fAtAddress , b@var969 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745835 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var970 ) {
602: setFlag (@expr1073745836 fIncompleteVar , b@var970 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745837 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var971 ) {
609: setFlag (@expr1073745838 fIsIncompleteConstant , b@var971 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745839 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var972 ) {
616: setFlag (@expr1073745840 fConstexpr , b@var972 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745841 fExternC ) ;
621: }
622: void isExternC ( bool b@var973 ) {
623: setFlag (@expr1073745842 fExternC , b@var973 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745843 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var974 ) {
630: setFlag (@expr1073745844 fIsSplitVarDeclComma , b@var974 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745845 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var975 ) {
637: setFlag (@expr1073745846 fIsSplitVarDeclEq , b@var975 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745847 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var976 ) {
644: setFlag (@expr1073745848 fIsImplicitInt , b@var976 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745849 fIsInline ) ;
649: }
650: void isInline ( bool b@var977 ) {
651: setFlag (@expr1073745850 fIsInline , b@var977 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745851 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var978 ) {
658: setFlag (@expr1073745852 fIsRemovedVoidParameter , b@var978 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745853 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var979 ) {
665: setFlag (@expr1073745854 fIsTemplate , b@var979 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745855 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var980 ) {
672: setFlag (@expr1073745856 fIsSimplifedScope , b@var980 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1130 .@expr1073745857 mBits@var1164 >@expr1073745858 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1130 .@expr1073745859 mBits@var1164 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1130 .@expr1073745860 mTemplateSimplifierPointers@var1165 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var981 ) {
685: if (@expr1073745861 !@expr1073745862 mImpl@var1130 .@expr4039 mTemplateSimplifierPointers@var1165 ) {
686: mImpl@var1130 .@expr4039 mTemplateSimplifierPointers@var1165 =@expr1073745865 new std ::@expr1073745866 set < TemplateSimplifier ::@expr1073745867 TokenAndName *@expr1073745868 > ; }
687: mImpl@var1130 .@expr4039 mTemplateSimplifierPointers@var1165 .@expr1073745870 insert (@expr1073745871 tokenAndName@var981 ) ;
688: }
689: void setBits ( const unsigned char b@var982 ) {
690: mImpl@var1130 .@expr1073745872 mBits@var1164 =@expr1073745873 b@var982 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4050 (@expr4050 (@expr4050 mTokType@var1128 ==@expr1073745877 eString ) &&@expr1073745878 isPrefixStringCharLiteral (@expr1073745879 mStr@var1124 , '"' , "u8" ) ) ||@expr1073745880
695: (@expr4050 (@expr4050 mTokType@var1128 ==@expr1073745883 eChar ) &&@expr1073745884 isPrefixStringCharLiteral (@expr1073745885 mStr@var1124 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4062 (@expr4062 (@expr4062 mTokType@var1128 ==@expr1073745889 eString ) &&@expr1073745890 isPrefixStringCharLiteral (@expr1073745891 mStr@var1124 , '"' , "u" ) ) ||@expr1073745892
700: (@expr4062 (@expr4062 mTokType@var1128 ==@expr1073745895 eChar ) &&@expr1073745896 isPrefixStringCharLiteral (@expr1073745897 mStr@var1124 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4074 (@expr4074 (@expr4074 mTokType@var1128 ==@expr1073745901 eString ) &&@expr1073745902 isPrefixStringCharLiteral (@expr1073745903 mStr@var1124 , '"' , "U" ) ) ||@expr1073745904
705: (@expr4074 (@expr4074 mTokType@var1128 ==@expr1073745907 eChar ) &&@expr1073745908 isPrefixStringCharLiteral (@expr1073745909 mStr@var1124 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4086 (@expr4086 (@expr4086 mTokType@var1128 ==@expr1073745913 eString ) &&@expr1073745914 isPrefixStringCharLiteral (@expr1073745915 mStr@var1124 , '"' , "" ) ) ||@expr1073745916
710: (@expr4086 (@expr4086 mTokType@var1128 ==@expr1073745919 eChar ) &&@expr1073745920 isPrefixStringCharLiteral (@expr1073745921 mStr@var1124 , '\'' , "" ) &&@expr1073745922 mStr@var1124 .@expr1073745923 length (@expr1073745924 ) ==@expr1073745925 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4102 (@expr4102 (@expr4102 mTokType@var1128 ==@expr1073745929 eChar ) &&@expr1073745930 isPrefixStringCharLiteral (@expr1073745931 mStr@var1124 , '\'' , "" ) ) &&@expr1073745932
715: (@expr4102 mStr@var1124 .@expr1073745934 length (@expr1073745935 ) >@expr1073745936 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745937 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var983 ) {
738: setFlag (@expr1073745938 fIsTemplateArg , value@var983 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var984 , const char ( & pattern@var985 ) [ count ] ) {
743: return findsimplematch (@expr1073745940 startTok@var984 , pattern@var985 , count@expr1073745939 -@expr1073745941 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var986 , const char pattern@var987 [ ] , unsigned long pattern_len@var988 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var989 , const char ( & pattern@var990 ) [ count ] , const Token * const end@var991 ) {
749: return findsimplematch (@expr1073745943 startTok@var989 , pattern@var990 , count@expr1073745942 -@expr1073745944 1 , end@var991 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var992 , const char pattern@var993 [ ] , unsigned long pattern_len@var994 , const Token * const end@var995 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var996 , const char pattern@var997 [ ] , const int varId@var998 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var999 , const char pattern@var1000 [ ] , const Token * const end@var1001 , const int varId@var1002 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1003 , const char ( & pattern@var1004 ) [ count ] ) {
758: return findsimplematch (@expr1073745946 startTok@var1003 , pattern@var1004 , count@expr1073745945 -@expr1073745947 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1005 , const char pattern@var1006 [ ] , unsigned long pattern_len@var1007 ) {
761: return const_cast < Token *@expr4124 > (@expr1073745949 findsimplematch (@expr1073745950 const_cast < const Token *@expr4124 > (@expr1073745952 startTok@var1005 ) , pattern@var1006 , pattern_len@var1007 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1008 , const char ( & pattern@var1009 ) [ count ] , const Token * const end@var1010 ) {
765: return findsimplematch (@expr1073745954 startTok@var1008 , pattern@var1009 , count@expr1073745953 -@expr1073745955 1 , end@var1010 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1011 , const char pattern@var1012 [ ] , unsigned long pattern_len@var1013 , const Token * const end@var1014 ) {
768: return const_cast < Token *@expr4132 > (@expr1073745957 findsimplematch (@expr1073745958 const_cast < const Token *@expr4132 > (@expr1073745960 startTok@var1011 ) , pattern@var1012 , pattern_len@var1013 , end@var1014 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1015 , const char pattern@var1016 [ ] , const int varId@var1017 = 0 ) {
772: return const_cast < Token *@expr4137 > (@expr1073745962 findmatch (@expr1073745963 const_cast < const Token *@expr4137 > (@expr1073745965 startTok@var1015 ) , pattern@var1016 , varId@var1017 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1018 , const char pattern@var1019 [ ] , const Token * const end@var1020 , const int varId@var1021 = 0 ) {
775: return const_cast < Token *@expr4142 > (@expr1073745967 findmatch (@expr1073745968 const_cast < const Token *@expr4142 > (@expr1073745970 startTok@var1018 ) , pattern@var1019 , end@var1020 , varId@var1021 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1022 , const char * haystack@var1023 , int varid@var1024 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1130 .@expr1073745971 mFileIndex@var1166 ;
796: }
797: void fileIndex ( int indexOfFile@var1025 ) {
798: mImpl@var1130 .@expr1073745972 mFileIndex@var1166 =@expr1073745973 indexOfFile@var1025 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1130 .@expr1073745974 mLineNumber@var1167 ;
803: }
804: void linenr ( int lineNumber@var1026 ) {
805: mImpl@var1130 .@expr1073745975 mLineNumber@var1167 =@expr1073745976 lineNumber@var1026 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1130 .@expr1073745977 mColumn@var1168 ;
810: }
811: void column ( int c@var1027 ) {
812: mImpl@var1130 .@expr1073745978 mColumn@var1168 =@expr1073745979 c@var1027 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1125 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1028 , const Token * end@var1029 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1030 , const std :: string & originalNameStr@var1031 = emptyString@var1 , bool prepend@var1032 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1033 , const std :: string & originalNameStr@var1034 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745980 tokenStr@var1033 , originalNameStr@var1034 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1126 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1130 .@expr1073745981 mVarId@var1161 ;
851: }
852: void varId ( int id@var1035 ) {
853: mImpl@var1130 .@expr1073745982 mVarId@var1161 =@expr1073745983 id@var1035 ;
854: if (@expr1073745984 id@var1035 !=@expr1073745985 0 ) {
855: tokType (@expr1073745986 eVariable ) ;
856: isStandardType (@expr1073745987 false ) ;
857: } else {
858: update_property_info (@expr1073745988 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745989 mImpl@var1130 .@expr4166 mExprId@var1169 ) {
864: return mImpl@var1130 .@expr4166 mExprId@var1169 ; }
865: return mImpl@var1130 .@expr1073745992 mVarId@var1161 ;
866: }
867: void exprId ( int id@var1036 ) {
868: mImpl@var1130 .@expr1073745993 mExprId@var1169 =@expr1073745994 id@var1036 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1037 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1038 , const std :: vector < std :: string > & fileNames@var1039 ) const ;
888:
|
891:
892: void printLines ( int lines@var1040 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1041 , Token * start@var1042 , Token * end@var1043 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1044 ; varid@var1044 = false ;
905: bool exprid@var1045 ; exprid@var1045 = false ;
906: bool idtype@var1046 ; idtype@var1046 = false ;
907: bool attributes@var1047 ; attributes@var1047 = false ;
908: bool macro@var1048 ; macro@var1048 = false ;
909: bool linenumbers@var1049 ; linenumbers@var1049 = false ;
910: bool linebreaks@var1050 ; linebreaks@var1050 = false ;
911: bool files@var1051 ; files@var1051 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1052 ;
914: options@var1052 .@expr1073745995 attributes@var1053 =@expr1073745996 true ;
915: options@var1052 .@expr1073745997 macro@var1054 =@expr1073745998 true ;
916: options@var1052 .@expr1073745999 linenumbers@var1055 =@expr1073746000 true ;
917: options@var1052 .@expr1073746001 linebreaks@var1056 =@expr1073746002 true ;
918: options@var1052 .@expr1073746003 files@var1057 =@expr1073746004 true ;
919: return options@var1052 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1058 ; options@var1058 =@expr1073746005 forDebug (@expr1073746006 ) ;
923: options@var1058 .@expr1073746007 varid@var1059 =@expr1073746008 true ;
924: return options@var1058 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1060 ; options@var1060 =@expr1073746009 forDebug (@expr1073746010 ) ;
928: options@var1060 .@expr1073746011 exprid@var1061 =@expr1073746012 true ;
929: return options@var1060 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1062 ; options@var1062 =@expr1073746013 forDebug (@expr1073746014 ) ;
933: options@var1062 .@expr1073746015 exprid@var1063 =@expr1073746016 true ;
934: options@var1062 .@expr1073746017 varid@var1064 =@expr1073746018 true ;
935: options@var1062 .@expr1073746019 idtype@var1065 =@expr1073746020 true ;
936: return options@var1062 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1066 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1067 , bool attributes@var1068 , bool macro@var1069 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1070 , const std :: vector < std :: string > * fileNames@var1071 = nullptr , const Token * end@var1072 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1073 , bool attributes@var1074 = true ) const ;
952: std :: string stringifyList ( bool varid@var1075 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1076 , bool attributes@var1077 , bool linenumbers@var1078 , bool linebreaks@var1079 , bool files@var1080 , const std :: vector < std :: string > * fileNames@var1081 = nullptr , const Token * end@var1082 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1083 ) {
983: mLink@var1127 =@expr1073746021 linkToToken@var1083 ;
984: if (@expr1073746022 mStr@var1124 ==@expr1073746023 "<" ||@expr1073746024 mStr@var1124 ==@expr1073746025 ">" ) {
985: update_property_info (@expr1073746026 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1127 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1084 ) {
1006: mImpl@var1130 .@expr1073746027 mScope@var1170 =@expr1073746028 s@var1084 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1130 .@expr1073746029 mScope@var1170 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1085 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1128 ==@expr1073746030 eFunction ||@expr1073746031 mTokType@var1128 ==@expr1073746032 eLambda ?@expr1073746033 mImpl@var1130 .@expr1073746034 mFunction@var1171 :@expr1073746035 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1086 ) {
1034: mImpl@var1130 .@expr1073746036 mVariable@var1172 =@expr1073746037 v@var1086 ;
1035: if (@expr1073746038 v@var1086 ||@expr1073746039 mImpl@var1130 .@expr1073746040 mVarId@var1161 ) {
1036: tokType (@expr1073746041 eVariable ) ; }
1037: else { if (@expr1073746042 mTokType@var1128 ==@expr1073746043 eVariable ) {
1038: tokType (@expr1073746044 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1128 ==@expr1073746045 eVariable ?@expr1073746046 mImpl@var1130 .@expr1073746047 mVariable@var1172 :@expr1073746048 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1087 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1128 ==@expr1073746049 eType ?@expr1073746050 mImpl@var1130 .@expr1073746051 mType@var1173 :@expr1073746052 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1088 , const Token * * typeTok@var1089 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1090 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1091 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1128 ==@expr1073746053 eEnumerator ?@expr1073746054 mImpl@var1130 .@expr1073746055 mEnumerator@var1174 :@expr1073746056 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1092 ) {
1079: mImpl@var1130 .@expr1073746057 mEnumerator@var1174 =@expr1073746058 e@var1092 ;
1080: if (@expr1073746059 e@var1092 ) {
1081: tokType (@expr1073746060 eEnumerator ) ; }
1082: else { if (@expr1073746061 mTokType@var1128 ==@expr1073746062 eEnumerator ) {
1083: tokType (@expr1073746063 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1093 , Token * end@var1094 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1095 , Token * srcEnd@var1096 , Token * newLocation@var1097 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1130 .@expr1073746064 mProgressValue@var1175 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1098 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1130 .@expr4241 mOriginalName@var1176 ?@expr1073746066 *@expr1073746067 mImpl@var1130 .@expr4241 mOriginalName@var1176 :@expr1073746069 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1130 .@expr4246 mValues@var1149 ?@expr1073746071 *@expr1073746072 mImpl@var1130 .@expr4246 mValues@var1149 :@expr1073746074 TokenImpl ::@expr1073746075 mEmptyValueList@var896 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1099 ) {
1164: if (@expr1073746076 !@expr1073746077 mImpl@var1130 .@expr4254 mOriginalName@var1176 ) {
1165: mImpl@var1130 .@expr4254 mOriginalName@var1176 =@expr1073746080 new std ::@expr1073746081 string (@expr1073746082 name@var1099 ) ; }
1166: else {
1167: *@expr1073746083 mImpl@var1130 .@expr4254 mOriginalName@var1176 =@expr1073746085 name@var1099 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1100 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1101 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1102 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1130 .@expr1073746087 mValues@var1149 .@expr1073746088 front (@expr1073746089 ) .@expr1073746090 intvalue@expr1073746086 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1103 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1104 , long long path@var1105 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1106 , const Settings * settings@var1107 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1108 , const Settings * settings@var1109 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1110 , int argnr@var1111 , const Settings * settings@var1112 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1113 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1114 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1115 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1116 ) {
1200: if (@expr1073746091 mImpl@var1130 .@expr4268 mValues@var1149 ) {
1201: mImpl@var1130 .@expr4268 mValues@var1149 .@expr1073746094 remove_if (@expr1073746095 pred@var1116 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1130 .@expr1073746096 mIndex@var1177 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1117 ) {
1213: mNext@var1125 =@expr1073746097 nextToken@var1117 ;
1214: }
1215: void previous ( Token * previousToken@var1118 ) {
1216: mPrevious@var1126 =@expr1073746098 previousToken@var1118 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1119 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1120 , const char * word@var1121 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1122 , char c@var1123 ) ;
1235:
1236: std :: string mStr@var1124 ;
1237:
1238: Token * mNext@var1125 ;
1239: Token * mPrevious@var1126 ;
1240: Token * mLink@var1127 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1128 ;
1283:
1284: uint64_t mFlags@var1129 ;
1285:
1286: TokenImpl * mImpl@var1130 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1131 ) const {
1294: return (@expr4275 (@expr4275 mFlags@var1129 &@expr1073746101 flag_@var1131 ) !=@expr1073746102 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1132 , bool state_@var1133 ) {
1303: mFlags@var1129 =@expr1073746103 state_@var1133 ?@expr1073746104 mFlags@var1129 |@expr1073746105 flag_@var1132 :@expr1073746106 mFlags@var1129 &@expr1073746107 ~@expr1073746108 flag_@var1132 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1134 , const int indent1@var1135 = 0 , const int indent2@var1136 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1137 ) ;
1321: void astOperand2 ( Token * tok@var1138 ) ;
1322: void astParent ( Token * tok@var1139 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1130 .@expr1073746109 mAstOperand1@var1140 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1130 .@expr1073746110 mAstOperand1@var1140 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1130 .@expr1073746111 mAstOperand2@var1141 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1130 .@expr1073746112 mAstOperand2@var1141 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1130 .@expr1073746113 mAstParent@var1142 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1130 .@expr1073746114 mAstParent@var1142 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746115 !@expr1073746116 astParent (@expr4293 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746118 this@expr4295 ==@expr1073746120 astParent (@expr4293 ) .@expr4298 astOperand1 (@expr4299 ) ) {
1346: return astParent (@expr4293 ) .@expr4301 astOperand2 (@expr4302 ) ; }
1347: else { if (@expr1073746127 this@expr4295 ==@expr1073746128 astParent (@expr4293 ) .@expr4301 astOperand2 (@expr4302 ) ) {
1348: return astParent (@expr4293 ) .@expr4298 astOperand1 (@expr4299 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746135 !@expr1073746136 astParent (@expr4313 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746138 this@expr4315 ==@expr1073746140 astParent (@expr4313 ) .@expr4318 astOperand1 (@expr4319 ) ) {
1356: return astParent (@expr4313 ) .@expr4321 astOperand2 (@expr4322 ) ; }
1357: else { if (@expr1073746147 this@expr4315 ==@expr1073746148 astParent (@expr4313 ) .@expr4321 astOperand2 (@expr4322 ) ) {
1358: return astParent (@expr4313 ) .@expr4318 astOperand1 (@expr4319 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1143 ; ret@var1143 =@expr1073746155 this@expr1073746156 ;
1364: while (@expr1073746157 ret@var1143 .@expr4334 mImpl@var1144 .@expr4335 mAstParent@var1145 ) {
1365: ret@var1143 =@expr1073746160 ret@var1143 .@expr4334 mImpl@var1144 .@expr4335 mAstParent@var1145 ; }
1366: return ret@var1143 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1146 ; ret@var1146 =@expr1073746163 this@expr1073746164 ;
1371: while (@expr1073746165 ret@var1146 .@expr4342 mImpl@var1147 .@expr4343 mAstParent@var1148 ) {
1372: ret@var1146 =@expr1073746168 ret@var1146 .@expr4342 mImpl@var1147 .@expr4343 mAstParent@var1148 ; }
1373: return ret@var1146 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1130 .@expr1073746171 mAstOperand1@var1140 =@expr1073746172 mImpl@var1130 .@expr1073746173 mAstOperand2@var1141 =@expr1073746174 mImpl@var1130 .@expr1073746175 mAstParent@var1142 =@expr1073746176 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1130 .@expr4353 mValues@var1149 ;
1393: mImpl@var1130 .@expr4353 mValues@var1149 =@expr1073746179 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1150 = "" ) const {
1397: std ::@expr1073746180 string ret@var1151 ;
1398: if (@expr1073746181 mImpl@var1130 .@expr4358 mAstOperand1@var1140 ) {
1399: ret@var1151 =@expr1073746183 mImpl@var1130 .@expr4358 mAstOperand1@var1140 .@expr1073746185 astString (@expr1073746186 sep@var1150 ) ; }
1400: if (@expr1073746187 mImpl@var1130 .@expr4364 mAstOperand2@var1141 ) {
1401: ret@var1151 +=@expr1073746189 mImpl@var1130 .@expr4364 mAstOperand2@var1141 .@expr1073746191 astString (@expr1073746192 sep@var1150 ) ; }
1402: return ret@var1151 +@expr1073746193 sep@var1150 +@expr1073746194 mStr@var1124 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1152 , bool xml@var1153 , const std :: vector < std :: string > & fileNames@var1154 , std :: ostream & out@var1155 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1156 , std :: ostream & out@var1157 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1158 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1159 ) const {
1419: mImpl@var1130 .@expr1073746195 mCpp11init@var1160 =@expr1073746196 cpp11init@var1159 ?@expr1073746197 TokenImpl ::@expr4374 Cpp11init ::@expr1073746199 CPP11INIT :@expr1073746200 TokenImpl ::@expr4374 Cpp11init ::@expr1073746202 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1130 .@expr1073746203 mCpp11init@var1160 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1178 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1179 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1180 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1181 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1182 ( nullptr ) , num@var1183 ( 0 ) , known@var1184 ( true ) { }
62:
63: const Token * tok@var1182 ;
64: long long num@var1183 ;
65: bool known@var1184 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1185 ;
72: const Scope * classScope@var1186 ;
73: const Scope * enclosingScope@var1187 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1188 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1190 ( nullptr ) , nameTok@var1191 ( nullptr ) , access@var1192 ( AccessControl :: Public ) , isVirtual@var1193 ( false ) { }
82:
83: std :: string name@var1189 ;
84: const Type * type@var1190 ;
85: const Token * nameTok@var1191 ;
86: AccessControl access@var1192 ;
87: bool isVirtual@var1193 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1194 ) const {
90: return this@expr1073746204 .@expr1073746205 type@var1190 <@expr1073746206 rhs@var1194 .@expr1073746207 type@var1195 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1196 ( nullptr ) , nameEnd@var1197 ( nullptr ) , type@var1198 ( nullptr ) { }
97:
98: const Token * nameStart@var1196 ;
99: const Token * nameEnd@var1197 ;
100: const Type * type@var1198 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1199 ;
104: std :: vector < FriendInfo > friendList@var1200 ;
105:
106: const Token * typeStart@var1201 ;
107: const Token * typeEnd@var1202 ;
108: long long sizeOf@var1203 ;
109:
110: Type ( const Token * classDef_@var1204 = nullptr , const Scope * classScope_@var1205 = nullptr , const Scope * enclosingScope_@var1206 = nullptr ) :
111: classDef@var1185 ( classDef_@var1204 ) ,
112: classScope@var1186 ( classScope_@var1205 ) ,
113: enclosingScope@var1187 ( enclosingScope_@var1206 ) ,
114: needInitialization@var1188 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1201 ( nullptr ) ,
116: typeEnd@var1202 ( nullptr ) ,
117: sizeOf@var1203 ( 0 ) {
118: if (@expr1073746208 classDef_@var1204 &&@expr1073746209 classDef_@var1204 .@expr4386 str (@expr4387 ) ==@expr1073746212 "enum" ) {
119: needInitialization@var1188 =@expr1073746213 NeedInitialization ::@expr1073746214 True ; }
120: else { if (@expr1073746215 classDef_@var1204 &&@expr1073746216 classDef_@var1204 .@expr4386 str (@expr4387 ) ==@expr1073746219 "using" ) {
121: typeStart@var1201 =@expr1073746220 classDef@var1185 .@expr1073746221 tokAt (@expr1073746222 3 ) ;
122: typeEnd@var1202 =@expr1073746223 typeStart@var1201 ;
123: while (@expr1073746224 typeEnd@var1202 .@expr4401 next (@expr4402 ) &&@expr1073746227 typeEnd@var1202 .@expr4401 next (@expr4402 ) .@expr1073746230 str (@expr1073746231 ) !=@expr1073746232 ";" ) {
124: typeEnd@var1202 =@expr1073746233 typeEnd@var1202 .@expr4401 next (@expr4402 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1185 ?@expr1073746236 classDef@var1185 .@expr1073746237 str (@expr1073746238 ) :@expr1073746239 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1185 &&@expr1073746240 classDef@var1185 .@expr1073746241 str (@expr1073746242 ) ==@expr1073746243 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1207 , const Token * tok1@var1208 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1209 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1210 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1211 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1212 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1213 ) : scope@var1214 ( scope_@var1213 ) , name@var1215 ( nullptr ) , value@var1216 ( 0 ) , start@var1217 ( nullptr ) , end@var1218 ( nullptr ) , value_known@var1219 ( false ) { }
167: const Scope * scope@var1214 ;
168: const Token * name@var1215 ;
169: long long value@var1216 ;
170: const Token * start@var1217 ;
171: const Token * end@var1218 ;
172: bool value_known@var1219 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1220 ) const {
204: return (@expr4420 (@expr4420 mFlags@var1256 &@expr1073746246 flag_@var1220 ) !=@expr1073746247 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1221 , bool state_@var1222 ) {
213: mFlags@var1256 =@expr1073746248 state_@var1222 ?@expr1073746249 mFlags@var1256 |@expr1073746250 flag_@var1221 :@expr1073746251 mFlags@var1256 &@expr1073746252 ~@expr1073746253 flag_@var1221 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1223 , bool * isContainer@var1224 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1225 , const Token * start_@var1226 , const Token * end_@var1227 ,
226: int index_@var1228 , AccessControl access_@var1229 , const Type * type_@var1230 ,
227: const Scope * scope_@var1231 , const Settings * settings@var1232 )
228: : mNameToken@var1251 ( name_@var1225 ) ,
229: mTypeStartToken@var1252 ( start_@var1226 ) ,
230: mTypeEndToken@var1253 ( end_@var1227 ) ,
231: mIndex@var1254 ( index_@var1228 ) ,
232: mAccess@var1255 ( access_@var1229 ) ,
233: mFlags@var1256 ( 0 ) ,
234: mType@var1257 ( type_@var1230 ) ,
235: mScope@var1258 ( scope_@var1231 ) ,
236: mValueType@var1259 ( nullptr ) {
237: evaluate (@expr1073746254 settings@var1232 ) ;
238: }
239:
240: Variable ( const Token * name_@var1233 , const std :: string & clangType@var1234 , const Token * typeStart@var1235 ,
241: const Token * typeEnd@var1236 , int index_@var1237 , AccessControl access_@var1238 ,
242: const Type * type_@var1239 , const Scope * scope_@var1240 ) ;
243:
244: Variable ( const Variable & var@var1241 , const Scope * scope@var1242 ) ;
245:
246: Variable ( const Variable & var@var1243 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1244 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1251 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1252 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1253 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746255 mNameToken@var1251 ) {
300: return mNameToken@var1251 .@expr1073746256 str (@expr1073746257 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746258 mNameToken@var1251 ) {
312: return mNameToken@var1251 .@expr1073746259 varId (@expr1073746260 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1254 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1255 ==@expr1073746261 AccessControl ::@expr1073746262 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1255 ==@expr1073746263 AccessControl ::@expr1073746264 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1255 ==@expr1073746265 AccessControl ::@expr1073746266 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1255 ==@expr1073746267 AccessControl ::@expr1073746268 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1255 ==@expr1073746269 AccessControl ::@expr1073746270 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1255 ==@expr1073746271 AccessControl ::@expr1073746272 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746274 mAccess@var1255 ==@expr1073746275 AccessControl ::@expr1073746276 Local@expr1073746273 ) &&@expr1073746277 !@expr1073746278 isExtern (@expr1073746279 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746280 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746281 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746282 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746283 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746284 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1255 ==@expr1073746285 AccessControl ::@expr1073746286 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746287 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746288 fIsArray ) &&@expr1073746289 !@expr1073746290 getFlag (@expr1073746291 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746292 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746293 ) &&@expr1073746294 getFlag (@expr1073746295 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746296 fIsArray ) ||@expr1073746297 getFlag (@expr1073746298 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746299 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746300 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746301 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746302 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1257 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1257 ?@expr1073746303 mType@var1257 .@expr1073746304 classScope@var1262 :@expr1073746305 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1258 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1260 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1245 ) const {
550: return mDimensions@var1260 [@expr1073746306 index_@var1245 ] .@expr1073746307 num@var2935 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1246 ) const {
558: return mDimensions@var1260 [@expr1073746308 index_@var1246 ] .@expr1073746309 known@var2936 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746310 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746311 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746312 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1247 ) const {
602: return isStlType (@expr1073746313 ) &&@expr1073746314 stlType@var1247 ==@expr1073746315 mTypeStartToken@var1252 .@expr1073746316 strAt (@expr1073746317 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1248 ) const {
616: return isStlType (@expr1073746318 ) &&@expr1073746319 stlTypes@var1248 .@expr1073746320 find (@expr1073746321 mTypeStartToken@var1252 .@expr1073746322 strAt (@expr1073746323 2 ) ) !=@expr1073746324 stlTypes@var1248 .@expr1073746325 end (@expr1073746326 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746327 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4504 ) &&@expr1073746329 type (@expr4504 ) .@expr1073746331 isEnumType (@expr1073746332 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746333 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1259 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1249 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1255 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1250 ) {
660: mType@var1257 =@expr1073746334 t@var1250 ;
661: }
662:
663:
664: const Token * mNameToken@var1251 ;
665:
666:
667: const Token * mTypeStartToken@var1252 ;
668:
669:
670: const Token * mTypeEndToken@var1253 ;
671:
672:
673: int mIndex@var1254 ;
674:
675:
676: AccessControl mAccess@var1255 ;
677:
678:
679: unsigned int mFlags@var1256 ;
680:
681:
682: const Type * mType@var1257 ;
683:
684:
685: const Scope * mScope@var1258 ;
686:
687: ValueType * mValueType@var1259 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1260 ;
691:
692:
693: void evaluate ( const Settings * settings@var1261 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1263 ) const {
735: return (@expr4511 (@expr4511 mFlags@var1312 &@expr1073746337 flag@var1263 ) !=@expr1073746338 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1264 , bool state@var1265 ) {
744: mFlags@var1312 =@expr1073746339 state@var1265 ?@expr1073746340 mFlags@var1312 |@expr1073746341 flag@var1264 :@expr1073746342 mFlags@var1312 &@expr1073746343 ~@expr1073746344 flag@var1264 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1266 , const Token * tok@var1267 , const Scope * scope@var1268 , const Token * tokDef@var1269 , const Token * tokArgDef@var1270 ) ;
751: Function ( const Token * tokenDef@var1271 , const std :: string & clangType@var1272 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1282 .@expr1073746345 str (@expr1073746346 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1290 .@expr1073746347 size (@expr1073746348 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1290 .@expr1073746349 size (@expr1073746350 ) -@expr1073746351 initArgCount@var1291 ;
764: }
765: const Variable * getArgumentVar ( int num@var1273 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1291 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1274 , const Scope * scope@var1275 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1276 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1277 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1292 ==@expr1073746352 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1292 ==@expr1073746353 eConstructor ||@expr1073746354
785: type@var1292 ==@expr1073746355 eCopyConstructor ||@expr1073746356
786: type@var1292 ==@expr1073746357 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1292 ==@expr1073746358 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1282 .@expr1073746359 isAttributeConstructor (@expr1073746360 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1282 .@expr1073746361 isAttributeDestructor (@expr1073746362 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1282 .@expr1073746363 isAttributePure (@expr1073746364 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1282 .@expr1073746365 isAttributeConst (@expr1073746366 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1282 .@expr1073746367 isAttributeNoreturn (@expr1073746368 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1282 .@expr1073746369 isAttributeNothrow (@expr1073746370 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1282 .@expr1073746371 isAttributeNodiscard (@expr1073746372 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746373 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746374 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746375 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746376 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746377 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746378 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746379 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746380 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746381 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746382 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746383 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746384 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746385 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746386 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746387 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746388 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746389 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746390 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746391 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746392 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746393 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746394 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1278 ) {
881: setFlag (@expr1073746395 fHasBody , state@var1278 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746396 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746397 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1279 ) {
891: setFlag (@expr1073746398 fIsEscapeFunction , state@var1279 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746399 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1280 ) {
898: setFlag (@expr1073746400 fIsConstexpr , state@var1280 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1281 ) const ;
901:
902: const Token * tokenDef@var1282 ;
903: const Token * argDef@var1283 ;
904: const Token * token@var1284 ;
905: const Token * arg@var1285 ;
906: const Token * retDef@var1286 ;
907: const :: Type * retType@var1287 ;
908: const Scope * functionScope@var1288 ;
909: const Scope * nestedIn@var1289 ;
910: std :: list < Variable > argumentList@var1290 ;
911: int initArgCount@var1291 ;
912: Type type@var1292 ;
913: AccessControl access@var1293 ;
914: const Token * noexceptArg@var1294 ;
915: const Token * throwArg@var1295 ;
916: const Token * templateDef@var1296 ;
917: const Token * functionPointerUsage@var1297 ;
918:
919: bool argsMatch ( const Scope * scope@var1298 , const Token * first@var1299 , const Token * second@var1300 , const std :: string & path@var1301 , int path_length@var1302 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1303 , bool unknown@var1304 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1305 , bool unknown@var1306 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1307 , bool unknown@var1308 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1309 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746401 this@expr1073746402 .@expr1073746403 hasTrailingReturnType (@expr1073746404 ) ) {
931: return Token ::@expr1073746405 findmatch (@expr1073746406 retDef@var1286 , "{|;" ) ;
932: } else {
933: return tokenDef@var1282 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1310 , bool * foundAllBaseClasses@var1311 ) const ;
946:
947: unsigned int mFlags@var1312 ;
948:
949: void isInline ( bool state@var1313 ) {
950: setFlag (@expr1073746407 fIsInline , state@var1313 ) ;
951: }
952: void isConst ( bool state@var1314 ) {
953: setFlag (@expr1073746408 fIsConst , state@var1314 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1315 ) {
956: setFlag (@expr1073746409 fHasVirtualSpecifier , state@var1315 ) ;
957: }
958: void isPure ( bool state@var1316 ) {
959: setFlag (@expr1073746410 fIsPure , state@var1316 ) ;
960: }
961: void isStatic ( bool state@var1317 ) {
962: setFlag (@expr1073746411 fIsStatic , state@var1317 ) ;
963: }
964: void isStaticLocal ( bool state@var1318 ) {
965: setFlag (@expr1073746412 fIsStaticLocal , state@var1318 ) ;
966: }
967: void isExtern ( bool state@var1319 ) {
968: setFlag (@expr1073746413 fIsExtern , state@var1319 ) ;
969: }
970: void isFriend ( bool state@var1320 ) {
971: setFlag (@expr1073746414 fIsFriend , state@var1320 ) ;
972: }
973: void isExplicit ( bool state@var1321 ) {
974: setFlag (@expr1073746415 fIsExplicit , state@var1321 ) ;
975: }
976: void isDefault ( bool state@var1322 ) {
977: setFlag (@expr1073746416 fIsDefault , state@var1322 ) ;
978: }
979: void isDelete ( bool state@var1323 ) {
980: setFlag (@expr1073746417 fIsDelete , state@var1323 ) ;
981: }
982: void isNoExcept ( bool state@var1324 ) {
983: setFlag (@expr1073746418 fIsNoExcept , state@var1324 ) ;
984: }
985: void isThrow ( bool state@var1325 ) {
986: setFlag (@expr1073746419 fIsThrow , state@var1325 ) ;
987: }
988: void isOperator ( bool state@var1326 ) {
989: setFlag (@expr1073746420 fIsOperator , state@var1326 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1327 ) {
992: setFlag (@expr1073746421 fHasLvalRefQual , state@var1327 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1328 ) {
995: setFlag (@expr1073746422 fHasRvalRefQual , state@var1328 ) ;
996: }
997: void isVariadic ( bool state@var1329 ) {
998: setFlag (@expr1073746423 fIsVariadic , state@var1329 ) ;
999: }
1000: void isVolatile ( bool state@var1330 ) {
1001: setFlag (@expr1073746424 fIsVolatile , state@var1330 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1331 ) {
1004: return setFlag (@expr1073746425 fHasTrailingReturnType , state@var1331 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1332 ) {
1007: setFlag (@expr1073746426 fIsInlineKeyword , state@var1332 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1333 , const Scope * scope@var1334 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1335 ;
1019: const Scope * scope@var1336 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1337 , const Token * classDef_@var1338 , const Scope * nestedIn_@var1339 ) ;
1025: Scope ( const SymbolDatabase * check_@var1340 , const Token * classDef_@var1341 , const Scope * nestedIn_@var1342 , ScopeType type_@var1343 , const Token * start_@var1344 ) ;
1026:
1027: const SymbolDatabase * check@var1345 ;
1028: std :: string className@var1346 ;
1029: const Token * classDef@var1347 ;
1030: const Token * bodyStart@var1348 ;
1031: const Token * bodyEnd@var1349 ;
1032: std :: list < Function > functionList@var1350 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1351 ;
1034: std :: list < Variable > varlist@var1352 ;
1035: const Scope * nestedIn@var1353 ;
1036: std :: list < Scope * > nestedList@var1354 ;
1037: int numConstructors@var1355 ;
1038: int numCopyOrMoveConstructors@var1356 ;
1039: std :: list < UsingInfo > usingList@var1357 ;
1040: ScopeType type@var1358 ;
1041: Type * definedType@var1359 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1360 ;
1043: std :: vector < const Token * > bodyStartList@var1361 ;
1044:
1045:
1046: const Scope * functionOf@var1362 ;
1047: Function * function@var1363 ;
1048:
1049:
1050: const Token * enumType@var1364 ;
1051: bool enumClass@var1365 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1366 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1367 ) {
1056: bodyStart@var1348 =@expr1073746427 start@var1367 ;
1057: bodyEnd@var1349 =@expr1073746428 start@var1367 ?@expr1073746429 start@var1367 .@expr1073746430 link (@expr1073746431 ) :@expr1073746432 nullptr ;
1058: if (@expr1073746433 start@var1367 ) {
1059: bodyStartList@var1361 .@expr1073746434 push_back (@expr1073746435 start@var1367 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1346 .@expr1073746436 size (@expr1073746437 ) >@expr1073746438 9 &&@expr1073746439 className@var1346 .@expr1073746440 compare (@expr1073746441 0 , 9 , "Anonymous" ) ==@expr1073746442 0 &&@expr1073746443 std ::@expr1073746444 isdigit (@expr1073746445 className@var1346 [@expr1073746446 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1368 ) const {
1068: for (@expr1073746447 const Enumerator &@expr1073746448 i@var1369 :@expr1073746449 enumeratorList@var1366 ) {
1069: if (@expr1073746450 i@var1369 .@expr1073746451 name@var1370 .@expr1073746452 str (@expr1073746453 ) ==@expr1073746454 name@var1368 ) {
1070: return &@expr1073746455 i@var1369 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1371 ) const {
1076: if (@expr1073746456 !@expr1073746457 outer@var1371 ) {
1077: return false ; }
1078: if (@expr1073746458 outer@var1371 ==@expr1073746459 this@expr1073746460 ) {
1079: return true ; }
1080: const Scope * parent@var1372 ; parent@var1372 =@expr1073746461 nestedIn@var1353 ;
1081: while (@expr1073746462 outer@var1371 !=@expr1073746463 parent@var1372 &&@expr1073746464 parent@var1372 ) {
1082: parent@var1372 =@expr1073746465 parent@var1372 .@expr1073746466 nestedIn@var1373 ; }
1083: if (@expr1073746467 parent@var1372 &&@expr1073746468 parent@var1372 ==@expr1073746469 outer@var1371 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1374 ) {
1089: while (@expr1073746470 scope@var1374 ) {
1090: if (@expr1073746471 scope@var1374 .@expr1073746472 type@var1375 ==@expr1073746473 Scope ::@expr1073746474 eFunction ) {
1091: break ; }
1092: scope@var1374 =@expr1073746475 scope@var1374 .@expr1073746476 nestedIn@var1376 ;
1093: }
1094: if (@expr1073746477 !@expr1073746478 scope@var1374 ) {
1095: return nullptr ; }
1096: return scope@var1374 .@expr1073746479 function@var1377 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746480 type@var1358 ==@expr1073746481 eClass ||@expr1073746482 type@var1358 ==@expr1073746483 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746484 type@var1358 ==@expr1073746485 eClass ||@expr1073746486 type@var1358 ==@expr1073746487 eStruct ||@expr1073746488 type@var1358 ==@expr1073746489 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1358 !=@expr1073746490 eClass &&@expr1073746491 type@var1358 !=@expr1073746492 eStruct &&@expr1073746493 type@var1358 !=@expr1073746494 eUnion &&@expr1073746495 type@var1358 !=@expr1073746496 eGlobal &&@expr1073746497 type@var1358 !=@expr1073746498 eNamespace &&@expr1073746499 type@var1358 !=@expr1073746500 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1358 ==@expr1073746501 Scope ::@expr4678 ScopeType ::@expr1073746503 eFor ||@expr1073746504 type@var1358 ==@expr1073746505 Scope ::@expr4678 ScopeType ::@expr1073746507 eWhile ||@expr1073746508 type@var1358 ==@expr1073746509 Scope ::@expr4678 ScopeType ::@expr1073746511 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746512 type@var1358 ==@expr1073746513 eIf ||@expr1073746514 type@var1358 ==@expr1073746515 eElse ||@expr1073746516
1117: type@var1358 ==@expr1073746517 eFor ||@expr1073746518 type@var1358 ==@expr1073746519 eWhile ||@expr1073746520 type@var1358 ==@expr1073746521 eDo ||@expr1073746522
1118: type@var1358 ==@expr1073746523 eSwitch ||@expr1073746524 type@var1358 ==@expr1073746525 eUnconditional ||@expr1073746526
1119: type@var1358 ==@expr1073746527 eTry ||@expr1073746528 type@var1358 ==@expr1073746529 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1378 , bool requireConst@var1379 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1380 , bool isC@var1381 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1382 ) {
1135: return const_cast < Scope *@expr4706 > (@expr1073746531 const_cast < const Scope *@expr4706 > (@expr1073746533 this@expr1073746534 ) .@expr1073746535 findRecordInNestedList (@expr1073746536 name@var1382 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1383 ) const ;
1139: Type * findType ( const std :: string & name@var1384 ) {
1140: return const_cast < Type *@expr4713 > (@expr1073746538 const_cast < const Scope *@expr4713 > (@expr1073746540 this@expr1073746541 ) .@expr1073746542 findType (@expr1073746543 name@var1384 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1385 ) ;
1148:
1149: void addVariable ( const Token * token_@var1386 , const Token * start_@var1387 ,
1150: const Token * end_@var1388 , AccessControl access_@var1389 , const Type * type_@var1390 ,
1151: const Scope * scope_@var1391 , const Settings * settings@var1392 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1393 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1394 ) {
1159: functionList@var1350 .@expr1073746544 push_back (@expr1073746545 func@var1394 ) ;
1160:
1161: const Function * back@var1395 ; back@var1395 =@expr1073746546 &@expr1073746547 functionList@var1350 .@expr1073746548 back (@expr1073746549 ) ;
1162:
1163: functionMap@var1351 .@expr1073746550 insert (@expr1073746551 make_pair (@expr1073746552 back@var1395 .@expr1073746553 tokenDef@var1396 .@expr1073746554 str (@expr1073746555 ) , back@var1395 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1397 , AccessControl varaccess@var1398 , const Settings * settings@var1399 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1400 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1401 , bool isCpp@var1402 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1403 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1404 , const Token * & vartok@var1405 , const Token * & typetok@var1406 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1407 , int args@var1408 , std :: vector < const Function * > & matches@var1409 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1410 , const Token * start@var1411 , const Token * end@var1412 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1413 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1414 ;
1239: int bits@var1415 ;
1240: int pointer@var1416 ;
1241: int constness@var1417 ;
1242: Reference reference@var1418 ; reference@var1418 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1419 ;
1245: const :: Type * smartPointerType@var1420 ;
1246: const Token * smartPointerTypeToken@var1421 ;
1247: const Library :: SmartPointer * smartPointer@var1422 ;
1248: const Library :: Container * container@var1423 ;
1249:
1250: const Token * containerTypeToken@var1424 ;
1251:
1252: std :: string originalTypeName@var1425 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1413 ( UNKNOWN_SIGN ) ,
1257: type@var1414 ( UNKNOWN_TYPE ) ,
1258: bits@var1415 ( 0 ) ,
1259: pointer@var1416 ( 0U ) ,
1260: constness@var1417 ( 0U ) ,
1261: typeScope@var1419 ( nullptr ) ,
1262: smartPointerType@var1420 ( nullptr ) ,
1263: smartPointerTypeToken@var1421 ( nullptr ) ,
1264: smartPointer@var1422 ( nullptr ) ,
1265: container@var1423 ( nullptr ) ,
1266: containerTypeToken@var1424 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1426 , enum Type t@var1427 , int p@var1428 )
1269: : sign@var1413 ( s@var1426 ) ,
1270: type@var1414 ( t@var1427 ) ,
1271: bits@var1415 ( 0 ) ,
1272: pointer@var1416 ( p@var1428 ) ,
1273: constness@var1417 ( 0U ) ,
1274: typeScope@var1419 ( nullptr ) ,
1275: smartPointerType@var1420 ( nullptr ) ,
1276: smartPointerTypeToken@var1421 ( nullptr ) ,
1277: smartPointer@var1422 ( nullptr ) ,
1278: container@var1423 ( nullptr ) ,
1279: containerTypeToken@var1424 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1429 , enum Type t@var1430 , int p@var1431 , int c@var1432 )
1282: : sign@var1413 ( s@var1429 ) ,
1283: type@var1414 ( t@var1430 ) ,
1284: bits@var1415 ( 0 ) ,
1285: pointer@var1416 ( p@var1431 ) ,
1286: constness@var1417 ( c@var1432 ) ,
1287: typeScope@var1419 ( nullptr ) ,
1288: smartPointerType@var1420 ( nullptr ) ,
1289: smartPointerTypeToken@var1421 ( nullptr ) ,
1290: smartPointer@var1422 ( nullptr ) ,
1291: container@var1423 ( nullptr ) ,
1292: containerTypeToken@var1424 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1433 , enum Type t@var1434 , int p@var1435 , int c@var1436 , const std :: string & otn@var1437 )
1295: : sign@var1413 ( s@var1433 ) ,
1296: type@var1414 ( t@var1434 ) ,
1297: bits@var1415 ( 0 ) ,
1298: pointer@var1416 ( p@var1435 ) ,
1299: constness@var1417 ( c@var1436 ) ,
1300: typeScope@var1419 ( nullptr ) ,
1301: smartPointerType@var1420 ( nullptr ) ,
1302: smartPointerTypeToken@var1421 ( nullptr ) ,
1303: smartPointer@var1422 ( nullptr ) ,
1304: container@var1423 ( nullptr ) ,
1305: containerTypeToken@var1424 ( nullptr ) ,
1306: originalTypeName@var1425 ( otn@var1437 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1438 , const Settings * settings@var1439 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1440 , bool longType@var1441 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1442 , const ValueType * func@var1443 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1444 , const Variable * callVar@var1445 , const Variable * funcVar@var1446 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746556 type@var1414 >=@expr1073746557 ValueType ::@expr1073746558 Type ::@expr1073746559 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746560 type@var1414 >=@expr1073746561 ValueType ::@expr4738 Type ::@expr1073746563 BOOL &&@expr1073746564 type@var1414 <=@expr1073746565 ValueType ::@expr4738 Type ::@expr1073746567 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746568 type@var1414 >=@expr1073746569 ValueType ::@expr4746 Type ::@expr1073746571 FLOAT &&@expr1073746572 type@var1414 <=@expr1073746573 ValueType ::@expr4746 Type ::@expr1073746575 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1447 , const Settings * settings@var1448 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1419 &&@expr1073746576 typeScope@var1419 .@expr1073746577 type@var1449 ==@expr1073746578 Scope ::@expr1073746579 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1450 , bool p@var1451 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1452 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1453 , const Settings * settings@var1454 , ErrorLogger * errorLogger@var1455 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1456 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1457 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1458 ;
1359:
1360:
1361: std :: list < Type > typeList@var1459 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1460 , const Token * typeTok@var1461 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1462 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1463 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1464 , const Scope * startScope@var1465 , bool lookOutside@var1466 = false ) const ;
1382: Type * findType ( const Token * startTok@var1467 , Scope * startScope@var1468 , bool lookOutside@var1469 = false ) const {
1383: return const_cast < Type *@expr4756 > (@expr1073746581 this@expr1073746582 .@expr1073746583 findType (@expr1073746584 startTok@var1467 , const_cast < const Scope *@expr4756 > (@expr1073746586 startScope@var1468 ) , lookOutside@var1469 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1470 , const Scope * startScope@var1471 ) const ;
1387: Scope * findScope ( const Token * tok@var1472 , Scope * startScope@var1473 ) const {
1388: return const_cast < Scope *@expr4763 > (@expr1073746588 this@expr1073746589 .@expr1073746590 findScope (@expr1073746591 tok@var1472 , const_cast < const Scope *@expr4763 > (@expr1073746593 startScope@var1473 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1474 ) const {
1392: return varid@var1474 <@expr1073746594 mVariableList@var1531 .@expr1073746595 size (@expr1073746596 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1475 ) const {
1396: return mVariableList@var1531 .@expr1073746597 at (@expr1073746598 varId@var1475 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1531 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1476 , const std :: string & type@var1477 , const std :: string & msg@var1478 ) const ;
1407:
1408: void printOut ( const char * title@var1479 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1480 , const char * indent@var1481 ) const ;
1410: void printXml ( std :: ostream & out@var1482 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1483 , Token * tokens@var1484 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1485 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1486 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1487 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1488 , const Token * * tok@var1489 , const Token * argStart@var1490 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1491 , const Token * tok@var1492 , const Token * argStart@var1493 , const Token * funcStart@var1494 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1495 , const Token * & tok@var1496 , const Token * argStart@var1497 , const Token * funcStart@var1498 ) ;
1469: void addNewFunction ( Scope * * scope@var1499 , const Token * * tok@var1500 ) ;
1470: bool isFunction ( const Token * tok@var1501 , const Scope * outerScope@var1502 , const Token * * funcStart@var1503 , const Token * * argStart@var1504 , const Token * * declEnd@var1505 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1506 , const Scope * startScope@var1507 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1508 , const Scope * scope@var1509 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1510 , const Scope * ns@var1511 , const std :: string & path@var1512 , int path_length@var1513 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1514 , const Token * typeTok@var1515 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1516 , const Token * vartok@var1517 , Token * membertok@var1518 , const Variable * membervar@var1519 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1520 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1521 ) const ;
1485:
1486: void setValueType ( Token * tok@var1522 , const ValueType & valuetype@var1523 ) ;
1487: void setValueType ( Token * tok@var1524 , const Variable & var@var1525 ) ;
1488: void setValueType ( Token * tok@var1526 , const Enumerator & enumerator@var1527 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1528 ;
1491: const Settings * mSettings@var1529 ;
1492: ErrorLogger * mErrorLogger@var1530 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1531 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1532 ;
1499:
1500: bool mIsCpp@var1533 ;
1501: ValueType :: Sign mDefaultSignedness@var1534 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1535 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1536 , const TFunc & visitor@var1537 )
52: {
53: if (@expr1073746599 !@expr1073746600 ast@var1536 ) {
54: return ; }
55:
56: std ::@expr1073746601 stack < T *@expr4778 , std ::@expr1073746603 vector < T *@expr4778 > > tokens@var1538 ;
57: T * tok@var1539 ; tok@var1539 =@expr1073746605 ast@var1536 ;
58: do {
59: ChildrenToVisit c@var1540 ; c@var1540 =@expr1073746606 visitor@var1537 (@expr1073746607 tok@var1539 ) ;
60:
61: if (@expr1073746608 c@var1540 ==@expr1073746609 ChildrenToVisit ::@expr1073746610 done ) {
62: break ; }
63: if (@expr1073746611 c@var1540 ==@expr1073746612 ChildrenToVisit ::@expr1073746613 op2 ||@expr1073746614 c@var1540 ==@expr4791 ChildrenToVisit ::@expr4792 op1_and_op2 ) {
64: T * t2@var1541 ; t2@var1541 =@expr1073746617 tok@var1539 .@expr1073746618 astOperand2 (@expr1073746619 ) ;
65: if (@expr1073746620 t2@var1541 ) {
66: tokens@var1538 .@expr4797 push (@expr1073746622 t2@var1541 ) ; }
67: }
68: if (@expr1073746623 c@var1540 ==@expr1073746624 ChildrenToVisit ::@expr1073746625 op1 ||@expr1073746626 c@var1540 ==@expr4791 ChildrenToVisit ::@expr4792 op1_and_op2 ) {
69: T * t1@var1542 ; t1@var1542 =@expr1073746629 tok@var1539 .@expr1073746630 astOperand1 (@expr1073746631 ) ;
70: if (@expr1073746632 t1@var1542 ) {
71: tokens@var1538 .@expr4797 push (@expr1073746634 t1@var1542 ) ; }
72: }
73:
74: if (@expr1073746635 tokens@var1538 .@expr1073746636 empty (@expr1073746637 ) ) {
75: break ; }
76:
77: tok@var1539 =@expr1073746638 tokens@var1538 .@expr1073746639 top (@expr1073746640 ) ;
78: tokens@var1538 .@expr1073746641 pop (@expr1073746642 ) ;
79: } while (@expr1073746643 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1543 , const std :: function < bool ( const Token * ) > & pred@var1544 ) ;
83: const Token * findExpression ( const int exprid@var1545 ,
84: const Token * start@var1546 ,
85: const Token * end@var1547 ,
86: const std :: function < bool ( const Token * ) > & pred@var1548 ) ;
87: const Token * findExpression ( const Token * start@var1549 , const int exprid@var1550 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1551 , const char * op@var1552 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1553 , const char * op@var1554 ) ;
91:
92: int astCount ( const Token * tok@var1555 , const char * op@var1556 , int depth@var1557 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1558 , const Token * tok@var1559 ) ;
95:
96: bool astHasVar ( const Token * tok@var1560 , int varid@var1561 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1562 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1563 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1564 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1565 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1566 , bool unknown@var1567 ) ;
107: bool astIsUnsigned ( const Token * tok@var1568 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1569 , bool unknown@var1570 ) ;
110:
111: bool astIsBool ( const Token * tok@var1571 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1572 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1573 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1574 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1575 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1576 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1577 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1578 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1579 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1580 , const std :: string & comp@var1581 , const std :: string & rhs@var1582 , const Token * * vartok@var1583 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1584 ) ;
140:
141: bool isTemporary ( bool cpp@var1585 , const Token * tok@var1586 , const Library * library@var1587 , bool unknown@var1588 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1589 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1590 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1591 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1592 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1593 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1594 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1595 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1596 ) ;
155: const Token * getParentLifetime ( bool cpp@var1597 , const Token * tok@var1598 , const Library * library@var1599 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1600 ) ;
158: bool astIsRHS ( const Token * tok@var1601 ) ;
159:
160: Token * getCondTok ( Token * tok@var1602 ) ;
161: const Token * getCondTok ( const Token * tok@var1603 ) ;
162:
163: Token * getInitTok ( Token * tok@var1604 ) ;
164: const Token * getInitTok ( const Token * tok@var1605 ) ;
165:
166: Token * getStepTok ( Token * tok@var1606 ) ;
167: const Token * getStepTok ( const Token * tok@var1607 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1608 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1609 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1610 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1611 ,
180: int * const varid@var1612 ,
181: bool * const knownInitValue@var1613 ,
182: long long * const initValue@var1614 ,
183: bool * const partialCond@var1615 ,
184: long long * const stepValue@var1616 ,
185: long long * const lastValue@var1617 ) ;
186:
187: bool precedes ( const Token * tok1@var1618 , const Token * tok2@var1619 ) ;
188: bool succeeds ( const Token * tok1@var1620 , const Token * tok2@var1621 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1622 , bool onVar@var1623 = true , int depth@var1624 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1625 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1626 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1627 ,
198: bool temporary@var1628 = true ,
199: bool inconclusive@var1629 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1630 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1631 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1632 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1633 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1634 , bool macro@var1635 , const Token * tok1@var1636 , const Token * tok2@var1637 , const Library & library@var1638 , bool pure@var1639 , bool followVar@var1640 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1641 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1642 , const Token * const tok2@var1643 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1644 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1645 , bool cpp@var1646 , const Token * const cond1@var1647 , const Token * const cond2@var1648 , const Library & library@var1649 , bool pure@var1650 , bool followVar@var1651 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1652 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1653 , const Token * const tok1@var1654 , const Token * const tok2@var1655 , const Library & library@var1656 , bool pure@var1657 , bool followVar@var1658 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1659 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1660 , const Library & library@var1661 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1662 , const Library & library@var1663 , bool pure@var1664 , bool cpp@var1665 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1666 , const Token * tok@var1667 , bool checkArrayAccess@var1668 = false , bool checkReference@var1669 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1670 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1671 , const Library * library@var1672 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1673 ,
238: const Library * library@var1674 = nullptr ,
239: const Token * * unknownFunc@var1675 = nullptr ,
240: bool functionScope@var1676 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1677 ,
244: const Variable * var@var1678 ,
245: Scope :: ScopeType type@var1679 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1680 , int & argn@var1681 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1682 , int & argn@var1683 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1684 , int argnr@var1685 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1686 , int indirect@var1687 , int varid@var1688 , const Settings * settings@var1689 , bool * inconclusive@var1690 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1691 , int indirect@var1692 , const Settings * settings@var1693 , bool * inconclusive@var1694 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1695 , const Token * end@var1696 , const int exprid@var1697 , bool globalvar@var1698 , const Settings * settings@var1699 , bool cpp@var1700 , int depth@var1701 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1702 , const Token * end@var1703 , int indirect@var1704 , const int exprid@var1705 , bool globalvar@var1706 , const Settings * settings@var1707 , bool cpp@var1708 , int depth@var1709 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1710 , int indirect@var1711 , const Settings * settings@var1712 , bool cpp@var1713 , int depth@var1714 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1715 , const Settings * settings@var1716 , bool cpp@var1717 , int depth@var1718 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1719 ,
283: const Token * end@var1720 ,
284: int indirect@var1721 ,
285: std :: vector < const Variable * > vars@var1722 ,
286: const Settings * settings@var1723 ,
287: bool cpp@var1724 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1725 , int indirect@var1726 , const Settings * settings@var1727 , bool cpp@var1728 ) ;
290: bool isThisChanged ( const Token * start@var1729 , const Token * end@var1730 , int indirect@var1731 , const Settings * settings@var1732 , bool cpp@var1733 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1734 , const Token * end@var1735 , int indirect@var1736 , const int exprid@var1737 , bool globalvar@var1738 , const Settings * settings@var1739 , bool cpp@var1740 , int depth@var1741 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1742 , const Token * end@var1743 , int indirect@var1744 , const int exprid@var1745 , bool globalvar@var1746 , const Settings * settings@var1747 , bool cpp@var1748 , int depth@var1749 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1750 ,
296: const Token * start@var1751 ,
297: const Token * end@var1752 ,
298: const Settings * settings@var1753 ,
299: bool cpp@var1754 ,
300: int depth@var1755 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1756 ,
303: const Token * tok@var1757 ,
304: int indirect@var1758 ,
305: bool globalvar@var1759 ,
306: const Settings * settings@var1760 ,
307: bool cpp@var1761 ,
308: int depth@var1762 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1763 , int varid@var1764 , bool * inconclusive@var1765 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1766 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1767 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1768 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1769 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1770 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1771 , const Function * f@var1772 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1773 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1774 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1775 ) ;
346: Token * findLambdaEndToken ( Token * first@var1776 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1777 , const Token * stream@var1778 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1779 , const Token * op@var1780 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1781 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1782 , const char * skipMatch@var1783 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1784 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1785 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1786 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1787 , const Library & library@var1788 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1789 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1790 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1791 , bool cpp@var1792 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1793 , const Library & library@var1794 ) : mCpp@var1827 ( cpp@var1793 ) , mLibrary@var1828 ( library@var1794 ) , mWhat@var1829 ( What :: Reassign ) , mValueFlowKnown@var1831 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1795 , const Token * lhs@var1796 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1797 , const Token * startToken@var1798 , const Token * endToken@var1799 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1800 , const Token * startToken@var1801 , const Token * endToken@var1802 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1803 ;
407: const Token * token@var1804 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1805 , const Token * startToken@var1806 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1807 , bool * localOut@var1808 = nullptr , bool * unknownVarIdOut@var1809 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1810 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1811 ;
420: explicit Result ( Type type@var1812 ) : type@var1811 ( type@var1812 ) , token@var1815 ( nullptr ) { }
421: Result ( Type type@var1813 , const Token * token@var1814 ) : type@var1811 ( type@var1813 ) , token@var1815 ( token@var1814 ) { }
422: const Token * token@var1815 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1816 , const Token * startToken@var1817 , const Token * endToken@var1818 ) ;
426: struct Result checkRecursive ( const Token * expr@var1819 , const Token * startToken@var1820 , const Token * endToken@var1821 , const std :: set < int > & exprVarIds@var1822 , bool local@var1823 , bool inInnerClass@var1824 , int depth@var1825 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1826 ) const ;
430:
431: const bool mCpp@var1827 ;
432: const Library & mLibrary@var1828 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1829 ;
434: std :: vector < KnownAndToken > mValueFlow@var1830 ;
435: bool mValueFlowKnown@var1831 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1832 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1833 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1834 ) {
47: mSettings@var1869 =@expr1073746644 settings@var1834 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1869 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1871 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1872 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1835 ) ;
72:
73: void addtoken ( const std :: string & str@var1836 , const int lineno@var1837 , const int column@var1838 , const int fileno@var1839 , bool split@var1840 = false ) ;
74: void addtoken ( const std :: string & str@var1841 , const Token * locationTok@var1842 ) ;
75:
76: void addtoken ( const Token * tok@var1843 , const int lineno@var1844 , const int column@var1845 , const int fileno@var1846 ) ;
77: void addtoken ( const Token * tok@var1847 , const Token * locationTok@var1848 ) ;
78: void addtoken ( const Token * tok@var1849 ) ;
79:
80: static void insertTokens ( Token * dest@var1850 , const Token * src@var1851 , int n@var1852 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1853 , const Token * first@var1854 , const Token * last@var1855 , bool one_line@var1856 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1857 , const std :: string & file0@var1858 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1859 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1860 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1866 .@expr1073746645 front@var1873 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1866 .@expr1073746646 front@var1873 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1866 .@expr1073746647 back@var1874 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1866 .@expr1073746648 back@var1874 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1867 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1861 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1862 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1863 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1864 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1865 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1866 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1867 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1868 ;
212:
213:
214: const Settings * mSettings@var1869 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1870 ;
217:
218:
219: bool mIsC@var1871 ;
220: bool mIsCpp@var1872 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var1875 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var1876 ;
67: mutable int mVarId@var1877 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var1878 ) ;
73: bool hasVariable ( const std :: string & varname@var1879 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var1880 ) const {
75: return mVariableId@var1875 .@expr1073746649 find (@expr1073746650 varname@var1880 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var1875 .@expr1073746651 end (@expr1073746652 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var1875 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746653 mVarId@var1877 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var1881 , ErrorLogger * errorLogger@var1882 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var1883 ) {
95: mTimerResults@var2003 =@expr1073746654 tr@var1883 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var1981 .@expr1073746655 isC (@expr1073746656 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var1981 .@expr1073746657 isCPP (@expr1073746658 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var1884 , bool * unknown@var1885 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var1886 , const std :: string & FileName@var1887 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var1888 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var1889 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var1890 ,
142: const char FileName@var1891 [ ] ,
143: const std :: string & configuration@var1892 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var1893 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var1894 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var1895 , const Token * end@var1896 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var1897 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var1898 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var1899 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var1900 , const Token * const tokEnd@var1901 , const bool only_k_r_fpar@var1902 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var1903 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var1904 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var1905 , bool commandWithCondition@var1906 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var1907 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var1908 , Token * * _tok2@var1909 , Token * * _tok3@var1910 , std :: string & value@var1911 , int & valueVarId@var1912 , bool & valueIsPointer@var1913 , bool floatvar@var1914 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var1915 , Token * tok3@var1916 , int varid@var1917 , const std :: string & structname@var1918 , std :: string & value@var1919 , int valueVarId@var1920 , bool valueIsPointer@var1921 , const Token * const valueToken@var1922 , int indentlevel@var1923 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var1924 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var1925 , const std :: string & endsWith@var1926 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1927 , const std :: string & endsWith@var1928 , bool cpp@var1929 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1930 ) {
585: mPreprocessor@var2004 =@expr1073746659 preprocessor@var1930 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2004 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1931 , const Token * end@var1932 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1933 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1934 , const std :: string & code@var1935 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1936 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1937 , const std :: string & what@var1938 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1939 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1940 , const std :: string & msg@var1941 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1942 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1943 , const std :: string & macroName@var1944 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1945 , const Token * end@var1946 , bool allowSemicolon@var1947 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1948 , const Severity :: SeverityType severity@var1949 , const std :: string & id@var1950 , const std :: string & msg@var1951 , bool inconclusive@var1952 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1953 , Severity :: SeverityType severity@var1954 , const std :: string & id@var1955 , const std :: string & msg@var1956 , bool inconclusive@var1957 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1958 , const Token * name@var1959 , const Token * typeDef@var1960 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1961 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1962 ,
821: const VariableMap & variableMap@var1963 ,
822: const int scopeStartVarId@var1964 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1965 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1966 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1967 ,
827: int * varId@var1968 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1969 ,
830: Token * const startToken@var1970 ,
831: const Token * const endToken@var1971 ,
832: const std :: map < std :: string , int > & varlist@var1972 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1973 ,
834: int * varId_@var1974 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1975 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1976 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2002 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1977 ) {
861: mSettings@var1988 =@expr1073746660 settings@var1977 ;
862: list@var1981 .@expr1073746661 setSettings (@expr1073746662 settings@var1977 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var1990 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1978 ) const ;
877:
878: void dump ( std :: ostream & out@var1979 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var1980 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2000 ;
888: }
889:
|
892:
893: TokenList list@var1981 ;
894:
895: const Token * tokens ( ) const {
896: return list@var1981 .@expr1073746663 front (@expr1073746664 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var1982 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var1983 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var1984 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var1985 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var1988 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var1986 , bool inOperator@var1987 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746665 mVarId@var2000 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var1988 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var1989 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var1990 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var1991 ;
973:
974:
975:
976: std :: string mConfiguration@var1992 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var1993 ;
980:
981: struct TypedefInfo {
982: std :: string name@var1994 ;
983: std :: string filename@var1995 ;
984: int lineNumber@var1996 ;
985: int column@var1997 ;
986: bool used@var1998 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var1999 ;
989:
990:
991: int mVarId@var2000 ;
992:
993:
994: int mUnnamedCount@var2001 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2002 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2003 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2004 ;
1013: } ;

##file cppcheck-2.8/lib/checkmemoryleak.h

1:
|
42:
43: class Function ;
44: class Scope ;
45: class Settings ;
46: class Token ;
47: class Variable ;
48: class ErrorLogger ;
49:
|
53:
54: class CheckMemoryLeak {
55: private:
56:
57: const Tokenizer * const mTokenizer_@var2005 ;
58:
59:
60: ErrorLogger * const mErrorLogger_@var2006 ;
61:
62:
63: const Settings * const mSettings_@var2007 ;
64:
|
72:
73: void reportErr ( const Token * tok@var2008 , Severity :: SeverityType severity@var2009 , const std :: string & id@var2010 , const std :: string & msg@var2011 , const CWE & cwe@var2012 ) const ;
74:
|
82:
83: void reportErr ( const std :: list < const Token * > & callstack@var2013 , Severity :: SeverityType severity@var2014 , const std :: string & id@var2015 , const std :: string & msg@var2016 , const CWE & cwe@var2017 ) const ;
84:
85: public:
86: CheckMemoryLeak ( ) = delete ;
87: CheckMemoryLeak ( const CheckMemoryLeak & ) = delete ;
88: void operator= ( const CheckMemoryLeak & ) = delete ;
89:
90: CheckMemoryLeak ( const Tokenizer * t@var2018 , ErrorLogger * e@var2019 , const Settings * s@var2020 )
91: : mTokenizer_@var2005 ( t@var2018 ) , mErrorLogger_@var2006 ( e@var2019 ) , mSettings_@var2007 ( s@var2020 ) { }
92:
93:
94: enum AllocType { No , Malloc , New , NewArray , File , Fd , Pipe , OtherMem , OtherRes , Many } ;
95:
96: void memoryLeak ( const Token * tok@var2021 , const std :: string & varname@var2022 , AllocType alloctype@var2023 ) const ;
97:
|
103:
104: AllocType getDeallocationType ( const Token * tok@var2024 , int varid@var2025 ) const ;
105:
|
108:
109: AllocType getAllocationType ( const Token * tok2@var2026 , int varid@var2027 , std :: list < const Function * > * callstack@var2028 = nullptr ) const ;
110:
|
113:
114: AllocType getReallocationType ( const Token * tok2@var2029 , int varid@var2030 ) const ;
115:
|
119:
120: bool isReopenStandardStream ( const Token * tok@var2031 ) const ;
121:
|
125:
126: void memleakError ( const Token * tok@var2032 , const std :: string & varname@var2033 ) const ;
127:
|
132:
133: void resourceLeakError ( const Token * tok@var2034 , const std :: string & varname@var2035 ) const ;
134:
|
139:
140: void deallocDeallocError ( const Token * tok@var2036 , const std :: string & varname@var2037 ) const ;
141: void deallocuseError ( const Token * tok@var2038 , const std :: string & varname@var2039 ) const ;
142: void mismatchSizeError ( const Token * tok@var2040 , const std :: string & sz@var2041 ) const ;
143: void mismatchAllocDealloc ( const std :: list < const Token * > & callstack@var2042 , const std :: string & varname@var2043 ) const ;
144: void memleakUponReallocFailureError ( const Token * tok@var2044 , const std :: string & reallocfunction@var2045 , const std :: string & varname@var2046 ) const ;
145:
146:
147: AllocType functionReturnType ( const Function * func@var2047 , std :: list < const Function * > * callstack@var2048 = nullptr ) const ;
148: } ;
149:
|
167:
168: class CheckMemoryLeakInFunction : private Check , public CheckMemoryLeak {
169: public:
170:
171: CheckMemoryLeakInFunction ( ) : Check ( myName ( ) ) , CheckMemoryLeak ( nullptr , nullptr , nullptr ) { }
172:
173:
174: CheckMemoryLeakInFunction ( const Tokenizer * tokenizer@var2049 , const Settings * settings@var2050 , ErrorLogger * errorLogger@var2051 )
175: : Check ( myName ( ) , tokenizer@var2049 , settings@var2050 , errorLogger@var2051 ) , CheckMemoryLeak ( tokenizer@var2049 , errorLogger@var2051 , settings@var2050 ) { }
176:
177: void runChecks ( const Tokenizer * tokenizer@var2052 , const Settings * settings@var2053 , ErrorLogger * errorLogger@var2054 ) override {
178: CheckMemoryLeakInFunction checkMemoryLeak@var2055 (@expr1073746666 tokenizer@var2052 , settings@var2053 , errorLogger@var2054 ) ;
179: checkMemoryLeak@var2055 .@expr1073746667 checkReallocUsage (@expr1073746668 ) ;
180: }
181:
182:
183: static bool test_white_list ( const std :: string & funcname@var2056 , const Settings * settings@var2057 , bool cpp@var2058 ) ;
184:
|
187:
188: void checkReallocUsage ( ) ;
189:
190: private:
191:
192: void getErrorMessages ( ErrorLogger * e@var2059 , const Settings * settings@var2060 ) const override {
193: CheckMemoryLeakInFunction c@var2061 (@expr1073746669 nullptr , settings@var2060 , e@var2059 ) ;
194:
195: c@var2061 .@expr1073746670 memleakError (@expr1073746671 nullptr , "varname" ) ;
196: c@var2061 .@expr1073746672 resourceLeakError (@expr1073746673 nullptr , "varname" ) ;
197:
198: c@var2061 .@expr1073746674 deallocDeallocError (@expr1073746675 nullptr , "varname" ) ;
199: c@var2061 .@expr1073746676 deallocuseError (@expr1073746677 nullptr , "varname" ) ;
200: c@var2061 .@expr1073746678 mismatchSizeError (@expr1073746679 nullptr , "sz" ) ;
201: const std ::@expr1073746680 list < const Token *@expr1073746681 > callstack@var2062 ;
202: c@var2061 .@expr1073746682 mismatchAllocDealloc (@expr1073746683 callstack@var2062 , "varname" ) ;
203: c@var2061 .@expr1073746684 memleakUponReallocFailureError (@expr1073746685 nullptr , "realloc" , "varname" ) ;
204: }
205:
|
209:
210: static std :: string myName ( ) {
211: return "Memory leaks (function variables)" ;
212: }
213:
|
217:
218: std :: string classInfo ( ) const override {
219: return "Is there any allocated memory when a function goes out of scope\n" ;
220: }
221: } ;
222:
|
228:
229: class CheckMemoryLeakInClass : private Check , private CheckMemoryLeak {
230: public:
231: CheckMemoryLeakInClass ( ) : Check ( myName ( ) ) , CheckMemoryLeak ( nullptr , nullptr , nullptr ) { }
232:
233: CheckMemoryLeakInClass ( const Tokenizer * tokenizer@var2063 , const Settings * settings@var2064 , ErrorLogger * errorLogger@var2065 )
234: : Check ( myName ( ) , tokenizer@var2063 , settings@var2064 , errorLogger@var2065 ) , CheckMemoryLeak ( tokenizer@var2063 , errorLogger@var2065 , settings@var2064 ) { }
235:
236: void runChecks ( const Tokenizer * tokenizr@var2066 , const Settings * settings@var2067 , ErrorLogger * errLog@var2068 ) override {
237: if (@expr1073746686 !@expr1073746687 tokenizr@var2066 .@expr1073746688 isCPP (@expr1073746689 ) ) {
238: return ; }
239:
240: CheckMemoryLeakInClass checkMemoryLeak@var2069 (@expr1073746690 tokenizr@var2066 , settings@var2067 , errLog@var2068 ) ;
241: checkMemoryLeak@var2069 .@expr1073746691 check (@expr1073746692 ) ;
242: }
243:
244: void check ( ) ;
245:
246: private:
247: void variable ( const Scope * scope@var2070 , const Token * tokVarname@var2071 ) ;
248:
249:
250: void checkPublicFunctions ( const Scope * scope@var2072 , const Token * classtok@var2073 ) ;
251: void publicAllocationError ( const Token * tok@var2074 , const std :: string & varname@var2075 ) ;
252:
253: void unsafeClassError ( const Token * tok@var2076 , const std :: string & classname@var2077 , const std :: string & varname@var2078 ) ;
254:
255: void getErrorMessages ( ErrorLogger * e@var2079 , const Settings * settings@var2080 ) const override {
256: CheckMemoryLeakInClass c@var2081 (@expr1073746693 nullptr , settings@var2080 , e@var2079 ) ;
257: c@var2081 .@expr1073746694 publicAllocationError (@expr1073746695 nullptr , "varname" ) ;
258: c@var2081 .@expr1073746696 unsafeClassError (@expr1073746697 nullptr , "class" , "class::varname" ) ;
259: }
260:
261: static std :: string myName ( ) {
262: return "Memory leaks (class variables)" ;
263: }
264:
265: std :: string classInfo ( ) const override {
266: return "If the constructor allocate memory then the destructor must deallocate it.\n" ;
267: }
268: } ;
269:
|
273:
274: class CheckMemoryLeakStructMember : private Check , private CheckMemoryLeak {
275: public:
276: CheckMemoryLeakStructMember ( ) : Check ( myName ( ) ) , CheckMemoryLeak ( nullptr , nullptr , nullptr ) { }
277:
278: CheckMemoryLeakStructMember ( const Tokenizer * tokenizer@var2082 , const Settings * settings@var2083 , ErrorLogger * errorLogger@var2084 )
279: : Check ( myName ( ) , tokenizer@var2082 , settings@var2083 , errorLogger@var2084 ) , CheckMemoryLeak ( tokenizer@var2082 , errorLogger@var2084 , settings@var2083 ) { }
280:
281: void runChecks ( const Tokenizer * tokenizer@var2085 , const Settings * settings@var2086 , ErrorLogger * errorLogger@var2087 ) override {
282: CheckMemoryLeakStructMember checkMemoryLeak@var2088 (@expr1073746698 tokenizer@var2085 , settings@var2086 , errorLogger@var2087 ) ;
283: checkMemoryLeak@var2088 .@expr1073746699 check (@expr1073746700 ) ;
284: }
285:
286: void check ( ) ;
287:
288: private:
289:
290:
291: static bool isMalloc ( const Variable * variable@var2089 ) ;
292:
293: void checkStructVariable ( const Variable * const variable@var2090 ) ;
294:
295: void getErrorMessages ( ErrorLogger * , const Settings * ) const override { }
296:
297: static std :: string myName ( ) {
298: return "Memory leaks (struct members)" ;
299: }
300:
301: std :: string classInfo ( ) const override {
302: return "Don't forget to deallocate struct members\n" ;
303: }
304: } ;
305:
|
309:
310: class CheckMemoryLeakNoVar : private Check , private CheckMemoryLeak {
311: public:
312: CheckMemoryLeakNoVar ( ) : Check ( myName ( ) ) , CheckMemoryLeak ( nullptr , nullptr , nullptr ) { }
313:
314: CheckMemoryLeakNoVar ( const Tokenizer * tokenizer@var2091 , const Settings * settings@var2092 , ErrorLogger * errorLogger@var2093 )
315: : Check ( myName ( ) , tokenizer@var2091 , settings@var2092 , errorLogger@var2093 ) , CheckMemoryLeak ( tokenizer@var2091 , errorLogger@var2093 , settings@var2092 ) { }
316:
317: void runChecks ( const Tokenizer * tokenizer@var2094 , const Settings * settings@var2095 , ErrorLogger * errorLogger@var2096 ) override {
318: CheckMemoryLeakNoVar checkMemoryLeak@var2097 (@expr1073746701 tokenizer@var2094 , settings@var2095 , errorLogger@var2096 ) ;
319: checkMemoryLeak@var2097 .@expr1073746702 check (@expr1073746703 ) ;
320: }
321:
322: void check ( ) ;
323:
324: private:
325:
|
329:
330: void checkForUnreleasedInputArgument ( const Scope * scope@var2098 ) ;
331:
|
335:
336: void checkForUnusedReturnValue ( const Scope * scope@var2099 ) ;
337:
|
341:
342: void checkForUnsafeArgAlloc ( const Scope * scope@var2100 ) ;
343:
344: void functionCallLeak ( const Token * loc@var2101 , const std :: string & alloc@var2102 , const std :: string & functionCall@var2103 ) ;
345: void returnValueNotUsedError ( const Token * tok@var2104 , const std :: string & alloc@var2105 ) ;
346: void unsafeArgAllocError ( const Token * tok@var2106 , const std :: string & funcName@var2107 , const std :: string & ptrType@var2108 , const std :: string & objType@var2109 ) ;
347:
348: void getErrorMessages ( ErrorLogger * e@var2110 , const Settings * settings@var2111 ) const override {
349: CheckMemoryLeakNoVar c@var2112 (@expr1073746704 nullptr , settings@var2111 , e@var2110 ) ;
350:
351: c@var2112 .@expr1073746705 functionCallLeak (@expr1073746706 nullptr , "funcName" , "funcName" ) ;
352: c@var2112 .@expr1073746707 returnValueNotUsedError (@expr1073746708 nullptr , "funcName" ) ;
353: c@var2112 .@expr1073746709 unsafeArgAllocError (@expr1073746710 nullptr , "funcName" , "shared_ptr" , "int" ) ;
354: }
355:
356: static std :: string myName ( ) {
357: return "Memory leaks (address not taken)" ;
358: }
359:
360: std :: string classInfo ( ) const override {
361: return "Not taking the address to allocated memory\n" ;
362: }
363: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var2113 ;
43: std :: string errorId@var2114 ;
44: void setFileName ( const std :: string & s@var2115 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var2119 ;
47: }
48: int lineNumber@var2116 ;
49: Certainty :: CertaintyLevel certainty@var2117 ;
50: std :: string symbolNames@var2118 ;
51: private:
52: std :: string mFileName@var2119 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2153 ( NO_LINE ) , hash@var2155 ( 0 ) , thisAndNextLine@var2156 ( false ) , matched@var2157 ( false ) , checked@var2158 ( false ) { }
57: Suppression ( const Suppression & other@var2120 ) {
58: *@expr1073746711 this@expr1073746712 =@expr1073746713 other@var2120 ;
59: }
60: Suppression ( const std :: string & id@var2121 , const std :: string & file@var2122 , int line@var2123 = NO_LINE ) : errorId@var2151 ( id@var2121 ) , fileName@var2152 ( file@var2122 ) , lineNumber@var2153 ( line@var2123 ) , hash@var2155 ( 0 ) , thisAndNextLine@var2156 ( false ) , matched@var2157 ( false ) , checked@var2158 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var2124 ) {
63: errorId@var2151 =@expr1073746714 other@var2124 .@expr1073746715 errorId@var2125 ;
64: fileName@var2152 =@expr1073746716 other@var2124 .@expr1073746717 fileName@var2126 ;
65: lineNumber@var2153 =@expr1073746718 other@var2124 .@expr1073746719 lineNumber@var2127 ;
66: symbolName@var2154 =@expr1073746720 other@var2124 .@expr1073746721 symbolName@var2128 ;
67: hash@var2155 =@expr1073746722 other@var2124 .@expr1073746723 hash@var2129 ;
68: thisAndNextLine@var2156 =@expr1073746724 other@var2124 .@expr1073746725 thisAndNextLine@var2130 ;
69: matched@var2157 =@expr1073746726 other@var2124 .@expr1073746727 matched@var2131 ;
70: checked@var2158 =@expr1073746728 other@var2124 .@expr1073746729 checked@var2132 ;
71: return *@expr1073746730 this@expr1073746731 ;
72: }
73:
74: bool operator< ( const Suppression & other@var2133 ) const {
75: if (@expr1073746732 errorId@var2151 !=@expr1073746733 other@var2133 .@expr4910 errorId@var2134 ) {
76: return errorId@var2151 <@expr1073746735 other@var2133 .@expr4910 errorId@var2134 ; }
77: if (@expr1073746737 lineNumber@var2153 <@expr1073746738 other@var2133 .@expr1073746739 lineNumber@var2135 ) {
78: return true ; }
79: if (@expr1073746740 fileName@var2152 !=@expr1073746741 other@var2133 .@expr4918 fileName@var2136 ) {
80: return fileName@var2152 <@expr1073746743 other@var2133 .@expr4918 fileName@var2136 ; }
81: if (@expr1073746745 symbolName@var2154 !=@expr1073746746 other@var2133 .@expr4923 symbolName@var2137 ) {
82: return symbolName@var2154 <@expr1073746748 other@var2133 .@expr4923 symbolName@var2137 ; }
83: if (@expr1073746750 hash@var2155 !=@expr1073746751 other@var2133 .@expr4928 hash@var2138 ) {
84: return hash@var2155 <@expr1073746753 other@var2133 .@expr4928 hash@var2138 ; }
85: if (@expr1073746755 thisAndNextLine@var2156 !=@expr1073746756 other@var2133 .@expr1073746757 thisAndNextLine@var2139 ) {
86: return thisAndNextLine@var2156 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2140 , std :: string * errorMessage@var2141 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2142 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2143 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746759 fileName@var2152 .@expr1073746760 empty (@expr1073746761 ) &&@expr1073746762 fileName@var2152 .@expr1073746763 find_first_of (@expr1073746764 "?*" ) ==@expr1073746765 std ::@expr1073746766 string ::@expr1073746767 npos@expr1073746758 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2144 ) const {
109: return errorId@var2151 ==@expr1073746768 other@var2144 .@expr1073746769 errorId@var2145 &&@expr1073746770
110: fileName@var2152 ==@expr1073746771 other@var2144 .@expr1073746772 fileName@var2146 &&@expr1073746773
111: lineNumber@var2153 ==@expr1073746774 other@var2144 .@expr1073746775 lineNumber@var2147 &&@expr1073746776
112: symbolName@var2154 ==@expr1073746777 other@var2144 .@expr1073746778 symbolName@var2148 &&@expr1073746779
113: hash@var2155 ==@expr1073746780 other@var2144 .@expr1073746781 hash@var2149 &&@expr1073746782
114: thisAndNextLine@var2156 ==@expr1073746783 other@var2144 .@expr1073746784 thisAndNextLine@var2150 ;
115: }
116:
117: std :: string errorId@var2151 ;
118: std :: string fileName@var2152 ;
119: int lineNumber@var2153 ;
120: std :: string symbolName@var2154 ;
121: unsigned long hash@var2155 ;
122: bool thisAndNextLine@var2156 ;
123: bool matched@var2157 ;
124: bool checked@var2158 ;
125:
126: enum Anonymous4 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2159 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2160 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2161 , std :: string * errorMessage@var2162 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2163 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2164 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2165 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2166 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2167 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2168 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2169 , const bool unusedFunctionChecking@var2170 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2171 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2172 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2173 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var2174 , const Color & c@var2175 ) ;
42:
43: std :: string toString ( const Color & c@var2176 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var2177 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var2178 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var2179 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var2180 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var2181 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var2197 ( 0 ) , line@var2198 ( 0 ) , column@var2199 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var2182 , int line@var2183 , unsigned int column@var2184 )
73: : fileIndex@var2197 ( 0 ) , line@var2198 ( line@var2183 ) , column@var2199 ( column@var2184 ) , mOrigFileName@var2201 ( file@var2182 ) , mFileName@var2202 ( file@var2182 ) { }
74:
75: FileLocation ( const std :: string & file@var2185 , const std :: string & info@var2186 , int line@var2187 , unsigned int column@var2188 )
76: : fileIndex@var2197 ( 0 ) , line@var2198 ( line@var2187 ) , column@var2199 ( column@var2188 ) , mOrigFileName@var2201 ( file@var2185 ) , mFileName@var2202 ( file@var2185 ) , mInfo@var2203 ( info@var2186 ) { }
77:
78: FileLocation ( const Token * tok@var2189 , const TokenList * tokenList@var2190 ) ;
79: FileLocation ( const Token * tok@var2191 , const std :: string & info@var2192 , const TokenList * tokenList@var2193 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var2194 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var2195 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var2196 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var2197 ;
107: int line@var2198 ;
108: unsigned int column@var2199 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var2203 ;
112: }
113: void setinfo ( const std :: string & i@var2200 ) {
114: mInfo@var2203 =@expr1073746785 i@var2200 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var2201 ;
119: std :: string mFileName@var2202 ;
120: std :: string mInfo@var2203 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var2204 ,
124: const std :: string & file1@var2205 ,
125: Severity :: SeverityType severity@var2206 ,
126: const std :: string & msg@var2207 ,
127: const std :: string & id@var2208 , Certainty :: CertaintyLevel certainty@var2209 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var2210 ,
129: const std :: string & file1@var2211 ,
130: Severity :: SeverityType severity@var2212 ,
131: const std :: string & msg@var2213 ,
132: const std :: string & id@var2214 ,
133: const CWE & cwe@var2215 ,
134: Certainty :: CertaintyLevel certainty@var2216 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var2217 ,
136: const TokenList * list@var2218 ,
137: Severity :: SeverityType severity@var2219 ,
138: const std :: string & id@var2220 ,
139: const std :: string & msg@var2221 ,
140: Certainty :: CertaintyLevel certainty@var2222 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var2223 ,
142: const TokenList * list@var2224 ,
143: Severity :: SeverityType severity@var2225 ,
144: const std :: string & id@var2226 ,
145: const std :: string & msg@var2227 ,
146: const CWE & cwe@var2228 ,
147: Certainty :: CertaintyLevel certainty@var2229 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var2230 ,
149: const TokenList * tokenList@var2231 ,
150: Severity :: SeverityType severity@var2232 ,
151: const char id@var2233 [ ] ,
152: const std :: string & msg@var2234 ,
153: const CWE & cwe@var2235 ,
154: Certainty :: CertaintyLevel certainty@var2236 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var2237 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var2238 ,
176: const std :: string & templateFormat@var2239 = emptyString@var1 ,
177: const std :: string & templateLocation@var2240 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var2241 ) ;
181:
182: std :: list < FileLocation > callStack@var2242 ;
183: std :: string id@var2243 ;
184:
185:
186: std :: string file0@var2244 ;
187:
188: std :: string function@var2245 ;
189:
190: bool incomplete@var2246 ;
191:
192: Severity :: SeverityType severity@var2247 ;
193: CWE cwe@var2248 ;
194: Certainty :: CertaintyLevel certainty@var2249 ;
195:
196:
197: unsigned long hash@var2250 ;
198:
199:
200: void setmsg ( const std :: string & msg@var2251 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var2253 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var2254 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var2255 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var2252 ) ;
221:
222:
223: std :: string mShortMessage@var2253 ;
224:
225:
226: std :: string mVerboseMessage@var2254 ;
227:
228:
229: std :: string mSymbolNames@var2255 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var2256 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073746786 plistFile@var2256 .@expr1073746787 is_open (@expr1073746788 ) ) {
243: plistFile@var2256 <<@expr1073746789 ErrorLogger ::@expr1073746790 plistFooter (@expr1073746791 ) ;
244: plistFile@var2256 .@expr1073746792 close (@expr1073746793 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var2257 , Color c@var2258 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var2259 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var2260 , const char stage@var2261 [ ] , const unsigned long value@var2262 ) {
271: (@expr1073746794 void ) filename@var2260 ;
272: (@expr1073746795 void ) stage@var2261 ;
273: (@expr1073746796 void ) value@var2262 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var2263 ) {
281: reportErr (@expr1073746797 msg@var2263 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var2264 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var2265 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var2266 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var2267 , const std :: vector < std :: string > & files@var2268 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var2269 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var2270 , const std :: string & from@var2271 , const std :: string & to@var2272 ) ;

##file cppcheck-2.8/lib/ctu.h

1:
|
36:
37: class Function ;
38: class Settings ;
39: class Token ;
40: class Tokenizer ;
41:
42: namespace tinyxml2 {
43: class XMLElement ;
44: }
45:
|
50:
51: namespace CTU {
52: class FileInfo : public Check :: FileInfo {
53: public:
54: enum class InvalidValueType { null , uninit , bufferOverflow } ;
55:
56: std :: string toString ( ) const override ;
57:
58: struct Location {
59: Location ( ) = default ;
60: Location ( const Tokenizer * tokenizer@var2273 , const Token * tok@var2274 ) ;
61: Location ( const std :: string & fileName@var2275 , int lineNumber@var2276 , int column@var2277 ) : fileName@var2278 ( fileName@var2275 ) , lineNumber@var2279 ( lineNumber@var2276 ) , column@var2280 ( column@var2277 ) { }
62: std :: string fileName@var2278 ;
63: int lineNumber@var2279 { } ;
64: int column@var2280 { } ;
65: } ;
66:
67: struct UnsafeUsage {
68: UnsafeUsage ( ) = default ;
69: UnsafeUsage ( const std :: string & myId@var2281 , int myArgNr@var2282 , const std :: string & myArgumentName@var2283 , const Location & location@var2284 , long long value@var2285 ) : myId@var2286 ( myId@var2281 ) , myArgNr@var2287 ( myArgNr@var2282 ) , myArgumentName@var2288 ( myArgumentName@var2283 ) , location@var2289 ( location@var2284 ) , value@var2290 ( value@var2285 ) { }
70: std :: string myId@var2286 ;
71: int myArgNr@var2287 { } ;
72: std :: string myArgumentName@var2288 ;
73: Location location@var2289 ;
74: long long value@var2290 { } ;
75: std :: string toString ( ) const ;
76: } ;
77:
78: class CallBase {
79: public:
80: CallBase ( ) = default ;
81: CallBase ( const std :: string & callId@var2291 , int callArgNr@var2292 , const std :: string & callFunctionName@var2293 , const Location & loc@var2294 )
82: : callId@var2297 ( callId@var2291 ) , callArgNr@var2298 ( callArgNr@var2292 ) , callFunctionName@var2299 ( callFunctionName@var2293 ) , location@var2300 ( loc@var2294 )
83: { }
84: CallBase ( const Tokenizer * tokenizer@var2295 , const Token * callToken@var2296 ) ;
85: virtual ~ CallBase ( ) { }
86: std :: string callId@var2297 ;
87: int callArgNr@var2298 { } ;
88: std :: string callFunctionName@var2299 ;
89: Location location@var2300 ;
90: protected:
91: std :: string toBaseXmlString ( ) const ;
92: bool loadBaseFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2301 ) ;
93: } ;
94:
95: class FunctionCall : public CallBase {
96: public:
97: std :: string callArgumentExpression@var2302 ;
98: long long callArgValue@var2303 ;
99: ValueFlow :: Value :: ValueType callValueType@var2304 ;
100: std :: vector < ErrorMessage :: FileLocation > callValuePath@var2305 ;
101: bool warning@var2306 ;
102:
103: std :: string toXmlString ( ) const ;
104: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2307 ) ;
105: } ;
106:
107: class NestedCall : public CallBase {
108: public:
109: NestedCall ( ) = default ;
110:
111: NestedCall ( const std :: string & myId@var2308 , int myArgNr@var2309 , const std :: string & callId@var2310 , int callArgnr@var2311 , const std :: string & callFunctionName@var2312 , const Location & location@var2313 )
112: : CallBase ( callId@var2310 , callArgnr@var2311 , callFunctionName@var2312 , location@var2313 ) ,
113: myId@var2318 ( myId@var2308 ) ,
114: myArgNr@var2319 ( myArgNr@var2309 ) { }
115:
116: NestedCall ( const Tokenizer * tokenizer@var2314 , const Function * myFunction@var2315 , const Token * callToken@var2316 ) ;
117:
118: std :: string toXmlString ( ) const ;
119: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2317 ) ;
120:
121: std :: string myId@var2318 ;
122: int myArgNr@var2319 { } ;
123: } ;
124:
125: std :: list < FunctionCall > functionCalls@var2320 ;
126: std :: list < NestedCall > nestedCalls@var2321 ;
127:
128: void loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2322 ) ;
129: std :: map < std :: string , std :: list < const CallBase * > > getCallsMap ( ) const ;
130:
131: static std :: list < ErrorMessage :: FileLocation > getErrorPath ( InvalidValueType invalidValue@var2323 ,
132: const UnsafeUsage & unsafeUsage@var2324 ,
133: const std :: map < std :: string , std :: list < const CallBase * > > & callsMap@var2325 ,
134: const char info@var2326 [ ] ,
135: const FunctionCall * * const functionCallPtr@var2327 ,
136: bool warning@var2328 ) ;
137: } ;
138:
139: extern int maxCtuDepth@var2329 ;
140:
141: std :: string toString ( const std :: list < FileInfo :: UnsafeUsage > & unsafeUsage@var2330 ) ;
142:
143: std :: string getFunctionId ( const Tokenizer * tokenizer@var2331 , const Function * function@var2332 ) ;
144:
145:
146: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2333 ) ;
147:
148: std :: list < FileInfo :: UnsafeUsage > getUnsafeUsage ( const Tokenizer * tokenizer@var2334 , const Settings * settings@var2335 , const Check * check@var2336 , bool ( * isUnsafeUsage@var2337 ) ( const Check * , const Token * , long long * ) ) ;
149:
150: std :: list < FileInfo :: UnsafeUsage > loadUnsafeUsageListFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2338 ) ;
151: }

##file cppcheck-2.8/lib/checknullpointer.h

1:
|
32:
33: class ErrorLogger ;
34: class Library ;
35: class Settings ;
36: class Token ;
37: class Tokenizer ;
38:
39: namespace tinyxml2 {
40: class XMLElement ;
41: }
42:
|
48:
49: class CheckNullPointer : public Check {
50: public:
51:
52: CheckNullPointer ( ) : Check ( myName ( ) ) { }
53:
54:
55: CheckNullPointer ( const Tokenizer * tokenizer@var2339 , const Settings * settings@var2340 , ErrorLogger * errorLogger@var2341 )
56: : Check ( myName ( ) , tokenizer@var2339 , settings@var2340 , errorLogger@var2341 ) { }
57:
58:
59: void runChecks ( const Tokenizer * tokenizer@var2342 , const Settings * settings@var2343 , ErrorLogger * errorLogger@var2344 ) override {
60: CheckNullPointer checkNullPointer@var2345 (@expr1073746798 tokenizer@var2342 , settings@var2343 , errorLogger@var2344 ) ;
61: checkNullPointer@var2345 .@expr1073746799 nullPointer (@expr1073746800 ) ;
62: checkNullPointer@var2345 .@expr1073746801 arithmetic (@expr1073746802 ) ;
63: checkNullPointer@var2345 .@expr1073746803 nullConstantDereference (@expr1073746804 ) ;
64: }
65:
|
71:
72: static void parseFunctionCall ( const Token & tok@var2346 ,
73: std :: list < const Token * > & var@var2347 ,
74: const Library * library@var2348 ) ;
75:
|
84:
85: bool isPointerDeRef ( const Token * tok@var2349 , bool & unknown@var2350 ) const ;
86:
87: static bool isPointerDeRef ( const Token * tok@var2351 , bool & unknown@var2352 , const Settings * settings@var2353 ) ;
88:
89:
90: void nullPointer ( ) ;
91:
92:
93: void nullConstantDereference ( ) ;
94:
95: void nullPointerError ( const Token * tok@var2354 ) {
96: ValueFlow ::@expr1073746805 Value v@var2355 (@expr1073746806 0 ) ;
97: v@var2355 .@expr1073746807 setKnown (@expr1073746808 ) ;
98: nullPointerError (@expr1073746809 tok@var2354 , "" , &@expr1073746810 v@var2355 , false ) ;
99: }
100: void nullPointerError ( const Token * tok@var2356 , const std :: string & varname@var2357 , const ValueFlow :: Value * value@var2358 , bool inconclusive@var2359 ) ;
101:
102:
103: class MyFileInfo : public Check :: FileInfo {
104: public:
105:
106: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var2360 ;
107:
108:
109: std :: string toString ( ) const override ;
110: } ;
111:
112:
113: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2361 , const Settings * settings@var2362 ) const override ;
114:
115: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2363 ) const override ;
116:
117:
118: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2364 , const std :: list < Check :: FileInfo * > & fileInfo@var2365 , const Settings & settings@var2366 , ErrorLogger & errorLogger@var2367 ) override ;
119:
120: private:
121:
122: void getErrorMessages ( ErrorLogger * errorLogger@var2368 , const Settings * settings@var2369 ) const override {
123: CheckNullPointer c@var2370 (@expr1073746811 nullptr , settings@var2369 , errorLogger@var2368 ) ;
124: c@var2370 .@expr1073746812 nullPointerError (@expr1073746813 nullptr , "pointer" , nullptr , false ) ;
125: c@var2370 .@expr1073746814 pointerArithmeticError (@expr1073746815 nullptr , nullptr , false ) ;
126: c@var2370 .@expr1073746816 redundantConditionWarning (@expr1073746817 nullptr , nullptr , nullptr , false ) ;
127: }
128:
129:
130: static std :: string myName ( ) {
131: return "Null pointer" ;
132: }
133:
134:
135: std :: string classInfo ( ) const override {
136: return "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
137:
138: ;
139: }
140:
|
144:
145: void nullPointerByDeRefAndChec ( ) ;
146:
147:
148: void arithmetic ( ) ;
149: void pointerArithmeticError ( const Token * tok@var2371 , const ValueFlow :: Value * value@var2372 , bool inconclusive@var2373 ) ;
150: void redundantConditionWarning ( const Token * tok@var2374 , const ValueFlow :: Value * value@var2375 , const Token * condition@var2376 , bool inconclusive@var2377 ) ;
151: } ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2378 ) {
44: if (@expr1073746818 bit@var2378 >=@expr1073746819 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746820 (@expr1073746821 1LL <<@expr1073746822 (@expr1073746823 bit@var2378 -@expr1073746824 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var2379 ) {
50: if (@expr1073746825 bit@var2379 >=@expr1073746826 64 ) {
51: return (@expr5003 ~@expr1073746828 0ULL ) >>@expr1073746829 1 ; }
52: return (@expr5003 1LL <<@expr1073746831 (@expr5003 bit@var2379 -@expr1073746833 1 ) ) -@expr1073746834 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var2380 ) const {
59: return value@var2380 >=@expr1073746835 min_value (@expr1073746836 int_bit@var2390 ) &&@expr1073746837 value@var2380 <=@expr1073746838 max_value (@expr1073746839 int_bit@var2390 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var2381 ) const {
63: unsigned long long intMax@var2382 ; intMax@var2382 =@expr1073746840 max_value (@expr1073746841 int_bit@var2390 ) ;
64: return value@var2381 <=@expr1073746842 intMax@var2382 ;
65: }
66:
67: bool isLongValue ( long long value@var2383 ) const {
68: return value@var2383 >=@expr1073746843 min_value (@expr1073746844 long_bit@var2391 ) &&@expr1073746845 value@var2383 <=@expr1073746846 max_value (@expr1073746847 long_bit@var2391 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var2384 ) const {
72: unsigned long long longMax@var2385 ; longMax@var2385 =@expr1073746848 max_value (@expr1073746849 long_bit@var2391 ) ;
73: return value@var2384 <=@expr1073746850 longMax@var2385 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var2386 ) const {
77: unsigned long long longLongMax@var2387 ; longLongMax@var2387 =@expr1073746851 max_value (@expr1073746852 long_long_bit@var2392 ) ;
78: return value@var2386 <=@expr1073746853 longLongMax@var2387 ;
79: }
80:
81: int char_bit@var2388 ;
82: int short_bit@var2389 ;
83: int int_bit@var2390 ;
84: int long_bit@var2391 ;
85: int long_long_bit@var2392 ;
86:
87:
88: int sizeof_bool@var2393 ;
89: int sizeof_short@var2394 ;
90: int sizeof_int@var2395 ;
91: int sizeof_long@var2396 ;
92: int sizeof_long_long@var2397 ;
93: int sizeof_float@var2398 ;
94: int sizeof_double@var2399 ;
95: int sizeof_long_double@var2400 ;
96: int sizeof_wchar_t@var2401 ;
97: int sizeof_size_t@var2402 ;
98: int sizeof_pointer@var2403 ;
99:
100: char defaultSign@var2404 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var2405 ;
115:
116:
117: bool platform ( PlatformType type@var2406 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var2407 [ ] , const std :: string & filename@var2408 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var2409 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var2405 ==@expr1073746854 Win32A ||@expr1073746855
136: platformType@var2405 ==@expr1073746856 Win32W ||@expr1073746857
137: platformType@var2405 ==@expr1073746858 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746859 platformType@var2405 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var2410 ) {
145: switch (@expr1073746860 pt@var2410 ) {
146: case Unspecified :@expr5037 ;
147: return "Unspecified" ;
148: case Native :@expr5037 ;
149: return "Native" ;
150: case Win32A :@expr5037 ;
151: return "win32A" ;
152: case Win32W :@expr5037 ;
153: return "win32W" ;
154: case Win64 :@expr5037 ;
155: return "win64" ;
156: case Unix32 :@expr5037 ;
157: return "unix32" ;
158: case Unix64 :@expr5037 ;
159: return "unix64" ;
160: case PlatformFile :@expr5037 ;
161: return "platformFile" ;
162: default :@expr5037 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746870 char_bit@var2388 +@expr1073746871 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746872 char_bit@var2388 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746873 char_bit@var2388 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var2411 , const std :: string & rhs@var2412 ) const {
41: return caseInsensitiveStringCompare (@expr1073746874 lhs@var2411 , rhs@var2412 ) <@expr1073746875 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var2420 ( cppcheck :: Platform :: Unspecified ) , msc@var2421 ( false ) , useMfc@var2422 ( false ) { }
67: std :: string cfg@var2413 ;
68: std :: string filename@var2414 ;
69: std :: string defines@var2415 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var2415 +@expr1073746876 (@expr1073746877 msc@var2421 ?@expr1073746878 ";_MSC_VER=1900" :@expr1073746879 "" ) +@expr1073746880 (@expr1073746881 useMfc@var2422 ?@expr1073746882 ";__AFXWIN_H__=1" :@expr1073746883 "" ) ;
72: }
73: std :: set < std :: string > undefs@var2416 ;
74: std :: list < std :: string > includePaths@var2417 ;
75: std :: list < std :: string > systemIncludePaths@var2418 ;
76: std :: string standard@var2419 ;
77: cppcheck :: Platform :: PlatformType platformType@var2420 ;
78: bool msc@var2421 ;
79: bool useMfc@var2422 ;
80:
81: void parseCommand ( std :: string command@var2423 ) ;
82: void setDefines ( std :: string defs@var2424 ) ;
83: void setIncludePaths ( const std :: string & basepath@var2425 , const std :: list < std :: string > & in@var2426 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2427 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var2428 ;
86: Type projectType@var2429 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var2430 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous5 {
96: std :: string analyzeAllVsConfigs@var2431 ;
97: std :: vector < std :: string > pathNames@var2432 ;
98: std :: list < std :: string > libraries@var2433 ;
99: std :: list < std :: string > excludedPaths@var2434 ;
100: std :: list < std :: string > checkVsConfigs@var2435 ;
101: std :: string projectFile@var2436 ;
102: std :: string platform@var2437 ;
103: } ; struct Anonymous5 guiProject@var2438 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var2439 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var2440 ) ;
107:
108: Type import ( const std :: string & filename@var2441 , Settings * settings@var2442 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var2443 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var2444 , Settings * settings@var2445 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2446 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2447 , const std :: string & path@var2448 , const std :: vector < std :: string > & fileFilters@var2449 ) ;
115: bool importVcxproj ( const std :: string & filename@var2450 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2451 , const std :: string & additionalIncludeDirectories@var2452 , const std :: vector < std :: string > & fileFilters@var2453 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2454 ) ;
117:
118: static void printError ( const std :: string & message@var2455 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2456 ) ;
121:
122: std :: string mPath@var2457 ;
123: std :: set < std :: string > mAllVSConfigs@var2458 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2459 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2460 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2461 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2462 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2463 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2464 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2465 [ 7 ] = "parser" ;
135: const char BugHunting@var2466 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2467 [ 11 ] = "includedir" ;
137: const char DirElementName@var2468 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2469 [ 5 ] = "name" ;
139: const char DefinesElementName@var2470 [ 8 ] = "defines" ;
140: const char DefineName@var2471 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2472 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2473 [ 10 ] = "undefines" ;
143: const char UndefineName@var2474 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2475 [ 6 ] = "paths" ;
145: const char PathName@var2476 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2477 [ 5 ] = "name" ;
147: const char RootPathName@var2478 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2479 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2480 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2481 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2482 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2483 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2484 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2485 [ 5 ] = "name" ;
155: const char FunctionContracts@var2486 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2487 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2488 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2489 [ 8 ] = "library" ;
159: const char PlatformElementName@var2490 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2491 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2492 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2493 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2494 [ 7 ] = "addons" ;
164: const char ToolElementName@var2495 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2496 [ 6 ] = "tools" ;
166: const char TagsElementName@var2497 [ 5 ] = "tags" ;
167: const char TagElementName@var2498 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2499 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2500 [ 4 ] = "tag" ;
170: const char WarningElementName@var2501 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2502 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2503 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2504 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2505 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2506 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2507 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2508 [ 11 ] = "clang-tidy" ;
178: const char Name@var2509 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2510 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2511 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2512 , std :: clock_t clocks@var2513 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2514 ;
45: long mNumberOfResults@var2515 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2514 ( 0 )
49: , mNumberOfResults@var2515 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2516 =@expr1073746885 (@expr1073746886 double ) (@expr1073746887 (@expr1073746888 unsigned long ) mClocks@var2514 ) /@expr1073746889 (@expr1073746890 double ) CLOCKS_PER_SEC@expr1073746884 ;
53: return ret@var2516 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2517 ) const ;
62: void addResults ( const std :: string & str@var2518 , std :: clock_t clocks@var2519 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2520 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2521 , SHOWTIME_MODES showtimeMode@var2522 , TimerResultsIntf * timerResults@var2523 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2524 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2525 ;
79: TimerResultsIntf * mTimerResults@var2526 ;
80: std :: clock_t mStart@var2527 ;
81: const SHOWTIME_MODES mShowTimeMode@var2528 ;
82: bool mStopped@var2529 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2530 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2531 ;
103:
104:
105: std :: string addonPython@var2532 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2533 ;
109:
110:
111: std :: string buildDir@var2534 ;
112:
113:
114: bool checkAllConfigurations@var2535 ;
115:
116:
117: bool checkConfiguration@var2536 ;
118:
|
121:
122: bool checkHeaders@var2537 ;
123:
124:
125: bool checkLibrary@var2538 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2539 ;
129:
130:
131: bool checkUnusedTemplates@var2540 ;
132:
133:
134: bool clang@var2541 ;
135:
136:
137: std :: string clangExecutable@var2542 ;
138:
139:
140: bool clangTidy@var2543 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2544 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2545 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2546 ;
150:
151:
152: bool daca@var2547 ;
153:
154:
155: bool debugnormal@var2548 ;
156:
157:
158: bool debugSimplified@var2549 ;
159:
160:
161: bool debugtemplate@var2550 ;
162:
163:
164: bool debugwarnings@var2551 ;
165:
166:
167: bool dump@var2552 ;
168: std :: string dumpFile@var2553 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2554 ;
176:
177:
178: bool exceptionHandling@var2555 ;
179:
180:
181: std :: string exename@var2556 ;
182:
183:
184:
185: int exitCode@var2557 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2558 ;
189:
190:
191: bool force@var2559 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2560 ;
196:
197:
198: bool inlineSuppressions@var2561 ;
199:
200:
201:
202: unsigned int jobs@var2562 ;
203:
|
206:
207: bool jointSuppressionReport@var2563 ;
208:
209:
210: std :: list < std :: string > libraries@var2564 ;
211:
212:
213: Library library@var2565 ;
214:
215:
216:
217: int loadAverage@var2566 ;
218:
|
221:
222: int maxConfigs@var2567 ;
223:
224:
225: int maxCtuDepth@var2568 ;
226:
227:
228: int maxTemplateRecursion@var2569 ;
229:
230:
231: Suppressions nofail@var2570 ;
232:
233:
234: Suppressions nomsg@var2571 ;
235:
236:
237: std :: string outputFile@var2572 ;
238:
239:
240: std :: string plistOutput@var2573 ;
241:
242:
243: bool preprocessOnly@var2574 ;
244:
245: ImportProject project@var2575 ;
246:
247:
248: bool quiet@var2576 ;
249:
250:
251: bool relativePaths@var2577 ;
252:
253:
254: bool reportProgress@var2578 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2579 ( "simple" )
261: , id@var2581 ( "rule" )
262: , severity@var2583 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2579 ;
266: std :: string pattern@var2580 ;
267: std :: string id@var2581 ;
268: std :: string summary@var2582 ;
269: Severity :: SeverityType severity@var2583 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2584 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2590 ( false ) , externalFunctions@var2591 ( false ) , internalFunctions@var2592 ( false ) , externalVariables@var2593 ( false ) { }
281:
282: static const char XmlRootName@var2585 [ ] ;
283: static const char XmlClasses@var2586 [ ] ;
284: static const char XmlExternalFunctions@var2587 [ ] ;
285: static const char XmlInternalFunctions@var2588 [ ] ;
286: static const char XmlExternalVariables@var2589 [ ] ;
287:
288: void clear ( ) {
289: classes@var2590 =@expr1073746891 externalFunctions@var2591 =@expr1073746892 internalFunctions@var2592 =@expr1073746893 externalVariables@var2593 =@expr1073746894 false ;
290: }
291:
|
297:
298: bool classes@var2590 ;
299:
|
304:
305: bool externalFunctions@var2591 ;
306:
|
310:
311: bool internalFunctions@var2592 ;
312:
|
316:
317: bool externalVariables@var2593 ;
318: } ;
319:
320: SafeChecks safeChecks@var2594 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2595 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2596 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2597 ;
325:
326:
327: SHOWTIME_MODES showtime@var2598 ;
328:
329:
330: Standards standards@var2599 ;
331:
332:
333:
334: std :: string templateFormat@var2600 ;
335:
336:
337:
338: std :: string templateLocation@var2601 ;
339:
340:
341: std :: string userDefines@var2602 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2603 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2604 ;
348:
349:
350: bool verbose@var2605 ;
351:
352:
353: bool xml@var2606 ;
354:
355:
356: int xml_version@var2607 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2608 ) const {
363: for (@expr1073746895 const std ::@expr1073746896 string &@expr1073746897 configExcludePath@var2609 :@expr1073746898 configExcludePaths@var2544 ) {
364: if (@expr1073746899 file@var2608 .@expr1073746900 length (@expr1073746901 ) >=@expr1073746902 configExcludePath@var2609 .@expr5079 length (@expr5080 ) &&@expr1073746905 file@var2608 .@expr1073746906 compare (@expr1073746907 0 , configExcludePath@var2609 .@expr5079 length (@expr5080 ) , configExcludePath@var2609 ) ==@expr1073746910 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2610 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2611 , bool inconclusiveCheck@var2612 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746911 find (@expr1073746912 libraries@var2564 .@expr1073746913 begin (@expr1073746914 ) , libraries@var2564 .@expr5091 end (@expr5092 ) , "posix" ) !=@expr1073746917 libraries@var2564 .@expr5091 end (@expr5092 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2613 = true ) {
392: Settings ::@expr1073746920 mTerminated@var2530 =@expr1073746921 t@var2613 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746922 mTerminated@var2530 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2614 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/checkleakautovar.cpp

1:
|
43:
44: namespace {
45: CheckLeakAutoVar instance@var2615 ;
46: }
47:
48: static const CWE CWE672@var2616 ( 672U ) ;
49: static const CWE CWE415@var2617 ( 415U ) ;
50:
51:
52: static const int NEW_ARRAY@var2618 = -2 ;
53: static const int NEW@var2619 = -1 ;
54:
55: static const std :: vector < std :: pair < std :: string , std :: string > > alloc_failed_conds@var2620 { { "==" , "0" } , { "<" , "0" } , { "==" , "-1" } , { "<=" , "-1" } } ;
56: static const std :: vector < std :: pair < std :: string , std :: string > > alloc_success_conds@var2621 { { "!=" , "0" } , { ">" , "0" } , { "!=" , "-1" } , { ">=" , "0" } } ;
57:
|
62:
63: static bool isAutoDealloc ( const Variable * var@var2622 )
64: {
65: if (@expr1073746923 var@var2622 .@expr5100 valueType (@expr5101 ) &&@expr1073746926 var@var2622 .@expr5100 valueType (@expr5101 ) .@expr5105 type@var2937 !=@expr1073746930 ValueType ::@expr5107 Type ::@expr1073746932 RECORD &&@expr1073746933 var@var2622 .@expr5100 valueType (@expr5101 ) .@expr5105 type@var2937 !=@expr1073746937 ValueType ::@expr5107 Type ::@expr1073746939 UNKNOWN_TYPE ) {
66: return false ; }
67:
|
71:
72: if (@expr1073746940 var@var2622 .@expr5117 typeScope (@expr5118 ) &&@expr1073746943 var@var2622 .@expr5117 typeScope (@expr5118 ) .@expr1073746946 numConstructors@var2938 ==@expr1073746947 0 &&@expr1073746948
73: (@expr1073746949 var@var2622 .@expr5117 typeScope (@expr5118 ) .@expr1073746952 varlist@var2939 .@expr1073746953 empty (@expr1073746954 ) ||@expr1073746955 var@var2622 .@expr5132 type (@expr5133 ) .@expr1073746958 needInitialization@var2940 ==@expr1073746959 Type ::@expr1073746960 NeedInitialization ::@expr1073746961 True ) &&@expr1073746962
74: var@var2622 .@expr5132 type (@expr5133 ) .@expr1073746965 derivedFrom@var2941 .@expr1073746966 empty (@expr1073746967 ) ) {
75: return false ; }
76:
77: return true ;
78: }
79:
80: static bool isVarTokComparison ( const Token * tok@var2623 , const Token * * vartok@var2624 ,
81: const std :: vector < std :: pair < std :: string , std :: string > > & ops@var2625 )
82: {
83: for (@expr1073746968 const auto &@expr1073746969 op@var2626 :@expr1073746970 ops@var2625 ) {
84: if (@expr1073746971 astIsVariableComparison (@expr1073746972 tok@var2623 , op@var2626 .@expr1073746973 first@var2627 , op@var2626 .@expr1073746974 second@var2628 , vartok@var2624 ) ) {
85: return true ; }
86: }
87: return false ;
88: }
89:
90:
91:
92: void VarInfo :: print ( )
93: {
94: std ::@expr5153 cout@expr5151 <<@expr1073746978 "size=" <<@expr1073746979 alloctype@var534 .@expr1073746980 size (@expr1073746981 ) <<@expr1073746982 std ::@expr5159 endl@expr5152 ;
95: for (@expr1073746984 std ::@expr5161 map < int , AllocInfo > ::@expr5161 const_iterator it@var2629 =@expr1073746987 alloctype@var534 .@expr1073746988 begin (@expr1073746989 ) ; it@var2629 !=@expr1073746990 alloctype@var534 .@expr1073746991 end (@expr1073746992 ) ; ++@expr1073746993 it@var2629 ) {
96: std ::@expr1073746994 string strusage@var2630 ;
97: const std ::@expr1073746995 map < int , std ::@expr5161 string > ::@expr1073746997 const_iterator use@var2631 =@expr1073746998
98: possibleUsage@var535 .@expr1073746999 find (@expr1073747000 it@var2629 .@expr5177 first@var2632 ) ;
99: if (@expr1073747002 use@var2631 !=@expr1073747003 possibleUsage@var535 .@expr1073747004 end (@expr1073747005 ) ) {
100: strusage@var2630 =@expr1073747006 use@var2631 .@expr1073747007 second@var2633 ; }
101:
102: std ::@expr1073747008 string status@var2634 ;
103: switch (@expr1073747009 it@var2629 .@expr5186 second@var2635 .@expr1073747011 status@var2636 ) {
104: case OWNED :@expr5188 ;
105: status@var2634 =@expr1073747013 "owned" ;
106: break ;
107: case DEALLOC :@expr5188 ;
108: status@var2634 =@expr1073747015 "dealloc" ;
109: break ;
110: case ALLOC :@expr5188 ;
111: status@var2634 =@expr1073747017 "alloc" ;
112: break ;
113: case NOALLOC :@expr5188 ;
114: status@var2634 =@expr1073747019 "noalloc" ;
115: break ;
116: case REALLOC :@expr5188 ;
117: status@var2634 =@expr1073747021 "realloc" ;
118: break ;
119: default :@expr5188 ;
120: status@var2634 =@expr1073747023 "?" ;
121: break ;
122: }
123:
124: std ::@expr5153 cout@expr5151 <<@expr1073747025 "status=" <<@expr1073747026 status@var2634 <<@expr1073747027 " "
125: <<@expr1073747028 "alloctype='" <<@expr1073747029 it@var2629 .@expr5186 second@var2635 .@expr1073747031 type@var2637 <<@expr1073747032 "' "
126: <<@expr1073747033 "possibleUsage='" <<@expr1073747034 strusage@var2630 <<@expr1073747035 "' "
127: <<@expr1073747036 "conditionalAlloc=" <<@expr1073747037 (@expr1073747038 conditionalAlloc@var536 .@expr1073747039 find (@expr1073747040 it@var2629 .@expr5177 first@var2632 ) !=@expr1073747042 conditionalAlloc@var536 .@expr1073747043 end (@expr1073747044 ) ?@expr1073747045 "yes" :@expr5222 "no" ) <<@expr1073747047 " "
128: <<@expr1073747048 "referenced=" <<@expr1073747049 (@expr1073747050 referenced@var537 .@expr1073747051 find (@expr1073747052 it@var2629 .@expr5177 first@var2632 ) !=@expr1073747054 referenced@var537 .@expr1073747055 end (@expr1073747056 ) ?@expr1073747057 "yes" :@expr5222 "no" ) <<@expr1073747059 " "
129: <<@expr1073747060 "reallocedFrom=" <<@expr1073747061 it@var2629 .@expr5186 second@var2635 .@expr1073747063 reallocedFromType@var2638
130: <<@expr1073747064 std ::@expr5159 endl@expr5152 ;
131: }
132: }
133:
134: void VarInfo :: possibleUsageAll ( const std :: string & functionName@var2639 )
135: {
136: possibleUsage@var535 .@expr1073747066 clear (@expr1073747067 ) ;
137: for (@expr1073747068 std ::@expr5245 map < int , AllocInfo > ::@expr5245 const_iterator it@var2640 =@expr1073747071 alloctype@var534 .@expr1073747072 begin (@expr1073747073 ) ; it@var2640 !=@expr1073747074 alloctype@var534 .@expr1073747075 end (@expr1073747076 ) ; ++@expr1073747077 it@var2640 ) {
138: possibleUsage@var535 [@expr1073747078 it@var2640 .@expr1073747079 first@var2641 ] =@expr1073747080 functionName@var2639 ; }
139: }
140:
141:
142: void CheckLeakAutoVar :: leakError ( const Token * tok@var2642 , const std :: string & varname@var2643 , int type@var2644 )
143: {
144: const CheckMemoryLeak checkmemleak@var2645 (@expr1073747081 mTokenizer@var28 , mErrorLogger@var30 , mSettings@var29 ) ;
145: if (@expr1073747082 Library ::@expr1073747083 isresource (@expr1073747084 type@var2644 ) ) {
146: checkmemleak@var2645 .@expr1073747085 resourceLeakError (@expr1073747086 tok@var2642 , varname@var2643 ) ; }
147: else {
148: checkmemleak@var2645 .@expr1073747087 memleakError (@expr1073747088 tok@var2642 , varname@var2643 ) ; }
149: }
150:
151: void CheckLeakAutoVar :: mismatchError ( const Token * deallocTok@var2646 , const Token * allocTok@var2647 , const std :: string & varname@var2648 )
152: {
153: const CheckMemoryLeak c@var2649 (@expr1073747089 mTokenizer@var28 , mErrorLogger@var30 , mSettings@var29 ) ;
154: const std ::@expr1073747090 list < const Token *@expr1073747091 > callstack@var2650 =@expr1073747092 {@expr1073747093 allocTok@var2647 , deallocTok@var2646 } ;
155: c@var2649 .@expr1073747094 mismatchAllocDealloc (@expr1073747095 callstack@var2650 , varname@var2648 ) ;
156: }
157:
158: void CheckLeakAutoVar :: deallocUseError ( const Token * tok@var2651 , const std :: string & varname@var2652 )
159: {
160: const CheckMemoryLeak c@var2653 (@expr1073747096 mTokenizer@var28 , mErrorLogger@var30 , mSettings@var29 ) ;
161: c@var2653 .@expr1073747097 deallocuseError (@expr1073747098 tok@var2651 , varname@var2652 ) ;
162: }
163:
164: void CheckLeakAutoVar :: deallocReturnError ( const Token * tok@var2654 , const Token * deallocTok@var2655 , const std :: string & varname@var2656 )
165: {
166: const std ::@expr1073747099 list < const Token *@expr1073747100 > locations@var2657 =@expr1073747101 {@expr1073747102 deallocTok@var2655 , tok@var2654 } ;
167: reportError (@expr1073747103 locations@var2657 , Severity ::@expr1073747104 error , "deallocret" , "$symbol:" +@expr1073747105 varname@var2656 +@expr1073747106 "\nReturning/dereferencing '$symbol' after it is deallocated / released" , CWE672@var2616 , Certainty ::@expr1073747107 normal ) ;
168: }
169:
170: void CheckLeakAutoVar :: configurationInfo ( const Token * tok@var2658 , const std :: string & functionName@var2659 )
171: {
172: if (@expr1073747108 mSettings@var29 .@expr1073747109 checkLibrary@var2923 &&@expr1073747110 mSettings@var29 .@expr1073747111 severity@var2924 .@expr1073747112 isEnabled (@expr1073747113 Severity ::@expr5290 information ) ) {
173: reportError (@expr1073747115 tok@var2658 ,
174: Severity ::@expr5290 information ,
175: "checkLibraryUseIgnore" ,
176: "--check-library: Function " +@expr1073747117 functionName@var2659 +@expr1073747118 "() should have <use>/<leak-ignore> configuration" ) ;
177: }
178: }
179:
180: void CheckLeakAutoVar :: doubleFreeError ( const Token * tok@var2660 , const Token * prevFreeTok@var2661 , const std :: string & varname@var2662 , int type@var2663 )
181: {
182: const std ::@expr1073747119 list < const Token *@expr1073747120 > locations@var2664 =@expr1073747121 {@expr1073747122 prevFreeTok@var2661 , tok@var2660 } ;
183:
184: if (@expr1073747123 Library ::@expr1073747124 isresource (@expr1073747125 type@var2663 ) ) {
185: reportError (@expr1073747126 locations@var2664 , Severity ::@expr5303 error , "doubleFree" , "$symbol:" +@expr5304 varname@var2662 +@expr1073747129 "\nResource handle '$symbol' freed twice." , CWE415@var2617 , Certainty ::@expr5306 normal ) ; }
186: else {
187: reportError (@expr1073747131 locations@var2664 , Severity ::@expr5303 error , "doubleFree" , "$symbol:" +@expr5304 varname@var2662 +@expr1073747134 "\nMemory pointed to by '$symbol' is freed twice." , CWE415@var2617 , Certainty ::@expr5306 normal ) ; }
188: }
189:
190:
191: void CheckLeakAutoVar :: check ( )
192: {
193: if (@expr1073747136 mSettings@var29 .@expr1073747137 clang@var2925 ) {
194: return ; }
195:
196: const SymbolDatabase * symbolDatabase@var2665 ; symbolDatabase@var2665 =@expr1073747138 mTokenizer@var28 .@expr1073747139 getSymbolDatabase (@expr1073747140 ) ;
197:
198:
199: const std ::@expr1073747141 set < int > notzero@var2666 ;
200:
201:
202: for (@expr1073747142 const Scope *@expr1073747143 scope@var2667 :@expr1073747144 symbolDatabase@var2665 .@expr1073747145 functionScopes@var2668 ) {
203: if (@expr1073747146 scope@var2667 .@expr1073747147 hasInlineOrLambdaFunction (@expr1073747148 ) ) {
204: continue ; }
205:
206:
207: VarInfo varInfo@var2669 ;
208:
209: checkScope (@expr1073747149 scope@var2667 .@expr1073747150 bodyStart@var2670 , &@expr1073747151 varInfo@var2669 , notzero@var2666 , 0 ) ;
210: }
211: }
212:
213: static bool isVarUsedInTree ( const Token * tok@var2671 , int varid@var2672 )
214: {
215: if (@expr1073747152 !@expr1073747153 tok@var2671 ) {
216: return false ; }
217: if (@expr1073747154 tok@var2671 .@expr1073747155 varId (@expr1073747156 ) ==@expr1073747157 varid@var2672 ) {
218: return true ; }
219: if (@expr1073747158 tok@var2671 .@expr1073747159 str (@expr1073747160 ) ==@expr1073747161 "(" &&@expr1073747162 Token ::@expr1073747163 simpleMatch (@expr1073747164 tok@var2671 .@expr5341 astOperand1 (@expr5342 ) , "sizeof" ) ) {
220: return false ; }
221: return isVarUsedInTree (@expr1073747167 tok@var2671 .@expr5341 astOperand1 (@expr5342 ) , varid@var2672 ) ||@expr1073747170 isVarUsedInTree (@expr1073747171 tok@var2671 .@expr1073747172 astOperand2 (@expr1073747173 ) , varid@var2672 ) ;
222: }
223:
224: static bool isPointerReleased ( const Token * startToken@var2673 , const Token * endToken@var2674 , int varid@var2675 )
225: {
226: for (@expr1073747174 const Token *@expr1073747175 tok@var2676 =@expr1073747176 startToken@var2673 ; tok@var2676 &&@expr1073747177 tok@var2676 !=@expr1073747178 endToken@var2674 ; tok@var2676 =@expr1073747179 tok@var2676 .@expr1073747180 next (@expr1073747181 ) ) {
227: if (@expr1073747182 tok@var2676 .@expr1073747183 varId (@expr1073747184 ) !=@expr1073747185 varid@var2675 ) {
228: continue ; }
229: if (@expr1073747186 Token ::@expr5363 Match (@expr1073747188 tok@var2676 , "%var% . release ( )" ) ) {
230: return true ; }
231: if (@expr1073747189 Token ::@expr5363 Match (@expr1073747191 tok@var2676 , "%var% =" ) ) {
232: return false ; }
233: }
234: return false ;
235: }
236:
237: static bool isLocalVarNoAutoDealloc ( const Token * varTok@var2677 , const bool isCpp@var2678 )
238: {
239:
240: const Variable * var@var2679 ; var@var2679 =@expr1073747192 varTok@var2677 .@expr1073747193 variable (@expr1073747194 ) ;
241: if (@expr1073747195 !@expr1073747196 var@var2679 ) {
242: return true ; }
243: if (@expr1073747197 !@expr1073747198 var@var2679 .@expr1073747199 isArgument (@expr1073747200 ) &&@expr1073747201 (@expr1073747202 !@expr1073747203 var@var2679 .@expr1073747204 isLocal (@expr1073747205 ) ||@expr1073747206 var@var2679 .@expr1073747207 isStatic (@expr1073747208 ) ) ) {
244: return false ; }
245:
246:
247: if (@expr1073747209 var@var2679 .@expr1073747210 isReference (@expr1073747211 ) ) {
248: return false ; }
249:
250:
251: if (@expr1073747212 isCpp@var2678 ) {
252:
253: if (@expr1073747213 isAutoDealloc (@expr1073747214 var@var2679 ) &&@expr1073747215 Token ::@expr1073747216 Match (@expr1073747217 varTok@var2677 , "%var% = new" ) ) {
254: return false ; }
255: if (@expr1073747218 !@expr1073747219 var@var2679 .@expr1073747220 isPointer (@expr1073747221 ) &&@expr1073747222 !@expr1073747223 var@var2679 .@expr1073747224 typeStartToken (@expr1073747225 ) .@expr1073747226 isStandardType (@expr1073747227 ) ) {
256: return false ; }
257: }
258: return true ;
259: }
260:
|
268:
269: static const Token * isFunctionCall ( const Token * nameToken@var2680 )
270: {
271: if (@expr1073747228 nameToken@var2680 .@expr1073747229 isName (@expr1073747230 ) ) {
272: nameToken@var2680 =@expr1073747231 nameToken@var2680 .@expr1073747232 next (@expr1073747233 ) ;
273:
274: if (@expr1073747234 nameToken@var2680 &&@expr5411 nameToken@var2680 .@expr5412 link (@expr5413 ) &&@expr1073747238 nameToken@var2680 .@expr5415 str (@expr5416 ) ==@expr1073747241 "<" ) {
275:
276: nameToken@var2680 =@expr1073747242 nameToken@var2680 .@expr5412 link (@expr5413 ) .@expr1073747245 next (@expr1073747246 ) ;
277: }
278:
279: if (@expr1073747247 nameToken@var2680 &&@expr5411 nameToken@var2680 .@expr5412 link (@expr5413 ) &&@expr1073747251 nameToken@var2680 .@expr5415 str (@expr5416 ) ==@expr1073747254 "(" ) {
280:
281: return nameToken@var2680 ;
282: }
283: }
284: return nullptr ;
285: }
286:
287: void CheckLeakAutoVar :: checkScope ( const Token * const startToken@var2681 ,
288: VarInfo * varInfo@var2682 ,
289: std :: set < int > notzero@var2683 ,
290: int recursiveCount@var2684 )
291: {
292:
293:
294:
295: static const int recursiveLimit@var2685 =@expr1073747256 1000 ;
296:
297: if (@expr1073747257 ++@expr1073747258 recursiveCount@var2684 >@expr1073747259 recursiveLimit@var2685 ) {
298: throw InternalError (@expr1073747260 startToken@var2681 , "Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached." , InternalError ::@expr1073747261 LIMIT ) ; }
299:
300: std ::@expr5438 map < int , VarInfo ::@expr5439 AllocInfo > & alloctype@var2686 =@expr1073747264 varInfo@var2682 .@expr1073747265 alloctype@var2687 ;
301: std ::@expr1073747266 map < int , std ::@expr5439 string > & possibleUsage@var2688 =@expr1073747268 varInfo@var2682 .@expr1073747269 possibleUsage@var2689 ;
302: const std ::@expr1073747270 set < int > conditionalAlloc@var2690 (@expr1073747271 varInfo@var2682 .@expr5448 conditionalAlloc@var2691 ) ;
303:
304:
305: const Token * const endToken@var2692 ; endToken@var2692 =@expr1073747273 startToken@var2681 .@expr1073747274 link (@expr1073747275 ) ;
306: for (@expr1073747276 const Token *@expr5453 tok@var2693 =@expr1073747278 startToken@var2681 ; tok@var2693 &&@expr1073747279 tok@var2693 !=@expr1073747280 endToken@var2692 ; tok@var2693 =@expr1073747281 tok@var2693 .@expr5458 next (@expr5459 ) ) {
307: if (@expr1073747284 !@expr1073747285 tok@var2693 .@expr5462 scope (@expr5463 ) .@expr1073747288 isExecutable (@expr1073747289 ) ) {
308: tok@var2693 =@expr1073747290 tok@var2693 .@expr5462 scope (@expr5463 ) .@expr1073747293 bodyEnd@var2942 ;
309: if (@expr1073747294 !@expr5471 tok@var2693 ) {
310: break ; }
311: }
312:
313:
314: {
315: const Token * nextTok@var2694 ; nextTok@var2694 =@expr1073747296 checkTokenInsideExpression (@expr1073747297 tok@var2693 , varInfo@var2682 ) ;
316: if (@expr1073747298 nextTok@var2694 ) {
317: tok@var2693 =@expr1073747299 nextTok@var2694 ;
318: continue ;
319: }
320: }
321:
322:
323:
324: if (@expr1073747300 !@expr1073747301 Token ::@expr5478 Match (@expr1073747303 tok@var2693 , "[;{},]" ) ||@expr1073747304 Token ::@expr5478 Match (@expr1073747306 tok@var2693 .@expr5458 next (@expr5459 ) , "[;{},]" ) ) {
325: continue ; }
326:
327: tok@var2693 =@expr1073747309 tok@var2693 .@expr5458 next (@expr5459 ) ;
328: if (@expr1073747312 !@expr5471 tok@var2693 ||@expr1073747314 tok@var2693 ==@expr1073747315 endToken@var2692 ) {
329: break ; }
330:
331: if (@expr1073747316 Token ::@expr5478 Match (@expr1073747318 tok@var2693 , "const %type%" ) ) {
332: tok@var2693 =@expr1073747319 tok@var2693 .@expr5496 tokAt (@expr5497 2 ) ; }
333:
334: while (@expr1073747322 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr5501 "(" ) {
335: tok@var2693 =@expr1073747326 tok@var2693 .@expr5458 next (@expr5459 ) ; }
336: while (@expr1073747329 tok@var2693 .@expr1073747330 isUnaryOp (@expr1073747331 "*" ) &&@expr1073747332 tok@var2693 .@expr5509 astOperand1 (@expr5510 ) .@expr1073747335 isUnaryOp (@expr1073747336 "&" ) ) {
337: tok@var2693 =@expr1073747337 tok@var2693 .@expr5509 astOperand1 (@expr5510 ) .@expr1073747340 astOperand1 (@expr1073747341 ) ; }
338:
339:
340: const Token * varTok@var2695 ; varTok@var2695 =@expr1073747342 tok@var2693 ;
341: while (@expr1073747343 Token ::@expr5478 Match (@expr1073747345 varTok@var2695 , "%name% ::|. %name% !!(" ) ) {
342: varTok@var2695 =@expr1073747346 varTok@var2695 .@expr1073747347 tokAt (@expr1073747348 2 ) ; }
343:
344: const Token * ftok@var2696 ; ftok@var2696 =@expr1073747349 tok@var2693 ;
345: if (@expr1073747350 ftok@var2696 .@expr1073747351 str (@expr1073747352 ) ==@expr1073747353 "::" ) {
346: ftok@var2696 =@expr1073747354 ftok@var2696 .@expr5531 next (@expr5532 ) ; }
347: while (@expr1073747357 Token ::@expr5478 Match (@expr1073747359 ftok@var2696 , "%name% :: %name%" ) ) {
348: ftok@var2696 =@expr1073747360 ftok@var2696 .@expr5537 tokAt (@expr1073747362 2 ) ; }
349:
350: auto isAssignment@var2697 ; isAssignment@var2697 =@expr1073747363 [@expr1073747364 ] (@expr1073747365 const Token *@expr5453 varTok@var2698 ) .@expr1073747367 const Token *@expr5453 {
351: if (@expr1073747369 varTok@var2698 .@expr5546 varId (@expr5547 ) ) {
352: const Token * top@var2699 ; top@var2699 =@expr1073747372 varTok@var2698 ;
353: while (@expr1073747373 top@var2699 .@expr5550 astParent (@expr5551 ) ) {
354: top@var2699 =@expr1073747376 top@var2699 .@expr5550 astParent (@expr5551 ) ;
355: if (@expr1073747379 !@expr1073747380 Token ::@expr5478 Match (@expr1073747382 top@var2699 , "(|*|&|." ) ) {
356: break ; }
357: }
358: if (@expr1073747383 top@var2699 .@expr1073747384 str (@expr1073747385 ) ==@expr1073747386 "=" &&@expr1073747387 succeeds (@expr1073747388 top@var2699 , varTok@var2698 ) ) {
359: return top@var2699 ; }
360: }
361: return nullptr ;
362: } ;
363:
364:
365: if (@expr1073747389 const Token *@expr5453 const tokAssignOp@var2700 =@expr1073747391 isAssignment@var2697 (@expr1073747392 varTok@var2698 ) ) {
366:
367:
368: if (@expr1073747393 Token ::@expr5478 Match (@expr1073747395 tokAssignOp@var2700 , "= %var% [+;]" ) ) {
369: if (@expr1073747396 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) .@expr1073747399 varId (@expr1073747400 ) !=@expr1073747401 varTok@var2698 .@expr5546 varId (@expr5547 ) ) {
370:
371: leakIfAllocated (@expr5580 varTok@var2698 , *@expr5581 varInfo@var2682 ) ;
372:
373:
374: for (@expr1073747406 const Token *@expr5453 tok2@var2701 =@expr1073747408 varTok@var2698 ; tok2@var2701 ; tok2@var2701 =@expr1073747409 tok2@var2701 .@expr1073747410 next (@expr1073747411 ) ) {
375: if (@expr1073747412 tok2@var2701 .@expr1073747413 str (@expr1073747414 ) ==@expr1073747415 ";" ) {
376: break ;
377: }
378: if (@expr1073747416 tok2@var2701 .@expr5593 varId (@expr5594 ) ) {
379: varInfo@var2682 .@expr5595 erase (@expr1073747420 tok2@var2701 .@expr5593 varId (@expr5594 ) ) ;
380: }
381: }
382: }
383: }
384:
385:
386: const Token * tokRightAstOperand@var2702 ; tokRightAstOperand@var2702 =@expr1073747423 tokAssignOp@var2700 .@expr1073747424 astOperand2 (@expr1073747425 ) ;
387: while (@expr1073747426 tokRightAstOperand@var2702 &&@expr1073747427 tokRightAstOperand@var2702 .@expr1073747428 isCast (@expr1073747429 ) ) {
388: tokRightAstOperand@var2702 =@expr1073747430 tokRightAstOperand@var2702 .@expr5607 astOperand2 (@expr5608 ) ?@expr1073747433 tokRightAstOperand@var2702 .@expr5607 astOperand2 (@expr5608 ) :@expr1073747436 tokRightAstOperand@var2702 .@expr1073747437 astOperand1 (@expr1073747438 ) ; }
389:
390:
391: if (@expr1073747439 isVarUsedInTree (@expr1073747440 tokRightAstOperand@var2702 , varTok@var2698 .@expr5546 varId (@expr5547 ) ) ) {
392: continue ; }
393:
394:
395: if (@expr1073747443 conditionalAlloc@var2690 .@expr5620 find (@expr1073747445 varTok@var2698 .@expr5546 varId (@expr5547 ) ) ==@expr1073747448 conditionalAlloc@var2690 .@expr5625 end (@expr5626 ) ) {
396: leakIfAllocated (@expr5580 varTok@var2698 , *@expr5581 varInfo@var2682 ) ; }
397: varInfo@var2682 .@expr5595 erase (@expr1073747454 varTok@var2698 .@expr5546 varId (@expr5547 ) ) ;
398:
399: if (@expr1073747457 !@expr1073747458 isLocalVarNoAutoDealloc (@expr1073747459 varTok@var2698 , mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) ) ) {
400: continue ; }
401:
402:
403: const Token * const fTok@var2703 ; fTok@var2703 =@expr1073747462 tokRightAstOperand@var2702 ?@expr1073747463 tokRightAstOperand@var2702 .@expr1073747464 previous (@expr1073747465 ) :@expr1073747466 nullptr ;
404: if (@expr1073747467 Token ::@expr5478 Match (@expr1073747469 fTok@var2703 , "%type% (" ) ) {
405: const Library ::@expr5646 AllocFunc * f@var2704 ; f@var2704 =@expr1073747471 mSettings@var29 .@expr5648 library@var2926 .@expr5649 getAllocFuncInfo (@expr1073747474 fTok@var2703 ) ;
406: if (@expr1073747475 f@var2704 &&@expr1073747476 f@var2704 .@expr1073747477 arg@var2705 ==@expr1073747478 -1 ) {
407: VarInfo ::@expr5439 AllocInfo &@expr5656 varAlloc@var2706 =@expr1073747481 alloctype@var2686 [@expr5658 varTok@var2698 .@expr5546 varId (@expr5547 ) ] ;
408: varAlloc@var2706 .@expr1073747485 type@var2707 =@expr1073747486 f@var2704 .@expr1073747487 groupId@var2708 ;
409: varAlloc@var2706 .@expr1073747488 status@var2709 =@expr1073747489 VarInfo ::@expr5666 ALLOC ;
410: varAlloc@var2706 .@expr1073747491 allocTok@var2710 =@expr1073747492 fTok@var2703 ;
411: }
412:
413: changeAllocStatusIfRealloc (@expr1073747493 alloctype@var2686 , fTok@var2703 , varTok@var2698 ) ;
414: } else { if (@expr1073747494 mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) &&@expr1073747497 Token ::@expr5478 Match (@expr1073747499 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) , "new !!(" ) ) {
415: const Token * tok2@var2711 ; tok2@var2711 =@expr1073747502 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) .@expr1073747505 astOperand1 (@expr1073747506 ) ;
416: const bool arrayNew@var2712 =@expr1073747507 tok2@var2711 &&@expr1073747508 (@expr1073747509 tok2@var2711 .@expr5686 str (@expr5687 ) ==@expr1073747512 "[" ||@expr1073747513 (@expr1073747514 tok2@var2711 .@expr5686 str (@expr5687 ) ==@expr1073747517 "(" &&@expr1073747518 tok2@var2711 .@expr5695 astOperand1 (@expr5696 ) &&@expr1073747521 tok2@var2711 .@expr5695 astOperand1 (@expr5696 ) .@expr1073747524 str (@expr1073747525 ) ==@expr1073747526 "[" ) ) ;
417: VarInfo ::@expr5439 AllocInfo &@expr5656 varAlloc@var2713 =@expr1073747529 alloctype@var2686 [@expr5658 varTok@var2698 .@expr5546 varId (@expr5547 ) ] ;
418: varAlloc@var2713 .@expr1073747533 type@var2714 =@expr1073747534 arrayNew@var2712 ?@expr1073747535 NEW_ARRAY@var2618 :@expr5712 NEW@var2619 ;
419: varAlloc@var2713 .@expr1073747537 status@var2715 =@expr1073747538 VarInfo ::@expr5666 ALLOC ;
420: varAlloc@var2713 .@expr1073747540 allocTok@var2716 =@expr1073747541 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) ;
421: } }
422:
423:
424:
425: if (@expr1073747544 Token ::@expr5478 Match (@expr1073747546 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) , "%num% ;" ) &&@expr1073747549 MathLib ::@expr1073747550 toLongNumber (@expr1073747551 varTok@var2698 .@expr1073747552 strAt (@expr1073747553 2 ) ) !=@expr1073747554 0 ) {
426: notzero@var2683 .@expr5731 insert (@expr5732 varTok@var2698 .@expr5546 varId (@expr5547 ) ) ; }
427: else { if (@expr1073747559 Token ::@expr5478 Match (@expr1073747561 varTok@var2698 .@expr5573 tokAt (@expr5574 2 ) , "- %type% ;" ) &&@expr1073747564 varTok@var2698 .@expr5573 tokAt (@expr1073747566 3 ) .@expr1073747567 isUpperCaseName (@expr1073747568 ) ) {
428: notzero@var2683 .@expr5731 insert (@expr5732 varTok@var2698 .@expr5546 varId (@expr5547 ) ) ; }
429: else {
430: notzero@var2683 .@expr1073747573 erase (@expr1073747574 varTok@var2698 .@expr5546 varId (@expr5547 ) ) ; } }
431: }
432:
433:
434: else { if (@expr1073747577 Token ::@expr5754 simpleMatch (@expr1073747579 tok@var2693 , "if (" ) ) {
435:
436:
437: const Token * closingParenthesis@var2717 ; closingParenthesis@var2717 =@expr1073747580 tok@var2693 .@expr5757 linkAt (@expr5758 1 ) ;
438: for (@expr1073747583 const Token *@expr5453 innerTok@var2718 =@expr1073747585 tok@var2693 .@expr5496 tokAt (@expr5497 2 ) ; innerTok@var2718 &&@expr1073747588 innerTok@var2718 !=@expr1073747589 closingParenthesis@var2717 ; innerTok@var2718 =@expr1073747590 innerTok@var2718 .@expr5767 next (@expr5768 ) ) {
439:
440:
441: if (@expr1073747593 !@expr1073747594 isLocalVarNoAutoDealloc (@expr1073747595 innerTok@var2718 , mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) ) ) {
442: continue ; }
443:
444: if (@expr1073747598 Token ::@expr5478 Match (@expr1073747600 innerTok@var2718 , "%var% =" ) &&@expr1073747601 innerTok@var2718 .@expr1073747602 astParent (@expr1073747603 ) ==@expr1073747604 innerTok@var2718 .@expr5767 next (@expr5768 ) ) {
445:
446:
447: const Token * tokRightAstOperand@var2719 ; tokRightAstOperand@var2719 =@expr1073747607 innerTok@var2718 .@expr5767 next (@expr5768 ) .@expr1073747610 astOperand2 (@expr1073747611 ) ;
448: while (@expr1073747612 tokRightAstOperand@var2719 &&@expr1073747613 tokRightAstOperand@var2719 .@expr1073747614 isCast (@expr1073747615 ) ) {
449: tokRightAstOperand@var2719 =@expr1073747616 tokRightAstOperand@var2719 .@expr5793 astOperand2 (@expr5794 ) ?@expr1073747619 tokRightAstOperand@var2719 .@expr5793 astOperand2 (@expr5794 ) :@expr1073747622 tokRightAstOperand@var2719 .@expr1073747623 astOperand1 (@expr1073747624 ) ; }
450: if (@expr1073747625 tokRightAstOperand@var2719 &&@expr1073747626 Token ::@expr5478 Match (@expr1073747628 tokRightAstOperand@var2719 .@expr5805 previous (@expr5806 ) , "%type% (" ) ) {
451: const Library ::@expr5646 AllocFunc * f@var2720 ; f@var2720 =@expr1073747632 mSettings@var29 .@expr5648 library@var2926 .@expr5649 getAllocFuncInfo (@expr1073747635 tokRightAstOperand@var2719 .@expr5805 previous (@expr5806 ) ) ;
452: if (@expr1073747638 f@var2720 &&@expr1073747639 f@var2720 .@expr1073747640 arg@var2721 ==@expr1073747641 -1 ) {
453: VarInfo ::@expr5439 AllocInfo &@expr5656 varAlloc@var2722 =@expr1073747644 alloctype@var2686 [@expr5821 innerTok@var2718 .@expr5822 varId (@expr5823 ) ] ;
454: varAlloc@var2722 .@expr1073747648 type@var2723 =@expr1073747649 f@var2720 .@expr1073747650 groupId@var2724 ;
455: varAlloc@var2722 .@expr1073747651 status@var2725 =@expr1073747652 VarInfo ::@expr5666 ALLOC ;
456: varAlloc@var2722 .@expr1073747654 allocTok@var2726 =@expr1073747655 tokRightAstOperand@var2719 .@expr5805 previous (@expr5806 ) ;
457: } else {
458:
459: alloctype@var2686 .@expr1073747658 erase (@expr1073747659 innerTok@var2718 .@expr5822 varId (@expr5823 ) ) ;
460: }
461:
462: changeAllocStatusIfRealloc (@expr1073747662 alloctype@var2686 , innerTok@var2718 .@expr5839 tokAt (@expr5840 2 ) , varTok@var2698 ) ;
463: } else { if (@expr1073747665 mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) &&@expr1073747668 Token ::@expr5478 Match (@expr1073747670 innerTok@var2718 .@expr5839 tokAt (@expr5840 2 ) , "new !!(" ) ) {
464: const Token * tok2@var2727 ; tok2@var2727 =@expr1073747673 innerTok@var2718 .@expr5839 tokAt (@expr5840 2 ) .@expr1073747676 astOperand1 (@expr1073747677 ) ;
465: const bool arrayNew@var2728 =@expr1073747678 tok2@var2727 &&@expr1073747679 (@expr1073747680 tok2@var2727 .@expr5857 str (@expr5858 ) ==@expr1073747683 "[" ||@expr1073747684 (@expr1073747685 tok2@var2727 .@expr5857 str (@expr5858 ) ==@expr1073747688 "(" &&@expr1073747689 tok2@var2727 .@expr5866 astOperand1 (@expr5867 ) &&@expr1073747692 tok2@var2727 .@expr5866 astOperand1 (@expr5867 ) .@expr1073747695 str (@expr1073747696 ) ==@expr1073747697 "[" ) ) ;
466: VarInfo ::@expr5439 AllocInfo &@expr5656 varAlloc@var2729 =@expr1073747700 alloctype@var2686 [@expr5821 innerTok@var2718 .@expr5822 varId (@expr5823 ) ] ;
467: varAlloc@var2729 .@expr1073747704 type@var2730 =@expr1073747705 arrayNew@var2728 ?@expr1073747706 NEW_ARRAY@var2618 :@expr5712 NEW@var2619 ;
468: varAlloc@var2729 .@expr1073747708 status@var2731 =@expr1073747709 VarInfo ::@expr5666 ALLOC ;
469: varAlloc@var2729 .@expr1073747711 allocTok@var2732 =@expr1073747712 innerTok@var2718 .@expr5839 tokAt (@expr5840 2 ) ;
470: } }
471: }
472:
473:
474: const Token * const openingPar@var2733 ; openingPar@var2733 =@expr1073747715 isFunctionCall (@expr1073747716 innerTok@var2718 ) ;
475: if (@expr1073747717 openingPar@var2733 ) {
476:
477: const VarInfo ::@expr1073747718 AllocInfo allocation@var2734 (@expr1073747719 0 , VarInfo ::@expr5896 NOALLOC ) ;
478: functionCall (@expr1073747721 innerTok@var2718 , openingPar@var2733 , varInfo@var2682 , allocation@var2734 , nullptr ) ;
479: innerTok@var2718 =@expr1073747722 openingPar@var2733 .@expr1073747723 link (@expr1073747724 ) ;
480: }
481: }
482:
483: if (@expr1073747725 Token ::@expr5754 simpleMatch (@expr1073747727 closingParenthesis@var2717 , ") {" ) ) {
484: VarInfo varInfo1@var2735 (@expr1073747728 *@expr5581 varInfo@var2682 ) ;
485: VarInfo varInfo2@var2736 (@expr1073747730 *@expr5581 varInfo@var2682 ) ;
486:
487:
488: const Token * astOperand2AfterCommas@var2737 ; astOperand2AfterCommas@var2737 =@expr1073747732 tok@var2693 .@expr5458 next (@expr5459 ) .@expr1073747735 astOperand2 (@expr1073747736 ) ;
489: while (@expr1073747737 Token ::@expr5754 simpleMatch (@expr1073747739 astOperand2AfterCommas@var2737 , "," ) ) {
490: astOperand2AfterCommas@var2737 =@expr1073747740 astOperand2AfterCommas@var2737 .@expr1073747741 astOperand2 (@expr1073747742 ) ; }
491:
492:
493: visitAstNodes (@expr1073747743 astOperand2AfterCommas@var2737 , [@expr1073747744 &@expr5656 ] (@expr1073747746 const Token *@expr5453 tok3@var2738 ) {
494: if (@expr1073747748 !@expr1073747749 tok3@var2738 ) {
495: return ChildrenToVisit ::@expr5926 none ; }
496: if (@expr1073747751 tok3@var2738 .@expr5928 str (@expr5929 ) ==@expr1073747754 "&&" ||@expr1073747755 tok3@var2738 .@expr5928 str (@expr5929 ) ==@expr1073747758 "||" ) {
497:
498: return ChildrenToVisit ::@expr1073747759 op1_and_op2 ;
499: }
500: if (@expr1073747760 tok3@var2738 .@expr5928 str (@expr5929 ) ==@expr5939 "(" &&@expr1073747764 Token ::@expr5478 Match (@expr1073747766 tok3@var2738 .@expr1073747767 astOperand1 (@expr1073747768 ) , "UNLIKELY|LIKELY" ) ) {
501: return ChildrenToVisit ::@expr1073747769 op2 ;
502: } else { if (@expr1073747770 tok3@var2738 .@expr5928 str (@expr5929 ) ==@expr5939 "(" &&@expr1073747774 Token ::@expr5478 Match (@expr1073747776 tok3@var2738 .@expr5953 previous (@expr5954 ) , "%name%" ) ) {
503: const std ::@expr1073747779 vector < const Token *@expr5453 > params@var2739 =@expr1073747781 getArguments (@expr1073747782 tok3@var2738 .@expr5953 previous (@expr5954 ) ) ;
504: for (@expr1073747785 const Token *@expr5453 par@var2740 :@expr1073747787 params@var2739 ) {
505: if (@expr1073747788 !@expr1073747789 par@var2740 .@expr1073747790 isComparisonOp (@expr1073747791 ) ) {
506: continue ; }
507: const Token * vartok@var2741 ; vartok@var2741 =@expr1073747792 nullptr ;
508: if (@expr1073747793 isVarTokComparison (@expr1073747794 par@var2740 , &@expr5971 vartok@var2741 , alloc_success_conds@var2621 ) ||@expr1073747796
509: (@expr1073747797 isVarTokComparison (@expr1073747798 par@var2740 , &@expr5971 vartok@var2741 , alloc_failed_conds@var2620 ) ) ) {
510: varInfo1@var2735 .@expr5976 erase (@expr1073747801 vartok@var2741 .@expr5978 varId (@expr5979 ) ) ;
511: varInfo2@var2736 .@expr5980 erase (@expr1073747805 vartok@var2741 .@expr5978 varId (@expr5979 ) ) ;
512: }
513: }
514: return ChildrenToVisit ::@expr5926 none ;
515: } }
516:
517: const Token * vartok@var2742 ; vartok@var2742 =@expr1073747809 nullptr ;
518: if (@expr1073747810 isVarTokComparison (@expr1073747811 tok3@var2738 , &@expr5988 vartok@var2742 , alloc_success_conds@var2621 ) ) {
519: varInfo2@var2736 .@expr1073747813 reallocToAlloc (@expr1073747814 vartok@var2742 .@expr5991 varId (@expr5992 ) ) ;
520: varInfo2@var2736 .@expr5980 erase (@expr1073747818 vartok@var2742 .@expr5991 varId (@expr5992 ) ) ;
521: if (@expr1073747821 astIsVariableComparison (@expr1073747822 tok3@var2738 , "!=" , "0" , &@expr5988 vartok@var2742 ) &&@expr1073747824
522: (@expr1073747825 notzero@var2683 .@expr1073747826 find (@expr1073747827 vartok@var2742 .@expr5991 varId (@expr5992 ) ) !=@expr1073747830 notzero@var2683 .@expr1073747831 end (@expr1073747832 ) ) ) {
523: varInfo2@var2736 .@expr1073747833 clear (@expr1073747834 ) ; }
524: } else { if (@expr1073747835 isVarTokComparison (@expr1073747836 tok3@var2738 , &@expr5988 vartok@var2742 , alloc_failed_conds@var2620 ) ) {
525: varInfo1@var2735 .@expr1073747838 reallocToAlloc (@expr1073747839 vartok@var2742 .@expr5991 varId (@expr5992 ) ) ;
526: varInfo1@var2735 .@expr5976 erase (@expr1073747843 vartok@var2742 .@expr5991 varId (@expr5992 ) ) ;
527: } }
528: return ChildrenToVisit ::@expr5926 none ;
529: } ) ;
530:
531: checkScope (@expr1073747847 closingParenthesis@var2717 .@expr1073747848 next (@expr1073747849 ) , &@expr1073747850 varInfo1@var2735 , notzero@var2683 , recursiveCount@var2684 ) ;
532: closingParenthesis@var2717 =@expr1073747851 closingParenthesis@var2717 .@expr6028 linkAt (@expr1073747853 1 ) ;
533: if (@expr1073747854 Token ::@expr5754 simpleMatch (@expr1073747856 closingParenthesis@var2717 , "} else {" ) ) {
534: checkScope (@expr1073747857 closingParenthesis@var2717 .@expr1073747858 tokAt (@expr1073747859 2 ) , &@expr1073747860 varInfo2@var2736 , notzero@var2683 , recursiveCount@var2684 ) ;
535: tok@var2693 =@expr1073747861 closingParenthesis@var2717 .@expr6028 linkAt (@expr1073747863 2 ) .@expr1073747864 previous (@expr1073747865 ) ;
536: } else {
537: tok@var2693 =@expr1073747866 closingParenthesis@var2717 .@expr1073747867 previous (@expr1073747868 ) ;
538: }
539:
540: VarInfo old@var2743 ;
541: old@var2743 .@expr1073747869 swap (@expr1073747870 *@expr5581 varInfo@var2682 ) ;
542:
543: std ::@expr5438 map < int , VarInfo ::@expr5439 AllocInfo > ::@expr1073747874 const_iterator it@var2744 ;
544:
545: for (@expr1073747875 it@var2744 =@expr1073747876 old@var2743 .@expr6053 alloctype@var2745 .@expr1073747878 begin (@expr1073747879 ) ; it@var2744 !=@expr1073747880 old@var2743 .@expr6053 alloctype@var2745 .@expr6058 end (@expr6059 ) ; ++@expr1073747884 it@var2744 ) {
546: const int varId@var2746 =@expr1073747885 it@var2744 .@expr6062 first@var2747 ;
547: if (@expr1073747887 old@var2743 .@expr6064 conditionalAlloc@var2748 .@expr1073747889 find (@expr1073747890 varId@var2746 ) ==@expr1073747891 old@var2743 .@expr6064 conditionalAlloc@var2748 .@expr1073747893 end (@expr1073747894 ) ) {
548: continue ; }
549: if (@expr1073747895 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6073 find (@expr1073747898 varId@var2746 ) ==@expr1073747899 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6077 end (@expr6078 ) ||@expr1073747903
550: varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6081 find (@expr1073747906 varId@var2746 ) ==@expr1073747907 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6085 end (@expr6086 ) ) {
551: varInfo1@var2735 .@expr5976 erase (@expr1073747912 varId@var2746 ) ;
552: varInfo2@var2736 .@expr5980 erase (@expr1073747914 varId@var2746 ) ;
553: }
554: }
555:
556:
557: for (@expr1073747915 it@var2744 =@expr1073747916 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6094 begin (@expr6095 ) ; it@var2744 !=@expr6096 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6077 end (@expr6078 ) ; ++@expr1073747924 it@var2744 ) {
558: if (@expr1073747925 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6081 find (@expr1073747928 it@var2744 .@expr6062 first@var2747 ) ==@expr1073747930 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6085 end (@expr6086 ) &&@expr1073747934
559: old@var2743 .@expr6053 alloctype@var2745 .@expr6112 find (@expr6113 it@var2744 .@expr6062 first@var2747 ) ==@expr6115 old@var2743 .@expr6053 alloctype@var2745 .@expr6058 end (@expr6059 ) ) {
560: varInfo@var2682 .@expr5448 conditionalAlloc@var2691 .@expr6120 insert (@expr6121 it@var2744 .@expr6062 first@var2747 ) ;
561: }
562: }
563:
564:
565: for (@expr1073747947 it@var2744 =@expr1073747948 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6126 begin (@expr6127 ) ; it@var2744 !=@expr6128 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6085 end (@expr6086 ) ; ++@expr1073747956 it@var2744 ) {
566: if (@expr1073747957 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6073 find (@expr1073747960 it@var2744 .@expr6062 first@var2747 ) ==@expr1073747962 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6077 end (@expr6078 ) &&@expr1073747966
567: old@var2743 .@expr6053 alloctype@var2745 .@expr6112 find (@expr6113 it@var2744 .@expr6062 first@var2747 ) ==@expr6115 old@var2743 .@expr6053 alloctype@var2745 .@expr6058 end (@expr6059 ) ) {
568: varInfo@var2682 .@expr5448 conditionalAlloc@var2691 .@expr6120 insert (@expr6121 it@var2744 .@expr6062 first@var2747 ) ;
569: }
570: }
571:
572:
573: for (@expr1073747979 it@var2744 =@expr1073747980 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6094 begin (@expr6095 ) ; it@var2744 !=@expr6096 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6077 end (@expr6078 ) ; ++@expr1073747988 it@var2744 ) {
574: if (@expr6165 it@var2744 .@expr6166 second@var2751 .@expr6167 managed (@expr6168 ) &&@expr6169 conditionalAlloc@var2690 .@expr5620 find (@expr6171 it@var2744 .@expr6062 first@var2747 ) !=@expr6173 conditionalAlloc@var2690 .@expr5625 end (@expr5626 ) ) {
575: varInfo@var2682 .@expr5448 conditionalAlloc@var2691 .@expr6177 erase (@expr6178 it@var2744 .@expr6062 first@var2747 ) ;
576: varInfo2@var2736 .@expr5980 erase (@expr1073748005 it@var2744 .@expr6062 first@var2747 ) ;
577: }
578: }
579: for (@expr1073748007 it@var2744 =@expr1073748008 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6126 begin (@expr6127 ) ; it@var2744 !=@expr6128 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6085 end (@expr6086 ) ; ++@expr1073748016 it@var2744 ) {
580: if (@expr6165 it@var2744 .@expr6166 second@var2751 .@expr6167 managed (@expr6168 ) &&@expr6169 conditionalAlloc@var2690 .@expr5620 find (@expr6171 it@var2744 .@expr6062 first@var2747 ) !=@expr6173 conditionalAlloc@var2690 .@expr5625 end (@expr5626 ) ) {
581: varInfo@var2682 .@expr5448 conditionalAlloc@var2691 .@expr6177 erase (@expr6178 it@var2744 .@expr6062 first@var2747 ) ;
582: varInfo1@var2735 .@expr5976 erase (@expr1073748033 it@var2744 .@expr6062 first@var2747 ) ;
583: }
584: }
585:
586: alloctype@var2686 .@expr6211 insert (@expr1073748036 varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6094 begin (@expr6095 ) , varInfo1@var2735 .@expr6072 alloctype@var2749 .@expr6077 end (@expr6078 ) ) ;
587: alloctype@var2686 .@expr6211 insert (@expr1073748044 varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6126 begin (@expr6127 ) , varInfo2@var2736 .@expr6080 alloctype@var2750 .@expr6085 end (@expr6086 ) ) ;
588:
589: possibleUsage@var2688 .@expr6227 insert (@expr1073748052 varInfo1@var2735 .@expr6229 possibleUsage@var2752 .@expr1073748054 begin (@expr1073748055 ) , varInfo1@var2735 .@expr6229 possibleUsage@var2752 .@expr1073748057 end (@expr1073748058 ) ) ;
590: possibleUsage@var2688 .@expr6227 insert (@expr1073748060 varInfo2@var2736 .@expr6237 possibleUsage@var2753 .@expr1073748062 begin (@expr1073748063 ) , varInfo2@var2736 .@expr6237 possibleUsage@var2753 .@expr1073748065 end (@expr1073748066 ) ) ;
591: }
592: }
593:
594:
595: else { if (@expr1073748067 (@expr1073748068 Token ::@expr5478 Match (@expr1073748070 tok@var2693 , "%type% (" ) &&@expr1073748071 Token ::@expr5754 simpleMatch (@expr1073748073 tok@var2693 .@expr5757 linkAt (@expr5758 1 ) , ") {" ) ) ||@expr1073748076 Token ::@expr5754 simpleMatch (@expr1073748078 tok@var2693 , "do {" ) ) {
596: varInfo@var2682 .@expr6255 clear (@expr6256 ) ;
597: break ;
598: }
599:
600:
601: else { if (@expr1073748081 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr1073748084 "return" ) {
602: ret (@expr6261 tok@var2693 , *@expr5581 varInfo@var2682 ) ;
603: varInfo@var2682 .@expr6255 clear (@expr6256 ) ;
604: }
605:
606:
607: else { if (@expr1073748089 mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) &&@expr1073748092 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr1073748095 "throw" ) {
608: bool tryFound@var2754 ; tryFound@var2754 =@expr1073748096 false ;
609: const Scope * scope@var2755 ; scope@var2755 =@expr1073748097 tok@var2693 .@expr5462 scope (@expr5463 ) ;
610: while (@expr1073748100 scope@var2755 &&@expr1073748101 scope@var2755 .@expr1073748102 isExecutable (@expr1073748103 ) ) {
611: if (@expr1073748104 scope@var2755 .@expr1073748105 type@var2756 ==@expr1073748106 Scope ::@expr1073748107 eTry ) {
612: tryFound@var2754 =@expr1073748108 true ; }
613: scope@var2755 =@expr1073748109 scope@var2755 .@expr1073748110 nestedIn@var2757 ;
614: }
615:
616: if (@expr1073748111 !@expr1073748112 tryFound@var2754 ) {
617: ret (@expr6261 tok@var2693 , *@expr5581 varInfo@var2682 ) ; }
618: varInfo@var2682 .@expr6255 clear (@expr6256 ) ;
619: }
620:
621:
622: else { if (@expr1073748117 mTokenizer@var28 .@expr5636 isCPP (@expr5637 ) &&@expr1073748120 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr1073748123 "delete" ) {
623: const Token * delTok@var2758 ; delTok@var2758 =@expr1073748124 tok@var2693 ;
624: const bool arrayDelete@var2759 =@expr1073748125 Token ::@expr5754 simpleMatch (@expr1073748127 tok@var2693 .@expr5458 next (@expr5459 ) , "[ ]" ) ;
625: if (@expr1073748130 arrayDelete@var2759 ) {
626: tok@var2693 =@expr1073748131 tok@var2693 .@expr5496 tokAt (@expr1073748133 3 ) ; }
627: else {
628: tok@var2693 =@expr1073748134 tok@var2693 .@expr5458 next (@expr5459 ) ; }
629: if (@expr1073748137 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr5501 "(" ) {
630: tok@var2693 =@expr1073748141 tok@var2693 .@expr5458 next (@expr5459 ) ; }
631: while (@expr1073748144 Token ::@expr5478 Match (@expr1073748146 tok@var2693 , "%name% ::|." ) ) {
632: tok@var2693 =@expr1073748147 tok@var2693 .@expr5496 tokAt (@expr5497 2 ) ; }
633: const bool isnull@var2760 =@expr1073748150 tok@var2693 .@expr1073748151 hasKnownIntValue (@expr1073748152 ) &&@expr1073748153 tok@var2693 .@expr1073748154 values (@expr1073748155 ) .@expr1073748156 front (@expr1073748157 ) .@expr1073748158 intvalue@expr1073747255 ==@expr1073748159 0 ;
634: if (@expr1073748160 !@expr1073748161 isnull@var2760 &&@expr1073748162 tok@var2693 .@expr1073748163 varId (@expr1073748164 ) &&@expr1073748165 tok@var2693 .@expr1073748166 strAt (@expr1073748167 1 ) !=@expr1073748168 "[" ) {
635: const VarInfo ::@expr1073748169 AllocInfo allocation@var2761 (@expr1073748170 arrayDelete@var2759 ?@expr1073748171 NEW_ARRAY@var2618 :@expr5712 NEW@var2619 , VarInfo ::@expr6349 DEALLOC , delTok@var2758 ) ;
636: changeAllocStatus (@expr1073748174 varInfo@var2682 , allocation@var2761 , tok@var2693 , tok@var2693 ) ;
637: }
638: }
639:
640:
641: else { if (@expr1073748175 isFunctionCall (@expr6352 ftok@var2696 ) ) {
642: const Token * openingPar@var2762 ; openingPar@var2762 =@expr1073748177 isFunctionCall (@expr6352 ftok@var2696 ) ;
643: const Library ::@expr5646 AllocFunc * af@var2763 ; af@var2763 =@expr1073748180 mSettings@var29 .@expr5648 library@var2926 .@expr6358 getDeallocFuncInfo (@expr1073748183 ftok@var2696 ) ;
644: VarInfo ::@expr1073748184 AllocInfo allocation@var2764 (@expr1073748185 af@var2763 ?@expr1073748186 af@var2763 .@expr1073748187 groupId@var2765 :@expr1073748188 0 , VarInfo ::@expr6349 DEALLOC , ftok@var2696 ) ;
645: if (@expr1073748190 allocation@var2764 .@expr1073748191 type@var2766 ==@expr1073748192 0 ) {
646: allocation@var2764 .@expr6369 status@var2767 =@expr1073748194 VarInfo ::@expr5896 NOALLOC ; }
647: functionCall (@expr1073748196 ftok@var2696 , openingPar@var2762 , varInfo@var2682 , allocation@var2764 , af@var2763 ) ;
648:
649: tok@var2693 =@expr1073748197 ftok@var2696 .@expr5531 next (@expr5532 ) .@expr1073748200 link (@expr1073748201 ) ;
650:
651:
652: if (@expr1073748202 allocation@var2764 .@expr6369 status@var2767 ==@expr1073748204 VarInfo ::@expr5896 NOALLOC &&@expr1073748206 Token ::@expr5754 simpleMatch (@expr1073748208 tok@var2693 , ") ; }" ) ) {
653: const std ::@expr1073748209 string functionName@var2768 (@expr1073748210 mSettings@var29 .@expr5648 library@var2926 .@expr1073748212 getFunctionName (@expr1073748213 tok@var2693 .@expr1073748214 link (@expr1073748215 ) .@expr1073748216 previous (@expr1073748217 ) ) ) ;
654: bool unknown@var2769 ; unknown@var2769 =@expr1073748218 false ;
655: if (@expr1073748219 mTokenizer@var28 .@expr1073748220 isScopeNoReturn (@expr1073748221 tok@var2693 .@expr5496 tokAt (@expr5497 2 ) , &@expr1073748224 unknown@var2769 ) ) {
656: if (@expr1073748225 !@expr1073748226 unknown@var2769 ) {
657: varInfo@var2682 .@expr6255 clear (@expr6256 ) ; }
658: else { if (@expr1073748229 !@expr1073748230 mSettings@var29 .@expr5648 library@var2926 .@expr1073748232 isLeakIgnore (@expr1073748233 functionName@var2768 ) &&@expr1073748234 !@expr1073748235 mSettings@var29 .@expr5648 library@var2926 .@expr1073748237 isUse (@expr1073748238 functionName@var2768 ) ) {
659: varInfo@var2682 .@expr1073748239 possibleUsageAll (@expr1073748240 functionName@var2768 ) ; } }
660: }
661: }
662:
663: continue ;
664: }
665:
666:
667: else { if (@expr1073748241 tok@var2693 .@expr5499 str (@expr5500 ) ==@expr1073748244 "goto" ) {
668: varInfo@var2682 .@expr6255 clear (@expr6256 ) ;
669: }
670:
671:
672: else { if (@expr1073748247 Token ::@expr5478 Match (@expr1073748249 tok@var2693 , "continue|break ;" ) ) {
673: varInfo@var2682 .@expr6255 clear (@expr6256 ) ;
674: }
675:
676:
677: else { if (@expr1073748252 Token ::@expr5478 Match (@expr1073748254 ftok@var2696 , "%name% <" ) &&@expr1073748255 mSettings@var29 .@expr5648 library@var2926 .@expr1073748257 isSmartPointer (@expr1073748258 tok@var2693 ) ) {
678: const Token * typeEndTok@var2770 ; typeEndTok@var2770 =@expr1073748259 ftok@var2696 .@expr1073748260 linkAt (@expr1073748261 1 ) ;
679: if (@expr1073748262 !@expr1073748263 Token ::@expr5478 Match (@expr1073748265 typeEndTok@var2770 , "> %var% {|( %var% ,|)|}" ) ) {
680: continue ; }
681:
682: tok@var2693 =@expr1073748266 typeEndTok@var2770 .@expr6443 linkAt (@expr6444 2 ) ;
683:
684: const int varid@var2771 =@expr1073748269 typeEndTok@var2770 .@expr1073748270 next (@expr1073748271 ) .@expr1073748272 varId (@expr1073748273 ) ;
685: if (@expr1073748274 isPointerReleased (@expr1073748275 typeEndTok@var2770 .@expr6452 tokAt (@expr1073748277 2 ) , endToken@var2692 , varid@var2771 ) ) {
686: continue ; }
687:
688: bool arrayDelete@var2772 ; arrayDelete@var2772 =@expr1073748278 false ;
689: if (@expr1073748279 Token ::@expr1073748280 findsimplematch (@expr1073748281 ftok@var2696 .@expr5531 next (@expr5532 ) , "[ ]" , typeEndTok@var2770 ) ) {
690: arrayDelete@var2772 =@expr1073748284 true ; }
691:
692:
693: const Token * deleterToken@var2773 ; deleterToken@var2773 =@expr1073748285 nullptr ;
694: const Token * endDeleterToken@var2774 ; endDeleterToken@var2774 =@expr1073748286 nullptr ;
695: const Library ::@expr5646 AllocFunc * af@var2775 ; af@var2775 =@expr1073748288 nullptr ;
696: if (@expr1073748289 Token ::@expr5478 Match (@expr1073748291 ftok@var2696 , "unique_ptr < %type% ," ) ) {
697: deleterToken@var2773 =@expr1073748292 ftok@var2696 .@expr5537 tokAt (@expr1073748294 4 ) ;
698: endDeleterToken@var2774 =@expr1073748295 typeEndTok@var2770 ;
699: } else { if (@expr1073748296 Token ::@expr5478 Match (@expr1073748298 typeEndTok@var2770 , "> %var% {|( %var% ," ) ) {
700: deleterToken@var2773 =@expr1073748299 typeEndTok@var2770 .@expr6452 tokAt (@expr1073748301 5 ) ;
701: endDeleterToken@var2774 =@expr1073748302 typeEndTok@var2770 .@expr6443 linkAt (@expr6444 2 ) ;
702: } }
703: if (@expr1073748305 deleterToken@var2773 ) {
704:
705: if (@expr1073748306 deleterToken@var2773 .@expr6483 str (@expr6484 ) ==@expr1073748309 "+" ) {
706: deleterToken@var2773 =@expr1073748310 deleterToken@var2773 .@expr1073748311 next (@expr1073748312 ) ;
707: }
708:
709: const Token * dtok@var2776 ; dtok@var2776 =@expr1073748313 Token ::@expr6490 findmatch (@expr1073748315 deleterToken@var2773 , "& %name%" , endDeleterToken@var2774 ) ;
710: if (@expr1073748316 dtok@var2776 ) {
711: af@var2775 =@expr1073748317 mSettings@var29 .@expr5648 library@var2926 .@expr6358 getDeallocFuncInfo (@expr1073748320 dtok@var2776 .@expr1073748321 tokAt (@expr1073748322 1 ) ) ;
712: } else {
713: const Token * tscopeStart@var2777 ; tscopeStart@var2777 =@expr1073748323 nullptr ;
714: const Token * tscopeEnd@var2778 ; tscopeEnd@var2778 =@expr1073748324 nullptr ;
715:
716: if (@expr1073748325 deleterToken@var2773 .@expr6483 str (@expr6484 ) ==@expr1073748328 "[" &&@expr1073748329
717: Token ::@expr5754 simpleMatch (@expr1073748331 deleterToken@var2773 .@expr6508 link (@expr6509 ) , "] (" ) &&@expr1073748334
718:
719: Token ::@expr5754 simpleMatch (@expr1073748336 deleterToken@var2773 .@expr6508 link (@expr6509 ) .@expr6515 linkAt (@expr6516 1 ) , ") {" ) ) {
720: tscopeStart@var2777 =@expr1073748341 deleterToken@var2773 .@expr6508 link (@expr6509 ) .@expr6515 linkAt (@expr6516 1 ) .@expr1073748346 tokAt (@expr1073748347 1 ) ;
721: tscopeEnd@var2778 =@expr1073748348 tscopeStart@var2777 .@expr1073748349 link (@expr1073748350 ) ;
722:
723: } else { if (@expr1073748351 (@expr1073748352 dtok@var2776 =@expr1073748353 Token ::@expr6490 findmatch (@expr1073748355 deleterToken@var2773 , "%type%" , endDeleterToken@var2774 ) ) &&@expr1073748356 dtok@var2776 .@expr6533 type (@expr6534 ) ) {
724: const Scope * tscope@var2779 ; tscope@var2779 =@expr1073748359 dtok@var2776 .@expr6533 type (@expr6534 ) .@expr1073748362 classScope@var2943 ;
725: if (@expr1073748363 tscope@var2779 ) {
726: tscopeStart@var2777 =@expr1073748364 tscope@var2779 .@expr1073748365 bodyStart@var2780 ;
727: tscopeEnd@var2778 =@expr1073748366 tscope@var2779 .@expr1073748367 bodyEnd@var2781 ;
728: }
729: } }
730:
731: if (@expr1073748368 tscopeStart@var2777 &&@expr1073748369 tscopeEnd@var2778 ) {
732: for (@expr1073748370 const Token *@expr5453 tok2@var2782 =@expr1073748372 tscopeStart@var2777 ; tok2@var2782 !=@expr1073748373 tscopeEnd@var2778 ; tok2@var2782 =@expr1073748374 tok2@var2782 .@expr1073748375 next (@expr1073748376 ) ) {
733: af@var2775 =@expr1073748377 mSettings@var29 .@expr5648 library@var2926 .@expr6358 getDeallocFuncInfo (@expr1073748380 tok2@var2782 ) ;
734: if (@expr1073748381 af@var2775 ) {
735: break ; }
736: }
737: }
738: }
739: }
740:
741: const Token * vtok@var2783 ; vtok@var2783 =@expr1073748382 typeEndTok@var2770 .@expr6452 tokAt (@expr1073748384 3 ) ;
742: const VarInfo ::@expr1073748385 AllocInfo allocation@var2784 (@expr1073748386 af@var2775 ?@expr1073748387 af@var2775 .@expr1073748388 groupId@var2785 :@expr1073748389 (@expr1073748390 arrayDelete@var2772 ?@expr1073748391 NEW_ARRAY@var2618 :@expr5712 NEW@var2619 ) , VarInfo ::@expr1073748393 OWNED , ftok@var2696 ) ;
743: changeAllocStatus (@expr1073748394 varInfo@var2682 , allocation@var2784 , vtok@var2783 , vtok@var2783 ) ;
744: } } } } } } } } } }
745: }
746: ret (@expr1073748395 endToken@var2692 , *@expr5581 varInfo@var2682 , true ) ;
747: }
748:
749:
750: const Token * CheckLeakAutoVar :: checkTokenInsideExpression ( const Token * const tok@var2786 , VarInfo * varInfo@var2787 )
751: {
752:
753: if (@expr1073748397 tok@var2786 .@expr6574 varId (@expr6575 ) >@expr1073748400 0 ) {
754:
755: const std ::@expr1073748401 map < int , VarInfo ::@expr6578 AllocInfo > ::@expr1073748403 const_iterator var@var2788 =@expr1073748404 varInfo@var2787 .@expr6581 alloctype@var2789 .@expr1073748406 find (@expr1073748407 tok@var2786 .@expr6574 varId (@expr6575 ) ) ;
756: if (@expr1073748410 var@var2788 !=@expr1073748411 varInfo@var2787 .@expr6581 alloctype@var2789 .@expr1073748413 end (@expr1073748414 ) ) {
757: bool unknown@var2790 ; unknown@var2790 =@expr1073748415 false ;
758: if (@expr1073748416 var@var2788 .@expr1073748417 second@var2791 .@expr1073748418 status@var2792 ==@expr1073748419 VarInfo ::@expr6596 DEALLOC &&@expr1073748421 CheckNullPointer ::@expr1073748422 isPointerDeRef (@expr1073748423 tok@var2786 , unknown@var2790 , mSettings@var29 ) &&@expr1073748424 !@expr1073748425 unknown@var2790 ) {
759: deallocUseError (@expr1073748426 tok@var2786 , tok@var2786 .@expr1073748427 str (@expr1073748428 ) ) ;
760: } else { if (@expr1073748429 Token ::@expr1073748430 simpleMatch (@expr1073748431 tok@var2786 .@expr6608 tokAt (@expr1073748433 -2 ) , "= &" ) ) {
761: varInfo@var2787 .@expr6610 erase (@expr6611 tok@var2786 .@expr6574 varId (@expr6575 ) ) ;
762: } else {
763:
764: const Token * rhs@var2793 ; rhs@var2793 =@expr1073748438 tok@var2786 ;
765: while (@expr1073748439 rhs@var2793 .@expr6616 astParent (@expr6617 ) ) {
766: if (@expr1073748442 rhs@var2793 .@expr6616 astParent (@expr6617 ) .@expr1073748445 str (@expr1073748446 ) ==@expr1073748447 "=" ) {
767: break ; }
768: rhs@var2793 =@expr1073748448 rhs@var2793 .@expr6616 astParent (@expr6617 ) ;
769: }
770: while (@expr1073748451 rhs@var2793 .@expr1073748452 isCast (@expr1073748453 ) ) {
771: rhs@var2793 =@expr1073748454 rhs@var2793 .@expr6631 astOperand1 (@expr6632 ) ;
772: }
773: if (@expr1073748457 rhs@var2793 .@expr1073748458 varId (@expr1073748459 ) ==@expr1073748460 tok@var2786 .@expr6574 varId (@expr6575 ) ) {
774:
775: varInfo@var2787 .@expr6610 erase (@expr6611 tok@var2786 .@expr6574 varId (@expr6575 ) ) ;
776: } else { if (@expr1073748467 rhs@var2793 .@expr1073748468 str (@expr1073748469 ) ==@expr1073748470 "(" &&@expr1073748471 !@expr1073748472 mSettings@var29 .@expr6649 library@var2926 .@expr6650 returnValue (@expr6651 rhs@var2793 .@expr6631 astOperand1 (@expr6632 ) ) .@expr1073748478 empty (@expr1073748479 ) ) {
777:
778: const std ::@expr6578 string &@expr6657 returnValue@var2794 =@expr1073748482 mSettings@var29 .@expr6649 library@var2926 .@expr6650 returnValue (@expr6651 rhs@var2793 .@expr6631 astOperand1 (@expr6632 ) ) ;
779: if (@expr1073748488 returnValue@var2794 .@expr1073748489 compare (@expr1073748490 0 , 3 , "arg" ) ==@expr1073748491 0 ) {
780: int argn@var2795 ;
781: const Token * func@var2796 ; func@var2796 =@expr1073748492 getTokenArgumentFunction (@expr1073748493 tok@var2786 , argn@var2795 ) ;
782: if (@expr1073748494 func@var2796 ) {
783: const std ::@expr6578 string arg@var2797 =@expr1073748496 "arg" +@expr1073748497 std ::@expr1073748498 to_string (@expr1073748499 argn@var2795 +@expr1073748500 1 ) ;
784: if (@expr1073748501 returnValue@var2794 ==@expr1073748502 arg@var2797 ) {
785: varInfo@var2787 .@expr6610 erase (@expr6611 tok@var2786 .@expr6574 varId (@expr6575 ) ) ;
786: }
787: }
788: }
789: } }
790: } }
791: } else { if (@expr1073748507 Token ::@expr1073748508 Match (@expr1073748509 tok@var2786 .@expr1073748510 previous (@expr1073748511 ) , "& %name% = %var% ;" ) ) {
792: varInfo@var2787 .@expr1073748512 referenced@var2798 .@expr1073748513 insert (@expr1073748514 tok@var2786 .@expr6608 tokAt (@expr1073748516 2 ) .@expr1073748517 varId (@expr1073748518 ) ) ;
793: } }
794: }
795:
796:
797: const Token * const openingPar@var2799 ; openingPar@var2799 =@expr1073748519 isFunctionCall (@expr1073748520 tok@var2786 ) ;
798: if (@expr1073748521 openingPar@var2799 ) {
799: const Library ::@expr1073748522 AllocFunc * allocFunc@var2800 ; allocFunc@var2800 =@expr1073748523 mSettings@var29 .@expr6649 library@var2926 .@expr1073748525 getDeallocFuncInfo (@expr1073748526 tok@var2786 ) ;
800: VarInfo ::@expr1073748527 AllocInfo alloc@var2801 (@expr1073748528 allocFunc@var2800 ?@expr1073748529 allocFunc@var2800 .@expr1073748530 groupId@var2802 :@expr1073748531 0 , VarInfo ::@expr6596 DEALLOC , tok@var2786 ) ;
801: if (@expr1073748533 alloc@var2801 .@expr1073748534 type@var2803 ==@expr1073748535 0 ) {
802: alloc@var2801 .@expr1073748536 status@var2804 =@expr1073748537 VarInfo ::@expr1073748538 NOALLOC ; }
803: functionCall (@expr1073748539 tok@var2786 , openingPar@var2799 , varInfo@var2787 , alloc@var2801 , nullptr ) ;
804: const std ::@expr6578 string &@expr6657 returnValue@var2805 =@expr1073748542 mSettings@var29 .@expr6649 library@var2926 .@expr6650 returnValue (@expr1073748545 tok@var2786 ) ;
805: if (@expr1073748546 returnValue@var2805 .@expr1073748547 compare (@expr1073748548 0 , 3 , "arg" ) ==@expr1073748549 0 ) {
806:
807: return openingPar@var2799 ; }
808: return openingPar@var2799 .@expr1073748550 link (@expr1073748551 ) ;
809: }
810:
811: return nullptr ;
812: }
813:
814:
815: void CheckLeakAutoVar :: changeAllocStatusIfRealloc ( std :: map < int , VarInfo :: AllocInfo > & alloctype@var2806 , const Token * fTok@var2807 , const Token * retTok@var2808 )
816: {
817: const Library ::@expr1073748552 AllocFunc * f@var2809 ; f@var2809 =@expr1073748553 mSettings@var29 .@expr1073748554 library@var2926 .@expr1073748555 getReallocFuncInfo (@expr1073748556 fTok@var2807 ) ;
818: if (@expr1073748557 f@var2809 &&@expr1073748558 f@var2809 .@expr1073748559 arg@var2810 ==@expr1073748560 -1 &&@expr1073748561 f@var2809 .@expr6738 reallocArg@var2811 >@expr1073748563 0 &&@expr1073748564 f@var2809 .@expr6738 reallocArg@var2811 <=@expr1073748566 numberOfArguments (@expr1073748567 fTok@var2807 ) ) {
819: const Token * argTok@var2812 ; argTok@var2812 =@expr1073748568 getArguments (@expr1073748569 fTok@var2807 ) .@expr1073748570 at (@expr1073748571 f@var2809 .@expr6738 reallocArg@var2811 -@expr1073748573 1 ) ;
820: if (@expr1073748574 alloctype@var2806 .@expr1073748575 find (@expr1073748576 argTok@var2812 .@expr6753 varId (@expr6754 ) ) !=@expr1073748579 alloctype@var2806 .@expr1073748580 end (@expr1073748581 ) ) {
821: VarInfo ::@expr6758 AllocInfo &@expr6759 argAlloc@var2813 =@expr1073748584 alloctype@var2806 [@expr1073748585 argTok@var2812 .@expr6753 varId (@expr6754 ) ] ;
822: if (@expr1073748588 argAlloc@var2813 .@expr6765 type@var2814 !=@expr1073748590 0 &&@expr1073748591 argAlloc@var2813 .@expr6765 type@var2814 !=@expr1073748593 f@var2809 .@expr6770 groupId@var2815 ) {
823: mismatchError (@expr1073748595 fTok@var2807 , argAlloc@var2813 .@expr6772 allocTok@var2816 , argTok@var2812 .@expr1073748597 str (@expr1073748598 ) ) ; }
824: argAlloc@var2813 .@expr1073748599 status@var2817 =@expr1073748600 VarInfo ::@expr1073748601 REALLOC ;
825: argAlloc@var2813 .@expr6772 allocTok@var2816 =@expr1073748603 fTok@var2807 ;
826: }
827: VarInfo ::@expr6758 AllocInfo &@expr6759 retAlloc@var2818 =@expr1073748606 alloctype@var2806 [@expr1073748607 retTok@var2808 .@expr1073748608 varId (@expr1073748609 ) ] ;
828: retAlloc@var2818 .@expr1073748610 type@var2819 =@expr1073748611 f@var2809 .@expr6770 groupId@var2815 ;
829: retAlloc@var2818 .@expr1073748613 status@var2820 =@expr1073748614 VarInfo ::@expr1073748615 ALLOC ;
830: retAlloc@var2818 .@expr1073748616 allocTok@var2821 =@expr1073748617 fTok@var2807 ;
831: retAlloc@var2818 .@expr1073748618 reallocedFromType@var2822 =@expr1073748619 argTok@var2812 .@expr6753 varId (@expr6754 ) ;
832: }
833: }
834:
835:
836: void CheckLeakAutoVar :: changeAllocStatus ( VarInfo * varInfo@var2823 , const VarInfo :: AllocInfo & allocation@var2824 , const Token * tok@var2825 , const Token * arg@var2826 )
837: {
838: std ::@expr6798 map < int , VarInfo ::@expr6799 AllocInfo > & alloctype@var2827 =@expr1073748624 varInfo@var2823 .@expr1073748625 alloctype@var2828 ;
839: const std ::@expr6798 map < int , VarInfo ::@expr6799 AllocInfo > ::@expr1073748628 iterator var@var2829 =@expr1073748629 alloctype@var2827 .@expr1073748630 find (@expr1073748631 arg@var2826 .@expr6808 varId (@expr6809 ) ) ;
840: if (@expr1073748634 var@var2829 !=@expr1073748635 alloctype@var2827 .@expr1073748636 end (@expr1073748637 ) ) {
841: if (@expr1073748638 allocation@var2824 .@expr6815 status@var2830 ==@expr1073748640 VarInfo ::@expr6817 NOALLOC ) {
842:
843: varInfo@var2823 .@expr1073748642 possibleUsage@var2831 [@expr1073748643 arg@var2826 .@expr6808 varId (@expr6809 ) ] =@expr1073748646 tok@var2825 .@expr1073748647 str (@expr1073748648 ) ;
844: if (@expr1073748649 var@var2829 .@expr6826 second@var2832 .@expr6827 status@var2833 ==@expr1073748652 VarInfo ::@expr6829 DEALLOC &&@expr1073748654 arg@var2826 .@expr1073748655 previous (@expr1073748656 ) .@expr1073748657 str (@expr1073748658 ) ==@expr1073748659 "&" ) {
845: varInfo@var2823 .@expr6836 erase (@expr6837 arg@var2826 .@expr6808 varId (@expr6809 ) ) ; }
846: } else { if (@expr1073748664 var@var2829 .@expr6826 second@var2832 .@expr1073748666 managed (@expr1073748667 ) ) {
847: doubleFreeError (@expr1073748668 tok@var2825 , var@var2829 .@expr6826 second@var2832 .@expr6846 allocTok@var2834 , arg@var2826 .@expr6847 str (@expr6848 ) , allocation@var2824 .@expr6849 type@var2835 ) ;
848: var@var2829 .@expr6826 second@var2832 .@expr6827 status@var2833 =@expr1073748676 allocation@var2824 .@expr6815 status@var2830 ;
849: } else { if (@expr1073748678 var@var2829 .@expr6826 second@var2832 .@expr6856 type@var2836 !=@expr1073748681 allocation@var2824 .@expr6849 type@var2835 &&@expr1073748683 var@var2829 .@expr6826 second@var2832 .@expr6856 type@var2836 !=@expr1073748686 0 ) {
850:
851: mismatchError (@expr1073748687 tok@var2825 , var@var2829 .@expr6826 second@var2832 .@expr6846 allocTok@var2834 , arg@var2826 .@expr6847 str (@expr6848 ) ) ;
852: varInfo@var2823 .@expr6836 erase (@expr6837 arg@var2826 .@expr6808 varId (@expr6809 ) ) ;
853: } else {
854:
855: var@var2829 .@expr6826 second@var2832 .@expr6827 status@var2833 =@expr1073748698 allocation@var2824 .@expr6815 status@var2830 ;
856: var@var2829 .@expr6826 second@var2832 .@expr6856 type@var2836 =@expr1073748702 allocation@var2824 .@expr6849 type@var2835 ;
857: var@var2829 .@expr6826 second@var2832 .@expr6846 allocTok@var2834 =@expr1073748706 allocation@var2824 .@expr1073748707 allocTok@var2837 ;
858: } } }
859: } else { if (@expr1073748708 allocation@var2824 .@expr6815 status@var2830 !=@expr1073748710 VarInfo ::@expr6817 NOALLOC &&@expr1073748712 allocation@var2824 .@expr6815 status@var2830 !=@expr1073748714 VarInfo ::@expr1073748715 OWNED &&@expr1073748716 !@expr1073748717 Token ::@expr1073748718 simpleMatch (@expr1073748719 tok@var2825 .@expr1073748720 astTop (@expr1073748721 ) , "return" ) ) {
860: alloctype@var2827 [@expr6898 arg@var2826 .@expr6808 varId (@expr6809 ) ] .@expr1073748725 status@var2944 =@expr1073748726 VarInfo ::@expr6829 DEALLOC ;
861: alloctype@var2827 [@expr6898 arg@var2826 .@expr6808 varId (@expr6809 ) ] .@expr1073748731 allocTok@var2945 =@expr1073748732 tok@var2825 ;
862: } }
863: }
864:
865: void CheckLeakAutoVar :: functionCall ( const Token * tokName@var2838 , const Token * tokOpeningPar@var2839 , VarInfo * varInfo@var2840 , const VarInfo :: AllocInfo & allocation@var2841 , const Library :: AllocFunc * af@var2842 )
866: {
867:
868: if (@expr1073748734 mSettings@var29 .@expr6911 library@var2926 .@expr1073748736 isLeakIgnore (@expr1073748737 mSettings@var29 .@expr6911 library@var2926 .@expr1073748739 getFunctionName (@expr1073748740 tokName@var2838 ) ) ) {
869: return ; }
870: if (@expr1073748741 mSettings@var29 .@expr6911 library@var2926 .@expr1073748743 getReallocFuncInfo (@expr1073748744 tokName@var2838 ) ) {
871: return ; }
872:
873: const Token * const tokFirstArg@var2843 ; tokFirstArg@var2843 =@expr1073748745 tokOpeningPar@var2839 .@expr1073748746 next (@expr1073748747 ) ;
874: if (@expr1073748748 !@expr1073748749 tokFirstArg@var2843 ||@expr1073748750 tokFirstArg@var2843 .@expr1073748751 str (@expr1073748752 ) ==@expr1073748753 ")" ) {
875:
876: return ;
877: }
878:
879: int argNr@var2844 ; argNr@var2844 =@expr1073748754 1 ;
880: for (@expr1073748755 const Token *@expr6932 funcArg@var2845 =@expr1073748757 tokFirstArg@var2843 ; funcArg@var2845 ; funcArg@var2845 =@expr1073748758 funcArg@var2845 .@expr1073748759 nextArgument (@expr1073748760 ) ) {
881: const Token * arg@var2846 ; arg@var2846 =@expr1073748761 funcArg@var2845 ;
882: if (@expr1073748762 mTokenizer@var28 .@expr1073748763 isCPP (@expr1073748764 ) ) {
883: int tokAdvance@var2847 ; tokAdvance@var2847 =@expr1073748765 0 ;
884: if (@expr1073748766 arg@var2846 .@expr6943 str (@expr6944 ) ==@expr1073748769 "new" ) {
885: tokAdvance@var2847 =@expr1073748770 1 ; }
886: else { if (@expr1073748771 Token ::@expr6948 simpleMatch (@expr1073748773 arg@var2846 , "* new" ) ) {
887: tokAdvance@var2847 =@expr1073748774 2 ; } }
888: if (@expr1073748775 tokAdvance@var2847 >@expr1073748776 0 ) {
889: arg@var2846 =@expr1073748777 arg@var2846 .@expr6954 tokAt (@expr1073748779 tokAdvance@var2847 ) ;
890: if (@expr1073748780 Token ::@expr6948 simpleMatch (@expr1073748782 arg@var2846 , "( std :: nothrow )" ) ) {
891: arg@var2846 =@expr1073748783 arg@var2846 .@expr6954 tokAt (@expr1073748785 5 ) ; }
892: }
893: }
894:
895:
896: while (@expr1073748786 arg@var2846 &&@expr1073748787 arg@var2846 .@expr1073748788 isCast (@expr1073748789 ) ) {
897: arg@var2846 =@expr1073748790 arg@var2846 .@expr6967 astOperand2 (@expr6968 ) ?@expr1073748793 arg@var2846 .@expr6967 astOperand2 (@expr6968 ) :@expr1073748796 arg@var2846 .@expr1073748797 astOperand1 (@expr1073748798 ) ; }
898: const Token * const argTypeStartTok@var2848 ; argTypeStartTok@var2848 =@expr1073748799 arg@var2846 ;
899:
900: while (@expr1073748800 Token ::@expr6977 Match (@expr1073748802 arg@var2846 , "%name% .|:: %name%" ) ) {
901: arg@var2846 =@expr1073748803 arg@var2846 .@expr6954 tokAt (@expr1073748805 2 ) ; }
902:
903: if (@expr1073748806 Token ::@expr6977 Match (@expr1073748808 arg@var2846 , "%var% [-,)] !!." ) ||@expr1073748809 Token ::@expr6977 Match (@expr1073748811 arg@var2846 , "& %var%" ) ) {
904:
905: if (@expr1073748812 arg@var2846 .@expr6943 str (@expr6944 ) ==@expr1073748815 "&" ) {
906: arg@var2846 =@expr1073748816 arg@var2846 .@expr6993 next (@expr6994 ) ; }
907:
908: const bool isnull@var2849 =@expr1073748819 arg@var2846 .@expr1073748820 hasKnownIntValue (@expr1073748821 ) &&@expr1073748822 arg@var2846 .@expr1073748823 values (@expr1073748824 ) .@expr1073748825 front (@expr1073748826 ) .@expr1073748827 intvalue@expr1073748733 ==@expr1073748828 0 ;
909:
910:
911: if (@expr1073748829 !@expr1073748830 isnull@var2849 &&@expr1073748831 (@expr1073748832 !@expr1073748833 af@var2842 ||@expr1073748834 af@var2842 .@expr1073748835 arg@var2850 ==@expr1073748836 argNr@var2844 ) ) {
912: changeAllocStatus (@expr1073748837 varInfo@var2840 , allocation@var2841 , tokName@var2838 , arg@var2846 ) ; }
913: }
914:
915: else { if (@expr1073748838 Token ::@expr6977 Match (@expr1073748840 arg@var2846 , "%name% < %type%" ) &&@expr1073748841 mSettings@var29 .@expr6911 library@var2926 .@expr1073748843 isSmartPointer (@expr1073748844 argTypeStartTok@var2848 ) ) {
916: const Token * typeEndTok@var2851 ; typeEndTok@var2851 =@expr1073748845 arg@var2846 .@expr1073748846 linkAt (@expr1073748847 1 ) ;
917: const Token * allocTok@var2852 ; allocTok@var2852 =@expr1073748848 nullptr ;
918: if (@expr1073748849 !@expr1073748850 Token ::@expr6977 Match (@expr1073748852 typeEndTok@var2851 , "> {|( %var% ,|)|}" ) ) {
919: continue ; }
920:
921: bool arrayDelete@var2853 ; arrayDelete@var2853 =@expr1073748853 false ;
922: if (@expr1073748854 Token ::@expr1073748855 findsimplematch (@expr1073748856 arg@var2846 .@expr6993 next (@expr6994 ) , "[ ]" , typeEndTok@var2851 ) ) {
923: arrayDelete@var2853 =@expr1073748859 true ; }
924:
925:
926: const Token * deleterToken@var2854 ; deleterToken@var2854 =@expr1073748860 nullptr ;
927: const Token * endDeleterToken@var2855 ; endDeleterToken@var2855 =@expr1073748861 nullptr ;
928: const Library ::@expr1073748862 AllocFunc * sp_af@var2856 ; sp_af@var2856 =@expr1073748863 nullptr ;
929: if (@expr1073748864 Token ::@expr6977 Match (@expr1073748866 arg@var2846 , "unique_ptr < %type% ," ) ) {
930: deleterToken@var2854 =@expr1073748867 arg@var2846 .@expr6954 tokAt (@expr1073748869 4 ) ;
931: endDeleterToken@var2855 =@expr1073748870 typeEndTok@var2851 ;
932: } else { if (@expr1073748871 Token ::@expr6977 Match (@expr1073748873 typeEndTok@var2851 , "> {|( %var% ," ) ) {
933: deleterToken@var2854 =@expr1073748874 typeEndTok@var2851 .@expr7051 tokAt (@expr1073748876 4 ) ;
934: endDeleterToken@var2855 =@expr1073748877 typeEndTok@var2851 .@expr1073748878 linkAt (@expr1073748879 1 ) ;
935: } }
936: if (@expr1073748880 deleterToken@var2854 ) {
937:
938: const Token * dtok@var2857 ; dtok@var2857 =@expr1073748881 Token ::@expr7058 findmatch (@expr1073748883 deleterToken@var2854 , "& %name%" , endDeleterToken@var2855 ) ;
939: if (@expr1073748884 dtok@var2857 ) {
940: sp_af@var2856 =@expr1073748885 mSettings@var29 .@expr6911 library@var2926 .@expr7063 getDeallocFuncInfo (@expr1073748888 dtok@var2857 .@expr1073748889 tokAt (@expr1073748890 1 ) ) ;
941: } else {
942:
943: dtok@var2857 =@expr1073748891 Token ::@expr7058 findmatch (@expr1073748893 deleterToken@var2854 , "%type%" , endDeleterToken@var2855 ) ;
944: if (@expr1073748894 dtok@var2857 &&@expr1073748895 dtok@var2857 .@expr7072 type (@expr7073 ) ) {
945: const Scope * tscope@var2858 ; tscope@var2858 =@expr1073748898 dtok@var2857 .@expr7072 type (@expr7073 ) .@expr1073748901 classScope@var2943 ;
946: for (@expr1073748902 const Token *@expr6932 tok2@var2859 =@expr1073748904 tscope@var2858 .@expr1073748905 bodyStart@var2860 ; tok2@var2859 !=@expr1073748906 tscope@var2858 .@expr1073748907 bodyEnd@var2861 ; tok2@var2859 =@expr1073748908 tok2@var2859 .@expr1073748909 next (@expr1073748910 ) ) {
947: sp_af@var2856 =@expr1073748911 mSettings@var29 .@expr6911 library@var2926 .@expr7063 getDeallocFuncInfo (@expr1073748914 tok2@var2859 ) ;
948: if (@expr1073748915 sp_af@var2856 ) {
949: allocTok@var2852 =@expr1073748916 tok2@var2859 ;
950: break ;
951: }
952: }
953: }
954: }
955: }
956:
957: const Token * vtok@var2862 ; vtok@var2862 =@expr1073748917 typeEndTok@var2851 .@expr7051 tokAt (@expr1073748919 2 ) ;
958: const VarInfo ::@expr1073748920 AllocInfo sp_allocation@var2863 (@expr1073748921 sp_af@var2856 ?@expr1073748922 sp_af@var2856 .@expr1073748923 groupId@var2864 :@expr1073748924 (@expr1073748925 arrayDelete@var2853 ?@expr1073748926 NEW_ARRAY@var2618 :@expr1073748927 NEW@var2619 ) , VarInfo ::@expr1073748928 OWNED , allocTok@var2852 ) ;
959: changeAllocStatus (@expr1073748929 varInfo@var2840 , sp_allocation@var2863 , vtok@var2862 , vtok@var2862 ) ;
960: } else {
961: checkTokenInsideExpression (@expr1073748930 arg@var2846 , varInfo@var2840 ) ;
962: } }
963:
964: argNr@var2844 ++@expr1073748931 ;
965: }
966: }
967:
968:
969: void CheckLeakAutoVar :: leakIfAllocated ( const Token * vartok@var2865 ,
970: const VarInfo & varInfo@var2866 )
971: {
972: const std ::@expr7108 map < int , VarInfo ::@expr7109 AllocInfo > & alloctype@var2867 =@expr1073748934 varInfo@var2866 .@expr1073748935 alloctype@var2868 ;
973: const std ::@expr7112 map < int , std ::@expr7109 string > & possibleUsage@var2869 =@expr1073748938 varInfo@var2866 .@expr1073748939 possibleUsage@var2870 ;
974:
975: const std ::@expr7108 map < int , VarInfo ::@expr7109 AllocInfo > ::@expr1073748942 const_iterator var@var2871 =@expr1073748943 alloctype@var2867 .@expr1073748944 find (@expr1073748945 vartok@var2865 .@expr7122 varId (@expr7123 ) ) ;
976: if (@expr1073748948 var@var2871 !=@expr1073748949 alloctype@var2867 .@expr1073748950 end (@expr1073748951 ) &&@expr1073748952 var@var2871 .@expr7129 second@var2872 .@expr1073748954 status@var2873 ==@expr1073748955 VarInfo ::@expr1073748956 ALLOC ) {
977: const std ::@expr7112 map < int , std ::@expr7109 string > ::@expr1073748959 const_iterator use@var2874 =@expr1073748960 possibleUsage@var2869 .@expr1073748961 find (@expr1073748962 vartok@var2865 .@expr7122 varId (@expr7123 ) ) ;
978: if (@expr1073748965 use@var2874 ==@expr1073748966 possibleUsage@var2869 .@expr1073748967 end (@expr1073748968 ) ) {
979: leakError (@expr1073748969 vartok@var2865 , vartok@var2865 .@expr1073748970 str (@expr1073748971 ) , var@var2871 .@expr7129 second@var2872 .@expr1073748973 type@var2875 ) ;
980: } else {
981: configurationInfo (@expr1073748974 vartok@var2865 , use@var2874 .@expr1073748975 second@var2876 ) ;
982: }
983: }
984: }
985:
986: void CheckLeakAutoVar :: ret ( const Token * tok@var2877 , VarInfo & varInfo@var2878 , const bool isEndOfScope@var2879 )
987: {
988: const std ::@expr1073748976 map < int , VarInfo ::@expr7153 AllocInfo > & alloctype@var2880 =@expr1073748978 varInfo@var2878 .@expr1073748979 alloctype@var2881 ;
989: const std ::@expr7156 map < int , std ::@expr7153 string > & possibleUsage@var2882 =@expr1073748982 varInfo@var2878 .@expr1073748983 possibleUsage@var2883 ;
990: std ::@expr1073748984 vector < int > toRemove@var2884 ;
991:
992: const SymbolDatabase * symbolDatabase@var2885 ; symbolDatabase@var2885 =@expr1073748985 mTokenizer@var28 .@expr1073748986 getSymbolDatabase (@expr1073748987 ) ;
993: for (@expr1073748988 std ::@expr7153 map < int , VarInfo ::@expr7153 AllocInfo > ::@expr7153 const_iterator it@var2886 =@expr1073748992 alloctype@var2880 .@expr1073748993 begin (@expr1073748994 ) ; it@var2886 !=@expr1073748995 alloctype@var2880 .@expr1073748996 end (@expr1073748997 ) ; ++@expr1073748998 it@var2886 ) {
994:
995: if (@expr1073748999 !@expr1073749000 isEndOfScope@var2879 &&@expr1073749001 !@expr7178 it@var2886 .@expr7179 second@var2887 .@expr7180 managed (@expr7181 ) &&@expr1073749006 varInfo@var2878 .@expr7183 conditionalAlloc@var2888 .@expr1073749008 find (@expr1073749009 it@var2886 .@expr7186 first@var2889 ) !=@expr1073749011 varInfo@var2878 .@expr7183 conditionalAlloc@var2888 .@expr1073749013 end (@expr1073749014 ) ) {
996: continue ; }
997:
998:
999: if (@expr1073749015 varInfo@var2878 .@expr7192 referenced@var2890 .@expr1073749017 find (@expr1073749018 it@var2886 .@expr7186 first@var2889 ) !=@expr1073749020 varInfo@var2878 .@expr7192 referenced@var2890 .@expr1073749022 end (@expr1073749023 ) ) {
1000: continue ; }
1001:
1002: const int varid@var2891 =@expr1073749024 it@var2886 .@expr7186 first@var2889 ;
1003: const Variable * var@var2892 ; var@var2892 =@expr1073749026 symbolDatabase@var2885 .@expr1073749027 getVariableFromVarId (@expr1073749028 varid@var2891 ) ;
1004: if (@expr1073749029 var@var2892 ) {
1005:
1006: if (@expr1073749030 isEndOfScope@var2879 &&@expr1073749031 var@var2892 .@expr7208 scope (@expr7209 ) &&@expr1073749034 tok@var2877 !=@expr1073749035 var@var2892 .@expr7208 scope (@expr7209 ) .@expr1073749038 bodyEnd@var2942 ) {
1007: continue ; }
1008: bool used@var2893 ; used@var2893 =@expr1073749039 false ;
1009: for (@expr1073749040 const Token *@expr1073749041 tok2@var2894 =@expr1073749042 tok@var2877 ; tok2@var2894 ; tok2@var2894 =@expr1073749043 tok2@var2894 .@expr7220 next (@expr7221 ) ) {
1010: if (@expr1073749046 tok2@var2894 .@expr1073749047 str (@expr1073749048 ) ==@expr1073749049 ";" ) {
1011: break ; }
1012: if (@expr1073749050 !@expr1073749051 Token ::@expr7228 Match (@expr1073749053 tok2@var2894 , "return|(|{|," ) ) {
1013: continue ; }
1014:
1015: const Token * tok3@var2895 ; tok3@var2895 =@expr1073749054 tok2@var2894 .@expr7220 next (@expr7221 ) ;
1016: while (@expr1073749057 tok3@var2895 &&@expr1073749058 tok3@var2895 .@expr1073749059 isCast (@expr1073749060 ) &&@expr1073749061 tok3@var2895 .@expr7238 valueType (@expr7239 ) &&@expr1073749064
1017: (@expr1073749065 tok3@var2895 .@expr7238 valueType (@expr7239 ) .@expr1073749068 pointer@var2946 ||@expr1073749069
1018: (@expr1073749070 tok3@var2895 .@expr7238 valueType (@expr7239 ) .@expr7249 typeSize (@expr7250 *@expr7251 mSettings@var29 ) ==@expr1073749076 0 ) ||@expr1073749077
1019: (@expr1073749078 tok3@var2895 .@expr7238 valueType (@expr7239 ) .@expr7249 typeSize (@expr7250 *@expr7251 mSettings@var29 ) >=@expr1073749084 mSettings@var29 .@expr1073749085 sizeof_pointer@var2927 ) ) ) {
1020: tok3@var2895 =@expr1073749086 tok3@var2895 .@expr7263 astOperand2 (@expr7264 ) ?@expr1073749089 tok3@var2895 .@expr7263 astOperand2 (@expr7264 ) :@expr1073749092 tok3@var2895 .@expr1073749093 astOperand1 (@expr1073749094 ) ; }
1021: if (@expr1073749095 Token ::@expr7228 Match (@expr1073749097 tok3@var2895 , "%varid%" , varid@var2891 ) ) {
1022: tok2@var2894 =@expr1073749098 tok3@var2895 .@expr1073749099 next (@expr1073749100 ) ; }
1023: else { if (@expr1073749101 Token ::@expr7228 Match (@expr1073749103 tok3@var2895 , "& %varid% . %name%" , varid@var2891 ) ) {
1024: tok2@var2894 =@expr1073749104 tok3@var2895 .@expr1073749105 tokAt (@expr1073749106 4 ) ; }
1025: else {
1026: continue ; } }
1027: if (@expr1073749107 Token ::@expr7228 Match (@expr1073749109 tok2@var2894 , "[});,+]" ) ) {
1028: used@var2893 =@expr1073749110 true ;
1029: break ;
1030: }
1031: }
1032:
1033:
1034: if (@expr1073749111 used@var2893 &&@expr1073749112 it@var2886 .@expr7179 second@var2887 .@expr1073749114 status@var2896 ==@expr1073749115 VarInfo ::@expr1073749116 DEALLOC ) {
1035: deallocReturnError (@expr1073749117 tok@var2877 , it@var2886 .@expr7179 second@var2887 .@expr1073749119 allocTok@var2897 , var@var2892 .@expr7296 name (@expr7297 ) ) ; }
1036:
1037: else { if (@expr1073749122 !@expr1073749123 used@var2893 &&@expr1073749124 !@expr7178 it@var2886 .@expr7179 second@var2887 .@expr7180 managed (@expr7181 ) ) {
1038: const std ::@expr7156 map < int , std ::@expr7153 string > ::@expr1073749131 const_iterator use@var2898 =@expr1073749132 possibleUsage@var2882 .@expr1073749133 find (@expr1073749134 varid@var2891 ) ;
1039: if (@expr1073749135 use@var2898 ==@expr1073749136 possibleUsage@var2882 .@expr1073749137 end (@expr1073749138 ) ) {
1040: leakError (@expr1073749139 tok@var2877 , var@var2892 .@expr7296 name (@expr7297 ) , it@var2886 .@expr7179 second@var2887 .@expr1073749143 type@var2899 ) ;
1041: } else {
1042: configurationInfo (@expr1073749144 tok@var2877 , use@var2898 .@expr1073749145 second@var2900 ) ;
1043: }
1044: } }
1045: toRemove@var2884 .@expr1073749146 push_back (@expr1073749147 varid@var2891 ) ;
1046: }
1047: }
1048: for (@expr1073749148 int varId@var2901 :@expr1073749149 toRemove@var2884 ) {
1049: varInfo@var2878 .@expr1073749150 erase (@expr1073749151 varId@var2901 ) ; }
1050: }

##file cppcheck-2.8/lib/settings.h

1:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2902 ; mFlags@var2902 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2902 ;
54: }
55: void clear ( ) {
56: mFlags@var2902 =@expr1073749152 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2902 =@expr1073749153 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2903 ) {
62: if (@expr1073749154 enabled@var2903 ) {
63: fill (@expr1073749155 ) ; }
64: else {
65: clear (@expr1073749156 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2904 ) const {
68: return (@expr7333 mFlags@var2902 &@expr1073749158 (@expr7333 1U <<@expr1073749160 (@expr1073749161 uint32_t ) flag@var2904 ) ) !=@expr1073749162 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2905 ) {
71: mFlags@var2902 |=@expr1073749163 (@expr1073749164 1U <<@expr1073749165 (@expr1073749166 uint32_t ) flag@var2905 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2906 ) {
74: mFlags@var2902 &=@expr1073749167 ~@expr1073749168 (@expr1073749169 1U <<@expr1073749170 (@expr1073749171 uint32_t ) flag@var2906 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2907 , bool enabled@var2908 ) {
77: if (@expr1073749172 enabled@var2908 ) {
78: enable (@expr1073749173 flag@var2907 ) ; }
79: else {
80: disable (@expr1073749174 flag@var2907 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2909 ; mFlags@var2909 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2909 ;
54: }
55: void clear ( ) {
56: mFlags@var2909 =@expr1073749175 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2909 =@expr1073749176 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2910 ) {
62: if (@expr1073749177 enabled@var2910 ) {
63: fill (@expr1073749178 ) ; }
64: else {
65: clear (@expr1073749179 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2911 ) const {
68: return (@expr7356 mFlags@var2909 &@expr1073749181 (@expr7356 1U <<@expr1073749183 (@expr1073749184 uint32_t ) flag@var2911 ) ) !=@expr1073749185 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2912 ) {
71: mFlags@var2909 |=@expr1073749186 (@expr1073749187 1U <<@expr1073749188 (@expr1073749189 uint32_t ) flag@var2912 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2913 ) {
74: mFlags@var2909 &=@expr1073749190 ~@expr1073749191 (@expr1073749192 1U <<@expr1073749193 (@expr1073749194 uint32_t ) flag@var2913 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2914 , bool enabled@var2915 ) {
77: if (@expr1073749195 enabled@var2915 ) {
78: enable (@expr1073749196 flag@var2914 ) ; }
79: else {
80: disable (@expr1073749197 flag@var2914 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2916 ; mFlags@var2916 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2916 ;
54: }
55: void clear ( ) {
56: mFlags@var2916 =@expr1073749198 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2916 =@expr1073749199 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2917 ) {
62: if (@expr1073749200 enabled@var2917 ) {
63: fill (@expr1073749201 ) ; }
64: else {
65: clear (@expr1073749202 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2918 ) const {
68: return (@expr7379 mFlags@var2916 &@expr1073749204 (@expr7379 1U <<@expr1073749206 (@expr1073749207 uint32_t ) flag@var2918 ) ) !=@expr1073749208 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2919 ) {
71: mFlags@var2916 |=@expr1073749209 (@expr1073749210 1U <<@expr1073749211 (@expr1073749212 uint32_t ) flag@var2919 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2920 ) {
74: mFlags@var2916 &=@expr1073749213 ~@expr1073749214 (@expr1073749215 1U <<@expr1073749216 (@expr1073749217 uint32_t ) flag@var2920 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2921 , bool enabled@var2922 ) {
77: if (@expr1073749218 enabled@var2922 ) {
78: enable (@expr1073749219 flag@var2921 ) ; }
79: else {
80: disable (@expr1073749220 flag@var2921 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  severity possible 6@73
  id possible "checkLibraryUseIgnore"@73
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@58736,34@58992}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@229,34@230}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@229,""@230,""@231,"U"@232,"U"@233,"u"@234,"u"@235,"u8"@236,"u8"@237}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@109,34@110}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@106,34@108}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  id inconclusive 0@24903
  > {!<=-1,!>=2,0}
  0 always 0
  && {!<=-1,!>=2,0}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 42
  REALLOC always -3
  = always -3
  -3 always -3
  , always -2
  OWNED always -2
  = always -2
  -2 always -2
  , always -1
  DEALLOC always -1
  = always -1
  -1 always -1
  , always 0
  NOALLOC always 0
  = always 0
  0 always 0
  , always 1
  ALLOC always 1
  = always 1
  1 always 1
Line 50
  = always -1
  -1 always -1
Line 52
  = always 0
  0 always 0
  = always 0
  NOALLOC always 0
  = always 0
  nullptr always 0
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 71
  varid possible symbolic=(rhs->varId())@100
Line 72
  varid inconclusive symbolic=(rhs->varId())@100
Line 73
  varid inconclusive symbolic=(rhs->varId())@100
Line 74
  varid inconclusive symbolic=(rhs->varId())@100
Line 86
  alloc always symbolic=(alloctype[varid])
  >= always {!<=-1,!>=2}
  0 always 0
Line 87
  :: possible {symbolic=(alloctype.end()),end=0}
  it possible {symbolic=(alloctype.end()),end=0}
  = possible lifetime[Iterator]=(alloctype)
  ( possible lifetime[Iterator]=(alloctype)
  alloc always symbolic=(alloctype[varid])
  . {>=0,!<=-1}
Line 88
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(alloctype),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(alloctype.end()),!end=0}
  == always {!<=-1,!>=2}
  REALLOC always -3
Line 89
  it always {!symbolic=(alloctype.end()),!end=0}
  = always 1
  ALLOC always 1
Line 111
  ( always "Leaks (auto variables)"
Line 115
  ( always "Leaks (auto variables)"
Line 150
  , always 0
  = always 0
  false always 0
Line 165
  nullptr always 0
Line 166
  nullptr always 0
  nullptr always 0
  "p" always "p"
Line 167
  nullptr always 0
  "f" always "f"
Line 168
  nullptr always 0
  nullptr always 0
  "varname" always "varname"
  0 always 0
Line 172
  "Leaks (auto variables)" always "Leaks (auto variables)"
Line 176
  "Detect when a auto variable is allocated but not deallocated or deallocated twice.\n" always "Detect when a auto variable is allocated but not deallocated or deallocated twice.\n"
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@63,128@64,64@65,32@66,16@67,8@68,4@69,2@70,1@71}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@72,128@73,64@74,32@75,16@76,8@77,4@78,2@79,1@80}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@72,4294967167@73,4294967231@74,4294967263@75,4294967279@76,4294967287@77,4294967291@78,4294967293@79,4294967294@80}
  flag {!<=-1,256@72,128@73,64@74,32@75,16@76,8@77,4@78,2@79,1@80}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {-2@89,2@108,1@35}
Line 246
  ( always !0
  this always !0
  index possible 1@32
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(funcArg)@44,symbolic=(tok->next()->astOperand2())@201,symbolic=(ftok->next()->link())@12}
  pattern possible {"* new"@44,"( std :: nothrow )"@45,"return"@74,"= &"@88,"if ("@169,") {"@198,","@201,"} else {"@232,") {"@241,"do {"@242}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@218,4@219,0@220}
  t possible {10@218,4@219,0@220}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@218,4@219,0@220}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@218,0@220}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@218,0@220}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@218}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@218}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@218}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@218}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@218}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"*"@123,"&"@125}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@226}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible {"[ ]"@54,"[ ]"@23}
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@228,17179869184@239,8589934592@241,34359738368@243,4294967296@245,2147483648@247,1073741824@249,536870912@251,268435456@253}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@59,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@60}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@227,17179869184@238,8589934592@240,34359738368@242,4294967296@244,2147483648@246,1073741824@248,536870912@250,268435456@252}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@227,17179869184@238,8589934592@240,34359738368@242,4294967296@244,2147483648@246,1073741824@248,536870912@250,268435456@252}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@161,4096@164,16384@167,2048@168,1024@169,65536@170,512@171,256@172,128@173}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@126,4194304@128,8388608@129,2097152@131,1048576@132,524288@133,262144@134,131072@135,65536@136}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@104,2097152@105,1048576@106,524288@107,262144@108,131072@109,65536@110,32768@111,16384@112}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@104,4292870143@105,4293918719@106,4294443007@107,4294705151@108,4294836223@109,4294901759@110,4294934527@111,4294950911@112}
  flag {!<=-1,8388608@104,2097152@105,1048576@106,524288@107,262144@108,131072@109,65536@110,32768@111,16384@112}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1396
  varId possible symbolic=(it->first)@14
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
  ast possible symbolic=(tok->next()->astOperand2())@203
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 91
  , inconclusive lifetime[SubObject]=(e)
  ( inconclusive lifetime[SubObject]=(e)
Line 94
  No always 0
  Malloc always 1
  New always 2
  NewArray always 3
  File always 4
  Fd always 5
  Pipe always 6
  OtherMem always 7
  OtherRes always 8
  Many always 9
Line 109
  , always 0
  = always 0
  nullptr always 0
Line 120
  ( always {!<=-1,!>=2}
Line 147
  , always 0
  = always 0
  nullptr always 0
Line 171
  ( always "Memory leaks (function variables)"
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 175
  ( possible lifetime[SubObject]=(tokenizer)
  ( always "Memory leaks (function variables)"
Line 183
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 193
  nullptr always 0
Line 195
  nullptr always 0
  "varname" always "varname"
Line 196
  nullptr always 0
  "varname" always "varname"
Line 198
  nullptr always 0
  "varname" always "varname"
Line 199
  nullptr always 0
  "varname" always "varname"
Line 200
  nullptr always 0
  "sz" always "sz"
Line 202
  callstack always size=0
  "varname" always "varname"
Line 203
  nullptr always 0
  "realloc" always "realloc"
  "varname" always "varname"
Line 211
  "Memory leaks (function variables)" always "Memory leaks (function variables)"
Line 219
  "Is there any allocated memory when a function goes out of scope\n" always "Is there any allocated memory when a function goes out of scope\n"
Line 231
  ( always "Memory leaks (class variables)"
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 234
  ( possible lifetime[SubObject]=(tokenizer)
  ( always "Memory leaks (class variables)"
Line 237
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 256
  nullptr always 0
Line 257
  nullptr always 0
  "varname" always "varname"
Line 258
  nullptr always 0
  "class" always "class"
  "class::varname" always "class::varname"
Line 262
  "Memory leaks (class variables)" always "Memory leaks (class variables)"
Line 266
  "If the constructor allocate memory then the destructor must deallocate it.\n" always "If the constructor allocate memory then the destructor must deallocate it.\n"
Line 276
  ( always "Memory leaks (struct members)"
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 279
  ( possible lifetime[SubObject]=(tokenizer)
  ( always "Memory leaks (struct members)"
Line 291
  ( always {!<=-1,!>=2}
Line 298
  "Memory leaks (struct members)" always "Memory leaks (struct members)"
Line 302
  "Don't forget to deallocate struct members\n" always "Don't forget to deallocate struct members\n"
Line 312
  ( always "Memory leaks (address not taken)"
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 315
  ( possible lifetime[SubObject]=(tokenizer)
  ( always "Memory leaks (address not taken)"
Line 349
  nullptr always 0
Line 351
  nullptr always 0
  "funcName" always "funcName"
  "funcName" always "funcName"
Line 352
  nullptr always 0
  "funcName" always "funcName"
Line 353
  nullptr always 0
  "funcName" always "funcName"
  "shared_ptr" always "shared_ptr"
  "int" always "int"
Line 357
  "Memory leaks (address not taken)" always "Memory leaks (address not taken)"
Line 361
  "Not taking the address to allocated memory\n" always "Not taking the address to allocated memory\n"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 54
  null always 0
  uninit always 1
  bufferOverflow always 2
Line 63
  { always 0
Line 64
  { always 0
Line 71
  { always 0
Line 74
  { always 0
Line 87
  { always 0
Line 92
  ( always {!<=-1,!>=2}
Line 101
  warning always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 122
  { always 0
Line 136
  warning always {!<=-1,!>=2}
Line 148
  ( always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
Line 52
  ( always "Null pointer"
Line 56
  ( always "Null pointer"
Line 85
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 96
  0 always 0
Line 98
  "" always ""
  & {lifetime[Address]=(v),!0}
  false always 0
Line 100
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 123
  nullptr always 0
Line 124
  nullptr always 0
  "pointer" always "pointer"
  nullptr always 0
  false always 0
Line 125
  nullptr always 0
  nullptr always 0
  false always 0
Line 126
  nullptr always 0
  nullptr always 0
  nullptr always 0
  false always 0
Line 131
  "Null pointer" always "Null pointer"
Line 136
  "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n" always "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
Line 149
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 150
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 48
  672U always 672
Line 49
  415U always 415
Line 52
  NEW_ARRAY always -2
  = always -2
  -2 always -2
Line 53
  NEW always -1
  = always -1
  -1 always -1
Line 55
  "==" always "=="
  "0" always "0"
  "<" always "<"
  "0" always "0"
  "==" always "=="
  "-1" always "-1"
  "<=" always "<="
  "-1" always "-1"
Line 56
  "!=" always "!="
  "0" always "0"
  ">" always ">"
  "0" always "0"
  "!=" always "!="
  "-1" always "-1"
  ">=" always ">="
  "0" always "0"
Line 63
  ( always {!<=-1,!>=2}
Line 65
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 3
  RECORD always 3
  && always {!<=-1,!>=2}
  ( always !0
  . always !3
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 66
  return always {!<=-1,!>=2}
  false always 0
Line 72
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 73
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  false always 0
Line 77
  return always {!<=-1,!>=2}
  true always 1
Line 80
  ( always {!<=-1,!>=2}
Line 84
  vartok possible {lifetime[Address]=(vartok)@212,lifetime[Address]=(vartok)@213,lifetime[Address]=(vartok)@218,lifetime[Address]=(vartok)@225}
Line 85
  return always {!<=-1,!>=2}
  true always 1
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 94
  "size=" always "size="
  ( always !<=-1
Line 95
  = {lifetime[Iterator]=(alloctype),start=0}
  ( {lifetime[Iterator]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(alloctype),end=0}
Line 97
  :: possible {symbolic=(possibleUsage.end()),end=0}
  use possible {symbolic=(possibleUsage.end()),end=0}
  = possible lifetime[Iterator]=(possibleUsage)
Line 98
  ( possible lifetime[Iterator]=(possibleUsage)
  it possible lifetime[Iterator]=(alloctype)
Line 99
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(possibleUsage),end=0}
Line 100
  use always {!symbolic=(possibleUsage.end()),!end=0}
Line 104
  OWNED always -2
Line 105
  = always "owned"
  "owned" always "owned"
Line 107
  DEALLOC always -1
Line 108
  = always "dealloc"
  "dealloc" always "dealloc"
Line 110
  ALLOC always 1
Line 111
  = always "alloc"
  "alloc" always "alloc"
Line 113
  NOALLOC always 0
Line 114
  = always "noalloc"
  "noalloc" always "noalloc"
Line 116
  REALLOC always -3
Line 117
  = always "realloc"
  "realloc" always "realloc"
Line 120
  = always "?"
  "?" always "?"
Line 124
  "status=" always "status="
  status possible {"owned",size=5,"dealloc",size=7,"alloc","noalloc","realloc","?",size=1}
  " " always " "
Line 125
  "alloctype='" always "alloctype='"
  "' " always "' "
Line 126
  "possibleUsage='" always "possibleUsage='"
  "' " always "' "
Line 127
  "conditionalAlloc=" always "conditionalAlloc="
  ( possible lifetime[Iterator]=(conditionalAlloc)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(conditionalAlloc),end=0}
  "yes" always "yes"
  : always "no"
  "no" always "no"
  " " always " "
Line 128
  "referenced=" always "referenced="
  ( possible lifetime[Iterator]=(referenced)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(referenced),end=0}
  "yes" always "yes"
  : always "no"
  "no" always "no"
  " " always " "
Line 129
  "reallocedFrom=" always "reallocedFrom="
Line 137
  = {lifetime[Iterator]=(alloctype),start=0}
  ( {lifetime[Iterator]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(alloctype),end=0}
  it possible lifetime[Iterator]=(alloctype)
Line 138
  it {lifetime[Iterator]=(alloctype),!symbolic=(alloctype.end()),!end=0}
Line 145
  ( always {!<=-1,!>=2}
Line 155
  callstack always {{,size=2}
Line 166
  deallocTok possible 0@95
  tok inconclusive 0@95
Line 167
  locations always {{,size=2}
  :: always 1
  error always 1
  "deallocret" always "deallocret"
  "$symbol:" always "$symbol:"
  varname inconclusive "p"@95
  "\nReturning/dereferencing '$symbol' after it is deallocated / released" always "\nReturning/dereferencing '$symbol' after it is deallocated / released"
  :: always 0
  normal always 0
Line 172
  . always {!<=-1,!>=2}
  checkLibrary always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 6
  information always 6
Line 174
  :: always 6
  information always 6
Line 175
  "checkLibraryUseIgnore" always "checkLibraryUseIgnore"
Line 176
  "--check-library: Function " always "--check-library: Function "
  "() should have <use>/<leak-ignore> configuration" always "() should have <use>/<leak-ignore> configuration"
Line 182
  prevFreeTok possible 0@97
  tok inconclusive 0@97
Line 184
  ( always {!<=-1,!>=2}
  type inconclusive 0@97
Line 185
  locations always {{,size=2}
  :: always 1
  error always 1
  "doubleFree" always "doubleFree"
  "$symbol:" always "$symbol:"
  "\nResource handle '$symbol' freed twice." always "\nResource handle '$symbol' freed twice."
  :: always 0
  normal always 0
Line 187
  locations always {{,size=2}
  :: always 1
  error always 1
  "doubleFree" always "doubleFree"
  "$symbol:" always "$symbol:"
  varname inconclusive "varname"@97
  "\nMemory pointed to by '$symbol' is freed twice." always "\nMemory pointed to by '$symbol' is freed twice."
  :: always 0
  normal always 0
Line 193
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
Line 202
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 203
  ( always {!<=-1,!>=2}
Line 209
  & {lifetime[Address]=(varInfo),!0}
  notzero always size=0
  0 always 0
Line 213
  ( always {!<=-1,!>=2}
Line 215
  ! {!<=-1,!>=2,1@147}
  tok possible {symbolic=(tokAssignOp->astOperand2())@147,0@147}
Line 216
  return always {!<=-1,!>=2}
  false always 0
Line 217
  tok always !0
  == always {!<=-1,!>=2}
Line 218
  return always {!<=-1,!>=2}
  true always 1
Line 219
  tok always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "sizeof" always "sizeof"
Line 220
  return always {!<=-1,!>=2}
  false always 0
Line 221
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  varid always !symbolic=(tok->varId())
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  varid always !symbolic=(tok->varId())
Line 224
  ( always {!<=-1,!>=2}
Line 226
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 227
  != always {!<=-1,!>=2}
  varid possible symbolic=(typeEndTok->next()->varId())@22
Line 229
  ( always {!<=-1,!>=2}
  "%var% . release ( )" always "%var% . release ( )"
Line 230
  return always {!<=-1,!>=2}
  true always 1
Line 231
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
Line 232
  return always {!<=-1,!>=2}
  false always 0
Line 234
  return always {!<=-1,!>=2}
  false always 0
Line 237
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 241
  ! always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
Line 242
  return always {!<=-1,!>=2}
  true always 1
Line 243
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 244
  return always {!<=-1,!>=2}
  false always 0
Line 247
  var always !0
  ( always {!<=-1,!>=2}
Line 248
  return always {!<=-1,!>=2}
  false always 0
Line 251
  isCpp always {!<=-1,!>=2}
Line 253
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% = new" always "%var% = new"
Line 254
  return always {!<=-1,!>=2}
  false always 0
Line 255
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 256
  return always {!<=-1,!>=2}
  false always 0
Line 258
  return always {!<=-1,!>=2}
  true always 1
Line 271
  ( always {!<=-1,!>=2}
Line 274
  && always {!<=-1,!>=2}
  nameToken always !0
  && always {!<=-1,!>=2}
  nameToken always !0
  == always {!<=-1,!>=2}
  "<" always "<"
Line 276
  nameToken always !0
  ( always !0
Line 279
  && always {!<=-1,!>=2}
  nameToken always !0
  && always {!<=-1,!>=2}
  nameToken always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 281
  nameToken always !0
Line 284
  nullptr always 0
Line 295
  recursiveLimit always 1000
  = always 1000
  1000 always 1000
Line 297
  ++ possible 1@70
  recursiveCount possible 0@70
  > {!<=-1,!>=2,0}
  recursiveLimit always 1000
Line 298
  ( inconclusive lifetime[SubObject]=(startToken)
  "Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached." always "Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached."
  :: always 4
  LIMIT always 4
Line 300
  varInfo possible {lifetime[Address]=(varInfo1)@230,lifetime[Address]=(varInfo2)@233,lifetime[Address]=(varInfo)@70}
Line 301
  varInfo possible {lifetime[Address]=(varInfo1)@230,lifetime[Address]=(varInfo2)@233,lifetime[Address]=(varInfo)@70}
Line 302
  varInfo possible {lifetime[Address]=(varInfo1)@230,lifetime[Address]=(varInfo2)@233,lifetime[Address]=(varInfo)@70}
Line 306
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  endToken always symbolic=(startToken->link())
Line 307
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 309
  ! always {!<=-1,!>=2}
Line 315
  varInfo possible lifetime[Address]=(varInfo)@70
Line 317
  = always !0
  nextTok always !0
Line 324
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{},]" always "[;{},]"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{},]" always "[;{},]"
Line 328
  ! always {!<=-1,!>=2}
  tok possible symbolic=(endToken)
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 331
  ( always {!<=-1,!>=2}
  tok always {!symbolic=(endToken),!0}
  "const %type%" always "const %type%"
Line 332
  tok always {!symbolic=(endToken),!0}
  2 always 2
Line 334
  == always {!<=-1,!>=2}
  "(" always "("
Line 336
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 341
  ( always {!<=-1,!>=2}
  varTok possible symbolic=(tok)
  "%name% ::|. %name% !!(" always "%name% ::|. %name% !!("
Line 342
  2 always 2
Line 344
  = possible symbolic=(varTok)
  tok possible symbolic=(varTok)
Line 345
  ftok {symbolic=(tok),symbolic=(varTok)}
  == always {!<=-1,!>=2}
  "::" always "::"
Line 346
  ftok always symbolic=(tok)
Line 347
  ( always {!<=-1,!>=2}
  ftok possible symbolic=(tok)
  "%name% :: %name%" always "%name% :: %name%"
Line 348
  2 always 2
Line 353
  top possible symbolic=(varTok)
Line 354
  = always !0
  ( always !0
Line 355
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always !0
  "(|*|&|." always "(|*|&|."
Line 358
  top possible symbolic=(varTok)
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 361
  nullptr always 0
Line 368
  ( always {!<=-1,!>=2}
  tokAssignOp always !0
  "= %var% [+;]" always "= %var% [+;]"
Line 369
  2 always 2
  != always {!<=-1,!>=2}
Line 375
  == always {!<=-1,!>=2}
  ";" always ";"
Line 379
  ( always !0
Line 386
  tokAssignOp always !0
Line 387
  tokRightAstOperand possible symbolic=(tokAssignOp->astOperand2())
  && always {!<=-1,!>=2}
  tokRightAstOperand {symbolic=(tokAssignOp->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 388
  tokRightAstOperand always !0
  tokRightAstOperand always !0
  ( always !0
  : always 1
  tokRightAstOperand always !0
Line 391
  ( always {!<=-1,!>=2}
  tokRightAstOperand possible {symbolic=(tokAssignOp->astOperand2()),0}
Line 395
  ( possible lifetime[Iterator]=(conditionalAlloc)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(conditionalAlloc),end=0}
Line 399
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
Line 403
  = possible 0
  ? possible 0
  tokRightAstOperand always !0
  : always 0
  nullptr always 0
Line 404
  ( always {!<=-1,!>=2}
  fTok {symbolic=(tokRightAstOperand?tokRightAstOperand->previous():nullptr),0}
  "%type% (" always "%type% ("
Line 405
  fTok always symbolic=(tokRightAstOperand?tokRightAstOperand->previous():nullptr)
Line 406
  && always {!<=-1,!>=2}
  f always !0
  == always {!<=-1,!>=2}
  -1 always -1
Line 408
  varAlloc always {symbolic=(alloctype[varTok->varId()]),symbolic=(varAlloc)}
  f always !0
Line 409
  = always 1
  :: always 1
  ALLOC always 1
Line 413
  fTok inconclusive symbolic=(tokRightAstOperand?tokRightAstOperand->previous():nullptr)
Line 414
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "new !!(" always "new !!("
Line 415
  2 always 2
Line 416
  arrayNew always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 418
  varAlloc always {symbolic=(alloctype[varTok->varId()]),symbolic=(varAlloc)}
  = possible {-2,-1}
  arrayNew {symbolic=(tok2&&(tok2->str()=="["||(tok2->str()=="("&&tok2->astOperand1()&&tok2->astOperand1()->str()=="["))),!<=-1,!>=2}
  ? possible {-2,-1}
  NEW_ARRAY always -2
  : always -1
  NEW always -1
Line 419
  = always 1
  :: always 1
  ALLOC always 1
Line 420
  2 always 2
Line 425
  ( always {!<=-1,!>=2}
  2 always 2
  "%num% ;" always "%num% ;"
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  0 always 0
Line 427
  ( always {!<=-1,!>=2}
  2 always 2
  "- %type% ;" always "- %type% ;"
  && always {!<=-1,!>=2}
  3 always 3
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 437
  1 always 1
Line 438
  2 always 2
  && always {!<=-1,!>=2}
  innerTok always !0
  != always {!<=-1,!>=2}
  innerTok possible symbolic=(openingPar->link())
Line 441
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
Line 444
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 447
  ( always symbolic=(innerTok->astParent())
Line 448
  tokRightAstOperand possible {symbolic=(innerTok->next()->astOperand2()),0}
  && always {!<=-1,!>=2}
  tokRightAstOperand {symbolic=(innerTok->next()->astOperand2()),!0}
  ( always {!<=-1,!>=2}
Line 449
  tokRightAstOperand always !0
  tokRightAstOperand always !0
  ( always !0
  : always 1
  tokRightAstOperand always !0
Line 450
  tokRightAstOperand possible {symbolic=(innerTok->next()->astOperand2()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tokRightAstOperand always !0
  "%type% (" always "%type% ("
Line 451
  tokRightAstOperand always !0
Line 452
  && always {!<=-1,!>=2}
  f always !0
  == always {!<=-1,!>=2}
  -1 always -1
Line 454
  varAlloc always {symbolic=(alloctype[innerTok->varId()]),symbolic=(varAlloc)}
  f always !0
Line 455
  = always 1
  :: always 1
  ALLOC always 1
Line 456
  tokRightAstOperand always !0
Line 462
  2 always 2
Line 463
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "new !!(" always "new !!("
Line 464
  2 always 2
Line 465
  arrayNew always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  tok2 always !0
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 467
  varAlloc always {symbolic=(alloctype[innerTok->varId()]),symbolic=(varAlloc)}
  = possible {-2,-1}
  arrayNew {symbolic=(tok2&&(tok2->str()=="["||(tok2->str()=="("&&tok2->astOperand1()&&tok2->astOperand1()->str()=="["))),!<=-1,!>=2}
  ? possible {-2,-1}
  NEW_ARRAY always -2
  : always -1
  NEW always -1
Line 468
  = always 1
  :: always 1
  ALLOC always 1
Line 469
  2 always 2
Line 477
  0 always 0
  :: always 0
  NOALLOC always 0
Line 478
  openingPar always !0
  nullptr always 0
Line 479
  openingPar always !0
Line 483
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 489
  ( always {!<=-1,!>=2}
  astOperand2AfterCommas possible symbolic=(tok->next()->astOperand2())
  "," always ","
Line 493
  astOperand2AfterCommas possible symbolic=(tok->next()->astOperand2())
  [ possible {lifetime[Lambda]=(varInfo1),lifetime[Lambda]=(notzero)}
Line 494
  ! always {!<=-1,!>=2}
Line 495
  :: always 0
  none always 0
Line 496
  tok3 always !0
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "&&" always "&&"
  || always {!<=-1,!>=2}
  tok3 always !0
  == always {!<=-1,!>=2}
  "||" always "||"
Line 498
  :: always 3
  op1_and_op2 always 3
Line 500
  tok3 always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  "UNLIKELY|LIKELY" always "UNLIKELY|LIKELY"
Line 501
  :: always 2
  op2 always 2
Line 502
  tok3 always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  "%name%" always "%name%"
Line 503
  tok3 always !0
Line 505
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 507
  = always 0
  nullptr always 0
Line 508
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  vartok always 0
  || always {!<=-1,!>=2}
Line 509
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
Line 514
  :: always 0
  none always 0
Line 517
  = always 0
  nullptr always 0
Line 518
  ( always {!<=-1,!>=2}
  tok3 always !0
  & {lifetime[Address]=(vartok),!0}
  vartok always 0
Line 521
  tok3 always !0
  "!=" always "!="
  "0" always "0"
  & {lifetime[Address]=(vartok),!0}
  && always {!<=-1,!>=2}
Line 522
  ( possible lifetime[Iterator]=(notzero)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(notzero),end=0}
Line 523
  varInfo2 always NonMovedVariable
Line 524
  ( always {!<=-1,!>=2}
  tok3 always !0
  & {lifetime[Address]=(vartok),!0}
Line 528
  :: always 0
  none always 0
Line 531
  & {lifetime[Address]=(varInfo1),!0}
Line 532
  1 always 1
Line 533
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 534
  2 always 2
  & {lifetime[Address]=(varInfo2),!0}
Line 535
  2 always 2
Line 545
  = {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),end=0}
Line 546
  it {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),!symbolic=(old.alloctype.end()),!end=0}
Line 547
  ( possible {lifetime[Iterator]=(old.conditionalAlloc),lifetime[Object]=(conditionalAlloc)}
  varId always symbolic=(it->first)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(old.conditionalAlloc),lifetime[Object]=(conditionalAlloc),end=0}
Line 549
  ( possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),end=0}
  || always {!<=-1,!>=2}
Line 550
  ( possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),end=0}
Line 557
  = {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),end=0}
Line 558
  ( possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype)}
  it possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),end=0}
  && always {!<=-1,!>=2}
Line 559
  ( possible {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),end=0}
Line 565
  = {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),end=0}
Line 566
  ( possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype)}
  it possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),end=0}
  && always {!<=-1,!>=2}
Line 567
  ( possible {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype)}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(old.alloctype),lifetime[Object]=(alloctype),end=0}
Line 573
  = {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),end=0}
Line 574
  it possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype)}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(conditionalAlloc)
  it possible {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(conditionalAlloc),end=0}
Line 579
  = {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),end=0}
Line 580
  it possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype)}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(conditionalAlloc)
  it possible {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(conditionalAlloc),end=0}
Line 586
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo1.alloctype),lifetime[Object]=(alloctype),end=0}
Line 587
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo2.alloctype),lifetime[Object]=(alloctype),end=0}
Line 589
  ( {lifetime[Iterator]=(varInfo1.possibleUsage),lifetime[Object]=(possibleUsage),start=0}
  ( {lifetime[Iterator]=(varInfo1.possibleUsage),lifetime[Object]=(possibleUsage),end=0}
Line 590
  ( {lifetime[Iterator]=(varInfo2.possibleUsage),lifetime[Object]=(possibleUsage),start=0}
  ( {lifetime[Iterator]=(varInfo2.possibleUsage),lifetime[Object]=(possibleUsage),end=0}
Line 595
  ( always {!<=-1,!>=2}
  "%type% (" always "%type% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 601
  ( possible {size=5,size=6,size=4}
  == {!<=-1,!>=2,0}
  "return" always "return"
Line 607
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "throw" always "throw"
Line 608
  tryFound always {!<=-1,!>=2}
  tryFound always {!<=-1,!>=2}
  = always 0
  false always 0
Line 610
  scope possible symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
Line 611
  scope always !0
  == always {!<=-1,!>=2}
  :: always 13
  eTry always 13
Line 612
  tryFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 613
  scope always !0
Line 616
  ! {!<=-1,!>=2,1}
  tryFound {!<=-1,!>=2,0}
Line 622
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "delete" always "delete"
Line 624
  arrayDelete always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(delTok)
  "[ ]" always "[ ]"
Line 625
  arrayDelete {!<=-1,!>=2,0}
Line 626
  tok always symbolic=(delTok)
  3 always 3
Line 628
  tok always symbolic=(delTok)
Line 629
  == always {!<=-1,!>=2}
  "(" always "("
Line 631
  ( always {!<=-1,!>=2}
  "%name% ::|." always "%name% ::|."
Line 632
  2 always 2
Line 633
  isnull always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 634
  ! always {!<=-1,!>=2}
  isnull always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "[" always "["
Line 635
  arrayDelete always {!<=-1,!>=2}
  ? possible {-2,-1}
  NEW_ARRAY always -2
  : always -1
  NEW always -1
  :: always -1
  DEALLOC always -1
Line 644
  ? possible 0
  af always !0
  : always 0
  0 always 0
  :: always -1
  DEALLOC always -1
Line 645
  == always {!<=-1,!>=2}
  0 always 0
Line 646
  = always 0
  :: always 0
  NOALLOC always 0
Line 652
  . possible 0
  == {!<=-1,!>=2,1}
  :: always 0
  NOALLOC always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(ftok->next()->link())
  ") ; }" always ") ; }"
Line 653
  tok always symbolic=(ftok->next()->link())
Line 654
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 655
  ( always {!<=-1,!>=2}
  tok always symbolic=(ftok->next()->link())
  2 always 2
  & {lifetime[Address]=(unknown),!0}
  unknown always 0
Line 656
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 658
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 667
  == always {!<=-1,!>=2}
  "goto" always "goto"
Line 672
  ( always {!<=-1,!>=2}
  "continue|break ;" always "continue|break ;"
Line 677
  ( always {!<=-1,!>=2}
  "%name% <" always "%name% <"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 678
  1 always 1
Line 679
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> %var% {|( %var% ,|)|}" always "> %var% {|( %var% ,|)|}"
Line 682
  2 always 2
Line 685
  ( always {!<=-1,!>=2}
  2 always 2
  varid always symbolic=(typeEndTok->next()->varId())
Line 688
  arrayDelete always {!<=-1,!>=2}
  arrayDelete always {!<=-1,!>=2}
  = always 0
  false always 0
Line 689
  "[ ]" always "[ ]"
Line 690
  arrayDelete always {!<=-1,!>=2}
  = always 1
  true always 1
Line 693
  = always 0
  nullptr always 0
Line 694
  = always 0
  nullptr always 0
Line 695
  = always 0
  nullptr always 0
Line 696
  ( always {!<=-1,!>=2}
  "unique_ptr < %type% ," always "unique_ptr < %type% ,"
Line 697
  4 always 4
Line 699
  ( always {!<=-1,!>=2}
  "> %var% {|( %var% ," always "> %var% {|( %var% ,"
Line 700
  5 always 5
Line 701
  2 always 2
Line 705
  deleterToken always !0
  == always {!<=-1,!>=2}
  "+" always "+"
Line 706
  deleterToken always !0
Line 709
  "& %name%" always "& %name%"
Line 711
  dtok always !0
  1 always 1
Line 713
  = always 0
  nullptr always 0
Line 714
  = always 0
  nullptr always 0
Line 716
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
Line 717
  ( always {!<=-1,!>=2}
  "] (" always "] ("
  && always {!<=-1,!>=2}
Line 719
  ( always {!<=-1,!>=2}
  1 always 1
  ") {" always ") {"
Line 720
  1 always 1
  1 always 1
Line 723
  "%type%" always "%type%"
  && always {!<=-1,!>=2}
  dtok always !0
Line 724
  dtok always !0
  ( always !0
Line 725
  tscope always symbolic=(dtok->type()->classScope)
Line 726
  tscope {symbolic=(dtok->type()->classScope),!0}
Line 727
  tscope {symbolic=(dtok->type()->classScope),!0}
Line 731
  tscopeStart possible symbolic=(tscope->bodyStart)
  && always {!<=-1,!>=2}
Line 732
  = always !0
  tscopeStart always !0
  != always {!<=-1,!>=2}
  tscopeEnd always !0
Line 741
  3 always 3
Line 742
  af possible 0
  ? possible {-2,-1}
  af always !0
  : possible {-2,-1}
  arrayDelete always {!<=-1,!>=2}
  ? possible {-2,-1}
  NEW_ARRAY always -2
  : always -1
  NEW always -1
  :: always -2
  OWNED always -2
Line 746
  varInfo possible lifetime[Address]=(varInfo)@70
  true always 1
Line 753
  > always {!<=-1,!>=2}
  0 always 0
Line 755
  :: possible {symbolic=(varInfo->alloctype.end()),end=0}
  var possible {symbolic=(varInfo->alloctype.end()),end=0}
  = possible lifetime[Iterator]=(varInfo->alloctype)
  varInfo possible lifetime[Address]=(varInfo)@18038
  ( possible lifetime[Iterator]=(varInfo->alloctype)
  ( {>=1,!<=0}
Line 756
  != always {!<=-1,!>=2}
  varInfo possible lifetime[Address]=(varInfo)@18038
  ( {lifetime[Iterator]=(varInfo->alloctype),end=0}
Line 757
  unknown {!<=-1,!>=2,0}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 758
  var always {!symbolic=(varInfo->alloctype.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always -1
  DEALLOC always -1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unknown always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 760
  ( always {!<=-1,!>=2}
  -2 always -2
  "= &" always "= &"
Line 761
  varInfo possible lifetime[Address]=(varInfo)@18038
Line 765
  rhs possible symbolic=(tok)
Line 766
  ( always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 768
  = always !0
  ( always !0
Line 770
  rhs possible symbolic=(tok)
  ( always {!<=-1,!>=2}
Line 773
  == always {!<=-1,!>=2}
Line 775
  ( always symbolic=(rhs->varId())
Line 776
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 779
  0 always 0
  3 always 3
  "arg" always "arg"
  == always {!<=-1,!>=2}
  0 always 0
Line 781
  argn always Uninit
Line 783
  "arg" always "arg"
  1 always 1
Line 784
  == always {!<=-1,!>=2}
Line 785
  ( always !symbolic=(rhs->varId())
Line 791
  ( always {!<=-1,!>=2}
  "& %name% = %var% ;" always "& %name% = %var% ;"
Line 792
  varInfo possible lifetime[Address]=(varInfo)@18038
  2 always 2
Line 800
  ? possible 0
  allocFunc always !0
  : always 0
  0 always 0
  :: always -1
  DEALLOC always -1
Line 801
  == always {!<=-1,!>=2}
  0 always 0
Line 802
  = always 0
  :: always 0
  NOALLOC always 0
Line 803
  openingPar always !0
  varInfo possible lifetime[Address]=(varInfo)@18038
  nullptr always 0
Line 805
  0 always 0
  3 always 3
  "arg" always "arg"
  == always {!<=-1,!>=2}
  0 always 0
Line 807
  openingPar always !0
Line 808
  openingPar always !0
Line 811
  nullptr always 0
Line 817
  fTok inconclusive symbolic=(tokRightAstOperand?tokRightAstOperand->previous():nullptr)@157
Line 818
  && always {!<=-1,!>=2}
  f always !0
  == always {!<=-1,!>=2}
  -1 always -1
  && always {!<=-1,!>=2}
  f always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  <= always {!<=-1,!>=2}
  fTok inconclusive symbolic=(tokRightAstOperand?tokRightAstOperand->previous():nullptr)@157
Line 819
  f always !0
  . {>=1,!<=0}
  - {>=0,!<=-1}
  1 always 1
Line 820
  ( possible lifetime[Iterator]=(alloctype)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(alloctype),end=0}
Line 822
  argAlloc always {symbolic=(alloctype[argTok->varId()]),symbolic=(argAlloc)}
  . possible symbolic=(f->groupId)
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  argAlloc always {symbolic=(alloctype[argTok->varId()]),symbolic=(argAlloc)}
  . always !0
  != always {!<=-1,!>=2}
  f always !0
Line 824
  argAlloc possible {symbolic=(alloctype[argTok->varId()]),symbolic=(argAlloc)}
  = always -3
  :: always -3
  REALLOC always -3
Line 828
  retAlloc always {symbolic=(alloctype[retTok->varId()]),symbolic=(retAlloc)}
  f always !0
Line 829
  = always 1
  :: always 1
  ALLOC always 1
Line 839
  :: possible {symbolic=(alloctype.end()),end=0}
  var possible {symbolic=(alloctype.end()),end=0}
  = possible lifetime[Iterator]=(varInfo->alloctype)
  ( possible lifetime[Iterator]=(varInfo->alloctype)
Line 840
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo->alloctype),end=0}
Line 841
  == always {!<=-1,!>=2}
  :: always 0
  NOALLOC always 0
Line 844
  var always {!symbolic=(alloctype.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always -1
  DEALLOC always -1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 846
  var always {!symbolic=(alloctype.end()),!end=0}
Line 847
  var always !end=0
Line 848
  var always !end=0
Line 849
  var always !end=0
  . possible 0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !end=0
  . always !symbolic=(allocation.type)
  != always {!<=-1,!>=2}
  0 always 0
Line 851
  var always !end=0
Line 855
  var always !end=0
Line 856
  var always !end=0
Line 857
  var always !end=0
Line 859
  . possible -2
  != {!<=-1,!>=2,1}
  :: always 0
  NOALLOC always 0
  && always {!<=-1,!>=2}
  . always !0
  != always {!<=-1,!>=2}
  :: always -2
  OWNED always -2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 860
  = always -1
  :: always -1
  DEALLOC always -1
Line 868
  ( always {!<=-1,!>=2}
Line 874
  ! always {!<=-1,!>=2}
  tokFirstArg always symbolic=(tokOpeningPar->next())
  || always {!<=-1,!>=2}
  tokFirstArg {symbolic=(tokOpeningPar->next()),!0}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 879
  = always 1
  1 always 1
Line 880
  = {symbolic=(tokOpeningPar->next()),!0}
  tokFirstArg {symbolic=(tokOpeningPar->next()),!0}
  funcArg possible symbolic=(tokOpeningPar->next())
Line 882
  ( always {!<=-1,!>=2}
Line 883
  = always 0
  0 always 0
Line 884
  arg always symbolic=(funcArg)
  == always {!<=-1,!>=2}
  "new" always "new"
Line 885
  = always 1
  1 always 1
Line 886
  ( always {!<=-1,!>=2}
  arg always symbolic=(funcArg)
  "* new" always "* new"
Line 887
  = always 2
  2 always 2
Line 888
  tokAdvance possible {1,2}
  > {!<=-1,!>=2,1}
  0 always 0
Line 889
  arg always symbolic=(funcArg)
  tokAdvance {1,2,!<=0}
Line 890
  ( always {!<=-1,!>=2}
  "( std :: nothrow )" always "( std :: nothrow )"
Line 891
  5 always 5
Line 896
  arg possible symbolic=(funcArg)
  && always {!<=-1,!>=2}
  arg always !0
  ( always {!<=-1,!>=2}
Line 897
  arg always !0
  arg always !0
  ( always !0
  : always 1
  arg always !0
Line 898
  = possible 0
  arg possible 0
Line 900
  ( always {!<=-1,!>=2}
  arg possible {symbolic=(argTypeStartTok),0}
  "%name% .|:: %name%" always "%name% .|:: %name%"
Line 901
  2 always 2
Line 903
  ( always {!<=-1,!>=2}
  arg possible symbolic=(argTypeStartTok)
  "%var% [-,)] !!." always "%var% [-,)] !!."
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "& %var%" always "& %var%"
Line 905
  == always {!<=-1,!>=2}
  "&" always "&"
Line 908
  isnull always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 911
  ! always {!<=-1,!>=2}
  isnull always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  af always !0
  == always {!<=-1,!>=2}
Line 915
  ( always {!<=-1,!>=2}
  "%name% < %type%" always "%name% < %type%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 916
  1 always 1
Line 917
  = always 0
  nullptr always 0
Line 918
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "> {|( %var% ,|)|}" always "> {|( %var% ,|)|}"
Line 921
  arrayDelete always {!<=-1,!>=2}
  arrayDelete always {!<=-1,!>=2}
  = always 0
  false always 0
Line 922
  "[ ]" always "[ ]"
Line 923
  arrayDelete always {!<=-1,!>=2}
  = always 1
  true always 1
Line 926
  = always 0
  nullptr always 0
Line 927
  = always 0
  nullptr always 0
Line 928
  = always 0
  nullptr always 0
Line 929
  ( always {!<=-1,!>=2}
  "unique_ptr < %type% ," always "unique_ptr < %type% ,"
Line 930
  4 always 4
Line 932
  ( always {!<=-1,!>=2}
  "> {|( %var% ," always "> {|( %var% ,"
Line 933
  4 always 4
Line 934
  1 always 1
Line 938
  deleterToken always !0
  "& %name%" always "& %name%"
Line 940
  dtok always !0
  1 always 1
Line 943
  deleterToken always !0
  "%type%" always "%type%"
Line 944
  && always {!<=-1,!>=2}
  dtok always !0
Line 945
  dtok always !0
  ( always !0
Line 946
  tscope always symbolic=(dtok->type()->classScope)
  != always {!<=-1,!>=2}
  tscope always symbolic=(dtok->type()->classScope)
Line 957
  2 always 2
Line 958
  sp_af possible 0
  ? possible {-2,-1}
  sp_af always !0
  : possible {-2,-1}
  arrayDelete always {!<=-1,!>=2}
  ? possible {-2,-1}
  NEW_ARRAY always -2
  : always -1
  NEW always -1
  :: always -2
  OWNED always -2
Line 964
  argNr possible 1
  ++ possible 1
Line 975
  :: possible {symbolic=(alloctype.end()),end=0}
  var possible {symbolic=(alloctype.end()),end=0}
  = possible {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype)}
  ( possible {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype)}
Line 976
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype),end=0}
  && always {!<=-1,!>=2}
  var always {!symbolic=(alloctype.end()),!end=0}
  == always {!<=-1,!>=2}
  :: always 1
  ALLOC always 1
Line 977
  :: possible {symbolic=(possibleUsage.end()),end=0}
  use possible {symbolic=(possibleUsage.end()),end=0}
  = possible {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage)}
  ( possible {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage)}
Line 978
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage),end=0}
Line 979
  var always !end=0
Line 981
  use always !end=0
Line 986
  , always {!<=-1,!>=2}
  isEndOfScope always {!<=-1,!>=2}
Line 993
  = {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype),start=0}
  ( {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype),start=0}
  it possible {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype),end=0}
Line 995
  ! {!<=-1,!>=2,1,0@41}
  isEndOfScope {!<=-1,!>=2,0,1@41}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  it possible {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype)}
  && always {!<=-1,!>=2}
  ( possible {lifetime[Iterator]=(varInfo.conditionalAlloc),lifetime[Object]=(conditionalAlloc)}
  it possible {lifetime[Iterator]=(varInfo.alloctype),lifetime[Object]=(alloctype)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.conditionalAlloc),lifetime[Object]=(conditionalAlloc),end=0}
Line 999
  ( possible {lifetime[Iterator]=(varInfo.referenced),lifetime[Object]=(referenced)}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.referenced),lifetime[Object]=(referenced),end=0}
Line 1003
  varid always symbolic=(it->first)
Line 1006
  isEndOfScope always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  var always !0
  ( always !0
Line 1008
  used always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1009
  = possible symbolic=(var->scope()->bodyEnd)
  tok possible symbolic=(var->scope()->bodyEnd)
  tok2 possible symbolic=(var->scope()->bodyEnd)
Line 1010
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1012
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|(|{|," always "return|(|{|,"
Line 1016
  tok3 possible symbolic=(tok2->next())
  && always {!<=-1,!>=2}
  tok3 {symbolic=(tok2->next()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok3 {symbolic=(tok2->next()),!0}
  && always {!<=-1,!>=2}
Line 1017
  tok3 possible symbolic=(tok2->next())
  ( always !0
  || always {!<=-1,!>=2}
Line 1018
  tok3 possible symbolic=(tok2->next())
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
Line 1019
  tok3 possible symbolic=(tok2->next())
  ( always !0
  >= always {!<=-1,!>=2}
Line 1020
  tok3 always !0
  tok3 always !0
  ( always !0
  : always 1
  tok3 always !0
Line 1021
  ( always {!<=-1,!>=2}
  tok3 possible {symbolic=(tok2->next()),0}
  "%varid%" always "%varid%"
Line 1023
  ( always {!<=-1,!>=2}
  "& %varid% . %name%" always "& %varid% . %name%"
Line 1024
  4 always 4
Line 1027
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok3->next())
  "[});,+]" always "[});,+]"
Line 1028
  used always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1034
  used {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always -1
  DEALLOC always -1
Line 1037
  ! {!<=-1,!>=2,1}
  used {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1038
  :: possible {symbolic=(possibleUsage.end()),end=0}
  use possible {symbolic=(possibleUsage.end()),end=0}
  = possible {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage)}
  ( possible {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage)}
Line 1039
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varInfo.possibleUsage),lifetime[Object]=(possibleUsage),end=0}
Line 1042
  use always !end=0
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,6@72}
  flag possible 6@72
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
