

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073745560 !@expr1073745561 mTokenizer@var28 ) {
69: instances (@expr1073745562 ) .@expr1073745563 remove (@expr1073745564 this@expr1073745565 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073745566 string (@expr1073745567 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073745568 void ) tokenizer@var21 ;
108: (@expr1073745569 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073745570 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073745571 void ) ctu@var24 ;
120: (@expr1073745572 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073745573 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073745574 0U ) , Certainty ::@expr1073745575 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073745576 list < const Token *@expr1073745577 > callstack@var41 (@expr1073745578 1 , tok@var35 ) ;
141: reportError (@expr1073745579 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073745580 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073745581 0U ) , Certainty ::@expr1073745582 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/checkother.h

1:
|
31:
32: namespace ValueFlow {
33: class Value ;
34: }
35:
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class Function ;
40: class Variable ;
41: class ErrorLogger ;
42:
|
48:
49: class CheckOther : public Check {
50: public:
51:
52: CheckOther ( ) : Check ( myName ( ) ) { }
53:
54:
55: CheckOther ( const Tokenizer * tokenizer@var64 , const Settings * settings@var65 , ErrorLogger * errorLogger@var66 )
56: : Check ( myName ( ) , tokenizer@var64 , settings@var65 , errorLogger@var66 ) { }
57:
58:
59: void runChecks ( const Tokenizer * tokenizer@var67 , const Settings * settings@var68 , ErrorLogger * errorLogger@var69 ) override {
60: CheckOther checkOther@var70 (@expr1073745583 tokenizer@var67 , settings@var68 , errorLogger@var69 ) ;
61:
62:
63: checkOther@var70 .@expr1073745584 warningOldStylePointerCast (@expr1073745585 ) ;
64: checkOther@var70 .@expr1073745586 invalidPointerCast (@expr1073745587 ) ;
65: checkOther@var70 .@expr1073745588 checkCharVariable (@expr1073745589 ) ;
66: checkOther@var70 .@expr1073745590 checkRedundantAssignment (@expr1073745591 ) ;
67: checkOther@var70 .@expr1073745592 checkRedundantAssignmentInSwitch (@expr1073745593 ) ;
68: checkOther@var70 .@expr1073745594 checkSuspiciousCaseInSwitch (@expr1073745595 ) ;
69: checkOther@var70 .@expr1073745596 checkDuplicateBranch (@expr1073745597 ) ;
70: checkOther@var70 .@expr1073745598 checkDuplicateExpression (@expr1073745599 ) ;
71: checkOther@var70 .@expr1073745600 checkUnreachableCode (@expr1073745601 ) ;
72: checkOther@var70 .@expr1073745602 checkSuspiciousSemicolon (@expr1073745603 ) ;
73: checkOther@var70 .@expr1073745604 checkVariableScope (@expr1073745605 ) ;
74: checkOther@var70 .@expr1073745606 checkSignOfUnsignedVariable (@expr1073745607 ) ;
75: checkOther@var70 .@expr1073745608 checkIncompleteArrayFill (@expr1073745609 ) ;
76: checkOther@var70 .@expr1073745610 checkVarFuncNullUB (@expr1073745611 ) ;
77: checkOther@var70 .@expr1073745612 checkNanInArithmeticExpression (@expr1073745613 ) ;
78: checkOther@var70 .@expr1073745614 checkCommaSeparatedReturn (@expr1073745615 ) ;
79: checkOther@var70 .@expr1073745616 checkRedundantPointerOp (@expr1073745617 ) ;
80: checkOther@var70 .@expr1073745618 checkZeroDivision (@expr1073745619 ) ;
81: checkOther@var70 .@expr1073745620 checkNegativeBitwiseShift (@expr1073745621 ) ;
82: checkOther@var70 .@expr1073745622 checkInterlockedDecrement (@expr1073745623 ) ;
83: checkOther@var70 .@expr1073745624 checkUnusedLabel (@expr1073745625 ) ;
84: checkOther@var70 .@expr1073745626 checkEvaluationOrder (@expr1073745627 ) ;
85: checkOther@var70 .@expr1073745628 checkFuncArgNamesDifferent (@expr1073745629 ) ;
86: checkOther@var70 .@expr1073745630 checkShadowVariables (@expr1073745631 ) ;
87: checkOther@var70 .@expr1073745632 checkKnownArgument (@expr1073745633 ) ;
88: checkOther@var70 .@expr1073745634 checkComparePointers (@expr1073745635 ) ;
89: checkOther@var70 .@expr1073745636 checkIncompleteStatement (@expr1073745637 ) ;
90: checkOther@var70 .@expr1073745638 checkPipeParameterSize (@expr1073745639 ) ;
91: checkOther@var70 .@expr1073745640 checkRedundantCopy (@expr1073745641 ) ;
92: checkOther@var70 .@expr1073745642 clarifyCalculation (@expr1073745643 ) ;
93: checkOther@var70 .@expr1073745644 checkPassByReference (@expr1073745645 ) ;
94: checkOther@var70 .@expr1073745646 checkConstVariable (@expr1073745647 ) ;
95: checkOther@var70 .@expr1073745648 checkConstPointer (@expr1073745649 ) ;
96: checkOther@var70 .@expr1073745650 checkComparisonFunctionIsAlwaysTrueOrFalse (@expr1073745651 ) ;
97: checkOther@var70 .@expr1073745652 checkInvalidFree (@expr1073745653 ) ;
98: checkOther@var70 .@expr1073745654 clarifyStatement (@expr1073745655 ) ;
99: checkOther@var70 .@expr1073745656 checkCastIntToCharAndBack (@expr1073745657 ) ;
100: checkOther@var70 .@expr1073745658 checkMisusedScopedObject (@expr1073745659 ) ;
101: checkOther@var70 .@expr1073745660 checkAccessOfMovedVariable (@expr1073745661 ) ;
102: checkOther@var70 .@expr1073745662 checkModuloOfOne (@expr1073745663 ) ;
103: checkOther@var70 .@expr1073745664 checkOverlappingWrite (@expr1073745665 ) ;
104: }
105:
106:
107: static bool comparisonNonZeroExpressionLessThanZero ( const Token * tok@var71 , const ValueFlow :: Value * * zeroValue@var72 , const Token * * nonZeroExpr@var73 ) ;
108:
109:
110: static bool testIfNonZeroExpressionIsPositive ( const Token * tok@var74 , const ValueFlow :: Value * * zeroValue@var75 , const Token * * nonZeroExpr@var76 ) ;
111:
112:
113:
114: void clarifyCalculation ( ) ;
115:
116:
117: void clarifyStatement ( ) ;
118:
119:
120: void warningOldStylePointerCast ( ) ;
121:
122:
123: void invalidPointerCast ( ) ;
124:
125:
126: void checkVariableScope ( ) ;
127: static bool checkInnerScope ( const Token * tok@var77 , const Variable * var@var78 , bool & used@var79 ) ;
128:
129:
130: void checkCommaSeparatedReturn ( ) ;
131:
132:
133: void checkPassByReference ( ) ;
134:
135: void checkConstVariable ( ) ;
136: void checkConstPointer ( ) ;
137:
138:
139: void checkCharVariable ( ) ;
140:
141:
142: void checkIncompleteStatement ( ) ;
143:
144:
145: void checkZeroDivision ( ) ;
146:
147:
148: void checkNanInArithmeticExpression ( ) ;
149:
150:
151: void checkRedundantAssignment ( ) ;
152:
153:
154: void checkRedundantAssignmentInSwitch ( ) ;
155:
156:
157: void checkSuspiciousCaseInSwitch ( ) ;
158:
159:
160: void checkMisusedScopedObject ( ) ;
161:
162:
163: void checkDuplicateBranch ( ) ;
164:
165:
166: void checkDuplicateExpression ( ) ;
167:
168:
169: void checkUnreachableCode ( ) ;
170:
171:
172: void checkSignOfUnsignedVariable ( ) ;
173:
174:
175: void checkSuspiciousSemicolon ( ) ;
176:
177:
178: void checkInvalidFree ( ) ;
179: void invalidFreeError ( const Token * tok@var80 , const std :: string & allocation@var81 , bool inconclusive@var82 ) ;
180:
181:
182: void checkRedundantCopy ( ) ;
183:
184:
185: void checkNegativeBitwiseShift ( ) ;
186:
187:
188: void checkIncompleteArrayFill ( ) ;
189:
190:
191: void checkVarFuncNullUB ( ) ;
192:
193:
194: void checkPipeParameterSize ( ) ;
195:
196:
197: void checkCastIntToCharAndBack ( ) ;
198:
199:
200: void checkComparisonFunctionIsAlwaysTrueOrFalse ( ) ;
201:
202:
203: void checkRedundantPointerOp ( ) ;
204:
205:
206: void checkInterlockedDecrement ( ) ;
207:
208:
209: void checkUnusedLabel ( ) ;
210:
211:
212: void checkEvaluationOrder ( ) ;
213:
214:
215: void checkAccessOfMovedVariable ( ) ;
216:
217:
218: void checkFuncArgNamesDifferent ( ) ;
219:
220:
221: void checkShadowVariables ( ) ;
222:
223: void checkKnownArgument ( ) ;
224:
225: void checkComparePointers ( ) ;
226:
227: void checkModuloOfOne ( ) ;
228:
229: void checkOverlappingWrite ( ) ;
230: void overlappingWriteUnion ( const Token * tok@var83 ) ;
231: void overlappingWriteFunction ( const Token * tok@var84 ) ;
232:
233: private:
234:
235: void checkComparisonFunctionIsAlwaysTrueOrFalseError ( const Token * tok@var85 , const std :: string & functionName@var86 , const std :: string & varName@var87 , const bool result@var88 ) ;
236: void checkCastIntToCharAndBackError ( const Token * tok@var89 , const std :: string & strFunctionName@var90 ) ;
237: void checkPipeParameterSizeError ( const Token * tok@var91 , const std :: string & strVarName@var92 , const std :: string & strDim@var93 ) ;
238: void clarifyCalculationError ( const Token * tok@var94 , const std :: string & op@var95 ) ;
239: void clarifyStatementError ( const Token * tok@var96 ) ;
240: void cstyleCastError ( const Token * tok@var97 ) ;
241: void invalidPointerCastError ( const Token * tok@var98 , const std :: string & from@var99 , const std :: string & to@var100 , bool inconclusive@var101 , bool toIsInt@var102 ) ;
242: void passedByValueError ( const Token * tok@var103 , const std :: string & parname@var104 , bool inconclusive@var105 ) ;
243: void constVariableError ( const Variable * var@var106 , const Function * function@var107 ) ;
244: void constStatementError ( const Token * tok@var108 , const std :: string & type@var109 , bool inconclusive@var110 ) ;
245: void signedCharArrayIndexError ( const Token * tok@var111 ) ;
246: void unknownSignCharArrayIndexError ( const Token * tok@var112 ) ;
247: void charBitOpError ( const Token * tok@var113 ) ;
248: void variableScopeError ( const Token * tok@var114 , const std :: string & varname@var115 ) ;
249: void zerodivError ( const Token * tok@var116 , const ValueFlow :: Value * value@var117 ) ;
250: void nanInArithmeticExpressionError ( const Token * tok@var118 ) ;
251: void redundantAssignmentError ( const Token * tok1@var119 , const Token * tok2@var120 , const std :: string & var@var121 , bool inconclusive@var122 ) ;
252: void redundantInitializationError ( const Token * tok1@var123 , const Token * tok2@var124 , const std :: string & var@var125 , bool inconclusive@var126 ) ;
253: void redundantAssignmentInSwitchError ( const Token * tok1@var127 , const Token * tok2@var128 , const std :: string & var@var129 ) ;
254: void redundantCopyError ( const Token * tok1@var130 , const Token * tok2@var131 , const std :: string & var@var132 ) ;
255: void redundantCopyInSwitchError ( const Token * tok1@var133 , const Token * tok2@var134 , const std :: string & var@var135 ) ;
256: void redundantBitwiseOperationInSwitchError ( const Token * tok@var136 , const std :: string & varname@var137 ) ;
257: void suspiciousCaseInSwitchError ( const Token * tok@var138 , const std :: string & operatorString@var139 ) ;
258: void selfAssignmentError ( const Token * tok@var140 , const std :: string & varname@var141 ) ;
259: void misusedScopeObjectError ( const Token * tok@var142 , const std :: string & varname@var143 ) ;
260: void duplicateBranchError ( const Token * tok1@var144 , const Token * tok2@var145 , std :: list < std :: pair < const Token * , std :: string > > errors@var146 ) ;
261: void duplicateAssignExpressionError ( const Token * tok1@var147 , const Token * tok2@var148 , bool inconclusive@var149 ) ;
262: void oppositeExpressionError ( const Token * opTok@var150 , std :: list < std :: pair < const Token * , std :: string > > errors@var151 ) ;
263: void duplicateExpressionError ( const Token * tok1@var152 , const Token * tok2@var153 , const Token * opTok@var154 , std :: list < std :: pair < const Token * , std :: string > > errors@var155 , bool hasMultipleExpr@var156 = false ) ;
264: void duplicateValueTernaryError ( const Token * tok@var157 ) ;
265: void duplicateExpressionTernaryError ( const Token * tok@var158 , std :: list < std :: pair < const Token * , std :: string > > errors@var159 ) ;
266: void duplicateBreakError ( const Token * tok@var160 , bool inconclusive@var161 ) ;
267: void unreachableCodeError ( const Token * tok@var162 , bool inconclusive@var163 ) ;
268: void unsignedLessThanZeroError ( const Token * tok@var164 , const ValueFlow :: Value * v@var165 , const std :: string & varname@var166 ) ;
269: void pointerLessThanZeroError ( const Token * tok@var167 , const ValueFlow :: Value * v@var168 ) ;
270: void unsignedPositiveError ( const Token * tok@var169 , const ValueFlow :: Value * v@var170 , const std :: string & varname@var171 ) ;
271: void pointerPositiveError ( const Token * tok@var172 , const ValueFlow :: Value * v@var173 ) ;
272: void suspiciousSemicolonError ( const Token * tok@var174 ) ;
273: void negativeBitwiseShiftError ( const Token * tok@var175 , int op@var176 ) ;
274: void redundantCopyError ( const Token * tok@var177 , const std :: string & varname@var178 ) ;
275: void incompleteArrayFillError ( const Token * tok@var179 , const std :: string & buffer@var180 , const std :: string & function@var181 , bool boolean@var182 ) ;
276: void varFuncNullUBError ( const Token * tok@var183 ) ;
277: void commaSeparatedReturnError ( const Token * tok@var184 ) ;
278: void redundantPointerOpError ( const Token * tok@var185 , const std :: string & varname@var186 , bool inconclusive@var187 , bool addressOfDeref@var188 ) ;
279: void raceAfterInterlockedDecrementError ( const Token * tok@var189 ) ;
280: void unusedLabelError ( const Token * tok@var190 , bool inSwitch@var191 , bool hasIfdef@var192 ) ;
281: void unknownEvaluationOrder ( const Token * tok@var193 ) ;
282: static bool isMovedParameterAllowedForInconclusiveFunction ( const Token * tok@var194 ) ;
283: void accessMovedError ( const Token * tok@var195 , const std :: string & varname@var196 , const ValueFlow :: Value * value@var197 , bool inconclusive@var198 ) ;
284: void funcArgNamesDifferent ( const std :: string & functionName@var199 , int index@var200 , const Token * declaration@var201 , const Token * definition@var202 ) ;
285: void funcArgOrderDifferent ( const std :: string & functionName@var203 , const Token * declaration@var204 , const Token * definition@var205 , const std :: vector < const Token * > & declarations@var206 , const std :: vector < const Token * > & definitions@var207 ) ;
286: void shadowError ( const Token * var@var208 , const Token * shadowed@var209 , std :: string type@var210 ) ;
287: void knownArgumentError ( const Token * tok@var211 , const Token * ftok@var212 , const ValueFlow :: Value * value@var213 , const std :: string & varexpr@var214 , bool isVariableExpressionHidden@var215 ) ;
288: void comparePointersError ( const Token * tok@var216 , const ValueFlow :: Value * v1@var217 , const ValueFlow :: Value * v2@var218 ) ;
289: void checkModuloOfOneError ( const Token * tok@var219 ) ;
290:
291: void getErrorMessages ( ErrorLogger * errorLogger@var220 , const Settings * settings@var221 ) const override {
292: CheckOther c@var222 (@expr1073745666 nullptr , settings@var221 , errorLogger@var220 ) ;
293:
294: std ::@expr1073745667 list < std ::@expr3844 pair < const Token *@expr3845 , std ::@expr3844 string > > errorPath@var223 ;
295:
296:
297: c@var222 .@expr1073745671 zerodivError (@expr1073745672 nullptr , nullptr ) ;
298: c@var222 .@expr1073745673 misusedScopeObjectError (@expr1073745674 nullptr , "varname" ) ;
299: c@var222 .@expr1073745675 invalidPointerCastError (@expr1073745676 nullptr , "float *" , "double *" , false , false ) ;
300: c@var222 .@expr3853 negativeBitwiseShiftError (@expr1073745678 nullptr , 1 ) ;
301: c@var222 .@expr3853 negativeBitwiseShiftError (@expr1073745680 nullptr , 2 ) ;
302: c@var222 .@expr1073745681 checkPipeParameterSizeError (@expr1073745682 nullptr , "varname" , "dimension" ) ;
303: c@var222 .@expr1073745683 raceAfterInterlockedDecrementError (@expr1073745684 nullptr ) ;
304: c@var222 .@expr1073745685 invalidFreeError (@expr1073745686 nullptr , "malloc" , false ) ;
305: c@var222 .@expr1073745687 overlappingWriteUnion (@expr1073745688 nullptr ) ;
306: c@var222 .@expr1073745689 overlappingWriteFunction (@expr1073745690 nullptr ) ;
307:
308:
309: c@var222 .@expr3867 redundantCopyError (@expr1073745692 nullptr , "varname" ) ;
310: c@var222 .@expr3867 redundantCopyError (@expr1073745694 nullptr , nullptr , "var" ) ;
311:
312:
313: c@var222 .@expr1073745695 checkComparisonFunctionIsAlwaysTrueOrFalseError (@expr1073745696 nullptr , "isless" , "varName" , false ) ;
314: c@var222 .@expr1073745697 checkCastIntToCharAndBackError (@expr1073745698 nullptr , "func_name" ) ;
315: c@var222 .@expr1073745699 cstyleCastError (@expr1073745700 nullptr ) ;
316: c@var222 .@expr1073745701 passedByValueError (@expr1073745702 nullptr , "parametername" , false ) ;
317: c@var222 .@expr1073745703 constVariableError (@expr1073745704 nullptr , nullptr ) ;
318: c@var222 .@expr1073745705 constStatementError (@expr1073745706 nullptr , "type" , false ) ;
319: c@var222 .@expr1073745707 signedCharArrayIndexError (@expr1073745708 nullptr ) ;
320: c@var222 .@expr1073745709 unknownSignCharArrayIndexError (@expr1073745710 nullptr ) ;
321: c@var222 .@expr1073745711 charBitOpError (@expr1073745712 nullptr ) ;
322: c@var222 .@expr1073745713 variableScopeError (@expr1073745714 nullptr , "varname" ) ;
323: c@var222 .@expr1073745715 redundantAssignmentInSwitchError (@expr1073745716 nullptr , nullptr , "var" ) ;
324: c@var222 .@expr1073745717 redundantCopyInSwitchError (@expr1073745718 nullptr , nullptr , "var" ) ;
325: c@var222 .@expr1073745719 suspiciousCaseInSwitchError (@expr1073745720 nullptr , "||" ) ;
326: c@var222 .@expr1073745721 selfAssignmentError (@expr1073745722 nullptr , "varname" ) ;
327: c@var222 .@expr1073745723 clarifyCalculationError (@expr1073745724 nullptr , "+" ) ;
328: c@var222 .@expr1073745725 clarifyStatementError (@expr1073745726 nullptr ) ;
329: c@var222 .@expr1073745727 duplicateBranchError (@expr1073745728 nullptr , nullptr , errorPath@var223 ) ;
330: c@var222 .@expr1073745729 duplicateAssignExpressionError (@expr1073745730 nullptr , nullptr , true ) ;
331: c@var222 .@expr1073745731 oppositeExpressionError (@expr1073745732 nullptr , errorPath@var223 ) ;
332: c@var222 .@expr1073745733 duplicateExpressionError (@expr1073745734 nullptr , nullptr , nullptr , errorPath@var223 ) ;
333: c@var222 .@expr1073745735 duplicateValueTernaryError (@expr1073745736 nullptr ) ;
334: c@var222 .@expr1073745737 duplicateExpressionTernaryError (@expr1073745738 nullptr , errorPath@var223 ) ;
335: c@var222 .@expr1073745739 duplicateBreakError (@expr1073745740 nullptr , false ) ;
336: c@var222 .@expr1073745741 unreachableCodeError (@expr1073745742 nullptr , false ) ;
337: c@var222 .@expr1073745743 unsignedLessThanZeroError (@expr1073745744 nullptr , nullptr , "varname" ) ;
338: c@var222 .@expr1073745745 unsignedPositiveError (@expr1073745746 nullptr , nullptr , "varname" ) ;
339: c@var222 .@expr1073745747 pointerLessThanZeroError (@expr1073745748 nullptr , nullptr ) ;
340: c@var222 .@expr1073745749 pointerPositiveError (@expr1073745750 nullptr , nullptr ) ;
341: c@var222 .@expr1073745751 suspiciousSemicolonError (@expr1073745752 nullptr ) ;
342: c@var222 .@expr1073745753 incompleteArrayFillError (@expr1073745754 nullptr , "buffer" , "memset" , false ) ;
343: c@var222 .@expr1073745755 varFuncNullUBError (@expr1073745756 nullptr ) ;
344: c@var222 .@expr1073745757 nanInArithmeticExpressionError (@expr1073745758 nullptr ) ;
345: c@var222 .@expr1073745759 commaSeparatedReturnError (@expr1073745760 nullptr ) ;
346: c@var222 .@expr1073745761 redundantPointerOpError (@expr1073745762 nullptr , "varname" , false , true ) ;
347: c@var222 .@expr3939 unusedLabelError (@expr1073745764 nullptr , false , false ) ;
348: c@var222 .@expr3939 unusedLabelError (@expr1073745766 nullptr , false , true ) ;
349: c@var222 .@expr3939 unusedLabelError (@expr1073745768 nullptr , true , false ) ;
350: c@var222 .@expr3939 unusedLabelError (@expr1073745770 nullptr , true , true ) ;
351: c@var222 .@expr1073745771 unknownEvaluationOrder (@expr1073745772 nullptr ) ;
352: c@var222 .@expr1073745773 accessMovedError (@expr1073745774 nullptr , "v" , nullptr , false ) ;
353: c@var222 .@expr1073745775 funcArgNamesDifferent (@expr1073745776 "function" , 1 , nullptr , nullptr ) ;
354: c@var222 .@expr1073745777 redundantBitwiseOperationInSwitchError (@expr1073745778 nullptr , "varname" ) ;
355: c@var222 .@expr3955 shadowError (@expr1073745780 nullptr , nullptr , "variable" ) ;
356: c@var222 .@expr3955 shadowError (@expr1073745782 nullptr , nullptr , "function" ) ;
357: c@var222 .@expr3955 shadowError (@expr1073745784 nullptr , nullptr , "argument" ) ;
358: c@var222 .@expr1073745785 knownArgumentError (@expr1073745786 nullptr , nullptr , nullptr , "x" , false ) ;
359: c@var222 .@expr1073745787 comparePointersError (@expr1073745788 nullptr , nullptr , nullptr ) ;
360: c@var222 .@expr1073745789 redundantAssignmentError (@expr1073745790 nullptr , nullptr , "var" , false ) ;
361: c@var222 .@expr1073745791 redundantInitializationError (@expr1073745792 nullptr , nullptr , "var" , false ) ;
362:
363: const std ::@expr1073745793 vector < const Token *@expr3845 > nullvec@var224 ;
364: c@var222 .@expr1073745795 funcArgOrderDifferent (@expr1073745796 "function" , nullptr , nullptr , nullvec@var224 , nullvec@var224 ) ;
365: c@var222 .@expr1073745797 checkModuloOfOneError (@expr1073745798 nullptr ) ;
366: }
367:
368: static std :: string myName ( ) {
369: return "Other" ;
370: }
371:
372: std :: string classInfo ( ) const override {
373: return "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n"
374:
|
428:
429: ;
430: }
431: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var225 ;
42: double mDoubleValue@var226 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var227 ;
44: bool mIsUnsigned@var228 ;
45:
46: void promote ( const value & v@var229 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var230 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var227 !=@expr1073745799 Type ::@expr1073745800 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var227 ==@expr1073745801 Type ::@expr1073745802 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745803 ) ?@expr1073745804 mDoubleValue@var226 :@expr1073745805 (@expr1073745806 double ) mIntValue@var225 ;
60: }
61:
62: static value calc ( char op@var231 , const value & v1@var232 , const value & v2@var233 ) ;
63: int compare ( const value & v@var234 ) const ;
64: value add ( int v@var235 ) const ;
65: value shiftLeft ( const value & v@var236 ) const ;
66: value shiftRight ( const value & v@var237 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var238 ;
72:
73: static long long toLongNumber ( const std :: string & str@var239 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var240 ) ;
75:
76: template < class T > static std :: string toString ( T value@var241 ) {
77: std ::@expr1073745807 ostringstream result@var242 ;
78: result@var242 <<@expr1073745808 value@var241 ;
79: return result@var242 .@expr1073745809 str (@expr1073745810 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var243 ) ;
82:
83: static bool isInt ( const std :: string & str@var244 ) ;
84: static bool isFloat ( const std :: string & str@var245 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var246 ) ;
86: static bool isNegative ( const std :: string & str@var247 ) ;
87: static bool isPositive ( const std :: string & str@var248 ) ;
88: static bool isDec ( const std :: string & str@var249 ) ;
89: static bool isFloatHex ( const std :: string & str@var250 ) ;
90: static bool isIntHex ( const std :: string & str@var251 ) ;
91: static bool isOct ( const std :: string & str@var252 ) ;
92: static bool isBin ( const std :: string & str@var253 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var254 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var255 , bool supportMicrosoftExtensions@var256 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var257 , const std :: string & second@var258 ) ;
105: static std :: string subtract ( const std :: string & first@var259 , const std :: string & second@var260 ) ;
106: static std :: string multiply ( const std :: string & first@var261 , const std :: string & second@var262 ) ;
107: static std :: string divide ( const std :: string & first@var263 , const std :: string & second@var264 ) ;
108: static std :: string mod ( const std :: string & first@var265 , const std :: string & second@var266 ) ;
109: static std :: string incdec ( const std :: string & var@var267 , const std :: string & op@var268 ) ;
110: static std :: string calculate ( const std :: string & first@var269 , const std :: string & second@var270 , char action@var271 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var272 ) ;
113: static std :: string cos ( const std :: string & tok@var273 ) ;
114: static std :: string tan ( const std :: string & tok@var274 ) ;
115: static std :: string abs ( const std :: string & tok@var275 ) ;
116: static bool isEqual ( const std :: string & first@var276 , const std :: string & second@var277 ) ;
117: static bool isNotEqual ( const std :: string & first@var278 , const std :: string & second@var279 ) ;
118: static bool isGreater ( const std :: string & first@var280 , const std :: string & second@var281 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var282 , const std :: string & second@var283 ) ;
120: static bool isLess ( const std :: string & first@var284 , const std :: string & second@var285 ) ;
121: static bool isLessEqual ( const std :: string & first@var286 , const std :: string & second@var287 ) ;
122: static bool isNullValue ( const std :: string & str@var288 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var289 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var290 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var291 , std :: string :: size_type iPos@var292 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var293 , const MathLib :: value & v2@var294 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var295 , const MathLib :: value & v2@var296 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var297 , const MathLib :: value & v2@var298 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var299 , const MathLib :: value & v2@var300 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var301 , const MathLib :: value & v2@var302 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var303 , const MathLib :: value & v2@var304 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var305 , const MathLib :: value & v2@var306 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var307 , const MathLib :: value & v2@var308 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var309 , const MathLib :: value & v2@var310 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var311 , const MathLib :: value & v2@var312 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var313 ) ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var314 ) const {
35: return p@var314 .@expr1073745811 first@var315 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var316 ) const {
42: return p@var316 .@expr1073745812 second@var317 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var318 , const T & x@var319 )
48: {
49: return std ::@expr1073745813 find (@expr1073745814 r@var318 .@expr1073745815 begin (@expr1073745816 ) , r@var318 .@expr3993 end (@expr3994 ) , x@var319 ) !=@expr1073745819 r@var318 .@expr3993 end (@expr3994 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var320 , const T & x@var321 )
54: {
55: return std ::@expr1073745822 find (@expr1073745823 r@var320 .@expr1073745824 begin (@expr1073745825 ) , r@var320 .@expr4002 end (@expr4003 ) , x@var321 ) !=@expr1073745828 r@var320 .@expr4002 end (@expr4003 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var322 , const U & x@var323 )
60: {
61: return std ::@expr1073745831 find (@expr1073745832 r@var322 .@expr1073745833 begin (@expr1073745834 ) , r@var322 .@expr4011 end (@expr4012 ) , x@var323 ) !=@expr1073745837 r@var322 .@expr4011 end (@expr4012 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var324 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745840 t@var324 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var325 , char c@var326 )
74: {
75: return !@expr1073745841 str@var325 .@expr1073745842 empty (@expr1073745843 ) &&@expr1073745844 str@var325 .@expr1073745845 back (@expr1073745846 ) ==@expr1073745847 c@var326 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var327 , const char end@var328 [ ] , unsigned long endlen@var329 )
79: {
80: return (@expr4024 str@var327 .@expr4025 size (@expr4026 ) >=@expr1073745851 endlen@var329 ) &&@expr1073745852 (@expr4024 str@var327 .@expr1073745854 compare (@expr1073745855 str@var327 .@expr4025 size (@expr4026 ) -@expr1073745858 endlen@var329 , endlen@var329 , end@var328 ) ==@expr1073745859 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var330 , const char ( & end@var331 ) [ N ] )
85: {
86: return endsWith (@expr1073745861 str@var330 , end@var331 , N@expr1073745860 -@expr1073745862 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var332 , char q@var333 , const std :: string & p@var334 )
90: {
91: if (@expr1073745863 !@expr1073745864 endsWith (@expr1073745865 str@var332 , q@var333 ) ) {
92: return false ; }
93: if (@expr1073745866 (@expr1073745867 str@var332 .@expr1073745868 length (@expr1073745869 ) +@expr1073745870 1 ) >@expr1073745871 p@var334 .@expr1073745872 length (@expr1073745873 ) &&@expr1073745874 (@expr1073745875 str@var332 .@expr1073745876 compare (@expr1073745877 0 , p@var334 .@expr1073745878 size (@expr1073745879 ) +@expr1073745880 1 , p@var334 +@expr1073745881 q@var333 ) ==@expr1073745882 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var335 , char q@var336 )
99: {
100: static const std ::@expr4059 vector < std ::@expr4059 string > suffixes@var337 {@expr1073745885 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745886 const std ::@expr4059 string &@expr1073745888 p@var338 :@expr1073745889 suffixes@var337 ) {
102: if (@expr1073745890 isPrefixStringCharLiteral (@expr1073745891 str@var335 , q@var336 , p@var338 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var339 )
109: {
110: return isStringCharLiteral (@expr1073745892 str@var339 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var340 )
114: {
115: return isStringCharLiteral (@expr1073745893 str@var340 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var341 , char q@var342 )
119: {
120: const unsigned long quotePos@var343 =@expr1073745894 str@var341 .@expr1073745895 find (@expr1073745896 q@var342 ) ;
121: return str@var341 .@expr1073745897 substr (@expr1073745898 quotePos@var343 +@expr1073745899 1U , str@var341 .@expr1073745900 size (@expr1073745901 ) -@expr1073745902 quotePos@var343 -@expr1073745903 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var344 )
125: {
126: if (@expr1073745904 isStringLiteral (@expr1073745905 str@var344 ) ) {
127: return getStringCharLiteral (@expr1073745906 str@var344 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var345 )
132: {
133: if (@expr1073745907 isCharLiteral (@expr1073745908 str@var345 ) ) {
134: return getStringCharLiteral (@expr1073745909 str@var345 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var346 )
139: {
140: if (@expr1073745910 i@var346 ==@expr1073745911 1 ) {
141: return "st" ; }
142: if (@expr1073745912 i@var346 ==@expr1073745913 2 ) {
143: return "nd" ; }
144: if (@expr1073745914 i@var346 ==@expr1073745915 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var347 , const std :: string & rhs@var348 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var349 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var350 , const std :: string & name@var351 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var352 , const std :: string & name@var353 ) ;
156:
157: void strTolower ( std :: string & str@var354 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var355 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var356 ;
42:
43:
44: std :: string stdValue@var357 ;
45:
46:
47: Standards ( ) : c@var355 ( CLatest ) , cpp@var356 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var358 ) {
50: stdValue@var357 =@expr1073745916 str@var358 ;
51: if (@expr1073745917 str@var358 ==@expr1073745918 "c89" ||@expr1073745919 str@var358 ==@expr1073745920 "C89" ) {
52: c@var355 =@expr1073745921 C89 ;
53: return true ;
54: }
55: if (@expr1073745922 str@var358 ==@expr1073745923 "c99" ||@expr1073745924 str@var358 ==@expr1073745925 "C99" ) {
56: c@var355 =@expr1073745926 C99 ;
57: return true ;
58: }
59: if (@expr1073745927 str@var358 ==@expr1073745928 "c11" ||@expr1073745929 str@var358 ==@expr1073745930 "C11" ) {
60: c@var355 =@expr1073745931 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745932 c@var355 ) {
67: case C89 :@expr4109 ;
68: return "c89" ;
69: case C99 :@expr4109 ;
70: return "c99" ;
71: case C11 :@expr4109 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var359 ) {
77: if (@expr1073745936 std@var359 ==@expr1073745937 "c89" ) {
78: return Standards ::@expr1073745938 C89 ;
79: }
80: if (@expr1073745939 std@var359 ==@expr1073745940 "c99" ) {
81: return Standards ::@expr1073745941 C99 ;
82: }
83: if (@expr1073745942 std@var359 ==@expr1073745943 "c11" ) {
84: return Standards ::@expr1073745944 C11 ;
85: }
86: return Standards ::@expr1073745945 CLatest ;
87: }
88: bool setCPP ( std :: string str@var360 ) {
89: stdValue@var357 =@expr1073745946 str@var360 ;
90: strTolower (@expr1073745947 str@var360 ) ;
91: cpp@var356 =@expr1073745948 getCPP (@expr1073745949 str@var360 ) ;
92: return !@expr1073745950 stdValue@var357 .@expr1073745951 empty (@expr1073745952 ) &&@expr1073745953 str@var360 ==@expr1073745954 getCPP (@expr1073745955 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745956 cpp@var356 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var361 ) {
98: switch (@expr1073745957 std@var361 ) {
99: case CPP03 :@expr4134 ;
100: return "c++03" ;
101: case CPP11 :@expr4134 ;
102: return "c++11" ;
103: case CPP14 :@expr4134 ;
104: return "c++14" ;
105: case CPP17 :@expr4134 ;
106: return "c++17" ;
107: case CPP20 :@expr4134 ;
108: return "c++20" ;
109: case CPP23 :@expr4134 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var362 ) {
115: if (@expr1073745964 std@var362 ==@expr1073745965 "c++03" ) {
116: return Standards ::@expr1073745966 CPP03 ;
117: }
118: if (@expr1073745967 std@var362 ==@expr1073745968 "c++11" ) {
119: return Standards ::@expr1073745969 CPP11 ;
120: }
121: if (@expr1073745970 std@var362 ==@expr1073745971 "c++14" ) {
122: return Standards ::@expr1073745972 CPP14 ;
123: }
124: if (@expr1073745973 std@var362 ==@expr1073745974 "c++17" ) {
125: return Standards ::@expr1073745975 CPP17 ;
126: }
127: if (@expr1073745976 std@var362 ==@expr1073745977 "c++20" ) {
128: return Standards ::@expr1073745978 CPP20 ;
129: }
130: if (@expr1073745979 std@var362 ==@expr1073745980 "c++23" ) {
131: return Standards ::@expr1073745981 CPP23 ;
132: }
133: return Standards ::@expr1073745982 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var366 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var363 ) : errorcode@var366 ( e@var363 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var364 , T && r@var365 ) : errorcode@var366 ( e@var364 ) , reason@var367 ( r@var365 ) { }
66: ErrorCode errorcode@var366 ;
67: std :: string reason@var367 ;
68: } ;
69:
70: Error load ( const char exename@var368 [ ] , const char path@var369 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var370 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var371 [ ] , unsigned long len@var372 ) ;
75:
76: struct AllocFunc {
77: int groupId@var373 ;
78: int arg@var374 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var375 ;
81: int bufferSizeArg1@var376 ;
82: int bufferSizeArg2@var377 ;
83: int reallocArg@var378 ;
84: bool initData@var379 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var380 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var381 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var382 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var383 , int arg@var384 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var385 , int arg@var386 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var387 , int arg@var388 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var389 [ ] ) const {
107: return getAllocDealloc (@expr1073745983 mAlloc@var655 , name@var389 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var390 [ ] ) const {
112: return getAllocDealloc (@expr1073745984 mDealloc@var656 , name@var390 ) ;
113: }
114:
115:
116: int allocId ( const char name@var391 [ ] ) const {
117: const AllocFunc * af@var392 ; af@var392 =@expr1073745985 getAllocDealloc (@expr1073745986 mAlloc@var655 , name@var391 ) ;
118: return af@var392 ?@expr1073745987 af@var392 .@expr1073745988 groupId@var393 :@expr1073745989 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var394 [ ] ) const {
123: const AllocFunc * af@var395 ; af@var395 =@expr1073745990 getAllocDealloc (@expr1073745991 mDealloc@var656 , name@var394 ) ;
124: return af@var395 ?@expr1073745992 af@var395 .@expr1073745993 groupId@var396 :@expr1073745994 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var397 , int id@var398 , int arg@var399 ) {
129: mAlloc@var655 [@expr4171 functionname@var397 ] .@expr1073745996 groupId@var3744 =@expr1073745997 id@var398 ;
130: mAlloc@var655 [@expr4171 functionname@var397 ] .@expr1073745999 arg@var3745 =@expr1073746000 arg@var399 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var400 , int id@var401 , int arg@var402 ) {
134: mDealloc@var656 [@expr4177 functionname@var400 ] .@expr1073746002 groupId@var3746 =@expr1073746003 id@var401 ;
135: mDealloc@var656 [@expr4177 functionname@var400 ] .@expr1073746005 arg@var3747 =@expr1073746006 arg@var402 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var403 , int id@var404 , int arg@var405 , int reallocArg@var406 = 1 ) {
139: mRealloc@var657 [@expr4183 functionname@var403 ] .@expr1073746008 groupId@var3748 =@expr1073746009 id@var404 ;
140: mRealloc@var657 [@expr4183 functionname@var403 ] .@expr1073746011 arg@var3749 =@expr1073746012 arg@var405 ;
141: mRealloc@var657 [@expr4183 functionname@var403 ] .@expr1073746014 reallocArg@var3750 =@expr1073746015 reallocArg@var406 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var407 , bool noreturn@var408 ) {
146: mNoReturn@var658 [@expr1073746016 funcname@var407 ] =@expr1073746017 noreturn@var408 ?@expr1073746018 FalseTrueMaybe ::@expr1073746019 True :@expr1073746020 FalseTrueMaybe ::@expr1073746021 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var409 ) ;
150:
151:
152: static bool ismemory ( const int id@var410 ) {
153: return (@expr4198 (@expr4198 id@var410 >@expr1073746024 0 ) &&@expr1073746025 (@expr4198 (@expr4198 id@var410 &@expr1073746028 1 ) ==@expr1073746029 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var411 ) {
156: return (@expr4206 (@expr4206 func@var411 .@expr4208 groupId@var412 >@expr1073746033 0 ) &&@expr1073746034 (@expr4206 (@expr4206 func@var411 .@expr4208 groupId@var412 &@expr1073746038 1 ) ==@expr1073746039 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var413 ) {
161: return (@expr4216 (@expr4216 id@var413 >@expr1073746042 0 ) &&@expr1073746043 (@expr4216 (@expr4216 id@var413 &@expr1073746046 1 ) ==@expr1073746047 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var414 ) {
164: return (@expr4224 (@expr4224 func@var414 .@expr4226 groupId@var415 >@expr1073746051 0 ) &&@expr1073746052 (@expr4224 (@expr4224 func@var414 .@expr4226 groupId@var415 &@expr1073746056 1 ) ==@expr1073746057 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var416 ) const ;
168: int formatstr_argno ( const Token * ftok@var417 ) const ;
169: bool formatstr_scan ( const Token * ftok@var418 ) const ;
170: bool formatstr_secure ( const Token * ftok@var419 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var420 ;
174: int ptr2Arg@var421 ;
175: int sizeArg@var422 ;
176: int strlenArg@var423 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var424 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var425 ;
182: Standards standards@var426 ;
183: Severity :: SeverityType severity@var427 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var428 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var429 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var430 ) const ;
191: bool matchArguments ( const Token * ftok@var431 , const std :: string & functionName@var432 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var433 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var434 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var435 ) const ;
198: int returnValueContainer ( const Token * ftok@var436 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var437 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var438 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var439 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var440 , std :: string * unknownFunc@var441 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var451 ( -1 ) ,
210: size_templateArgNo@var453 ( -1 ) ,
211: arrayLike_indexOp@var454 ( false ) ,
212: stdStringLike@var455 ( false ) ,
213: stdAssociativeLike@var456 ( false ) ,
214: opLessAllowed@var457 ( true ) ,
215: hasInitializerListConstructor@var458 ( false ) ,
216: unstableErase@var459 ( false ) ,
217: unstableInsert@var460 ( false ) ,
218: view@var461 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var442 ;
248: Yield yield@var443 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var444 ;
252: int templateParameter@var445 ;
253: } ;
254: std :: string startPattern@var446 ; std :: string startPattern2@var447 ; std :: string endPattern@var448 ; std :: string itEndPattern@var449 ;
255: std :: map < std :: string , Function > functions@var450 ;
256: int type_templateArgNo@var451 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var452 ;
258: int size_templateArgNo@var453 ;
259: bool arrayLike_indexOp@var454 ;
260: bool stdStringLike@var455 ;
261: bool stdAssociativeLike@var456 ;
262: bool opLessAllowed@var457 ;
263: bool hasInitializerListConstructor@var458 ;
264: bool unstableErase@var459 ;
265: bool unstableInsert@var460 ;
266: bool view@var461 ;
267:
268: Action getAction ( const std :: string & function@var462 ) const {
269: const std ::@expr1073746058 map < std ::@expr1073746059 string , Function > ::@expr1073746060 const_iterator i@var463 =@expr1073746061 functions@var450 .@expr1073746062 find (@expr1073746063 function@var462 ) ;
270: if (@expr1073746064 i@var463 !=@expr1073746065 functions@var450 .@expr1073746066 end (@expr1073746067 ) ) {
271: return i@var463 .@expr1073746068 second@var464 .@expr1073746069 action@var465 ; }
272: return Action ::@expr1073746070 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var466 ) const {
276: const std ::@expr1073746071 map < std ::@expr1073746072 string , Function > ::@expr1073746073 const_iterator i@var467 =@expr1073746074 functions@var450 .@expr1073746075 find (@expr1073746076 function@var466 ) ;
277: if (@expr1073746077 i@var467 !=@expr1073746078 functions@var450 .@expr1073746079 end (@expr1073746080 ) ) {
278: return i@var467 .@expr1073746081 second@var468 .@expr1073746082 yield@var469 ; }
279: return Yield ::@expr1073746083 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var470 ) ;
283: static Action actionFrom ( const std :: string & actionName@var471 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var472 ;
286: const Container * detectContainer ( const Token * typeStart@var473 , bool iterator@var474 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var475 , bool * isIterator@var476 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var477 ( false ) ,
293: notnull@var478 ( false ) ,
294: notuninit@var479 ( -1 ) ,
295: formatstr@var480 ( false ) ,
296: strz@var481 ( false ) ,
297: optional@var482 ( false ) ,
298: variadic@var483 ( false ) ,
299: iteratorInfo@var489 ( ) ,
300: direction@var497 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var477 ;
303: bool notnull@var478 ;
304: int notuninit@var479 ;
305: bool formatstr@var480 ;
306: bool strz@var481 ;
307: bool optional@var482 ;
308: bool variadic@var483 ;
309: std :: string valid@var484 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var485 ( 0 ) , it@var486 ( false ) , first@var487 ( false ) , last@var488 ( false ) { }
314:
315: int container@var485 ;
316: bool it@var486 ;
317: bool first@var487 ;
318: bool last@var488 ;
319: } ;
320: IteratorInfo iteratorInfo@var489 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var490 , int a@var491 ) : type@var492 ( t@var490 ) , arg@var493 ( a@var491 ) , arg2@var494 ( 0 ) , value@var495 ( 0 ) { }
326: Type type@var492 ;
327: int arg@var493 ;
328: int arg2@var494 ;
329: long long value@var495 ;
330: } ;
331: std :: vector < MinSize > minsizes@var496 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var497 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var498 ;
344: bool use@var499 ;
345: bool leakignore@var500 ;
346: bool isconst@var501 ;
347: bool ispure@var502 ;
348: UseRetValType useretval@var503 ;
349: bool ignore@var504 ;
350: bool formatstr@var505 ;
351: bool formatstr_scan@var506 ;
352: bool formatstr_secure@var507 ;
353: Container :: Action containerAction@var508 ;
354: Container :: Yield containerYield@var509 ;
355: Function ( )
356: : use@var499 ( false ) ,
357: leakignore@var500 ( false ) ,
358: isconst@var501 ( false ) ,
359: ispure@var502 ( false ) ,
360: useretval@var503 ( UseRetValType :: NONE ) ,
361: ignore@var504 ( false ) ,
362: formatstr@var505 ( false ) ,
363: formatstr_scan@var506 ( false ) ,
364: formatstr_secure@var507 ( false ) ,
365: containerAction@var508 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var509 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var510 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var511 ;
372: bool isUse ( const std :: string & functionName@var512 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var513 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var514 , bool pure@var515 ) const ;
375: bool isFunctionConst ( const Token * ftok@var516 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var517 , int argnr@var518 ) const {
378: const ArgumentChecks * arg@var519 ; arg@var519 =@expr1073746084 getarg (@expr1073746085 ftok@var517 , argnr@var518 ) ;
379: return arg@var519 &&@expr1073746086 arg@var519 .@expr1073746087 notbool@var520 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var521 , int argnr@var522 ) const ;
383: bool isuninitargbad ( const Token * ftok@var523 , int argnr@var524 , int indirect@var525 = 0 , bool * hasIndirect@var526 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var527 , int argnr@var528 ) const {
386: const ArgumentChecks * arg@var529 ; arg@var529 =@expr1073746088 getarg (@expr1073746089 ftok@var527 , argnr@var528 ) ;
387: return arg@var529 &&@expr1073746090 arg@var529 .@expr1073746091 formatstr@var530 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var531 , int argnr@var532 ) const {
391: const ArgumentChecks * arg@var533 ; arg@var533 =@expr1073746092 getarg (@expr1073746093 ftok@var531 , argnr@var532 ) ;
392: return arg@var533 &&@expr1073746094 arg@var533 .@expr1073746095 strz@var534 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var535 , int argnr@var536 , const long long argvalue@var537 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var538 , int argnr@var539 , double argvalue@var540 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var541 , int argnr@var542 ) const {
399: const ArgumentChecks * arg@var543 ; arg@var543 =@expr1073746096 getarg (@expr1073746097 ftok@var541 , argnr@var542 ) ;
400: return arg@var543 ?@expr1073746098 arg@var543 .@expr1073746099 valid@var544 :@expr1073746100 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var545 ;
405: std :: string op1@var546 ;
406: std :: string op2@var547 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073746101 isInt (@expr1073746102 op1@var546 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var548 , int argnr@var549 ) const {
413: const ArgumentChecks * arg@var550 ; arg@var550 =@expr1073746103 getarg (@expr1073746104 ftok@var548 , argnr@var549 ) ;
414: return arg@var550 &&@expr1073746105 arg@var550 .@expr4282 iteratorInfo@var551 .@expr1073746107 it@var552 ?@expr1073746108 &@expr1073746109 arg@var550 .@expr4282 iteratorInfo@var551 :@expr1073746111 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var553 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var554 , int argnr@var555 ) const {
420: const ArgumentChecks * arg@var556 ; arg@var556 =@expr1073746112 getarg (@expr1073746113 ftok@var554 , argnr@var555 ) ;
421: return arg@var556 ?@expr1073746114 &@expr1073746115 arg@var556 .@expr1073746116 minsizes@var557 :@expr1073746117 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var558 , int argnr@var559 ) const ;
425:
426: bool markupFile ( const std :: string & path@var560 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var561 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var665 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var562 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var563 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var564 , const std :: string & token@var565 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var566 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var567 ) const ;
443: const std :: string & blockend ( const std :: string & file@var568 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var569 , const std :: string & keyword@var570 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var571 ) const {
448: return mExporters@var668 .@expr1073746118 find (@expr1073746119 prefix@var571 ) !=@expr1073746120 mExporters@var668 .@expr1073746121 end (@expr1073746122 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var572 , const std :: string & token@var573 ) const {
452: const std ::@expr1073746123 map < std ::@expr1073746124 string , ExportedFunctions > ::@expr1073746125 const_iterator it@var574 =@expr1073746126 mExporters@var668 .@expr1073746127 find (@expr1073746128 prefix@var572 ) ;
453: return (@expr1073746129 it@var574 !=@expr1073746130 mExporters@var668 .@expr1073746131 end (@expr1073746132 ) &&@expr1073746133 it@var574 .@expr1073746134 second@var575 .@expr1073746135 isPrefix (@expr1073746136 token@var573 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var576 , const std :: string & token@var577 ) const {
457: const std ::@expr1073746137 map < std ::@expr1073746138 string , ExportedFunctions > ::@expr1073746139 const_iterator it@var578 =@expr1073746140 mExporters@var668 .@expr1073746141 find (@expr1073746142 prefix@var576 ) ;
458: return (@expr1073746143 it@var578 !=@expr1073746144 mExporters@var668 .@expr1073746145 end (@expr1073746146 ) &&@expr1073746147 it@var578 .@expr1073746148 second@var579 .@expr1073746149 isSuffix (@expr1073746150 token@var577 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var580 , const std :: string & importer@var581 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var582 , Container :: Yield yield@var583 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var584 , Container :: Action action@var585 ) const ;
465:
466: bool isreflection ( const std :: string & token@var586 ) const {
467: return mReflection@var670 .@expr1073746151 find (@expr1073746152 token@var586 ) !=@expr1073746153 mReflection@var670 .@expr1073746154 end (@expr1073746155 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var587 ) const {
471: const std ::@expr1073746156 map < std ::@expr1073746157 string , int > ::@expr1073746158 const_iterator it@var588 =@expr1073746159 mReflection@var670 .@expr1073746160 find (@expr1073746161 token@var587 ) ;
472: if (@expr1073746162 it@var588 !=@expr1073746163 mReflection@var670 .@expr1073746164 end (@expr1073746165 ) ) {
473: return it@var588 .@expr1073746166 second@var589 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var590 ;
478:
479: struct SmartPointer {
480: std :: string name@var591 ; name@var591 = "" ;
481: bool unique@var592 ; unique@var592 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var593 ;
485: bool isSmartPointer ( const Token * tok@var594 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var595 ) const ;
487:
488: struct PodType {
489: unsigned int size@var596 ;
490: char sign@var597 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var598 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var599 ) const {
494: const std ::@expr1073746167 unordered_map < std ::@expr1073746168 string , PodType > ::@expr1073746169 const_iterator it@var600 =@expr1073746170 mPodTypes@var671 .@expr1073746171 find (@expr1073746172 name@var599 ) ;
495: return (@expr4349 it@var600 !=@expr1073746174 mPodTypes@var671 .@expr1073746175 end (@expr1073746176 ) ) ?@expr1073746177 &@expr1073746178 (@expr4349 it@var600 .@expr1073746180 second@var601 ) :@expr1073746181 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var612 ( false )
501: , mUnsigned@var613 ( false )
502: , mLong@var614 ( false )
503: , mPointer@var615 ( false )
504: , mPtrPtr@var616 ( false )
505: , mConstPtr@var617 ( false ) { }
506: bool operator== ( const PlatformType & type@var602 ) const {
507: return (@expr1073746182 mSigned@var612 ==@expr1073746183 type@var602 .@expr1073746184 mSigned@var603 &&@expr1073746185
508: mUnsigned@var613 ==@expr1073746186 type@var602 .@expr1073746187 mUnsigned@var604 &&@expr1073746188
509: mLong@var614 ==@expr1073746189 type@var602 .@expr1073746190 mLong@var605 &&@expr1073746191
510: mPointer@var615 ==@expr1073746192 type@var602 .@expr1073746193 mPointer@var606 &&@expr1073746194
511: mPtrPtr@var616 ==@expr1073746195 type@var602 .@expr1073746196 mPtrPtr@var607 &&@expr1073746197
512: mConstPtr@var617 ==@expr1073746198 type@var602 .@expr1073746199 mConstPtr@var608 &&@expr1073746200
513: mType@var611 ==@expr1073746201 type@var602 .@expr1073746202 mType@var609 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var610 ) const {
516: return !@expr1073746203 (@expr1073746204 *@expr1073746205 this@expr1073746206 ==@expr1073746207 type@var610 ) ;
517: }
518: std :: string mType@var611 ;
519: bool mSigned@var612 ;
520: bool mUnsigned@var613 ;
521: bool mLong@var614 ;
522: bool mPointer@var615 ;
523: bool mPtrPtr@var616 ;
524: bool mConstPtr@var617 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var618 ) const {
529: const std ::@expr1073746208 map < std ::@expr1073746209 string , PlatformType > ::@expr1073746210 const_iterator it@var619 =@expr1073746211 mPlatformTypes@var621 .@expr1073746212 find (@expr1073746213 name@var618 ) ;
530: return (@expr4390 it@var619 !=@expr1073746215 mPlatformTypes@var621 .@expr1073746216 end (@expr1073746217 ) ) ?@expr1073746218 &@expr1073746219 (@expr4390 it@var619 .@expr1073746221 second@var620 ) :@expr1073746222 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var621 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var622 , const std :: string & platform@var623 ) const {
536: const std ::@expr1073746223 map < std ::@expr4400 string , Platform > ::@expr1073746225 const_iterator it@var624 =@expr1073746226 mPlatforms@var673 .@expr1073746227 find (@expr1073746228 platform@var623 ) ;
537: if (@expr1073746229 it@var624 !=@expr1073746230 mPlatforms@var673 .@expr1073746231 end (@expr1073746232 ) ) {
538: const PlatformType * const type@var625 ; type@var625 =@expr1073746233 it@var624 .@expr1073746234 second@var626 .@expr1073746235 platform_type (@expr1073746236 name@var622 ) ;
539: if (@expr1073746237 type@var625 ) {
540: return type@var625 ; }
541: }
542:
543: const std ::@expr1073746238 map < std ::@expr4400 string , PlatformType > ::@expr1073746240 const_iterator it2@var627 =@expr1073746241 mPlatformTypes@var672 .@expr1073746242 find (@expr1073746243 name@var622 ) ;
544: return (@expr4420 it2@var627 !=@expr1073746245 mPlatformTypes@var672 .@expr1073746246 end (@expr1073746247 ) ) ?@expr1073746248 &@expr1073746249 (@expr4420 it2@var627 .@expr1073746251 second@var628 ) :@expr1073746252 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var629 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var630 , Library :: Container :: Yield y@var631 , const std :: string & fallback@var632 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var633 , const std :: string & typeName@var634 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var635 , const std :: string & name@var636 , std :: set < std :: string > & unknown_elements@var637 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var638 ) {
565: mPrefixes@var642 .@expr1073746253 insert (@expr1073746254 prefix@var638 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var639 ) {
568: mSuffixes@var643 .@expr1073746255 insert (@expr1073746256 suffix@var639 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var640 ) const {
571: return (@expr1073746257 mPrefixes@var642 .@expr1073746258 find (@expr1073746259 prefix@var640 ) !=@expr1073746260 mPrefixes@var642 .@expr1073746261 end (@expr1073746262 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var641 ) const {
574: return (@expr1073746263 mSuffixes@var643 .@expr1073746264 find (@expr1073746265 suffix@var641 ) !=@expr1073746266 mSuffixes@var643 .@expr1073746267 end (@expr1073746268 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var642 ;
579: std :: set < std :: string > mSuffixes@var643 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var651 ( 0 ) { }
584:
585: void setStart ( const char * s@var644 ) {
586: mStart@var649 =@expr1073746269 s@var644 ;
587: }
588: void setEnd ( const char * e@var645 ) {
589: mEnd@var650 =@expr1073746270 e@var645 ;
590: }
591: void setOffset ( const int o@var646 ) {
592: mOffset@var651 =@expr1073746271 o@var646 ;
593: }
594: void addBlock ( const char * blockName@var647 ) {
595: mBlocks@var652 .@expr1073746272 insert (@expr1073746273 blockName@var647 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var649 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var650 ;
602: }
603: int offset ( ) const {
604: return mOffset@var651 ;
605: }
606: bool isBlock ( const std :: string & blockName@var648 ) const {
607: return mBlocks@var652 .@expr1073746274 find (@expr1073746275 blockName@var648 ) !=@expr1073746276 mBlocks@var652 .@expr1073746277 end (@expr1073746278 ) ;
608: }
609:
610: private:
611: std :: string mStart@var649 ;
612: std :: string mEnd@var650 ;
613: int mOffset@var651 ;
614: std :: set < std :: string > mBlocks@var652 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var653 ;
618: std :: set < std :: string > mFiles@var654 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var655 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var656 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var657 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var658 ;
623: std :: map < std :: string , std :: string > mReturnValue@var659 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var660 ;
625: std :: map < std :: string , int > mReturnValueContainer@var661 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var662 ;
627: std :: map < std :: string , bool > mReportErrors@var663 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var664 ;
629: std :: set < std :: string > mMarkupExtensions@var665 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var666 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var667 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var668 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var669 ;
634: std :: map < std :: string , int > mReflection@var670 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var671 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var672 ;
637: std :: map < std :: string , Platform > mPlatforms@var673 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var674 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var675 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var676 , int argnr@var677 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var678 , bool * error@var679 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var680 , const std :: string & name@var681 ) {
646: const std ::@expr1073746279 map < std ::@expr1073746280 string , AllocFunc > ::@expr1073746281 const_iterator it@var682 =@expr1073746282 data@var680 .@expr1073746283 find (@expr1073746284 name@var681 ) ;
647: return (@expr1073746285 it@var682 ==@expr1073746286 data@var680 .@expr1073746287 end (@expr1073746288 ) ) ?@expr1073746289 nullptr :@expr1073746290 &@expr1073746291 it@var682 .@expr1073746292 second@var683 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var684 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var685 ,
654: const Settings * settings@var686 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var687 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var688 ) const {
54: x@var688 ++@expr1073746293 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var689 ) const {
60: x@var689 --@expr1073746294 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var690 , const U & y@var691 ) const {
67: return x@var690 <@expr1073746295 y@var691 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var692 , const U & y@var693 ) const {
74: return std ::@expr1073746296 abs (@expr1073746297 x@var692 -@expr1073746298 y@var693 ) ==@expr1073746299 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var694 , T x@var695 , U y@var696 ) const {
81: result@var694 =@expr1073746300 !@expr1073746301 (@expr1073746302 x@var695 >@expr1073746303 y@var696 ||@expr1073746304 x@var695 <@expr1073746305 y@var696 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var697 = 0 , Bound b@var698 = Bound :: Point )
91: : valueType@var738 ( ValueType :: INT ) ,
92: bound@var739 ( b@var698 ) ,
93: intvalue@var740 ( val@var697 ) ,
94: tokvalue@var741 ( nullptr ) ,
95: floatValue@var742 ( 0.0 ) ,
96: moveKind@var743 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var744 ( val@var697 ) ,
98: condition@var745 ( nullptr ) ,
99: varId@var747 ( 0U ) ,
100: safe@var748 ( false ) ,
101: conditional@var749 ( false ) ,
102: macro@var750 ( false ) ,
103: defaultArg@var751 ( false ) ,
104: indirect@var752 ( 0 ) ,
105: path@var753 ( 0 ) ,
106: wideintvalue@var754 ( val@var697 ) ,
107: subexpressions@var755 ( ) ,
108: capturetok@var756 ( nullptr ) ,
109: lifetimeKind@var757 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var758 ( LifetimeScope :: Local ) ,
111: valueKind@var763 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var699 , long long val@var700 , Bound b@var701 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var702 ) const {
118: if (@expr1073746306 valueType@var738 !=@expr1073746307 rhs@var702 .@expr1073746308 valueType@var703 ) {
119: return false ; }
120: switch (@expr1073746309 valueType@var738 ) {
121: case ValueType ::@expr1073746310 INT :@expr4487
122: case ValueType ::@expr1073746312 CONTAINER_SIZE :@expr4487
123: case ValueType ::@expr1073746314 BUFFER_SIZE :@expr4487
124: case ValueType ::@expr1073746316 ITERATOR_START :@expr4487
125: case ValueType ::@expr1073746318 ITERATOR_END :@expr4487 ;
126: if (@expr4496 intvalue@var740 !=@expr4497 rhs@var702 .@expr4498 intvalue@var704 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073746323 TOK :@expr4487 ;
130: if (@expr4501 tokvalue@var741 !=@expr4502 rhs@var702 .@expr4503 tokvalue@var705 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073746328 FLOAT :@expr4487 ;
134:
135: if (@expr1073746330 floatValue@var742 >@expr1073746331 rhs@var702 .@expr4508 floatValue@var706 ||@expr1073746333 floatValue@var742 <@expr1073746334 rhs@var702 .@expr4508 floatValue@var706 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073746336 MOVED :@expr4487 ;
139: if (@expr1073746338 moveKind@var743 !=@expr1073746339 rhs@var702 .@expr1073746340 moveKind@var707 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073746341 UNINIT :@expr4487 ;
143: break ;
144: case ValueType ::@expr1073746343 LIFETIME :@expr4487 ;
145: if (@expr4501 tokvalue@var741 !=@expr4502 rhs@var702 .@expr4503 tokvalue@var705 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073746348 SYMBOLIC :@expr4487 ;
149: if (@expr1073746350 !@expr1073746351 sameToken (@expr1073746352 tokvalue@var741 , rhs@var702 .@expr4503 tokvalue@var705 ) ) {
150: return false ; }
151: if (@expr4496 intvalue@var740 !=@expr4497 rhs@var702 .@expr4498 intvalue@var704 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var708 , F f@var709 ) {
160: switch (@expr1073746357 self@var708 .@expr1073746358 valueType@var710 ) {
161: case ValueType ::@expr1073746359 INT :@expr4536
162: case ValueType ::@expr1073746361 SYMBOLIC :@expr4536
163: case ValueType ::@expr1073746363 BUFFER_SIZE :@expr4536
164: case ValueType ::@expr1073746365 CONTAINER_SIZE :@expr4536
165: case ValueType ::@expr1073746367 ITERATOR_START :@expr4536
166: case ValueType ::@expr1073746369 ITERATOR_END :@expr4536 ; {
167: f@var709 (@expr1073746371 self@var708 .@expr1073746372 intvalue@var711 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073746373 FLOAT :@expr4536 ; {
171: f@var709 (@expr1073746375 self@var708 .@expr1073746376 floatValue@var712 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073746377 UNINIT :@expr4536
175: case ValueType ::@expr1073746379 TOK :@expr4536
176: case ValueType ::@expr1073746381 LIFETIME :@expr4536
177: case ValueType ::@expr1073746383 MOVED :@expr4536 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var713 , Compare compare@var714 , T x@var715 , U y@var716 ) const {
186: result@var713 =@expr1073746385 compare@var714 (@expr1073746386 x@var715 , y@var716 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var717 , const Value & rhs@var718 , Compare compare@var719 , T x@var720 ) const {
191: visitValue (@expr1073746388 rhs@var718 ,
192: std ::@expr1073746389 bind (@expr1073746390 innerVisitor {@expr1073746391 } , std ::@expr1073746392 ref (@expr1073746393 result@var717 ) , std ::@expr1073746394 move (@expr1073746395 compare@var719 ) , x@var720 , std ::@expr1073746396 placeholders ::@expr1073746397 _1@expr1073746387 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var721 , Compare compare@var722 ) const {
198: assert (@expr1073746399 (@expr1073746400 !@expr1073746401 this@expr4578 .@expr1073746403 isSymbolicValue (@expr1073746404 ) &&@expr1073746405 !@expr1073746406 rhs@var721 .@expr1073746407 isSymbolicValue (@expr1073746408 ) ) ||@expr1073746409
199: (@expr1073746410 this@expr4578 .@expr1073746411 valueType@var738 ==@expr1073746412 rhs@var721 .@expr1073746413 valueType@var723 &&@expr1073746414 sameToken (@expr1073746415 this@expr4578 .@expr1073746416 tokvalue@var741 , rhs@var721 .@expr1073746417 tokvalue@var724 ) ) ) ;
200: bool result@var725 ; result@var725 =@expr1073746418 false ;
201: visitValue (@expr1073746419
202: *@expr1073746420 this@expr4578 ,
203: std ::@expr1073746421 bind (@expr1073746422 compareVisitor {@expr1073746423 } , std ::@expr4600 ref (@expr1073746425 result@var725 ) , std ::@expr4600 ref (@expr1073746427 rhs@var721 ) , std ::@expr1073746428 move (@expr1073746429 compare@var722 ) , std ::@expr1073746430 placeholders ::@expr1073746431 _1@expr1073746398 ) ) ;
204: return result@var725 ;
205: }
206:
207: bool operator== ( const Value & rhs@var726 ) const {
208: if (@expr1073746432 !@expr1073746433 equalValue (@expr1073746434 rhs@var726 ) ) {
209: return false ; }
210:
211: return varvalue@var744 ==@expr1073746435 rhs@var726 .@expr1073746436 varvalue@var727 &&@expr1073746437
212: condition@var745 ==@expr1073746438 rhs@var726 .@expr1073746439 condition@var728 &&@expr1073746440
213: varId@var747 ==@expr1073746441 rhs@var726 .@expr1073746442 varId@var729 &&@expr1073746443
214: conditional@var749 ==@expr1073746444 rhs@var726 .@expr1073746445 conditional@var730 &&@expr1073746446
215: defaultArg@var751 ==@expr1073746447 rhs@var726 .@expr1073746448 defaultArg@var731 &&@expr1073746449
216: indirect@var752 ==@expr1073746450 rhs@var726 .@expr1073746451 indirect@var732 &&@expr1073746452
217: valueKind@var763 ==@expr1073746453 rhs@var726 .@expr1073746454 valueKind@var733 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var734 ) const {
221: return !@expr1073746455 (@expr1073746456 *@expr1073746457 this@expr1073746458 ==@expr1073746459 rhs@var734 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var735 ) const {
226: bool result@var736 ; result@var736 =@expr1073746461 false ;
227: visitValue (@expr1073746462 *@expr1073746463 this@expr1073746464 , std ::@expr1073746465 bind (@expr1073746466 equalVisitor {@expr1073746467 } , std ::@expr1073746468 ref (@expr1073746469 result@var736 ) , x@var735 , std ::@expr1073746470 placeholders ::@expr1073746471 _1@expr1073746460 ) ) ;
228: return result@var736 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073746472 bound@var739 ==@expr1073746473 Bound ::@expr1073746474 Lower ) {
233: visitValue (@expr1073746475 *@expr4652 this@expr4653 , increment {@expr1073746478 } ) ; }
234: else { if (@expr1073746479 bound@var739 ==@expr1073746480 Bound ::@expr1073746481 Upper ) {
235: visitValue (@expr1073746482 *@expr4652 this@expr4653 , decrement {@expr1073746484 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073746485 bound@var739 ==@expr1073746486 Bound ::@expr4663 Lower ) {
240: bound@var739 =@expr1073746488 Bound ::@expr4665 Upper ; }
241: else { if (@expr1073746490 bound@var739 ==@expr1073746491 Bound ::@expr4665 Upper ) {
242: bound@var739 =@expr1073746493 Bound ::@expr4663 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073746495 ) ;
247: decreaseRange (@expr1073746496 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var737 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var738 ;
267: bool isIntValue ( ) const {
268: return valueType@var738 ==@expr1073746497 ValueType ::@expr1073746498 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var738 ==@expr1073746499 ValueType ::@expr1073746500 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var738 ==@expr1073746501 ValueType ::@expr1073746502 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var738 ==@expr1073746503 ValueType ::@expr1073746504 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var738 ==@expr1073746505 ValueType ::@expr1073746506 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var738 ==@expr1073746507 ValueType ::@expr1073746508 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var738 ==@expr1073746509 ValueType ::@expr1073746510 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var738 ==@expr1073746511 ValueType ::@expr1073746512 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var738 ==@expr1073746513 ValueType ::@expr1073746514 ITERATOR_START ||@expr1073746515 valueType@var738 ==@expr1073746516 ValueType ::@expr1073746517 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var738 ==@expr1073746518 ValueType ::@expr1073746519 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var738 ==@expr1073746520 ValueType ::@expr1073746521 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var738 ==@expr1073746522 ValueType ::@expr1073746523 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var738 ==@expr1073746525 ValueType ::@expr1073746526 LIFETIME &&@expr1073746527 lifetimeScope@var758 ==@expr1073746528 LifetimeScope ::@expr1073746529 Local@expr1073746524 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var738 ==@expr1073746530 ValueType ::@expr1073746531 LIFETIME &&@expr1073746532 lifetimeScope@var758 ==@expr1073746533 LifetimeScope ::@expr1073746534 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var738 ==@expr1073746535 ValueType ::@expr1073746536 LIFETIME &&@expr1073746537 lifetimeScope@var758 ==@expr1073746538 LifetimeScope ::@expr1073746539 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073746540 ) ||@expr1073746541 isUninitValue (@expr1073746542 ) ||@expr1073746543 isLifetimeValue (@expr1073746544 ) ;
318: }
319:
320:
321: Bound bound@var739 ;
322:
323:
324: long long intvalue@var740 ;
325:
326:
327: const Token * tokvalue@var741 ;
328:
329:
330: double floatValue@var742 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var743 ;
334:
335:
336: long long varvalue@var744 ;
337:
338:
339: const Token * condition@var745 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var746 ;
342:
343:
344: int varId@var747 ;
345:
346:
347: bool safe@var748 ;
348:
349:
350: bool conditional@var749 ;
351:
352:
353: bool macro@var750 ;
354:
355:
356: bool defaultArg@var751 ;
357:
358: int indirect@var752 ;
359:
360:
361: long long path@var753 ;
362:
363:
364: long long wideintvalue@var754 ;
365:
366: std :: vector < std :: string > subexpressions@var755 ;
367:
368:
369: const Token * capturetok@var756 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var757 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var758 ;
385:
386: static const char * toString ( MoveKind moveKind@var759 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var760 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var761 ) ;
389: static const char * toString ( Bound bound@var762 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var763 ;
402:
403: void setKnown ( ) {
404: valueKind@var763 =@expr1073746545 ValueKind ::@expr1073746546 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var763 ==@expr1073746547 ValueKind ::@expr1073746548 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var763 =@expr1073746550 ValueKind ::@expr1073746551 Possible@expr1073746549 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var763 ==@expr1073746553 ValueKind ::@expr1073746554 Possible@expr1073746552 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var763 ==@expr1073746555 ValueKind ::@expr1073746556 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var763 =@expr1073746557 ValueKind ::@expr1073746558 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var764 = true ) {
428: if (@expr1073746559 inconclusive@var764 ) {
429: valueKind@var763 =@expr1073746560 ValueKind ::@expr1073746561 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var763 ==@expr1073746562 ValueKind ::@expr1073746563 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073746565 isKnown (@expr1073746566 ) ) {
438: valueKind@var763 =@expr1073746567 ValueKind ::@expr1073746568 Possible@expr1073746564 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073746569 condition@var745 &&@expr1073746570 !@expr1073746571 defaultArg@var751 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var765 , const Token * tok2@var766 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var767 , const Settings * settings@var768 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var769 , SymbolDatabase * symboldatabase@var770 , ErrorLogger * errorLogger@var771 , const Settings * settings@var772 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var773 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var774 , const Settings * settings@var775 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var776 ,
459: const Settings * settings@var777 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var778 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var779 , const Token * indexTok@var780 , bool possible@var781 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var782 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var783 , const Settings * settings@var784 = nullptr , int depth@var785 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var786 ;
471: bool addressOf@var787 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var788 ;
473: bool inconclusive@var789 ;
474:
475: LifetimeToken ( ) : token@var786 ( nullptr ) , addressOf@var787 ( false ) , errorPath@var788 ( ) , inconclusive@var789 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var790 , ValueFlow :: Value :: ErrorPath errorPath@var791 )
478: : token@var786 ( token@var790 ) , addressOf@var787 ( false ) , errorPath@var788 ( std :: move ( errorPath@var791 ) ) , inconclusive@var789 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var792 , bool addressOf@var793 , ValueFlow :: Value :: ErrorPath errorPath@var794 )
482: : token@var786 ( token@var792 ) , addressOf@var787 ( addressOf@var793 ) , errorPath@var788 ( std :: move ( errorPath@var794 ) ) , inconclusive@var789 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var795 , bool b@var796 ) {
486: for (@expr1073746572 LifetimeToken &@expr1073746573 x@var797 :@expr1073746574 v@var795 ) {
487: x@var797 .@expr1073746575 addressOf@var798 =@expr1073746576 b@var796 ; }
488: return v@var795 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var799 , bool b@var800 ) {
492: for (@expr1073746577 LifetimeToken &@expr1073746578 x@var801 :@expr1073746579 v@var799 ) {
493: x@var801 .@expr1073746580 inconclusive@var802 =@expr1073746581 b@var800 ; }
494: return v@var799 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var803 , ValueFlow :: Value & true_value@var804 , ValueFlow :: Value & false_value@var805 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var806 ) ;
499: const Token * parseCompareInt ( const Token * tok@var807 , ValueFlow :: Value & true_value@var808 , ValueFlow :: Value & false_value@var809 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var810 , long long val@var811 , const Token * varTok@var812 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var813 , const Token * varTok@var814 , long long val@var815 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var816 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var817 ,
508: ValueFlow :: Value & value@var818 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var819 ,
511: bool escape@var820 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var821 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var822 , const Token * lifetime@var823 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var824 , ValueFlow :: Value :: ErrorPath & errorPath@var825 , bool * addressOf@var826 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var827 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var828 , const Settings * settings@var829 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var830 , const ValueFlow :: Value * val@var831 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var832 , const ValueFlow :: Value * val@var833 , ValueFlow :: Value :: ErrorPath & errorPath@var834 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var835 , bool inconclusive@var836 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var837 ,
529: bool inconclusive@var838 = false ,
530: long long path@var839 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var840 , const Scope * defaultScope@var841 = nullptr , bool smallest@var842 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var843 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var844 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var845 ;
69: std :: string mScope@var846 ;
70: std :: string mName@var847 ;
71: std :: string mFullName@var848 ;
72: const Token * mNameToken@var849 ;
73: const Token * mParamEnd@var850 ;
74: unsigned int mFlags@var851 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var852 ) {
90: setFlag (@expr1073746582 fIsClass , state@var852 ) ;
91: }
92: void isFunction ( bool state@var853 ) {
93: setFlag (@expr1073746583 fIsFunction , state@var853 ) ;
94: }
95: void isVariable ( bool state@var854 ) {
96: setFlag (@expr1073746584 fIsVariable , state@var854 ) ;
97: }
98: void isAlias ( bool state@var855 ) {
99: setFlag (@expr1073746585 fIsAlias , state@var855 ) ;
100: }
101: void isSpecialization ( bool state@var856 ) {
102: setFlag (@expr1073746586 fIsSpecialization , state@var856 ) ;
103: }
104: void isPartialSpecialization ( bool state@var857 ) {
105: setFlag (@expr1073746587 fIsPartialSpecialization , state@var857 ) ;
106: }
107: void isForwardDeclaration ( bool state@var858 ) {
108: setFlag (@expr1073746588 fIsForwardDeclaration , state@var858 ) ;
109: }
110: void isVariadic ( bool state@var859 ) {
111: setFlag (@expr1073746589 fIsVariadic , state@var859 ) ;
112: }
113: void isFriend ( bool state@var860 ) {
114: setFlag (@expr1073746590 fIsFriend , state@var860 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var861 ) const {
123: return (@expr4767 (@expr4767 mFlags@var851 &@expr1073746593 flag@var861 ) !=@expr1073746594 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var862 , bool state@var863 ) {
132: mFlags@var851 =@expr1073746595 state@var863 ?@expr1073746596 mFlags@var851 |@expr1073746597 flag@var862 :@expr1073746598 mFlags@var851 &@expr1073746599 ~@expr1073746600 flag@var862 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var864 , const std :: string & scope@var865 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var866 , const std :: string & scope@var867 , const Token * nameToken@var868 , const Token * paramEnd@var869 ) ;
150: TokenAndName ( const TokenAndName & other@var870 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var871 ) const {
154: return mToken@var845 ==@expr1073746601 rhs@var871 .@expr1073746602 mToken@var872 &&@expr1073746603 mScope@var846 ==@expr1073746604 rhs@var871 .@expr1073746605 mScope@var873 &&@expr1073746606 mName@var847 ==@expr1073746607 rhs@var871 .@expr1073746608 mName@var874 &&@expr1073746609 mFullName@var848 ==@expr1073746610 rhs@var871 .@expr1073746611 mFullName@var875 &&@expr1073746612
155: mNameToken@var849 ==@expr1073746613 rhs@var871 .@expr1073746614 mNameToken@var876 &&@expr1073746615 mParamEnd@var850 ==@expr1073746616 rhs@var871 .@expr1073746617 mParamEnd@var877 &&@expr1073746618 mFlags@var851 ==@expr1073746619 rhs@var871 .@expr1073746620 mFlags@var878 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var845 ;
160: }
161: void token ( Token * token@var879 ) {
162: mToken@var845 =@expr1073746621 token@var879 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var846 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var847 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var848 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var849 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var850 ;
178: }
179: void paramEnd ( const Token * end@var880 ) {
180: mParamEnd@var850 =@expr1073746622 end@var880 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073746623 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073746624 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073746625 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073746626 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073746627 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073746628 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073746629 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073746630 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073746631 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var881 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var882 ) const {
243:
244:
245: return (@expr4808 (@expr4808 mFlags@var851 &@expr1073746634 fFamilyMask ) &@expr1073746635 (@expr4808 decl@var882 .@expr1073746637 mFlags@var883 &@expr1073746638 fFamilyMask ) ) !=@expr1073746639 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var884 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var885 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var886 , const unsigned long numberOfArguments@var887 , bool variadic@var888 , const char patternAfter@var889 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var890 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var891 , int & namepos@var892 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var893 , int & namepos@var894 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var895 , int & namepos@var896 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var897 ,
306: bool & codeWithTemplates@var898 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var899 , bool isTemplate@var900 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var901 = nullptr , Token * backToken@var902 = nullptr , bool isTemplate@var903 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var904 , Token * end@var905 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var906 , const std :: string & scope@var907 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var908 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var909 ,
393: const std :: list < const Token * > & specializations@var910 ,
394: const std :: time_t maxtime@var911 ,
395: std :: set < std :: string > & expandedtemplates@var912 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var913 , const Token * tok@var914 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var915 , const Token * tok@var916 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var917 ,
422: const TokenAndName & templateInstantiation@var918 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var919 ,
424: const std :: string & newName@var920 ,
425: bool copy@var921 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var922 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var923 ,
435: const std :: string & newName@var924 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var925 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var926 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var927 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var928 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var929 ,
458: const Token * templateInstantiationNameToken@var930 ,
459: const std :: list < const Token * > & specializations@var931 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var932 , const Token * end@var933 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var934 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var935 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var936 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var937 ,
487: const std :: string & indent@var938 = "    " ) const ;
488: void printOut ( const std :: string & text@var939 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var940 ;
491: TokenList & mTokenList@var941 ;
492: const Settings * mSettings@var942 ;
493: ErrorLogger * mErrorLogger@var943 ;
494: bool mChanged@var944 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var945 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var946 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var947 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var948 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var949 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var950 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var951 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var952 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var953 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var954 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var955 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var956 ;
57: Token * back@var957 ;
58: const TokenList * list@var958 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var959 , const Token * bodyEnd_@var960 , const std :: set < std :: string > & usingNamespaces_@var961 = std :: set < std :: string > ( ) ) : name@var962 ( name_@var959 ) , bodyEnd@var963 ( bodyEnd_@var960 ) , usingNamespaces@var964 ( usingNamespaces_@var961 ) { }
63: std :: string name@var962 ;
64: const Token * const bodyEnd@var963 ;
65: std :: set < std :: string > usingNamespaces@var964 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var965 ;
70: int mFileIndex@var966 ;
71: int mLineNumber@var967 ;
72: int mColumn@var968 ;
73: int mExprId@var969 ;
74:
75:
76: Token * mAstOperand1@var970 ;
77: Token * mAstOperand2@var971 ;
78: Token * mAstParent@var972 ;
79:
80:
81: const Scope * mScope@var973 ;
82: union {
83: const Function * mFunction@var974 ;
84: const Variable * mVariable@var975 ;
85: const :: Type * mType@var976 ;
86: const Enumerator * mEnumerator@var977 ;
87: } ;
88:
|
92:
93: int mProgressValue@var978 ;
94:
|
97:
98: int mIndex@var979 ;
99:
100:
101: std :: string * mOriginalName@var980 ;
102:
103:
104: ValueType * mValueType@var981 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var982 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var983 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var984 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var985 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var986 ;
119: long long value@var987 ;
120: struct CppcheckAttributes * next@var988 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var989 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var990 ;
126:
127:
128: unsigned char mBits@var991 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var992 , long long value@var993 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var994 , long long * value@var995 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var965 ( 0 )
135: , mFileIndex@var966 ( 0 )
136: , mLineNumber@var967 ( 0 )
137: , mColumn@var968 ( 0 )
138: , mExprId@var969 ( 0 )
139: , mAstOperand1@var970 ( nullptr )
140: , mAstOperand2@var971 ( nullptr )
141: , mAstParent@var972 ( nullptr )
142: , mScope@var973 ( nullptr )
143: , mFunction@var974 ( nullptr )
144: , mProgressValue@var978 ( 0 )
145: , mIndex@var979 ( 0 )
146: , mOriginalName@var980 ( nullptr )
147: , mValueType@var981 ( nullptr )
148: , mValues@var982 ( nullptr )
149: , mTemplateSimplifierPointers@var984 ( nullptr )
150: , mScopeInfo@var985 ( nullptr )
151: , mCppcheckAttributes@var989 ( nullptr )
152: , mCpp11init@var990 ( Cpp11init :: UNKNOWN )
153: , mBits@var991 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var996 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var997 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var998 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var999 ) {
199: mStr@var1211 =@expr1073746640 s@var999 ;
200: mImpl@var1217 .@expr1073746641 mVarId@var1248 =@expr1073746642 0 ;
201:
202: update_property_info (@expr1073746643 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1000 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1211 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1001 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1002 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1003 ) const ;
236: Token * tokAt ( int index@var1004 ) {
237: return const_cast < Token *@expr4820 > (@expr1073746645 const_cast < const Token *@expr4820 > (@expr1073746647 this@expr1073746648 ) .@expr1073746649 tokAt (@expr1073746650 index@var1004 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1005 ) const ;
245: Token * linkAt ( int index@var1006 ) {
246: return const_cast < Token *@expr4827 > (@expr1073746652 const_cast < const Token *@expr4827 > (@expr1073746654 this@expr1073746655 ) .@expr1073746656 linkAt (@expr1073746657 index@var1006 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1007 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1008 , const char ( & pattern@var1009 ) [ count ] ) {
276: return simpleMatch (@expr1073746659 tok@var1008 , pattern@var1009 , count@expr1073746658 -@expr1073746660 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1010 , const char pattern@var1011 [ ] , unsigned long pattern_len@var1012 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1013 , const char pattern@var1014 [ ] , int varid@var1015 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1016 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1017 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1018 , const Settings * const settings@var1019 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1020 , long long index@var1021 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1217 .@expr1073746661 mValueType@var1249 ;
366: }
367: void setValueType ( ValueType * vt@var1022 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1023 ; top@var1023 =@expr1073746662 this@expr1073746663 ;
371: while (@expr1073746664 top@var1023 &&@expr1073746665 !@expr1073746666 Token ::@expr1073746667 Match (@expr1073746668 top@var1023 .@expr4845 astParent (@expr4846 ) , ",|(" ) ) {
372: top@var1023 =@expr1073746671 top@var1023 .@expr4845 astParent (@expr4846 ) ; }
373: return top@var1023 ?@expr1073746674 top@var1023 .@expr1073746675 mImpl@var1024 .@expr1073746676 mValueType@var1025 :@expr1073746677 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1215 ;
378: }
379: void tokType ( Token :: Type t@var1026 ) {
380: mTokType@var1215 =@expr1073746678 t@var1026 ;
381:
382: const bool memoizedIsName@var1027 =@expr1073746679 mTokType@var1215 ==@expr1073746680 eName ||@expr1073746681 mTokType@var1215 ==@expr1073746682 eType ||@expr1073746683 mTokType@var1215 ==@expr1073746684 eVariable ||@expr1073746685
383: mTokType@var1215 ==@expr1073746686 eFunction ||@expr1073746687 mTokType@var1215 ==@expr1073746688 eKeyword ||@expr1073746689 mTokType@var1215 ==@expr4866 eBoolean ||@expr1073746691
384: mTokType@var1215 ==@expr4868 eEnumerator ;
385: setFlag (@expr1073746693 fIsName , memoizedIsName@var1027 ) ;
386:
387: const bool memoizedIsLiteral@var1028 =@expr1073746694 mTokType@var1215 ==@expr1073746695 eNumber ||@expr1073746696 mTokType@var1215 ==@expr1073746697 eString ||@expr1073746698 mTokType@var1215 ==@expr1073746699 eChar ||@expr1073746700
388: mTokType@var1215 ==@expr4866 eBoolean ||@expr1073746702 mTokType@var1215 ==@expr1073746703 eLiteral ||@expr1073746704 mTokType@var1215 ==@expr4868 eEnumerator ;
389: setFlag (@expr1073746706 fIsLiteral , memoizedIsLiteral@var1028 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1215 ==@expr1073746707 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073746708 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1216 ==@expr1073746709 fIsName &&@expr1073746710 mTokType@var1215 ==@expr1073746711 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073746712 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1215 ==@expr1073746713 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1215 ==@expr1073746714 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073746715 isConstOp (@expr1073746716 ) ||@expr1073746717
412: isAssignmentOp (@expr1073746718 ) ||@expr1073746719
413: mTokType@var1215 ==@expr1073746720 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073746721 isArithmeticalOp (@expr1073746722 ) ||@expr1073746723
417: mTokType@var1215 ==@expr1073746724 eLogicalOp ||@expr1073746725
418: mTokType@var1215 ==@expr1073746726 eComparisonOp ||@expr1073746727
419: mTokType@var1215 ==@expr1073746728 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073746729 ) ||@expr1073746730
423: mTokType@var1215 ==@expr1073746731 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1215 ==@expr1073746732 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1215 ==@expr1073746733 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1215 ==@expr1073746734 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1215 ==@expr1073746735 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1215 ==@expr1073746736 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073746737 ) !=@expr1073746738 nullptr &&@expr1073746739 astOperand2 (@expr1073746740 ) !=@expr1073746741 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1029 ) const {
444: return s@var1029 ==@expr1073746742 mStr@var1211 &&@expr1073746743 astOperand1 (@expr1073746744 ) !=@expr1073746745 nullptr &&@expr1073746746 astOperand2 (@expr1073746747 ) ==@expr1073746748 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1216 ;
450: }
451: void flags ( const unsigned int flags_@var1030 ) {
452: mFlags@var1216 =@expr1073746749 flags_@var1030 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073746750 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1031 ) {
458: setFlag (@expr1073746751 fIsUnsigned , sign@var1031 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073746752 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1032 ) {
464: setFlag (@expr1073746753 fIsSigned , sign@var1032 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073746754 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1033 ) {
470: setFlag (@expr1073746755 fIsPointerCompare , b@var1033 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073746756 fIsLong ) ;
474: }
475: void isLong ( bool size@var1034 ) {
476: setFlag (@expr1073746757 fIsLong , size@var1034 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073746758 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1035 ) {
482: setFlag (@expr1073746759 fIsStandardType , b@var1035 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073746760 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1036 ) {
488: setFlag (@expr1073746761 fIsExpandedMacro , m@var1036 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073746762 fIsCast ) ;
492: }
493: void isCast ( bool c@var1037 ) {
494: setFlag (@expr1073746763 fIsCast , c@var1037 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073746764 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1038 ) {
500: setFlag (@expr1073746765 fIsAttributeConstructor , ac@var1038 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073746766 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1039 ) {
506: setFlag (@expr1073746767 fIsAttributeDestructor , value@var1039 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073746768 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1040 ) {
512: setFlag (@expr1073746769 fIsAttributeUnused , unused@var1040 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073746770 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1041 ) {
518: setFlag (@expr1073746771 fIsAttributeUsed , unused@var1041 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073746772 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1042 ) {
524: setFlag (@expr1073746773 fIsAttributePure , value@var1042 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073746774 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1043 ) {
530: setFlag (@expr1073746775 fIsAttributeConst , value@var1043 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073746776 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1044 ) {
536: setFlag (@expr1073746777 fIsAttributeNoreturn , value@var1044 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073746778 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1045 ) {
542: setFlag (@expr1073746779 fIsAttributeNothrow , value@var1045 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073746780 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1046 ) {
548: setFlag (@expr1073746781 fIsAttributePacked , value@var1046 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073746782 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1047 ) {
554: setFlag (@expr1073746783 fIsAttributeNodiscard , value@var1047 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073746784 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1048 ) {
560: setFlag (@expr1073746785 fIsAttributeMaybeUnused , value@var1048 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1049 , long long value@var1050 ) {
563: mImpl@var1217 .@expr1073746786 setCppcheckAttribute (@expr1073746787 type@var1049 , value@var1050 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1051 , long long * value@var1052 ) const {
566: return mImpl@var1217 .@expr1073746788 getCppcheckAttribute (@expr1073746789 type@var1051 , value@var1052 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073746790 mImpl@var1217 .@expr1073746791 mCppcheckAttributes@var1250 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073746792 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073746793 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1053 ) {
578: setFlag (@expr1073746794 fIsOperatorKeyword , value@var1053 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073746795 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1054 ) {
584: setFlag (@expr1073746796 fIsComplex , value@var1054 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073746797 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1055 ) {
590: setFlag (@expr1073746798 fIsEnumType , value@var1055 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073746799 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1056 ) {
596: setFlag (@expr1073746800 fAtAddress , b@var1056 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073746801 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1057 ) {
602: setFlag (@expr1073746802 fIncompleteVar , b@var1057 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073746803 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1058 ) {
609: setFlag (@expr1073746804 fIsIncompleteConstant , b@var1058 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073746805 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1059 ) {
616: setFlag (@expr1073746806 fConstexpr , b@var1059 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073746807 fExternC ) ;
621: }
622: void isExternC ( bool b@var1060 ) {
623: setFlag (@expr1073746808 fExternC , b@var1060 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073746809 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1061 ) {
630: setFlag (@expr1073746810 fIsSplitVarDeclComma , b@var1061 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073746811 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1062 ) {
637: setFlag (@expr1073746812 fIsSplitVarDeclEq , b@var1062 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073746813 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1063 ) {
644: setFlag (@expr1073746814 fIsImplicitInt , b@var1063 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073746815 fIsInline ) ;
649: }
650: void isInline ( bool b@var1064 ) {
651: setFlag (@expr1073746816 fIsInline , b@var1064 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073746817 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1065 ) {
658: setFlag (@expr1073746818 fIsRemovedVoidParameter , b@var1065 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073746819 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1066 ) {
665: setFlag (@expr1073746820 fIsTemplate , b@var1066 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073746821 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1067 ) {
672: setFlag (@expr1073746822 fIsSimplifedScope , b@var1067 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1217 .@expr1073746823 mBits@var1251 >@expr1073746824 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1217 .@expr1073746825 mBits@var1251 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1217 .@expr1073746826 mTemplateSimplifierPointers@var1252 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1068 ) {
685: if (@expr1073746827 !@expr1073746828 mImpl@var1217 .@expr5005 mTemplateSimplifierPointers@var1252 ) {
686: mImpl@var1217 .@expr5005 mTemplateSimplifierPointers@var1252 =@expr1073746831 new std ::@expr1073746832 set < TemplateSimplifier ::@expr1073746833 TokenAndName *@expr1073746834 > ; }
687: mImpl@var1217 .@expr5005 mTemplateSimplifierPointers@var1252 .@expr1073746836 insert (@expr1073746837 tokenAndName@var1068 ) ;
688: }
689: void setBits ( const unsigned char b@var1069 ) {
690: mImpl@var1217 .@expr1073746838 mBits@var1251 =@expr1073746839 b@var1069 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr5016 (@expr5016 (@expr5016 mTokType@var1215 ==@expr1073746843 eString ) &&@expr1073746844 isPrefixStringCharLiteral (@expr1073746845 mStr@var1211 , '"' , "u8" ) ) ||@expr1073746846
695: (@expr5016 (@expr5016 mTokType@var1215 ==@expr1073746849 eChar ) &&@expr1073746850 isPrefixStringCharLiteral (@expr1073746851 mStr@var1211 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr5028 (@expr5028 (@expr5028 mTokType@var1215 ==@expr1073746855 eString ) &&@expr1073746856 isPrefixStringCharLiteral (@expr1073746857 mStr@var1211 , '"' , "u" ) ) ||@expr1073746858
700: (@expr5028 (@expr5028 mTokType@var1215 ==@expr1073746861 eChar ) &&@expr1073746862 isPrefixStringCharLiteral (@expr1073746863 mStr@var1211 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr5040 (@expr5040 (@expr5040 mTokType@var1215 ==@expr1073746867 eString ) &&@expr1073746868 isPrefixStringCharLiteral (@expr1073746869 mStr@var1211 , '"' , "U" ) ) ||@expr1073746870
705: (@expr5040 (@expr5040 mTokType@var1215 ==@expr1073746873 eChar ) &&@expr1073746874 isPrefixStringCharLiteral (@expr1073746875 mStr@var1211 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr5052 (@expr5052 (@expr5052 mTokType@var1215 ==@expr1073746879 eString ) &&@expr1073746880 isPrefixStringCharLiteral (@expr1073746881 mStr@var1211 , '"' , "" ) ) ||@expr1073746882
710: (@expr5052 (@expr5052 mTokType@var1215 ==@expr1073746885 eChar ) &&@expr1073746886 isPrefixStringCharLiteral (@expr1073746887 mStr@var1211 , '\'' , "" ) &&@expr1073746888 mStr@var1211 .@expr1073746889 length (@expr1073746890 ) ==@expr1073746891 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr5068 (@expr5068 (@expr5068 mTokType@var1215 ==@expr1073746895 eChar ) &&@expr1073746896 isPrefixStringCharLiteral (@expr1073746897 mStr@var1211 , '\'' , "" ) ) &&@expr1073746898
715: (@expr5068 mStr@var1211 .@expr1073746900 length (@expr1073746901 ) >@expr1073746902 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073746903 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1070 ) {
738: setFlag (@expr1073746904 fIsTemplateArg , value@var1070 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1071 , const char ( & pattern@var1072 ) [ count ] ) {
743: return findsimplematch (@expr1073746906 startTok@var1071 , pattern@var1072 , count@expr1073746905 -@expr1073746907 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1073 , const char pattern@var1074 [ ] , unsigned long pattern_len@var1075 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1076 , const char ( & pattern@var1077 ) [ count ] , const Token * const end@var1078 ) {
749: return findsimplematch (@expr1073746909 startTok@var1076 , pattern@var1077 , count@expr1073746908 -@expr1073746910 1 , end@var1078 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1079 , const char pattern@var1080 [ ] , unsigned long pattern_len@var1081 , const Token * const end@var1082 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1083 , const char pattern@var1084 [ ] , const int varId@var1085 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1086 , const char pattern@var1087 [ ] , const Token * const end@var1088 , const int varId@var1089 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1090 , const char ( & pattern@var1091 ) [ count ] ) {
758: return findsimplematch (@expr1073746912 startTok@var1090 , pattern@var1091 , count@expr1073746911 -@expr1073746913 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1092 , const char pattern@var1093 [ ] , unsigned long pattern_len@var1094 ) {
761: return const_cast < Token *@expr5090 > (@expr1073746915 findsimplematch (@expr1073746916 const_cast < const Token *@expr5090 > (@expr1073746918 startTok@var1092 ) , pattern@var1093 , pattern_len@var1094 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1095 , const char ( & pattern@var1096 ) [ count ] , const Token * const end@var1097 ) {
765: return findsimplematch (@expr1073746920 startTok@var1095 , pattern@var1096 , count@expr1073746919 -@expr1073746921 1 , end@var1097 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1098 , const char pattern@var1099 [ ] , unsigned long pattern_len@var1100 , const Token * const end@var1101 ) {
768: return const_cast < Token *@expr5098 > (@expr1073746923 findsimplematch (@expr1073746924 const_cast < const Token *@expr5098 > (@expr1073746926 startTok@var1098 ) , pattern@var1099 , pattern_len@var1100 , end@var1101 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1102 , const char pattern@var1103 [ ] , const int varId@var1104 = 0 ) {
772: return const_cast < Token *@expr5103 > (@expr1073746928 findmatch (@expr1073746929 const_cast < const Token *@expr5103 > (@expr1073746931 startTok@var1102 ) , pattern@var1103 , varId@var1104 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1105 , const char pattern@var1106 [ ] , const Token * const end@var1107 , const int varId@var1108 = 0 ) {
775: return const_cast < Token *@expr5108 > (@expr1073746933 findmatch (@expr1073746934 const_cast < const Token *@expr5108 > (@expr1073746936 startTok@var1105 ) , pattern@var1106 , end@var1107 , varId@var1108 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1109 , const char * haystack@var1110 , int varid@var1111 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1217 .@expr1073746937 mFileIndex@var1253 ;
796: }
797: void fileIndex ( int indexOfFile@var1112 ) {
798: mImpl@var1217 .@expr1073746938 mFileIndex@var1253 =@expr1073746939 indexOfFile@var1112 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1217 .@expr1073746940 mLineNumber@var1254 ;
803: }
804: void linenr ( int lineNumber@var1113 ) {
805: mImpl@var1217 .@expr1073746941 mLineNumber@var1254 =@expr1073746942 lineNumber@var1113 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1217 .@expr1073746943 mColumn@var1255 ;
810: }
811: void column ( int c@var1114 ) {
812: mImpl@var1217 .@expr1073746944 mColumn@var1255 =@expr1073746945 c@var1114 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1212 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1115 , const Token * end@var1116 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1117 , const std :: string & originalNameStr@var1118 = emptyString@var1 , bool prepend@var1119 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1120 , const std :: string & originalNameStr@var1121 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746946 tokenStr@var1120 , originalNameStr@var1121 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1213 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1217 .@expr1073746947 mVarId@var1248 ;
851: }
852: void varId ( int id@var1122 ) {
853: mImpl@var1217 .@expr1073746948 mVarId@var1248 =@expr1073746949 id@var1122 ;
854: if (@expr1073746950 id@var1122 !=@expr1073746951 0 ) {
855: tokType (@expr1073746952 eVariable ) ;
856: isStandardType (@expr1073746953 false ) ;
857: } else {
858: update_property_info (@expr1073746954 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746955 mImpl@var1217 .@expr5132 mExprId@var1256 ) {
864: return mImpl@var1217 .@expr5132 mExprId@var1256 ; }
865: return mImpl@var1217 .@expr1073746958 mVarId@var1248 ;
866: }
867: void exprId ( int id@var1123 ) {
868: mImpl@var1217 .@expr1073746959 mExprId@var1256 =@expr1073746960 id@var1123 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1124 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1125 , const std :: vector < std :: string > & fileNames@var1126 ) const ;
888:
|
891:
892: void printLines ( int lines@var1127 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1128 , Token * start@var1129 , Token * end@var1130 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1131 ; varid@var1131 = false ;
905: bool exprid@var1132 ; exprid@var1132 = false ;
906: bool idtype@var1133 ; idtype@var1133 = false ;
907: bool attributes@var1134 ; attributes@var1134 = false ;
908: bool macro@var1135 ; macro@var1135 = false ;
909: bool linenumbers@var1136 ; linenumbers@var1136 = false ;
910: bool linebreaks@var1137 ; linebreaks@var1137 = false ;
911: bool files@var1138 ; files@var1138 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1139 ;
914: options@var1139 .@expr1073746961 attributes@var1140 =@expr1073746962 true ;
915: options@var1139 .@expr1073746963 macro@var1141 =@expr1073746964 true ;
916: options@var1139 .@expr1073746965 linenumbers@var1142 =@expr1073746966 true ;
917: options@var1139 .@expr1073746967 linebreaks@var1143 =@expr1073746968 true ;
918: options@var1139 .@expr1073746969 files@var1144 =@expr1073746970 true ;
919: return options@var1139 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1145 ; options@var1145 =@expr1073746971 forDebug (@expr1073746972 ) ;
923: options@var1145 .@expr1073746973 varid@var1146 =@expr1073746974 true ;
924: return options@var1145 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1147 ; options@var1147 =@expr1073746975 forDebug (@expr1073746976 ) ;
928: options@var1147 .@expr1073746977 exprid@var1148 =@expr1073746978 true ;
929: return options@var1147 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1149 ; options@var1149 =@expr1073746979 forDebug (@expr1073746980 ) ;
933: options@var1149 .@expr1073746981 exprid@var1150 =@expr1073746982 true ;
934: options@var1149 .@expr1073746983 varid@var1151 =@expr1073746984 true ;
935: options@var1149 .@expr1073746985 idtype@var1152 =@expr1073746986 true ;
936: return options@var1149 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1153 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1154 , bool attributes@var1155 , bool macro@var1156 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1157 , const std :: vector < std :: string > * fileNames@var1158 = nullptr , const Token * end@var1159 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1160 , bool attributes@var1161 = true ) const ;
952: std :: string stringifyList ( bool varid@var1162 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1163 , bool attributes@var1164 , bool linenumbers@var1165 , bool linebreaks@var1166 , bool files@var1167 , const std :: vector < std :: string > * fileNames@var1168 = nullptr , const Token * end@var1169 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1170 ) {
983: mLink@var1214 =@expr1073746987 linkToToken@var1170 ;
984: if (@expr1073746988 mStr@var1211 ==@expr1073746989 "<" ||@expr1073746990 mStr@var1211 ==@expr1073746991 ">" ) {
985: update_property_info (@expr1073746992 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1214 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1171 ) {
1006: mImpl@var1217 .@expr1073746993 mScope@var1257 =@expr1073746994 s@var1171 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1217 .@expr1073746995 mScope@var1257 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1172 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1215 ==@expr1073746996 eFunction ||@expr1073746997 mTokType@var1215 ==@expr1073746998 eLambda ?@expr1073746999 mImpl@var1217 .@expr1073747000 mFunction@var1258 :@expr1073747001 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1173 ) {
1034: mImpl@var1217 .@expr1073747002 mVariable@var1259 =@expr1073747003 v@var1173 ;
1035: if (@expr1073747004 v@var1173 ||@expr1073747005 mImpl@var1217 .@expr1073747006 mVarId@var1248 ) {
1036: tokType (@expr1073747007 eVariable ) ; }
1037: else { if (@expr1073747008 mTokType@var1215 ==@expr1073747009 eVariable ) {
1038: tokType (@expr1073747010 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1215 ==@expr1073747011 eVariable ?@expr1073747012 mImpl@var1217 .@expr1073747013 mVariable@var1259 :@expr1073747014 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1174 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1215 ==@expr1073747015 eType ?@expr1073747016 mImpl@var1217 .@expr1073747017 mType@var1260 :@expr1073747018 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1175 , const Token * * typeTok@var1176 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1177 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1178 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1215 ==@expr1073747019 eEnumerator ?@expr1073747020 mImpl@var1217 .@expr1073747021 mEnumerator@var1261 :@expr1073747022 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1179 ) {
1079: mImpl@var1217 .@expr1073747023 mEnumerator@var1261 =@expr1073747024 e@var1179 ;
1080: if (@expr1073747025 e@var1179 ) {
1081: tokType (@expr1073747026 eEnumerator ) ; }
1082: else { if (@expr1073747027 mTokType@var1215 ==@expr1073747028 eEnumerator ) {
1083: tokType (@expr1073747029 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1180 , Token * end@var1181 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1182 , Token * srcEnd@var1183 , Token * newLocation@var1184 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1217 .@expr1073747030 mProgressValue@var1262 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1185 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1217 .@expr5207 mOriginalName@var1263 ?@expr1073747032 *@expr1073747033 mImpl@var1217 .@expr5207 mOriginalName@var1263 :@expr1073747035 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1217 .@expr5212 mValues@var1236 ?@expr1073747037 *@expr1073747038 mImpl@var1217 .@expr5212 mValues@var1236 :@expr1073747040 TokenImpl ::@expr1073747041 mEmptyValueList@var983 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1186 ) {
1164: if (@expr1073747042 !@expr1073747043 mImpl@var1217 .@expr5220 mOriginalName@var1263 ) {
1165: mImpl@var1217 .@expr5220 mOriginalName@var1263 =@expr1073747046 new std ::@expr1073747047 string (@expr1073747048 name@var1186 ) ; }
1166: else {
1167: *@expr1073747049 mImpl@var1217 .@expr5220 mOriginalName@var1263 =@expr1073747051 name@var1186 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1187 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1188 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1189 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1217 .@expr1073747053 mValues@var1236 .@expr1073747054 front (@expr1073747055 ) .@expr1073747056 intvalue@expr1073747052 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1190 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1191 , long long path@var1192 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1193 , const Settings * settings@var1194 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1195 , const Settings * settings@var1196 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1197 , int argnr@var1198 , const Settings * settings@var1199 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1200 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1201 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1202 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1203 ) {
1200: if (@expr1073747057 mImpl@var1217 .@expr5234 mValues@var1236 ) {
1201: mImpl@var1217 .@expr5234 mValues@var1236 .@expr1073747060 remove_if (@expr1073747061 pred@var1203 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1217 .@expr1073747062 mIndex@var1264 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1204 ) {
1213: mNext@var1212 =@expr1073747063 nextToken@var1204 ;
1214: }
1215: void previous ( Token * previousToken@var1205 ) {
1216: mPrevious@var1213 =@expr1073747064 previousToken@var1205 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1206 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1207 , const char * word@var1208 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1209 , char c@var1210 ) ;
1235:
1236: std :: string mStr@var1211 ;
1237:
1238: Token * mNext@var1212 ;
1239: Token * mPrevious@var1213 ;
1240: Token * mLink@var1214 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1215 ;
1283:
1284: uint64_t mFlags@var1216 ;
1285:
1286: TokenImpl * mImpl@var1217 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1218 ) const {
1294: return (@expr5241 (@expr5241 mFlags@var1216 &@expr1073747067 flag_@var1218 ) !=@expr1073747068 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1219 , bool state_@var1220 ) {
1303: mFlags@var1216 =@expr1073747069 state_@var1220 ?@expr1073747070 mFlags@var1216 |@expr1073747071 flag_@var1219 :@expr1073747072 mFlags@var1216 &@expr1073747073 ~@expr1073747074 flag_@var1219 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1221 , const int indent1@var1222 = 0 , const int indent2@var1223 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1224 ) ;
1321: void astOperand2 ( Token * tok@var1225 ) ;
1322: void astParent ( Token * tok@var1226 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1217 .@expr1073747075 mAstOperand1@var1227 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1217 .@expr1073747076 mAstOperand1@var1227 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1217 .@expr1073747077 mAstOperand2@var1228 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1217 .@expr1073747078 mAstOperand2@var1228 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1217 .@expr1073747079 mAstParent@var1229 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1217 .@expr1073747080 mAstParent@var1229 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073747081 !@expr1073747082 astParent (@expr5259 ) ) {
1344: return nullptr ; }
1345: if (@expr1073747084 this@expr5261 ==@expr1073747086 astParent (@expr5259 ) .@expr5264 astOperand1 (@expr5265 ) ) {
1346: return astParent (@expr5259 ) .@expr5267 astOperand2 (@expr5268 ) ; }
1347: else { if (@expr1073747093 this@expr5261 ==@expr1073747094 astParent (@expr5259 ) .@expr5267 astOperand2 (@expr5268 ) ) {
1348: return astParent (@expr5259 ) .@expr5264 astOperand1 (@expr5265 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073747101 !@expr1073747102 astParent (@expr5279 ) ) {
1354: return nullptr ; }
1355: if (@expr1073747104 this@expr5281 ==@expr1073747106 astParent (@expr5279 ) .@expr5284 astOperand1 (@expr5285 ) ) {
1356: return astParent (@expr5279 ) .@expr5287 astOperand2 (@expr5288 ) ; }
1357: else { if (@expr1073747113 this@expr5281 ==@expr1073747114 astParent (@expr5279 ) .@expr5287 astOperand2 (@expr5288 ) ) {
1358: return astParent (@expr5279 ) .@expr5284 astOperand1 (@expr5285 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1230 ; ret@var1230 =@expr1073747121 this@expr1073747122 ;
1364: while (@expr1073747123 ret@var1230 .@expr5300 mImpl@var1231 .@expr5301 mAstParent@var1232 ) {
1365: ret@var1230 =@expr1073747126 ret@var1230 .@expr5300 mImpl@var1231 .@expr5301 mAstParent@var1232 ; }
1366: return ret@var1230 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1233 ; ret@var1233 =@expr1073747129 this@expr1073747130 ;
1371: while (@expr1073747131 ret@var1233 .@expr5308 mImpl@var1234 .@expr5309 mAstParent@var1235 ) {
1372: ret@var1233 =@expr1073747134 ret@var1233 .@expr5308 mImpl@var1234 .@expr5309 mAstParent@var1235 ; }
1373: return ret@var1233 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1217 .@expr1073747137 mAstOperand1@var1227 =@expr1073747138 mImpl@var1217 .@expr1073747139 mAstOperand2@var1228 =@expr1073747140 mImpl@var1217 .@expr1073747141 mAstParent@var1229 =@expr1073747142 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1217 .@expr5319 mValues@var1236 ;
1393: mImpl@var1217 .@expr5319 mValues@var1236 =@expr1073747145 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1237 = "" ) const {
1397: std ::@expr1073747146 string ret@var1238 ;
1398: if (@expr1073747147 mImpl@var1217 .@expr5324 mAstOperand1@var1227 ) {
1399: ret@var1238 =@expr1073747149 mImpl@var1217 .@expr5324 mAstOperand1@var1227 .@expr1073747151 astString (@expr1073747152 sep@var1237 ) ; }
1400: if (@expr1073747153 mImpl@var1217 .@expr5330 mAstOperand2@var1228 ) {
1401: ret@var1238 +=@expr1073747155 mImpl@var1217 .@expr5330 mAstOperand2@var1228 .@expr1073747157 astString (@expr1073747158 sep@var1237 ) ; }
1402: return ret@var1238 +@expr1073747159 sep@var1237 +@expr1073747160 mStr@var1211 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1239 , bool xml@var1240 , const std :: vector < std :: string > & fileNames@var1241 , std :: ostream & out@var1242 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1243 , std :: ostream & out@var1244 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1245 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1246 ) const {
1419: mImpl@var1217 .@expr1073747161 mCpp11init@var1247 =@expr1073747162 cpp11init@var1246 ?@expr1073747163 TokenImpl ::@expr5340 Cpp11init ::@expr1073747165 CPP11INIT :@expr1073747166 TokenImpl ::@expr5340 Cpp11init ::@expr1073747168 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1217 .@expr1073747169 mCpp11init@var1247 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1265 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1266 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1267 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1268 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1269 ( nullptr ) , num@var1270 ( 0 ) , known@var1271 ( true ) { }
62:
63: const Token * tok@var1269 ;
64: long long num@var1270 ;
65: bool known@var1271 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1272 ;
72: const Scope * classScope@var1273 ;
73: const Scope * enclosingScope@var1274 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1275 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1277 ( nullptr ) , nameTok@var1278 ( nullptr ) , access@var1279 ( AccessControl :: Public ) , isVirtual@var1280 ( false ) { }
82:
83: std :: string name@var1276 ;
84: const Type * type@var1277 ;
85: const Token * nameTok@var1278 ;
86: AccessControl access@var1279 ;
87: bool isVirtual@var1280 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1281 ) const {
90: return this@expr1073747170 .@expr1073747171 type@var1277 <@expr1073747172 rhs@var1281 .@expr1073747173 type@var1282 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1283 ( nullptr ) , nameEnd@var1284 ( nullptr ) , type@var1285 ( nullptr ) { }
97:
98: const Token * nameStart@var1283 ;
99: const Token * nameEnd@var1284 ;
100: const Type * type@var1285 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1286 ;
104: std :: vector < FriendInfo > friendList@var1287 ;
105:
106: const Token * typeStart@var1288 ;
107: const Token * typeEnd@var1289 ;
108: long long sizeOf@var1290 ;
109:
110: Type ( const Token * classDef_@var1291 = nullptr , const Scope * classScope_@var1292 = nullptr , const Scope * enclosingScope_@var1293 = nullptr ) :
111: classDef@var1272 ( classDef_@var1291 ) ,
112: classScope@var1273 ( classScope_@var1292 ) ,
113: enclosingScope@var1274 ( enclosingScope_@var1293 ) ,
114: needInitialization@var1275 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1288 ( nullptr ) ,
116: typeEnd@var1289 ( nullptr ) ,
117: sizeOf@var1290 ( 0 ) {
118: if (@expr1073747174 classDef_@var1291 &&@expr1073747175 classDef_@var1291 .@expr5352 str (@expr5353 ) ==@expr1073747178 "enum" ) {
119: needInitialization@var1275 =@expr1073747179 NeedInitialization ::@expr1073747180 True ; }
120: else { if (@expr1073747181 classDef_@var1291 &&@expr1073747182 classDef_@var1291 .@expr5352 str (@expr5353 ) ==@expr1073747185 "using" ) {
121: typeStart@var1288 =@expr1073747186 classDef@var1272 .@expr1073747187 tokAt (@expr1073747188 3 ) ;
122: typeEnd@var1289 =@expr1073747189 typeStart@var1288 ;
123: while (@expr1073747190 typeEnd@var1289 .@expr5367 next (@expr5368 ) &&@expr1073747193 typeEnd@var1289 .@expr5367 next (@expr5368 ) .@expr1073747196 str (@expr1073747197 ) !=@expr1073747198 ";" ) {
124: typeEnd@var1289 =@expr1073747199 typeEnd@var1289 .@expr5367 next (@expr5368 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1272 ?@expr1073747202 classDef@var1272 .@expr1073747203 str (@expr1073747204 ) :@expr1073747205 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1272 &&@expr1073747206 classDef@var1272 .@expr1073747207 str (@expr1073747208 ) ==@expr1073747209 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1294 , const Token * tok1@var1295 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1296 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1297 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1298 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1299 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1300 ) : scope@var1301 ( scope_@var1300 ) , name@var1302 ( nullptr ) , value@var1303 ( 0 ) , start@var1304 ( nullptr ) , end@var1305 ( nullptr ) , value_known@var1306 ( false ) { }
167: const Scope * scope@var1301 ;
168: const Token * name@var1302 ;
169: long long value@var1303 ;
170: const Token * start@var1304 ;
171: const Token * end@var1305 ;
172: bool value_known@var1306 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1307 ) const {
204: return (@expr5386 (@expr5386 mFlags@var1343 &@expr1073747212 flag_@var1307 ) !=@expr1073747213 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1308 , bool state_@var1309 ) {
213: mFlags@var1343 =@expr1073747214 state_@var1309 ?@expr1073747215 mFlags@var1343 |@expr1073747216 flag_@var1308 :@expr1073747217 mFlags@var1343 &@expr1073747218 ~@expr1073747219 flag_@var1308 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1310 , bool * isContainer@var1311 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1312 , const Token * start_@var1313 , const Token * end_@var1314 ,
226: int index_@var1315 , AccessControl access_@var1316 , const Type * type_@var1317 ,
227: const Scope * scope_@var1318 , const Settings * settings@var1319 )
228: : mNameToken@var1338 ( name_@var1312 ) ,
229: mTypeStartToken@var1339 ( start_@var1313 ) ,
230: mTypeEndToken@var1340 ( end_@var1314 ) ,
231: mIndex@var1341 ( index_@var1315 ) ,
232: mAccess@var1342 ( access_@var1316 ) ,
233: mFlags@var1343 ( 0 ) ,
234: mType@var1344 ( type_@var1317 ) ,
235: mScope@var1345 ( scope_@var1318 ) ,
236: mValueType@var1346 ( nullptr ) {
237: evaluate (@expr1073747220 settings@var1319 ) ;
238: }
239:
240: Variable ( const Token * name_@var1320 , const std :: string & clangType@var1321 , const Token * typeStart@var1322 ,
241: const Token * typeEnd@var1323 , int index_@var1324 , AccessControl access_@var1325 ,
242: const Type * type_@var1326 , const Scope * scope_@var1327 ) ;
243:
244: Variable ( const Variable & var@var1328 , const Scope * scope@var1329 ) ;
245:
246: Variable ( const Variable & var@var1330 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1331 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1338 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1339 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1340 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073747221 mNameToken@var1338 ) {
300: return mNameToken@var1338 .@expr1073747222 str (@expr1073747223 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073747224 mNameToken@var1338 ) {
312: return mNameToken@var1338 .@expr1073747225 varId (@expr1073747226 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1341 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1342 ==@expr1073747227 AccessControl ::@expr1073747228 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1342 ==@expr1073747229 AccessControl ::@expr1073747230 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1342 ==@expr1073747231 AccessControl ::@expr1073747232 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1342 ==@expr1073747233 AccessControl ::@expr1073747234 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1342 ==@expr1073747235 AccessControl ::@expr1073747236 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1342 ==@expr1073747237 AccessControl ::@expr1073747238 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073747240 mAccess@var1342 ==@expr1073747241 AccessControl ::@expr1073747242 Local@expr1073747239 ) &&@expr1073747243 !@expr1073747244 isExtern (@expr1073747245 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073747246 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073747247 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073747248 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073747249 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073747250 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1342 ==@expr1073747251 AccessControl ::@expr1073747252 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073747253 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073747254 fIsArray ) &&@expr1073747255 !@expr1073747256 getFlag (@expr1073747257 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073747258 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073747259 ) &&@expr1073747260 getFlag (@expr1073747261 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073747262 fIsArray ) ||@expr1073747263 getFlag (@expr1073747264 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073747265 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073747266 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073747267 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073747268 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1344 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1344 ?@expr1073747269 mType@var1344 .@expr1073747270 classScope@var1349 :@expr1073747271 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1345 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1347 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1332 ) const {
550: return mDimensions@var1347 [@expr1073747272 index_@var1332 ] .@expr1073747273 num@var3751 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1333 ) const {
558: return mDimensions@var1347 [@expr1073747274 index_@var1333 ] .@expr1073747275 known@var3752 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073747276 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073747277 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073747278 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1334 ) const {
602: return isStlType (@expr1073747279 ) &&@expr1073747280 stlType@var1334 ==@expr1073747281 mTypeStartToken@var1339 .@expr1073747282 strAt (@expr1073747283 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1335 ) const {
616: return isStlType (@expr1073747284 ) &&@expr1073747285 stlTypes@var1335 .@expr1073747286 find (@expr1073747287 mTypeStartToken@var1339 .@expr1073747288 strAt (@expr1073747289 2 ) ) !=@expr1073747290 stlTypes@var1335 .@expr1073747291 end (@expr1073747292 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073747293 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr5470 ) &&@expr1073747295 type (@expr5470 ) .@expr1073747297 isEnumType (@expr1073747298 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073747299 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1346 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1336 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1342 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1337 ) {
660: mType@var1344 =@expr1073747300 t@var1337 ;
661: }
662:
663:
664: const Token * mNameToken@var1338 ;
665:
666:
667: const Token * mTypeStartToken@var1339 ;
668:
669:
670: const Token * mTypeEndToken@var1340 ;
671:
672:
673: int mIndex@var1341 ;
674:
675:
676: AccessControl mAccess@var1342 ;
677:
678:
679: unsigned int mFlags@var1343 ;
680:
681:
682: const Type * mType@var1344 ;
683:
684:
685: const Scope * mScope@var1345 ;
686:
687: ValueType * mValueType@var1346 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1347 ;
691:
692:
693: void evaluate ( const Settings * settings@var1348 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1350 ) const {
735: return (@expr5477 (@expr5477 mFlags@var1399 &@expr1073747303 flag@var1350 ) !=@expr1073747304 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1351 , bool state@var1352 ) {
744: mFlags@var1399 =@expr1073747305 state@var1352 ?@expr1073747306 mFlags@var1399 |@expr1073747307 flag@var1351 :@expr1073747308 mFlags@var1399 &@expr1073747309 ~@expr1073747310 flag@var1351 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1353 , const Token * tok@var1354 , const Scope * scope@var1355 , const Token * tokDef@var1356 , const Token * tokArgDef@var1357 ) ;
751: Function ( const Token * tokenDef@var1358 , const std :: string & clangType@var1359 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1369 .@expr1073747311 str (@expr1073747312 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1377 .@expr1073747313 size (@expr1073747314 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1377 .@expr1073747315 size (@expr1073747316 ) -@expr1073747317 initArgCount@var1378 ;
764: }
765: const Variable * getArgumentVar ( int num@var1360 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1378 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1361 , const Scope * scope@var1362 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1363 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1364 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1379 ==@expr1073747318 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1379 ==@expr1073747319 eConstructor ||@expr1073747320
785: type@var1379 ==@expr1073747321 eCopyConstructor ||@expr1073747322
786: type@var1379 ==@expr1073747323 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1379 ==@expr1073747324 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1369 .@expr1073747325 isAttributeConstructor (@expr1073747326 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1369 .@expr1073747327 isAttributeDestructor (@expr1073747328 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1369 .@expr1073747329 isAttributePure (@expr1073747330 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1369 .@expr1073747331 isAttributeConst (@expr1073747332 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1369 .@expr1073747333 isAttributeNoreturn (@expr1073747334 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1369 .@expr1073747335 isAttributeNothrow (@expr1073747336 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1369 .@expr1073747337 isAttributeNodiscard (@expr1073747338 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073747339 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073747340 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073747341 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073747342 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073747343 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073747344 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073747345 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073747346 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073747347 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073747348 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073747349 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073747350 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073747351 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073747352 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073747353 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073747354 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073747355 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073747356 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073747357 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073747358 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073747359 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073747360 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1365 ) {
881: setFlag (@expr1073747361 fHasBody , state@var1365 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073747362 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073747363 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1366 ) {
891: setFlag (@expr1073747364 fIsEscapeFunction , state@var1366 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073747365 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1367 ) {
898: setFlag (@expr1073747366 fIsConstexpr , state@var1367 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1368 ) const ;
901:
902: const Token * tokenDef@var1369 ;
903: const Token * argDef@var1370 ;
904: const Token * token@var1371 ;
905: const Token * arg@var1372 ;
906: const Token * retDef@var1373 ;
907: const :: Type * retType@var1374 ;
908: const Scope * functionScope@var1375 ;
909: const Scope * nestedIn@var1376 ;
910: std :: list < Variable > argumentList@var1377 ;
911: int initArgCount@var1378 ;
912: Type type@var1379 ;
913: AccessControl access@var1380 ;
914: const Token * noexceptArg@var1381 ;
915: const Token * throwArg@var1382 ;
916: const Token * templateDef@var1383 ;
917: const Token * functionPointerUsage@var1384 ;
918:
919: bool argsMatch ( const Scope * scope@var1385 , const Token * first@var1386 , const Token * second@var1387 , const std :: string & path@var1388 , int path_length@var1389 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1390 , bool unknown@var1391 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1392 , bool unknown@var1393 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1394 , bool unknown@var1395 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1396 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073747367 this@expr1073747368 .@expr1073747369 hasTrailingReturnType (@expr1073747370 ) ) {
931: return Token ::@expr1073747371 findmatch (@expr1073747372 retDef@var1373 , "{|;" ) ;
932: } else {
933: return tokenDef@var1369 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1397 , bool * foundAllBaseClasses@var1398 ) const ;
946:
947: unsigned int mFlags@var1399 ;
948:
949: void isInline ( bool state@var1400 ) {
950: setFlag (@expr1073747373 fIsInline , state@var1400 ) ;
951: }
952: void isConst ( bool state@var1401 ) {
953: setFlag (@expr1073747374 fIsConst , state@var1401 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1402 ) {
956: setFlag (@expr1073747375 fHasVirtualSpecifier , state@var1402 ) ;
957: }
958: void isPure ( bool state@var1403 ) {
959: setFlag (@expr1073747376 fIsPure , state@var1403 ) ;
960: }
961: void isStatic ( bool state@var1404 ) {
962: setFlag (@expr1073747377 fIsStatic , state@var1404 ) ;
963: }
964: void isStaticLocal ( bool state@var1405 ) {
965: setFlag (@expr1073747378 fIsStaticLocal , state@var1405 ) ;
966: }
967: void isExtern ( bool state@var1406 ) {
968: setFlag (@expr1073747379 fIsExtern , state@var1406 ) ;
969: }
970: void isFriend ( bool state@var1407 ) {
971: setFlag (@expr1073747380 fIsFriend , state@var1407 ) ;
972: }
973: void isExplicit ( bool state@var1408 ) {
974: setFlag (@expr1073747381 fIsExplicit , state@var1408 ) ;
975: }
976: void isDefault ( bool state@var1409 ) {
977: setFlag (@expr1073747382 fIsDefault , state@var1409 ) ;
978: }
979: void isDelete ( bool state@var1410 ) {
980: setFlag (@expr1073747383 fIsDelete , state@var1410 ) ;
981: }
982: void isNoExcept ( bool state@var1411 ) {
983: setFlag (@expr1073747384 fIsNoExcept , state@var1411 ) ;
984: }
985: void isThrow ( bool state@var1412 ) {
986: setFlag (@expr1073747385 fIsThrow , state@var1412 ) ;
987: }
988: void isOperator ( bool state@var1413 ) {
989: setFlag (@expr1073747386 fIsOperator , state@var1413 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1414 ) {
992: setFlag (@expr1073747387 fHasLvalRefQual , state@var1414 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1415 ) {
995: setFlag (@expr1073747388 fHasRvalRefQual , state@var1415 ) ;
996: }
997: void isVariadic ( bool state@var1416 ) {
998: setFlag (@expr1073747389 fIsVariadic , state@var1416 ) ;
999: }
1000: void isVolatile ( bool state@var1417 ) {
1001: setFlag (@expr1073747390 fIsVolatile , state@var1417 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1418 ) {
1004: return setFlag (@expr1073747391 fHasTrailingReturnType , state@var1418 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1419 ) {
1007: setFlag (@expr1073747392 fIsInlineKeyword , state@var1419 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1420 , const Scope * scope@var1421 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1422 ;
1019: const Scope * scope@var1423 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1424 , const Token * classDef_@var1425 , const Scope * nestedIn_@var1426 ) ;
1025: Scope ( const SymbolDatabase * check_@var1427 , const Token * classDef_@var1428 , const Scope * nestedIn_@var1429 , ScopeType type_@var1430 , const Token * start_@var1431 ) ;
1026:
1027: const SymbolDatabase * check@var1432 ;
1028: std :: string className@var1433 ;
1029: const Token * classDef@var1434 ;
1030: const Token * bodyStart@var1435 ;
1031: const Token * bodyEnd@var1436 ;
1032: std :: list < Function > functionList@var1437 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1438 ;
1034: std :: list < Variable > varlist@var1439 ;
1035: const Scope * nestedIn@var1440 ;
1036: std :: list < Scope * > nestedList@var1441 ;
1037: int numConstructors@var1442 ;
1038: int numCopyOrMoveConstructors@var1443 ;
1039: std :: list < UsingInfo > usingList@var1444 ;
1040: ScopeType type@var1445 ;
1041: Type * definedType@var1446 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1447 ;
1043: std :: vector < const Token * > bodyStartList@var1448 ;
1044:
1045:
1046: const Scope * functionOf@var1449 ;
1047: Function * function@var1450 ;
1048:
1049:
1050: const Token * enumType@var1451 ;
1051: bool enumClass@var1452 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1453 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1454 ) {
1056: bodyStart@var1435 =@expr1073747393 start@var1454 ;
1057: bodyEnd@var1436 =@expr1073747394 start@var1454 ?@expr1073747395 start@var1454 .@expr1073747396 link (@expr1073747397 ) :@expr1073747398 nullptr ;
1058: if (@expr1073747399 start@var1454 ) {
1059: bodyStartList@var1448 .@expr1073747400 push_back (@expr1073747401 start@var1454 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1433 .@expr1073747402 size (@expr1073747403 ) >@expr1073747404 9 &&@expr1073747405 className@var1433 .@expr1073747406 compare (@expr1073747407 0 , 9 , "Anonymous" ) ==@expr1073747408 0 &&@expr1073747409 std ::@expr1073747410 isdigit (@expr1073747411 className@var1433 [@expr1073747412 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1455 ) const {
1068: for (@expr1073747413 const Enumerator &@expr1073747414 i@var1456 :@expr1073747415 enumeratorList@var1453 ) {
1069: if (@expr1073747416 i@var1456 .@expr1073747417 name@var1457 .@expr1073747418 str (@expr1073747419 ) ==@expr1073747420 name@var1455 ) {
1070: return &@expr1073747421 i@var1456 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1458 ) const {
1076: if (@expr1073747422 !@expr1073747423 outer@var1458 ) {
1077: return false ; }
1078: if (@expr1073747424 outer@var1458 ==@expr1073747425 this@expr1073747426 ) {
1079: return true ; }
1080: const Scope * parent@var1459 ; parent@var1459 =@expr1073747427 nestedIn@var1440 ;
1081: while (@expr1073747428 outer@var1458 !=@expr1073747429 parent@var1459 &&@expr1073747430 parent@var1459 ) {
1082: parent@var1459 =@expr1073747431 parent@var1459 .@expr1073747432 nestedIn@var1460 ; }
1083: if (@expr1073747433 parent@var1459 &&@expr1073747434 parent@var1459 ==@expr1073747435 outer@var1458 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1461 ) {
1089: while (@expr1073747436 scope@var1461 ) {
1090: if (@expr1073747437 scope@var1461 .@expr1073747438 type@var1462 ==@expr1073747439 Scope ::@expr1073747440 eFunction ) {
1091: break ; }
1092: scope@var1461 =@expr1073747441 scope@var1461 .@expr1073747442 nestedIn@var1463 ;
1093: }
1094: if (@expr1073747443 !@expr1073747444 scope@var1461 ) {
1095: return nullptr ; }
1096: return scope@var1461 .@expr1073747445 function@var1464 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073747446 type@var1445 ==@expr1073747447 eClass ||@expr1073747448 type@var1445 ==@expr1073747449 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073747450 type@var1445 ==@expr1073747451 eClass ||@expr1073747452 type@var1445 ==@expr1073747453 eStruct ||@expr1073747454 type@var1445 ==@expr1073747455 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1445 !=@expr1073747456 eClass &&@expr1073747457 type@var1445 !=@expr1073747458 eStruct &&@expr1073747459 type@var1445 !=@expr1073747460 eUnion &&@expr1073747461 type@var1445 !=@expr1073747462 eGlobal &&@expr1073747463 type@var1445 !=@expr1073747464 eNamespace &&@expr1073747465 type@var1445 !=@expr1073747466 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1445 ==@expr1073747467 Scope ::@expr5644 ScopeType ::@expr1073747469 eFor ||@expr1073747470 type@var1445 ==@expr1073747471 Scope ::@expr5644 ScopeType ::@expr1073747473 eWhile ||@expr1073747474 type@var1445 ==@expr1073747475 Scope ::@expr5644 ScopeType ::@expr1073747477 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073747478 type@var1445 ==@expr1073747479 eIf ||@expr1073747480 type@var1445 ==@expr1073747481 eElse ||@expr1073747482
1117: type@var1445 ==@expr1073747483 eFor ||@expr1073747484 type@var1445 ==@expr1073747485 eWhile ||@expr1073747486 type@var1445 ==@expr1073747487 eDo ||@expr1073747488
1118: type@var1445 ==@expr1073747489 eSwitch ||@expr1073747490 type@var1445 ==@expr1073747491 eUnconditional ||@expr1073747492
1119: type@var1445 ==@expr1073747493 eTry ||@expr1073747494 type@var1445 ==@expr1073747495 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1465 , bool requireConst@var1466 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1467 , bool isC@var1468 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1469 ) {
1135: return const_cast < Scope *@expr5672 > (@expr1073747497 const_cast < const Scope *@expr5672 > (@expr1073747499 this@expr1073747500 ) .@expr1073747501 findRecordInNestedList (@expr1073747502 name@var1469 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1470 ) const ;
1139: Type * findType ( const std :: string & name@var1471 ) {
1140: return const_cast < Type *@expr5679 > (@expr1073747504 const_cast < const Scope *@expr5679 > (@expr1073747506 this@expr1073747507 ) .@expr1073747508 findType (@expr1073747509 name@var1471 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1472 ) ;
1148:
1149: void addVariable ( const Token * token_@var1473 , const Token * start_@var1474 ,
1150: const Token * end_@var1475 , AccessControl access_@var1476 , const Type * type_@var1477 ,
1151: const Scope * scope_@var1478 , const Settings * settings@var1479 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1480 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1481 ) {
1159: functionList@var1437 .@expr1073747510 push_back (@expr1073747511 func@var1481 ) ;
1160:
1161: const Function * back@var1482 ; back@var1482 =@expr1073747512 &@expr1073747513 functionList@var1437 .@expr1073747514 back (@expr1073747515 ) ;
1162:
1163: functionMap@var1438 .@expr1073747516 insert (@expr1073747517 make_pair (@expr1073747518 back@var1482 .@expr1073747519 tokenDef@var1483 .@expr1073747520 str (@expr1073747521 ) , back@var1482 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1484 , AccessControl varaccess@var1485 , const Settings * settings@var1486 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1487 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1488 , bool isCpp@var1489 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1490 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1491 , const Token * & vartok@var1492 , const Token * & typetok@var1493 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1494 , int args@var1495 , std :: vector < const Function * > & matches@var1496 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1497 , const Token * start@var1498 , const Token * end@var1499 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1500 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1501 ;
1239: int bits@var1502 ;
1240: int pointer@var1503 ;
1241: int constness@var1504 ;
1242: Reference reference@var1505 ; reference@var1505 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1506 ;
1245: const :: Type * smartPointerType@var1507 ;
1246: const Token * smartPointerTypeToken@var1508 ;
1247: const Library :: SmartPointer * smartPointer@var1509 ;
1248: const Library :: Container * container@var1510 ;
1249:
1250: const Token * containerTypeToken@var1511 ;
1251:
1252: std :: string originalTypeName@var1512 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1500 ( UNKNOWN_SIGN ) ,
1257: type@var1501 ( UNKNOWN_TYPE ) ,
1258: bits@var1502 ( 0 ) ,
1259: pointer@var1503 ( 0U ) ,
1260: constness@var1504 ( 0U ) ,
1261: typeScope@var1506 ( nullptr ) ,
1262: smartPointerType@var1507 ( nullptr ) ,
1263: smartPointerTypeToken@var1508 ( nullptr ) ,
1264: smartPointer@var1509 ( nullptr ) ,
1265: container@var1510 ( nullptr ) ,
1266: containerTypeToken@var1511 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1513 , enum Type t@var1514 , int p@var1515 )
1269: : sign@var1500 ( s@var1513 ) ,
1270: type@var1501 ( t@var1514 ) ,
1271: bits@var1502 ( 0 ) ,
1272: pointer@var1503 ( p@var1515 ) ,
1273: constness@var1504 ( 0U ) ,
1274: typeScope@var1506 ( nullptr ) ,
1275: smartPointerType@var1507 ( nullptr ) ,
1276: smartPointerTypeToken@var1508 ( nullptr ) ,
1277: smartPointer@var1509 ( nullptr ) ,
1278: container@var1510 ( nullptr ) ,
1279: containerTypeToken@var1511 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1516 , enum Type t@var1517 , int p@var1518 , int c@var1519 )
1282: : sign@var1500 ( s@var1516 ) ,
1283: type@var1501 ( t@var1517 ) ,
1284: bits@var1502 ( 0 ) ,
1285: pointer@var1503 ( p@var1518 ) ,
1286: constness@var1504 ( c@var1519 ) ,
1287: typeScope@var1506 ( nullptr ) ,
1288: smartPointerType@var1507 ( nullptr ) ,
1289: smartPointerTypeToken@var1508 ( nullptr ) ,
1290: smartPointer@var1509 ( nullptr ) ,
1291: container@var1510 ( nullptr ) ,
1292: containerTypeToken@var1511 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1520 , enum Type t@var1521 , int p@var1522 , int c@var1523 , const std :: string & otn@var1524 )
1295: : sign@var1500 ( s@var1520 ) ,
1296: type@var1501 ( t@var1521 ) ,
1297: bits@var1502 ( 0 ) ,
1298: pointer@var1503 ( p@var1522 ) ,
1299: constness@var1504 ( c@var1523 ) ,
1300: typeScope@var1506 ( nullptr ) ,
1301: smartPointerType@var1507 ( nullptr ) ,
1302: smartPointerTypeToken@var1508 ( nullptr ) ,
1303: smartPointer@var1509 ( nullptr ) ,
1304: container@var1510 ( nullptr ) ,
1305: containerTypeToken@var1511 ( nullptr ) ,
1306: originalTypeName@var1512 ( otn@var1524 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1525 , const Settings * settings@var1526 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1527 , bool longType@var1528 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1529 , const ValueType * func@var1530 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1531 , const Variable * callVar@var1532 , const Variable * funcVar@var1533 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073747522 type@var1501 >=@expr1073747523 ValueType ::@expr1073747524 Type ::@expr1073747525 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073747526 type@var1501 >=@expr1073747527 ValueType ::@expr5704 Type ::@expr1073747529 BOOL &&@expr1073747530 type@var1501 <=@expr1073747531 ValueType ::@expr5704 Type ::@expr1073747533 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073747534 type@var1501 >=@expr1073747535 ValueType ::@expr5712 Type ::@expr1073747537 FLOAT &&@expr1073747538 type@var1501 <=@expr1073747539 ValueType ::@expr5712 Type ::@expr1073747541 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1534 , const Settings * settings@var1535 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1506 &&@expr1073747542 typeScope@var1506 .@expr1073747543 type@var1536 ==@expr1073747544 Scope ::@expr1073747545 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1537 , bool p@var1538 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1539 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1540 , const Settings * settings@var1541 , ErrorLogger * errorLogger@var1542 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1543 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1544 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1545 ;
1359:
1360:
1361: std :: list < Type > typeList@var1546 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1547 , const Token * typeTok@var1548 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1549 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1550 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1551 , const Scope * startScope@var1552 , bool lookOutside@var1553 = false ) const ;
1382: Type * findType ( const Token * startTok@var1554 , Scope * startScope@var1555 , bool lookOutside@var1556 = false ) const {
1383: return const_cast < Type *@expr5722 > (@expr1073747547 this@expr1073747548 .@expr1073747549 findType (@expr1073747550 startTok@var1554 , const_cast < const Scope *@expr5722 > (@expr1073747552 startScope@var1555 ) , lookOutside@var1556 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1557 , const Scope * startScope@var1558 ) const ;
1387: Scope * findScope ( const Token * tok@var1559 , Scope * startScope@var1560 ) const {
1388: return const_cast < Scope *@expr5729 > (@expr1073747554 this@expr1073747555 .@expr1073747556 findScope (@expr1073747557 tok@var1559 , const_cast < const Scope *@expr5729 > (@expr1073747559 startScope@var1560 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1561 ) const {
1392: return varid@var1561 <@expr1073747560 mVariableList@var1618 .@expr1073747561 size (@expr1073747562 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1562 ) const {
1396: return mVariableList@var1618 .@expr1073747563 at (@expr1073747564 varId@var1562 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1618 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1563 , const std :: string & type@var1564 , const std :: string & msg@var1565 ) const ;
1407:
1408: void printOut ( const char * title@var1566 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1567 , const char * indent@var1568 ) const ;
1410: void printXml ( std :: ostream & out@var1569 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1570 , Token * tokens@var1571 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1572 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1573 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1574 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1575 , const Token * * tok@var1576 , const Token * argStart@var1577 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1578 , const Token * tok@var1579 , const Token * argStart@var1580 , const Token * funcStart@var1581 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1582 , const Token * & tok@var1583 , const Token * argStart@var1584 , const Token * funcStart@var1585 ) ;
1469: void addNewFunction ( Scope * * scope@var1586 , const Token * * tok@var1587 ) ;
1470: bool isFunction ( const Token * tok@var1588 , const Scope * outerScope@var1589 , const Token * * funcStart@var1590 , const Token * * argStart@var1591 , const Token * * declEnd@var1592 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1593 , const Scope * startScope@var1594 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1595 , const Scope * scope@var1596 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1597 , const Scope * ns@var1598 , const std :: string & path@var1599 , int path_length@var1600 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1601 , const Token * typeTok@var1602 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1603 , const Token * vartok@var1604 , Token * membertok@var1605 , const Variable * membervar@var1606 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1607 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1608 ) const ;
1485:
1486: void setValueType ( Token * tok@var1609 , const ValueType & valuetype@var1610 ) ;
1487: void setValueType ( Token * tok@var1611 , const Variable & var@var1612 ) ;
1488: void setValueType ( Token * tok@var1613 , const Enumerator & enumerator@var1614 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1615 ;
1491: const Settings * mSettings@var1616 ;
1492: ErrorLogger * mErrorLogger@var1617 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1618 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1619 ;
1499:
1500: bool mIsCpp@var1620 ;
1501: ValueType :: Sign mDefaultSignedness@var1621 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1622 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1623 , const TFunc & visitor@var1624 )
52: {
53: if (@expr1073747565 !@expr1073747566 ast@var1623 ) {
54: return ; }
55:
56: std ::@expr1073747567 stack < T *@expr5744 , std ::@expr1073747569 vector < T *@expr5744 > > tokens@var1625 ;
57: T * tok@var1626 ; tok@var1626 =@expr1073747571 ast@var1623 ;
58: do {
59: ChildrenToVisit c@var1627 ; c@var1627 =@expr1073747572 visitor@var1624 (@expr1073747573 tok@var1626 ) ;
60:
61: if (@expr1073747574 c@var1627 ==@expr1073747575 ChildrenToVisit ::@expr1073747576 done ) {
62: break ; }
63: if (@expr1073747577 c@var1627 ==@expr1073747578 ChildrenToVisit ::@expr1073747579 op2 ||@expr1073747580 c@var1627 ==@expr5757 ChildrenToVisit ::@expr5758 op1_and_op2 ) {
64: T * t2@var1628 ; t2@var1628 =@expr1073747583 tok@var1626 .@expr1073747584 astOperand2 (@expr1073747585 ) ;
65: if (@expr1073747586 t2@var1628 ) {
66: tokens@var1625 .@expr5763 push (@expr1073747588 t2@var1628 ) ; }
67: }
68: if (@expr1073747589 c@var1627 ==@expr1073747590 ChildrenToVisit ::@expr1073747591 op1 ||@expr1073747592 c@var1627 ==@expr5757 ChildrenToVisit ::@expr5758 op1_and_op2 ) {
69: T * t1@var1629 ; t1@var1629 =@expr1073747595 tok@var1626 .@expr1073747596 astOperand1 (@expr1073747597 ) ;
70: if (@expr1073747598 t1@var1629 ) {
71: tokens@var1625 .@expr5763 push (@expr1073747600 t1@var1629 ) ; }
72: }
73:
74: if (@expr1073747601 tokens@var1625 .@expr1073747602 empty (@expr1073747603 ) ) {
75: break ; }
76:
77: tok@var1626 =@expr1073747604 tokens@var1625 .@expr1073747605 top (@expr1073747606 ) ;
78: tokens@var1625 .@expr1073747607 pop (@expr1073747608 ) ;
79: } while (@expr1073747609 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1630 , const std :: function < bool ( const Token * ) > & pred@var1631 ) ;
83: const Token * findExpression ( const int exprid@var1632 ,
84: const Token * start@var1633 ,
85: const Token * end@var1634 ,
86: const std :: function < bool ( const Token * ) > & pred@var1635 ) ;
87: const Token * findExpression ( const Token * start@var1636 , const int exprid@var1637 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1638 , const char * op@var1639 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1640 , const char * op@var1641 ) ;
91:
92: int astCount ( const Token * tok@var1642 , const char * op@var1643 , int depth@var1644 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1645 , const Token * tok@var1646 ) ;
95:
96: bool astHasVar ( const Token * tok@var1647 , int varid@var1648 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1649 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1650 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1651 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1652 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1653 , bool unknown@var1654 ) ;
107: bool astIsUnsigned ( const Token * tok@var1655 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1656 , bool unknown@var1657 ) ;
110:
111: bool astIsBool ( const Token * tok@var1658 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1659 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1660 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1661 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1662 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1663 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1664 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1665 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1666 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1667 , const std :: string & comp@var1668 , const std :: string & rhs@var1669 , const Token * * vartok@var1670 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1671 ) ;
140:
141: bool isTemporary ( bool cpp@var1672 , const Token * tok@var1673 , const Library * library@var1674 , bool unknown@var1675 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1676 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1677 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1678 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1679 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1680 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1681 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1682 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1683 ) ;
155: const Token * getParentLifetime ( bool cpp@var1684 , const Token * tok@var1685 , const Library * library@var1686 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1687 ) ;
158: bool astIsRHS ( const Token * tok@var1688 ) ;
159:
160: Token * getCondTok ( Token * tok@var1689 ) ;
161: const Token * getCondTok ( const Token * tok@var1690 ) ;
162:
163: Token * getInitTok ( Token * tok@var1691 ) ;
164: const Token * getInitTok ( const Token * tok@var1692 ) ;
165:
166: Token * getStepTok ( Token * tok@var1693 ) ;
167: const Token * getStepTok ( const Token * tok@var1694 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1695 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1696 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1697 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1698 ,
180: int * const varid@var1699 ,
181: bool * const knownInitValue@var1700 ,
182: long long * const initValue@var1701 ,
183: bool * const partialCond@var1702 ,
184: long long * const stepValue@var1703 ,
185: long long * const lastValue@var1704 ) ;
186:
187: bool precedes ( const Token * tok1@var1705 , const Token * tok2@var1706 ) ;
188: bool succeeds ( const Token * tok1@var1707 , const Token * tok2@var1708 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1709 , bool onVar@var1710 = true , int depth@var1711 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1712 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1713 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1714 ,
198: bool temporary@var1715 = true ,
199: bool inconclusive@var1716 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1717 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1718 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1719 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1720 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1721 , bool macro@var1722 , const Token * tok1@var1723 , const Token * tok2@var1724 , const Library & library@var1725 , bool pure@var1726 , bool followVar@var1727 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1728 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1729 , const Token * const tok2@var1730 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1731 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1732 , bool cpp@var1733 , const Token * const cond1@var1734 , const Token * const cond2@var1735 , const Library & library@var1736 , bool pure@var1737 , bool followVar@var1738 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1739 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1740 , const Token * const tok1@var1741 , const Token * const tok2@var1742 , const Library & library@var1743 , bool pure@var1744 , bool followVar@var1745 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1746 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1747 , const Library & library@var1748 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1749 , const Library & library@var1750 , bool pure@var1751 , bool cpp@var1752 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1753 , const Token * tok@var1754 , bool checkArrayAccess@var1755 = false , bool checkReference@var1756 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1757 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1758 , const Library * library@var1759 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1760 ,
238: const Library * library@var1761 = nullptr ,
239: const Token * * unknownFunc@var1762 = nullptr ,
240: bool functionScope@var1763 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1764 ,
244: const Variable * var@var1765 ,
245: Scope :: ScopeType type@var1766 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1767 , int & argn@var1768 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1769 , int & argn@var1770 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1771 , int argnr@var1772 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1773 , int indirect@var1774 , int varid@var1775 , const Settings * settings@var1776 , bool * inconclusive@var1777 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1778 , int indirect@var1779 , const Settings * settings@var1780 , bool * inconclusive@var1781 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1782 , const Token * end@var1783 , const int exprid@var1784 , bool globalvar@var1785 , const Settings * settings@var1786 , bool cpp@var1787 , int depth@var1788 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1789 , const Token * end@var1790 , int indirect@var1791 , const int exprid@var1792 , bool globalvar@var1793 , const Settings * settings@var1794 , bool cpp@var1795 , int depth@var1796 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1797 , int indirect@var1798 , const Settings * settings@var1799 , bool cpp@var1800 , int depth@var1801 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1802 , const Settings * settings@var1803 , bool cpp@var1804 , int depth@var1805 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1806 ,
283: const Token * end@var1807 ,
284: int indirect@var1808 ,
285: std :: vector < const Variable * > vars@var1809 ,
286: const Settings * settings@var1810 ,
287: bool cpp@var1811 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1812 , int indirect@var1813 , const Settings * settings@var1814 , bool cpp@var1815 ) ;
290: bool isThisChanged ( const Token * start@var1816 , const Token * end@var1817 , int indirect@var1818 , const Settings * settings@var1819 , bool cpp@var1820 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1821 , const Token * end@var1822 , int indirect@var1823 , const int exprid@var1824 , bool globalvar@var1825 , const Settings * settings@var1826 , bool cpp@var1827 , int depth@var1828 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1829 , const Token * end@var1830 , int indirect@var1831 , const int exprid@var1832 , bool globalvar@var1833 , const Settings * settings@var1834 , bool cpp@var1835 , int depth@var1836 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1837 ,
296: const Token * start@var1838 ,
297: const Token * end@var1839 ,
298: const Settings * settings@var1840 ,
299: bool cpp@var1841 ,
300: int depth@var1842 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1843 ,
303: const Token * tok@var1844 ,
304: int indirect@var1845 ,
305: bool globalvar@var1846 ,
306: const Settings * settings@var1847 ,
307: bool cpp@var1848 ,
308: int depth@var1849 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1850 , int varid@var1851 , bool * inconclusive@var1852 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1853 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1854 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1855 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1856 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1857 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1858 , const Function * f@var1859 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1860 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1861 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1862 ) ;
346: Token * findLambdaEndToken ( Token * first@var1863 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1864 , const Token * stream@var1865 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1866 , const Token * op@var1867 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1868 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1869 , const char * skipMatch@var1870 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1871 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1872 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1873 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1874 , const Library & library@var1875 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1876 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1877 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1878 , bool cpp@var1879 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1880 , const Library & library@var1881 ) : mCpp@var1914 ( cpp@var1880 ) , mLibrary@var1915 ( library@var1881 ) , mWhat@var1916 ( What :: Reassign ) , mValueFlowKnown@var1918 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1882 , const Token * lhs@var1883 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1884 , const Token * startToken@var1885 , const Token * endToken@var1886 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1887 , const Token * startToken@var1888 , const Token * endToken@var1889 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1890 ;
407: const Token * token@var1891 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1892 , const Token * startToken@var1893 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1894 , bool * localOut@var1895 = nullptr , bool * unknownVarIdOut@var1896 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1897 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1898 ;
420: explicit Result ( Type type@var1899 ) : type@var1898 ( type@var1899 ) , token@var1902 ( nullptr ) { }
421: Result ( Type type@var1900 , const Token * token@var1901 ) : type@var1898 ( type@var1900 ) , token@var1902 ( token@var1901 ) { }
422: const Token * token@var1902 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1903 , const Token * startToken@var1904 , const Token * endToken@var1905 ) ;
426: struct Result checkRecursive ( const Token * expr@var1906 , const Token * startToken@var1907 , const Token * endToken@var1908 , const std :: set < int > & exprVarIds@var1909 , bool local@var1910 , bool inInnerClass@var1911 , int depth@var1912 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1913 ) const ;
430:
431: const bool mCpp@var1914 ;
432: const Library & mLibrary@var1915 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1916 ;
434: std :: vector < KnownAndToken > mValueFlow@var1917 ;
435: bool mValueFlowKnown@var1918 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1919 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1920 ) {
44: if (@expr1073747610 bit@var1920 >=@expr1073747611 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073747612 (@expr1073747613 1LL <<@expr1073747614 (@expr1073747615 bit@var1920 -@expr1073747616 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1921 ) {
50: if (@expr1073747617 bit@var1921 >=@expr1073747618 64 ) {
51: return (@expr5795 ~@expr1073747620 0ULL ) >>@expr1073747621 1 ; }
52: return (@expr5795 1LL <<@expr1073747623 (@expr5795 bit@var1921 -@expr1073747625 1 ) ) -@expr1073747626 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1922 ) const {
59: return value@var1922 >=@expr1073747627 min_value (@expr1073747628 int_bit@var1932 ) &&@expr1073747629 value@var1922 <=@expr1073747630 max_value (@expr1073747631 int_bit@var1932 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1923 ) const {
63: unsigned long long intMax@var1924 ; intMax@var1924 =@expr1073747632 max_value (@expr1073747633 int_bit@var1932 ) ;
64: return value@var1923 <=@expr1073747634 intMax@var1924 ;
65: }
66:
67: bool isLongValue ( long long value@var1925 ) const {
68: return value@var1925 >=@expr1073747635 min_value (@expr1073747636 long_bit@var1933 ) &&@expr1073747637 value@var1925 <=@expr1073747638 max_value (@expr1073747639 long_bit@var1933 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1926 ) const {
72: unsigned long long longMax@var1927 ; longMax@var1927 =@expr1073747640 max_value (@expr1073747641 long_bit@var1933 ) ;
73: return value@var1926 <=@expr1073747642 longMax@var1927 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1928 ) const {
77: unsigned long long longLongMax@var1929 ; longLongMax@var1929 =@expr1073747643 max_value (@expr1073747644 long_long_bit@var1934 ) ;
78: return value@var1928 <=@expr1073747645 longLongMax@var1929 ;
79: }
80:
81: int char_bit@var1930 ;
82: int short_bit@var1931 ;
83: int int_bit@var1932 ;
84: int long_bit@var1933 ;
85: int long_long_bit@var1934 ;
86:
87:
88: int sizeof_bool@var1935 ;
89: int sizeof_short@var1936 ;
90: int sizeof_int@var1937 ;
91: int sizeof_long@var1938 ;
92: int sizeof_long_long@var1939 ;
93: int sizeof_float@var1940 ;
94: int sizeof_double@var1941 ;
95: int sizeof_long_double@var1942 ;
96: int sizeof_wchar_t@var1943 ;
97: int sizeof_size_t@var1944 ;
98: int sizeof_pointer@var1945 ;
99:
100: char defaultSign@var1946 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1947 ;
115:
116:
117: bool platform ( PlatformType type@var1948 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1949 [ ] , const std :: string & filename@var1950 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1951 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1947 ==@expr1073747646 Win32A ||@expr1073747647
136: platformType@var1947 ==@expr1073747648 Win32W ||@expr1073747649
137: platformType@var1947 ==@expr1073747650 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073747651 platformType@var1947 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1952 ) {
145: switch (@expr1073747652 pt@var1952 ) {
146: case Unspecified :@expr5829 ;
147: return "Unspecified" ;
148: case Native :@expr5829 ;
149: return "Native" ;
150: case Win32A :@expr5829 ;
151: return "win32A" ;
152: case Win32W :@expr5829 ;
153: return "win32W" ;
154: case Win64 :@expr5829 ;
155: return "win64" ;
156: case Unix32 :@expr5829 ;
157: return "unix32" ;
158: case Unix64 :@expr5829 ;
159: return "unix64" ;
160: case PlatformFile :@expr5829 ;
161: return "platformFile" ;
162: default :@expr5829 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073747662 char_bit@var1930 +@expr1073747663 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073747664 char_bit@var1930 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073747665 char_bit@var1930 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1953 , const std :: string & rhs@var1954 ) const {
41: return caseInsensitiveStringCompare (@expr1073747666 lhs@var1953 , rhs@var1954 ) <@expr1073747667 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1962 ( cppcheck :: Platform :: Unspecified ) , msc@var1963 ( false ) , useMfc@var1964 ( false ) { }
67: std :: string cfg@var1955 ;
68: std :: string filename@var1956 ;
69: std :: string defines@var1957 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1957 +@expr1073747668 (@expr1073747669 msc@var1963 ?@expr1073747670 ";_MSC_VER=1900" :@expr1073747671 "" ) +@expr1073747672 (@expr1073747673 useMfc@var1964 ?@expr1073747674 ";__AFXWIN_H__=1" :@expr1073747675 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1958 ;
74: std :: list < std :: string > includePaths@var1959 ;
75: std :: list < std :: string > systemIncludePaths@var1960 ;
76: std :: string standard@var1961 ;
77: cppcheck :: Platform :: PlatformType platformType@var1962 ;
78: bool msc@var1963 ;
79: bool useMfc@var1964 ;
80:
81: void parseCommand ( std :: string command@var1965 ) ;
82: void setDefines ( std :: string defs@var1966 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1967 , const std :: list < std :: string > & in@var1968 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1969 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1970 ;
86: Type projectType@var1971 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1972 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var1973 ;
97: std :: vector < std :: string > pathNames@var1974 ;
98: std :: list < std :: string > libraries@var1975 ;
99: std :: list < std :: string > excludedPaths@var1976 ;
100: std :: list < std :: string > checkVsConfigs@var1977 ;
101: std :: string projectFile@var1978 ;
102: std :: string platform@var1979 ;
103: } ; struct Anonymous4 guiProject@var1980 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1981 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1982 ) ;
107:
108: Type import ( const std :: string & filename@var1983 , Settings * settings@var1984 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1985 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1986 , Settings * settings@var1987 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1988 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1989 , const std :: string & path@var1990 , const std :: vector < std :: string > & fileFilters@var1991 ) ;
115: bool importVcxproj ( const std :: string & filename@var1992 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1993 , const std :: string & additionalIncludeDirectories@var1994 , const std :: vector < std :: string > & fileFilters@var1995 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1996 ) ;
117:
118: static void printError ( const std :: string & message@var1997 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1998 ) ;
121:
122: std :: string mPath@var1999 ;
123: std :: set < std :: string > mAllVSConfigs@var2000 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2001 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2002 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2003 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2004 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2005 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2006 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2007 [ 7 ] = "parser" ;
135: const char BugHunting@var2008 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2009 [ 11 ] = "includedir" ;
137: const char DirElementName@var2010 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2011 [ 5 ] = "name" ;
139: const char DefinesElementName@var2012 [ 8 ] = "defines" ;
140: const char DefineName@var2013 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2014 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2015 [ 10 ] = "undefines" ;
143: const char UndefineName@var2016 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2017 [ 6 ] = "paths" ;
145: const char PathName@var2018 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2019 [ 5 ] = "name" ;
147: const char RootPathName@var2020 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2021 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2022 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2023 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2024 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2025 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2026 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2027 [ 5 ] = "name" ;
155: const char FunctionContracts@var2028 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2029 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2030 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2031 [ 8 ] = "library" ;
159: const char PlatformElementName@var2032 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2033 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2034 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2035 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2036 [ 7 ] = "addons" ;
164: const char ToolElementName@var2037 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2038 [ 6 ] = "tools" ;
166: const char TagsElementName@var2039 [ 5 ] = "tags" ;
167: const char TagElementName@var2040 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2041 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2042 [ 4 ] = "tag" ;
170: const char WarningElementName@var2043 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2044 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2045 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2046 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2047 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2048 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2049 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2050 [ 11 ] = "clang-tidy" ;
178: const char Name@var2051 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2052 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2053 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var2054 ;
43: std :: string errorId@var2055 ;
44: void setFileName ( const std :: string & s@var2056 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var2060 ;
47: }
48: int lineNumber@var2057 ;
49: Certainty :: CertaintyLevel certainty@var2058 ;
50: std :: string symbolNames@var2059 ;
51: private:
52: std :: string mFileName@var2060 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2094 ( NO_LINE ) , hash@var2096 ( 0 ) , thisAndNextLine@var2097 ( false ) , matched@var2098 ( false ) , checked@var2099 ( false ) { }
57: Suppression ( const Suppression & other@var2061 ) {
58: *@expr1073747676 this@expr1073747677 =@expr1073747678 other@var2061 ;
59: }
60: Suppression ( const std :: string & id@var2062 , const std :: string & file@var2063 , int line@var2064 = NO_LINE ) : errorId@var2092 ( id@var2062 ) , fileName@var2093 ( file@var2063 ) , lineNumber@var2094 ( line@var2064 ) , hash@var2096 ( 0 ) , thisAndNextLine@var2097 ( false ) , matched@var2098 ( false ) , checked@var2099 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var2065 ) {
63: errorId@var2092 =@expr1073747679 other@var2065 .@expr1073747680 errorId@var2066 ;
64: fileName@var2093 =@expr1073747681 other@var2065 .@expr1073747682 fileName@var2067 ;
65: lineNumber@var2094 =@expr1073747683 other@var2065 .@expr1073747684 lineNumber@var2068 ;
66: symbolName@var2095 =@expr1073747685 other@var2065 .@expr1073747686 symbolName@var2069 ;
67: hash@var2096 =@expr1073747687 other@var2065 .@expr1073747688 hash@var2070 ;
68: thisAndNextLine@var2097 =@expr1073747689 other@var2065 .@expr1073747690 thisAndNextLine@var2071 ;
69: matched@var2098 =@expr1073747691 other@var2065 .@expr1073747692 matched@var2072 ;
70: checked@var2099 =@expr1073747693 other@var2065 .@expr1073747694 checked@var2073 ;
71: return *@expr1073747695 this@expr1073747696 ;
72: }
73:
74: bool operator< ( const Suppression & other@var2074 ) const {
75: if (@expr1073747697 errorId@var2092 !=@expr1073747698 other@var2074 .@expr5875 errorId@var2075 ) {
76: return errorId@var2092 <@expr1073747700 other@var2074 .@expr5875 errorId@var2075 ; }
77: if (@expr1073747702 lineNumber@var2094 <@expr1073747703 other@var2074 .@expr1073747704 lineNumber@var2076 ) {
78: return true ; }
79: if (@expr1073747705 fileName@var2093 !=@expr1073747706 other@var2074 .@expr5883 fileName@var2077 ) {
80: return fileName@var2093 <@expr1073747708 other@var2074 .@expr5883 fileName@var2077 ; }
81: if (@expr1073747710 symbolName@var2095 !=@expr1073747711 other@var2074 .@expr5888 symbolName@var2078 ) {
82: return symbolName@var2095 <@expr1073747713 other@var2074 .@expr5888 symbolName@var2078 ; }
83: if (@expr1073747715 hash@var2096 !=@expr1073747716 other@var2074 .@expr5893 hash@var2079 ) {
84: return hash@var2096 <@expr1073747718 other@var2074 .@expr5893 hash@var2079 ; }
85: if (@expr1073747720 thisAndNextLine@var2097 !=@expr1073747721 other@var2074 .@expr1073747722 thisAndNextLine@var2080 ) {
86: return thisAndNextLine@var2097 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2081 , std :: string * errorMessage@var2082 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2083 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2084 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073747724 fileName@var2093 .@expr1073747725 empty (@expr1073747726 ) &&@expr1073747727 fileName@var2093 .@expr1073747728 find_first_of (@expr1073747729 "?*" ) ==@expr1073747730 std ::@expr1073747731 string ::@expr1073747732 npos@expr1073747723 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2085 ) const {
109: return errorId@var2092 ==@expr1073747733 other@var2085 .@expr1073747734 errorId@var2086 &&@expr1073747735
110: fileName@var2093 ==@expr1073747736 other@var2085 .@expr1073747737 fileName@var2087 &&@expr1073747738
111: lineNumber@var2094 ==@expr1073747739 other@var2085 .@expr1073747740 lineNumber@var2088 &&@expr1073747741
112: symbolName@var2095 ==@expr1073747742 other@var2085 .@expr1073747743 symbolName@var2089 &&@expr1073747744
113: hash@var2096 ==@expr1073747745 other@var2085 .@expr1073747746 hash@var2090 &&@expr1073747747
114: thisAndNextLine@var2097 ==@expr1073747748 other@var2085 .@expr1073747749 thisAndNextLine@var2091 ;
115: }
116:
117: std :: string errorId@var2092 ;
118: std :: string fileName@var2093 ;
119: int lineNumber@var2094 ;
120: std :: string symbolName@var2095 ;
121: unsigned long hash@var2096 ;
122: bool thisAndNextLine@var2097 ;
123: bool matched@var2098 ;
124: bool checked@var2099 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2100 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2101 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2102 , std :: string * errorMessage@var2103 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2104 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2105 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2106 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2107 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2108 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2109 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2110 , const bool unusedFunctionChecking@var2111 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2112 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2113 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2114 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2115 , std :: clock_t clocks@var2116 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2117 ;
45: long mNumberOfResults@var2118 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2117 ( 0 )
49: , mNumberOfResults@var2118 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2119 =@expr1073747751 (@expr1073747752 double ) (@expr1073747753 (@expr1073747754 unsigned long ) mClocks@var2117 ) /@expr1073747755 (@expr1073747756 double ) CLOCKS_PER_SEC@expr1073747750 ;
53: return ret@var2119 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2120 ) const ;
62: void addResults ( const std :: string & str@var2121 , std :: clock_t clocks@var2122 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2123 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2124 , SHOWTIME_MODES showtimeMode@var2125 , TimerResultsIntf * timerResults@var2126 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2127 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2128 ;
79: TimerResultsIntf * mTimerResults@var2129 ;
80: std :: clock_t mStart@var2130 ;
81: const SHOWTIME_MODES mShowTimeMode@var2131 ;
82: bool mStopped@var2132 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2133 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2134 ;
103:
104:
105: std :: string addonPython@var2135 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2136 ;
109:
110:
111: std :: string buildDir@var2137 ;
112:
113:
114: bool checkAllConfigurations@var2138 ;
115:
116:
117: bool checkConfiguration@var2139 ;
118:
|
121:
122: bool checkHeaders@var2140 ;
123:
124:
125: bool checkLibrary@var2141 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2142 ;
129:
130:
131: bool checkUnusedTemplates@var2143 ;
132:
133:
134: bool clang@var2144 ;
135:
136:
137: std :: string clangExecutable@var2145 ;
138:
139:
140: bool clangTidy@var2146 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2147 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2148 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2149 ;
150:
151:
152: bool daca@var2150 ;
153:
154:
155: bool debugnormal@var2151 ;
156:
157:
158: bool debugSimplified@var2152 ;
159:
160:
161: bool debugtemplate@var2153 ;
162:
163:
164: bool debugwarnings@var2154 ;
165:
166:
167: bool dump@var2155 ;
168: std :: string dumpFile@var2156 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2157 ;
176:
177:
178: bool exceptionHandling@var2158 ;
179:
180:
181: std :: string exename@var2159 ;
182:
183:
184:
185: int exitCode@var2160 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2161 ;
189:
190:
191: bool force@var2162 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2163 ;
196:
197:
198: bool inlineSuppressions@var2164 ;
199:
200:
201:
202: unsigned int jobs@var2165 ;
203:
|
206:
207: bool jointSuppressionReport@var2166 ;
208:
209:
210: std :: list < std :: string > libraries@var2167 ;
211:
212:
213: Library library@var2168 ;
214:
215:
216:
217: int loadAverage@var2169 ;
218:
|
221:
222: int maxConfigs@var2170 ;
223:
224:
225: int maxCtuDepth@var2171 ;
226:
227:
228: int maxTemplateRecursion@var2172 ;
229:
230:
231: Suppressions nofail@var2173 ;
232:
233:
234: Suppressions nomsg@var2174 ;
235:
236:
237: std :: string outputFile@var2175 ;
238:
239:
240: std :: string plistOutput@var2176 ;
241:
242:
243: bool preprocessOnly@var2177 ;
244:
245: ImportProject project@var2178 ;
246:
247:
248: bool quiet@var2179 ;
249:
250:
251: bool relativePaths@var2180 ;
252:
253:
254: bool reportProgress@var2181 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2182 ( "simple" )
261: , id@var2184 ( "rule" )
262: , severity@var2186 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2182 ;
266: std :: string pattern@var2183 ;
267: std :: string id@var2184 ;
268: std :: string summary@var2185 ;
269: Severity :: SeverityType severity@var2186 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2187 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2193 ( false ) , externalFunctions@var2194 ( false ) , internalFunctions@var2195 ( false ) , externalVariables@var2196 ( false ) { }
281:
282: static const char XmlRootName@var2188 [ ] ;
283: static const char XmlClasses@var2189 [ ] ;
284: static const char XmlExternalFunctions@var2190 [ ] ;
285: static const char XmlInternalFunctions@var2191 [ ] ;
286: static const char XmlExternalVariables@var2192 [ ] ;
287:
288: void clear ( ) {
289: classes@var2193 =@expr1073747757 externalFunctions@var2194 =@expr1073747758 internalFunctions@var2195 =@expr1073747759 externalVariables@var2196 =@expr1073747760 false ;
290: }
291:
|
297:
298: bool classes@var2193 ;
299:
|
304:
305: bool externalFunctions@var2194 ;
306:
|
310:
311: bool internalFunctions@var2195 ;
312:
|
316:
317: bool externalVariables@var2196 ;
318: } ;
319:
320: SafeChecks safeChecks@var2197 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2198 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2199 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2200 ;
325:
326:
327: SHOWTIME_MODES showtime@var2201 ;
328:
329:
330: Standards standards@var2202 ;
331:
332:
333:
334: std :: string templateFormat@var2203 ;
335:
336:
337:
338: std :: string templateLocation@var2204 ;
339:
340:
341: std :: string userDefines@var2205 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2206 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2207 ;
348:
349:
350: bool verbose@var2208 ;
351:
352:
353: bool xml@var2209 ;
354:
355:
356: int xml_version@var2210 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2211 ) const {
363: for (@expr1073747761 const std ::@expr1073747762 string &@expr1073747763 configExcludePath@var2212 :@expr1073747764 configExcludePaths@var2147 ) {
364: if (@expr1073747765 file@var2211 .@expr1073747766 length (@expr1073747767 ) >=@expr1073747768 configExcludePath@var2212 .@expr5945 length (@expr5946 ) &&@expr1073747771 file@var2211 .@expr1073747772 compare (@expr1073747773 0 , configExcludePath@var2212 .@expr5945 length (@expr5946 ) , configExcludePath@var2212 ) ==@expr1073747776 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2213 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2214 , bool inconclusiveCheck@var2215 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073747777 find (@expr1073747778 libraries@var2167 .@expr1073747779 begin (@expr1073747780 ) , libraries@var2167 .@expr5957 end (@expr5958 ) , "posix" ) !=@expr1073747783 libraries@var2167 .@expr5957 end (@expr5958 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2216 = true ) {
392: Settings ::@expr1073747786 mTerminated@var2133 =@expr1073747787 t@var2216 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073747788 mTerminated@var2133 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2217 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2218 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2219 ) {
47: mSettings@var2254 =@expr1073747789 settings@var2219 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2254 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2256 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2257 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2220 ) ;
72:
73: void addtoken ( const std :: string & str@var2221 , const int lineno@var2222 , const int column@var2223 , const int fileno@var2224 , bool split@var2225 = false ) ;
74: void addtoken ( const std :: string & str@var2226 , const Token * locationTok@var2227 ) ;
75:
76: void addtoken ( const Token * tok@var2228 , const int lineno@var2229 , const int column@var2230 , const int fileno@var2231 ) ;
77: void addtoken ( const Token * tok@var2232 , const Token * locationTok@var2233 ) ;
78: void addtoken ( const Token * tok@var2234 ) ;
79:
80: static void insertTokens ( Token * dest@var2235 , const Token * src@var2236 , int n@var2237 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2238 , const Token * first@var2239 , const Token * last@var2240 , bool one_line@var2241 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2242 , const std :: string & file0@var2243 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2244 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2245 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2251 .@expr1073747790 front@var2258 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2251 .@expr1073747791 front@var2258 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2251 .@expr1073747792 back@var2259 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2251 .@expr1073747793 back@var2259 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2252 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2246 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2247 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2248 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2249 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2250 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2251 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2252 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2253 ;
212:
213:
214: const Settings * mSettings@var2254 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2255 ;
217:
218:
219: bool mIsC@var2256 ;
220: bool mIsCpp@var2257 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2260 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2261 ;
67: mutable int mVarId@var2262 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2263 ) ;
73: bool hasVariable ( const std :: string & varname@var2264 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2265 ) const {
75: return mVariableId@var2260 .@expr1073747794 find (@expr1073747795 varname@var2265 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2260 .@expr1073747796 end (@expr1073747797 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2260 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073747798 mVarId@var2262 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2266 , ErrorLogger * errorLogger@var2267 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2268 ) {
95: mTimerResults@var2388 =@expr1073747799 tr@var2268 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2366 .@expr1073747800 isC (@expr1073747801 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2366 .@expr1073747802 isCPP (@expr1073747803 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2269 , bool * unknown@var2270 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2271 , const std :: string & FileName@var2272 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2273 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2274 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2275 ,
142: const char FileName@var2276 [ ] ,
143: const std :: string & configuration@var2277 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2278 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2279 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2280 , const Token * end@var2281 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2282 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2283 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2284 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2285 , const Token * const tokEnd@var2286 , const bool only_k_r_fpar@var2287 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2288 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2289 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2290 , bool commandWithCondition@var2291 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2292 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2293 , Token * * _tok2@var2294 , Token * * _tok3@var2295 , std :: string & value@var2296 , int & valueVarId@var2297 , bool & valueIsPointer@var2298 , bool floatvar@var2299 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2300 , Token * tok3@var2301 , int varid@var2302 , const std :: string & structname@var2303 , std :: string & value@var2304 , int valueVarId@var2305 , bool valueIsPointer@var2306 , const Token * const valueToken@var2307 , int indentlevel@var2308 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2309 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2310 , const std :: string & endsWith@var2311 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2312 , const std :: string & endsWith@var2313 , bool cpp@var2314 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2315 ) {
585: mPreprocessor@var2389 =@expr1073747804 preprocessor@var2315 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2389 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2316 , const Token * end@var2317 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2318 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2319 , const std :: string & code@var2320 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2321 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2322 , const std :: string & what@var2323 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2324 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2325 , const std :: string & msg@var2326 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2327 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2328 , const std :: string & macroName@var2329 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2330 , const Token * end@var2331 , bool allowSemicolon@var2332 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2333 , const Severity :: SeverityType severity@var2334 , const std :: string & id@var2335 , const std :: string & msg@var2336 , bool inconclusive@var2337 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2338 , Severity :: SeverityType severity@var2339 , const std :: string & id@var2340 , const std :: string & msg@var2341 , bool inconclusive@var2342 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2343 , const Token * name@var2344 , const Token * typeDef@var2345 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2346 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2347 ,
821: const VariableMap & variableMap@var2348 ,
822: const int scopeStartVarId@var2349 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2350 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2351 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2352 ,
827: int * varId@var2353 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2354 ,
830: Token * const startToken@var2355 ,
831: const Token * const endToken@var2356 ,
832: const std :: map < std :: string , int > & varlist@var2357 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2358 ,
834: int * varId_@var2359 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2360 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2361 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2387 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2362 ) {
861: mSettings@var2373 =@expr1073747805 settings@var2362 ;
862: list@var2366 .@expr1073747806 setSettings (@expr1073747807 settings@var2362 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2375 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2363 ) const ;
877:
878: void dump ( std :: ostream & out@var2364 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2365 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2385 ;
888: }
889:
|
892:
893: TokenList list@var2366 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2366 .@expr1073747808 front (@expr1073747809 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2367 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2368 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2369 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2370 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2373 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2371 , bool inOperator@var2372 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073747810 mVarId@var2385 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2373 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2374 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2375 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2376 ;
973:
974:
975:
976: std :: string mConfiguration@var2377 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2378 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2379 ;
983: std :: string filename@var2380 ;
984: int lineNumber@var2381 ;
985: int column@var2382 ;
986: bool used@var2383 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2384 ;
989:
990:
991: int mVarId@var2385 ;
992:
993:
994: int mUnnamedCount@var2386 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2387 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2388 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2389 ;
1013: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var2390 , const Color & c@var2391 ) ;
42:
43: std :: string toString ( const Color & c@var2392 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var2393 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var2394 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var2395 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var2396 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var2397 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var2413 ( 0 ) , line@var2414 ( 0 ) , column@var2415 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var2398 , int line@var2399 , unsigned int column@var2400 )
73: : fileIndex@var2413 ( 0 ) , line@var2414 ( line@var2399 ) , column@var2415 ( column@var2400 ) , mOrigFileName@var2417 ( file@var2398 ) , mFileName@var2418 ( file@var2398 ) { }
74:
75: FileLocation ( const std :: string & file@var2401 , const std :: string & info@var2402 , int line@var2403 , unsigned int column@var2404 )
76: : fileIndex@var2413 ( 0 ) , line@var2414 ( line@var2403 ) , column@var2415 ( column@var2404 ) , mOrigFileName@var2417 ( file@var2401 ) , mFileName@var2418 ( file@var2401 ) , mInfo@var2419 ( info@var2402 ) { }
77:
78: FileLocation ( const Token * tok@var2405 , const TokenList * tokenList@var2406 ) ;
79: FileLocation ( const Token * tok@var2407 , const std :: string & info@var2408 , const TokenList * tokenList@var2409 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var2410 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var2411 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var2412 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var2413 ;
107: int line@var2414 ;
108: unsigned int column@var2415 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var2419 ;
112: }
113: void setinfo ( const std :: string & i@var2416 ) {
114: mInfo@var2419 =@expr1073747811 i@var2416 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var2417 ;
119: std :: string mFileName@var2418 ;
120: std :: string mInfo@var2419 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var2420 ,
124: const std :: string & file1@var2421 ,
125: Severity :: SeverityType severity@var2422 ,
126: const std :: string & msg@var2423 ,
127: const std :: string & id@var2424 , Certainty :: CertaintyLevel certainty@var2425 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var2426 ,
129: const std :: string & file1@var2427 ,
130: Severity :: SeverityType severity@var2428 ,
131: const std :: string & msg@var2429 ,
132: const std :: string & id@var2430 ,
133: const CWE & cwe@var2431 ,
134: Certainty :: CertaintyLevel certainty@var2432 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var2433 ,
136: const TokenList * list@var2434 ,
137: Severity :: SeverityType severity@var2435 ,
138: const std :: string & id@var2436 ,
139: const std :: string & msg@var2437 ,
140: Certainty :: CertaintyLevel certainty@var2438 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var2439 ,
142: const TokenList * list@var2440 ,
143: Severity :: SeverityType severity@var2441 ,
144: const std :: string & id@var2442 ,
145: const std :: string & msg@var2443 ,
146: const CWE & cwe@var2444 ,
147: Certainty :: CertaintyLevel certainty@var2445 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var2446 ,
149: const TokenList * tokenList@var2447 ,
150: Severity :: SeverityType severity@var2448 ,
151: const char id@var2449 [ ] ,
152: const std :: string & msg@var2450 ,
153: const CWE & cwe@var2451 ,
154: Certainty :: CertaintyLevel certainty@var2452 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var2453 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var2454 ,
176: const std :: string & templateFormat@var2455 = emptyString@var1 ,
177: const std :: string & templateLocation@var2456 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var2457 ) ;
181:
182: std :: list < FileLocation > callStack@var2458 ;
183: std :: string id@var2459 ;
184:
185:
186: std :: string file0@var2460 ;
187:
188: std :: string function@var2461 ;
189:
190: bool incomplete@var2462 ;
191:
192: Severity :: SeverityType severity@var2463 ;
193: CWE cwe@var2464 ;
194: Certainty :: CertaintyLevel certainty@var2465 ;
195:
196:
197: unsigned long hash@var2466 ;
198:
199:
200: void setmsg ( const std :: string & msg@var2467 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var2469 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var2470 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var2471 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var2468 ) ;
221:
222:
223: std :: string mShortMessage@var2469 ;
224:
225:
226: std :: string mVerboseMessage@var2470 ;
227:
228:
229: std :: string mSymbolNames@var2471 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var2472 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073747812 plistFile@var2472 .@expr1073747813 is_open (@expr1073747814 ) ) {
243: plistFile@var2472 <<@expr1073747815 ErrorLogger ::@expr1073747816 plistFooter (@expr1073747817 ) ;
244: plistFile@var2472 .@expr1073747818 close (@expr1073747819 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var2473 , Color c@var2474 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var2475 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var2476 , const char stage@var2477 [ ] , const unsigned long value@var2478 ) {
271: (@expr1073747820 void ) filename@var2476 ;
272: (@expr1073747821 void ) stage@var2477 ;
273: (@expr1073747822 void ) value@var2478 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var2479 ) {
281: reportErr (@expr1073747823 msg@var2479 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var2480 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var2481 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var2482 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var2483 , const std :: vector < std :: string > & files@var2484 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var2485 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var2486 , const std :: string & from@var2487 , const std :: string & to@var2488 ) ;

##file cppcheck-2.8/lib/ctu.h

1:
|
36:
37: class Function ;
38: class Settings ;
39: class Token ;
40: class Tokenizer ;
41:
42: namespace tinyxml2 {
43: class XMLElement ;
44: }
45:
|
50:
51: namespace CTU {
52: class FileInfo : public Check :: FileInfo {
53: public:
54: enum class InvalidValueType { null , uninit , bufferOverflow } ;
55:
56: std :: string toString ( ) const override ;
57:
58: struct Location {
59: Location ( ) = default ;
60: Location ( const Tokenizer * tokenizer@var2489 , const Token * tok@var2490 ) ;
61: Location ( const std :: string & fileName@var2491 , int lineNumber@var2492 , int column@var2493 ) : fileName@var2494 ( fileName@var2491 ) , lineNumber@var2495 ( lineNumber@var2492 ) , column@var2496 ( column@var2493 ) { }
62: std :: string fileName@var2494 ;
63: int lineNumber@var2495 { } ;
64: int column@var2496 { } ;
65: } ;
66:
67: struct UnsafeUsage {
68: UnsafeUsage ( ) = default ;
69: UnsafeUsage ( const std :: string & myId@var2497 , int myArgNr@var2498 , const std :: string & myArgumentName@var2499 , const Location & location@var2500 , long long value@var2501 ) : myId@var2502 ( myId@var2497 ) , myArgNr@var2503 ( myArgNr@var2498 ) , myArgumentName@var2504 ( myArgumentName@var2499 ) , location@var2505 ( location@var2500 ) , value@var2506 ( value@var2501 ) { }
70: std :: string myId@var2502 ;
71: int myArgNr@var2503 { } ;
72: std :: string myArgumentName@var2504 ;
73: Location location@var2505 ;
74: long long value@var2506 { } ;
75: std :: string toString ( ) const ;
76: } ;
77:
78: class CallBase {
79: public:
80: CallBase ( ) = default ;
81: CallBase ( const std :: string & callId@var2507 , int callArgNr@var2508 , const std :: string & callFunctionName@var2509 , const Location & loc@var2510 )
82: : callId@var2513 ( callId@var2507 ) , callArgNr@var2514 ( callArgNr@var2508 ) , callFunctionName@var2515 ( callFunctionName@var2509 ) , location@var2516 ( loc@var2510 )
83: { }
84: CallBase ( const Tokenizer * tokenizer@var2511 , const Token * callToken@var2512 ) ;
85: virtual ~ CallBase ( ) { }
86: std :: string callId@var2513 ;
87: int callArgNr@var2514 { } ;
88: std :: string callFunctionName@var2515 ;
89: Location location@var2516 ;
90: protected:
91: std :: string toBaseXmlString ( ) const ;
92: bool loadBaseFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2517 ) ;
93: } ;
94:
95: class FunctionCall : public CallBase {
96: public:
97: std :: string callArgumentExpression@var2518 ;
98: long long callArgValue@var2519 ;
99: ValueFlow :: Value :: ValueType callValueType@var2520 ;
100: std :: vector < ErrorMessage :: FileLocation > callValuePath@var2521 ;
101: bool warning@var2522 ;
102:
103: std :: string toXmlString ( ) const ;
104: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2523 ) ;
105: } ;
106:
107: class NestedCall : public CallBase {
108: public:
109: NestedCall ( ) = default ;
110:
111: NestedCall ( const std :: string & myId@var2524 , int myArgNr@var2525 , const std :: string & callId@var2526 , int callArgnr@var2527 , const std :: string & callFunctionName@var2528 , const Location & location@var2529 )
112: : CallBase ( callId@var2526 , callArgnr@var2527 , callFunctionName@var2528 , location@var2529 ) ,
113: myId@var2534 ( myId@var2524 ) ,
114: myArgNr@var2535 ( myArgNr@var2525 ) { }
115:
116: NestedCall ( const Tokenizer * tokenizer@var2530 , const Function * myFunction@var2531 , const Token * callToken@var2532 ) ;
117:
118: std :: string toXmlString ( ) const ;
119: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2533 ) ;
120:
121: std :: string myId@var2534 ;
122: int myArgNr@var2535 { } ;
123: } ;
124:
125: std :: list < FunctionCall > functionCalls@var2536 ;
126: std :: list < NestedCall > nestedCalls@var2537 ;
127:
128: void loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2538 ) ;
129: std :: map < std :: string , std :: list < const CallBase * > > getCallsMap ( ) const ;
130:
131: static std :: list < ErrorMessage :: FileLocation > getErrorPath ( InvalidValueType invalidValue@var2539 ,
132: const UnsafeUsage & unsafeUsage@var2540 ,
133: const std :: map < std :: string , std :: list < const CallBase * > > & callsMap@var2541 ,
134: const char info@var2542 [ ] ,
135: const FunctionCall * * const functionCallPtr@var2543 ,
136: bool warning@var2544 ) ;
137: } ;
138:
139: extern int maxCtuDepth@var2545 ;
140:
141: std :: string toString ( const std :: list < FileInfo :: UnsafeUsage > & unsafeUsage@var2546 ) ;
142:
143: std :: string getFunctionId ( const Tokenizer * tokenizer@var2547 , const Function * function@var2548 ) ;
144:
145:
146: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2549 ) ;
147:
148: std :: list < FileInfo :: UnsafeUsage > getUnsafeUsage ( const Tokenizer * tokenizer@var2550 , const Settings * settings@var2551 , const Check * check@var2552 , bool ( * isUnsafeUsage@var2553 ) ( const Check * , const Token * , long long * ) ) ;
149:
150: std :: list < FileInfo :: UnsafeUsage > loadUnsafeUsageListFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2554 ) ;
151: }

##file cppcheck-2.8/lib/checkuninitvar.h

1:
|
36:
37: class Scope ;
38: class Token ;
39: class Tokenizer ;
40: class Variable ;
41: class ErrorLogger ;
42: class Settings ;
43: class Library ;
44:
45: namespace tinyxml2 {
46: class XMLElement ;
47: }
48:
49:
50: struct VariableValue {
51: explicit VariableValue ( long long val@var2555 = 0 ) : value@var2556 ( val@var2555 ) , notEqual@var2557 ( false ) { }
52: long long value@var2556 ;
53: bool notEqual@var2557 ;
54: } ;
55:
|
61:
62: class CheckUninitVar : public Check {
63: public:
64:
65: CheckUninitVar ( ) : Check ( myName ( ) ) { }
66:
67:
68: CheckUninitVar ( const Tokenizer * tokenizer@var2558 , const Settings * settings@var2559 , ErrorLogger * errorLogger@var2560 )
69: : Check ( myName ( ) , tokenizer@var2558 , settings@var2559 , errorLogger@var2560 ) { }
70:
71:
72: void runChecks ( const Tokenizer * tokenizer@var2561 , const Settings * settings@var2562 , ErrorLogger * errorLogger@var2563 ) override {
73: CheckUninitVar checkUninitVar@var2564 (@expr1073747824 tokenizer@var2561 , settings@var2562 , errorLogger@var2563 ) ;
74: checkUninitVar@var2564 .@expr1073747825 valueFlowUninit (@expr1073747826 ) ;
75: checkUninitVar@var2564 .@expr1073747827 check (@expr1073747828 ) ;
76: }
77:
78: bool diag ( const Token * tok@var2565 ) ;
79:
80: void check ( ) ;
81: void checkScope ( const Scope * scope@var2566 , const std :: set < std :: string > & arrayTypeDefs@var2567 ) ;
82: void checkStruct ( const Token * tok@var2568 , const Variable & structvar@var2569 ) ;
83: enum Alloc { NO_ALLOC , NO_CTOR_CALL , CTOR_CALL , ARRAY } ;
84: bool checkScopeForVariable ( const Token * tok@var2570 , const Variable & var@var2571 , bool * const possibleInit@var2572 , bool * const noreturn@var2573 , Alloc * const alloc@var2574 , const std :: string & membervar@var2575 , std :: map < int , VariableValue > variableValue@var2576 ) ;
85: const Token * checkExpr ( const Token * tok@var2577 , const Variable & var@var2578 , const Alloc alloc@var2579 , bool known@var2580 , bool * bailout@var2581 = nullptr ) ;
86: bool checkIfForWhileHead ( const Token * startparentheses@var2582 , const Variable & var@var2583 , bool suppressErrors@var2584 , bool isuninit@var2585 , Alloc alloc@var2586 , const std :: string & membervar@var2587 ) ;
87: bool checkLoopBody ( const Token * tok@var2588 , const Variable & var@var2589 , const Alloc alloc@var2590 , const std :: string & membervar@var2591 , const bool suppressErrors@var2592 ) ;
88: const Token * checkLoopBodyRecursive ( const Token * start@var2593 , const Variable & var@var2594 , const Alloc alloc@var2595 , const std :: string & membervar@var2596 , bool & bailout@var2597 ) const ;
89: void checkRhs ( const Token * tok@var2598 , const Variable & var@var2599 , Alloc alloc@var2600 , int number_of_if@var2601 , const std :: string & membervar@var2602 ) ;
90: static const Token * isVariableUsage ( bool cpp@var2603 , const Token * vartok@var2604 , const Library & library@var2605 , bool pointer@var2606 , Alloc alloc@var2607 , int indirect@var2608 = 0 ) ;
91: const Token * isVariableUsage ( const Token * vartok@var2609 , bool pointer@var2610 , Alloc alloc@var2611 , int indirect@var2612 = 0 ) const ;
92: static int isFunctionParUsage ( const Token * vartok@var2613 , const Library & library@var2614 , bool pointer@var2615 , Alloc alloc@var2616 , int indirect@var2617 = 0 ) ;
93: int isFunctionParUsage ( const Token * vartok@var2618 , bool pointer@var2619 , Alloc alloc@var2620 , int indirect@var2621 = 0 ) const ;
94: bool isMemberVariableAssignment ( const Token * tok@var2622 , const std :: string & membervar@var2623 ) const ;
95: bool isMemberVariableUsage ( const Token * tok@var2624 , bool isPointer@var2625 , Alloc alloc@var2626 , const std :: string & membervar@var2627 ) const ;
96:
97:
98: void valueFlowUninit ( ) ;
99:
100:
101: class MyFileInfo : public Check :: FileInfo {
102: public:
103:
104: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var2628 ;
105:
106:
107: std :: string toString ( ) const override ;
108: } ;
109:
110:
111: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2629 , const Settings * settings@var2630 ) const override ;
112:
113: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2631 ) const override ;
114:
115:
116: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2632 , const std :: list < Check :: FileInfo * > & fileInfo@var2633 , const Settings & settings@var2634 , ErrorLogger & errorLogger@var2635 ) override ;
117:
118: void uninitvarError ( const Token * tok@var2636 , const ValueFlow :: Value & v@var2637 ) ;
119: void uninitstringError ( const Token * tok@var2638 , const std :: string & varname@var2639 , bool strncpy_@var2640 ) ;
120: void uninitdataError ( const Token * tok@var2641 , const std :: string & varname@var2642 ) ;
121: void uninitvarError ( const Token * tok@var2643 , const std :: string & varname@var2644 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2645 ) ;
122: void uninitvarError ( const Token * tok@var2646 , const std :: string & varname@var2647 ) {
123: std ::@expr1073747829 list < std ::@expr6006 pair < const Token *@expr1073747831 , std ::@expr6006 string > > errorPath@var2648 ;
124: uninitvarError (@expr1073747833 tok@var2646 , varname@var2647 , errorPath@var2648 ) ;
125: }
126: void uninitvarError ( const Token * tok@var2649 , const std :: string & varname@var2650 , Alloc alloc@var2651 ) {
127: if (@expr1073747834 alloc@var2651 ==@expr1073747835 NO_CTOR_CALL ||@expr1073747836 alloc@var2651 ==@expr1073747837 CTOR_CALL ) {
128: uninitdataError (@expr1073747838 tok@var2649 , varname@var2650 ) ; }
129: else {
130: uninitvarError (@expr1073747839 tok@var2649 , varname@var2650 ) ; }
131: }
132: void uninitStructMemberError ( const Token * tok@var2652 , const std :: string & membername@var2653 ) ;
133:
134: private:
135: std :: set < const Token * > mUninitDiags@var2654 ;
136: Check :: FileInfo * getFileInfo ( ) const ;
137: bool isUnsafeFunction ( const Scope * scope@var2655 , int argnr@var2656 , const Token * * tok@var2657 ) const ;
138:
139: void getErrorMessages ( ErrorLogger * errorLogger@var2658 , const Settings * settings@var2659 ) const override
140: {
141: CheckUninitVar c@var2660 (@expr1073747840 nullptr , settings@var2659 , errorLogger@var2658 ) ;
142:
143: ValueFlow ::@expr1073747841 Value v@var2661 {@expr1073747842 } ;
144:
145:
146: c@var2660 .@expr1073747843 uninitvarError (@expr1073747844 nullptr , v@var2661 ) ;
147: c@var2660 .@expr1073747845 uninitstringError (@expr1073747846 nullptr , "varname" , true ) ;
148: c@var2660 .@expr1073747847 uninitdataError (@expr1073747848 nullptr , "varname" ) ;
149: c@var2660 .@expr1073747849 uninitStructMemberError (@expr1073747850 nullptr , "a.b" ) ;
150: }
151:
152: static std :: string myName ( ) {
153: return "Uninitialized variables" ;
154: }
155:
156: std :: string classInfo ( ) const override {
157: return "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
158:
159: ;
160: }
161: } ;

##file cppcheck-2.8/lib/checkclass.h

1:
|
35:
36: class ErrorLogger ;
37: class Settings ;
38: class Token ;
39:
40: namespace CTU {
41: class FileInfo ;
42: }
43:
44: namespace tinyxml2 {
45: class XMLElement ;
46: }
47:
|
52:
53: class CheckClass : public Check {
54: public:
55:
56: CheckClass ( ) : Check ( myName ( ) ) , mSymbolDatabase@var2694 ( nullptr ) { }
57:
58:
59: CheckClass ( const Tokenizer * tokenizer@var2662 , const Settings * settings@var2663 , ErrorLogger * errorLogger@var2664 ) ;
60:
61:
62: void runChecks ( const Tokenizer * tokenizer@var2665 , const Settings * settings@var2666 , ErrorLogger * errorLogger@var2667 ) override {
63: if (@expr1073747851 tokenizer@var2665 .@expr1073747852 isC (@expr1073747853 ) ) {
64: return ; }
65:
66: CheckClass checkClass@var2668 (@expr1073747854 tokenizer@var2665 , settings@var2666 , errorLogger@var2667 ) ;
67:
68:
69: checkClass@var2668 .@expr1073747855 checkMemset (@expr1073747856 ) ;
70: checkClass@var2668 .@expr1073747857 constructors (@expr1073747858 ) ;
71: checkClass@var2668 .@expr1073747859 privateFunctions (@expr1073747860 ) ;
72: checkClass@var2668 .@expr1073747861 operatorEqRetRefThis (@expr1073747862 ) ;
73: checkClass@var2668 .@expr1073747863 thisSubtraction (@expr1073747864 ) ;
74: checkClass@var2668 .@expr1073747865 operatorEqToSelf (@expr1073747866 ) ;
75: checkClass@var2668 .@expr1073747867 initializerListOrder (@expr1073747868 ) ;
76: checkClass@var2668 .@expr1073747869 initializationListUsage (@expr1073747870 ) ;
77: checkClass@var2668 .@expr1073747871 checkSelfInitialization (@expr1073747872 ) ;
78: checkClass@var2668 .@expr1073747873 virtualDestructor (@expr1073747874 ) ;
79: checkClass@var2668 .@expr1073747875 checkConst (@expr1073747876 ) ;
80: checkClass@var2668 .@expr1073747877 copyconstructors (@expr1073747878 ) ;
81: checkClass@var2668 .@expr1073747879 checkVirtualFunctionCallInConstructor (@expr1073747880 ) ;
82: checkClass@var2668 .@expr1073747881 checkDuplInheritedMembers (@expr1073747882 ) ;
83: checkClass@var2668 .@expr1073747883 checkExplicitConstructors (@expr1073747884 ) ;
84: checkClass@var2668 .@expr1073747885 checkCopyCtorAndEqOperator (@expr1073747886 ) ;
85: checkClass@var2668 .@expr1073747887 checkOverride (@expr1073747888 ) ;
86: checkClass@var2668 .@expr1073747889 checkThisUseAfterFree (@expr1073747890 ) ;
87: checkClass@var2668 .@expr1073747891 checkUnsafeClassRefMember (@expr1073747892 ) ;
88: }
89:
90:
91: void constructors ( ) ;
92:
93:
94:
95: void checkExplicitConstructors ( ) ;
96:
97:
98: void privateFunctions ( ) ;
99:
|
107:
108: void checkMemset ( ) ;
109: void checkMemsetType ( const Scope * start@var2669 , const Token * tok@var2670 , const Scope * type@var2671 , bool allocation@var2672 , std :: set < const Scope * > parsedTypes@var2673 ) ;
110:
111:
112: void operatorEqRetRefThis ( ) ;
113:
114:
115: void operatorEqToSelf ( ) ;
116:
117:
118: void virtualDestructor ( ) ;
119:
120:
121: void thisSubtraction ( ) ;
122:
123:
124: void checkConst ( ) ;
125:
126:
127: void initializerListOrder ( ) ;
128:
129:
130: void initializationListUsage ( ) ;
131:
132:
133: void checkSelfInitialization ( ) ;
134:
135: void copyconstructors ( ) ;
136:
137:
138: void checkVirtualFunctionCallInConstructor ( ) ;
139:
140:
141: void checkDuplInheritedMembers ( ) ;
142:
143:
144: void checkCopyCtorAndEqOperator ( ) ;
145:
146:
147: void checkOverride ( ) ;
148:
149:
150: void checkThisUseAfterFree ( ) ;
151:
152:
153: void checkUnsafeClassRefMember ( ) ;
154:
155:
156:
157: class MyFileInfo : public Check :: FileInfo {
158: public:
159: struct NameLoc {
160: std :: string className@var2674 ;
161: std :: string fileName@var2675 ;
162: int lineNumber@var2676 ;
163: int column@var2677 ;
164: unsigned long hash@var2678 ;
165:
166: bool operator== ( const NameLoc & other@var2679 ) const {
167: return isSameLocation (@expr1073747893 other@var2679 ) &&@expr1073747894 hash@var2678 ==@expr1073747895 other@var2679 .@expr1073747896 hash@var2680 ;
168: }
169:
170: bool isSameLocation ( const NameLoc & other@var2681 ) const {
171: return fileName@var2675 ==@expr1073747897 other@var2681 .@expr1073747898 fileName@var2682 &&@expr1073747899
172: lineNumber@var2676 ==@expr1073747900 other@var2681 .@expr1073747901 lineNumber@var2683 &&@expr1073747902
173: column@var2677 ==@expr1073747903 other@var2681 .@expr1073747904 column@var2684 ;
174: }
175: } ;
176: std :: vector < NameLoc > classDefinitions@var2685 ;
177:
178:
179: std :: string toString ( ) const override ;
180: } ;
181:
182:
183: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2686 , const Settings * settings@var2687 ) const override ;
184:
185: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2688 ) const override ;
186:
187:
188: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2689 , const std :: list < Check :: FileInfo * > & fileInfo@var2690 , const Settings & settings@var2691 , ErrorLogger & errorLogger@var2692 ) override ;
189:
190:
191: static const std :: set < std :: string > stl_containers_not_const@var2693 ;
192:
193: private:
194: const SymbolDatabase * mSymbolDatabase@var2694 ;
195:
196:
197: void noConstructorError ( const Token * tok@var2695 , const std :: string & classname@var2696 , bool isStruct@var2697 ) ;
198: void noExplicitConstructorError ( const Token * tok@var2698 , const std :: string & classname@var2699 , bool isStruct@var2700 ) ;
199:
200: void copyConstructorShallowCopyError ( const Token * tok@var2701 , const std :: string & varname@var2702 ) ;
201: void noCopyConstructorError ( const Scope * scope@var2703 , bool isdefault@var2704 , const Token * alloc@var2705 , bool inconclusive@var2706 ) ;
202: void noOperatorEqError ( const Scope * scope@var2707 , bool isdefault@var2708 , const Token * alloc@var2709 , bool inconclusive@var2710 ) ;
203: void noDestructorError ( const Scope * scope@var2711 , bool isdefault@var2712 , const Token * alloc@var2713 ) ;
204: void uninitVarError ( const Token * tok@var2714 , bool isprivate@var2715 , Function :: Type functionType@var2716 , const std :: string & classname@var2717 , const std :: string & varname@var2718 , bool derived@var2719 , bool inconclusive@var2720 ) ;
205: void uninitVarError ( const Token * tok@var2721 , const std :: string & classname@var2722 , const std :: string & varname@var2723 ) ;
206: void missingMemberCopyError ( const Token * tok@var2724 , Function :: Type functionType@var2725 , const std :: string & classname@var2726 , const std :: string & varname@var2727 ) ;
207: void operatorEqVarError ( const Token * tok@var2728 , const std :: string & classname@var2729 , const std :: string & varname@var2730 , bool inconclusive@var2731 ) ;
208: void unusedPrivateFunctionError ( const Token * tok@var2732 , const std :: string & classname@var2733 , const std :: string & funcname@var2734 ) ;
209: void memsetError ( const Token * tok@var2735 , const std :: string & memfunc@var2736 , const std :: string & classname@var2737 , const std :: string & type@var2738 ) ;
210: void memsetErrorReference ( const Token * tok@var2739 , const std :: string & memfunc@var2740 , const std :: string & type@var2741 ) ;
211: void memsetErrorFloat ( const Token * tok@var2742 , const std :: string & type@var2743 ) ;
212: void mallocOnClassError ( const Token * tok@var2744 , const std :: string & memfunc@var2745 , const Token * classTok@var2746 , const std :: string & classname@var2747 ) ;
213: void mallocOnClassWarning ( const Token * tok@var2748 , const std :: string & memfunc@var2749 , const Token * classTok@var2750 ) ;
214: void virtualDestructorError ( const Token * tok@var2751 , const std :: string & Base@var2752 , const std :: string & Derived@var2753 , bool inconclusive@var2754 ) ;
215: void thisSubtractionError ( const Token * tok@var2755 ) ;
216: void operatorEqRetRefThisError ( const Token * tok@var2756 ) ;
217: void operatorEqShouldBeLeftUnimplementedError ( const Token * tok@var2757 ) ;
218: void operatorEqMissingReturnStatementError ( const Token * tok@var2758 , bool error@var2759 ) ;
219: void operatorEqToSelfError ( const Token * tok@var2760 ) ;
220: void checkConstError ( const Token * tok@var2761 , const std :: string & classname@var2762 , const std :: string & funcname@var2763 , bool suggestStatic@var2764 ) ;
221: void checkConstError2 ( const Token * tok1@var2765 , const Token * tok2@var2766 , const std :: string & classname@var2767 , const std :: string & funcname@var2768 , bool suggestStatic@var2769 ) ;
222: void initializerListError ( const Token * tok1@var2770 , const Token * tok2@var2771 , const std :: string & classname@var2772 , const std :: string & varname@var2773 ) ;
223: void suggestInitializationList ( const Token * tok@var2774 , const std :: string & varname@var2775 ) ;
224: void selfInitializationError ( const Token * tok@var2776 , const std :: string & varname@var2777 ) ;
225: void pureVirtualFunctionCallInConstructorError ( const Function * scopeFunction@var2778 , const std :: list < const Token * > & tokStack@var2779 , const std :: string & purefuncname@var2780 ) ;
226: void virtualFunctionCallInConstructorError ( const Function * scopeFunction@var2781 , const std :: list < const Token * > & tokStack@var2782 , const std :: string & funcname@var2783 ) ;
227: void duplInheritedMembersError ( const Token * tok1@var2784 , const Token * tok2@var2785 , const std :: string & derivedName@var2786 , const std :: string & baseName@var2787 , const std :: string & variableName@var2788 , bool derivedIsStruct@var2789 , bool baseIsStruct@var2790 ) ;
228: void copyCtorAndEqOperatorError ( const Token * tok@var2791 , const std :: string & classname@var2792 , bool isStruct@var2793 , bool hasCopyCtor@var2794 ) ;
229: void overrideError ( const Function * funcInBase@var2795 , const Function * funcInDerived@var2796 ) ;
230: void thisUseAfterFree ( const Token * self@var2797 , const Token * free@var2798 , const Token * use@var2799 ) ;
231: void unsafeClassRefMemberError ( const Token * tok@var2800 , const std :: string & varname@var2801 ) ;
232: void checkDuplInheritedMembersRecursive ( const Type * typeCurrent@var2802 , const Type * typeBase@var2803 ) ;
233:
234: void getErrorMessages ( ErrorLogger * errorLogger@var2804 , const Settings * settings@var2805 ) const override {
235: CheckClass c@var2806 (@expr1073747905 nullptr , settings@var2805 , errorLogger@var2804 ) ;
236: c@var2806 .@expr1073747906 noConstructorError (@expr1073747907 nullptr , "classname" , false ) ;
237: c@var2806 .@expr1073747908 noExplicitConstructorError (@expr1073747909 nullptr , "classname" , false ) ;
238:
239: c@var2806 .@expr1073747910 copyConstructorShallowCopyError (@expr1073747911 nullptr , "var" ) ;
240: c@var2806 .@expr1073747912 noCopyConstructorError (@expr1073747913 nullptr , false , nullptr , false ) ;
241: c@var2806 .@expr1073747914 noOperatorEqError (@expr1073747915 nullptr , false , nullptr , false ) ;
242: c@var2806 .@expr1073747916 noDestructorError (@expr1073747917 nullptr , false , nullptr ) ;
243: c@var2806 .@expr6094 uninitVarError (@expr1073747919 nullptr , false , Function ::@expr6096 eConstructor , "classname" , "varname" , false , false ) ;
244: c@var2806 .@expr6094 uninitVarError (@expr1073747922 nullptr , true , Function ::@expr6096 eConstructor , "classname" , "varnamepriv" , false , false ) ;
245: c@var2806 .@expr6094 uninitVarError (@expr1073747925 nullptr , false , Function ::@expr6096 eConstructor , "classname" , "varname" , true , false ) ;
246: c@var2806 .@expr6094 uninitVarError (@expr1073747928 nullptr , true , Function ::@expr6096 eConstructor , "classname" , "varnamepriv" , true , false ) ;
247: c@var2806 .@expr1073747930 missingMemberCopyError (@expr1073747931 nullptr , Function ::@expr6096 eConstructor , "classname" , "varnamepriv" ) ;
248: c@var2806 .@expr1073747933 operatorEqVarError (@expr1073747934 nullptr , "classname" , emptyString@var1 , false ) ;
249: c@var2806 .@expr1073747935 unusedPrivateFunctionError (@expr1073747936 nullptr , "classname" , "funcname" ) ;
250: c@var2806 .@expr1073747937 memsetError (@expr1073747938 nullptr , "memfunc" , "classname" , "class" ) ;
251: c@var2806 .@expr1073747939 memsetErrorReference (@expr1073747940 nullptr , "memfunc" , "class" ) ;
252: c@var2806 .@expr1073747941 memsetErrorFloat (@expr1073747942 nullptr , "class" ) ;
253: c@var2806 .@expr1073747943 mallocOnClassWarning (@expr1073747944 nullptr , "malloc" , nullptr ) ;
254: c@var2806 .@expr1073747945 mallocOnClassError (@expr1073747946 nullptr , "malloc" , nullptr , "std::string" ) ;
255: c@var2806 .@expr1073747947 virtualDestructorError (@expr1073747948 nullptr , "Base" , "Derived" , false ) ;
256: c@var2806 .@expr1073747949 thisSubtractionError (@expr1073747950 nullptr ) ;
257: c@var2806 .@expr1073747951 operatorEqRetRefThisError (@expr1073747952 nullptr ) ;
258: c@var2806 .@expr1073747953 operatorEqMissingReturnStatementError (@expr1073747954 nullptr , true ) ;
259: c@var2806 .@expr1073747955 operatorEqShouldBeLeftUnimplementedError (@expr1073747956 nullptr ) ;
260: c@var2806 .@expr1073747957 operatorEqToSelfError (@expr1073747958 nullptr ) ;
261: c@var2806 .@expr6135 checkConstError (@expr1073747960 nullptr , "class" , "function" , false ) ;
262: c@var2806 .@expr6135 checkConstError (@expr1073747962 nullptr , "class" , "function" , true ) ;
263: c@var2806 .@expr1073747963 initializerListError (@expr1073747964 nullptr , nullptr , "class" , "variable" ) ;
264: c@var2806 .@expr1073747965 suggestInitializationList (@expr1073747966 nullptr , "variable" ) ;
265: c@var2806 .@expr1073747967 selfInitializationError (@expr1073747968 nullptr , "var" ) ;
266: c@var2806 .@expr1073747969 duplInheritedMembersError (@expr1073747970 nullptr , nullptr , "class" , "class" , "variable" , false , false ) ;
267: c@var2806 .@expr1073747971 copyCtorAndEqOperatorError (@expr1073747972 nullptr , "class" , false , false ) ;
268: c@var2806 .@expr1073747973 pureVirtualFunctionCallInConstructorError (@expr1073747974 nullptr , std ::@expr6151 list < const Token *@expr6152 > (@expr6153 ) , "f" ) ;
269: c@var2806 .@expr1073747978 virtualFunctionCallInConstructorError (@expr1073747979 nullptr , std ::@expr6151 list < const Token *@expr6152 > (@expr6153 ) , "f" ) ;
270: c@var2806 .@expr1073747983 overrideError (@expr1073747984 nullptr , nullptr ) ;
271: c@var2806 .@expr1073747985 thisUseAfterFree (@expr1073747986 nullptr , nullptr , nullptr ) ;
272: c@var2806 .@expr1073747987 unsafeClassRefMemberError (@expr1073747988 nullptr , "UnsafeClass::var" ) ;
273: }
274:
275: static std :: string myName ( ) {
276: return "Class" ;
277: }
278:
279: std :: string classInfo ( ) const override {
280: return "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
281:
|
301:
302: ;
303: }
304:
305:
306: void checkReturnPtrThis ( const Scope * scope@var2807 , const Function * func@var2808 , const Token * tok@var2809 , const Token * last@var2810 ) ;
307: void checkReturnPtrThis ( const Scope * scope@var2811 , const Function * func@var2812 , const Token * tok@var2813 , const Token * last@var2814 , std :: set < const Function * > & analyzedFunctions@var2815 ) ;
308:
309:
310: bool hasAllocation ( const Function * func@var2816 , const Scope * scope@var2817 ) const ;
311: bool hasAllocation ( const Function * func@var2818 , const Scope * scope@var2819 , const Token * start@var2820 , const Token * end@var2821 ) const ;
312: bool hasAllocationInIfScope ( const Function * func@var2822 , const Scope * scope@var2823 , const Token * ifStatementScopeStart@var2824 ) const ;
313: static bool hasAssignSelf ( const Function * func@var2825 , const Token * rhs@var2826 , const Token * * out_ifStatementScopeStart@var2827 ) ;
314: enum class Bool { TRUE , FALSE , BAILOUT } ;
315: static Bool isInverted ( const Token * tok@var2828 , const Token * rhs@var2829 ) ;
316: static const Token * getIfStmtBodyStart ( const Token * tok@var2830 , const Token * rhs@var2831 ) ;
317:
318:
319: bool isMemberVar ( const Scope * scope@var2832 , const Token * tok@var2833 ) const ;
320: bool isMemberFunc ( const Scope * scope@var2834 , const Token * tok@var2835 ) const ;
321: bool isConstMemberFunc ( const Scope * scope@var2836 , const Token * tok@var2837 ) const ;
322: bool checkConstFunc ( const Scope * scope@var2838 , const Function * func@var2839 , bool & memberAccessed@var2840 ) const ;
323:
324:
325:
326: struct Usage {
327: explicit Usage ( const Variable * var@var2841 ) : var@var2842 ( var@var2841 ) , assign@var2843 ( false ) , init@var2844 ( false ) { }
328:
329:
330: const Variable * var@var2842 ;
331:
332:
333: bool assign@var2843 ;
334:
335:
336: bool init@var2844 ;
337: } ;
338:
339: static bool isBaseClassFunc ( const Token * tok@var2845 , const Scope * scope@var2846 ) ;
340:
|
345:
346: static std :: vector < Usage > createUsageList ( const Scope * scope@var2847 ) ;
347:
|
352:
353: static void assignVar ( std :: vector < Usage > & usageList@var2848 , int varid@var2849 ) ;
354:
|
359:
360: static void initVar ( std :: vector < Usage > & usageList@var2850 , int varid@var2851 ) ;
361:
|
365:
366: static void assignAllVar ( std :: vector < Usage > & usageList@var2852 ) ;
367:
|
371:
372: static void clearAllVar ( std :: vector < Usage > & usageList@var2853 ) ;
373:
|
380:
381: void initializeVarList ( const Function & func@var2854 , std :: list < const Function * > & callstack@var2855 , const Scope * scope@var2856 , std :: vector < Usage > & usage@var2857 ) ;
382:
|
388:
389: const std :: list < const Token * > & getVirtualFunctionCalls (
390: const Function & function@var2858 ,
391: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var2859 ) ;
392:
|
398:
399: void getFirstVirtualFunctionCallStack (
400: std :: map < const Function * , std :: list < const Token * > > & virtualFunctionCallsMap@var2860 ,
401: const Token * callToken@var2861 ,
402: std :: list < const Token * > & pureFuncStack@var2862 ) ;
403:
404: static bool canNotCopy ( const Scope * scope@var2863 ) ;
405:
406: static bool canNotMove ( const Scope * scope@var2864 ) ;
407:
|
410:
411: bool checkThisUseAfterFreeRecursive ( const Scope * classScope@var2865 , const Function * func@var2866 , const Variable * selfPointer@var2867 , std :: set < const Function * > callstack@var2868 , const Token * * freeToken@var2869 ) ;
412: } ;

##file cppcheck-2.8/lib/checkother.cpp

1:
|
48:
49: namespace {
50: CheckOther instance@var2870 ;
51: }
52:
53: static const struct CWE CWE128@var2871 ( 128U ) ;
54: static const struct CWE CWE131@var2872 ( 131U ) ;
55: static const struct CWE CWE197@var2873 ( 197U ) ;
56: static const struct CWE CWE362@var2874 ( 362U ) ;
57: static const struct CWE CWE369@var2875 ( 369U ) ;
58: static const struct CWE CWE398@var2876 ( 398U ) ;
59: static const struct CWE CWE475@var2877 ( 475U ) ;
60: static const struct CWE CWE482@var2878 ( 482U ) ;
61: static const struct CWE CWE561@var2879 ( 561U ) ;
62: static const struct CWE CWE563@var2880 ( 563U ) ;
63: static const struct CWE CWE570@var2881 ( 570U ) ;
64: static const struct CWE CWE571@var2882 ( 571U ) ;
65: static const struct CWE CWE672@var2883 ( 672U ) ;
66: static const struct CWE CWE628@var2884 ( 628U ) ;
67: static const struct CWE CWE683@var2885 ( 683U ) ;
68: static const struct CWE CWE686@var2886 ( 686U ) ;
69: static const struct CWE CWE704@var2887 ( 704U ) ;
70: static const struct CWE CWE758@var2888 ( 758U ) ;
71: static const struct CWE CWE768@var2889 ( 768U ) ;
72: static const struct CWE CWE783@var2890 ( 783U ) ;
73:
|
85:
86: void CheckOther :: checkCastIntToCharAndBack ( )
87: {
88: if (@expr1073747989 !@expr1073747990 mSettings@var29 .@expr1073747991 severity@var3736 .@expr1073747992 isEnabled (@expr1073747993 Severity ::@expr1073747994 warning ) ) {
89: return ; }
90:
91: const SymbolDatabase * symbolDatabase@var2891 ; symbolDatabase@var2891 =@expr1073747995 mTokenizer@var28 .@expr1073747996 getSymbolDatabase (@expr1073747997 ) ;
92: for (@expr1073747998 const Scope *@expr6175 scope@var2892 :@expr1073748000 symbolDatabase@var2891 .@expr1073748001 functionScopes@var2893 ) {
93: std ::@expr1073748002 map < int , std ::@expr1073748003 string > vars@var2894 ;
94: for (@expr1073748004 const Token *@expr6175 tok@var2895 =@expr1073748006 scope@var2892 .@expr1073748007 bodyStart@var2896 .@expr1073748008 next (@expr1073748009 ) ; tok@var2895 !=@expr1073748010 scope@var2892 .@expr1073748011 bodyEnd@var2897 ; tok@var2895 =@expr1073748012 tok@var2895 .@expr1073748013 next (@expr1073748014 ) ) {
95:
96: if (@expr1073748015 !@expr1073748016 Token ::@expr6193 Match (@expr1073748018 tok@var2895 , "%var%|EOF %comp%|=" ) ) {
97: continue ; }
98: if (@expr1073748019 Token ::@expr6193 Match (@expr1073748021 tok@var2895 , "%var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (" ) ) {
99: const Variable * var@var2898 ; var@var2898 =@expr1073748022 tok@var2895 .@expr6199 variable (@expr6200 ) ;
100: if (@expr1073748025 var@var2898 &&@expr1073748026 var@var2898 .@expr6203 typeEndToken (@expr6204 ) .@expr1073748029 str (@expr1073748030 ) ==@expr1073748031 "char" &&@expr1073748032 !@expr1073748033 var@var2898 .@expr6203 typeEndToken (@expr6204 ) .@expr1073748036 isSigned (@expr1073748037 ) ) {
101: vars@var2894 [@expr6214 tok@var2895 .@expr6215 varId (@expr6216 ) ] =@expr1073748041 tok@var2895 .@expr6218 strAt (@expr6219 2 ) ;
102: }
103: } else { if (@expr1073748044 Token ::@expr6193 Match (@expr1073748046 tok@var2895 , "EOF %comp% ( %var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (" ) ) {
104: tok@var2895 =@expr1073748047 tok@var2895 .@expr6224 tokAt (@expr6225 3 ) ;
105: const Variable * var@var2899 ; var@var2899 =@expr1073748050 tok@var2895 .@expr6199 variable (@expr6200 ) ;
106: if (@expr1073748053 var@var2899 &&@expr1073748054 var@var2899 .@expr6231 typeEndToken (@expr6232 ) .@expr1073748057 str (@expr1073748058 ) ==@expr1073748059 "char" &&@expr1073748060 !@expr1073748061 var@var2899 .@expr6231 typeEndToken (@expr6232 ) .@expr1073748064 isSigned (@expr1073748065 ) ) {
107: checkCastIntToCharAndBackError (@expr1073748066 tok@var2895 , tok@var2895 .@expr6218 strAt (@expr6219 2 ) ) ;
108: }
109: } else { if (@expr1073748069 mTokenizer@var28 .@expr6246 isCPP (@expr6247 ) &&@expr1073748072 (@expr1073748073 Token ::@expr6193 Match (@expr1073748075 tok@var2895 , "EOF %comp% ( %var% = std :: cin . get (" ) ||@expr1073748076 Token ::@expr6193 Match (@expr1073748078 tok@var2895 , "EOF %comp% ( %var% = cin . get (" ) ) ) {
110: tok@var2895 =@expr1073748079 tok@var2895 .@expr6224 tokAt (@expr6225 3 ) ;
111: const Variable * var@var2900 ; var@var2900 =@expr1073748082 tok@var2895 .@expr6199 variable (@expr6200 ) ;
112: if (@expr1073748085 var@var2900 &&@expr1073748086 var@var2900 .@expr6263 typeEndToken (@expr6264 ) .@expr1073748089 str (@expr1073748090 ) ==@expr1073748091 "char" &&@expr1073748092 !@expr1073748093 var@var2900 .@expr6263 typeEndToken (@expr6264 ) .@expr1073748096 isSigned (@expr1073748097 ) ) {
113: checkCastIntToCharAndBackError (@expr1073748098 tok@var2895 , "cin.get" ) ;
114: }
115: } else { if (@expr1073748099 mTokenizer@var28 .@expr6246 isCPP (@expr6247 ) &&@expr1073748102 (@expr1073748103 Token ::@expr6193 Match (@expr1073748105 tok@var2895 , "%var% = std :: cin . get (" ) ||@expr1073748106 Token ::@expr6193 Match (@expr1073748108 tok@var2895 , "%var% = cin . get (" ) ) ) {
116: const Variable * var@var2901 ; var@var2901 =@expr1073748109 tok@var2895 .@expr6199 variable (@expr6200 ) ;
117: if (@expr1073748112 var@var2901 &&@expr1073748113 var@var2901 .@expr6290 typeEndToken (@expr6291 ) .@expr1073748116 str (@expr1073748117 ) ==@expr1073748118 "char" &&@expr1073748119 !@expr1073748120 var@var2901 .@expr6290 typeEndToken (@expr6291 ) .@expr1073748123 isSigned (@expr1073748124 ) ) {
118: vars@var2894 [@expr6214 tok@var2895 .@expr6215 varId (@expr6216 ) ] =@expr1073748128 "cin.get" ;
119: }
120: } else { if (@expr1073748129 Token ::@expr6193 Match (@expr1073748131 tok@var2895 , "%var% %comp% EOF" ) ) {
121: if (@expr6308 vars@var2894 .@expr6309 find (@expr6310 tok@var2895 .@expr6215 varId (@expr6216 ) ) !=@expr6313 vars@var2894 .@expr6314 end (@expr6315 ) ) {
122: checkCastIntToCharAndBackError (@expr6316 tok@var2895 , vars@var2894 [@expr6214 tok@var2895 .@expr6215 varId (@expr6216 ) ] ) ;
123: }
124: } else { if (@expr1073748144 Token ::@expr6193 Match (@expr1073748146 tok@var2895 , "EOF %comp% %var%" ) ) {
125: tok@var2895 =@expr1073748147 tok@var2895 .@expr6224 tokAt (@expr1073748149 2 ) ;
126: if (@expr6308 vars@var2894 .@expr6309 find (@expr6310 tok@var2895 .@expr6215 varId (@expr6216 ) ) !=@expr6313 vars@var2894 .@expr6314 end (@expr6315 ) ) {
127: checkCastIntToCharAndBackError (@expr6316 tok@var2895 , vars@var2894 [@expr6214 tok@var2895 .@expr6215 varId (@expr6216 ) ] ) ;
128: }
129: } } } } } }
130: }
131: }
132: }
133:
134: void CheckOther :: checkCastIntToCharAndBackError ( const Token * tok@var2902 , const std :: string & strFunctionName@var2903 )
135: {
136: reportError (@expr1073748162
137: tok@var2902 ,
138: Severity ::@expr1073748163 warning ,
139: "checkCastIntToCharAndBack" ,
140: "$symbol:" +@expr1073748164 strFunctionName@var2903 +@expr1073748165 "\nStoring $symbol() return value in char variable and then comparing with EOF.\nWhen saving $symbol() return value in char variable there is loss of precision.  When $symbol() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop \"while (EOF != (c = $symbol());\" loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character."
141:
|
145:
146: , CWE197@var2873 , Certainty ::@expr1073748166 normal
147: ) ;
148: }
149:
|
153:
154: void CheckOther :: clarifyCalculation ( )
155: {
156: if (@expr1073748167 !@expr1073748168 mSettings@var29 .@expr1073748169 severity@var3736 .@expr1073748170 isEnabled (@expr1073748171 Severity ::@expr1073748172 style ) ) {
157: return ; }
158:
159: const SymbolDatabase * symbolDatabase@var2904 ; symbolDatabase@var2904 =@expr1073748173 mTokenizer@var28 .@expr1073748174 getSymbolDatabase (@expr1073748175 ) ;
160: for (@expr1073748176 const Scope *@expr6353 scope@var2905 :@expr1073748178 symbolDatabase@var2904 .@expr1073748179 functionScopes@var2906 ) {
161: for (@expr1073748180 const Token *@expr6353 tok@var2907 =@expr1073748182 scope@var2905 .@expr1073748183 bodyStart@var2908 .@expr1073748184 next (@expr1073748185 ) ; tok@var2907 !=@expr1073748186 scope@var2905 .@expr1073748187 bodyEnd@var2909 ; tok@var2907 =@expr1073748188 tok@var2907 .@expr1073748189 next (@expr1073748190 ) ) {
162:
163: if (@expr1073748191 tok@var2907 .@expr1073748192 str (@expr1073748193 ) !=@expr1073748194 "?" ||@expr1073748195 !@expr1073748196 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) ||@expr1073748199 !@expr1073748200 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr1073748203 isCalculation (@expr1073748204 ) ) {
164: continue ; }
165: if (@expr1073748205 !@expr1073748206 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr1073748209 isArithmeticalOp (@expr1073748210 ) &&@expr1073748211 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6390 tokType (@expr6391 ) !=@expr1073748216 Token ::@expr6393 eBitOp ) {
166: continue ; }
167:
168:
169: if (@expr1073748218 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6397 isBinaryOp (@expr6398 ) &&@expr1073748223 Token ::@expr6400 Match (@expr1073748225 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) , "%or%|&|%|*|/" ) &&@expr1073748228 tok@var2907 .@expr6405 astOperand2 (@expr6406 ) .@expr6407 valueType (@expr6408 ) &&@expr1073748233 tok@var2907 .@expr6405 astOperand2 (@expr6406 ) .@expr6407 valueType (@expr6408 ) .@expr1073748238 pointer@var3770 >@expr1073748239 0 ) {
170: continue ; }
171:
172:
173: if (@expr1073748240 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6390 tokType (@expr6391 ) ==@expr1073748245 Token ::@expr6393 eBitOp &&@expr1073748247 Token ::@expr6400 Match (@expr1073748249 tok@var2907 .@expr6405 astOperand2 (@expr6406 ) .@expr1073748252 astOperand1 (@expr1073748253 ) , "%char%" ) &&@expr1073748254 Token ::@expr6400 Match (@expr1073748256 tok@var2907 .@expr6405 astOperand2 (@expr6406 ) .@expr1073748259 astOperand2 (@expr1073748260 ) , "%char%" ) ) {
174: continue ; }
175:
176:
177: if (@expr1073748261 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6397 isBinaryOp (@expr6398 ) &&@expr1073748266 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6445 astOperand2 (@expr6446 ) .@expr1073748271 hasKnownIntValue (@expr1073748272 ) ) {
178: const Token * op@var2910 ; op@var2910 =@expr1073748273 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr6445 astOperand2 (@expr6446 ) ;
179: if (@expr1073748278 op@var2910 .@expr1073748279 isNumber (@expr1073748280 ) ) {
180: continue ; }
181: if (@expr1073748281 op@var2910 .@expr6458 valueType (@expr6459 ) &&@expr1073748284 op@var2910 .@expr6458 valueType (@expr6459 ) .@expr1073748287 isEnum (@expr1073748288 ) ) {
182: continue ; }
183: }
184:
185:
186: const Token * tok2@var2911 ; tok2@var2911 =@expr1073748289 tok@var2907 .@expr6373 astOperand1 (@expr6374 ) ;
187: for (@expr1073748292 ; tok2@var2911 ; tok2@var2911 =@expr1073748293 tok2@var2911 .@expr1073748294 next (@expr1073748295 ) ) {
188: if (@expr1073748296 tok2@var2911 .@expr6473 str (@expr6474 ) ==@expr1073748299 "(" ) {
189: tok2@var2911 =@expr1073748300 tok2@var2911 .@expr1073748301 link (@expr1073748302 ) ; }
190: else { if (@expr1073748303 tok2@var2911 .@expr6473 str (@expr6474 ) ==@expr1073748306 ")" ) {
191: break ; }
192: else { if (@expr1073748307 tok2@var2911 .@expr6473 str (@expr6474 ) ==@expr1073748310 "?" ) {
193: clarifyCalculationError (@expr1073748311 tok@var2907 , tok@var2907 .@expr6373 astOperand1 (@expr6374 ) .@expr1073748314 str (@expr1073748315 ) ) ;
194: break ;
195: } } }
196: }
197: }
198: }
199: }
200:
201: void CheckOther :: clarifyCalculationError ( const Token * tok@var2912 , const std :: string & op@var2913 )
202: {
203:
204: const std ::@expr1073748316 string calc@var2914 (@expr1073748317 "'a" +@expr6494 op@var2913 +@expr1073748319 "b?c:d'" ) ;
205:
206:
207: const std ::@expr1073748320 string s1@var2915 (@expr1073748321 "'(a" +@expr1073748322 op@var2913 +@expr1073748323 "b)?c:d'" ) ;
208:
209:
210: const std ::@expr1073748324 string s2@var2916 (@expr1073748325 "'a" +@expr6494 op@var2913 +@expr1073748327 "(b?c:d)'" ) ;
211:
212: reportError (@expr1073748328 tok@var2912 ,
213: Severity ::@expr1073748329 style ,
214: "clarifyCalculation" ,
215: "Clarify calculation precedence for '" +@expr1073748330 op@var2913 +@expr1073748331 "' and '?'.\nSuspicious calculation. Please use parentheses to clarify the code. The code '"
216:
217: +@expr1073748332 calc@var2914 +@expr1073748333 "' should be written as either '" +@expr1073748334 s1@var2915 +@expr1073748335 "' or '" +@expr1073748336 s2@var2916 +@expr1073748337 "'." , CWE783@var2890 , Certainty ::@expr1073748338 normal ) ;
218: }
219:
|
222:
223: void CheckOther :: clarifyStatement ( )
224: {
225: if (@expr1073748339 !@expr1073748340 mSettings@var29 .@expr1073748341 severity@var3736 .@expr1073748342 isEnabled (@expr1073748343 Severity ::@expr1073748344 warning ) ) {
226: return ; }
227:
228: const SymbolDatabase * symbolDatabase@var2917 ; symbolDatabase@var2917 =@expr1073748345 mTokenizer@var28 .@expr1073748346 getSymbolDatabase (@expr1073748347 ) ;
229: for (@expr1073748348 const Scope *@expr6525 scope@var2918 :@expr1073748350 symbolDatabase@var2917 .@expr1073748351 functionScopes@var2919 ) {
230: for (@expr1073748352 const Token *@expr6525 tok@var2920 =@expr1073748354 scope@var2918 .@expr1073748355 bodyStart@var2921 ; tok@var2920 &&@expr1073748356 tok@var2920 !=@expr1073748357 scope@var2918 .@expr1073748358 bodyEnd@var2922 ; tok@var2920 =@expr1073748359 tok@var2920 .@expr1073748360 next (@expr1073748361 ) ) {
231: if (@expr1073748362 Token ::@expr6539 Match (@expr1073748364 tok@var2920 , "* %name%" ) &&@expr1073748365 tok@var2920 .@expr6542 astOperand1 (@expr6543 ) ) {
232: const Token * tok2@var2923 ; tok2@var2923 =@expr1073748368 tok@var2920 .@expr1073748369 previous (@expr1073748370 ) ;
233:
234: while (@expr1073748371 tok2@var2923 &&@expr1073748372 tok2@var2923 .@expr1073748373 str (@expr1073748374 ) ==@expr1073748375 "*" ) {
235: tok2@var2923 =@expr1073748376 tok2@var2923 .@expr1073748377 previous (@expr1073748378 ) ; }
236:
237: if (@expr1073748379 tok2@var2923 &&@expr1073748380 !@expr1073748381 tok2@var2923 .@expr1073748382 astParent (@expr1073748383 ) &&@expr1073748384 Token ::@expr6539 Match (@expr1073748386 tok2@var2923 , "[{};]" ) ) {
238: tok2@var2923 =@expr1073748387 tok@var2920 .@expr6542 astOperand1 (@expr6543 ) ;
239: if (@expr1073748390 Token ::@expr6539 Match (@expr1073748392 tok2@var2923 , "++|-- [;,]" ) ) {
240: clarifyStatementError (@expr1073748393 tok2@var2923 ) ; }
241: }
242: }
243: }
244: }
245: }
246:
247: void CheckOther :: clarifyStatementError ( const Token * tok@var2924 )
248: {
249: reportError (@expr1073748394 tok@var2924 , Severity ::@expr1073748395 warning , "clarifyStatement" , "In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?\nA statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?"
250:
251: , CWE783@var2890 , Certainty ::@expr1073748396 normal ) ;
252: }
253:
|
256:
257: void CheckOther :: checkSuspiciousSemicolon ( )
258: {
259: if (@expr1073748398 !@expr1073748399 mSettings@var29 .@expr1073748400 certainty@var3737 .@expr1073748401 isEnabled (@expr1073748402 Certainty ::@expr1073748403 inconclusive@expr1073748397 ) ||@expr1073748404 !@expr1073748405 mSettings@var29 .@expr1073748406 severity@var3736 .@expr1073748407 isEnabled (@expr1073748408 Severity ::@expr1073748409 warning ) ) {
260: return ; }
261:
262: const SymbolDatabase * const symbolDatabase@var2925 ; symbolDatabase@var2925 =@expr1073748410 mTokenizer@var28 .@expr1073748411 getSymbolDatabase (@expr1073748412 ) ;
263:
264:
265: for (@expr1073748413 const Scope &@expr1073748414 scope@var2926 :@expr1073748415 symbolDatabase@var2925 .@expr1073748416 scopeList@var2927 ) {
266: if (@expr1073748417 scope@var2926 .@expr6594 type@var2928 ==@expr1073748419 Scope ::@expr1073748420 eIf ||@expr1073748421 scope@var2926 .@expr6594 type@var2928 ==@expr1073748423 Scope ::@expr1073748424 eElse ||@expr1073748425 scope@var2926 .@expr6594 type@var2928 ==@expr1073748427 Scope ::@expr1073748428 eWhile ||@expr1073748429 scope@var2926 .@expr6594 type@var2928 ==@expr1073748431 Scope ::@expr1073748432 eFor ) {
267:
268:
269: if (@expr1073748433 Token ::@expr1073748434 simpleMatch (@expr1073748435 scope@var2926 .@expr6612 bodyStart@var2929 , "{ ; } {" ) &&@expr1073748437
270: scope@var2926 .@expr6612 bodyStart@var2929 .@expr1073748439 previous (@expr1073748440 ) .@expr1073748441 linenr (@expr1073748442 ) ==@expr1073748443 scope@var2926 .@expr6612 bodyStart@var2929 .@expr6621 tokAt (@expr1073748446 2 ) .@expr1073748447 linenr (@expr1073748448 ) &&@expr1073748449
271: scope@var2926 .@expr6612 bodyStart@var2929 .@expr1073748451 linenr (@expr1073748452 ) +@expr1073748453 1 >=@expr1073748454 scope@var2926 .@expr6612 bodyStart@var2929 .@expr6621 tokAt (@expr6633 3 ) .@expr1073748458 linenr (@expr1073748459 ) &&@expr1073748460
272: !@expr1073748461 scope@var2926 .@expr6612 bodyStart@var2929 .@expr6621 tokAt (@expr6633 3 ) .@expr1073748465 isExpandedMacro (@expr1073748466 ) ) {
273: suspiciousSemicolonError (@expr1073748467 scope@var2926 .@expr1073748468 classDef@var2930 ) ;
274: }
275: }
276: }
277: }
278:
279: void CheckOther :: suspiciousSemicolonError ( const Token * tok@var2931 )
280: {
281: reportError (@expr1073748469 tok@var2931 , Severity ::@expr1073748470 warning , "suspiciousSemicolon" ,
282: "Suspicious use of ; at the end of '" +@expr1073748471 (@expr1073748472 tok@var2931 ?@expr1073748473 tok@var2931 .@expr1073748474 str (@expr1073748475 ) :@expr1073748476 std ::@expr1073748477 string (@expr1073748478 ) ) +@expr1073748479 "' statement." , CWE398@var2876 , Certainty ::@expr1073748480 normal ) ;
283: }
284:
|
288:
289: void CheckOther :: warningOldStylePointerCast ( )
290: {
291:
292: if (@expr1073748482 !@expr1073748483 mSettings@var29 .@expr1073748484 severity@var3736 .@expr1073748485 isEnabled (@expr1073748486 Severity ::@expr1073748487 style ) ||@expr1073748488 !@expr1073748489 mTokenizer@var28 .@expr1073748490 isCPP (@expr1073748491 ) ) {
293: return ; }
294:
295: const SymbolDatabase * symbolDatabase@var2932 ; symbolDatabase@var2932 =@expr1073748492 mTokenizer@var28 .@expr1073748493 getSymbolDatabase (@expr1073748494 ) ;
296: for (@expr1073748495 const Scope *@expr1073748496 scope@var2933 :@expr1073748497 symbolDatabase@var2932 .@expr1073748498 functionScopes@var2934 ) {
297: const Token * tok@var2935 ;
298: if (@expr1073748499 scope@var2933 .@expr6676 function@var2936 &&@expr1073748501 scope@var2933 .@expr6676 function@var2936 .@expr1073748503 isConstructor (@expr1073748504 ) ) {
299: tok@var2935 =@expr1073748505 scope@var2933 .@expr1073748506 classDef@var2937 ; }
300: else {
301: tok@var2935 =@expr1073748507 scope@var2933 .@expr1073748508 bodyStart@var2938 ; }
302: for (@expr1073748509 ; tok@var2935 &&@expr1073748510 tok@var2935 !=@expr1073748511 scope@var2933 .@expr1073748512 bodyEnd@var2939 ; tok@var2935 =@expr1073748513 tok@var2935 .@expr6690 next (@expr6691 ) ) {
303:
304: if (@expr1073748516 !@expr1073748517 Token ::@expr6694 Match (@expr1073748519 tok@var2935 , "( const|volatile| const|volatile|class|struct| %type% * *| *| const|&| ) (| %name%|%num%|%bool%|%char%|%str%" ) ) {
305: continue ; }
306: if (@expr1073748520 Token ::@expr6694 Match (@expr1073748522 tok@var2935 .@expr1073748523 previous (@expr1073748524 ) , "%type%" ) ) {
307: continue ; }
308:
309:
310: while (@expr1073748525 Token ::@expr6694 Match (@expr1073748527 tok@var2935 .@expr6690 next (@expr6691 ) , "const|volatile|class|struct" ) ) {
311: tok@var2935 =@expr1073748530 tok@var2935 .@expr6690 next (@expr6691 ) ; }
312: const Token * typeTok@var2940 ; typeTok@var2940 =@expr1073748533 tok@var2935 .@expr6690 next (@expr6691 ) ;
313:
314: if (@expr1073748536 tok@var2935 .@expr1073748537 strAt (@expr1073748538 3 ) ==@expr1073748539 "const" ) {
315: tok@var2935 =@expr1073748540 tok@var2935 .@expr6690 next (@expr6691 ) ; }
316:
317: const Token * p@var2941 ; p@var2941 =@expr1073748543 tok@var2935 .@expr1073748544 tokAt (@expr1073748545 4 ) ;
318: if (@expr1073748546 p@var2941 .@expr1073748547 hasKnownIntValue (@expr1073748548 ) &&@expr1073748549 p@var2941 .@expr1073748550 values (@expr1073748551 ) .@expr1073748552 front (@expr1073748553 ) .@expr1073748554 intvalue@expr1073748481 ==@expr1073748555 0 ) {
319: continue ; }
320:
321: if (@expr1073748556 typeTok@var2940 .@expr6733 tokType (@expr6734 ) ==@expr1073748559 Token ::@expr1073748560 eType ||@expr1073748561 typeTok@var2940 .@expr6733 tokType (@expr6734 ) ==@expr1073748564 Token ::@expr1073748565 eName ) {
322: cstyleCastError (@expr1073748566 tok@var2935 ) ; }
323: }
324: }
325: }
326:
327: void CheckOther :: cstyleCastError ( const Token * tok@var2942 )
328: {
329: reportError (@expr1073748567 tok@var2942 , Severity ::@expr1073748568 style , "cstyleCast" ,
330: "C-style pointer casting\nC-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts."
331:
332:
333:
334: , CWE398@var2876 , Certainty ::@expr1073748569 normal ) ;
335: }
336:
|
340:
341: void CheckOther :: invalidPointerCast ( )
342: {
343: if (@expr1073748571 !@expr1073748572 mSettings@var29 .@expr1073748573 severity@var3736 .@expr1073748574 isEnabled (@expr1073748575 Severity ::@expr1073748576 portability ) ) {
344: return ; }
345:
346: const bool printInconclusive@var2943 =@expr1073748577 mSettings@var29 .@expr1073748578 certainty@var3737 .@expr1073748579 isEnabled (@expr1073748580 Certainty ::@expr1073748581 inconclusive@expr1073748570 ) ;
347: const SymbolDatabase * const symbolDatabase@var2944 ; symbolDatabase@var2944 =@expr1073748582 mTokenizer@var28 .@expr1073748583 getSymbolDatabase (@expr1073748584 ) ;
348: for (@expr1073748585 const Scope *@expr6762 scope@var2945 :@expr1073748587 symbolDatabase@var2944 .@expr1073748588 functionScopes@var2946 ) {
349: for (@expr1073748589 const Token *@expr6762 tok@var2947 =@expr1073748591 scope@var2945 .@expr1073748592 bodyStart@var2948 .@expr1073748593 next (@expr1073748594 ) ; tok@var2947 !=@expr1073748595 scope@var2945 .@expr1073748596 bodyEnd@var2949 ; tok@var2947 =@expr1073748597 tok@var2947 .@expr1073748598 next (@expr1073748599 ) ) {
350: const Token * toTok@var2950 ; toTok@var2950 =@expr1073748600 nullptr ;
351: const Token * fromTok@var2951 ; fromTok@var2951 =@expr1073748601 nullptr ;
352:
353: if (@expr1073748602 Token ::@expr1073748603 Match (@expr1073748604 tok@var2947 , "( const|volatile| const|volatile| %type% %type%| const| * )" ) ) {
354: toTok@var2950 =@expr1073748605 tok@var2947 ;
355: fromTok@var2951 =@expr1073748606 tok@var2947 .@expr1073748607 astOperand1 (@expr1073748608 ) ;
356: } else { if (@expr1073748609 Token ::@expr1073748610 simpleMatch (@expr1073748611 tok@var2947 , "reinterpret_cast <" ) &&@expr1073748612 tok@var2947 .@expr6789 linkAt (@expr6790 1 ) ) {
357: toTok@var2950 =@expr1073748615 tok@var2947 .@expr6789 linkAt (@expr6790 1 ) .@expr1073748618 next (@expr1073748619 ) ;
358: fromTok@var2951 =@expr1073748620 toTok@var2950 .@expr1073748621 astOperand2 (@expr1073748622 ) ;
359: } }
360: if (@expr1073748623 !@expr1073748624 fromTok@var2951 ) {
361: continue ; }
362:
363: const ValueType * fromType@var2952 ; fromType@var2952 =@expr1073748625 fromTok@var2951 .@expr1073748626 valueType (@expr1073748627 ) ;
364: const ValueType * toType@var2953 ; toType@var2953 =@expr1073748628 toTok@var2950 .@expr1073748629 valueType (@expr1073748630 ) ;
365: if (@expr1073748631 !@expr1073748632 fromType@var2952 ||@expr1073748633 !@expr1073748634 toType@var2953 ||@expr1073748635 !@expr1073748636 fromType@var2952 .@expr1073748637 pointer@var2954 ||@expr1073748638 !@expr1073748639 toType@var2953 .@expr1073748640 pointer@var2955 ) {
366: continue ; }
367:
368: if (@expr1073748641 fromType@var2952 .@expr6818 type@var2956 !=@expr1073748643 toType@var2953 .@expr6820 type@var2957 &&@expr1073748645 fromType@var2952 .@expr6818 type@var2956 >=@expr1073748647 ValueType ::@expr6824 Type ::@expr6825 BOOL &&@expr1073748650 toType@var2953 .@expr6820 type@var2957 >=@expr1073748652 ValueType ::@expr6824 Type ::@expr6825 BOOL &&@expr1073748655 (@expr1073748656 toType@var2953 .@expr6820 type@var2957 !=@expr1073748658 ValueType ::@expr6824 Type ::@expr6836 CHAR ||@expr1073748661 printInconclusive@var2943 ) ) {
369: if (@expr1073748662 toType@var2953 .@expr6839 isIntegral (@expr6840 ) &&@expr1073748665 fromType@var2952 .@expr1073748666 isIntegral (@expr1073748667 ) ) {
370: continue ; }
371:
372: invalidPointerCastError (@expr1073748668 tok@var2947 , fromType@var2952 .@expr1073748669 str (@expr1073748670 ) , toType@var2953 .@expr1073748671 str (@expr1073748672 ) , toType@var2953 .@expr6820 type@var2957 ==@expr1073748674 ValueType ::@expr6824 Type ::@expr6836 CHAR , toType@var2953 .@expr6839 isIntegral (@expr6840 ) ) ;
373: }
374: }
375: }
376: }
377:
378:
379: void CheckOther :: invalidPointerCastError ( const Token * tok@var2958 , const std :: string & from@var2959 , const std :: string & to@var2960 , bool inconclusive@var2961 , bool toIsInt@var2962 )
380: {
381: if (@expr1073748679 toIsInt@var2962 ) {
382: reportError (@expr1073748680 tok@var2958 , Severity ::@expr6857 portability , "invalidPointerCast" , "Casting from " +@expr1073748682 from@var2959 +@expr1073748683 " to " +@expr1073748684 to@var2960 +@expr1073748685 " is not portable due to different binary data representations on different platforms." , CWE704@var2887 , inconclusive@var2961 ?@expr1073748686 Certainty ::@expr1073748687 inconclusive :@expr1073748688 Certainty ::@expr6865 normal ) ;
383: } else {
384: reportError (@expr1073748690 tok@var2958 , Severity ::@expr6857 portability , "invalidPointerCast" , "Casting between " +@expr1073748692 from@var2959 +@expr1073748693 " and " +@expr1073748694 to@var2960 +@expr1073748695 " which have an incompatible binary data representation." , CWE704@var2887 , Certainty ::@expr6865 normal ) ; }
385: }
386:
|
395:
396: void CheckOther :: checkPipeParameterSize ( )
397: {
398: if (@expr1073748697 !@expr1073748698 mSettings@var29 .@expr1073748699 posix (@expr1073748700 ) ) {
399: return ; }
400:
401: const SymbolDatabase * symbolDatabase@var2963 ; symbolDatabase@var2963 =@expr1073748701 mTokenizer@var28 .@expr1073748702 getSymbolDatabase (@expr1073748703 ) ;
402: for (@expr1073748704 const Scope *@expr6881 scope@var2964 :@expr1073748706 symbolDatabase@var2963 .@expr1073748707 functionScopes@var2965 ) {
403: for (@expr1073748708 const Token *@expr6881 tok@var2966 =@expr1073748710 scope@var2964 .@expr1073748711 bodyStart@var2967 .@expr1073748712 next (@expr1073748713 ) ; tok@var2966 !=@expr1073748714 scope@var2964 .@expr1073748715 bodyEnd@var2968 ; tok@var2966 =@expr1073748716 tok@var2966 .@expr1073748717 next (@expr1073748718 ) ) {
404: if (@expr1073748719 Token ::@expr6896 Match (@expr1073748721 tok@var2966 , "pipe ( %var% )" ) ||@expr1073748722
405: Token ::@expr6896 Match (@expr1073748724 tok@var2966 , "pipe2 ( %var% ," ) ) {
406: const Token * const varTok@var2969 ; varTok@var2969 =@expr1073748725 tok@var2966 .@expr1073748726 tokAt (@expr1073748727 2 ) ;
407:
408: const Variable * var@var2970 ; var@var2970 =@expr1073748728 varTok@var2969 .@expr1073748729 variable (@expr1073748730 ) ;
409: long long dim@var2971 ;
410: if (@expr1073748731 var@var2970 &&@expr1073748732 var@var2970 .@expr1073748733 isArray (@expr1073748734 ) &&@expr1073748735 !@expr1073748736 var@var2970 .@expr1073748737 isArgument (@expr1073748738 ) &&@expr1073748739 (@expr1073748740 (@expr1073748741 dim@var2971 =@expr1073748742 var@var2970 .@expr1073748743 dimension (@expr1073748744 0U ) ) <@expr1073748745 2 ) ) {
411: const std ::@expr1073748746 string strDim@var2972 =@expr1073748747 MathLib ::@expr1073748748 toString (@expr1073748749 dim@var2971 ) ;
412: checkPipeParameterSizeError (@expr1073748750 varTok@var2969 , varTok@var2969 .@expr1073748751 str (@expr1073748752 ) , strDim@var2972 ) ;
413: }
414: }
415: }
416: }
417: }
418:
419: void CheckOther :: checkPipeParameterSizeError ( const Token * tok@var2973 , const std :: string & strVarName@var2974 , const std :: string & strDim@var2975 )
420: {
421: reportError (@expr1073748753 tok@var2973 , Severity ::@expr1073748754 error ,
422: "wrongPipeParameterSize" ,
423: "$symbol:" +@expr1073748755 strVarName@var2974 +@expr1073748756 "\nBuffer '$symbol' must have size of 2 integers if used as parameter of pipe().\nThe pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\nThe variable '$symbol' is an array of size "
424:
425:
426: +@expr1073748757 strDim@var2975 +@expr1073748758 ", which does not match." , CWE686@var2886 , Certainty ::@expr1073748759 safe ) ;
427: }
428:
|
432:
433: void CheckOther :: checkRedundantAssignment ( )
434: {
435: if (@expr1073748761 !@expr1073748762 mSettings@var29 .@expr1073748763 severity@var3736 .@expr1073748764 isEnabled (@expr1073748765 Severity ::@expr1073748766 style ) ) {
436: return ; }
437: const SymbolDatabase * symbolDatabase@var2976 ; symbolDatabase@var2976 =@expr1073748767 mTokenizer@var28 .@expr1073748768 getSymbolDatabase (@expr1073748769 ) ;
438: for (@expr1073748770 const Scope *@expr6947 scope@var2977 :@expr1073748772 symbolDatabase@var2976 .@expr1073748773 functionScopes@var2978 ) {
439: if (@expr1073748774 !@expr1073748775 scope@var2977 .@expr6952 bodyStart@var2979 ) {
440: continue ; }
441: for (@expr1073748777 const Token *@expr6947 tok@var2980 =@expr1073748779 scope@var2977 .@expr6952 bodyStart@var2979 .@expr1073748781 next (@expr1073748782 ) ; tok@var2980 !=@expr1073748783 scope@var2977 .@expr6960 bodyEnd@var2981 ; tok@var2980 =@expr1073748785 tok@var2980 .@expr6962 next (@expr6963 ) ) {
442: if (@expr1073748788 Token ::@expr6965 simpleMatch (@expr1073748790 tok@var2980 , "] (" ) ) {
443:
444: break ; }
445: if (@expr1073748791 Token ::@expr6965 simpleMatch (@expr1073748793 tok@var2980 , "try {" ) ) {
446:
447: tok@var2980 =@expr1073748794 tok@var2980 .@expr1073748795 linkAt (@expr1073748796 1 ) ; }
448: if (@expr1073748797 (@expr1073748798 tok@var2980 .@expr6975 isAssignmentOp (@expr6976 ) ||@expr1073748801 Token ::@expr6978 Match (@expr1073748803 tok@var2980 , "++|--" ) ) &&@expr1073748804 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) ) {
449: if (@expr1073748807 tok@var2980 .@expr1073748808 astParent (@expr1073748809 ) ) {
450: continue ; }
451:
452:
453:
454: bool isInitialization@var2982 ; isInitialization@var2982 =@expr1073748810 false ;
455: if (@expr1073748811 Token ::@expr6978 Match (@expr1073748813 tok@var2980 .@expr6990 tokAt (@expr6991 -2 ) , "; %var% =" ) &&@expr1073748816 tok@var2980 .@expr6990 tokAt (@expr6991 -2 ) .@expr1073748819 isSplittedVarDeclEq (@expr1073748820 ) ) {
456: isInitialization@var2982 =@expr1073748821 true ;
457: bool trivial@var2983 ; trivial@var2983 =@expr1073748822 true ;
458: visitAstNodes (@expr1073748823 tok@var2980 .@expr7000 astOperand2 (@expr7001 ) ,
459: [@expr1073748826 &@expr7003 ] (@expr1073748828 const Token *@expr6947 rhs@var2984 ) {
460: if (@expr1073748830 Token ::@expr6965 simpleMatch (@expr1073748832 rhs@var2984 , "{ 0 }" ) ) {
461: return ChildrenToVisit ::@expr7009 none ; }
462: if (@expr1073748834 Token ::@expr6978 Match (@expr1073748836 rhs@var2984 , "%str%|%num%|%name%" ) &&@expr1073748837 !@expr1073748838 rhs@var2984 .@expr1073748839 varId (@expr1073748840 ) ) {
463: return ChildrenToVisit ::@expr7009 none ; }
464: if (@expr1073748842 Token ::@expr6978 Match (@expr1073748844 rhs@var2984 , ":: %name%" ) &&@expr1073748845 rhs@var2984 .@expr1073748846 hasKnownIntValue (@expr1073748847 ) ) {
465: return ChildrenToVisit ::@expr7009 none ; }
466: if (@expr1073748849 rhs@var2984 .@expr1073748850 isCast (@expr1073748851 ) ) {
467: return ChildrenToVisit ::@expr1073748852 op2 ; }
468: trivial@var2983 =@expr1073748853 false ;
469: return ChildrenToVisit ::@expr1073748854 done ;
470: } ) ;
471: if (@expr1073748855 trivial@var2983 ) {
472: continue ; }
473: }
474:
475: const Token * rhs@var2985 ; rhs@var2985 =@expr1073748856 tok@var2980 .@expr7000 astOperand2 (@expr7001 ) ;
476:
477: if (@expr1073748859 (@expr1073748860 rhs@var2985 &&@expr1073748861 MathLib ::@expr1073748862 isNullValue (@expr1073748863 rhs@var2985 .@expr1073748864 str (@expr1073748865 ) ) ) ||@expr1073748866 isNullOperand (@expr1073748867 rhs@var2985 ) ) {
478: continue ; }
479:
480: if (@expr1073748868 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7047 variable (@expr7048 ) &&@expr1073748873 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7047 variable (@expr7048 ) .@expr1073748878 isReference (@expr1073748879 ) ) {
481:
482: continue ; }
483:
484: if (@expr1073748880 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7047 variable (@expr7048 ) &&@expr1073748885 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7047 variable (@expr7048 ) .@expr1073748890 isStatic (@expr1073748891 ) ) {
485:
486: continue ; }
487:
488: bool inconclusive@var2986 ; inconclusive@var2986 =@expr1073748892 false ;
489: if (@expr1073748893 mTokenizer@var28 .@expr7070 isCPP (@expr7071 ) &&@expr1073748896 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7075 valueType (@expr7076 ) ) {
490:
491: if (@expr1073748901 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7075 valueType (@expr7076 ) .@expr7082 typeScope@var3771 ) {
492: const std ::@expr1073748907 string op@var2987 =@expr1073748908 "operator" +@expr1073748909 tok@var2980 .@expr1073748910 str (@expr1073748911 ) ;
493: for (@expr1073748912 const Function &@expr7003 f@var2988 :@expr1073748914 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7075 valueType (@expr7076 ) .@expr7082 typeScope@var3771 .@expr1073748920 functionList@var3772 ) {
494: if (@expr1073748921 f@var2988 .@expr1073748922 name (@expr1073748923 ) ==@expr1073748924 op@var2987 ) {
495: inconclusive@var2986 =@expr1073748925 true ;
496: break ;
497: }
498: }
499: }
500:
501: if (@expr1073748926 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7075 valueType (@expr7076 ) .@expr1073748931 type@var3773 ==@expr1073748932 ValueType ::@expr1073748933 SMART_POINTER ) {
502: break ; }
503: }
504: if (@expr1073748934 inconclusive@var2986 &&@expr1073748935 !@expr1073748936 mSettings@var29 .@expr1073748937 certainty@var3737 .@expr1073748938 isEnabled (@expr1073748939 Certainty ::@expr1073748940 inconclusive@expr1073748760 ) ) {
505: continue ; }
506:
507: FwdAnalysis fwdAnalysis@var2989 (@expr1073748941 mTokenizer@var28 .@expr7070 isCPP (@expr7071 ) , mSettings@var29 .@expr1073748944 library@var3738 ) ;
508: if (@expr1073748945 fwdAnalysis@var2989 .@expr1073748946 hasOperand (@expr1073748947 tok@var2980 .@expr7000 astOperand2 (@expr7001 ) , tok@var2980 .@expr6981 astOperand1 (@expr6982 ) ) ) {
509: continue ; }
510:
511:
512: const Token * start@var2990 ;
513: if (@expr1073748952 tok@var2980 .@expr6975 isAssignmentOp (@expr6976 ) ) {
514: start@var2990 =@expr1073748955 tok@var2980 .@expr6962 next (@expr6963 ) ; }
515: else {
516: start@var2990 =@expr1073748958 tok@var2980 .@expr1073748959 findExpressionStartEndTokens (@expr1073748960 ) .@expr1073748961 second .@expr1073748962 next (@expr1073748963 ) ; }
517:
518:
519: const Token * nextAssign@var2991 ; nextAssign@var2991 =@expr1073748964 fwdAnalysis@var2989 .@expr1073748965 reassign (@expr1073748966 tok@var2980 .@expr6981 astOperand1 (@expr6982 ) , start@var2990 , scope@var2977 .@expr6960 bodyEnd@var2981 ) ;
520:
521: if (@expr1073748970 !@expr1073748971 nextAssign@var2991 ) {
522: continue ; }
523:
524:
525: bool hasCase@var2992 ; hasCase@var2992 =@expr1073748972 false ;
526: for (@expr1073748973 const Token *@expr6947 tok2@var2993 =@expr1073748975 tok@var2980 ; tok2@var2993 !=@expr1073748976 nextAssign@var2991 ; tok2@var2993 =@expr1073748977 tok2@var2993 .@expr1073748978 next (@expr1073748979 ) ) {
527: if (@expr1073748980 tok2@var2993 .@expr7157 str (@expr7158 ) ==@expr1073748983 "break" ||@expr1073748984 tok2@var2993 .@expr7157 str (@expr7158 ) ==@expr1073748987 "return" ) {
528: break ; }
529: if (@expr1073748988 tok2@var2993 .@expr7157 str (@expr7158 ) ==@expr1073748991 "case" ) {
530: hasCase@var2992 =@expr1073748992 true ;
531: break ;
532: }
533: }
534:
535:
536: if (@expr1073748993 hasCase@var2992 ) {
537: redundantAssignmentInSwitchError (@expr1073748994 tok@var2980 , nextAssign@var2991 , tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7173 expressionString (@expr7174 ) ) ; }
538: else { if (@expr1073748999 isInitialization@var2982 ) {
539: redundantInitializationError (@expr1073749000 tok@var2980 , nextAssign@var2991 , tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7173 expressionString (@expr7174 ) , inconclusive@var2986 ) ; }
540: else {
541: redundantAssignmentError (@expr1073749005 tok@var2980 , nextAssign@var2991 , tok@var2980 .@expr6981 astOperand1 (@expr6982 ) .@expr7173 expressionString (@expr7174 ) , inconclusive@var2986 ) ; } }
542: }
543: }
544: }
545: }
546:
547: void CheckOther :: redundantCopyError ( const Token * tok1@var2994 , const Token * tok2@var2995 , const std :: string & var@var2996 )
548: {
549: const std ::@expr1073749010 list < const Token *@expr1073749011 > callstack@var2997 =@expr1073749012 {@expr1073749013 tok1@var2994 , tok2@var2995 } ;
550: reportError (@expr1073749014 callstack@var2997 , Severity ::@expr1073749015 performance , "redundantCopy" ,
551: "$symbol:" +@expr1073749016 var@var2996 +@expr1073749017 "\nBuffer '$symbol' is being written before its old content has been used."
552: , CWE563@var2880 , Certainty ::@expr1073749018 normal ) ;
553: }
554:
555: void CheckOther :: redundantCopyInSwitchError ( const Token * tok1@var2998 , const Token * tok2@var2999 , const std :: string & var@var3000 )
556: {
557: const std ::@expr1073749019 list < const Token *@expr1073749020 > callstack@var3001 =@expr1073749021 {@expr1073749022 tok1@var2998 , tok2@var2999 } ;
558: reportError (@expr1073749023 callstack@var3001 , Severity ::@expr1073749024 style , "redundantCopyInSwitch" ,
559: "$symbol:" +@expr1073749025 var@var3000 +@expr1073749026 "\nBuffer '$symbol' is being written before its old content has been used. 'break;' missing?"
560: , CWE563@var2880 , Certainty ::@expr1073749027 normal ) ;
561: }
562:
563: void CheckOther :: redundantAssignmentError ( const Token * tok1@var3002 , const Token * tok2@var3003 , const std :: string & var@var3004 , bool inconclusive@var3005 )
564: {
565: const std ::@expr1073749029 list < std ::@expr7206 pair < const Token *@expr7207 , std ::@expr7206 string > > errorPath@var3006 =@expr1073749033 {@expr1073749034 std ::@expr7211 pair < const Token *@expr7207 , std ::@expr7206 string > (@expr1073749038 tok1@var3002 , var@var3004 +@expr1073749039 " is assigned" ) , std ::@expr7211 pair < const Token *@expr7207 , std ::@expr7206 string > (@expr1073749043 tok2@var3003 , var@var3004 +@expr1073749044 " is overwritten" ) } ;
566: if (@expr1073749045 inconclusive@var3005 ) {
567: reportError (@expr1073749046 errorPath@var3006 , Severity ::@expr7223 style , "redundantAssignment" ,
568: "$symbol:" +@expr7224 var@var3004 +@expr1073749049 "\nVariable '$symbol' is reassigned a value before the old one has been used if variable is no semaphore variable.\nVariable '$symbol' is reassigned a value before the old one has been used. Make sure that this variable is not used like a semaphore in a threading environment before simplifying this code."
569:
570: , CWE563@var2880 , Certainty ::@expr1073749050 inconclusive@expr1073749028 ) ; }
571: else {
572: reportError (@expr1073749051 errorPath@var3006 , Severity ::@expr7223 style , "redundantAssignment" ,
573: "$symbol:" +@expr7224 var@var3004 +@expr1073749054 "\nVariable '$symbol' is reassigned a value before the old one has been used."
574: , CWE563@var2880 , Certainty ::@expr1073749055 normal ) ; }
575: }
576:
577: void CheckOther :: redundantInitializationError ( const Token * tok1@var3007 , const Token * tok2@var3008 , const std :: string & var@var3009 , bool inconclusive@var3010 )
578: {
579: const std ::@expr1073749056 list < std ::@expr7233 pair < const Token *@expr7234 , std ::@expr7233 string > > errorPath@var3011 =@expr1073749060 {@expr1073749061 std ::@expr7238 pair < const Token *@expr7234 , std ::@expr7233 string > (@expr1073749065 tok1@var3007 , var@var3009 +@expr1073749066 " is initialized" ) , std ::@expr7238 pair < const Token *@expr7234 , std ::@expr7233 string > (@expr1073749070 tok2@var3008 , var@var3009 +@expr1073749071 " is overwritten" ) } ;
580: reportError (@expr1073749072 errorPath@var3011 , Severity ::@expr1073749073 style , "redundantInitialization" ,
581: "$symbol:" +@expr1073749074 var@var3009 +@expr1073749075 "\nRedundant initialization for '$symbol'. The initialized value is overwritten before it is read." ,
582: CWE563@var2880 ,
583: inconclusive@var3010 ?@expr1073749076 Certainty ::@expr1073749077 inconclusive :@expr1073749078 Certainty ::@expr1073749079 normal ) ;
584: }
585:
586: void CheckOther :: redundantAssignmentInSwitchError ( const Token * tok1@var3012 , const Token * tok2@var3013 , const std :: string & var@var3014 )
587: {
588: const std ::@expr1073749080 list < std ::@expr7257 pair < const Token *@expr7258 , std ::@expr7257 string > > errorPath@var3015 =@expr1073749084 {@expr1073749085 std ::@expr7262 pair < const Token *@expr7258 , std ::@expr7257 string > (@expr1073749089 tok1@var3012 , "$symbol is assigned" ) , std ::@expr7262 pair < const Token *@expr7258 , std ::@expr7257 string > (@expr1073749093 tok2@var3013 , "$symbol is overwritten" ) } ;
589: reportError (@expr1073749094 errorPath@var3015 , Severity ::@expr1073749095 style , "redundantAssignInSwitch" ,
590: "$symbol:" +@expr1073749096 var@var3014 +@expr1073749097 "\nVariable '$symbol' is reassigned a value before the old one has been used. 'break;' missing?"
591: , CWE563@var2880 , Certainty ::@expr1073749098 normal ) ;
592: }
593:
|
603:
604: static bool isFunctionOrBreakPattern ( const Token * tok@var3016 )
605: {
606: if (@expr1073749099 Token ::@expr7276 Match (@expr1073749101 tok@var3016 , "%name% (" ) ||@expr1073749102 Token ::@expr7276 Match (@expr1073749104 tok@var3016 , "break|continue|return|exit|goto|throw" ) ) {
607: return true ; }
608:
609: return false ;
610: }
611:
612: void CheckOther :: checkRedundantAssignmentInSwitch ( )
613: {
614: if (@expr1073749105 !@expr1073749106 mSettings@var29 .@expr1073749107 severity@var3736 .@expr1073749108 isEnabled (@expr1073749109 Severity ::@expr1073749110 warning ) ) {
615: return ; }
616:
617: const SymbolDatabase * symbolDatabase@var3017 ; symbolDatabase@var3017 =@expr1073749111 mTokenizer@var28 .@expr1073749112 getSymbolDatabase (@expr1073749113 ) ;
618:
619:
620:
621: for (@expr1073749114 const Scope &@expr1073749115 switchScope@var3018 :@expr1073749116 symbolDatabase@var3017 .@expr1073749117 scopeList@var3019 ) {
622: if (@expr1073749118 switchScope@var3018 .@expr1073749119 type@var3020 !=@expr1073749120 Scope ::@expr1073749121 eSwitch ||@expr1073749122 !@expr1073749123 switchScope@var3018 .@expr7300 bodyStart@var3021 ) {
623: continue ; }
624:
625:
626: std ::@expr1073749125 map < int , const Token *@expr7302 > varsWithBitsSet@var3022 ;
627: std ::@expr1073749127 map < int , std ::@expr7304 string > bitOperations@var3023 ;
628:
629: for (@expr1073749129 const Token *@expr7302 tok2@var3024 =@expr1073749131 switchScope@var3018 .@expr7300 bodyStart@var3021 .@expr1073749133 next (@expr1073749134 ) ; tok2@var3024 !=@expr1073749135 switchScope@var3018 .@expr1073749136 bodyEnd@var3025 ; tok2@var3024 =@expr1073749137 tok2@var3024 .@expr7314 next (@expr7315 ) ) {
630: if (@expr1073749140 tok2@var3024 .@expr1073749141 str (@expr1073749142 ) ==@expr1073749143 "{" ) {
631:
632:
633:
634: if (@expr1073749144 Token ::@expr7321 Match (@expr1073749146 tok2@var3024 .@expr7323 previous (@expr7324 ) , ")|else {" ) &&@expr1073749149 tok2@var3024 .@expr7326 link (@expr7327 ) ) {
635: const Token * endOfConditional@var3026 ; endOfConditional@var3026 =@expr1073749152 tok2@var3024 .@expr7326 link (@expr7327 ) ;
636: for (@expr1073749155 const Token *@expr7302 tok3@var3027 =@expr1073749157 tok2@var3024 ; tok3@var3027 !=@expr1073749158 endOfConditional@var3026 ; tok3@var3027 =@expr1073749159 tok3@var3027 .@expr1073749160 next (@expr1073749161 ) ) {
637: if (@expr1073749162 tok3@var3027 .@expr7339 varId (@expr7340 ) !=@expr1073749165 0 ) {
638: varsWithBitsSet@var3022 .@expr7342 erase (@expr1073749167 tok3@var3027 .@expr7339 varId (@expr7340 ) ) ;
639: bitOperations@var3023 .@expr7346 erase (@expr1073749171 tok3@var3027 .@expr7339 varId (@expr7340 ) ) ;
640: } else { if (@expr1073749174 isFunctionOrBreakPattern (@expr1073749175 tok3@var3027 ) ) {
641: varsWithBitsSet@var3022 .@expr7352 clear (@expr7353 ) ;
642: bitOperations@var3023 .@expr7354 clear (@expr7355 ) ;
643: } }
644: }
645: tok2@var3024 =@expr1073749180 endOfConditional@var3026 ;
646: }
647: }
648:
|
652:
653: if (@expr1073749181 Token ::@expr7321 Match (@expr1073749183 tok2@var3024 .@expr7323 previous (@expr7324 ) , ";|{|}|: %var% = %any% ;" ) ) {
654: varsWithBitsSet@var3022 .@expr7342 erase (@expr7363 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
655: bitOperations@var3023 .@expr7346 erase (@expr7367 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
656: }
657:
|
660:
661: else { if (@expr1073749194 Token ::@expr7321 Match (@expr1073749196 tok2@var3024 .@expr7323 previous (@expr7324 ) , ";|{|}|: %var% %assign% %num% ;" ) &&@expr1073749199
662: (@expr1073749200 tok2@var3024 .@expr7377 strAt (@expr7378 1 ) ==@expr1073749203 "|=" ||@expr1073749204 tok2@var3024 .@expr7377 strAt (@expr7378 1 ) ==@expr1073749207 "&=" ) &&@expr1073749208
663: Token ::@expr7321 Match (@expr1073749210 tok2@var3024 .@expr7314 next (@expr7315 ) .@expr1073749213 astOperand2 (@expr1073749214 ) , "%num%" ) ) {
664: const std ::@expr7304 string bitOp@var3028 =@expr1073749216 tok2@var3024 .@expr7377 strAt (@expr7378 1 ) [@expr1073749219 0 ] +@expr1073749220 tok2@var3024 .@expr7377 strAt (@expr1073749222 2 ) ;
665: const std ::@expr7399 map < int , const Token *@expr7302 > ::@expr1073749225 const_iterator i2@var3029 =@expr1073749226 varsWithBitsSet@var3022 .@expr7403 find (@expr7404 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
666:
667:
668: if (@expr1073749231 i2@var3029 ==@expr1073749232 varsWithBitsSet@var3022 .@expr7409 end (@expr7410 ) ) {
669: varsWithBitsSet@var3022 [@expr7411 tok2@var3024 .@expr7364 varId (@expr7365 ) ] =@expr1073749238 tok2@var3024 ;
670: bitOperations@var3023 [@expr7415 tok2@var3024 .@expr7364 varId (@expr7365 ) ] =@expr1073749242 bitOp@var3028 ;
671: }
672:
673:
674: else { if (@expr1073749243 bitOperations@var3023 [@expr7415 tok2@var3024 .@expr7364 varId (@expr7365 ) ] ==@expr1073749247 bitOp@var3028 ) {
675: redundantBitwiseOperationInSwitchError (@expr1073749248 i2@var3029 .@expr7425 second@var3030 , i2@var3029 .@expr7425 second@var3030 .@expr1073749251 str (@expr1073749252 ) ) ; }
676:
677:
678: else {
679: varsWithBitsSet@var3022 .@expr7342 erase (@expr7363 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
680: bitOperations@var3023 .@expr7346 erase (@expr7367 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
681: } }
682: }
683:
|
686:
687: else { if (@expr1073749261 Token ::@expr7321 Match (@expr1073749263 tok2@var3024 .@expr7323 previous (@expr7324 ) , ";|{|}|: %var% = %name% %or%|& %num% ;" ) &&@expr1073749266
688: tok2@var3024 .@expr7364 varId (@expr7365 ) ==@expr1073749269 tok2@var3024 .@expr1073749270 tokAt (@expr1073749271 2 ) .@expr1073749272 varId (@expr1073749273 ) ) {
689: const std ::@expr7304 string bitOp@var3031 =@expr1073749275 tok2@var3024 .@expr7377 strAt (@expr1073749277 3 ) +@expr1073749278 tok2@var3024 .@expr7377 strAt (@expr1073749280 4 ) ;
690: const std ::@expr7399 map < int , const Token *@expr7302 > ::@expr1073749283 const_iterator i2@var3032 =@expr1073749284 varsWithBitsSet@var3022 .@expr7403 find (@expr7404 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
691:
692:
693: if (@expr1073749289 i2@var3032 ==@expr1073749290 varsWithBitsSet@var3022 .@expr7409 end (@expr7410 ) ) {
694: varsWithBitsSet@var3022 [@expr7411 tok2@var3024 .@expr7364 varId (@expr7365 ) ] =@expr1073749296 tok2@var3024 ;
695: bitOperations@var3023 [@expr7415 tok2@var3024 .@expr7364 varId (@expr7365 ) ] =@expr1073749300 bitOp@var3031 ;
696: }
697:
698:
699: else { if (@expr1073749301 bitOperations@var3023 [@expr7415 tok2@var3024 .@expr7364 varId (@expr7365 ) ] ==@expr1073749305 bitOp@var3031 ) {
700: redundantBitwiseOperationInSwitchError (@expr1073749306 i2@var3032 .@expr7483 second@var3033 , i2@var3032 .@expr7483 second@var3033 .@expr1073749309 str (@expr1073749310 ) ) ; }
701:
702:
703: else {
704: varsWithBitsSet@var3022 .@expr7342 erase (@expr7363 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
705: bitOperations@var3023 .@expr7346 erase (@expr7367 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
706: } }
707: }
708:
|
711:
712: else { if (@expr1073749319 tok2@var3024 .@expr7364 varId (@expr7365 ) !=@expr1073749322 0 &&@expr1073749323 tok2@var3024 .@expr7377 strAt (@expr7378 1 ) !=@expr1073749326 "|" &&@expr1073749327 tok2@var3024 .@expr7377 strAt (@expr7378 1 ) !=@expr1073749330 "&" ) {
713: varsWithBitsSet@var3022 .@expr7342 erase (@expr7363 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
714: bitOperations@var3023 .@expr7346 erase (@expr7367 tok2@var3024 .@expr7364 varId (@expr7365 ) ) ;
715: } } } }
716:
717:
718:
719: if (@expr1073749339 isFunctionOrBreakPattern (@expr1073749340 tok2@var3024 ) ) {
720: varsWithBitsSet@var3022 .@expr7352 clear (@expr7353 ) ;
721: bitOperations@var3023 .@expr7354 clear (@expr7355 ) ;
722: }
723: }
724: }
725: }
726:
727: void CheckOther :: redundantBitwiseOperationInSwitchError ( const Token * tok@var3034 , const std :: string & varname@var3035 )
728: {
729: reportError (@expr1073749345 tok@var3034 , Severity ::@expr1073749346 style ,
730: "redundantBitwiseOperationInSwitch" ,
731: "$symbol:" +@expr1073749347 varname@var3035 +@expr1073749348 "\nRedundant bitwise operation on '$symbol' in 'switch' statement. 'break;' missing?"
732: ) ;
733: }
734:
|
738:
739: void CheckOther :: checkSuspiciousCaseInSwitch ( )
740: {
741: if (@expr1073749350 !@expr1073749351 mSettings@var29 .@expr1073749352 certainty@var3737 .@expr1073749353 isEnabled (@expr1073749354 Certainty ::@expr1073749355 inconclusive@expr1073749349 ) ||@expr1073749356 !@expr1073749357 mSettings@var29 .@expr1073749358 severity@var3736 .@expr1073749359 isEnabled (@expr1073749360 Severity ::@expr1073749361 warning ) ) {
742: return ; }
743:
744: const SymbolDatabase * symbolDatabase@var3036 ; symbolDatabase@var3036 =@expr1073749362 mTokenizer@var28 .@expr1073749363 getSymbolDatabase (@expr1073749364 ) ;
745:
746: for (@expr1073749365 const Scope &@expr1073749366 scope@var3037 :@expr1073749367 symbolDatabase@var3036 .@expr1073749368 scopeList@var3038 ) {
747: if (@expr1073749369 scope@var3037 .@expr1073749370 type@var3039 !=@expr1073749371 Scope ::@expr1073749372 eSwitch ) {
748: continue ; }
749:
750: for (@expr1073749373 const Token *@expr7550 tok@var3040 =@expr1073749375 scope@var3037 .@expr1073749376 bodyStart@var3041 .@expr1073749377 next (@expr1073749378 ) ; tok@var3040 !=@expr1073749379 scope@var3037 .@expr1073749380 bodyEnd@var3042 ; tok@var3040 =@expr1073749381 tok@var3040 .@expr7558 next (@expr7559 ) ) {
751: if (@expr1073749384 tok@var3040 .@expr1073749385 str (@expr1073749386 ) ==@expr1073749387 "case" ) {
752: const Token * finding@var3043 ; finding@var3043 =@expr1073749388 nullptr ;
753: for (@expr1073749389 const Token *@expr7550 tok2@var3044 =@expr1073749391 tok@var3040 .@expr7558 next (@expr7559 ) ; tok2@var3044 ; tok2@var3044 =@expr1073749394 tok2@var3044 .@expr1073749395 next (@expr1073749396 ) ) {
754: if (@expr1073749397 tok2@var3044 .@expr7574 str (@expr7575 ) ==@expr1073749400 ":" ) {
755: break ; }
756: if (@expr1073749401 Token ::@expr7578 Match (@expr1073749403 tok2@var3044 , "[;}{]" ) ) {
757: break ; }
758:
759: if (@expr1073749404 tok2@var3044 .@expr7574 str (@expr7575 ) ==@expr1073749407 "?" ) {
760: finding@var3043 =@expr1073749408 nullptr ; }
761: else { if (@expr1073749409 Token ::@expr7578 Match (@expr1073749411 tok2@var3044 , "&&|%oror%" ) ) {
762: finding@var3043 =@expr1073749412 tok2@var3044 ; } }
763: }
764: if (@expr1073749413 finding@var3043 ) {
765: suspiciousCaseInSwitchError (@expr1073749414 finding@var3043 , finding@var3043 .@expr1073749415 str (@expr1073749416 ) ) ; }
766: }
767: }
768: }
769: }
770:
771: void CheckOther :: suspiciousCaseInSwitchError ( const Token * tok@var3045 , const std :: string & operatorString@var3046 )
772: {
773: reportError (@expr1073749418 tok@var3045 , Severity ::@expr1073749419 warning , "suspiciousCase" ,
774: "Found suspicious case label in switch(). Operator '" +@expr1073749420 operatorString@var3046 +@expr1073749421 "' probably doesn't work as intended.\nUsing an operator like '"
775: +@expr1073749422 operatorString@var3046 +@expr1073749423 "' in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?" , CWE398@var2876 , Certainty ::@expr1073749424 inconclusive@expr1073749417 ) ;
776: }
777:
|
783:
784: void CheckOther :: checkUnreachableCode ( )
785: {
786: if (@expr1073749426 !@expr1073749427 mSettings@var29 .@expr1073749428 severity@var3736 .@expr1073749429 isEnabled (@expr1073749430 Severity ::@expr1073749431 style ) ) {
787: return ; }
788: const bool printInconclusive@var3047 =@expr1073749432 mSettings@var29 .@expr1073749433 certainty@var3737 .@expr1073749434 isEnabled (@expr1073749435 Certainty ::@expr1073749436 inconclusive@expr1073749425 ) ;
789: const SymbolDatabase * symbolDatabase@var3048 ; symbolDatabase@var3048 =@expr1073749437 mTokenizer@var28 .@expr1073749438 getSymbolDatabase (@expr1073749439 ) ;
790: for (@expr1073749440 const Scope *@expr7617 scope@var3049 :@expr1073749442 symbolDatabase@var3048 .@expr1073749443 functionScopes@var3050 ) {
791: for (@expr1073749444 const Token *@expr7617 tok@var3051 =@expr1073749446 scope@var3049 .@expr1073749447 bodyStart@var3052 ; tok@var3051 &&@expr1073749448 tok@var3051 !=@expr1073749449 scope@var3049 .@expr7626 bodyEnd@var3053 ; tok@var3051 =@expr1073749451 tok@var3051 .@expr7628 next (@expr7629 ) ) {
792: const Token * secondBreak@var3054 ; secondBreak@var3054 =@expr1073749454 nullptr ;
793: const Token * labelName@var3055 ; labelName@var3055 =@expr1073749455 nullptr ;
794: if (@expr1073749456 tok@var3051 .@expr7633 link (@expr7634 ) &&@expr1073749459 Token ::@expr7636 Match (@expr1073749461 tok@var3051 , "(|[|<" ) ) {
795: tok@var3051 =@expr1073749462 tok@var3051 .@expr7633 link (@expr7634 ) ; }
796: else { if (@expr1073749465 Token ::@expr7636 Match (@expr1073749467 tok@var3051 , "break|continue ;" ) ) {
797: secondBreak@var3054 =@expr1073749468 tok@var3051 .@expr7645 tokAt (@expr1073749470 2 ) ; }
798: else { if (@expr1073749471 Token ::@expr7636 Match (@expr1073749473 tok@var3051 , "[;{}:] return|throw" ) &&@expr1073749474 tok@var3051 .@expr7628 next (@expr7629 ) .@expr1073749477 isKeyword (@expr1073749478 ) ) {
799: if (@expr1073749479 Token ::@expr7656 simpleMatch (@expr1073749481 tok@var3051 .@expr1073749482 astParent (@expr1073749483 ) , "?" ) ) {
800: continue ; }
801: tok@var3051 =@expr1073749484 tok@var3051 .@expr7628 next (@expr7629 ) ;
802: for (@expr1073749487 const Token *@expr7617 tok2@var3056 =@expr1073749489 tok@var3051 .@expr7628 next (@expr7629 ) ; tok2@var3056 ; tok2@var3056 =@expr1073749492 tok2@var3056 .@expr7669 next (@expr7670 ) ) {
803: if (@expr1073749495 tok2@var3056 .@expr7672 str (@expr7673 ) ==@expr1073749498 "(" ||@expr1073749499 tok2@var3056 .@expr7672 str (@expr7673 ) ==@expr1073749502 "{" ) {
804: tok2@var3056 =@expr1073749503 tok2@var3056 .@expr1073749504 link (@expr1073749505 ) ; }
805: if (@expr1073749506 tok2@var3056 .@expr7672 str (@expr7673 ) ==@expr1073749509 ";" ) {
806: secondBreak@var3054 =@expr1073749510 tok2@var3056 .@expr7669 next (@expr7670 ) ;
807: break ;
808: }
809: }
810: } else { if (@expr1073749513 Token ::@expr7636 Match (@expr1073749515 tok@var3051 , "goto %any% ;" ) ) {
811: secondBreak@var3054 =@expr1073749516 tok@var3051 .@expr7645 tokAt (@expr1073749518 3 ) ;
812: labelName@var3055 =@expr1073749519 tok@var3051 .@expr7628 next (@expr7629 ) ;
813: } else { if (@expr1073749522 Token ::@expr7636 Match (@expr1073749524 tok@var3051 , "%name% (" ) &&@expr1073749525 mSettings@var29 .@expr1073749526 library@var3738 .@expr1073749527 isnoreturn (@expr1073749528 tok@var3051 ) &&@expr1073749529 !@expr1073749530 Token ::@expr7636 Match (@expr1073749532 tok@var3051 .@expr7628 next (@expr7629 ) .@expr1073749535 astParent (@expr1073749536 ) , "?|:" ) ) {
814: if (@expr1073749537 (@expr1073749538 !@expr1073749539 tok@var3051 .@expr7716 function (@expr7717 ) ||@expr1073749542 (@expr1073749543 tok@var3051 .@expr7716 function (@expr7717 ) .@expr1073749546 token@var3753 !=@expr1073749547 tok@var3051 &&@expr1073749548 tok@var3051 .@expr7716 function (@expr7717 ) .@expr1073749551 tokenDef@var3754 !=@expr1073749552 tok@var3051 ) ) &&@expr1073749553 tok@var3051 .@expr7730 linkAt (@expr7731 1 ) .@expr1073749556 strAt (@expr1073749557 1 ) !=@expr1073749558 "{" ) {
815: secondBreak@var3054 =@expr1073749559 tok@var3051 .@expr7730 linkAt (@expr7731 1 ) .@expr1073749562 tokAt (@expr1073749563 2 ) ; }
816: if (@expr1073749564 Token ::@expr7656 simpleMatch (@expr1073749566 secondBreak@var3054 , "return" ) ) {
817:
818: continue ;
819: }
820: } } } } }
821:
822:
823:
824: const bool inconclusive@var3057 =@expr1073749567 secondBreak@var3054 &&@expr1073749568 (@expr1073749569 secondBreak@var3054 .@expr1073749570 linenr (@expr1073749571 ) -@expr1073749572 1 >@expr1073749573 secondBreak@var3054 .@expr1073749574 previous (@expr1073749575 ) .@expr1073749576 linenr (@expr1073749577 ) ) ;
825:
826: if (@expr1073749578 secondBreak@var3054 &&@expr1073749579 (@expr1073749580 printInconclusive@var3047 ||@expr1073749581 !@expr1073749582 inconclusive@var3057 ) ) {
827: if (@expr1073749583 Token ::@expr7636 Match (@expr1073749585 secondBreak@var3054 , "continue|goto|throw|return" ) &&@expr1073749586 secondBreak@var3054 .@expr1073749587 isKeyword (@expr1073749588 ) ) {
828: duplicateBreakError (@expr7765 secondBreak@var3054 , inconclusive@var3057 ) ;
829: tok@var3051 =@expr1073749590 Token ::@expr7767 findmatch (@expr7768 secondBreak@var3054 , "[}:]" ) ;
830: } else { if (@expr1073749593 secondBreak@var3054 .@expr1073749594 str (@expr1073749595 ) ==@expr1073749596 "break" ) {
831: if (@expr1073749597 tok@var3051 .@expr1073749598 str (@expr1073749599 ) ==@expr1073749600 "break" ) {
832: duplicateBreakError (@expr7765 secondBreak@var3054 , inconclusive@var3057 ) ; }
833: else {
834: if (@expr1073749602 tok@var3051 .@expr1073749603 scope (@expr1073749604 ) .@expr1073749605 type@var3755 !=@expr1073749606 Scope ::@expr1073749607 eSwitch ) {
835: duplicateBreakError (@expr7765 secondBreak@var3054 , inconclusive@var3057 ) ; }
836: }
837: tok@var3051 =@expr1073749609 Token ::@expr7767 findmatch (@expr7768 secondBreak@var3054 , "[}:]" ) ;
838: } else { if (@expr1073749612 !@expr1073749613 Token ::@expr7636 Match (@expr1073749615 secondBreak@var3054 , "return|}|case|default" ) &&@expr1073749616 secondBreak@var3054 .@expr1073749617 strAt (@expr1073749618 1 ) !=@expr1073749619 ":" ) {
839:
840:
841: bool labelInFollowingLoop@var3058 ; labelInFollowingLoop@var3058 =@expr1073749620 false ;
842: if (@expr1073749621 labelName@var3055 &&@expr1073749622 Token ::@expr7636 Match (@expr1073749624 secondBreak@var3054 , "while|do|for" ) ) {
843: const Token * scope2@var3059 ; scope2@var3059 =@expr1073749625 Token ::@expr1073749626 findsimplematch (@expr1073749627 secondBreak@var3054 , "{" ) ;
844: if (@expr1073749628 scope2@var3059 ) {
845: for (@expr1073749629 const Token *@expr7617 tokIter@var3060 =@expr1073749631 scope2@var3059 ; tokIter@var3060 !=@expr1073749632 scope2@var3059 .@expr1073749633 link (@expr1073749634 ) &&@expr1073749635 tokIter@var3060 ; tokIter@var3060 =@expr1073749636 tokIter@var3060 .@expr1073749637 next (@expr1073749638 ) ) {
846: if (@expr1073749639 Token ::@expr7636 Match (@expr1073749641 tokIter@var3060 , "[;{}] %any% :" ) &&@expr1073749642 labelName@var3055 .@expr1073749643 str (@expr1073749644 ) ==@expr1073749645 tokIter@var3060 .@expr1073749646 strAt (@expr1073749647 1 ) ) {
847: labelInFollowingLoop@var3058 =@expr1073749648 true ;
848: break ;
849: }
850: }
851: }
852: }
853:
854:
855: bool silencedCompilerWarningOnly@var3061 ; silencedCompilerWarningOnly@var3061 =@expr1073749649 false ;
856: const Token * silencedWarning@var3062 ; silencedWarning@var3062 =@expr1073749650 secondBreak@var3054 ;
857: for (@expr1073749651 ; ; ) {
858: if (@expr1073749652 Token ::@expr7636 Match (@expr1073749654 silencedWarning@var3062 , "( void ) %name% ;" ) ) {
859: silencedWarning@var3062 =@expr1073749655 silencedWarning@var3062 .@expr1073749656 tokAt (@expr1073749657 5 ) ;
860: continue ;
861: } else { if (@expr1073749658 silencedWarning@var3062 &&@expr1073749659 silencedWarning@var3062 ==@expr1073749660 scope@var3049 .@expr7626 bodyEnd@var3053 ) {
862: silencedCompilerWarningOnly@var3061 =@expr1073749662 true ; } }
863:
864: break ;
865: }
866: if (@expr1073749663 silencedWarning@var3062 ) {
867: secondBreak@var3054 =@expr1073749664 silencedWarning@var3062 ; }
868:
869: if (@expr1073749665 !@expr1073749666 labelInFollowingLoop@var3058 &&@expr1073749667 !@expr1073749668 silencedCompilerWarningOnly@var3061 ) {
870: unreachableCodeError (@expr1073749669 secondBreak@var3054 , inconclusive@var3057 ) ; }
871: tok@var3051 =@expr1073749670 Token ::@expr7767 findmatch (@expr7768 secondBreak@var3054 , "[}:]" ) ;
872: } else {
873: tok@var3051 =@expr1073749673 secondBreak@var3054 ; } } }
874:
875: if (@expr1073749674 !@expr1073749675 tok@var3051 ) {
876: break ; }
877: tok@var3051 =@expr1073749676 tok@var3051 .@expr1073749677 previous (@expr1073749678 ) ;
878: }
879: }
880: }
881: }
882:
883: void CheckOther :: duplicateBreakError ( const Token * tok@var3063 , bool inconclusive@var3064 )
884: {
885: reportError (@expr1073749679 tok@var3063 , Severity ::@expr1073749680 style , "duplicateBreak" ,
886: "Consecutive return, break, continue, goto or throw statements are unnecessary.\nConsecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed."
887:
888: , CWE561@var2879 , inconclusive@var3064 ?@expr1073749681 Certainty ::@expr1073749682 inconclusive :@expr1073749683 Certainty ::@expr1073749684 normal ) ;
889: }
890:
891: void CheckOther :: unreachableCodeError ( const Token * tok@var3065 , bool inconclusive@var3066 )
892: {
893: reportError (@expr1073749685 tok@var3065 , Severity ::@expr1073749686 style , "unreachableCode" ,
894: "Statements following return, break, continue, goto or throw will never be executed." , CWE561@var2879 , inconclusive@var3066 ?@expr1073749687 Certainty ::@expr1073749688 inconclusive :@expr1073749689 Certainty ::@expr1073749690 normal ) ;
895: }
896:
|
899:
900: void CheckOther :: checkVariableScope ( )
901: {
902: if (@expr1073749691 mSettings@var29 .@expr1073749692 clang@var3739 ) {
903: return ; }
904:
905: if (@expr1073749693 !@expr1073749694 mSettings@var29 .@expr1073749695 severity@var3736 .@expr1073749696 isEnabled (@expr1073749697 Severity ::@expr1073749698 style ) ) {
906: return ; }
907:
908: const SymbolDatabase * symbolDatabase@var3067 ; symbolDatabase@var3067 =@expr1073749699 mTokenizer@var28 .@expr1073749700 getSymbolDatabase (@expr1073749701 ) ;
909:
910:
911:
912: if (@expr1073749702 mSettings@var29 .@expr1073749703 daca@var3740 &&@expr1073749704 mTokenizer@var28 .@expr7881 isC (@expr7882 ) ) {
913: return ; }
914:
915: for (@expr1073749707 const Variable *@expr7884 var@var3068 :@expr1073749709 symbolDatabase@var3067 .@expr1073749710 variableList (@expr1073749711 ) ) {
916: if (@expr1073749712 !@expr1073749713 var@var3068 ||@expr1073749714 !@expr1073749715 var@var3068 .@expr1073749716 isLocal (@expr1073749717 ) ||@expr1073749718 var@var3068 .@expr1073749719 isConst (@expr1073749720 ) ) {
917: continue ; }
918:
919: const bool isPtrOrRef@var3069 =@expr1073749721 var@var3068 .@expr1073749722 isPointer (@expr1073749723 ) ||@expr1073749724 var@var3068 .@expr1073749725 isReference (@expr1073749726 ) ;
920: const bool isSimpleType@var3070 =@expr1073749727 var@var3068 .@expr7904 typeStartToken (@expr7905 ) .@expr1073749730 isStandardType (@expr1073749731 ) ||@expr1073749732 var@var3068 .@expr7904 typeStartToken (@expr7905 ) .@expr1073749735 isEnumType (@expr1073749736 ) ||@expr1073749737 (@expr1073749738 mTokenizer@var28 .@expr7881 isC (@expr7882 ) &&@expr1073749741 var@var3068 .@expr7918 type (@expr7919 ) &&@expr1073749744 var@var3068 .@expr7918 type (@expr7919 ) .@expr1073749747 isStructType (@expr1073749748 ) ) ;
921: if (@expr1073749749 !@expr1073749750 isPtrOrRef@var3069 &&@expr1073749751 !@expr1073749752 isSimpleType@var3070 &&@expr1073749753 !@expr1073749754 astIsContainer (@expr1073749755 var@var3068 .@expr7932 nameToken (@expr7933 ) ) ) {
922: continue ; }
923:
924: if (@expr1073749758 mTokenizer@var28 .@expr1073749759 hasIfdef (@expr1073749760 var@var3068 .@expr7932 nameToken (@expr7933 ) , var@var3068 .@expr7939 scope (@expr7940 ) .@expr7941 bodyEnd@var3756 ) ) {
925: continue ; }
926:
927:
928: if (@expr1073749766 Token ::@expr7943 Match (@expr1073749768 var@var3068 .@expr7932 nameToken (@expr7933 ) .@expr1073749771 previous (@expr1073749772 ) , "& %var% = %var% ." ) ) {
929: const Token * otherVarToken@var3071 ; otherVarToken@var3071 =@expr1073749773 var@var3068 .@expr7932 nameToken (@expr7933 ) .@expr1073749776 tokAt (@expr1073749777 2 ) ;
930: const Variable * otherVar@var3072 ; otherVar@var3072 =@expr1073749778 otherVarToken@var3071 .@expr1073749779 variable (@expr1073749780 ) ;
931: if (@expr1073749781 otherVar@var3072 &&@expr1073749782 Token ::@expr7943 Match (@expr1073749784 otherVar@var3072 .@expr7961 nameToken (@expr7962 ) , "%var% :" ) &&@expr1073749787
932: otherVar@var3072 .@expr7961 nameToken (@expr7962 ) .@expr7966 next (@expr7967 ) .@expr7968 astParent (@expr7969 ) &&@expr1073749794
933: Token ::@expr7971 simpleMatch (@expr1073749796 otherVar@var3072 .@expr7961 nameToken (@expr7962 ) .@expr7966 next (@expr7967 ) .@expr7968 astParent (@expr7969 ) .@expr1073749803 previous (@expr1073749804 ) , "for (" ) ) {
934: continue ; }
935: }
936:
937: bool forHead@var3073 ; forHead@var3073 =@expr1073749805 false ;
938: for (@expr1073749806 const Token *@expr7884 tok@var3074 =@expr1073749808 var@var3068 .@expr7904 typeStartToken (@expr7905 ) ; tok@var3074 ; tok@var3074 =@expr1073749811 tok@var3074 .@expr1073749812 previous (@expr1073749813 ) ) {
939: if (@expr1073749814 tok@var3074 .@expr1073749815 str (@expr1073749816 ) ==@expr1073749817 "(" ) {
940: forHead@var3073 =@expr1073749818 true ;
941: break ;
942: } else { if (@expr1073749819 Token ::@expr7943 Match (@expr1073749821 tok@var3074 , "[;{}]" ) ) {
943: break ; } }
944: }
945: if (@expr1073749822 forHead@var3073 ) {
946: continue ; }
947:
948: const Token * tok@var3075 ; tok@var3075 =@expr1073749823 var@var3068 .@expr7932 nameToken (@expr7933 ) .@expr1073749826 next (@expr1073749827 ) ;
949: if (@expr1073749828 Token ::@expr7943 Match (@expr1073749830 tok@var3075 , "; %varid% = %any% ;" , var@var3068 .@expr8007 declarationId (@expr8008 ) ) ) {
950: tok@var3075 =@expr1073749833 tok@var3075 .@expr1073749834 tokAt (@expr1073749835 3 ) ;
951: if (@expr1073749836 !@expr1073749837 tok@var3075 .@expr1073749838 isNumber (@expr1073749839 ) &&@expr1073749840 tok@var3075 .@expr8017 tokType (@expr8018 ) !=@expr1073749843 Token ::@expr1073749844 eString &&@expr1073749845 tok@var3075 .@expr8017 tokType (@expr8018 ) !=@expr1073749848 Token ::@expr1073749849 eChar &&@expr1073749850 !@expr1073749851 tok@var3075 .@expr1073749852 isBoolean (@expr1073749853 ) ) {
952: continue ; }
953: }
954:
955: if (@expr1073749854 Token ::@expr7943 Match (@expr1073749856 tok@var3075 , "[(=]" ) &&@expr1073749857 Token ::@expr7971 simpleMatch (@expr1073749859 tok@var3075 .@expr1073749860 astOperand2 (@expr1073749861 ) , "(" ) ) {
956: continue ; }
957: bool reduce@var3076 ; reduce@var3076 =@expr1073749862 true ;
958: bool used@var3077 ; used@var3077 =@expr1073749863 false ;
959: for (@expr1073749864 ; tok@var3075 &&@expr1073749865 tok@var3075 !=@expr1073749866 var@var3068 .@expr7939 scope (@expr7940 ) .@expr7941 bodyEnd@var3756 ; tok@var3075 =@expr1073749870 tok@var3075 .@expr8047 next (@expr8048 ) ) {
960: if (@expr1073749873 tok@var3075 .@expr8050 str (@expr8051 ) ==@expr1073749876 "{" &&@expr1073749877 tok@var3075 .@expr1073749878 scope (@expr1073749879 ) !=@expr1073749880 tok@var3075 .@expr1073749881 previous (@expr1073749882 ) .@expr1073749883 scope (@expr1073749884 ) &&@expr1073749885 !@expr1073749886 tok@var3075 .@expr1073749887 isExpandedMacro (@expr1073749888 ) &&@expr1073749889 !@expr1073749890 isWithinScope (@expr1073749891 tok@var3075 , var@var3068 , Scope ::@expr1073749892 ScopeType ::@expr1073749893 eLambda ) ) {
961: if (@expr1073749894 used@var3077 ) {
962: bool used2@var3078 ; used2@var3078 =@expr1073749895 false ;
963: if (@expr1073749896 !@expr1073749897 checkInnerScope (@expr1073749898 tok@var3075 , var@var3068 , used2@var3078 ) ||@expr1073749899 used2@var3078 ) {
964: reduce@var3076 =@expr1073749900 false ;
965: break ;
966: }
967: } else { if (@expr1073749901 !@expr1073749902 checkInnerScope (@expr1073749903 tok@var3075 , var@var3068 , used@var3077 ) ) {
968: reduce@var3076 =@expr1073749904 false ;
969: break ;
970: } }
971:
972: tok@var3075 =@expr1073749905 tok@var3075 .@expr1073749906 link (@expr1073749907 ) ;
973:
974:
975: } else { if (@expr1073749908 Token ::@expr7971 simpleMatch (@expr1073749910 tok@var3075 , "else { if (" ) &&@expr1073749911 Token ::@expr7971 simpleMatch (@expr1073749913 tok@var3075 .@expr8090 linkAt (@expr8091 3 ) , ") {" ) ) {
976: const Token * endif@var3079 ; endif@var3079 =@expr1073749916 tok@var3075 .@expr8090 linkAt (@expr8091 3 ) .@expr1073749919 linkAt (@expr1073749920 1 ) ;
977: bool elseif@var3080 ; elseif@var3080 =@expr1073749921 false ;
978: if (@expr1073749922 Token ::@expr7971 simpleMatch (@expr1073749924 endif@var3079 , "} }" ) ) {
979: elseif@var3080 =@expr1073749925 true ; }
980: else { if (@expr1073749926 Token ::@expr7971 simpleMatch (@expr1073749928 endif@var3079 , "} else {" ) &&@expr1073749929 Token ::@expr7971 simpleMatch (@expr1073749931 endif@var3079 .@expr1073749932 linkAt (@expr1073749933 2 ) , "} }" ) ) {
981: elseif@var3080 =@expr1073749934 true ; } }
982: if (@expr1073749935 elseif@var3080 &&@expr1073749936 Token ::@expr1073749937 findmatch (@expr1073749938 tok@var3075 .@expr8047 next (@expr8048 ) , "%varid%" , tok@var3075 .@expr8090 linkAt (@expr1073749942 1 ) , var@var3068 .@expr8007 declarationId (@expr8008 ) ) ) {
983: reduce@var3076 =@expr1073749945 false ;
984: break ;
985: }
986: } else { if (@expr1073749946 tok@var3075 .@expr1073749947 varId (@expr1073749948 ) ==@expr1073749949 var@var3068 .@expr8007 declarationId (@expr8008 ) ||@expr1073749952 tok@var3075 .@expr8050 str (@expr8051 ) ==@expr1073749955 "goto" ) {
987: reduce@var3076 =@expr1073749956 false ;
988: break ;
989: } } }
990: }
991:
992: if (@expr1073749957 reduce@var3076 &&@expr1073749958 used@var3077 ) {
993: variableScopeError (@expr1073749959 var@var3068 .@expr7932 nameToken (@expr7933 ) , var@var3068 .@expr1073749962 name (@expr1073749963 ) ) ; }
994: }
995: }
996:
997: bool CheckOther :: checkInnerScope ( const Token * tok@var3081 , const Variable * var@var3082 , bool & used@var3083 )
998: {
999: const Scope * scope@var3084 ; scope@var3084 =@expr1073749964 tok@var3081 .@expr8141 next (@expr8142 ) .@expr1073749967 scope (@expr1073749968 ) ;
1000: bool loopVariable@var3085 ; loopVariable@var3085 =@expr1073749969 scope@var3084 .@expr1073749970 isLoopScope (@expr1073749971 ) ;
1001: bool noContinue@var3086 ; noContinue@var3086 =@expr1073749972 true ;
1002: const Token * forHeadEnd@var3087 ; forHeadEnd@var3087 =@expr1073749973 nullptr ;
1003: const Token * end@var3088 ; end@var3088 =@expr1073749974 tok@var3081 .@expr1073749975 link (@expr1073749976 ) ;
1004: if (@expr1073749977 scope@var3084 .@expr8154 type@var3089 ==@expr1073749979 Scope ::@expr1073749980 eUnconditional &&@expr1073749981 (@expr1073749982 tok@var3081 .@expr8159 strAt (@expr8160 -1 ) ==@expr8161 ")" ||@expr1073749986 tok@var3081 .@expr1073749987 previous (@expr1073749988 ) .@expr1073749989 isName (@expr1073749990 ) ) ) {
1005: loopVariable@var3085 =@expr1073749991 true ; }
1006:
1007: if (@expr1073749992 scope@var3084 .@expr8154 type@var3089 ==@expr1073749994 Scope ::@expr1073749995 eDo ) {
1008: end@var3088 =@expr1073749996 end@var3088 .@expr1073749997 linkAt (@expr1073749998 2 ) ;
1009: } else { if (@expr1073749999 loopVariable@var3085 &&@expr1073750000 tok@var3081 .@expr8159 strAt (@expr8160 -1 ) ==@expr8161 ")" ) {
1010: tok@var3081 =@expr1073750004 tok@var3081 .@expr8181 linkAt (@expr1073750006 -1 ) ;
1011: } else { if (@expr8183 scope@var3084 .@expr8154 type@var3089 ==@expr8185 Scope ::@expr8186 eSwitch ) {
1012: for (@expr1073750011 const Scope *@expr8188 innerScope@var3090 :@expr1073750013 scope@var3084 .@expr1073750014 nestedList@var3091 ) {
1013: if (@expr1073750015 used@var3083 ) {
1014: bool used2@var3092 ; used2@var3092 =@expr1073750016 false ;
1015: if (@expr1073750017 !@expr1073750018 checkInnerScope (@expr1073750019 innerScope@var3090 .@expr8196 bodyStart@var3093 , var@var3082 , used2@var3092 ) ||@expr1073750021 used2@var3092 ) {
1016: return false ;
1017: }
1018: } else { if (@expr1073750022 !@expr1073750023 checkInnerScope (@expr1073750024 innerScope@var3090 .@expr8196 bodyStart@var3093 , var@var3082 , used@var3083 ) ) {
1019: return false ;
1020: } }
1021: }
1022: } } }
1023:
1024: bool bFirstAssignment@var3094 ; bFirstAssignment@var3094 =@expr1073750026 false ;
1025: for (@expr1073750027 ; tok@var3081 &&@expr1073750028 tok@var3081 !=@expr1073750029 end@var3088 ; tok@var3081 =@expr1073750030 tok@var3081 .@expr8141 next (@expr8142 ) ) {
1026: if (@expr1073750033 tok@var3081 .@expr8210 str (@expr8211 ) ==@expr1073750036 "goto" ) {
1027: return false ; }
1028: if (@expr1073750037 tok@var3081 .@expr8210 str (@expr8211 ) ==@expr1073750040 "continue" ) {
1029: noContinue@var3086 =@expr1073750041 false ; }
1030:
1031: if (@expr1073750042 Token ::@expr1073750043 simpleMatch (@expr1073750044 tok@var3081 , "for (" ) ) {
1032: forHeadEnd@var3087 =@expr1073750045 tok@var3081 .@expr8181 linkAt (@expr1073750047 1 ) ; }
1033: if (@expr1073750048 tok@var3081 ==@expr1073750049 forHeadEnd@var3087 ) {
1034: forHeadEnd@var3087 =@expr1073750050 nullptr ; }
1035:
1036: if (@expr1073750051 loopVariable@var3085 &&@expr1073750052 noContinue@var3086 &&@expr1073750053 tok@var3081 .@expr8230 scope (@expr8231 ) ==@expr8232 scope@var3084 &&@expr1073750057 !@expr1073750058 forHeadEnd@var3087 &&@expr1073750059 scope@var3084 .@expr8154 type@var3089 !=@expr1073750061 Scope ::@expr8186 eSwitch &&@expr1073750063 Token ::@expr8240 Match (@expr8241 tok@var3081 , "%varid% =" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) ) {
1037: loopVariable@var3085 =@expr1073750068 false ;
1038: int indent@var3095 ; indent@var3095 =@expr1073750069 0 ;
1039: for (@expr1073750070 const Token *@expr8188 tok2@var3096 =@expr1073750072 tok@var3081 .@expr1073750073 tokAt (@expr1073750074 2 ) ; tok2@var3096 ; tok2@var3096 =@expr1073750075 tok2@var3096 .@expr1073750076 next (@expr1073750077 ) ) {
1040: if (@expr1073750078 tok2@var3096 .@expr8255 str (@expr8256 ) ==@expr1073750081 "(" ) {
1041: indent@var3095 ++@expr1073750082 ; }
1042: else { if (@expr1073750083 tok2@var3096 .@expr8255 str (@expr8256 ) ==@expr1073750086 ")" ) {
1043: if (@expr1073750087 indent@var3095 ==@expr1073750088 0 ) {
1044: break ; }
1045: indent@var3095 --@expr1073750089 ;
1046: } else { if (@expr1073750090 tok2@var3096 .@expr8255 str (@expr8256 ) ==@expr1073750093 ";" ) {
1047: break ; }
1048: else { if (@expr1073750094 tok2@var3096 .@expr1073750095 varId (@expr1073750096 ) ==@expr1073750097 var@var3082 .@expr8242 declarationId (@expr8243 ) ) {
1049: loopVariable@var3085 =@expr1073750100 true ;
1050: break ;
1051: } } } }
1052: }
1053: }
1054:
1055: if (@expr1073750101 loopVariable@var3085 &&@expr1073750102 Token ::@expr8240 Match (@expr1073750104 tok@var3081 , "%varid% !!=" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) ) {
1056: return false ; }
1057:
1058: if (@expr1073750107 Token ::@expr8240 Match (@expr1073750109 tok@var3081 , "& %varid%" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) ) {
1059: return false ; }
1060:
1061: if (@expr1073750112 Token ::@expr8240 Match (@expr8241 tok@var3081 , "%varid% =" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) ) {
1062: bFirstAssignment@var3094 =@expr1073750117 true ; }
1063:
1064: if (@expr1073750118 !@expr1073750119 bFirstAssignment@var3094 &&@expr1073750120 Token ::@expr8240 Match (@expr1073750122 tok@var3081 , "* %varid%" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) ) {
1065: return false ; }
1066:
1067: if (@expr1073750125 Token ::@expr8240 Match (@expr1073750127 tok@var3081 , "= %varid%" , var@var3082 .@expr8242 declarationId (@expr8243 ) ) &&@expr1073750130 (@expr1073750131 var@var3082 .@expr1073750132 isArray (@expr1073750133 ) ||@expr1073750134 var@var3082 .@expr1073750135 isPointer (@expr1073750136 ) ||@expr1073750137 (@expr1073750138 var@var3082 .@expr8315 valueType (@expr8316 ) &&@expr1073750141 var@var3082 .@expr8315 valueType (@expr8316 ) .@expr1073750144 container@var3757 ) ) ) {
1068: return false ; }
1069:
1070: if (@expr1073750145 tok@var3081 .@expr1073750146 varId (@expr1073750147 ) ==@expr1073750148 var@var3082 .@expr8242 declarationId (@expr8243 ) ) {
1071: used@var3083 =@expr1073750151 true ;
1072: if (@expr1073750152 scope@var3084 ==@expr8232 tok@var3081 .@expr8230 scope (@expr8231 ) ) {
1073: if (@expr8183 scope@var3084 .@expr8154 type@var3089 ==@expr8185 Scope ::@expr8186 eSwitch ) {
1074: return false ; }
1075:
1076: if (@expr1073750160 scope@var3084 .@expr8337 bodyStart@var3097 &&@expr1073750162 scope@var3084 .@expr8337 bodyStart@var3097 .@expr1073750164 isSimplifiedScope (@expr1073750165 ) ) {
1077: return false ; }
1078: }
1079: }
1080: }
1081:
1082: return true ;
1083: }
1084:
1085: void CheckOther :: variableScopeError ( const Token * tok@var3098 , const std :: string & varname@var3099 )
1086: {
1087: reportError (@expr1073750166 tok@var3098 ,
1088: Severity ::@expr1073750167 style ,
1089: "variableScope" ,
1090: "$symbol:" +@expr1073750168 varname@var3099 +@expr1073750169 "\nThe scope of the variable '$symbol' can be reduced.\nThe scope of the variable '$symbol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:\nvoid f(int x)\n{\n    int i = 0;\n    if (x) {\n        // it's safe to move 'int i = 0;' here\n        for (int n = 0; n < 10; ++n) {\n            // it is possible but not safe to move 'int i = 0;' here\n            do_something(&i);\n        }\n    }\n}\nWhen you see this message it is always safe to reduce the variable scope 1 level."
1091:
|
1105:
1106: , CWE398@var2876 , Certainty ::@expr1073750170 normal ) ;
1107: }
1108:
|
1111:
1112: void CheckOther :: checkCommaSeparatedReturn ( )
1113: {
1114:
1115: if (@expr1073750171 !@expr1073750172 mSettings@var29 .@expr1073750173 certainty@var3737 .@expr1073750174 isEnabled (@expr1073750175 Certainty ::@expr1073750176 experimental ) ) {
1116: return ; }
1117:
1118: if (@expr1073750177 !@expr1073750178 mSettings@var29 .@expr1073750179 severity@var3736 .@expr1073750180 isEnabled (@expr1073750181 Severity ::@expr1073750182 style ) ) {
1119: return ; }
1120:
1121: for (@expr1073750183 const Token *@expr1073750184 tok@var3100 =@expr1073750185 mTokenizer@var28 .@expr1073750186 tokens (@expr1073750187 ) ; tok@var3100 ; tok@var3100 =@expr1073750188 tok@var3100 .@expr8365 next (@expr8366 ) ) {
1122: if (@expr1073750191 tok@var3100 .@expr8368 str (@expr8369 ) ==@expr1073750194 "return" ) {
1123: tok@var3100 =@expr1073750195 tok@var3100 .@expr8365 next (@expr8366 ) ;
1124: while (@expr1073750198 tok@var3100 &&@expr1073750199 tok@var3100 .@expr8368 str (@expr8369 ) !=@expr1073750202 ";" ) {
1125: if (@expr1073750203 tok@var3100 .@expr8380 link (@expr8381 ) &&@expr1073750206 Token ::@expr1073750207 Match (@expr1073750208 tok@var3100 , "[([{<]" ) ) {
1126: tok@var3100 =@expr1073750209 tok@var3100 .@expr8380 link (@expr8381 ) ; }
1127:
1128: if (@expr1073750212 !@expr1073750213 tok@var3100 .@expr1073750214 isExpandedMacro (@expr1073750215 ) &&@expr1073750216 tok@var3100 .@expr8368 str (@expr8369 ) ==@expr1073750219 "," &&@expr1073750220 tok@var3100 .@expr1073750221 linenr (@expr1073750222 ) !=@expr1073750223 tok@var3100 .@expr8365 next (@expr8366 ) .@expr1073750226 linenr (@expr1073750227 ) ) {
1129: commaSeparatedReturnError (@expr1073750228 tok@var3100 ) ; }
1130:
1131: tok@var3100 =@expr1073750229 tok@var3100 .@expr8365 next (@expr8366 ) ;
1132: }
1133:
1134: if (@expr1073750232 !@expr1073750233 tok@var3100 ) {
1135: break ; }
1136: }
1137: }
1138: }
1139:
1140: void CheckOther :: commaSeparatedReturnError ( const Token * tok@var3101 )
1141: {
1142: reportError (@expr1073750234 tok@var3101 ,
1143: Severity ::@expr1073750235 style ,
1144: "commaSeparatedReturn" ,
1145: "Comma is used in return statement. The comma can easily be misread as a ';'.\nComma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon. For example in the code below the value of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is returned:\n    if (x)\n        return a + 1,\n    b++;\nHowever it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood."
1146:
|
1153:
1154: , CWE398@var2876 , Certainty ::@expr1073750236 normal ) ;
1155: }
1156:
|
1159:
1160: static int estimateSize ( const Type * type@var3102 , const Settings * settings@var3103 , const SymbolDatabase * symbolDatabase@var3104 , int recursionDepth@var3105 = 0 )
1161: {
1162: if (@expr1073750237 recursionDepth@var3105 >@expr1073750238 20 ) {
1163: return 0 ; }
1164:
1165: int cumulatedSize@var3106 ; cumulatedSize@var3106 =@expr1073750239 0 ;
1166: const bool isUnion@var3107 =@expr1073750240 type@var3102 .@expr8417 classScope@var3108 .@expr1073750242 type@var3109 ==@expr1073750243 Scope ::@expr1073750244 ScopeType ::@expr1073750245 eUnion ;
1167: const auto accumulateSize@var3110 =@expr1073750246 [@expr1073750247 ] (@expr1073750248 int &@expr8425 cumulatedSize@var3111 , int size@var3112 , bool isUnion@var3113 ) .@expr1073750250 void {
1168: if (@expr1073750251 isUnion@var3113 ) {
1169: cumulatedSize@var3111 =@expr1073750252 std ::@expr1073750253 max (@expr1073750254 cumulatedSize@var3111 , size@var3112 ) ; }
1170: else {
1171: cumulatedSize@var3111 +=@expr1073750255 size@var3112 ; }
1172: } ;
1173: for (@expr1073750256 const Variable &@expr8425 var@var3114 :@expr1073750258 type@var3102 .@expr8417 classScope@var3108 .@expr1073750260 varlist@var3115 ) {
1174: int size@var3116 ; size@var3116 =@expr1073750261 0 ;
1175: if (@expr1073750262 var@var3114 .@expr1073750263 isStatic (@expr1073750264 ) ) {
1176: continue ; }
1177: if (@expr1073750265 var@var3114 .@expr1073750266 isPointer (@expr1073750267 ) ||@expr1073750268 var@var3114 .@expr1073750269 isReference (@expr1073750270 ) ) {
1178: size@var3116 =@expr1073750271 settings@var3103 .@expr8448 sizeof_pointer@var3117 ; }
1179: else { if (@expr1073750273 var@var3114 .@expr8450 type (@expr8451 ) &&@expr1073750276 var@var3114 .@expr8450 type (@expr8451 ) .@expr1073750279 classScope@var3758 ) {
1180: size@var3116 =@expr1073750280 estimateSize (@expr1073750281 var@var3114 .@expr8450 type (@expr8451 ) , settings@var3103 , symbolDatabase@var3104 , recursionDepth@var3105 +@expr8460 1 ) ; }
1181: else { if (@expr1073750285 var@var3114 .@expr1073750286 valueType (@expr1073750287 ) .@expr1073750288 type@var3759 ==@expr1073750289 ValueType ::@expr1073750290 Type ::@expr1073750291 CONTAINER ) {
1182: size@var3116 =@expr1073750292 3 *@expr1073750293 settings@var3103 .@expr8448 sizeof_pointer@var3117 ; }
1183: else {
1184: size@var3116 =@expr1073750295 symbolDatabase@var3104 .@expr1073750296 sizeOfType (@expr1073750297 var@var3114 .@expr1073750298 typeStartToken (@expr1073750299 ) ) ; } } }
1185:
1186: if (@expr1073750300 var@var3114 .@expr1073750301 isArray (@expr1073750302 ) ) {
1187: size@var3116 *=@expr1073750303 std ::@expr1073750304 accumulate (@expr1073750305 var@var3114 .@expr8482 dimensions (@expr8483 ) .@expr1073750308 begin (@expr1073750309 ) , var@var3114 .@expr8482 dimensions (@expr8483 ) .@expr1073750312 end (@expr1073750313 ) , 1 , [@expr1073750314 ] (@expr1073750315 int v@var3118 , const Dimension &@expr8425 d@var3119 ) {
1188: return v@var3118 *=@expr1073750317 d@var3119 .@expr1073750318 num@var3120 ;
1189: } ) ; }
1190:
1191: accumulateSize@var3110 (@expr1073750319 cumulatedSize@var3106 , size@var3116 , isUnion@var3107 ) ;
1192: }
1193: for (@expr1073750320 const Type ::@expr1073750321 BaseInfo &@expr8425 baseInfo@var3121 :@expr1073750323 type@var3102 .@expr1073750324 derivedFrom@var3122 ) {
1194: if (@expr1073750325 baseInfo@var3121 .@expr8502 type@var3123 &&@expr1073750327 baseInfo@var3121 .@expr8502 type@var3123 .@expr1073750329 classScope@var3124 ) {
1195: cumulatedSize@var3106 +=@expr1073750330 estimateSize (@expr1073750331 baseInfo@var3121 .@expr8502 type@var3123 , settings@var3103 , symbolDatabase@var3104 , recursionDepth@var3105 +@expr8460 1 ) ; }
1196: }
1197: return cumulatedSize@var3106 ;
1198: }
1199:
1200: static bool canBeConst ( const Variable * var@var3125 , const Settings * settings@var3126 )
1201: {
1202: {
1203:
1204: const Function * func_scope@var3127 ; func_scope@var3127 =@expr1073750334 var@var3125 .@expr8511 scope (@expr8512 ) .@expr1073750337 function@var3760 ;
1205: if (@expr1073750338 func_scope@var3127 .@expr1073750339 type@var3128 ==@expr1073750340 Function ::@expr1073750341 Type ::@expr1073750342 eConstructor ) {
1206:
1207: if (@expr1073750343 func_scope@var3127 .@expr8520 arg@var3129 .@expr8521 link (@expr8522 ) .@expr8523 next (@expr8524 ) .@expr1073750349 str (@expr1073750350 ) ==@expr1073750351 ":" ) {
1208: for (@expr1073750352 const Token *@expr8529 tok2@var3130 =@expr1073750354 func_scope@var3127 .@expr8520 arg@var3129 .@expr8521 link (@expr8522 ) .@expr8523 next (@expr8524 ) .@expr1073750360 next (@expr1073750361 ) ; tok2@var3130 !=@expr1073750362 var@var3125 .@expr8511 scope (@expr8512 ) .@expr8541 bodyStart@var3761 ; tok2@var3130 =@expr1073750366 tok2@var3130 .@expr1073750367 next (@expr1073750368 ) ) {
1209: if (@expr1073750369 tok2@var3130 .@expr1073750370 varId (@expr1073750371 ) !=@expr1073750372 var@var3125 .@expr8549 declarationId (@expr8550 ) ) {
1210: continue ; }
1211: const Token * parent@var3131 ; parent@var3131 =@expr1073750375 tok2@var3130 .@expr1073750376 astParent (@expr1073750377 ) ;
1212: if (@expr1073750378 parent@var3131 &&@expr1073750379 Token ::@expr1073750380 simpleMatch (@expr1073750381 parent@var3131 .@expr1073750382 previous (@expr1073750383 ) , "move (" ) ) {
1213: return false ; }
1214: }
1215: }
1216: }
1217: }
1218: for (@expr1073750384 const Token *@expr8529 tok2@var3132 =@expr1073750386 var@var3125 .@expr8511 scope (@expr8512 ) .@expr8541 bodyStart@var3761 ; tok2@var3132 !=@expr1073750390 var@var3125 .@expr8511 scope (@expr8512 ) .@expr1073750393 bodyEnd@var3756 ; tok2@var3132 =@expr1073750394 tok2@var3132 .@expr1073750395 next (@expr1073750396 ) ) {
1219: if (@expr1073750397 tok2@var3132 .@expr1073750398 varId (@expr1073750399 ) !=@expr1073750400 var@var3125 .@expr8549 declarationId (@expr8550 ) ) {
1220: continue ; }
1221:
1222: const Token * parent@var3133 ; parent@var3133 =@expr1073750403 tok2@var3132 .@expr1073750404 astParent (@expr1073750405 ) ;
1223: if (@expr1073750406 !@expr1073750407 parent@var3133 ) {
1224: continue ; }
1225: if (@expr1073750408 parent@var3133 .@expr8585 str (@expr8586 ) ==@expr8587 "<<" ||@expr1073750412 isLikelyStreamRead (@expr1073750413 true , parent@var3133 ) ) {
1226: if (@expr1073750414 parent@var3133 .@expr8585 str (@expr8586 ) ==@expr8587 "<<" &&@expr1073750418 parent@var3133 .@expr8595 astOperand1 (@expr8596 ) ==@expr8597 tok2@var3132 ) {
1227: return false ; }
1228: if (@expr1073750422 parent@var3133 .@expr8585 str (@expr8586 ) ==@expr1073750425 ">>" &&@expr1073750426 parent@var3133 .@expr8603 astOperand2 (@expr8604 ) ==@expr1073750429 tok2@var3132 ) {
1229: return false ; }
1230: } else { if (@expr1073750430 parent@var3133 .@expr8585 str (@expr8586 ) ==@expr1073750433 "," ||@expr1073750434 parent@var3133 .@expr8585 str (@expr8586 ) ==@expr1073750437 "(" ) {
1231: const Token * tok3@var3134 ; tok3@var3134 =@expr1073750438 tok2@var3132 .@expr1073750439 previous (@expr1073750440 ) ;
1232: int argNr@var3135 ; argNr@var3135 =@expr1073750441 0 ;
1233: while (@expr1073750442 tok3@var3134 &&@expr1073750443 tok3@var3134 .@expr8620 str (@expr8621 ) !=@expr8622 "(" ) {
1234: if (@expr1073750447 tok3@var3134 .@expr8624 link (@expr8625 ) &&@expr1073750450 Token ::@expr8627 Match (@expr1073750452 tok3@var3134 , ")|]|}|>" ) ) {
1235: tok3@var3134 =@expr1073750453 tok3@var3134 .@expr8624 link (@expr8625 ) ; }
1236: else { if (@expr1073750456 tok3@var3134 .@expr8624 link (@expr8625 ) ) {
1237: break ; }
1238: else { if (@expr1073750459 tok3@var3134 .@expr8620 str (@expr8621 ) ==@expr1073750462 ";" ) {
1239: break ; }
1240: else { if (@expr1073750463 tok3@var3134 .@expr8620 str (@expr8621 ) ==@expr1073750466 "," ) {
1241: argNr@var3135 ++@expr1073750467 ; } } } }
1242: tok3@var3134 =@expr1073750468 tok3@var3134 .@expr1073750469 previous (@expr1073750470 ) ;
1243: }
1244: if (@expr1073750471 !@expr1073750472 tok3@var3134 ||@expr1073750473 tok3@var3134 .@expr8620 str (@expr8621 ) !=@expr8622 "(" ) {
1245: return false ; }
1246: const Token * functionTok@var3136 ; functionTok@var3136 =@expr1073750477 tok3@var3134 .@expr1073750478 astOperand1 (@expr1073750479 ) ;
1247: if (@expr1073750480 !@expr1073750481 functionTok@var3136 ) {
1248: return false ; }
1249: const Function * tokFunction@var3137 ; tokFunction@var3137 =@expr1073750482 functionTok@var3136 .@expr8659 function (@expr8660 ) ;
1250: if (@expr1073750485 !@expr1073750486 tokFunction@var3137 &&@expr1073750487 functionTok@var3136 .@expr1073750488 str (@expr1073750489 ) ==@expr1073750490 "." &&@expr1073750491 (@expr1073750492 functionTok@var3136 =@expr1073750493 functionTok@var3136 .@expr1073750494 astOperand2 (@expr1073750495 ) ) ) {
1251: tokFunction@var3137 =@expr1073750496 functionTok@var3136 .@expr8659 function (@expr8660 ) ; }
1252: if (@expr1073750499 tokFunction@var3137 ) {
1253: const Variable * argVar@var3138 ; argVar@var3138 =@expr1073750500 tokFunction@var3137 .@expr1073750501 getArgumentVar (@expr1073750502 argNr@var3135 ) ;
1254: if (@expr1073750503 !@expr1073750504 argVar@var3138 ||@expr1073750505 (@expr1073750506 !@expr1073750507 argVar@var3138 .@expr1073750508 isConst (@expr1073750509 ) &&@expr1073750510 argVar@var3138 .@expr1073750511 isReference (@expr1073750512 ) ) ) {
1255: return false ; }
1256: }
1257: else { if (@expr1073750513 !@expr1073750514 settings@var3126 .@expr8691 library@var3139 .@expr8692 isFunctionConst (@expr1073750517 functionTok@var3136 ) ) {
1258: return false ; } }
1259: } else { if (@expr1073750518 parent@var3133 .@expr1073750519 isUnaryOp (@expr1073750520 "&" ) ) {
1260:
1261: return false ;
1262: } else { if (@expr1073750521 parent@var3133 .@expr1073750522 isConstOp (@expr1073750523 ) ||@expr1073750524
1263: (@expr1073750525 parent@var3133 .@expr8603 astOperand2 (@expr8604 ) &&@expr1073750528 settings@var3126 .@expr8691 library@var3139 .@expr8692 isFunctionConst (@expr1073750531 parent@var3133 .@expr8603 astOperand2 (@expr8604 ) ) ) ) {
1264: continue ; }
1265: else { if (@expr1073750534 parent@var3133 .@expr1073750535 isAssignmentOp (@expr1073750536 ) ) {
1266: if (@expr1073750537 parent@var3133 .@expr8595 astOperand1 (@expr8596 ) ==@expr8597 tok2@var3132 ) {
1267: return false ; }
1268: const Variable * assignedVar@var3140 ; assignedVar@var3140 =@expr1073750541 parent@var3133 .@expr8595 astOperand1 (@expr8596 ) ?@expr1073750544 parent@var3133 .@expr8595 astOperand1 (@expr8596 ) .@expr1073750547 variable (@expr1073750548 ) :@expr1073750549 nullptr ;
1269: if (@expr1073750550 assignedVar@var3140 &&@expr1073750551
1270: !@expr1073750552 assignedVar@var3140 .@expr1073750553 isConst (@expr1073750554 ) &&@expr1073750555
1271: assignedVar@var3140 .@expr1073750556 isReference (@expr1073750557 ) &&@expr1073750558
1272: assignedVar@var3140 .@expr1073750559 nameToken (@expr1073750560 ) ==@expr1073750561 parent@var3133 .@expr8595 astOperand1 (@expr8596 ) ) {
1273: return false ; }
1274: } else { if (@expr1073750564 Token ::@expr8627 Match (@expr1073750566 tok2@var3132 , "%var% . %name% (" ) ) {
1275: const Function * func@var3141 ; func@var3141 =@expr1073750567 tok2@var3132 .@expr1073750568 tokAt (@expr1073750569 2 ) .@expr1073750570 function (@expr1073750571 ) ;
1276: if (@expr1073750572 func@var3141 &&@expr1073750573 (@expr1073750574 func@var3141 .@expr1073750575 isConst (@expr1073750576 ) ||@expr1073750577 func@var3141 .@expr1073750578 isStatic (@expr1073750579 ) ) ) {
1277: continue ; }
1278: else {
1279: return false ; }
1280: } else {
1281: return false ; } } } } } }
1282: }
1283:
1284: return true ;
1285: }
1286:
1287: void CheckOther :: checkPassByReference ( )
1288: {
1289: if (@expr1073750581 !@expr1073750582 mSettings@var29 .@expr1073750583 severity@var3736 .@expr1073750584 isEnabled (@expr1073750585 Severity ::@expr1073750586 performance ) ||@expr1073750587 mTokenizer@var28 .@expr1073750588 isC (@expr1073750589 ) ) {
1290: return ; }
1291:
1292: const SymbolDatabase * const symbolDatabase@var3142 ; symbolDatabase@var3142 =@expr1073750590 mTokenizer@var28 .@expr1073750591 getSymbolDatabase (@expr1073750592 ) ;
1293:
1294: for (@expr1073750593 const Variable *@expr1073750594 var@var3143 :@expr1073750595 symbolDatabase@var3142 .@expr1073750596 variableList (@expr1073750597 ) ) {
1295: if (@expr1073750598 !@expr1073750599 var@var3143 ||@expr1073750600 !@expr1073750601 var@var3143 .@expr1073750602 isArgument (@expr1073750603 ) ||@expr1073750604 !@expr1073750605 var@var3143 .@expr1073750606 isClass (@expr1073750607 ) ||@expr1073750608 var@var3143 .@expr1073750609 isPointer (@expr1073750610 ) ||@expr1073750611 var@var3143 .@expr1073750612 isArray (@expr1073750613 ) ||@expr1073750614 var@var3143 .@expr1073750615 isReference (@expr1073750616 ) ||@expr1073750617 var@var3143 .@expr1073750618 isEnumType (@expr1073750619 ) ) {
1296: continue ; }
1297:
1298: if (@expr1073750620 var@var3143 .@expr8797 scope (@expr8798 ) &&@expr1073750623 var@var3143 .@expr8797 scope (@expr8798 ) .@expr8802 function@var3760 .@expr1073750627 arg@var3762 .@expr1073750628 link (@expr1073750629 ) .@expr1073750630 strAt (@expr1073750631 -1 ) ==@expr1073750632 "..." ) {
1299: continue ; }
1300:
1301: if (@expr1073750633 (@expr1073750634 var@var3143 .@expr8811 declEndToken (@expr8812 ) &&@expr1073750637 var@var3143 .@expr8811 declEndToken (@expr8812 ) .@expr1073750640 isExternC (@expr1073750641 ) ) ||@expr1073750642
1302: (@expr1073750643 var@var3143 .@expr8797 scope (@expr8798 ) &&@expr1073750646 var@var3143 .@expr8797 scope (@expr8798 ) .@expr8802 function@var3760 &&@expr1073750650 var@var3143 .@expr8797 scope (@expr8798 ) .@expr8802 function@var3760 .@expr8830 tokenDef@var3763 &&@expr1073750655 var@var3143 .@expr8797 scope (@expr8798 ) .@expr8802 function@var3760 .@expr8830 tokenDef@var3763 .@expr1073750660 isExternC (@expr1073750661 ) ) ) {
1303: continue ; }
1304:
1305: bool inconclusive@var3144 ; inconclusive@var3144 =@expr1073750662 false ;
1306:
1307: const bool isContainer@var3145 =@expr1073750663 var@var3143 .@expr8840 valueType (@expr8841 ) &&@expr1073750666 var@var3143 .@expr8840 valueType (@expr8841 ) .@expr1073750669 type@var3759 ==@expr1073750670 ValueType ::@expr1073750671 Type ::@expr1073750672 CONTAINER &&@expr1073750673 var@var3143 .@expr8840 valueType (@expr8841 ) .@expr8852 container@var3757 &&@expr1073750677 !@expr1073750678 var@var3143 .@expr8840 valueType (@expr8841 ) .@expr8852 container@var3757 .@expr1073750682 view@var3764 ;
1308: if (@expr1073750683 !@expr1073750684 isContainer@var3145 ) {
1309: if (@expr1073750685 var@var3143 .@expr8862 type (@expr8863 ) &&@expr1073750688 !@expr1073750689 var@var3143 .@expr8862 type (@expr8863 ) .@expr1073750692 isEnumType (@expr1073750693 ) ) {
1310:
1311: if (@expr1073750694 !@expr1073750695 var@var3143 .@expr8862 type (@expr8863 ) .@expr1073750698 classScope@var3758 ) {
1312: inconclusive@var3144 =@expr1073750699 true ; }
1313: else { if (@expr1073750700 estimateSize (@expr1073750701 var@var3143 .@expr8862 type (@expr8863 ) , mSettings@var29 , symbolDatabase@var3142 ) <=@expr1073750704 2 *@expr1073750705 mSettings@var29 .@expr1073750706 sizeof_pointer@var3741 ) {
1314: continue ; } }
1315: }
1316: else {
1317: continue ; }
1318: }
1319:
1320: if (@expr1073750707 inconclusive@var3144 &&@expr1073750708 !@expr1073750709 mSettings@var29 .@expr1073750710 certainty@var3737 .@expr1073750711 isEnabled (@expr1073750712 Certainty ::@expr1073750713 inconclusive@expr1073750580 ) ) {
1321: continue ; }
1322:
1323: const bool isConst@var3146 =@expr1073750714 var@var3143 .@expr1073750715 isConst (@expr1073750716 ) ;
1324: if (@expr1073750717 isConst@var3146 ) {
1325: passedByValueError (@expr8894 var@var3143 .@expr8895 nameToken (@expr8896 ) , var@var3143 .@expr8897 name (@expr8898 ) , inconclusive@var3144 ) ;
1326: continue ;
1327: }
1328:
1329:
1330: if (@expr1073750723 !@expr1073750724 var@var3143 .@expr8797 scope (@expr8798 ) ||@expr1073750727 var@var3143 .@expr8797 scope (@expr8798 ) .@expr8802 function@var3760 .@expr1073750731 hasVirtualSpecifier (@expr1073750732 ) ) {
1331: continue ; }
1332:
1333: if (@expr1073750733 canBeConst (@expr1073750734 var@var3143 , mSettings@var29 ) ) {
1334: passedByValueError (@expr8894 var@var3143 .@expr8895 nameToken (@expr8896 ) , var@var3143 .@expr8897 name (@expr8898 ) , inconclusive@var3144 ) ;
1335: }
1336: }
1337: }
1338:
1339: void CheckOther :: passedByValueError ( const Token * tok@var3147 , const std :: string & parname@var3148 , bool inconclusive@var3149 )
1340: {
1341: reportError (@expr1073750740 tok@var3147 , Severity ::@expr1073750741 performance , "passedByValue" ,
1342: "$symbol:" +@expr1073750742 parname@var3148 +@expr1073750743 "\nFunction parameter '$symbol' should be passed by const reference.\nParameter '$symbol' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++."
1343:
1344:
1345: , CWE398@var2876 , inconclusive@var3149 ?@expr1073750744 Certainty ::@expr1073750745 inconclusive :@expr1073750746 Certainty ::@expr1073750747 normal ) ;
1346: }
1347:
1348: static bool isUnusedVariable ( const Variable * var@var3150 )
1349: {
1350: if (@expr1073750748 !@expr1073750749 var@var3150 ) {
1351: return false ; }
1352: if (@expr1073750750 !@expr1073750751 var@var3150 .@expr8928 scope (@expr8929 ) ) {
1353: return false ; }
1354: const Token * start@var3151 ; start@var3151 =@expr1073750754 var@var3150 .@expr1073750755 declEndToken (@expr1073750756 ) ;
1355: if (@expr1073750757 !@expr1073750758 start@var3151 ) {
1356: return false ; }
1357: if (@expr1073750759 Token ::@expr1073750760 Match (@expr1073750761 start@var3151 , "; %varid% =" , var@var3150 .@expr8938 declarationId (@expr8939 ) ) ) {
1358: start@var3151 =@expr1073750764 start@var3151 .@expr1073750765 tokAt (@expr1073750766 2 ) ; }
1359: return !@expr1073750767 Token ::@expr1073750768 findmatch (@expr1073750769 start@var3151 .@expr1073750770 next (@expr1073750771 ) , "%varid%" , var@var3150 .@expr8928 scope (@expr8929 ) .@expr1073750774 bodyEnd@var3756 , var@var3150 .@expr8938 declarationId (@expr8939 ) ) ;
1360: }
1361:
1362: static bool isVariableMutableInInitializer ( const Token * start@var3152 , const Token * end@var3153 , int varid@var3154 )
1363: {
1364: if (@expr1073750777 !@expr1073750778 start@var3152 ) {
1365: return false ; }
1366: if (@expr1073750779 !@expr1073750780 end@var3153 ) {
1367: return false ; }
1368: for (@expr1073750781 const Token *@expr1073750782 tok@var3155 =@expr1073750783 start@var3152 ; tok@var3155 !=@expr1073750784 end@var3153 ; tok@var3155 =@expr1073750785 tok@var3155 .@expr1073750786 next (@expr1073750787 ) ) {
1369: if (@expr1073750788 tok@var3155 .@expr1073750789 varId (@expr1073750790 ) !=@expr1073750791 varid@var3154 ) {
1370: continue ; }
1371: if (@expr1073750792 tok@var3155 .@expr8969 astParent (@expr8970 ) ) {
1372: const Token * memberTok@var3156 ; memberTok@var3156 =@expr1073750795 tok@var3155 .@expr8969 astParent (@expr8970 ) .@expr1073750798 previous (@expr1073750799 ) ;
1373: if (@expr1073750800 Token ::@expr1073750801 Match (@expr1073750802 memberTok@var3156 , "%var% (" ) &&@expr1073750803 memberTok@var3156 .@expr8980 variable (@expr8981 ) ) {
1374: const Variable * memberVar@var3157 ; memberVar@var3157 =@expr1073750806 memberTok@var3156 .@expr8980 variable (@expr8981 ) ;
1375: if (@expr1073750809 memberVar@var3157 .@expr1073750810 isClass (@expr1073750811 ) ) {
1376:
1377:
1378: return true ; }
1379: if (@expr1073750812 !@expr1073750813 memberVar@var3157 .@expr1073750814 isReference (@expr1073750815 ) ) {
1380: continue ; }
1381: if (@expr1073750816 memberVar@var3157 .@expr1073750817 isConst (@expr1073750818 ) ) {
1382: continue ; }
1383: }
1384: return true ;
1385: } else {
1386: return true ;
1387: }
1388: }
1389: return false ;
1390: }
1391:
1392: void CheckOther :: checkConstVariable ( )
1393: {
1394: if (@expr1073750819 !@expr1073750820 mSettings@var29 .@expr1073750821 severity@var3736 .@expr1073750822 isEnabled (@expr1073750823 Severity ::@expr1073750824 style ) ||@expr1073750825 mTokenizer@var28 .@expr1073750826 isC (@expr1073750827 ) ) {
1395: return ; }
1396:
1397: const SymbolDatabase * const symbolDatabase@var3158 ; symbolDatabase@var3158 =@expr1073750828 mTokenizer@var28 .@expr1073750829 getSymbolDatabase (@expr1073750830 ) ;
1398:
1399: for (@expr1073750831 const Variable *@expr9008 var@var3159 :@expr1073750833 symbolDatabase@var3158 .@expr1073750834 variableList (@expr1073750835 ) ) {
1400: if (@expr1073750836 !@expr1073750837 var@var3159 ) {
1401: continue ; }
1402: if (@expr1073750838 !@expr1073750839 var@var3159 .@expr9016 isReference (@expr9017 ) ) {
1403: continue ; }
1404: if (@expr1073750842 var@var3159 .@expr1073750843 isRValueReference (@expr1073750844 ) ) {
1405: continue ; }
1406: if (@expr1073750845 var@var3159 .@expr1073750846 isPointer (@expr1073750847 ) ) {
1407: continue ; }
1408: if (@expr1073750848 var@var3159 .@expr1073750849 isConst (@expr1073750850 ) ) {
1409: continue ; }
1410: if (@expr1073750851 !@expr1073750852 var@var3159 .@expr9029 scope (@expr9030 ) ) {
1411: continue ; }
1412: const Scope * scope@var3160 ; scope@var3160 =@expr1073750855 var@var3159 .@expr9029 scope (@expr9030 ) ;
1413: if (@expr1073750858 !@expr1073750859 scope@var3160 .@expr9036 function@var3161 ) {
1414: continue ; }
1415: const Function * function@var3162 ; function@var3162 =@expr1073750861 scope@var3160 .@expr9036 function@var3161 ;
1416: if (@expr1073750863 var@var3159 .@expr1073750864 isArgument (@expr1073750865 ) ) {
1417: if (@expr1073750866 function@var3162 .@expr1073750867 isImplicitlyVirtual (@expr1073750868 ) ||@expr1073750869 function@var3162 .@expr1073750870 templateDef@var3163 ) {
1418: continue ; }
1419: if (@expr1073750871 isUnusedVariable (@expr1073750872 var@var3159 ) ) {
1420: continue ; }
1421: if (@expr1073750873 function@var3162 .@expr1073750874 isConstructor (@expr1073750875 ) &&@expr1073750876 isVariableMutableInInitializer (@expr1073750877 function@var3162 .@expr1073750878 constructorMemberInitialization (@expr1073750879 ) , scope@var3160 .@expr1073750880 bodyStart@var3164 , var@var3159 .@expr9057 declarationId (@expr9058 ) ) ) {
1422: continue ; }
1423: }
1424: if (@expr1073750883 var@var3159 .@expr1073750884 isGlobal (@expr1073750885 ) ) {
1425: continue ; }
1426: if (@expr1073750886 var@var3159 .@expr1073750887 isStatic (@expr1073750888 ) ) {
1427: continue ; }
1428: if (@expr1073750889 var@var3159 .@expr1073750890 isArray (@expr1073750891 ) ) {
1429: continue ; }
1430: if (@expr1073750892 var@var3159 .@expr1073750893 isEnumType (@expr1073750894 ) ) {
1431: continue ; }
1432: if (@expr1073750895 var@var3159 .@expr1073750896 isVolatile (@expr1073750897 ) ) {
1433: continue ; }
1434: if (@expr1073750898 isAliased (@expr1073750899 var@var3159 ) ) {
1435: continue ; }
1436: if (@expr1073750900 isVariableChanged (@expr1073750901 var@var3159 , mSettings@var29 , mTokenizer@var28 .@expr9078 isCPP (@expr9079 ) ) ) {
1437: continue ; }
1438: if (@expr1073750904 Function ::@expr1073750905 returnsReference (@expr1073750906 function@var3162 ) &&@expr1073750907 !@expr1073750908 Function ::@expr1073750909 returnsConst (@expr1073750910 function@var3162 ) ) {
1439: std ::@expr1073750911 vector < const Token *@expr9008 > returns@var3165 ; returns@var3165 =@expr1073750913 Function ::@expr1073750914 findReturns (@expr1073750915 function@var3162 ) ;
1440: if (@expr1073750916 std ::@expr1073750917 any_of (@expr1073750918 returns@var3165 .@expr1073750919 begin (@expr1073750920 ) , returns@var3165 .@expr1073750921 end (@expr1073750922 ) , [@expr1073750923 &@expr9100 ] (@expr1073750925 const Token *@expr9008 retTok@var3166 ) {
1441: if (@expr1073750927 retTok@var3166 .@expr1073750928 varId (@expr1073750929 ) ==@expr1073750930 var@var3159 .@expr9057 declarationId (@expr9058 ) ) {
1442: return true ; }
1443: while (@expr1073750933 retTok@var3166 &&@expr1073750934 retTok@var3166 .@expr1073750935 isCast (@expr1073750936 ) ) {
1444: retTok@var3166 =@expr1073750937 retTok@var3166 .@expr9114 astOperand2 (@expr9115 ) ; }
1445: while (@expr1073750940 Token ::@expr9117 simpleMatch (@expr1073750942 retTok@var3166 , "." ) ) {
1446: retTok@var3166 =@expr1073750943 retTok@var3166 .@expr9114 astOperand2 (@expr9115 ) ; }
1447: return hasLifetimeToken (@expr1073750946 getParentLifetime (@expr1073750947 retTok@var3166 ) , var@var3159 .@expr9124 nameToken (@expr9125 ) ) ;
1448: } ) ) {
1449: continue ; }
1450: }
1451:
1452: if (@expr1073750950 Token ::@expr1073750951 findmatch (@expr1073750952 var@var3159 .@expr9124 nameToken (@expr9125 ) , "& %varid%" , scope@var3160 .@expr9131 bodyEnd@var3167 , var@var3159 .@expr9057 declarationId (@expr9058 ) ) ) {
1453: continue ; }
1454:
1455: {
1456:
1457: bool usedInAssignment@var3168 ; usedInAssignment@var3168 =@expr1073750958 false ;
1458: for (@expr1073750959 const Token *@expr9008 tok@var3169 =@expr1073750961 var@var3159 .@expr9124 nameToken (@expr9125 ) ; tok@var3169 !=@expr1073750964 scope@var3160 .@expr9131 bodyEnd@var3167 &&@expr1073750966 tok@var3169 !=@expr1073750967 nullptr ; tok@var3169 =@expr1073750968 tok@var3169 .@expr9145 next (@expr9146 ) ) {
1459: if (@expr1073750971 Token ::@expr9148 Match (@expr1073750973 tok@var3169 , "& %var% = %varid%" , var@var3159 .@expr9057 declarationId (@expr9058 ) ) ) {
1460: const Variable * refvar@var3170 ; refvar@var3170 =@expr1073750976 tok@var3169 .@expr9145 next (@expr9146 ) .@expr1073750979 variable (@expr1073750980 ) ;
1461: if (@expr1073750981 refvar@var3170 &&@expr1073750982 !@expr1073750983 refvar@var3170 .@expr1073750984 isConst (@expr1073750985 ) &&@expr1073750986 refvar@var3170 .@expr1073750987 nameToken (@expr1073750988 ) ==@expr1073750989 tok@var3169 .@expr9145 next (@expr9146 ) ) {
1462: usedInAssignment@var3168 =@expr1073750992 true ;
1463: break ;
1464: }
1465: }
1466: }
1467: if (@expr1073750993 usedInAssignment@var3168 ) {
1468: continue ; }
1469: }
1470:
1471: {
1472: bool castToNonConst@var3171 ; castToNonConst@var3171 =@expr1073750994 false ;
1473: for (@expr1073750995 const Token *@expr9008 tok@var3172 =@expr1073750997 var@var3159 .@expr9124 nameToken (@expr9125 ) ; tok@var3172 !=@expr1073751000 scope@var3160 .@expr9131 bodyEnd@var3167 &&@expr1073751002 tok@var3172 !=@expr1073751003 nullptr ; tok@var3172 =@expr1073751004 tok@var3172 .@expr1073751005 next (@expr1073751006 ) ) {
1474: if (@expr1073751007 tok@var3172 .@expr1073751008 isCast (@expr1073751009 ) ) {
1475: if (@expr1073751010 !@expr1073751011 tok@var3172 .@expr9188 valueType (@expr9189 ) ) {
1476: castToNonConst@var3171 =@expr1073751014 true ;
1477: break ;
1478: }
1479: bool isConst@var3173 ; isConst@var3173 =@expr1073751015 0 !=@expr1073751016 (@expr1073751017 tok@var3172 .@expr9188 valueType (@expr9189 ) .@expr1073751020 constness@var3765 &@expr1073751021 (@expr1073751022 1 <<@expr1073751023 tok@var3172 .@expr9188 valueType (@expr9189 ) .@expr1073751026 pointer@var3766 ) ) ;
1480: if (@expr1073751027 !@expr1073751028 isConst@var3173 ) {
1481: castToNonConst@var3171 =@expr1073751029 true ;
1482: break ;
1483: }
1484: }
1485: }
1486: if (@expr1073751030 castToNonConst@var3171 ) {
1487: continue ; }
1488: }
1489:
1490: {
1491: bool changeStructData@var3174 ; changeStructData@var3174 =@expr1073751031 false ;
1492: for (@expr1073751032 const Token *@expr9008 tok@var3175 =@expr1073751034 var@var3159 .@expr9124 nameToken (@expr9125 ) ; tok@var3175 !=@expr1073751037 scope@var3160 .@expr9131 bodyEnd@var3167 &&@expr1073751039 tok@var3175 !=@expr1073751040 nullptr ; tok@var3175 =@expr1073751041 tok@var3175 .@expr1073751042 next (@expr1073751043 ) ) {
1493: if (@expr1073751044 tok@var3175 .@expr1073751045 variable (@expr1073751046 ) ==@expr1073751047 var@var3159 &&@expr1073751048 Token ::@expr9148 Match (@expr1073751050 tok@var3175 , "%var% ." ) ) {
1494: const Token * parent@var3176 ; parent@var3176 =@expr1073751051 tok@var3175 ;
1495: while (@expr1073751052 Token ::@expr9117 simpleMatch (@expr1073751054 parent@var3176 .@expr9231 astParent (@expr9232 ) , "." ) &&@expr1073751057 parent@var3176 ==@expr1073751058 parent@var3176 .@expr9231 astParent (@expr9232 ) .@expr1073751061 astOperand1 (@expr1073751062 ) ) {
1496: parent@var3176 =@expr1073751063 parent@var3176 .@expr9231 astParent (@expr9232 ) ; }
1497: if (@expr1073751066 parent@var3176 .@expr9243 valueType (@expr9244 ) &&@expr1073751069
1498: parent@var3176 .@expr9243 valueType (@expr9244 ) .@expr1073751072 pointer@var3766 >@expr1073751073 0 &&@expr1073751074
1499: parent@var3176 .@expr9243 valueType (@expr9244 ) .@expr1073751077 constness@var3765 ==@expr1073751078 0 &&@expr1073751079
1500: isVariableChanged (@expr1073751080 parent@var3176 , 1 , mSettings@var29 , mTokenizer@var28 .@expr9078 isCPP (@expr9079 ) ) ) {
1501: changeStructData@var3174 =@expr1073751083 true ;
1502: break ;
1503: }
1504: }
1505: }
1506: if (@expr1073751084 changeStructData@var3174 ) {
1507: continue ; }
1508: }
1509:
1510: if (@expr1073751085 var@var3159 .@expr9016 isReference (@expr9017 ) ) {
1511: bool callNonConstMethod@var3177 ; callNonConstMethod@var3177 =@expr1073751088 false ;
1512: for (@expr1073751089 const Token *@expr9008 tok@var3178 =@expr1073751091 var@var3159 .@expr9124 nameToken (@expr9125 ) ; tok@var3178 !=@expr1073751094 scope@var3160 .@expr9131 bodyEnd@var3167 &&@expr1073751096 tok@var3178 !=@expr1073751097 nullptr ; tok@var3178 =@expr1073751098 tok@var3178 .@expr1073751099 next (@expr1073751100 ) ) {
1513: if (@expr1073751101 tok@var3178 .@expr1073751102 variable (@expr1073751103 ) ==@expr1073751104 var@var3159 ) {
1514: if (@expr1073751105 Token ::@expr9148 Match (@expr1073751107 tok@var3178 , "%var% . * ( & %name% ::" ) ) {
1515: const Token * ftok@var3179 ; ftok@var3179 =@expr1073751108 tok@var3178 .@expr1073751109 linkAt (@expr1073751110 3 ) .@expr1073751111 previous (@expr1073751112 ) ;
1516: if (@expr1073751113 !@expr1073751114 ftok@var3179 .@expr9291 function (@expr9292 ) ||@expr1073751117 !@expr1073751118 ftok@var3179 .@expr9291 function (@expr9292 ) .@expr1073751121 isConst (@expr1073751122 ) ) {
1517: callNonConstMethod@var3177 =@expr1073751123 true ; }
1518: break ;
1519: }
1520: if (@expr1073751124 var@var3159 .@expr1073751125 isStlType (@expr1073751126 ) &&@expr1073751127 Token ::@expr9148 Match (@expr1073751129 tok@var3178 , "%var% [" ) ) {
1521: const Token * typeTok@var3180 ; typeTok@var3180 =@expr1073751130 var@var3159 .@expr9307 typeStartToken (@expr9308 ) ?@expr1073751133 var@var3159 .@expr9307 typeStartToken (@expr9308 ) .@expr1073751136 tokAt (@expr1073751137 2 ) :@expr1073751138 nullptr ;
1522: const auto &@expr9100 notConst@var3181 =@expr1073751140 CheckClass ::@expr1073751141 stl_containers_not_const@var2693 ;
1523: if (@expr1073751142 typeTok@var3180 &&@expr1073751143 notConst@var3181 .@expr1073751144 find (@expr1073751145 typeTok@var3180 .@expr1073751146 str (@expr1073751147 ) ) !=@expr1073751148 notConst@var3181 .@expr1073751149 end (@expr1073751150 ) ) {
1524: callNonConstMethod@var3177 =@expr1073751151 true ;
1525: break ;
1526: }
1527: }
1528: }
1529: }
1530: if (@expr1073751152 callNonConstMethod@var3177 ) {
1531: continue ; }
1532: }
1533:
1534: constVariableError (@expr1073751153 var@var3159 , function@var3162 ) ;
1535: }
1536: }
1537:
1538: void CheckOther :: checkConstPointer ( )
1539: {
1540: if (@expr1073751154 !@expr1073751155 mSettings@var29 .@expr1073751156 severity@var3736 .@expr1073751157 isEnabled (@expr1073751158 Severity ::@expr1073751159 style ) ) {
1541: return ; }
1542:
1543: std ::@expr1073751160 vector < const Variable *@expr9337 > pointers@var3182 ; std ::@expr1073751162 vector < const Variable *@expr9337 > nonConstPointers@var3183 ;
1544: for (@expr1073751164 const Token *@expr9337 tok@var3184 =@expr1073751166 mTokenizer@var28 .@expr1073751167 tokens (@expr1073751168 ) ; tok@var3184 ; tok@var3184 =@expr1073751169 tok@var3184 .@expr1073751170 next (@expr1073751171 ) ) {
1545: const Variable * const var@var3185 ; var@var3185 =@expr1073751172 tok@var3184 .@expr1073751173 variable (@expr1073751174 ) ;
1546: if (@expr1073751175 !@expr1073751176 var@var3185 ) {
1547: continue ; }
1548: if (@expr1073751177 !@expr1073751178 var@var3185 .@expr1073751179 isLocal (@expr1073751180 ) &&@expr1073751181 !@expr1073751182 var@var3185 .@expr1073751183 isArgument (@expr1073751184 ) ) {
1549: continue ; }
1550: const Token * const nameTok@var3186 ; nameTok@var3186 =@expr1073751185 var@var3185 .@expr1073751186 nameToken (@expr1073751187 ) ;
1551:
1552: if (@expr1073751188 tok@var3184 ==@expr1073751189 nameTok@var3186 &&@expr1073751190 (@expr1073751191 !@expr1073751192 var@var3185 .@expr1073751193 isStatic (@expr1073751194 ) ||@expr1073751195 Token ::@expr9372 simpleMatch (@expr1073751197 nameTok@var3186 .@expr1073751198 next (@expr1073751199 ) , "[" ) ) &&@expr1073751200
1553:
1554: !@expr1073751201 (@expr1073751202 Token ::@expr9372 simpleMatch (@expr1073751204 nameTok@var3186 .@expr9381 astParent (@expr9382 ) , ":" ) &&@expr1073751207 Token ::@expr9372 simpleMatch (@expr1073751209 nameTok@var3186 .@expr9381 astParent (@expr9382 ) .@expr1073751212 astParent (@expr1073751213 ) , "(" ) ) ) {
1555: continue ; }
1556: const ValueType * const vt@var3187 ; vt@var3187 =@expr1073751214 tok@var3184 .@expr1073751215 valueType (@expr1073751216 ) ;
1557: if (@expr1073751217 !@expr1073751218 vt@var3187 ) {
1558: continue ; }
1559: if (@expr1073751219 (@expr1073751220 vt@var3187 .@expr9397 pointer@var3188 !=@expr1073751222 1 &&@expr1073751223 !@expr1073751224 (@expr1073751225 vt@var3187 .@expr9397 pointer@var3188 ==@expr1073751227 2 &&@expr1073751228 var@var3185 .@expr1073751229 isArray (@expr1073751230 ) ) ) ||@expr1073751231 (@expr1073751232 vt@var3187 .@expr1073751233 constness@var3189 &@expr1073751234 1 ) ||@expr1073751235 vt@var3187 .@expr1073751236 reference@var3190 !=@expr1073751237 Reference ::@expr1073751238 None ) {
1560: continue ; }
1561: if (@expr1073751239 std ::@expr9416 find (@expr1073751241 nonConstPointers@var3183 .@expr9418 begin (@expr9419 ) , nonConstPointers@var3183 .@expr9420 end (@expr9421 ) , var@var3185 ) !=@expr1073751246 nonConstPointers@var3183 .@expr9420 end (@expr9421 ) ) {
1562: continue ; }
1563: pointers@var3182 .@expr1073751249 emplace_back (@expr1073751250 var@var3185 ) ;
1564: const Token * const parent@var3191 ; parent@var3191 =@expr1073751251 tok@var3184 .@expr1073751252 astParent (@expr1073751253 ) ;
1565: bool deref@var3192 ; deref@var3192 =@expr1073751254 false ;
1566: if (@expr1073751255 parent@var3191 &&@expr1073751256 parent@var3191 .@expr1073751257 isUnaryOp (@expr1073751258 "*" ) ) {
1567: deref@var3192 =@expr1073751259 true ; }
1568: else { if (@expr1073751260 Token ::@expr9372 simpleMatch (@expr1073751262 parent@var3191 , "[" ) &&@expr1073751263 parent@var3191 .@expr9440 astOperand1 (@expr9441 ) ==@expr1073751266 tok@var3184 &&@expr1073751267 tok@var3184 !=@expr1073751268 nameTok@var3186 ) {
1569: deref@var3192 =@expr1073751269 true ; } }
1570: if (@expr1073751270 deref@var3192 ) {
1571: const Token * const gparent@var3193 ; gparent@var3193 =@expr1073751271 parent@var3191 .@expr1073751272 astParent (@expr1073751273 ) ;
1572: if (@expr1073751274 Token ::@expr9451 Match (@expr1073751276 gparent@var3193 , "%cop%" ) &&@expr1073751277 !@expr1073751278 gparent@var3193 .@expr9455 isUnaryOp (@expr1073751280 "&" ) &&@expr1073751281 !@expr1073751282 gparent@var3193 .@expr9455 isUnaryOp (@expr1073751284 "*" ) ) {
1573: continue ; }
1574: if (@expr1073751285 Token ::@expr9372 simpleMatch (@expr1073751287 gparent@var3193 , "return" ) ) {
1575: continue ; }
1576: else { if (@expr1073751288 Token ::@expr9451 Match (@expr1073751290 gparent@var3193 , "%assign%" ) &&@expr1073751291 parent@var3191 ==@expr9468 gparent@var3193 .@expr9469 astOperand2 (@expr9470 ) ) {
1577: bool takingRef@var3194 ; takingRef@var3194 =@expr1073751295 false ;
1578: const Token * lhs@var3195 ; lhs@var3195 =@expr1073751296 gparent@var3193 .@expr1073751297 astOperand1 (@expr1073751298 ) ;
1579: if (@expr1073751299 lhs@var3195 &&@expr1073751300 lhs@var3195 .@expr9477 variable (@expr9478 ) &&@expr1073751303 lhs@var3195 .@expr9477 variable (@expr9478 ) .@expr1073751306 isReference (@expr1073751307 ) &&@expr1073751308 lhs@var3195 .@expr9477 variable (@expr9478 ) .@expr1073751311 nameToken (@expr1073751312 ) ==@expr1073751313 lhs@var3195 ) {
1580: takingRef@var3194 =@expr1073751314 true ; }
1581: if (@expr1073751315 !@expr1073751316 takingRef@var3194 ) {
1582: continue ; }
1583: } else { if (@expr1073751317 Token ::@expr9372 simpleMatch (@expr1073751319 gparent@var3193 , "[" ) &&@expr1073751320 gparent@var3193 .@expr9469 astOperand2 (@expr9470 ) ==@expr9468 parent@var3191 ) {
1584: continue ; } } }
1585: } else {
1586: if (@expr1073751324 Token ::@expr9451 Match (@expr1073751326 parent@var3191 , "%oror%|%comp%|&&|?|!|-" ) ) {
1587: continue ; }
1588: else { if (@expr1073751327 Token ::@expr9372 simpleMatch (@expr1073751329 parent@var3191 , "(" ) &&@expr1073751330 Token ::@expr9451 Match (@expr1073751332 parent@var3191 .@expr9440 astOperand1 (@expr9441 ) , "if|while" ) ) {
1589: continue ; } }
1590: }
1591: nonConstPointers@var3183 .@expr1073751335 emplace_back (@expr1073751336 var@var3185 ) ;
1592: }
1593: for (@expr1073751337 const Variable *@expr9337 p@var3196 :@expr1073751339 pointers@var3182 ) {
1594: if (@expr1073751340 p@var3196 .@expr9517 isArgument (@expr9518 ) ) {
1595: if (@expr1073751343 !@expr1073751344 p@var3196 .@expr9521 scope (@expr9522 ) ||@expr1073751347 !@expr1073751348 p@var3196 .@expr9521 scope (@expr9522 ) .@expr9527 function@var3760 ||@expr1073751352 p@var3196 .@expr9521 scope (@expr9522 ) .@expr9527 function@var3760 .@expr1073751356 isImplicitlyVirtual (@expr1073751357 true ) ||@expr1073751358 p@var3196 .@expr9521 scope (@expr9522 ) .@expr9527 function@var3760 .@expr1073751362 hasVirtualSpecifier (@expr1073751363 ) ) {
1596: continue ; }
1597: }
1598: if (@expr1073751364 std ::@expr9416 find (@expr1073751366 nonConstPointers@var3183 .@expr9418 begin (@expr9419 ) , nonConstPointers@var3183 .@expr9420 end (@expr9421 ) , p@var3196 ) ==@expr1073751371 nonConstPointers@var3183 .@expr9420 end (@expr9421 ) ) {
1599: const Token * start@var3197 ; start@var3197 =@expr1073751374 (@expr1073751375 p@var3196 .@expr9517 isArgument (@expr9518 ) ) ?@expr1073751378 p@var3196 .@expr9521 scope (@expr9522 ) .@expr1073751381 bodyStart@var3761 :@expr1073751382 p@var3196 .@expr1073751383 nameToken (@expr1073751384 ) .@expr1073751385 next (@expr1073751386 ) ;
1600: const int indirect@var3198 =@expr1073751387 p@var3196 .@expr1073751388 isArray (@expr1073751389 ) ?@expr1073751390 p@var3196 .@expr1073751391 dimensions (@expr1073751392 ) .@expr1073751393 size (@expr1073751394 ) :@expr1073751395 1 ;
1601: if (@expr1073751396 isVariableChanged (@expr1073751397 start@var3197 , p@var3196 .@expr9521 scope (@expr9522 ) .@expr1073751400 bodyEnd@var3756 , indirect@var3198 , p@var3196 .@expr1073751401 declarationId (@expr1073751402 ) , false , mSettings@var29 , mTokenizer@var28 .@expr1073751403 isCPP (@expr1073751404 ) ) ) {
1602: continue ; }
1603: constVariableError (@expr1073751405 p@var3196 , nullptr ) ;
1604: }
1605: }
1606: }
1607: void CheckOther :: constVariableError ( const Variable * var@var3199 , const Function * function@var3200 )
1608: {
1609: if (@expr1073751406 !@expr1073751407 var@var3199 ) {
1610: reportError (@expr1073751408 nullptr , Severity ::@expr9585 style , "constParameter" , "Parameter 'x' can be declared with const" ) ;
1611: reportError (@expr1073751410 nullptr , Severity ::@expr9585 style , "constVariable" , "Variable 'x' can be declared with const" ) ;
1612: reportError (@expr1073751412 nullptr , Severity ::@expr9585 style , "constParameterCallback" , "Parameter 'x' can be declared with const, however it seems that 'f' is a callback function." ) ;
1613: return ;
1614: }
1615:
1616: const std ::@expr1073751414 string vartype@var3201 (@expr1073751415 var@var3199 .@expr9592 isArgument (@expr9593 ) ?@expr1073751418 "Parameter" :@expr1073751419 "Variable" ) ;
1617: const std ::@expr1073751420 string varname@var3202 (@expr1073751421 var@var3199 .@expr1073751422 name (@expr1073751423 ) ) ;
1618:
1619: std ::@expr1073751424 list < std ::@expr9601 pair < const Token *@expr9602 , std ::@expr9601 string > > errorPath@var3203 ;
1620: std ::@expr1073751428 string id@var3204 ; id@var3204 =@expr1073751429 "const" +@expr1073751430 vartype@var3201 ;
1621: std ::@expr1073751431 string message@var3205 ; message@var3205 =@expr1073751432 "$symbol:" +@expr1073751433 varname@var3202 +@expr1073751434 "\n" +@expr1073751435 vartype@var3201 +@expr1073751436 " '$symbol' can be declared with const" ;
1622: errorPath@var3203 .@expr1073751437 push_back (@expr1073751438 std ::@expr9615 pair < const Token *@expr9602 , std ::@expr9601 string > (@expr1073751442 var@var3199 ?@expr1073751443 var@var3199 .@expr1073751444 nameToken (@expr1073751445 ) :@expr1073751446 nullptr , message@var3205 ) ) ;
1623: if (@expr1073751447 var@var3199 &&@expr1073751448 var@var3199 .@expr9592 isArgument (@expr9593 ) &&@expr1073751451 function@var3200 &&@expr1073751452 function@var3200 .@expr9629 functionPointerUsage@var3206 ) {
1624: errorPath@var3203 .@expr1073751454 push_front (@expr1073751455 std ::@expr9615 pair < const Token *@expr9602 , std ::@expr9601 string > (@expr1073751459 function@var3200 .@expr9629 functionPointerUsage@var3206 , "You might need to cast the function pointer here" ) ) ;
1625: id@var3204 +=@expr1073751461 "Callback" ;
1626: message@var3205 +=@expr1073751462 ". However it seems that '" +@expr1073751463 function@var3200 .@expr1073751464 name (@expr1073751465 ) +@expr1073751466 "' is a callback function, if '$symbol' is declared with const you might also need to cast function pointer(s)." ;
1627: }
1628:
1629: reportError (@expr1073751467 errorPath@var3203 , Severity ::@expr9585 style , id@var3204 .@expr1073751469 c_str (@expr1073751470 ) , message@var3205 , CWE398@var2876 , Certainty ::@expr1073751471 normal ) ;
1630: }
1631:
|
1635:
1636: void CheckOther :: checkCharVariable ( )
1637: {
1638: const bool warning@var3207 =@expr1073751472 mSettings@var29 .@expr9649 severity@var3736 .@expr9650 isEnabled (@expr1073751475 Severity ::@expr1073751476 warning ) ;
1639: const bool portability@var3208 =@expr1073751477 mSettings@var29 .@expr9649 severity@var3736 .@expr9650 isEnabled (@expr1073751480 Severity ::@expr1073751481 portability ) ;
1640: if (@expr1073751482 !@expr1073751483 warning@var3207 &&@expr1073751484 !@expr1073751485 portability@var3208 ) {
1641: return ; }
1642:
1643: const SymbolDatabase * symbolDatabase@var3209 ; symbolDatabase@var3209 =@expr1073751486 mTokenizer@var28 .@expr1073751487 getSymbolDatabase (@expr1073751488 ) ;
1644: for (@expr1073751489 const Scope *@expr9666 scope@var3210 :@expr1073751491 symbolDatabase@var3209 .@expr1073751492 functionScopes@var3211 ) {
1645: for (@expr1073751493 const Token *@expr9666 tok@var3212 =@expr1073751495 scope@var3210 .@expr1073751496 bodyStart@var3213 ; tok@var3212 !=@expr1073751497 scope@var3210 .@expr1073751498 bodyEnd@var3214 ; tok@var3212 =@expr1073751499 tok@var3212 .@expr9676 next (@expr9677 ) ) {
1646: if (@expr1073751502 Token ::@expr9679 Match (@expr1073751504 tok@var3212 , "%var% [" ) ) {
1647: if (@expr1073751505 !@expr1073751506 tok@var3212 .@expr9683 variable (@expr9684 ) ) {
1648: continue ; }
1649: if (@expr1073751509 !@expr1073751510 tok@var3212 .@expr9683 variable (@expr9684 ) .@expr9689 isArray (@expr9690 ) &&@expr1073751515 !@expr1073751516 tok@var3212 .@expr9683 variable (@expr9684 ) .@expr1073751519 isPointer (@expr1073751520 ) ) {
1650: continue ; }
1651: const Token * index@var3215 ; index@var3215 =@expr1073751521 tok@var3212 .@expr9676 next (@expr9677 ) .@expr1073751524 astOperand2 (@expr1073751525 ) ;
1652: if (@expr1073751526 warning@var3207 &&@expr1073751527 tok@var3212 .@expr9683 variable (@expr9684 ) .@expr9689 isArray (@expr9690 ) &&@expr1073751532 astIsSignedChar (@expr1073751533 index@var3215 ) &&@expr1073751534 index@var3215 .@expr9711 getValueGE (@expr9712 0x80 , mSettings@var29 ) ) {
1653: signedCharArrayIndexError (@expr1073751537 tok@var3212 ) ; }
1654: if (@expr1073751538 portability@var3208 &&@expr1073751539 astIsUnknownSignChar (@expr1073751540 index@var3215 ) &&@expr1073751541 index@var3215 .@expr9711 getValueGE (@expr9712 0x80 , mSettings@var29 ) ) {
1655: unknownSignCharArrayIndexError (@expr1073751544 tok@var3212 ) ; }
1656: } else { if (@expr1073751545 warning@var3207 &&@expr1073751546 Token ::@expr9679 Match (@expr1073751548 tok@var3212 , "[&|^]" ) &&@expr1073751549 tok@var3212 .@expr1073751550 isBinaryOp (@expr1073751551 ) ) {
1657: bool warn@var3216 ; warn@var3216 =@expr1073751552 false ;
1658: if (@expr1073751553 astIsSignedChar (@expr1073751554 tok@var3212 .@expr9731 astOperand1 (@expr9732 ) ) ) {
1659: const ValueFlow ::@expr9733 Value * v1@var3217 ; v1@var3217 =@expr1073751558 tok@var3212 .@expr9731 astOperand1 (@expr9732 ) .@expr1073751561 getValueLE (@expr1073751562 -1 , mSettings@var29 ) ;
1660: const ValueFlow ::@expr9733 Value * v2@var3218 ; v2@var3218 =@expr1073751564 tok@var3212 .@expr9741 astOperand2 (@expr9742 ) .@expr1073751567 getMaxValue (@expr1073751568 false ) ;
1661: if (@expr1073751569 !@expr1073751570 v1@var3217 ) {
1662: v1@var3217 =@expr1073751571 tok@var3212 .@expr9731 astOperand1 (@expr9732 ) .@expr1073751574 getValueGE (@expr1073751575 0x80 , mSettings@var29 ) ; }
1663: if (@expr1073751576 v1@var3217 &&@expr1073751577 !@expr1073751578 (@expr1073751579 tok@var3212 .@expr9756 str (@expr9757 ) ==@expr9758 "&" &&@expr1073751583 v2@var3218 &&@expr1073751584 v2@var3218 .@expr1073751585 isKnown (@expr1073751586 ) &&@expr1073751587 v2@var3218 .@expr9764 intvalue@var3219 >=@expr1073751589 0 &&@expr1073751590 v2@var3218 .@expr9764 intvalue@var3219 <@expr1073751592 0x100 ) ) {
1664: warn@var3216 =@expr1073751593 true ; }
1665: } else { if (@expr1073751594 astIsSignedChar (@expr1073751595 tok@var3212 .@expr9741 astOperand2 (@expr9742 ) ) ) {
1666: const ValueFlow ::@expr9733 Value * v1@var3220 ; v1@var3220 =@expr1073751599 tok@var3212 .@expr9741 astOperand2 (@expr9742 ) .@expr1073751602 getValueLE (@expr1073751603 -1 , mSettings@var29 ) ;
1667: const ValueFlow ::@expr9733 Value * v2@var3221 ; v2@var3221 =@expr1073751605 tok@var3212 .@expr9731 astOperand1 (@expr9732 ) .@expr1073751608 getMaxValue (@expr1073751609 false ) ;
1668: if (@expr1073751610 !@expr1073751611 v1@var3220 ) {
1669: v1@var3220 =@expr1073751612 tok@var3212 .@expr9741 astOperand2 (@expr9742 ) .@expr1073751615 getValueGE (@expr1073751616 0x80 , mSettings@var29 ) ; }
1670: if (@expr1073751617 v1@var3220 &&@expr1073751618 !@expr1073751619 (@expr1073751620 tok@var3212 .@expr9756 str (@expr9757 ) ==@expr9758 "&" &&@expr1073751624 v2@var3221 &&@expr1073751625 v2@var3221 .@expr1073751626 isKnown (@expr1073751627 ) &&@expr1073751628 v2@var3221 .@expr9805 intvalue@var3222 >=@expr1073751630 0 &&@expr1073751631 v2@var3221 .@expr9805 intvalue@var3222 <@expr1073751633 0x100 ) ) {
1671: warn@var3216 =@expr1073751634 true ; }
1672: } }
1673:
1674:
1675: if (@expr1073751635 warn@var3216 &&@expr1073751636 Token ::@expr1073751637 simpleMatch (@expr1073751638 tok@var3212 .@expr9815 astParent (@expr9816 ) , "=" ) ) {
1676: const Token * lhs@var3223 ; lhs@var3223 =@expr1073751641 tok@var3212 .@expr9815 astParent (@expr9816 ) .@expr1073751644 astOperand1 (@expr1073751645 ) ;
1677: if (@expr1073751646 lhs@var3223 &&@expr1073751647 lhs@var3223 .@expr9824 valueType (@expr9825 ) &&@expr1073751650 lhs@var3223 .@expr9824 valueType (@expr9825 ) .@expr1073751653 type@var3759 >=@expr1073751654 ValueType ::@expr1073751655 Type ::@expr1073751656 SHORT ) {
1678: charBitOpError (@expr1073751657 tok@var3212 ) ; }
1679: }
1680: } }
1681: }
1682: }
1683: }
1684:
1685: void CheckOther :: signedCharArrayIndexError ( const Token * tok@var3224 )
1686: {
1687: reportError (@expr1073751658 tok@var3224 ,
1688: Severity ::@expr1073751659 warning ,
1689: "signedCharArrayIndex" ,
1690: "Signed 'char' type used as array index.\nSigned 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension."
1691:
1692:
1693: , CWE128@var2871 , Certainty ::@expr1073751660 normal ) ;
1694: }
1695:
1696: void CheckOther :: unknownSignCharArrayIndexError ( const Token * tok@var3225 )
1697: {
1698: reportError (@expr1073751661 tok@var3225 ,
1699: Severity ::@expr1073751662 portability ,
1700: "unknownSignCharArrayIndex" ,
1701: "'char' type used as array index.\n'char' type used as array index. Values greater than 127 will be treated depending on whether 'char' is signed or unsigned on target platform."
1702:
1703: , CWE758@var2888 , Certainty ::@expr1073751663 normal ) ;
1704: }
1705:
1706: void CheckOther :: charBitOpError ( const Token * tok@var3226 )
1707: {
1708: reportError (@expr1073751664 tok@var3226 ,
1709: Severity ::@expr1073751665 warning ,
1710: "charBitOp" ,
1711: "When using 'char' variables in bit operations, sign extension can generate unexpected results.\nWhen using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\n    char c = 0x80;\n    int i = 0 | c;\n    if (i & 0x8000)\n        printf(\"not expected\");\nThe \"not expected\" will be printed on the screen."
1712:
|
1716:
1717: , CWE398@var2876 , Certainty ::@expr1073751666 normal ) ;
1718: }
1719:
|
1723:
1724: static bool isType ( const Token * tok@var3227 , bool unknown@var3228 )
1725: {
1726: if (@expr1073751667 Token ::@expr9844 Match (@expr1073751669 tok@var3227 , "%type%" ) ) {
1727: return true ; }
1728: if (@expr1073751670 Token ::@expr9847 simpleMatch (@expr1073751672 tok@var3227 , "::" ) ) {
1729: return isType (@expr1073751673 tok@var3227 .@expr1073751674 astOperand2 (@expr1073751675 ) , unknown@var3228 ) ; }
1730: if (@expr1073751676 Token ::@expr9847 simpleMatch (@expr1073751678 tok@var3227 , "<" ) &&@expr1073751679 tok@var3227 .@expr1073751680 link (@expr1073751681 ) ) {
1731: return true ; }
1732: if (@expr1073751682 unknown@var3228 &&@expr1073751683 Token ::@expr9844 Match (@expr1073751685 tok@var3227 , "%name% !!(" ) ) {
1733: return true ; }
1734: return false ;
1735: }
1736:
1737: static bool isVarDeclOp ( const Token * tok@var3229 )
1738: {
1739: if (@expr1073751686 !@expr1073751687 tok@var3229 ) {
1740: return false ; }
1741: const Token * vartok@var3230 ; vartok@var3230 =@expr1073751688 tok@var3229 .@expr1073751689 astOperand2 (@expr1073751690 ) ;
1742: if (@expr1073751691 vartok@var3230 &&@expr1073751692 vartok@var3230 .@expr9869 variable (@expr9870 ) &&@expr1073751695 vartok@var3230 .@expr9869 variable (@expr9870 ) .@expr1073751698 nameToken (@expr1073751699 ) ==@expr1073751700 vartok@var3230 ) {
1743: return true ; }
1744: const Token * typetok@var3231 ; typetok@var3231 =@expr1073751701 tok@var3229 .@expr1073751702 astOperand1 (@expr1073751703 ) ;
1745: return isType (@expr1073751704 typetok@var3231 , Token ::@expr1073751705 Match (@expr1073751706 vartok@var3230 , "%var%" ) ) ;
1746: }
1747:
1748: static bool isBracketAccess ( const Token * tok@var3232 )
1749: {
1750: if (@expr1073751707 !@expr1073751708 Token ::@expr9885 simpleMatch (@expr9886 tok@var3232 , "[" ) ||@expr1073751711 !@expr1073751712 tok@var3232 .@expr9889 astOperand1 (@expr9890 ) ) {
1751: return false ; }
1752: tok@var3232 =@expr1073751715 tok@var3232 .@expr9889 astOperand1 (@expr9890 ) ;
1753: if (@expr1073751718 tok@var3232 .@expr1073751719 str (@expr1073751720 ) ==@expr1073751721 "." ) {
1754: tok@var3232 =@expr1073751722 tok@var3232 .@expr1073751723 astOperand2 (@expr1073751724 ) ; }
1755: while (@expr1073751725 Token ::@expr9885 simpleMatch (@expr9886 tok@var3232 , "[" ) ) {
1756: tok@var3232 =@expr1073751728 tok@var3232 .@expr9889 astOperand1 (@expr9890 ) ; }
1757: if (@expr1073751731 !@expr1073751732 tok@var3232 ||@expr1073751733 !@expr1073751734 tok@var3232 .@expr9911 variable (@expr9912 ) ) {
1758: return false ; }
1759: return tok@var3232 .@expr9911 variable (@expr9912 ) .@expr1073751739 nameToken (@expr1073751740 ) !=@expr1073751741 tok@var3232 ;
1760: }
1761:
1762: static bool isConstStatement ( const Token * tok@var3233 , bool cpp@var3234 )
1763: {
1764: if (@expr1073751742 !@expr1073751743 tok@var3233 ) {
1765: return false ; }
1766: if (@expr1073751744 tok@var3233 .@expr1073751745 isExpandedMacro (@expr1073751746 ) ) {
1767: return false ; }
1768: if (@expr1073751747 Token ::@expr9924 Match (@expr1073751749 tok@var3233 , "%bool%|%num%|%str%|%char%|nullptr|NULL" ) ) {
1769: return true ; }
1770: if (@expr1073751750 Token ::@expr9924 Match (@expr1073751752 tok@var3233 , "%var%" ) ) {
1771: return true ; }
1772: if (@expr1073751753 Token ::@expr9924 Match (@expr1073751755 tok@var3233 , "*|&|&&" ) &&@expr1073751756
1773: (@expr1073751757 Token ::@expr9924 Match (@expr1073751759 tok@var3233 .@expr9936 previous (@expr9937 ) , "::|.|const|volatile|restrict" ) ||@expr1073751762 isVarDeclOp (@expr1073751763 tok@var3233 ) ) ) {
1774: return false ; }
1775: if (@expr1073751764 Token ::@expr9924 Match (@expr1073751766 tok@var3233 , "<<|>>" ) &&@expr1073751767 !@expr1073751768 astIsIntegral (@expr1073751769 tok@var3233 , false ) ) {
1776: return false ; }
1777: if (@expr1073751770 tok@var3233 .@expr9947 astTop (@expr9948 ) &&@expr1073751773 Token ::@expr9950 simpleMatch (@expr1073751775 tok@var3233 .@expr9947 astTop (@expr9948 ) .@expr1073751778 astOperand1 (@expr1073751779 ) , "delete" ) ) {
1778: return false ; }
1779: if (@expr1073751780 Token ::@expr9924 Match (@expr1073751782 tok@var3233 , "&&|%oror%" ) ) {
1780: return isConstStatement (@expr9959 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , cpp@var3234 ) &&@expr9962 isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ; }
1781: if (@expr1073751790 Token ::@expr9924 Match (@expr1073751792 tok@var3233 , "!|~|%cop%" ) &&@expr1073751793 (@expr1073751794 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) ||@expr1073751797 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) ) ) {
1782: return true ; }
1783: if (@expr1073751800 Token ::@expr9950 simpleMatch (@expr1073751802 tok@var3233 .@expr9936 previous (@expr9937 ) , "sizeof (" ) ) {
1784: return true ; }
1785: if (@expr1073751805 isCPPCast (@expr1073751806 tok@var3233 ) ) {
1786: if (@expr1073751807 Token ::@expr9950 simpleMatch (@expr1073751809 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , "dynamic_cast" ) &&@expr1073751812 Token ::@expr9950 simpleMatch (@expr1073751814 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) .@expr1073751817 linkAt (@expr1073751818 1 ) .@expr1073751819 previous (@expr1073751820 ) , "& >" ) ) {
1787: return false ; }
1788: return isWithoutSideEffects (@expr1073751821 cpp@var3234 , tok@var3233 ) &&@expr1073751822 isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ;
1789: }
1790: else { if (@expr1073751826 tok@var3233 .@expr1073751827 isCast (@expr1073751828 ) &&@expr1073751829 tok@var3233 .@expr10006 next (@expr10007 ) &&@expr1073751832 tok@var3233 .@expr10006 next (@expr10007 ) .@expr1073751835 isStandardType (@expr1073751836 ) ) {
1791: return isWithoutSideEffects (@expr1073751837 cpp@var3234 , tok@var3233 .@expr9960 astOperand1 (@expr9961 ) ) &&@expr1073751840 isConstStatement (@expr9959 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , cpp@var3234 ) ; } }
1792: if (@expr1073751844 Token ::@expr9950 simpleMatch (@expr1073751846 tok@var3233 , "." ) ) {
1793: return isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ; }
1794: if (@expr1073751850 Token ::@expr9950 simpleMatch (@expr1073751852 tok@var3233 , "," ) ) {
1795: if (@expr1073751853 tok@var3233 .@expr10030 astParent (@expr10031 ) ) {
1796: return isConstStatement (@expr9959 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , cpp@var3234 ) &&@expr9962 isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ; }
1797: else {
1798: const Token * lml@var3235 ; lml@var3235 =@expr1073751863 previousBeforeAstLeftmostLeaf (@expr1073751864 tok@var3233 ) ;
1799: if (@expr1073751865 lml@var3235 ) {
1800: lml@var3235 =@expr1073751866 lml@var3235 .@expr1073751867 next (@expr1073751868 ) ; }
1801: const Token * stream@var3236 ; stream@var3236 =@expr1073751869 lml@var3235 ;
1802: while (@expr1073751870 stream@var3236 &&@expr1073751871 Token ::@expr9924 Match (@expr1073751873 stream@var3236 .@expr10050 astParent (@expr10051 ) , ".|[|(|*" ) ) {
1803: stream@var3236 =@expr1073751876 stream@var3236 .@expr10050 astParent (@expr10051 ) ; }
1804: return (@expr1073751879 !@expr1073751880 stream@var3236 ||@expr1073751881 !@expr1073751882 isLikelyStream (@expr1073751883 cpp@var3234 , stream@var3236 ) ) &&@expr1073751884 isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ;
1805: }
1806: }
1807: if (@expr1073751888 Token ::@expr9950 simpleMatch (@expr1073751890 tok@var3233 , "?" ) &&@expr1073751891 Token ::@expr9950 simpleMatch (@expr1073751893 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , ":" ) ) {
1808: return isConstStatement (@expr9959 tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , cpp@var3234 ) &&@expr1073751899 isConstStatement (@expr1073751900 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) .@expr1073751903 astOperand1 (@expr1073751904 ) , cpp@var3234 ) &&@expr1073751905 isConstStatement (@expr1073751906 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) .@expr1073751909 astOperand2 (@expr1073751910 ) , cpp@var3234 ) ; }
1809: if (@expr1073751911 isBracketAccess (@expr1073751912 tok@var3233 ) &&@expr1073751913 isWithoutSideEffects (@expr1073751914 cpp@var3234 , tok@var3233 .@expr9960 astOperand1 (@expr9961 ) , true , false ) ) {
1810: if (@expr1073751917 Token ::@expr9950 simpleMatch (@expr1073751919 tok@var3233 .@expr10030 astParent (@expr10031 ) , "[" ) ) {
1811: return isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) &&@expr1073751925 isConstStatement (@expr1073751926 tok@var3233 .@expr10030 astParent (@expr10031 ) , cpp@var3234 ) ; }
1812: return isConstStatement (@expr9963 tok@var3233 .@expr9964 astOperand2 (@expr9965 ) , cpp@var3234 ) ;
1813: }
1814: return false ;
1815: }
1816:
1817: static bool isVoidStmt ( const Token * tok@var3237 )
1818: {
1819: if (@expr1073751932 Token ::@expr10109 simpleMatch (@expr1073751934 tok@var3237 , "( void" ) ) {
1820: return true ; }
1821: if (@expr1073751935 isCPPCast (@expr1073751936 tok@var3237 ) &&@expr1073751937 tok@var3237 .@expr10114 astOperand1 (@expr10115 ) &&@expr1073751940 Token ::@expr10117 Match (@expr1073751942 tok@var3237 .@expr10114 astOperand1 (@expr10115 ) .@expr1073751945 next (@expr1073751946 ) , "< void *| >" ) ) {
1822: return true ; }
1823: const Token * tok2@var3238 ; tok2@var3238 =@expr1073751947 tok@var3237 ;
1824: while (@expr1073751948 tok2@var3238 .@expr10125 astOperand1 (@expr10126 ) ) {
1825: tok2@var3238 =@expr1073751951 tok2@var3238 .@expr10125 astOperand1 (@expr10126 ) ; }
1826: if (@expr1073751954 Token ::@expr10109 simpleMatch (@expr1073751956 tok2@var3238 .@expr10133 previous (@expr10134 ) , ")" ) &&@expr1073751959 Token ::@expr10109 simpleMatch (@expr1073751961 tok2@var3238 .@expr10133 previous (@expr10134 ) .@expr1073751964 link (@expr1073751965 ) , "( void" ) ) {
1827: return true ; }
1828: if (@expr1073751966 Token ::@expr10109 simpleMatch (@expr1073751968 tok2@var3238 , "( void" ) ) {
1829: return true ; }
1830: return Token ::@expr10117 Match (@expr1073751970 tok2@var3238 .@expr10133 previous (@expr10134 ) , "delete|throw|return" ) ;
1831: }
1832:
1833: static bool isConstTop ( const Token * tok@var3239 )
1834: {
1835: if (@expr1073751973 !@expr1073751974 tok@var3239 ) {
1836: return false ; }
1837: if (@expr1073751975 !@expr1073751976 tok@var3239 .@expr10153 astParent (@expr10154 ) ) {
1838: return true ; }
1839: if (@expr1073751979 Token ::@expr10156 simpleMatch (@expr1073751981 tok@var3239 .@expr10153 astParent (@expr10154 ) , ";" ) &&@expr1073751984
1840: Token ::@expr1073751985 Match (@expr1073751986 tok@var3239 .@expr10163 astTop (@expr10164 ) .@expr1073751989 previous (@expr1073751990 ) , "for|if (" ) &&@expr1073751991 Token ::@expr10156 simpleMatch (@expr1073751993 tok@var3239 .@expr10163 astTop (@expr10164 ) .@expr1073751996 astOperand2 (@expr1073751997 ) , ";" ) ) {
1841: if (@expr1073751998 Token ::@expr10156 simpleMatch (@expr1073752000 tok@var3239 .@expr10153 astParent (@expr10154 ) .@expr1073752003 astParent (@expr1073752004 ) , ";" ) ) {
1842: return tok@var3239 .@expr10153 astParent (@expr10154 ) .@expr1073752007 astOperand2 (@expr1073752008 ) ==@expr1073752009 tok@var3239 ; }
1843: else {
1844: return tok@var3239 .@expr10153 astParent (@expr10154 ) .@expr1073752012 astOperand1 (@expr1073752013 ) ==@expr1073752014 tok@var3239 ; }
1845: }
1846: if (@expr1073752015 Token ::@expr10156 simpleMatch (@expr1073752017 tok@var3239 , "[" ) ) {
1847: const Token * bracTok@var3240 ; bracTok@var3240 =@expr1073752018 tok@var3239 ;
1848: while (@expr1073752019 Token ::@expr10156 simpleMatch (@expr1073752021 bracTok@var3240 .@expr10198 astParent (@expr10199 ) , "[" ) ) {
1849: bracTok@var3240 =@expr1073752024 bracTok@var3240 .@expr10198 astParent (@expr10199 ) ; }
1850: if (@expr1073752027 !@expr1073752028 bracTok@var3240 .@expr10198 astParent (@expr10199 ) ) {
1851: return true ; }
1852: }
1853: return false ;
1854: }
1855:
1856: void CheckOther :: checkIncompleteStatement ( )
1857: {
1858: if (@expr1073752032 !@expr1073752033 mSettings@var29 .@expr1073752034 severity@var3736 .@expr1073752035 isEnabled (@expr1073752036 Severity ::@expr1073752037 warning ) ) {
1859: return ; }
1860:
1861: for (@expr1073752038 const Token *@expr10215 tok@var3241 =@expr1073752040 mTokenizer@var28 .@expr1073752041 tokens (@expr1073752042 ) ; tok@var3241 ; tok@var3241 =@expr1073752043 tok@var3241 .@expr1073752044 next (@expr1073752045 ) ) {
1862: const Scope * scope@var3242 ; scope@var3242 =@expr1073752046 tok@var3241 .@expr1073752047 scope (@expr1073752048 ) ;
1863: if (@expr1073752049 scope@var3242 &&@expr1073752050 !@expr1073752051 scope@var3242 .@expr1073752052 isExecutable (@expr1073752053 ) ) {
1864: continue ; }
1865: if (@expr1073752054 !@expr1073752055 isConstTop (@expr1073752056 tok@var3241 ) ) {
1866: continue ; }
1867: if (@expr1073752057 tok@var3241 .@expr10234 str (@expr10235 ) ==@expr1073752060 "," &&@expr1073752061 Token ::@expr10238 simpleMatch (@expr1073752063 tok@var3241 .@expr1073752064 astTop (@expr1073752065 ) .@expr1073752066 previous (@expr1073752067 ) , "for (" ) ) {
1868: continue ; }
1869:
1870:
1871:
1872: if (@expr1073752068 Token ::@expr10245 Match (@expr1073752070 tok@var3241 , "%oror%|&&" ) ) {
1873: bool warn@var3243 ; warn@var3243 =@expr1073752071 false ;
1874: visitAstNodes (@expr1073752072 tok@var3241 , [@expr1073752073 &@expr1073752074 warn@var3243 ] (@expr1073752075 const Token *@expr10215 child@var3244 ) {
1875: if (@expr1073752077 Token ::@expr10245 Match (@expr1073752079 child@var3244 , "%oror%|&&" ) ) {
1876: return ChildrenToVisit ::@expr1073752080 op1_and_op2 ; }
1877: if (@expr1073752081 child@var3244 .@expr1073752082 isAssignmentOp (@expr1073752083 ) ) {
1878: return ChildrenToVisit ::@expr10260 none ; }
1879: if (@expr1073752085 child@var3244 .@expr1073752086 tokType (@expr1073752087 ) ==@expr1073752088 Token ::@expr1073752089 Type ::@expr1073752090 eIncDecOp ) {
1880: return ChildrenToVisit ::@expr10260 none ; }
1881: if (@expr1073752092 Token ::@expr10245 Match (@expr1073752094 child@var3244 .@expr1073752095 previous (@expr1073752096 ) , "%name% (" ) ) {
1882: return ChildrenToVisit ::@expr10260 none ; }
1883: warn@var3243 =@expr1073752098 true ;
1884: return ChildrenToVisit ::@expr1073752099 done ;
1885: } ) ;
1886: if (@expr1073752100 !@expr1073752101 warn@var3243 ) {
1887: continue ; }
1888: }
1889:
1890: const Token * rtok@var3245 ; rtok@var3245 =@expr1073752102 nextAfterAstRightmostLeaf (@expr1073752103 tok@var3241 ) ;
1891: if (@expr1073752104 !@expr1073752105 Token ::@expr10238 simpleMatch (@expr1073752107 tok@var3241 .@expr10284 astParent (@expr10285 ) , ";" ) &&@expr1073752110 !@expr1073752111 Token ::@expr10238 simpleMatch (@expr1073752113 rtok@var3245 , ";" ) &&@expr1073752114
1892: !@expr1073752115 Token ::@expr10245 Match (@expr1073752117 tok@var3241 .@expr1073752118 previous (@expr1073752119 ) , ";|}|{ %any% ;" ) &&@expr1073752120
1893: !@expr1073752121 (@expr1073752122 mTokenizer@var28 .@expr10299 isCPP (@expr10300 ) &&@expr1073752125 tok@var3241 .@expr1073752126 isCast (@expr1073752127 ) &&@expr1073752128 !@expr1073752129 tok@var3241 .@expr10284 astParent (@expr10285 ) ) &&@expr1073752132
1894: !@expr1073752133 Token ::@expr10238 simpleMatch (@expr1073752135 tok@var3241 .@expr10312 tokAt (@expr1073752137 -2 ) , "for (" ) &&@expr1073752138
1895: !@expr1073752139 Token ::@expr10245 Match (@expr1073752141 tok@var3241 .@expr10312 tokAt (@expr1073752143 -1 ) , "%var% [" ) ) {
1896: continue ; }
1897:
1898: if (@expr1073752144 Token ::@expr10238 simpleMatch (@expr1073752146 rtok@var3245 , "; } )" ) ) {
1899: continue ; }
1900: if (@expr1073752147 !@expr1073752148 isConstStatement (@expr1073752149 tok@var3241 , mTokenizer@var28 .@expr10299 isCPP (@expr10300 ) ) ) {
1901: continue ; }
1902: if (@expr1073752152 isVoidStmt (@expr1073752153 tok@var3241 ) ) {
1903: continue ; }
1904: if (@expr1073752154 mTokenizer@var28 .@expr10299 isCPP (@expr10300 ) &&@expr1073752157 tok@var3241 .@expr10234 str (@expr10235 ) ==@expr1073752160 "&" &&@expr1073752161 !@expr1073752162 (@expr1073752163 tok@var3241 .@expr10340 astOperand1 (@expr10341 ) .@expr10342 valueType (@expr10343 ) &&@expr1073752168 tok@var3241 .@expr10340 astOperand1 (@expr10341 ) .@expr10342 valueType (@expr10343 ) .@expr1073752173 isIntegral (@expr1073752174 ) ) ) {
1905:
1906: continue ; }
1907: bool inconclusive@var3246 ; inconclusive@var3246 =@expr1073752175 Token ::@expr10245 Match (@expr1073752177 tok@var3241 , "%cop%" ) ;
1908: if (@expr1073752178 mSettings@var29 .@expr1073752179 certainty@var3737 .@expr1073752180 isEnabled (@expr1073752181 Certainty ::@expr1073752182 inconclusive@expr1073752031 ) ||@expr1073752183 !@expr1073752184 inconclusive@var3246 ) {
1909: constStatementError (@expr1073752185 tok@var3241 , tok@var3241 .@expr1073752186 isNumber (@expr1073752187 ) ?@expr1073752188 "numeric" :@expr1073752189 "string" , inconclusive@var3246 ) ; }
1910: }
1911: }
1912:
1913: void CheckOther :: constStatementError ( const Token * tok@var3247 , const std :: string & type@var3248 , bool inconclusive@var3249 )
1914: {
1915: const Token * valueTok@var3250 ; valueTok@var3250 =@expr1073752190 tok@var3247 ;
1916: while (@expr1073752191 valueTok@var3250 &&@expr1073752192 valueTok@var3250 .@expr1073752193 isCast (@expr1073752194 ) ) {
1917: valueTok@var3250 =@expr1073752195 valueTok@var3250 .@expr10372 astOperand2 (@expr10373 ) ?@expr1073752198 valueTok@var3250 .@expr10372 astOperand2 (@expr10373 ) :@expr1073752201 valueTok@var3250 .@expr1073752202 astOperand1 (@expr1073752203 ) ; }
1918:
1919: std ::@expr1073752204 string msg@var3251 ;
1920: if (@expr1073752205 Token ::@expr1073752206 simpleMatch (@expr1073752207 tok@var3247 , "==" ) ) {
1921: msg@var3251 =@expr1073752208 "Found suspicious equality comparison. Did you intend to assign a value instead?" ; }
1922: else { if (@expr1073752209 Token ::@expr10386 Match (@expr1073752211 tok@var3247 , ",|!|~|%cop%" ) ) {
1923: msg@var3251 =@expr1073752212 "Found suspicious operator '" +@expr1073752213 tok@var3247 .@expr10390 str (@expr10391 ) +@expr1073752216 "', result is not used." ; }
1924: else { if (@expr1073752217 Token ::@expr10386 Match (@expr1073752219 tok@var3247 , "%var%" ) ) {
1925: msg@var3251 =@expr1073752220 "Unused variable value '" +@expr1073752221 tok@var3247 .@expr10390 str (@expr10391 ) +@expr1073752224 "'" ; }
1926: else { if (@expr1073752225 Token ::@expr10386 Match (@expr1073752227 valueTok@var3250 , "%str%|%num%|%bool%|%char%" ) ) {
1927: std ::@expr1073752228 string typeStr@var3252 (@expr1073752229 "string" ) ;
1928: if (@expr1073752230 valueTok@var3250 .@expr1073752231 isNumber (@expr1073752232 ) ) {
1929: typeStr@var3252 =@expr1073752233 "numeric" ; }
1930: else { if (@expr1073752234 valueTok@var3250 .@expr1073752235 isBoolean (@expr1073752236 ) ) {
1931: typeStr@var3252 =@expr1073752237 "bool" ; }
1932: else { if (@expr1073752238 valueTok@var3250 .@expr1073752239 tokType (@expr1073752240 ) ==@expr1073752241 Token ::@expr1073752242 eChar ) {
1933: typeStr@var3252 =@expr1073752243 "character" ; } } }
1934: msg@var3251 =@expr1073752244 "Redundant code: Found a statement that begins with " +@expr1073752245 typeStr@var3252 +@expr1073752246 " constant." ;
1935: }
1936: else { if (@expr1073752247 !@expr1073752248 tok@var3247 ) {
1937: msg@var3251 =@expr1073752249 "Redundant code: Found a statement that begins with " +@expr1073752250 type@var3248 +@expr1073752251 " constant." ; }
1938: else { if (@expr1073752252 tok@var3247 .@expr1073752253 isCast (@expr1073752254 ) &&@expr1073752255 tok@var3247 .@expr10432 tokType (@expr10433 ) ==@expr10434 Token ::@expr10435 Type ::@expr10436 eExtendedOp ) {
1939: msg@var3251 =@expr1073752261 "Redundant code: Found unused cast " ;
1940: msg@var3251 +=@expr1073752262 valueTok@var3250 ?@expr1073752263 "of expression '" +@expr1073752264 valueTok@var3250 .@expr1073752265 expressionString (@expr1073752266 ) +@expr1073752267 "'." :@expr1073752268 "expression." ;
1941: }
1942: else { if (@expr1073752269 tok@var3247 .@expr10390 str (@expr10391 ) ==@expr1073752272 "?" &&@expr1073752273 tok@var3247 .@expr10432 tokType (@expr10433 ) ==@expr10434 Token ::@expr10435 Type ::@expr10436 eExtendedOp ) {
1943: msg@var3251 =@expr1073752279 "Redundant code: Found unused result of ternary operator." ; }
1944: else { if (@expr1073752280 tok@var3247 .@expr10390 str (@expr10391 ) ==@expr1073752283 "." &&@expr1073752284 tok@var3247 .@expr10432 tokType (@expr10433 ) ==@expr1073752287 Token ::@expr10435 Type ::@expr1073752289 eOther ) {
1945: msg@var3251 =@expr1073752290 "Redundant code: Found unused member access." ; }
1946: else { if (@expr1073752291 tok@var3247 .@expr10390 str (@expr10391 ) ==@expr1073752294 "[" &&@expr1073752295 tok@var3247 .@expr10432 tokType (@expr10433 ) ==@expr10434 Token ::@expr10435 Type ::@expr10436 eExtendedOp ) {
1947: msg@var3251 =@expr1073752301 "Redundant code: Found unused array access." ; }
1948: else {
1949: reportError (@expr1073752302 tok@var3247 , Severity ::@expr1073752303 debug , "debug" , "constStatementError not handled." ) ;
1950: return ;
1951: } } } } } } } } }
1952: reportError (@expr1073752304 tok@var3247 , Severity ::@expr1073752305 warning , "constStatement" , msg@var3251 , CWE398@var2876 , inconclusive@var3249 ?@expr1073752306 Certainty ::@expr1073752307 inconclusive :@expr1073752308 Certainty ::@expr1073752309 normal ) ;
1953: }
1954:
|
1957:
1958: void CheckOther :: checkZeroDivision ( )
1959: {
1960: for (@expr1073752310 const Token *@expr1073752311 tok@var3253 =@expr1073752312 mTokenizer@var28 .@expr1073752313 tokens (@expr1073752314 ) ; tok@var3253 ; tok@var3253 =@expr1073752315 tok@var3253 .@expr1073752316 next (@expr1073752317 ) ) {
1961: if (@expr1073752318 !@expr1073752319 tok@var3253 .@expr10496 astOperand2 (@expr10497 ) ||@expr1073752322 !@expr1073752323 tok@var3253 .@expr1073752324 astOperand1 (@expr1073752325 ) ) {
1962: continue ; }
1963: if (@expr1073752326 tok@var3253 .@expr10503 str (@expr10504 ) !=@expr1073752329 "%" &&@expr1073752330 tok@var3253 .@expr10503 str (@expr10504 ) !=@expr1073752333 "/" &&@expr1073752334 tok@var3253 .@expr10503 str (@expr10504 ) !=@expr1073752337 "%=" &&@expr1073752338 tok@var3253 .@expr10503 str (@expr10504 ) !=@expr1073752341 "/=" ) {
1964: continue ; }
1965: if (@expr1073752342 !@expr1073752343 tok@var3253 .@expr10520 valueType (@expr10521 ) ||@expr1073752346 !@expr1073752347 tok@var3253 .@expr10520 valueType (@expr10521 ) .@expr1073752350 isIntegral (@expr1073752351 ) ) {
1966: continue ; }
1967:
1968:
1969: const ValueFlow ::@expr1073752352 Value * value@var3254 ; value@var3254 =@expr1073752353 tok@var3253 .@expr10496 astOperand2 (@expr10497 ) .@expr1073752356 getValue (@expr1073752357 0LL ) ;
1970: if (@expr1073752358 value@var3254 &&@expr1073752359 mSettings@var29 .@expr1073752360 isEnabled (@expr1073752361 value@var3254 , false ) ) {
1971: zerodivError (@expr1073752362 tok@var3253 , value@var3254 ) ; }
1972: }
1973: }
1974:
1975: void CheckOther :: zerodivError ( const Token * tok@var3255 , const ValueFlow :: Value * value@var3256 )
1976: {
1977: if (@expr1073752363 !@expr1073752364 tok@var3255 &&@expr1073752365 !@expr1073752366 value@var3256 ) {
1978: reportError (@expr1073752367 tok@var3255 , Severity ::@expr10544 error , "zerodiv" , "Division by zero." , CWE369@var2875 , Certainty ::@expr10545 normal ) ;
1979: reportError (@expr1073752370 tok@var3255 , Severity ::@expr10544 error , "zerodivcond" , ValueFlow ::@expr10548 eitherTheConditionIsRedundant (@expr1073752373 nullptr ) +@expr1073752374 " or there is division by zero." , CWE369@var2875 , Certainty ::@expr10545 normal ) ;
1980: return ;
1981: }
1982:
1983: const std ::@expr1073752376 list < std ::@expr10553 pair < const Token *@expr1073752378 , std ::@expr10553 string > > errorPath@var3257 =@expr1073752380 getErrorPath (@expr1073752381 tok@var3255 , value@var3256 , "Division by zero" ) ;
1984:
1985: std ::@expr1073752382 ostringstream errmsg@var3258 ;
1986: if (@expr1073752383 value@var3256 .@expr10560 condition@var3259 ) {
1987: const int line@var3260 =@expr1073752385 tok@var3255 ?@expr1073752386 tok@var3255 .@expr1073752387 linenr (@expr1073752388 ) :@expr1073752389 0 ;
1988: errmsg@var3258 <<@expr1073752390 ValueFlow ::@expr10548 eitherTheConditionIsRedundant (@expr1073752392 value@var3256 .@expr10560 condition@var3259 )
1989: <<@expr1073752394 " or there is division by zero at line " <<@expr1073752395 line@var3260 <<@expr1073752396 "." ;
1990: } else {
1991: errmsg@var3258 <<@expr1073752397 "Division by zero." ; }
1992:
1993: reportError (@expr1073752398 errorPath@var3257 ,
1994: value@var3256 .@expr1073752399 errorSeverity (@expr1073752400 ) ?@expr1073752401 Severity ::@expr10544 error :@expr1073752403 Severity ::@expr1073752404 warning ,
1995: value@var3256 .@expr10560 condition@var3259 ?@expr1073752406 "zerodivcond" :@expr1073752407 "zerodiv" ,
1996: errmsg@var3258 .@expr1073752408 str (@expr1073752409 ) , CWE369@var2875 , value@var3256 .@expr1073752410 isInconclusive (@expr1073752411 ) ?@expr1073752412 Certainty ::@expr1073752413 inconclusive :@expr1073752414 Certainty ::@expr10545 normal ) ;
1997: }
1998:
|
2003:
2004: void CheckOther :: checkNanInArithmeticExpression ( )
2005: {
2006: if (@expr1073752416 !@expr1073752417 mSettings@var29 .@expr1073752418 severity@var3736 .@expr1073752419 isEnabled (@expr1073752420 Severity ::@expr1073752421 style ) ) {
2007: return ; }
2008: for (@expr1073752422 const Token *@expr1073752423 tok@var3261 =@expr1073752424 mTokenizer@var28 .@expr1073752425 tokens (@expr1073752426 ) ; tok@var3261 ; tok@var3261 =@expr1073752427 tok@var3261 .@expr1073752428 next (@expr1073752429 ) ) {
2009: if (@expr1073752430 tok@var3261 .@expr1073752431 str (@expr1073752432 ) !=@expr1073752433 "/" ) {
2010: continue ; }
2011: if (@expr1073752434 !@expr1073752435 Token ::@expr1073752436 Match (@expr1073752437 tok@var3261 .@expr1073752438 astParent (@expr1073752439 ) , "[+-]" ) ) {
2012: continue ; }
2013: if (@expr1073752440 Token ::@expr1073752441 simpleMatch (@expr1073752442 tok@var3261 .@expr1073752443 astOperand2 (@expr1073752444 ) , "0.0" ) ) {
2014: nanInArithmeticExpressionError (@expr1073752445 tok@var3261 ) ; }
2015: }
2016: }
2017:
2018: void CheckOther :: nanInArithmeticExpressionError ( const Token * tok@var3262 )
2019: {
2020: reportError (@expr1073752446 tok@var3262 , Severity ::@expr1073752447 style , "nanInArithmeticExpression" ,
2021: "Using NaN/Inf in a computation.\nUsing NaN/Inf in a computation. Although nothing bad really happens, it is suspicious."
2022:
2023: , CWE369@var2875 , Certainty ::@expr1073752448 normal ) ;
2024: }
2025:
|
2028:
2029: void CheckOther :: checkMisusedScopedObject ( )
2030: {
2031:
2032: if (@expr1073752449 mTokenizer@var28 .@expr1073752450 isC (@expr1073752451 ) ) {
2033: return ; }
2034:
2035: if (@expr1073752452 !@expr1073752453 mSettings@var29 .@expr1073752454 severity@var3736 .@expr1073752455 isEnabled (@expr1073752456 Severity ::@expr1073752457 style ) ) {
2036: return ; }
2037:
2038: const SymbolDatabase * const symbolDatabase@var3263 ; symbolDatabase@var3263 =@expr1073752458 mTokenizer@var28 .@expr1073752459 getSymbolDatabase (@expr1073752460 ) ;
2039: for (@expr1073752461 const Scope *@expr10638 scope@var3264 :@expr1073752463 symbolDatabase@var3263 .@expr1073752464 functionScopes@var3265 ) {
2040: for (@expr1073752465 const Token *@expr10638 tok@var3266 =@expr1073752467 scope@var3264 .@expr1073752468 bodyStart@var3267 ; tok@var3266 &&@expr1073752469 tok@var3266 !=@expr1073752470 scope@var3264 .@expr1073752471 bodyEnd@var3268 ; tok@var3266 =@expr1073752472 tok@var3266 .@expr10649 next (@expr10650 ) ) {
2041: if (@expr1073752475 (@expr1073752476 tok@var3266 .@expr10649 next (@expr10650 ) .@expr1073752479 type (@expr1073752480 ) ||@expr1073752481 (@expr1073752482 tok@var3266 .@expr10649 next (@expr10650 ) .@expr10661 function (@expr10662 ) &&@expr1073752487 tok@var3266 .@expr10649 next (@expr10650 ) .@expr10661 function (@expr10662 ) .@expr10668 isConstructor (@expr10669 ) ) )
2042: &&@expr1073752494 Token ::@expr10671 Match (@expr1073752496 tok@var3266 , "[;{}] %name% (" )
2043: &&@expr1073752497 Token ::@expr10671 Match (@expr1073752499 tok@var3266 .@expr1073752500 linkAt (@expr1073752501 2 ) , ") ; !!}" )
2044: &&@expr1073752502 (@expr1073752503 !@expr1073752504 tok@var3266 .@expr10649 next (@expr10650 ) .@expr10661 function (@expr10662 ) ||@expr1073752509
2045: tok@var3266 .@expr10649 next (@expr10650 ) .@expr10661 function (@expr10662 ) .@expr10668 isConstructor (@expr10669 ) ) ) {
2046: tok@var3266 =@expr1073752516 tok@var3266 .@expr10649 next (@expr10650 ) ;
2047: misusedScopeObjectError (@expr1073752519 tok@var3266 , tok@var3266 .@expr1073752520 str (@expr1073752521 ) ) ;
2048: tok@var3266 =@expr1073752522 tok@var3266 .@expr10649 next (@expr10650 ) ;
2049: }
2050: }
2051: }
2052: }
2053:
2054: void CheckOther :: misusedScopeObjectError ( const Token * tok@var3269 , const std :: string & varname@var3270 )
2055: {
2056: reportError (@expr1073752525 tok@var3269 , Severity ::@expr1073752526 style ,
2057: "unusedScopedObject" ,
2058: "$symbol:" +@expr1073752527 varname@var3270 +@expr1073752528 "\nInstance of '$symbol' object is destroyed immediately."
2059: , CWE563@var2880 , Certainty ::@expr1073752529 normal ) ;
2060: }
2061:
2062: static const Token * getSingleExpressionInBlock ( const Token * tok@var3271 )
2063: {
2064: if (@expr1073752530 !@expr1073752531 tok@var3271 ) {
2065: return nullptr ; }
2066: const Token * top@var3272 ; top@var3272 =@expr1073752532 tok@var3271 .@expr1073752533 astTop (@expr1073752534 ) ;
2067: if (@expr1073752535 !@expr1073752536 top@var3272 ) {
2068: return nullptr ; }
2069: const Token * nextExpression@var3273 ; nextExpression@var3273 =@expr1073752537 nextAfterAstRightmostLeaf (@expr1073752538 top@var3272 ) ;
2070: if (@expr1073752539 !@expr1073752540 Token ::@expr1073752541 simpleMatch (@expr1073752542 nextExpression@var3273 , "; }" ) ) {
2071: return nullptr ; }
2072: return top@var3272 ;
2073: }
2074:
|
2078:
2079: void CheckOther :: checkDuplicateBranch ( )
2080: {
2081:
|
2088:
2089: if (@expr1073752544 !@expr1073752545 mSettings@var29 .@expr1073752546 severity@var3736 .@expr1073752547 isEnabled (@expr1073752548 Severity ::@expr1073752549 style ) ||@expr1073752550 !@expr1073752551 mSettings@var29 .@expr1073752552 certainty@var3737 .@expr1073752553 isEnabled (@expr1073752554 Certainty ::@expr1073752555 inconclusive@expr1073752543 ) ) {
2090: return ; }
2091:
2092: const SymbolDatabase * symbolDatabase@var3274 ; symbolDatabase@var3274 =@expr1073752556 mTokenizer@var28 .@expr1073752557 getSymbolDatabase (@expr1073752558 ) ;
2093:
2094: for (@expr1073752559 const Scope &@expr1073752560 scope@var3275 :@expr1073752561 symbolDatabase@var3274 .@expr1073752562 scopeList@var3276 ) {
2095: if (@expr1073752563 scope@var3275 .@expr1073752564 type@var3277 !=@expr1073752565 Scope ::@expr1073752566 eIf ) {
2096: continue ; }
2097:
2098:
2099: if (@expr1073752567 Token ::@expr1073752568 simpleMatch (@expr1073752569 scope@var3275 .@expr10746 bodyEnd@var3278 , "} else {" ) ) {
2100:
2101:
2102: bool macro@var3279 ; macro@var3279 =@expr1073752571 false ;
2103: for (@expr1073752572 const Token *@expr10749 tok@var3280 =@expr1073752574 scope@var3275 .@expr10751 bodyStart@var3281 ; tok@var3280 !=@expr1073752576 scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10754 linkAt (@expr10755 2 ) ; tok@var3280 =@expr1073752580 tok@var3280 .@expr1073752581 next (@expr1073752582 ) ) {
2104: if (@expr1073752583 tok@var3280 .@expr1073752584 isExpandedMacro (@expr1073752585 ) ) {
2105: macro@var3279 =@expr1073752586 true ;
2106: break ;
2107: }
2108: }
2109: if (@expr1073752587 macro@var3279 ) {
2110: continue ; }
2111:
2112:
2113: const std ::@expr10764 string branch1@var3282 =@expr1073752589 scope@var3275 .@expr10751 bodyStart@var3281 .@expr10767 next (@expr10768 ) .@expr1073752593 stringifyList (@expr1073752594 scope@var3275 .@expr10746 bodyEnd@var3278 ) ;
2114:
2115: if (@expr1073752596 branch1@var3282 .@expr1073752597 empty (@expr1073752598 ) ) {
2116: continue ; }
2117:
2118:
2119: const std ::@expr10764 string branch2@var3283 =@expr1073752600 scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10778 tokAt (@expr10779 3 ) .@expr1073752604 stringifyList (@expr1073752605 scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10754 linkAt (@expr10755 2 ) ) ;
2120:
2121: std ::@expr1073752609 list < std ::@expr10764 pair < const Token *@expr10749 , std ::@expr10764 string > > errorPath@var3284 ;
2122:
2123: if (@expr1073752613 branch1@var3282 ==@expr1073752614 branch2@var3283 ) {
2124: duplicateBranchError (@expr10791 scope@var3275 .@expr10792 classDef@var3285 , scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10794 next (@expr10795 ) , errorPath@var3284 ) ;
2125: continue ;
2126: }
2127:
2128:
2129: const Token * branchTop1@var3286 ; branchTop1@var3286 =@expr1073752620 getSingleExpressionInBlock (@expr1073752621 scope@var3275 .@expr10751 bodyStart@var3281 .@expr10767 next (@expr10768 ) ) ;
2130: const Token * branchTop2@var3287 ; branchTop2@var3287 =@expr1073752625 getSingleExpressionInBlock (@expr1073752626 scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10778 tokAt (@expr10779 3 ) ) ;
2131: if (@expr1073752630 !@expr1073752631 branchTop1@var3286 ||@expr1073752632 !@expr1073752633 branchTop2@var3287 ) {
2132: continue ; }
2133: if (@expr1073752634 branchTop1@var3286 .@expr1073752635 str (@expr1073752636 ) !=@expr1073752637 branchTop2@var3287 .@expr1073752638 str (@expr1073752639 ) ) {
2134: continue ; }
2135: if (@expr1073752640 isSameExpression (@expr1073752641 mTokenizer@var28 .@expr10818 isCPP (@expr10819 ) , false , branchTop1@var3286 .@expr1073752644 astOperand1 (@expr1073752645 ) , branchTop2@var3287 .@expr1073752646 astOperand1 (@expr1073752647 ) , mSettings@var29 .@expr10824 library@var3738 , true , true , &@expr10825 errorPath@var3284 ) &&@expr1073752650
2136: isSameExpression (@expr1073752651 mTokenizer@var28 .@expr10818 isCPP (@expr10819 ) , false , branchTop1@var3286 .@expr1073752654 astOperand2 (@expr1073752655 ) , branchTop2@var3287 .@expr1073752656 astOperand2 (@expr1073752657 ) , mSettings@var29 .@expr10824 library@var3738 , true , true , &@expr10825 errorPath@var3284 ) ) {
2137: duplicateBranchError (@expr10791 scope@var3275 .@expr10792 classDef@var3285 , scope@var3275 .@expr10746 bodyEnd@var3278 .@expr10794 next (@expr10795 ) , errorPath@var3284 ) ; }
2138: }
2139: }
2140: }
2141:
2142: void CheckOther :: duplicateBranchError ( const Token * tok1@var3288 , const Token * tok2@var3289 , std :: list < std :: pair < const Token * , std :: string > > errors@var3290 )
2143: {
2144: errors@var3290 .@expr10842 emplace_back (@expr1073752667 tok2@var3289 , "" ) ;
2145: errors@var3290 .@expr10842 emplace_back (@expr1073752669 tok1@var3288 , "" ) ;
2146:
2147: reportError (@expr1073752670 errors@var3290 , Severity ::@expr1073752671 style , "duplicateBranch" , "Found duplicate branches for 'if' and 'else'.\nFinding the same code in an 'if' and related 'else' branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
2148:
2149:
2150: , CWE398@var2876 , Certainty ::@expr1073752672 inconclusive@expr1073752665 ) ;
2151: }
2152:
|
2158:
2159: void CheckOther :: checkInvalidFree ( )
2160: {
2161: std ::@expr1073752674 map < int , bool > inconclusive@var3291 ;
2162: std ::@expr1073752675 map < int , std ::@expr1073752676 string > allocation@var3292 ;
2163:
2164: const bool printInconclusive@var3293 =@expr1073752677 mSettings@var29 .@expr1073752678 certainty@var3737 .@expr1073752679 isEnabled (@expr1073752680 Certainty ::@expr1073752681 inconclusive@expr1073752673 ) ;
2165: const SymbolDatabase * symbolDatabase@var3294 ; symbolDatabase@var3294 =@expr1073752682 mTokenizer@var28 .@expr1073752683 getSymbolDatabase (@expr1073752684 ) ;
2166: for (@expr1073752685 const Scope *@expr10862 scope@var3295 :@expr1073752687 symbolDatabase@var3294 .@expr1073752688 functionScopes@var3296 ) {
2167: for (@expr1073752689 const Token *@expr10862 tok@var3297 =@expr1073752691 scope@var3295 .@expr1073752692 bodyStart@var3298 .@expr1073752693 next (@expr1073752694 ) ; tok@var3297 !=@expr1073752695 scope@var3295 .@expr1073752696 bodyEnd@var3299 ; tok@var3297 =@expr1073752697 tok@var3297 .@expr10874 next (@expr10875 ) ) {
2168:
2169:
2170: if (@expr1073752700 Token ::@expr10877 Match (@expr1073752702 tok@var3297 , "%var% = malloc|g_malloc|new" ) ) {
2171: allocation@var3292 .@expr1073752703 insert (@expr1073752704 std ::@expr10881 make_pair (@expr1073752706 tok@var3297 .@expr10883 varId (@expr10884 ) , tok@var3297 .@expr10885 strAt (@expr1073752710 2 ) ) ) ;
2172: inconclusive@var3291 .@expr1073752711 insert (@expr1073752712 std ::@expr10881 make_pair (@expr1073752714 tok@var3297 .@expr10883 varId (@expr10884 ) , false ) ) ;
2173: }
2174:
|
2177:
2178: else { if (@expr1073752717 Token ::@expr10877 Match (@expr1073752719 tok@var3297 , "%var% = %name% +|-" ) &&@expr1073752720
2179: tok@var3297 .@expr10883 varId (@expr10884 ) ==@expr1073752723 tok@var3297 .@expr10900 tokAt (@expr1073752725 2 ) .@expr1073752726 varId (@expr1073752727 ) &&@expr1073752728
2180: allocation@var3292 .@expr1073752729 find (@expr1073752730 tok@var3297 .@expr10883 varId (@expr10884 ) ) !=@expr1073752733 allocation@var3292 .@expr1073752734 end (@expr1073752735 ) ) {
2181: if (@expr1073752736 printInconclusive@var3293 ) {
2182: inconclusive@var3291 [@expr1073752737 tok@var3297 .@expr10883 varId (@expr10884 ) ] =@expr1073752740 true ; }
2183: else {
2184: allocation@var3292 .@expr10917 erase (@expr10918 tok@var3297 .@expr10883 varId (@expr10884 ) ) ;
2185: inconclusive@var3291 .@expr10921 erase (@expr10922 tok@var3297 .@expr10883 varId (@expr10884 ) ) ;
2186: }
2187: }
2188:
2189:
2190:
2191: else { if (@expr1073752749 Token ::@expr10877 Match (@expr1073752751 tok@var3297 , "%var% =" ) ) {
2192: allocation@var3292 .@expr10917 erase (@expr10918 tok@var3297 .@expr10883 varId (@expr10884 ) ) ;
2193: inconclusive@var3291 .@expr10921 erase (@expr10922 tok@var3297 .@expr10883 varId (@expr10884 ) ) ;
2194: }
2195:
2196:
2197:
2198: else { if (@expr1073752760 Token ::@expr10877 Match (@expr1073752762 tok@var3297 , "free|g_free|delete ( %any% +|-" ) ||@expr1073752763
2199: Token ::@expr10877 Match (@expr1073752765 tok@var3297 , "delete [ ] ( %any% +|-" ) ||@expr1073752766
2200: Token ::@expr10877 Match (@expr1073752768 tok@var3297 , "delete %any% +|- %any%" ) ) {
2201:
2202: const int varIndex@var3300 =@expr1073752769 tok@var3297 .@expr10885 strAt (@expr1073752771 1 ) ==@expr1073752772 "(" ?@expr1073752773 2 :@expr1073752774
2203: tok@var3297 .@expr10885 strAt (@expr1073752776 3 ) ==@expr1073752777 "(" ?@expr1073752778 4 :@expr1073752779 1 ;
2204: const int var1@var3301 =@expr1073752780 tok@var3297 .@expr10900 tokAt (@expr1073752782 varIndex@var3300 ) .@expr1073752783 varId (@expr1073752784 ) ;
2205: const int var2@var3302 =@expr1073752785 tok@var3297 .@expr10900 tokAt (@expr1073752787 varIndex@var3300 +@expr1073752788 2 ) .@expr1073752789 varId (@expr1073752790 ) ;
2206: const std ::@expr10967 map < int , bool > ::@expr1073752792 const_iterator alloc1@var3303 =@expr1073752793 inconclusive@var3291 .@expr10970 find (@expr1073752795 var1@var3301 ) ;
2207: const std ::@expr10967 map < int , bool > ::@expr1073752797 const_iterator alloc2@var3304 =@expr1073752798 inconclusive@var3291 .@expr10970 find (@expr1073752800 var2@var3302 ) ;
2208: if (@expr1073752801 alloc1@var3303 !=@expr1073752802 inconclusive@var3291 .@expr10979 end (@expr10980 ) ) {
2209: invalidFreeError (@expr1073752805 tok@var3297 , allocation@var3292 [@expr1073752806 var1@var3301 ] , alloc1@var3303 .@expr1073752807 second@var3305 ) ;
2210: } else { if (@expr1073752808 alloc2@var3304 !=@expr1073752809 inconclusive@var3291 .@expr10979 end (@expr10980 ) ) {
2211: invalidFreeError (@expr1073752812 tok@var3297 , allocation@var3292 [@expr1073752813 var2@var3302 ] , alloc2@var3304 .@expr1073752814 second@var3306 ) ;
2212: } }
2213: }
2214:
|
2217:
2218: else { if (@expr1073752815 Token ::@expr10877 Match (@expr1073752817 tok@var3297 , "%name% (" ) &&@expr1073752818 !@expr1073752819 mSettings@var29 .@expr1073752820 library@var3738 .@expr1073752821 isFunctionConst (@expr1073752822 tok@var3297 .@expr1073752823 str (@expr1073752824 ) , true ) ) {
2219: const Token * tok2@var3307 ; tok2@var3307 =@expr1073752825 Token ::@expr11002 findmatch (@expr1073752827 tok@var3297 .@expr10874 next (@expr10875 ) , "%var%" , tok@var3297 .@expr11006 linkAt (@expr11007 1 ) ) ;
2220: while (@expr1073752832 tok2@var3307 !=@expr1073752833 nullptr ) {
2221: allocation@var3292 .@expr10917 erase (@expr10918 tok@var3297 .@expr10883 varId (@expr10884 ) ) ;
2222: inconclusive@var3291 .@expr10921 erase (@expr1073752839 tok2@var3307 .@expr1073752840 varId (@expr1073752841 ) ) ;
2223: tok2@var3307 =@expr1073752842 Token ::@expr11002 findmatch (@expr1073752844 tok2@var3307 .@expr1073752845 next (@expr1073752846 ) , "%var%" , tok@var3297 .@expr11006 linkAt (@expr11007 1 ) ) ;
2224: }
2225: } } } } }
2226: }
2227: }
2228: }
2229:
2230: void CheckOther :: invalidFreeError ( const Token * tok@var3308 , const std :: string & allocation@var3309 , bool inconclusive@var3310 )
2231: {
2232: std ::@expr1073752849 string alloc@var3311 ; alloc@var3311 =@expr1073752850 allocation@var3309 ;
2233: if (@expr1073752851 alloc@var3311 !=@expr1073752852 "new" ) {
2234: alloc@var3311 +=@expr1073752853 "()" ; }
2235: std ::@expr1073752854 string deallocated@var3312 ; deallocated@var3312 =@expr1073752855 (@expr1073752856 alloc@var3311 ==@expr1073752857 "new" ) ?@expr1073752858 "deleted" :@expr1073752859 "freed" ;
2236: reportError (@expr1073752860 tok@var3308 , Severity ::@expr1073752861 error , "invalidFree" , "Mismatching address is " +@expr1073752862 deallocated@var3312 +@expr1073752863 ". The address you get from " +@expr1073752864 alloc@var3311 +@expr1073752865 " must be " +@expr1073752866 deallocated@var3312 +@expr1073752867 " without offset." , CWE (@expr1073752868 0U ) , inconclusive@var3310 ?@expr1073752869 Certainty ::@expr1073752870 inconclusive :@expr1073752871 Certainty ::@expr1073752872 normal ) ;
2237: }
2238:
|
2245:
2246: namespace {
2247: bool notconst ( const Function * func@var3313 )
2248: {
2249: return !@expr1073752873 func@var3313 .@expr1073752874 isConst (@expr1073752875 ) ;
2250: }
2251:
2252: void getConstFunctions ( const SymbolDatabase * symbolDatabase@var3314 , std :: list < const Function * > & constFunctions@var3315 )
2253: {
2254: for (@expr1073752876 const Scope &@expr11053 scope@var3316 :@expr1073752878 symbolDatabase@var3314 .@expr1073752879 scopeList@var3317 ) {
2255:
2256:
2257:
2258: std ::@expr1073752880 map < std ::@expr11057 string , std ::@expr11057 list < const Function *@expr11059 > > functionsByName@var3318 ;
2259: for (@expr1073752884 const Function &@expr11053 func@var3319 :@expr1073752886 scope@var3316 .@expr1073752887 functionList@var3320 ) {
2260: functionsByName@var3318 [@expr1073752888 func@var3319 .@expr1073752889 tokenDef@var3321 .@expr1073752890 str (@expr1073752891 ) ] .@expr1073752892 push_back (@expr1073752893 &@expr1073752894 func@var3319 ) ;
2261: }
2262: for (@expr1073752895 std ::@expr11057 pair < const std ::@expr11057 string , std ::@expr11057 list < const Function *@expr11059 > > &@expr11053 it@var3322 :@expr1073752901 functionsByName@var3318 ) {
2263: const std ::@expr1073752902 list < const Function *@expr11059 > ::@expr1073752904 const_iterator nc@var3323 =@expr1073752905 std ::@expr1073752906 find_if (@expr1073752907 it@var3322 .@expr11084 second@var3324 .@expr1073752909 begin (@expr1073752910 ) , it@var3322 .@expr11084 second@var3324 .@expr11088 end (@expr11089 ) , notconst ) ;
2264: if (@expr1073752914 nc@var3323 ==@expr1073752915 it@var3322 .@expr11084 second@var3324 .@expr11088 end (@expr11089 ) ) {
2265:
2266: constFunctions@var3315 .@expr1073752919 splice (@expr1073752920 constFunctions@var3315 .@expr1073752921 end (@expr1073752922 ) , it@var3322 .@expr11084 second@var3324 ) ;
2267: }
2268: }
2269: }
2270: }
2271: }
2272:
2273: void CheckOther :: checkDuplicateExpression ( )
2274: {
2275: const bool styleEnabled@var3325 =@expr1073752925 mSettings@var29 .@expr11102 severity@var3736 .@expr11103 isEnabled (@expr1073752928 Severity ::@expr1073752929 style ) ;
2276: const bool warningEnabled@var3326 =@expr1073752930 mSettings@var29 .@expr11102 severity@var3736 .@expr11103 isEnabled (@expr1073752933 Severity ::@expr1073752934 warning ) ;
2277: if (@expr1073752935 !@expr1073752936 styleEnabled@var3325 &&@expr1073752937 !@expr1073752938 warningEnabled@var3326 ) {
2278: return ; }
2279:
2280:
2281: const SymbolDatabase * symbolDatabase@var3327 ; symbolDatabase@var3327 =@expr1073752939 mTokenizer@var28 .@expr1073752940 getSymbolDatabase (@expr1073752941 ) ;
2282:
2283: std ::@expr1073752942 list < const Function *@expr11119 > constFunctions@var3328 ;
2284: getConstFunctions (@expr1073752944 symbolDatabase@var3327 , constFunctions@var3328 ) ;
2285:
2286: for (@expr1073752945 const Scope *@expr11119 scope@var3329 :@expr1073752947 symbolDatabase@var3327 .@expr1073752948 functionScopes@var3330 ) {
2287: for (@expr1073752949 const Token *@expr11119 tok@var3331 =@expr1073752951 scope@var3329 .@expr1073752952 bodyStart@var3332 ; tok@var3331 !=@expr1073752953 scope@var3329 .@expr1073752954 bodyEnd@var3333 ; tok@var3331 =@expr1073752955 tok@var3331 .@expr11132 next (@expr11133 ) ) {
2288: if (@expr1073752958 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr11137 "=" &&@expr1073752962 Token ::@expr11139 Match (@expr1073752964 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , "%var%" ) ) {
2289: const Token * endStatement@var3334 ; endStatement@var3334 =@expr1073752967 Token ::@expr11144 findsimplematch (@expr1073752969 tok@var3331 , ";" ) ;
2290: if (@expr1073752970 Token ::@expr11139 Match (@expr1073752972 endStatement@var3334 , "; %type% %var% ;" ) ) {
2291: endStatement@var3334 =@expr1073752973 endStatement@var3334 .@expr11150 tokAt (@expr1073752975 4 ) ;
2292: }
2293: if (@expr1073752976 Token ::@expr11139 Match (@expr1073752978 endStatement@var3334 , "%var% %assign%" ) ) {
2294: const Token * nextAssign@var3335 ; nextAssign@var3335 =@expr1073752979 endStatement@var3334 .@expr11150 tokAt (@expr1073752981 1 ) ;
2295: const Token * var1@var3336 ; var1@var3336 =@expr1073752982 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ;
2296: const Token * var2@var3337 ; var2@var3337 =@expr1073752985 nextAssign@var3335 .@expr1073752986 astOperand1 (@expr1073752987 ) ;
2297: if (@expr1073752988 var1@var3336 &&@expr1073752989 var2@var3337 &&@expr1073752990
2298: Token ::@expr11139 Match (@expr1073752992 var1@var3336 .@expr1073752993 previous (@expr1073752994 ) , ";|{|} %var%" ) &&@expr1073752995
2299: Token ::@expr11139 Match (@expr1073752997 var2@var3337 .@expr1073752998 previous (@expr1073752999 ) , ";|{|} %var%" ) &&@expr1073753000
2300: var2@var3337 .@expr11177 valueType (@expr11178 ) &&@expr1073753003 var1@var3336 .@expr11180 valueType (@expr11181 ) &&@expr1073753006
2301: var2@var3337 .@expr11177 valueType (@expr11178 ) .@expr1073753009 originalTypeName@var3767 ==@expr1073753010 var1@var3336 .@expr11180 valueType (@expr11181 ) .@expr1073753013 originalTypeName@var3767 &&@expr1073753014
2302: var2@var3337 .@expr11177 valueType (@expr11178 ) .@expr1073753017 pointer@var3766 ==@expr1073753018 var1@var3336 .@expr11180 valueType (@expr11181 ) .@expr1073753021 pointer@var3766 &&@expr1073753022
2303: var2@var3337 .@expr11177 valueType (@expr11178 ) .@expr1073753025 constness@var3765 ==@expr1073753026 var1@var3336 .@expr11180 valueType (@expr11181 ) .@expr1073753029 constness@var3765 &&@expr1073753030
2304: var2@var3337 .@expr11207 varId (@expr11208 ) !=@expr1073753033 var1@var3336 .@expr11210 varId (@expr11211 ) &&@expr1073753036 (@expr1073753037
2305: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753040 isArithmeticalOp (@expr1073753041 ) ||@expr1073753042
2306: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753045 str (@expr1073753046 ) ==@expr1073753047 "." ||@expr1073753048
2307: Token ::@expr11139 Match (@expr1073753050 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753053 previous (@expr1073753054 ) , "%name% (" )
2308: ) &&@expr1073753055
2309: tok@var3331 .@expr11132 next (@expr11133 ) .@expr1073753058 tokType (@expr1073753059 ) !=@expr1073753060 Token ::@expr1073753061 eType &&@expr1073753062
2310: isSameExpression (@expr1073753063 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , true , tok@var3331 .@expr11132 next (@expr11133 ) , nextAssign@var3335 .@expr1073753068 next (@expr1073753069 ) , mSettings@var29 .@expr11246 library@var3738 , true , false ) &&@expr1073753071
2311: isSameExpression (@expr1073753072 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , true , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , nextAssign@var3335 .@expr11253 astOperand2 (@expr11254 ) , mSettings@var29 .@expr11246 library@var3738 , true , false ) &&@expr1073753080
2312: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753083 expressionString (@expr1073753084 ) ==@expr1073753085 nextAssign@var3335 .@expr11253 astOperand2 (@expr11254 ) .@expr1073753088 expressionString (@expr1073753089 ) ) {
2313: bool differentDomain@var3338 ; differentDomain@var3338 =@expr1073753090 false ;
2314: const Scope * varScope@var3339 ; varScope@var3339 =@expr1073753091 var1@var3336 .@expr11268 scope (@expr11269 ) ?@expr1073753094 var1@var3336 .@expr11268 scope (@expr11269 ) :@expr1073753097 scope@var3329 ;
2315: for (@expr1073753098 const Token *@expr11119 assignTok@var3340 =@expr1073753100 Token ::@expr11144 findsimplematch (@expr1073753102 var2@var3337 , ";" ) ; assignTok@var3340 &&@expr1073753103 assignTok@var3340 !=@expr1073753104 varScope@var3339 .@expr1073753105 bodyEnd@var3341 ; assignTok@var3340 =@expr1073753106 assignTok@var3340 .@expr1073753107 next (@expr1073753108 ) ) {
2316: if (@expr1073753109 !@expr1073753110 Token ::@expr11139 Match (@expr1073753112 assignTok@var3340 , "%assign%|%comp%" ) ) {
2317: continue ; }
2318: if (@expr1073753113 !@expr1073753114 assignTok@var3340 .@expr11291 astOperand1 (@expr11292 ) ) {
2319: continue ; }
2320: if (@expr1073753117 !@expr1073753118 assignTok@var3340 .@expr11295 astOperand2 (@expr11296 ) ) {
2321: continue ; }
2322:
2323: if (@expr1073753121 assignTok@var3340 .@expr11291 astOperand1 (@expr11292 ) .@expr11300 varId (@expr11301 ) !=@expr1073753126 var1@var3336 .@expr11210 varId (@expr11211 ) &&@expr1073753129
2324: assignTok@var3340 .@expr11291 astOperand1 (@expr11292 ) .@expr11300 varId (@expr11301 ) !=@expr1073753134 var2@var3337 .@expr11207 varId (@expr11208 ) &&@expr1073753137
2325: !@expr1073753138 isSameExpression (@expr1073753139 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2326: true ,
2327: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ,
2328: assignTok@var3340 .@expr11291 astOperand1 (@expr11292 ) ,
2329: mSettings@var29 .@expr11246 library@var3738 ,
2330: true ,
2331: true ) ) {
2332: continue ; }
2333: if (@expr1073753147 assignTok@var3340 .@expr11295 astOperand2 (@expr11296 ) .@expr11326 varId (@expr11327 ) !=@expr1073753152 var1@var3336 .@expr11210 varId (@expr11211 ) &&@expr1073753155
2334: assignTok@var3340 .@expr11295 astOperand2 (@expr11296 ) .@expr11326 varId (@expr11327 ) !=@expr1073753160 var2@var3337 .@expr11207 varId (@expr11208 ) &&@expr1073753163
2335: !@expr1073753164 isSameExpression (@expr1073753165 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2336: true ,
2337: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ,
2338: assignTok@var3340 .@expr11295 astOperand2 (@expr11296 ) ,
2339: mSettings@var29 .@expr11246 library@var3738 ,
2340: true ,
2341: true ) ) {
2342: continue ; }
2343: differentDomain@var3338 =@expr1073753173 true ;
2344: break ;
2345: }
2346: if (@expr1073753174 !@expr1073753175 differentDomain@var3338 &&@expr1073753176 !@expr1073753177 isUniqueExpression (@expr1073753178 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ) ) {
2347: duplicateAssignExpressionError (@expr1073753181 var1@var3336 , var2@var3337 , false ) ; }
2348: else { if (@expr1073753182 mSettings@var29 .@expr1073753183 certainty@var3737 .@expr1073753184 isEnabled (@expr1073753185 Certainty ::@expr1073753186 inconclusive@expr1073752924 ) ) {
2349: duplicateAssignExpressionError (@expr1073753187 var1@var3336 , var2@var3337 , true ) ; } }
2350: }
2351: }
2352: }
2353: std ::@expr1073753188 list < std ::@expr11365 pair < const Token *@expr11119 , std ::@expr11365 string > > errorPath@var3342 ;
2354: if (@expr1073753192 tok@var3331 .@expr1073753193 isOp (@expr1073753194 ) &&@expr1073753195 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) &&@expr1073753198 !@expr1073753199 Token ::@expr11139 Match (@expr1073753201 tok@var3331 , "+|*|<<|>>|+=|*=|<<=|>>=" ) ) {
2355: if (@expr1073753202 Token ::@expr11139 Match (@expr1073753204 tok@var3331 , "==|!=|-" ) &&@expr1073753205 astIsFloat (@expr1073753206 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , true ) ) {
2356: continue ; }
2357: const bool pointerDereference@var3343 =@expr1073753209 (@expr1073753210 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) &&@expr1073753213 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr1073753216 isUnaryOp (@expr1073753217 "*" ) ) ||@expr1073753218
2358: (@expr1073753219 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) &&@expr1073753222 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753225 isUnaryOp (@expr1073753226 "*" ) ) ;
2359: const bool followVar@var3344 =@expr1073753227 (@expr1073753228 !@expr1073753229 isConstVarExpression (@expr1073753230 tok@var3331 ) ||@expr1073753231 Token ::@expr11139 Match (@expr1073753233 tok@var3331 , "%comp%|%oror%|&&" ) ) &&@expr1073753234 !@expr1073753235 pointerDereference@var3343 ;
2360: if (@expr1073753236 isSameExpression (@expr1073753237 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2361: true ,
2362: tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ,
2363: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ,
2364: mSettings@var29 .@expr11246 library@var3738 ,
2365: true ,
2366: followVar@var3344 ,
2367: &@expr11421 errorPath@var3342 ) ) {
2368: if (@expr1073753246 isWithoutSideEffects (@expr11423 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ) ) {
2369: const bool assignment@var3345 =@expr1073753252 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr11137 "=" ;
2370: if (@expr1073753256 assignment@var3345 &&@expr1073753257 warningEnabled@var3326 ) {
2371: selfAssignmentError (@expr11434 tok@var3331 , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr11437 expressionString (@expr11438 ) ) ; }
2372: else { if (@expr1073753263 styleEnabled@var3325 ) {
2373: if (@expr1073753264 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) &&@expr1073753267 mSettings@var29 .@expr1073753268 standards@var3742 .@expr1073753269 cpp@var3743 >=@expr1073753270 Standards ::@expr1073753271 CPP11 &&@expr1073753272 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr1073753275 "==" ) {
2374: const Token * parent@var3346 ; parent@var3346 =@expr1073753276 tok@var3331 .@expr11453 astParent (@expr11454 ) ;
2375: while (@expr1073753279 parent@var3346 &&@expr1073753280 parent@var3346 .@expr11457 astParent (@expr11458 ) ) {
2376: parent@var3346 =@expr1073753283 parent@var3346 .@expr11457 astParent (@expr11458 ) ;
2377: }
2378: if (@expr1073753286 parent@var3346 &&@expr1073753287 parent@var3346 .@expr11464 previous (@expr11465 ) &&@expr1073753290 parent@var3346 .@expr11464 previous (@expr11465 ) .@expr1073753293 str (@expr1073753294 ) ==@expr1073753295 "static_assert" ) {
2379: continue ;
2380: }
2381: }
2382: duplicateExpressionError (@expr1073753296 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , tok@var3331 , errorPath@var3342 ) ;
2383: } }
2384: }
2385: } else { if (@expr1073753301 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr11137 "=" &&@expr1073753305 Token ::@expr1073753306 simpleMatch (@expr1073753307 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , "=" ) &&@expr1073753310
2386: isSameExpression (@expr1073753311 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2387: false ,
2388: tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ,
2389: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753318 astOperand1 (@expr1073753319 ) ,
2390: mSettings@var29 .@expr11246 library@var3738 ,
2391: true ,
2392: false ) ) {
2393: if (@expr1073753321 warningEnabled@var3326 &&@expr1073753322 isWithoutSideEffects (@expr11423 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ) ) {
2394: selfAssignmentError (@expr11434 tok@var3331 , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr11437 expressionString (@expr11438 ) ) ;
2395: }
2396: } else { if (@expr1073753333 styleEnabled@var3325 &&@expr1073753334
2397: isOppositeExpression (@expr1073753335 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2398: tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ,
2399: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ,
2400: mSettings@var29 .@expr11246 library@var3738 ,
2401: false ,
2402: true ,
2403: &@expr11421 errorPath@var3342 ) &&@expr1073753344
2404: !@expr1073753345 Token ::@expr11139 Match (@expr1073753347 tok@var3331 , "=|-|-=|/|/=" ) &&@expr1073753348
2405: isWithoutSideEffects (@expr11423 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ) ) {
2406: oppositeExpressionError (@expr1073753354 tok@var3331 , errorPath@var3342 ) ;
2407: } else { if (@expr1073753355 !@expr1073753356 Token ::@expr11139 Match (@expr1073753358 tok@var3331 , "[-/%]" ) ) {
2408: if (@expr1073753359 styleEnabled@var3325 &&@expr1073753360 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) &&@expr1073753363 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr1073753366 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr1073753369 str (@expr1073753370 ) &&@expr1073753371
2409: isSameExpression (@expr1073753372 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ,
2410: true ,
2411: tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ,
2412: tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr11555 astOperand2 (@expr11556 ) ,
2413: mSettings@var29 .@expr11246 library@var3738 ,
2414: true ,
2415: followVar@var3344 ,
2416: &@expr11421 errorPath@var3342 ) &&@expr1073753383
2417: isWithoutSideEffects (@expr1073753384 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ) ) {
2418: duplicateExpressionError (@expr1073753389 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr11555 astOperand2 (@expr11556 ) , tok@var3331 , errorPath@var3342 ) ; }
2419: else { if (@expr1073753396 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) &&@expr1073753399 isConstExpression (@expr1073753400 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , mSettings@var29 .@expr11246 library@var3738 , true , mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ) ) {
2420: auto checkDuplicate@var3347 ; checkDuplicate@var3347 =@expr1073753406 [@expr1073753407 &@expr1073753408 ] (@expr1073753409 const Token *@expr11119 exp1@var3348 , const Token *@expr11119 exp2@var3349 , const Token *@expr11119 ast1@var3350 ) {
2421: if (@expr1073753413 isSameExpression (@expr1073753414 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , true , exp1@var3348 , exp2@var3349 , mSettings@var29 .@expr11246 library@var3738 , true , true , &@expr11421 errorPath@var3342 ) &&@expr1073753419
2422: isWithoutSideEffects (@expr1073753420 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , exp1@var3348 ) &&@expr1073753423
2423: isWithoutSideEffects (@expr1073753424 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , ast1@var3350 .@expr1073753427 astOperand2 (@expr1073753428 ) ) ) {
2424: duplicateExpressionError (@expr1073753429 exp1@var3348 , exp2@var3349 , tok@var3331 , errorPath@var3342 , true ) ; }
2425: } ;
2426: const Token * ast1@var3351 ; ast1@var3351 =@expr1073753430 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) ;
2427: while (@expr1073753433 ast1@var3351 &&@expr1073753434 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr1073753437 ast1@var3351 .@expr1073753438 str (@expr1073753439 ) ) {
2428: checkDuplicate@var3347 (@expr1073753440 ast1@var3351 .@expr1073753441 astOperand2 (@expr1073753442 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , ast1@var3351 ) ;
2429: if (@expr1073753445 ast1@var3351 .@expr11622 astOperand1 (@expr11623 ) &&@expr1073753448 ast1@var3351 .@expr11622 astOperand1 (@expr11623 ) .@expr1073753451 str (@expr1073753452 ) !=@expr1073753453 tok@var3331 .@expr11135 str (@expr11136 ) ) {
2430: checkDuplicate@var3347 (@expr1073753456 ast1@var3351 .@expr11622 astOperand1 (@expr11623 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , ast1@var3351 ) ; }
2431: ast1@var3351 =@expr1073753461 ast1@var3351 .@expr11622 astOperand1 (@expr11623 ) ;
2432: }
2433: } }
2434: } } } }
2435: } else { if (@expr1073753464 styleEnabled@var3325 &&@expr1073753465 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) &&@expr1073753468 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) &&@expr1073753471 tok@var3331 .@expr11135 str (@expr11136 ) ==@expr1073753474 ":" &&@expr1073753475 tok@var3331 .@expr11453 astParent (@expr11454 ) &&@expr1073753478 tok@var3331 .@expr11453 astParent (@expr11454 ) .@expr1073753481 str (@expr1073753482 ) ==@expr1073753483 "?" ) {
2436: if (@expr1073753484 !@expr1073753485 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) .@expr1073753488 values (@expr1073753489 ) .@expr1073753490 empty (@expr1073753491 ) &&@expr1073753492 !@expr1073753493 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) .@expr1073753496 values (@expr1073753497 ) .@expr1073753498 empty (@expr1073753499 ) &&@expr1073753500 isEqualKnownValue (@expr1073753501 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) ) &&@expr1073753506
2437: !@expr1073753507 isVariableChanged (@expr1073753508 tok@var3331 .@expr11453 astParent (@expr11454 ) , 0 , mSettings@var29 , mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ) &&@expr1073753513
2438: isConstStatement (@expr1073753514 tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ) &&@expr1073753519 isConstStatement (@expr1073753520 tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) ) ) {
2439: duplicateValueTernaryError (@expr1073753525 tok@var3331 ) ; }
2440: else { if (@expr1073753526 isSameExpression (@expr1073753527 mTokenizer@var28 .@expr11240 isCPP (@expr11241 ) , true , tok@var3331 .@expr11141 astOperand1 (@expr11142 ) , tok@var3331 .@expr11214 astOperand2 (@expr11215 ) , mSettings@var29 .@expr11246 library@var3738 , false , true , &@expr11421 errorPath@var3342 ) ) {
2441: duplicateExpressionTernaryError (@expr1073753536 tok@var3331 , errorPath@var3342 ) ; } }
2442: } }
2443: }
2444: }
2445: }
2446:
2447: void CheckOther :: oppositeExpressionError ( const Token * opTok@var3352 , std :: list < std :: pair < const Token * , std :: string > > errors@var3353 )
2448: {
2449: errors@var3353 .@expr1073753537 emplace_back (@expr1073753538 opTok@var3352 , "" ) ;
2450:
2451: const std ::@expr1073753539 string &@expr1073753540 op@var3354 =@expr1073753541 opTok@var3352 ?@expr1073753542 opTok@var3352 .@expr1073753543 str (@expr1073753544 ) :@expr1073753545 "&&" ;
2452:
2453: reportError (@expr1073753546 errors@var3353 , Severity ::@expr1073753547 style , "oppositeExpression" , "Opposite expression on both sides of \'" +@expr1073753548 op@var3354 +@expr1073753549 "\'.\nFinding the opposite expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
2454:
2455:
2456: , CWE398@var2876 , Certainty ::@expr1073753550 normal ) ;
2457: }
2458:
2459: void CheckOther :: duplicateExpressionError ( const Token * tok1@var3355 , const Token * tok2@var3356 , const Token * opTok@var3357 , std :: list < std :: pair < const Token * , std :: string > > errors@var3358 , bool hasMultipleExpr@var3359 )
2460: {
2461: errors@var3358 .@expr1073753551 emplace_back (@expr1073753552 opTok@var3357 , "" ) ;
2462:
2463: const std ::@expr11729 string &@expr11730 expr1@var3360 =@expr1073753555 tok1@var3355 ?@expr1073753556 tok1@var3355 .@expr1073753557 expressionString (@expr1073753558 ) :@expr1073753559 "x" ;
2464: const std ::@expr11729 string &@expr11730 expr2@var3361 =@expr1073753562 tok2@var3356 ?@expr1073753563 tok2@var3356 .@expr1073753564 expressionString (@expr1073753565 ) :@expr1073753566 "x" ;
2465:
2466: const std ::@expr11729 string &@expr11730 op@var3362 =@expr1073753569 opTok@var3357 ?@expr1073753570 opTok@var3357 .@expr1073753571 str (@expr1073753572 ) :@expr1073753573 "&&" ;
2467: std ::@expr1073753574 string msg@var3363 ; msg@var3363 =@expr1073753575 "Same expression " +@expr1073753576 (@expr1073753577 hasMultipleExpr@var3359 ?@expr1073753578 "\'" +@expr1073753579 expr1@var3360 +@expr1073753580 "\'" +@expr1073753581 " found multiple times in chain of \'" +@expr1073753582 op@var3362 +@expr1073753583 "\' operators" :@expr1073753584 "on both sides of \'" +@expr1073753585 op@var3362 +@expr1073753586 "\'" ) ;
2468: const char * id@var3364 ; id@var3364 =@expr1073753587 "duplicateExpression" ;
2469: if (@expr1073753588 expr1@var3360 !=@expr1073753589 expr2@var3361 &&@expr1073753590 (@expr1073753591 !@expr1073753592 opTok@var3357 ||@expr1073753593 !@expr1073753594 opTok@var3357 .@expr1073753595 isArithmeticalOp (@expr1073753596 ) ) ) {
2470: id@var3364 =@expr1073753597 "knownConditionTrueFalse" ;
2471: std ::@expr1073753598 string exprMsg@var3365 ; exprMsg@var3365 =@expr1073753599 "The comparison \'" +@expr1073753600 expr1@var3360 +@expr1073753601 " " +@expr1073753602 op@var3362 +@expr1073753603 " " +@expr1073753604 expr2@var3361 +@expr1073753605 "\' is always " ;
2472: if (@expr1073753606 Token ::@expr11783 Match (@expr1073753608 opTok@var3357 , "==|>=|<=" ) ) {
2473: msg@var3363 =@expr1073753609 exprMsg@var3365 +@expr1073753610 "true" ; }
2474: else { if (@expr1073753611 Token ::@expr11783 Match (@expr1073753613 opTok@var3357 , "!=|>|<" ) ) {
2475: msg@var3363 =@expr1073753614 exprMsg@var3365 +@expr1073753615 "false" ; } }
2476: if (@expr1073753616 !@expr1073753617 Token ::@expr11783 Match (@expr1073753619 tok1@var3355 , "%num%|NULL|nullptr" ) &&@expr1073753620 !@expr1073753621 Token ::@expr11783 Match (@expr1073753623 tok2@var3356 , "%num%|NULL|nullptr" ) ) {
2477: msg@var3363 +=@expr1073753624 " because '" +@expr1073753625 expr1@var3360 +@expr1073753626 "' and '" +@expr1073753627 expr2@var3361 +@expr1073753628 "' represent the same value" ; }
2478: }
2479:
2480: reportError (@expr1073753629 errors@var3358 , Severity ::@expr1073753630 style , id@var3364 , msg@var3363 +@expr1073753631
2481: (@expr1073753632 std ::@expr1073753633 string (@expr1073753634 ".\nFinding the same expression " ) +@expr1073753635 (@expr1073753636 hasMultipleExpr@var3359 ?@expr1073753637 "more than once in a condition" :@expr1073753638 "on both sides of an operator" ) ) +@expr1073753639
2482: " is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
2483: , CWE398@var2876 , Certainty ::@expr1073753640 normal ) ;
2484: }
2485:
2486: void CheckOther :: duplicateAssignExpressionError ( const Token * tok1@var3366 , const Token * tok2@var3367 , bool inconclusive@var3368 )
2487: {
2488: const std ::@expr1073753641 list < const Token *@expr1073753642 > toks@var3369 =@expr1073753643 {@expr1073753644 tok2@var3367 , tok1@var3366 } ;
2489:
2490: const std ::@expr11821 string &@expr11822 var1@var3370 =@expr1073753647 tok1@var3366 ?@expr1073753648 tok1@var3366 .@expr1073753649 str (@expr1073753650 ) :@expr1073753651 "x" ;
2491: const std ::@expr11821 string &@expr11822 var2@var3371 =@expr1073753654 tok2@var3367 ?@expr1073753655 tok2@var3367 .@expr1073753656 str (@expr1073753657 ) :@expr1073753658 "x" ;
2492:
2493: reportError (@expr1073753659 toks@var3369 , Severity ::@expr1073753660 style , "duplicateAssignExpression" ,
2494: "Same expression used in consecutive assignments of '" +@expr1073753661 var1@var3370 +@expr1073753662 "' and '" +@expr1073753663 var2@var3371 +@expr1073753664 "'.\nFinding variables '"
2495: +@expr1073753665 var1@var3370 +@expr1073753666 "' and '" +@expr1073753667 var2@var3371 +@expr1073753668 "' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
2496:
2497: , CWE398@var2876 , inconclusive@var3368 ?@expr1073753669 Certainty ::@expr1073753670 inconclusive :@expr1073753671 Certainty ::@expr1073753672 normal ) ;
2498: }
2499:
2500: void CheckOther :: duplicateExpressionTernaryError ( const Token * tok@var3372 , std :: list < std :: pair < const Token * , std :: string > > errors@var3373 )
2501: {
2502: errors@var3373 .@expr1073753673 emplace_back (@expr1073753674 tok@var3372 , "" ) ;
2503: reportError (@expr1073753675 errors@var3373 , Severity ::@expr1073753676 style , "duplicateExpressionTernary" , "Same expression in both branches of ternary operator.\nFinding the same expression in both branches of ternary operator is suspicious as the same code is executed regardless of the condition."
2504:
2505: , CWE398@var2876 , Certainty ::@expr1073753677 normal ) ;
2506: }
2507:
2508: void CheckOther :: duplicateValueTernaryError ( const Token * tok@var3374 )
2509: {
2510: reportError (@expr1073753678 tok@var3374 , Severity ::@expr1073753679 style , "duplicateValueTernary" , "Same value in both branches of ternary operator.\nFinding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition."
2511:
2512: , CWE398@var2876 , Certainty ::@expr1073753680 normal ) ;
2513: }
2514:
2515: void CheckOther :: selfAssignmentError ( const Token * tok@var3375 , const std :: string & varname@var3376 )
2516: {
2517: reportError (@expr1073753681 tok@var3375 , Severity ::@expr1073753682 warning ,
2518: "selfAssignment" ,
2519: "$symbol:" +@expr1073753683 varname@var3376 +@expr1073753684 "\nRedundant assignment of '$symbol' to itself."
2520: , CWE398@var2876 , Certainty ::@expr1073753685 normal ) ;
2521: }
2522:
|
2531:
2532: void CheckOther :: checkComparisonFunctionIsAlwaysTrueOrFalse ( )
2533: {
2534: if (@expr1073753686 !@expr1073753687 mSettings@var29 .@expr1073753688 severity@var3736 .@expr1073753689 isEnabled (@expr1073753690 Severity ::@expr1073753691 warning ) ) {
2535: return ; }
2536:
2537: const SymbolDatabase * symbolDatabase@var3377 ; symbolDatabase@var3377 =@expr1073753692 mTokenizer@var28 .@expr1073753693 getSymbolDatabase (@expr1073753694 ) ;
2538: for (@expr1073753695 const Scope *@expr11872 scope@var3378 :@expr1073753697 symbolDatabase@var3377 .@expr1073753698 functionScopes@var3379 ) {
2539: for (@expr1073753699 const Token *@expr11872 tok@var3380 =@expr1073753701 scope@var3378 .@expr1073753702 bodyStart@var3381 .@expr1073753703 next (@expr1073753704 ) ; tok@var3380 !=@expr1073753705 scope@var3378 .@expr1073753706 bodyEnd@var3382 ; tok@var3380 =@expr1073753707 tok@var3380 .@expr1073753708 next (@expr1073753709 ) ) {
2540: if (@expr1073753710 tok@var3380 .@expr1073753711 isName (@expr1073753712 ) &&@expr1073753713 Token ::@expr1073753714 Match (@expr1073753715 tok@var3380 , "isgreater|isless|islessgreater|isgreaterequal|islessequal ( %var% , %var% )" ) ) {
2541: const int varidLeft@var3383 =@expr1073753716 tok@var3380 .@expr11893 tokAt (@expr1073753718 2 ) .@expr1073753719 varId (@expr1073753720 ) ;
2542: const int varidRight@var3384 =@expr1073753721 tok@var3380 .@expr11893 tokAt (@expr1073753723 4 ) .@expr1073753724 varId (@expr1073753725 ) ;
2543:
2544:
2545: if (@expr1073753726 varidLeft@var3383 ==@expr1073753727 varidRight@var3384 ) {
2546: const std ::@expr11904 string &@expr11905 functionName@var3385 =@expr1073753730 tok@var3380 .@expr1073753731 str (@expr1073753732 ) ;
2547: const std ::@expr11904 string &@expr11905 varNameLeft@var3386 =@expr1073753735 tok@var3380 .@expr1073753736 strAt (@expr1073753737 2 ) ;
2548: if (@expr1073753738 functionName@var3385 ==@expr1073753739 "isgreater" ||@expr1073753740 functionName@var3385 ==@expr1073753741 "isless" ||@expr1073753742 functionName@var3385 ==@expr1073753743 "islessgreater" ) {
2549:
2550: checkComparisonFunctionIsAlwaysTrueOrFalseError (@expr1073753744 tok@var3380 , functionName@var3385 , varNameLeft@var3386 , false ) ;
2551: } else {
2552:
2553: checkComparisonFunctionIsAlwaysTrueOrFalseError (@expr1073753745 tok@var3380 , functionName@var3385 , varNameLeft@var3386 , true ) ;
2554: }
2555: }
2556: }
2557: }
2558: }
2559: }
2560: void CheckOther :: checkComparisonFunctionIsAlwaysTrueOrFalseError ( const Token * tok@var3387 , const std :: string & functionName@var3388 , const std :: string & varName@var3389 , const bool result@var3390 )
2561: {
2562: const std ::@expr1073753746 string strResult@var3391 =@expr1073753747 result@var3390 ?@expr1073753748 "true" :@expr1073753749 "false" ;
2563: const struct CWE cweResult@var3392 =@expr1073753750 result@var3390 ?@expr1073753751 CWE571@var2882 :@expr1073753752 CWE570@var2881 ;
2564:
2565: reportError (@expr1073753753 tok@var3387 , Severity ::@expr1073753754 warning , "comparisonFunctionIsAlwaysTrueOrFalse" ,
2566: "$symbol:" +@expr1073753755 functionName@var3388 +@expr1073753756 "\nComparison of two identical variables with $symbol("
2567: +@expr1073753757 varName@var3389 +@expr1073753758 "," +@expr1073753759 varName@var3389 +@expr1073753760 ") always evaluates to " +@expr1073753761 strResult@var3391 +@expr1073753762 ".\nThe function $symbol is designed to compare two variables. Calling this function with one variable ("
2568: +@expr1073753763 varName@var3389 +@expr1073753764 ") for both parameters leads to a statement which is always "
2569: +@expr1073753765 strResult@var3391 +@expr1073753766 "." , cweResult@var3392 , Certainty ::@expr1073753767 normal ) ;
2570: }
2571:
|
2574:
2575: void CheckOther :: checkSignOfUnsignedVariable ( )
2576: {
2577: if (@expr1073753768 !@expr1073753769 mSettings@var29 .@expr1073753770 severity@var3736 .@expr1073753771 isEnabled (@expr1073753772 Severity ::@expr1073753773 style ) ) {
2578: return ; }
2579:
2580: const SymbolDatabase * symbolDatabase@var3393 ; symbolDatabase@var3393 =@expr1073753774 mTokenizer@var28 .@expr1073753775 getSymbolDatabase (@expr1073753776 ) ;
2581:
2582: for (@expr1073753777 const Scope *@expr11954 scope@var3394 :@expr1073753779 symbolDatabase@var3393 .@expr1073753780 functionScopes@var3395 ) {
2583:
2584: for (@expr1073753781 const Token *@expr11954 tok@var3396 =@expr1073753783 scope@var3394 .@expr1073753784 bodyStart@var3397 .@expr1073753785 next (@expr1073753786 ) ; tok@var3396 !=@expr1073753787 scope@var3394 .@expr1073753788 bodyEnd@var3398 ; tok@var3396 =@expr1073753789 tok@var3396 .@expr1073753790 next (@expr1073753791 ) ) {
2585: const ValueFlow ::@expr1073753792 Value * zeroValue@var3399 ; zeroValue@var3399 =@expr1073753793 nullptr ;
2586: const Token * nonZeroExpr@var3400 ; nonZeroExpr@var3400 =@expr1073753794 nullptr ;
2587: if (@expr1073753795 comparisonNonZeroExpressionLessThanZero (@expr1073753796 tok@var3396 , &@expr11973 zeroValue@var3399 , &@expr11974 nonZeroExpr@var3400 ) ) {
2588: const ValueType * vt@var3401 ; vt@var3401 =@expr1073753799 nonZeroExpr@var3400 .@expr11976 valueType (@expr11977 ) ;
2589: if (@expr1073753802 vt@var3401 .@expr1073753803 pointer@var3402 ) {
2590: pointerLessThanZeroError (@expr1073753804 tok@var3396 , zeroValue@var3399 ) ; }
2591: else {
2592: unsignedLessThanZeroError (@expr1073753805 tok@var3396 , zeroValue@var3399 , nonZeroExpr@var3400 .@expr11982 expressionString (@expr11983 ) ) ; }
2593: } else { if (@expr1073753808 testIfNonZeroExpressionIsPositive (@expr1073753809 tok@var3396 , &@expr11973 zeroValue@var3399 , &@expr11974 nonZeroExpr@var3400 ) ) {
2594: const ValueType * vt@var3403 ; vt@var3403 =@expr1073753812 nonZeroExpr@var3400 .@expr11976 valueType (@expr11977 ) ;
2595: if (@expr1073753815 vt@var3403 .@expr1073753816 pointer@var3404 ) {
2596: pointerPositiveError (@expr1073753817 tok@var3396 , zeroValue@var3399 ) ; }
2597: else {
2598: unsignedPositiveError (@expr1073753818 tok@var3396 , zeroValue@var3399 , nonZeroExpr@var3400 .@expr11982 expressionString (@expr11983 ) ) ; }
2599: } }
2600: }
2601: }
2602: }
2603:
2604: bool CheckOther :: comparisonNonZeroExpressionLessThanZero ( const Token * tok@var3405 , const ValueFlow :: Value * * zeroValue@var3406 , const Token * * nonZeroExpr@var3407 )
2605: {
2606: if (@expr1073753821 !@expr1073753822 tok@var3405 .@expr1073753823 isComparisonOp (@expr1073753824 ) ||@expr1073753825 !@expr1073753826 tok@var3405 .@expr12003 astOperand1 (@expr12004 ) ||@expr1073753829 !@expr1073753830 tok@var3405 .@expr12007 astOperand2 (@expr12008 ) ) {
2607: return false ; }
2608:
2609: const ValueFlow ::@expr12009 Value * v1@var3408 ; v1@var3408 =@expr1073753834 tok@var3405 .@expr12003 astOperand1 (@expr12004 ) .@expr1073753837 getValue (@expr1073753838 0 ) ;
2610: const ValueFlow ::@expr12009 Value * v2@var3409 ; v2@var3409 =@expr1073753840 tok@var3405 .@expr12007 astOperand2 (@expr12008 ) .@expr1073753843 getValue (@expr1073753844 0 ) ;
2611:
2612: if (@expr1073753845 Token ::@expr12022 Match (@expr1073753847 tok@var3405 , "<|<=" ) &&@expr1073753848 v2@var3409 &&@expr1073753849 v2@var3409 .@expr1073753850 isKnown (@expr1073753851 ) ) {
2613: *@expr12028 zeroValue@var3406 =@expr1073753853 v2@var3409 ;
2614: *@expr12030 nonZeroExpr@var3407 =@expr1073753855 tok@var3405 .@expr12003 astOperand1 (@expr12004 ) ;
2615: } else { if (@expr1073753858 Token ::@expr12022 Match (@expr1073753860 tok@var3405 , ">|>=" ) &&@expr1073753861 v1@var3408 &&@expr1073753862 v1@var3408 .@expr1073753863 isKnown (@expr1073753864 ) ) {
2616: *@expr12028 zeroValue@var3406 =@expr1073753866 v1@var3408 ;
2617: *@expr12030 nonZeroExpr@var3407 =@expr1073753868 tok@var3405 .@expr12007 astOperand2 (@expr12008 ) ;
2618: } else {
2619: return false ;
2620: } }
2621:
2622: const ValueType * vt@var3410 ; vt@var3410 =@expr1073753871 (@expr1073753872 *@expr12030 nonZeroExpr@var3407 ) .@expr1073753874 valueType (@expr1073753875 ) ;
2623: return vt@var3410 &&@expr1073753876 (@expr1073753877 vt@var3410 .@expr1073753878 pointer@var3411 ||@expr1073753879 vt@var3410 .@expr1073753880 sign@var3412 ==@expr1073753881 ValueType ::@expr1073753882 UNSIGNED ) ;
2624: }
2625:
2626: bool CheckOther :: testIfNonZeroExpressionIsPositive ( const Token * tok@var3413 , const ValueFlow :: Value * * zeroValue@var3414 , const Token * * nonZeroExpr@var3415 )
2627: {
2628: if (@expr1073753883 !@expr1073753884 tok@var3413 .@expr1073753885 isComparisonOp (@expr1073753886 ) ||@expr1073753887 !@expr1073753888 tok@var3413 .@expr12065 astOperand1 (@expr12066 ) ||@expr1073753891 !@expr1073753892 tok@var3413 .@expr12069 astOperand2 (@expr12070 ) ) {
2629: return false ; }
2630:
2631: const ValueFlow ::@expr12071 Value * v1@var3416 ; v1@var3416 =@expr1073753896 tok@var3413 .@expr12065 astOperand1 (@expr12066 ) .@expr1073753899 getValue (@expr1073753900 0 ) ;
2632: const ValueFlow ::@expr12071 Value * v2@var3417 ; v2@var3417 =@expr1073753902 tok@var3413 .@expr12069 astOperand2 (@expr12070 ) .@expr1073753905 getValue (@expr1073753906 0 ) ;
2633:
2634: if (@expr1073753907 Token ::@expr12084 simpleMatch (@expr1073753909 tok@var3413 , ">=" ) &&@expr1073753910 v2@var3417 &&@expr1073753911 v2@var3417 .@expr1073753912 isKnown (@expr1073753913 ) ) {
2635: *@expr12090 zeroValue@var3414 =@expr1073753915 v2@var3417 ;
2636: *@expr12092 nonZeroExpr@var3415 =@expr1073753917 tok@var3413 .@expr12065 astOperand1 (@expr12066 ) ;
2637: } else { if (@expr1073753920 Token ::@expr12084 simpleMatch (@expr1073753922 tok@var3413 , "<=" ) &&@expr1073753923 v1@var3416 &&@expr1073753924 v1@var3416 .@expr1073753925 isKnown (@expr1073753926 ) ) {
2638: *@expr12090 zeroValue@var3414 =@expr1073753928 v1@var3416 ;
2639: *@expr12092 nonZeroExpr@var3415 =@expr1073753930 tok@var3413 .@expr12069 astOperand2 (@expr12070 ) ;
2640: } else {
2641: return false ;
2642: } }
2643:
2644: const ValueType * vt@var3418 ; vt@var3418 =@expr1073753933 (@expr1073753934 *@expr12092 nonZeroExpr@var3415 ) .@expr1073753936 valueType (@expr1073753937 ) ;
2645: return vt@var3418 &&@expr1073753938 (@expr1073753939 vt@var3418 .@expr1073753940 pointer@var3419 ||@expr1073753941 vt@var3418 .@expr1073753942 sign@var3420 ==@expr1073753943 ValueType ::@expr1073753944 UNSIGNED ) ;
2646: }
2647:
2648: void CheckOther :: unsignedLessThanZeroError ( const Token * tok@var3421 , const ValueFlow :: Value * v@var3422 , const std :: string & varname@var3423 )
2649: {
2650: reportError (@expr1073753945 getErrorPath (@expr1073753946 tok@var3421 , v@var3422 , "Unsigned less than zero" ) , Severity ::@expr1073753947 style , "unsignedLessThanZero" ,
2651: "$symbol:" +@expr1073753948 varname@var3423 +@expr1073753949 "\nChecking if unsigned expression '$symbol' is less than zero.\nThe unsigned expression '$symbol' will never be negative so it is either pointless or an error to check if it is."
2652:
2653:
2654: , CWE570@var2881 , Certainty ::@expr1073753950 normal ) ;
2655: }
2656:
2657: void CheckOther :: pointerLessThanZeroError ( const Token * tok@var3424 , const ValueFlow :: Value * v@var3425 )
2658: {
2659: reportError (@expr1073753951 getErrorPath (@expr1073753952 tok@var3424 , v@var3425 , "Pointer less than zero" ) , Severity ::@expr1073753953 style , "pointerLessThanZero" ,
2660: "A pointer can not be negative so it is either pointless or an error to check if it is." , CWE570@var2881 , Certainty ::@expr1073753954 normal ) ;
2661: }
2662:
2663: void CheckOther :: unsignedPositiveError ( const Token * tok@var3426 , const ValueFlow :: Value * v@var3427 , const std :: string & varname@var3428 )
2664: {
2665: reportError (@expr1073753955 getErrorPath (@expr1073753956 tok@var3426 , v@var3427 , "Unsigned positive" ) , Severity ::@expr1073753957 style , "unsignedPositive" ,
2666: "$symbol:" +@expr1073753958 varname@var3428 +@expr1073753959 "\nUnsigned expression '$symbol' can't be negative so it is unnecessary to test it."
2667: , CWE570@var2881 , Certainty ::@expr1073753960 normal ) ;
2668: }
2669:
2670: void CheckOther :: pointerPositiveError ( const Token * tok@var3429 , const ValueFlow :: Value * v@var3430 )
2671: {
2672: reportError (@expr1073753961 getErrorPath (@expr1073753962 tok@var3429 , v@var3430 , "Pointer positive" ) , Severity ::@expr1073753963 style , "pointerPositive" ,
2673: "A pointer can not be negative so it is either pointless or an error to check if it is not." , CWE570@var2881 , Certainty ::@expr1073753964 normal ) ;
2674: }
2675:
2676:
2677: static bool constructorTakesReference ( const Scope * const classScope@var3431 )
2678: {
2679: for (@expr1073753965 const Function &@expr1073753966 constructor@var3432 :@expr1073753967 classScope@var3431 .@expr1073753968 functionList@var3433 ) {
2680: if (@expr1073753969 constructor@var3432 .@expr1073753970 isConstructor (@expr1073753971 ) ) {
2681: for (@expr1073753972 int argnr@var3434 =@expr1073753973 0U ; argnr@var3434 <@expr1073753974 constructor@var3432 .@expr1073753975 argCount (@expr1073753976 ) ; argnr@var3434 ++@expr1073753977 ) {
2682: const Variable * const argVar@var3435 ; argVar@var3435 =@expr1073753978 constructor@var3432 .@expr1073753979 getArgumentVar (@expr1073753980 argnr@var3434 ) ;
2683: if (@expr1073753981 argVar@var3435 &&@expr1073753982 argVar@var3435 .@expr1073753983 isReference (@expr1073753984 ) ) {
2684: return true ;
2685: }
2686: }
2687: }
2688: }
2689: return false ;
2690: }
2691:
|
2695:
2696: void CheckOther :: checkRedundantCopy ( )
2697: {
2698: if (@expr1073753986 !@expr1073753987 mSettings@var29 .@expr1073753988 severity@var3736 .@expr1073753989 isEnabled (@expr1073753990 Severity ::@expr1073753991 performance ) ||@expr1073753992 mTokenizer@var28 .@expr1073753993 isC (@expr1073753994 ) ||@expr1073753995 !@expr1073753996 mSettings@var29 .@expr1073753997 certainty@var3737 .@expr1073753998 isEnabled (@expr1073753999 Certainty ::@expr1073754000 inconclusive@expr1073753985 ) ) {
2699: return ; }
2700:
2701: const SymbolDatabase * symbolDatabase@var3436 ; symbolDatabase@var3436 =@expr1073754001 mTokenizer@var28 .@expr1073754002 getSymbolDatabase (@expr1073754003 ) ;
2702:
2703: for (@expr1073754004 const Variable *@expr1073754005 var@var3437 :@expr1073754006 symbolDatabase@var3436 .@expr1073754007 variableList (@expr1073754008 ) ) {
2704: if (@expr1073754009 !@expr1073754010 var@var3437 ||@expr1073754011 var@var3437 .@expr1073754012 isReference (@expr1073754013 ) ||@expr1073754014 !@expr1073754015 var@var3437 .@expr1073754016 isConst (@expr1073754017 ) ||@expr1073754018 var@var3437 .@expr1073754019 isPointer (@expr1073754020 ) ||@expr1073754021 (@expr1073754022 !@expr1073754023 var@var3437 .@expr1073754024 type (@expr1073754025 ) &&@expr1073754026 !@expr1073754027 var@var3437 .@expr1073754028 isStlType (@expr1073754029 ) ) ) {
2705: continue ; }
2706:
2707: const Token * startTok@var3438 ; startTok@var3438 =@expr1073754030 var@var3437 .@expr1073754031 nameToken (@expr1073754032 ) ;
2708: if (@expr1073754033 startTok@var3438 .@expr12210 strAt (@expr12211 1 ) ==@expr1073754036 "=" ) {
2709: ; }
2710: else { if (@expr1073754037 startTok@var3438 .@expr12210 strAt (@expr12211 1 ) ==@expr1073754040 "(" &&@expr1073754041 var@var3437 .@expr1073754042 isClass (@expr1073754043 ) &&@expr1073754044 var@var3437 .@expr12221 typeScope (@expr12222 ) ) {
2711:
2712: if (@expr1073754047 constructorTakesReference (@expr1073754048 var@var3437 .@expr12221 typeScope (@expr12222 ) ) ) {
2713: continue ; }
2714: } else {
2715: continue ; } }
2716:
2717: const Token * tok@var3439 ; tok@var3439 =@expr1073754051 startTok@var3438 .@expr1073754052 next (@expr1073754053 ) .@expr1073754054 astOperand2 (@expr1073754055 ) ;
2718: if (@expr1073754056 !@expr1073754057 tok@var3439 ) {
2719: continue ; }
2720: if (@expr1073754058 !@expr1073754059 Token ::@expr12236 Match (@expr1073754061 tok@var3439 .@expr12238 previous (@expr12239 ) , "%name% (" ) ) {
2721: continue ; }
2722: if (@expr1073754064 !@expr1073754065 Token ::@expr12236 Match (@expr1073754067 tok@var3439 .@expr1073754068 link (@expr1073754069 ) , ") )| ;" ) ) {
2723: continue ; }
2724:
2725: const Function * func@var3440 ; func@var3440 =@expr1073754070 tok@var3439 .@expr12238 previous (@expr12239 ) .@expr1073754073 function (@expr1073754074 ) ;
2726: if (@expr1073754075 func@var3440 &&@expr1073754076 func@var3440 .@expr1073754077 tokenDef@var3441 .@expr1073754078 strAt (@expr1073754079 -1 ) ==@expr1073754080 "&" ) {
2727: redundantCopyError (@expr1073754081 startTok@var3438 , startTok@var3438 .@expr1073754082 str (@expr1073754083 ) ) ;
2728: }
2729: }
2730: }
2731: void CheckOther :: redundantCopyError ( const Token * tok@var3442 , const std :: string & varname@var3443 )
2732: {
2733: reportError (@expr1073754085 tok@var3442 , Severity ::@expr1073754086 performance , "redundantCopyLocalConst" ,
2734: "$symbol:" +@expr1073754087 varname@var3443 +@expr1073754088 "\nUse const reference for '$symbol' to avoid unnecessary data copying.\nThe const variable '$symbol' is assigned a copy of the data. You can avoid the unnecessary data copying by converting '$symbol' to const reference."
2735:
2736:
2737: ,
2738: CWE398@var2876 ,
2739: Certainty ::@expr1073754089 inconclusive@expr1073754084 ) ;
2740: }
2741:
|
2745:
2746: static bool isNegative ( const Token * tok@var3444 , const Settings * settings@var3445 )
2747: {
2748: return tok@var3444 .@expr12266 valueType (@expr12267 ) &&@expr1073754092 tok@var3444 .@expr12266 valueType (@expr12267 ) .@expr1073754095 sign@var3768 ==@expr1073754096 ValueType ::@expr1073754097 SIGNED &&@expr1073754098 tok@var3444 .@expr1073754099 getValueLE (@expr1073754100 -1LL , settings@var3445 ) ;
2749: }
2750:
2751: void CheckOther :: checkNegativeBitwiseShift ( )
2752: {
2753: const bool portability@var3446 =@expr1073754101 mSettings@var29 .@expr1073754102 severity@var3736 .@expr1073754103 isEnabled (@expr1073754104 Severity ::@expr1073754105 portability ) ;
2754:
2755: for (@expr1073754106 const Token *@expr12283 tok@var3447 =@expr1073754108 mTokenizer@var28 .@expr1073754109 tokens (@expr1073754110 ) ; tok@var3447 ; tok@var3447 =@expr1073754111 tok@var3447 .@expr1073754112 next (@expr1073754113 ) ) {
2756: if (@expr1073754114 !@expr1073754115 tok@var3447 .@expr12292 astOperand1 (@expr12293 ) ||@expr1073754118 !@expr1073754119 tok@var3447 .@expr12296 astOperand2 (@expr12297 ) ) {
2757: continue ; }
2758:
2759: if (@expr1073754122 !@expr1073754123 Token ::@expr12300 Match (@expr1073754125 tok@var3447 , "<<|>>|<<=|>>=" ) ) {
2760: continue ; }
2761:
2762:
2763: if (@expr1073754126 mTokenizer@var28 .@expr1073754127 isCPP (@expr1073754128 ) ) {
2764: const ValueType * lhsType@var3448 ; lhsType@var3448 =@expr1073754129 tok@var3447 .@expr12292 astOperand1 (@expr12293 ) .@expr1073754132 valueType (@expr1073754133 ) ;
2765: if (@expr1073754134 !@expr1073754135 lhsType@var3448 ||@expr1073754136 !@expr1073754137 lhsType@var3448 .@expr1073754138 isIntegral (@expr1073754139 ) ) {
2766: continue ; }
2767: }
2768:
2769:
2770: bool ternary@var3449 ; ternary@var3449 =@expr1073754140 false ;
2771: for (@expr1073754141 const Token *@expr12283 parent@var3450 =@expr1073754143 tok@var3447 ; parent@var3450 ; parent@var3450 =@expr1073754144 parent@var3450 .@expr1073754145 astParent (@expr1073754146 ) ) {
2772: if (@expr1073754147 Token ::@expr12300 Match (@expr1073754149 parent@var3450 , "?|:" ) ) {
2773: ternary@var3449 =@expr1073754150 true ;
2774: break ;
2775: }
2776: }
2777: if (@expr1073754151 ternary@var3449 ) {
2778: continue ; }
2779:
2780:
2781: if (@expr1073754152 portability@var3446 &&@expr1073754153 isNegative (@expr1073754154 tok@var3447 .@expr12292 astOperand1 (@expr12293 ) , mSettings@var29 ) ) {
2782: negativeBitwiseShiftError (@expr1073754157 tok@var3447 , 1 ) ; }
2783: else { if (@expr1073754158 isNegative (@expr1073754159 tok@var3447 .@expr12296 astOperand2 (@expr12297 ) , mSettings@var29 ) ) {
2784: negativeBitwiseShiftError (@expr1073754162 tok@var3447 , 2 ) ; } }
2785: }
2786: }
2787:
2788:
2789: void CheckOther :: negativeBitwiseShiftError ( const Token * tok@var3451 , int op@var3452 )
2790: {
2791: if (@expr1073754163 op@var3452 ==@expr1073754164 1 ) {
2792:
2793:
2794:
2795: reportError (@expr1073754165 tok@var3451 , Severity ::@expr1073754166 portability , "shiftNegativeLHS" , "Shifting a negative value is technically undefined behaviour" , CWE758@var2888 , Certainty ::@expr12343 normal ) ; }
2796: else {
2797: reportError (@expr1073754168 tok@var3451 , Severity ::@expr1073754169 error , "shiftNegative" , "Shifting by a negative value is undefined behaviour" , CWE758@var2888 , Certainty ::@expr12343 normal ) ; }
2798: }
2799:
|
2802:
2803: void CheckOther :: checkIncompleteArrayFill ( )
2804: {
2805: if (@expr1073754172 !@expr1073754173 mSettings@var29 .@expr1073754174 certainty@var3737 .@expr1073754175 isEnabled (@expr1073754176 Certainty ::@expr1073754177 inconclusive@expr1073754171 ) ) {
2806: return ; }
2807: const bool printWarning@var3453 =@expr1073754178 mSettings@var29 .@expr12355 severity@var3736 .@expr12356 isEnabled (@expr1073754181 Severity ::@expr1073754182 warning ) ;
2808: const bool printPortability@var3454 =@expr1073754183 mSettings@var29 .@expr12355 severity@var3736 .@expr12356 isEnabled (@expr1073754186 Severity ::@expr1073754187 portability ) ;
2809: if (@expr1073754188 !@expr1073754189 printPortability@var3454 &&@expr1073754190 !@expr1073754191 printWarning@var3453 ) {
2810: return ; }
2811:
2812: const SymbolDatabase * symbolDatabase@var3455 ; symbolDatabase@var3455 =@expr1073754192 mTokenizer@var28 .@expr1073754193 getSymbolDatabase (@expr1073754194 ) ;
2813:
2814: for (@expr1073754195 const Scope *@expr12372 scope@var3456 :@expr1073754197 symbolDatabase@var3455 .@expr1073754198 functionScopes@var3457 ) {
2815: for (@expr1073754199 const Token *@expr12372 tok@var3458 =@expr1073754201 scope@var3456 .@expr1073754202 bodyStart@var3459 .@expr1073754203 next (@expr1073754204 ) ; tok@var3458 !=@expr1073754205 scope@var3456 .@expr1073754206 bodyEnd@var3460 ; tok@var3458 =@expr1073754207 tok@var3458 .@expr1073754208 next (@expr1073754209 ) ) {
2816: if (@expr1073754210 Token ::@expr12387 Match (@expr1073754212 tok@var3458 , "memset|memcpy|memmove ( %var% ," ) &&@expr1073754213 Token ::@expr12387 Match (@expr1073754215 tok@var3458 .@expr12392 linkAt (@expr12393 1 ) .@expr1073754218 tokAt (@expr1073754219 -2 ) , ", %num% )" ) ) {
2817: const Variable * var@var3461 ; var@var3461 =@expr1073754220 tok@var3458 .@expr1073754221 tokAt (@expr1073754222 2 ) .@expr1073754223 variable (@expr1073754224 ) ;
2818: if (@expr1073754225 !@expr1073754226 var@var3461 ||@expr1073754227 !@expr1073754228 var@var3461 .@expr1073754229 isArray (@expr1073754230 ) ||@expr1073754231 var@var3461 .@expr1073754232 dimensions (@expr1073754233 ) .@expr1073754234 empty (@expr1073754235 ) ||@expr1073754236 !@expr1073754237 var@var3461 .@expr12414 dimension (@expr12415 0 ) ) {
2819: continue ; }
2820:
2821: if (@expr1073754240 MathLib ::@expr1073754241 toLongNumber (@expr1073754242 tok@var3458 .@expr12392 linkAt (@expr12393 1 ) .@expr1073754245 strAt (@expr1073754246 -1 ) ) ==@expr1073754247 var@var3461 .@expr12414 dimension (@expr12415 0 ) ) {
2822: int size@var3462 ; size@var3462 =@expr1073754250 mTokenizer@var28 .@expr1073754251 sizeOfType (@expr1073754252 var@var3461 .@expr1073754253 typeStartToken (@expr1073754254 ) ) ;
2823: if (@expr1073754255 size@var3462 ==@expr12432 0 &&@expr1073754257 var@var3461 .@expr12434 valueType (@expr12435 ) .@expr1073754260 pointer@var3766 ) {
2824: size@var3462 =@expr1073754261 mSettings@var29 .@expr1073754262 sizeof_pointer@var3741 ; }
2825: else { if (@expr1073754263 size@var3462 ==@expr12432 0 &&@expr1073754265 var@var3461 .@expr12442 type (@expr12443 ) ) {
2826: size@var3462 =@expr1073754268 estimateSize (@expr1073754269 var@var3461 .@expr12442 type (@expr12443 ) , mSettings@var29 , symbolDatabase@var3455 ) ; } }
2827: if (@expr1073754272 (@expr1073754273 size@var3462 !=@expr1073754274 1 &&@expr1073754275 size@var3462 !=@expr1073754276 100 &&@expr1073754277 size@var3462 !=@expr1073754278 0 ) ||@expr1073754279 var@var3461 .@expr1073754280 isPointer (@expr1073754281 ) ) {
2828: if (@expr1073754282 printWarning@var3453 ) {
2829: incompleteArrayFillError (@expr1073754283 tok@var3458 , var@var3461 .@expr12460 name (@expr12461 ) , tok@var3458 .@expr12462 str (@expr12463 ) , false ) ; }
2830: } else { if (@expr1073754288 var@var3461 .@expr12434 valueType (@expr12435 ) .@expr1073754291 type@var3759 ==@expr1073754292 ValueType ::@expr1073754293 Type ::@expr1073754294 BOOL &&@expr1073754295 printPortability@var3454 ) {
2831: incompleteArrayFillError (@expr1073754296 tok@var3458 , var@var3461 .@expr12460 name (@expr12461 ) , tok@var3458 .@expr12462 str (@expr12463 ) , true ) ; } }
2832: }
2833: }
2834: }
2835: }
2836: }
2837:
2838: void CheckOther :: incompleteArrayFillError ( const Token * tok@var3463 , const std :: string & buffer@var3464 , const std :: string & function@var3465 , bool boolean@var3466 )
2839: {
2840: if (@expr1073754302 boolean@var3466 ) {
2841: reportError (@expr1073754303 tok@var3463 , Severity ::@expr1073754304 portability , "incompleteArrayFill" ,
2842: "$symbol:" +@expr12481 buffer@var3464 +@expr12482 "\n$symbol:"
2843: +@expr12483 function@var3465 +@expr12484 "\nArray '"
2844: +@expr12485 buffer@var3464 +@expr1073754310 "' might be filled incompletely. Did you forget to multiply the size given to '" +@expr1073754311 function@var3465 +@expr1073754312 "()' with 'sizeof(*" +@expr1073754313 buffer@var3464 +@expr1073754314 ")'?\nThe array '"
2845: +@expr1073754315 buffer@var3464 +@expr1073754316 "' is filled incompletely. The function '" +@expr1073754317 function@var3465 +@expr1073754318 "()' needs the size given in bytes, but the type 'bool' is larger than 1 on some platforms. Did you forget to multiply the size with 'sizeof(*" +@expr1073754319 buffer@var3464 +@expr1073754320 ")'?" , CWE131@var2872 , Certainty ::@expr12497 inconclusive@expr12477 ) ; }
2846: else {
2847: reportError (@expr1073754322 tok@var3463 , Severity ::@expr1073754323 warning , "incompleteArrayFill" ,
2848: "$symbol:" +@expr12481 buffer@var3464 +@expr12482 "\n$symbol:"
2849: +@expr12483 function@var3465 +@expr12484 "\nArray '"
2850: +@expr12485 buffer@var3464 +@expr1073754329 "' is filled incompletely. Did you forget to multiply the size given to '" +@expr1073754330 function@var3465 +@expr1073754331 "()' with 'sizeof(*" +@expr1073754332 buffer@var3464 +@expr1073754333 ")'?\nThe array '"
2851: +@expr1073754334 buffer@var3464 +@expr1073754335 "' is filled incompletely. The function '" +@expr1073754336 function@var3465 +@expr1073754337 "()' needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with 'sizeof(*" +@expr1073754338 buffer@var3464 +@expr1073754339 ")'?" , CWE131@var2872 , Certainty ::@expr12497 inconclusive@expr12477 ) ; }
2852: }
2853:
|
2857:
2858: void CheckOther :: checkVarFuncNullUB ( )
2859: {
2860: if (@expr1073754341 !@expr1073754342 mSettings@var29 .@expr1073754343 severity@var3736 .@expr1073754344 isEnabled (@expr1073754345 Severity ::@expr1073754346 portability ) ) {
2861: return ; }
2862:
2863: const SymbolDatabase * symbolDatabase@var3467 ; symbolDatabase@var3467 =@expr1073754347 mTokenizer@var28 .@expr1073754348 getSymbolDatabase (@expr1073754349 ) ;
2864: for (@expr1073754350 const Scope *@expr12527 scope@var3468 :@expr1073754352 symbolDatabase@var3467 .@expr1073754353 functionScopes@var3469 ) {
2865: for (@expr1073754354 const Token *@expr12527 tok@var3470 =@expr1073754356 scope@var3468 .@expr1073754357 bodyStart@var3471 ; tok@var3470 !=@expr1073754358 scope@var3468 .@expr1073754359 bodyEnd@var3472 ; tok@var3470 =@expr1073754360 tok@var3470 .@expr1073754361 next (@expr1073754362 ) ) {
2866:
2867: if (@expr1073754363 Token ::@expr1073754364 Match (@expr1073754365 tok@var3470 , "[(,] NULL [,)]" ) ) {
2868:
2869: const Token * ftok@var3473 ; ftok@var3473 =@expr1073754366 tok@var3470 ;
2870: int argnr@var3474 ; argnr@var3474 =@expr1073754367 1 ;
2871: while (@expr1073754368 ftok@var3473 &&@expr1073754369 ftok@var3473 .@expr12546 str (@expr12547 ) !=@expr1073754372 "(" ) {
2872: if (@expr1073754373 ftok@var3473 .@expr12546 str (@expr12547 ) ==@expr1073754376 ")" ) {
2873: ftok@var3473 =@expr1073754377 ftok@var3473 .@expr1073754378 link (@expr1073754379 ) ; }
2874: else { if (@expr1073754380 ftok@var3473 .@expr12546 str (@expr12547 ) ==@expr1073754383 "," ) {
2875: ++@expr1073754384 argnr@var3474 ; } }
2876: ftok@var3473 =@expr1073754385 ftok@var3473 .@expr12562 previous (@expr12563 ) ;
2877: }
2878: ftok@var3473 =@expr1073754388 ftok@var3473 ?@expr1073754389 ftok@var3473 .@expr12562 previous (@expr12563 ) :@expr1073754392 nullptr ;
2879: if (@expr1073754393 ftok@var3473 &&@expr1073754394 ftok@var3473 .@expr1073754395 isName (@expr1073754396 ) ) {
2880:
2881: const Function * f@var3475 ; f@var3475 =@expr1073754397 ftok@var3473 .@expr1073754398 function (@expr1073754399 ) ;
2882: if (@expr1073754400 f@var3475 &&@expr1073754401 f@var3475 .@expr1073754402 argCount (@expr1073754403 ) <=@expr1073754404 argnr@var3474 ) {
2883: const Token * tok2@var3476 ; tok2@var3476 =@expr1073754405 f@var3475 .@expr1073754406 argDef@var3477 ;
2884: tok2@var3476 =@expr1073754407 tok2@var3476 ?@expr1073754408 tok2@var3476 .@expr1073754409 link (@expr1073754410 ) :@expr1073754411 nullptr ;
2885: if (@expr1073754412 tok2@var3476 &&@expr1073754413 Token ::@expr1073754414 simpleMatch (@expr1073754415 tok2@var3476 .@expr1073754416 tokAt (@expr1073754417 -1 ) , "..." ) ) {
2886: varFuncNullUBError (@expr1073754418 tok@var3470 ) ; }
2887: }
2888: }
2889: }
2890: }
2891: }
2892: }
2893:
2894: void CheckOther :: varFuncNullUBError ( const Token * tok@var3478 )
2895: {
2896: reportError (@expr1073754419 tok@var3478 ,
2897: Severity ::@expr1073754420 portability ,
2898: "varFuncNullUB" ,
2899: "Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nPassing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nThe C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\nThe value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\nIn practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\nTo reproduce you might be able to use this little code example on 64bit platforms. If the output includes \"ERROR\", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the \"ERROR\" output go away.\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid f(char *s, ...) {\n    va_list ap;\n    va_start(ap,s);\n    for (;;) {\n        char *p = va_arg(ap,char*);\n        printf(\"%018p, %s\\n\", p, (long)p & 255 ? p : \"\");\n        if(!p) break;\n    }\n    va_end(ap);\n}\n\nvoid g() {\n    char *s2 = \"x\";\n    char *s3 = \"ERROR\";\n\n    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\n    f(\"first\", s2, s2, s2, s2, s2, 0, s3, (char*)0);\n}\n\nvoid h() {\n    int i;\n    volatile unsigned char a[1000];\n    for (i = 0; i<sizeof(a); i++)\n        a[i] = -1;\n}\n\nint main() {\n    h();\n    g();\n    return 0;\n}"
2900:
|
2937:
2938: , CWE475@var2877 , Certainty ::@expr1073754421 normal ) ;
2939: }
2940:
2941: void CheckOther :: checkRedundantPointerOp ( )
2942: {
2943: if (@expr1073754422 !@expr1073754423 mSettings@var29 .@expr1073754424 severity@var3736 .@expr1073754425 isEnabled (@expr1073754426 Severity ::@expr1073754427 style ) ) {
2944: return ; }
2945:
2946: for (@expr1073754428 const Token *@expr1073754429 tok@var3479 =@expr1073754430 mTokenizer@var28 .@expr1073754431 tokens (@expr1073754432 ) ; tok@var3479 ; tok@var3479 =@expr1073754433 tok@var3479 .@expr1073754434 next (@expr1073754435 ) ) {
2947: if (@expr1073754436 tok@var3479 .@expr12613 isExpandedMacro (@expr12614 ) &&@expr1073754439 tok@var3479 .@expr1073754440 str (@expr1073754441 ) ==@expr1073754442 "(" ) {
2948: tok@var3479 =@expr1073754443 tok@var3479 .@expr1073754444 link (@expr1073754445 ) ; }
2949:
2950: bool addressOfDeref@var3480 {@expr1073754446 } ;
2951: if (@expr1073754447 tok@var3479 .@expr12624 isUnaryOp (@expr1073754449 "&" ) &&@expr1073754450 tok@var3479 .@expr12627 astOperand1 (@expr12628 ) .@expr12629 isUnaryOp (@expr1073754454 "*" ) ) {
2952: addressOfDeref@var3480 =@expr1073754455 true ; }
2953: else { if (@expr1073754456 tok@var3479 .@expr12624 isUnaryOp (@expr1073754458 "*" ) &&@expr1073754459 tok@var3479 .@expr12627 astOperand1 (@expr12628 ) .@expr12629 isUnaryOp (@expr1073754463 "&" ) ) {
2954: addressOfDeref@var3480 =@expr1073754464 false ; }
2955: else {
2956: continue ; } }
2957:
2958:
2959: const Token * varTok@var3481 ; varTok@var3481 =@expr1073754465 tok@var3479 .@expr12627 astOperand1 (@expr12628 ) .@expr1073754468 astOperand1 (@expr1073754469 ) ;
2960: if (@expr1073754470 !@expr1073754471 varTok@var3481 ||@expr1073754472 varTok@var3481 .@expr1073754473 isExpandedMacro (@expr1073754474 ) ) {
2961: continue ; }
2962:
2963: if (@expr1073754475 !@expr1073754476 addressOfDeref@var3480 ) {
2964: if (@expr1073754477 tok@var3479 .@expr12613 isExpandedMacro (@expr12614 ) ) {
2965: continue ; }
2966: if (@expr1073754480 varTok@var3481 .@expr12657 valueType (@expr12658 ) &&@expr1073754483 varTok@var3481 .@expr12657 valueType (@expr12658 ) .@expr1073754486 pointer@var3766 &&@expr1073754487 varTok@var3481 .@expr12657 valueType (@expr12658 ) .@expr1073754490 reference@var3769 ==@expr1073754491 Reference ::@expr1073754492 LValue ) {
2967: continue ; }
2968: }
2969:
2970: const Variable * var@var3482 ; var@var3482 =@expr1073754493 varTok@var3481 .@expr1073754494 variable (@expr1073754495 ) ;
2971: if (@expr1073754496 !@expr1073754497 var@var3482 ||@expr1073754498 (@expr1073754499 addressOfDeref@var3480 &&@expr1073754500 !@expr1073754501 var@var3482 .@expr1073754502 isPointer (@expr1073754503 ) ) ) {
2972: continue ; }
2973:
2974: redundantPointerOpError (@expr1073754504 tok@var3479 , var@var3482 .@expr1073754505 name (@expr1073754506 ) , false , addressOfDeref@var3480 ) ;
2975: }
2976: }
2977:
2978: void CheckOther :: redundantPointerOpError ( const Token * tok@var3483 , const std :: string & varname@var3484 , bool inconclusive@var3485 , bool addressOfDeref@var3486 )
2979: {
2980: std ::@expr1073754507 string msg@var3487 ; msg@var3487 =@expr1073754508 "$symbol:" +@expr1073754509 varname@var3484 +@expr1073754510 "\nRedundant pointer operation on '$symbol' - it's already a " ;
2981: msg@var3487 +=@expr1073754511 addressOfDeref@var3486 ?@expr1073754512 "pointer." :@expr1073754513 "variable." ;
2982: reportError (@expr1073754514 tok@var3483 , Severity ::@expr1073754515 style , "redundantPointerOp" , msg@var3487 , CWE398@var2876 , inconclusive@var3485 ?@expr1073754516 Certainty ::@expr1073754517 inconclusive :@expr1073754518 Certainty ::@expr1073754519 normal ) ;
2983: }
2984:
2985: void CheckOther :: checkInterlockedDecrement ( )
2986: {
2987: if (@expr1073754520 !@expr1073754521 mSettings@var29 .@expr1073754522 isWindowsPlatform (@expr1073754523 ) ) {
2988: return ;
2989: }
2990:
2991: for (@expr1073754524 const Token *@expr1073754525 tok@var3488 =@expr1073754526 mTokenizer@var28 .@expr1073754527 tokens (@expr1073754528 ) ; tok@var3488 ; tok@var3488 =@expr1073754529 tok@var3488 .@expr12706 next (@expr12707 ) ) {
2992: if (@expr1073754532 tok@var3488 .@expr1073754533 isName (@expr1073754534 ) &&@expr1073754535 Token ::@expr12712 Match (@expr1073754537 tok@var3488 , "InterlockedDecrement ( & %name% ) ; if ( %name%|!|0" ) ) {
2993: const Token * interlockedVarTok@var3489 ; interlockedVarTok@var3489 =@expr1073754538 tok@var3488 .@expr12715 tokAt (@expr1073754540 3 ) ;
2994: const Token * checkStartTok@var3490 ; checkStartTok@var3490 =@expr1073754541 interlockedVarTok@var3489 .@expr1073754542 tokAt (@expr1073754543 5 ) ;
2995: if (@expr1073754544 (@expr1073754545 Token ::@expr12712 Match (@expr1073754547 checkStartTok@var3490 , "0 %comp% %name% )" ) &&@expr1073754548 checkStartTok@var3490 .@expr12725 strAt (@expr1073754550 2 ) ==@expr1073754551 interlockedVarTok@var3489 .@expr12728 str (@expr12729 ) ) ||@expr1073754554
2996: (@expr1073754555 Token ::@expr12712 Match (@expr1073754557 checkStartTok@var3490 , "! %name% )" ) &&@expr1073754558 checkStartTok@var3490 .@expr12725 strAt (@expr1073754560 1 ) ==@expr1073754561 interlockedVarTok@var3489 .@expr12728 str (@expr12729 ) ) ||@expr1073754564
2997: (@expr1073754565 Token ::@expr12712 Match (@expr1073754567 checkStartTok@var3490 , "%name% )" ) &&@expr1073754568 checkStartTok@var3490 .@expr12745 str (@expr12746 ) ==@expr12747 interlockedVarTok@var3489 .@expr12728 str (@expr12729 ) ) ||@expr1073754574
2998: (@expr1073754575 Token ::@expr12712 Match (@expr1073754577 checkStartTok@var3490 , "%name% %comp% 0 )" ) &&@expr1073754578 checkStartTok@var3490 .@expr12745 str (@expr12746 ) ==@expr12747 interlockedVarTok@var3489 .@expr12728 str (@expr12729 ) ) ) {
2999: raceAfterInterlockedDecrementError (@expr1073754584 checkStartTok@var3490 ) ;
3000: }
3001: } else { if (@expr1073754585 Token ::@expr12712 Match (@expr1073754587 tok@var3488 , "if ( ::| InterlockedDecrement ( & %name%" ) ) {
3002: const Token * condEnd@var3491 ; condEnd@var3491 =@expr1073754588 tok@var3488 .@expr12706 next (@expr12707 ) .@expr1073754591 link (@expr1073754592 ) ;
3003: const Token * funcTok@var3492 ; funcTok@var3492 =@expr1073754593 tok@var3488 .@expr12715 tokAt (@expr1073754595 2 ) ;
3004: const Token * firstAccessTok@var3493 ; firstAccessTok@var3493 =@expr1073754596 funcTok@var3492 .@expr1073754597 str (@expr1073754598 ) ==@expr1073754599 "::" ?@expr1073754600 funcTok@var3492 .@expr12777 tokAt (@expr1073754602 4 ) :@expr1073754603 funcTok@var3492 .@expr12777 tokAt (@expr1073754605 3 ) ;
3005: if (@expr1073754606 condEnd@var3491 &&@expr1073754607 condEnd@var3491 .@expr12784 next (@expr12785 ) &&@expr1073754610 condEnd@var3491 .@expr12784 next (@expr12785 ) .@expr12789 link (@expr12790 ) ) {
3006: const Token * ifEndTok@var3494 ; ifEndTok@var3494 =@expr1073754615 condEnd@var3491 .@expr12784 next (@expr12785 ) .@expr12789 link (@expr12790 ) ;
3007: if (@expr1073754620 Token ::@expr12712 Match (@expr1073754622 ifEndTok@var3494 , "} return %name%" ) ) {
3008: const Token * secondAccessTok@var3495 ; secondAccessTok@var3495 =@expr1073754623 ifEndTok@var3494 .@expr12800 tokAt (@expr1073754625 2 ) ;
3009: if (@expr1073754626 secondAccessTok@var3495 .@expr1073754627 str (@expr1073754628 ) ==@expr1073754629 firstAccessTok@var3493 .@expr12806 str (@expr12807 ) ) {
3010: raceAfterInterlockedDecrementError (@expr1073754632 secondAccessTok@var3495 ) ;
3011: }
3012: } else { if (@expr1073754633 Token ::@expr12712 Match (@expr1073754635 ifEndTok@var3494 , "} else { return %name%" ) ) {
3013: const Token * secondAccessTok@var3496 ; secondAccessTok@var3496 =@expr1073754636 ifEndTok@var3494 .@expr12800 tokAt (@expr1073754638 4 ) ;
3014: if (@expr1073754639 secondAccessTok@var3496 .@expr1073754640 str (@expr1073754641 ) ==@expr1073754642 firstAccessTok@var3493 .@expr12806 str (@expr12807 ) ) {
3015: raceAfterInterlockedDecrementError (@expr1073754645 secondAccessTok@var3496 ) ;
3016: }
3017: } }
3018: }
3019: } }
3020: }
3021: }
3022:
3023: void CheckOther :: raceAfterInterlockedDecrementError ( const Token * tok@var3497 )
3024: {
3025: reportError (@expr1073754646 tok@var3497 , Severity ::@expr1073754647 error , "raceAfterInterlockedDecrement" ,
3026: "Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead." , CWE362@var2874 , Certainty ::@expr1073754648 normal ) ;
3027: }
3028:
3029: void CheckOther :: checkUnusedLabel ( )
3030: {
3031: if (@expr1073754649 !@expr1073754650 mSettings@var29 .@expr12827 severity@var3736 .@expr12828 isEnabled (@expr1073754653 Severity ::@expr1073754654 style ) &&@expr1073754655 !@expr1073754656 mSettings@var29 .@expr12827 severity@var3736 .@expr12828 isEnabled (@expr1073754659 Severity ::@expr1073754660 warning ) ) {
3032: return ; }
3033:
3034: const SymbolDatabase * symbolDatabase@var3498 ; symbolDatabase@var3498 =@expr1073754661 mTokenizer@var28 .@expr1073754662 getSymbolDatabase (@expr1073754663 ) ;
3035: for (@expr1073754664 const Scope *@expr12841 scope@var3499 :@expr1073754666 symbolDatabase@var3498 .@expr1073754667 functionScopes@var3500 ) {
3036: const bool hasIfdef@var3501 =@expr1073754668 mTokenizer@var28 .@expr1073754669 hasIfdef (@expr1073754670 scope@var3499 .@expr12847 bodyStart@var3502 , scope@var3499 .@expr12848 bodyEnd@var3503 ) ;
3037: for (@expr1073754673 const Token *@expr12841 tok@var3504 =@expr1073754675 scope@var3499 .@expr12847 bodyStart@var3502 ; tok@var3504 !=@expr1073754677 scope@var3499 .@expr12848 bodyEnd@var3503 ; tok@var3504 =@expr1073754679 tok@var3504 .@expr12856 next (@expr12857 ) ) {
3038: if (@expr1073754682 !@expr1073754683 tok@var3504 .@expr12860 scope (@expr12861 ) .@expr1073754686 isExecutable (@expr1073754687 ) ) {
3039: tok@var3504 =@expr1073754688 tok@var3504 .@expr12860 scope (@expr12861 ) .@expr1073754691 bodyEnd@var3756 ; }
3040:
3041: if (@expr1073754692 Token ::@expr1073754693 Match (@expr1073754694 tok@var3504 , "{|}|; %name% :" ) &&@expr1073754695 !@expr1073754696 tok@var3504 .@expr1073754697 tokAt (@expr1073754698 1 ) .@expr1073754699 isKeyword (@expr1073754700 ) ) {
3042: const std ::@expr1073754701 string tmp@var3505 (@expr1073754702 "goto " +@expr1073754703 tok@var3504 .@expr1073754704 strAt (@expr1073754705 1 ) ) ;
3043: if (@expr1073754706 !@expr1073754707 Token ::@expr1073754708 findsimplematch (@expr1073754709 scope@var3499 .@expr12847 bodyStart@var3502 .@expr1073754711 next (@expr1073754712 ) , tmp@var3505 .@expr1073754713 c_str (@expr1073754714 ) , tmp@var3505 .@expr1073754715 size (@expr1073754716 ) , scope@var3499 .@expr12848 bodyEnd@var3503 .@expr1073754718 previous (@expr1073754719 ) ) ) {
3044: unusedLabelError (@expr1073754720 tok@var3504 .@expr12856 next (@expr12857 ) , tok@var3504 .@expr12856 next (@expr12857 ) .@expr1073754725 scope (@expr1073754726 ) .@expr1073754727 type@var3774 ==@expr1073754728 Scope ::@expr1073754729 eSwitch , hasIfdef@var3501 ) ; }
3045: }
3046: }
3047: }
3048: }
3049:
3050: void CheckOther :: unusedLabelError ( const Token * tok@var3506 , bool inSwitch@var3507 , bool hasIfdef@var3508 )
3051: {
3052: if (@expr1073754730 tok@var3506 &&@expr1073754731 !@expr1073754732 mSettings@var29 .@expr1073754733 severity@var3736 .@expr1073754734 isEnabled (@expr1073754735 inSwitch@var3507 ?@expr12912 Severity ::@expr12913 warning :@expr12914 Severity ::@expr12915 style ) ) {
3053: return ; }
3054:
3055: std ::@expr1073754740 string id@var3509 ; id@var3509 =@expr1073754741 "unusedLabel" ;
3056: if (@expr12918 inSwitch@var3507 ) {
3057: id@var3509 +=@expr1073754743 "Switch" ; }
3058: if (@expr12920 hasIfdef@var3508 ) {
3059: id@var3509 +=@expr1073754745 "Configuration" ; }
3060:
3061: std ::@expr1073754746 string msg@var3510 ; msg@var3510 =@expr1073754747 "$symbol:" +@expr1073754748 (@expr1073754749 tok@var3506 ?@expr1073754750 tok@var3506 .@expr1073754751 str (@expr1073754752 ) :@expr1073754753 emptyString@var1 ) +@expr1073754754 "\nLabel '$symbol' is not used." ;
3062: if (@expr12920 hasIfdef@var3508 ) {
3063: msg@var3510 +=@expr1073754756 " There is #if in function body so the label might be used in code that is removed by the preprocessor." ; }
3064: if (@expr12918 inSwitch@var3507 ) {
3065: msg@var3510 +=@expr1073754758 " Should this be a 'case' of the enclosing switch()?" ; }
3066:
3067: reportError (@expr1073754759 tok@var3506 ,
3068: inSwitch@var3507 ?@expr12912 Severity ::@expr12913 warning :@expr12914 Severity ::@expr12915 style ,
3069: id@var3509 ,
3070: msg@var3510 ,
3071: CWE398@var2876 ,
3072: Certainty ::@expr1073754764 normal ) ;
3073: }
3074:
3075:
3076: void CheckOther :: checkEvaluationOrder ( )
3077: {
3078:
3079: if (@expr1073754765 mTokenizer@var28 .@expr12942 isCPP (@expr12943 ) &&@expr1073754768 mSettings@var29 .@expr1073754769 standards@var3742 .@expr1073754770 cpp@var3743 >=@expr1073754771 Standards ::@expr1073754772 CPP11 ) {
3080: return ; }
3081:
3082: const SymbolDatabase * symbolDatabase@var3511 ; symbolDatabase@var3511 =@expr1073754773 mTokenizer@var28 .@expr1073754774 getSymbolDatabase (@expr1073754775 ) ;
3083: for (@expr1073754776 const Scope *@expr12953 functionScope@var3512 :@expr1073754778 symbolDatabase@var3511 .@expr1073754779 functionScopes@var3513 ) {
3084: for (@expr1073754780 const Token *@expr12953 tok@var3514 =@expr1073754782 functionScope@var3512 .@expr1073754783 bodyStart@var3515 ; tok@var3514 !=@expr1073754784 functionScope@var3512 .@expr1073754785 bodyEnd@var3516 ; tok@var3514 =@expr1073754786 tok@var3514 .@expr1073754787 next (@expr1073754788 ) ) {
3085: if (@expr1073754789 !@expr1073754790 Token ::@expr12967 Match (@expr1073754792 tok@var3514 , "++|--" ) &&@expr1073754793 !@expr1073754794 tok@var3514 .@expr1073754795 isAssignmentOp (@expr1073754796 ) ) {
3086: continue ; }
3087: if (@expr1073754797 !@expr1073754798 tok@var3514 .@expr12975 astOperand1 (@expr12976 ) ) {
3088: continue ; }
3089: for (@expr1073754801 const Token *@expr12953 tok2@var3517 =@expr1073754803 tok@var3514 ; ; tok2@var3517 =@expr1073754804 tok2@var3517 .@expr12981 astParent (@expr12982 ) ) {
3090:
3091: const Token * const parent@var3518 ; parent@var3518 =@expr1073754807 tok2@var3517 .@expr12981 astParent (@expr12982 ) ;
3092: if (@expr1073754810 !@expr1073754811 parent@var3518 ) {
3093: break ; }
3094: if (@expr1073754812 Token ::@expr12967 Match (@expr1073754814 parent@var3518 , "%oror%|&&|?|:|;" ) ) {
3095: break ; }
3096: if (@expr1073754815 parent@var3518 .@expr12992 str (@expr12993 ) ==@expr1073754818 "," ) {
3097: const Token * par@var3519 ; par@var3519 =@expr1073754819 parent@var3518 ;
3098: while (@expr1073754820 Token ::@expr12997 simpleMatch (@expr1073754822 par@var3519 , "," ) ) {
3099: par@var3519 =@expr1073754823 par@var3519 .@expr1073754824 astParent (@expr1073754825 ) ; }
3100:
3101: if (@expr1073754826 !@expr1073754827 (@expr1073754828 par@var3519 &&@expr1073754829 par@var3519 .@expr1073754830 str (@expr1073754831 ) ==@expr1073754832 "(" &&@expr1073754833 par@var3519 .@expr1073754834 astOperand2 (@expr1073754835 ) &&@expr1073754836 par@var3519 .@expr1073754837 strAt (@expr1073754838 -1 ) !=@expr1073754839 "while" ) ) {
3102: break ; }
3103:
3104: if (@expr1073754840 Token ::@expr12997 simpleMatch (@expr1073754842 par@var3519 .@expr1073754843 link (@expr1073754844 ) , ") {" ) ) {
3105: break ; }
3106:
3107: par@var3519 =@expr1073754845 par@var3519 .@expr1073754846 next (@expr1073754847 ) ;
3108: while (@expr1073754848 par@var3519 &&@expr1073754849 (@expr1073754850 par@var3519 .@expr1073754851 previous (@expr1073754852 ) !=@expr1073754853 parent@var3518 ) ) {
3109: par@var3519 =@expr1073754854 par@var3519 .@expr1073754855 nextArgument (@expr1073754856 ) ; }
3110: if (@expr1073754857 !@expr1073754858 par@var3519 ) {
3111: break ; }
3112: }
3113: if (@expr1073754859 parent@var3518 .@expr12992 str (@expr12993 ) ==@expr1073754862 "(" &&@expr1073754863 parent@var3518 .@expr13040 astOperand2 (@expr13041 ) ) {
3114: break ; }
3115:
3116:
3117: if (@expr1073754866 tok2@var3517 ==@expr1073754867 tok@var3514 &&@expr1073754868
3118: tok@var3514 .@expr1073754869 str (@expr1073754870 ) ==@expr1073754871 "=" &&@expr1073754872
3119: parent@var3518 .@expr12992 str (@expr12993 ) ==@expr1073754875 "=" &&@expr1073754876
3120: isSameExpression (@expr1073754877 mTokenizer@var28 .@expr12942 isCPP (@expr12943 ) , false , tok@var3514 .@expr12975 astOperand1 (@expr12976 ) , parent@var3518 .@expr13058 astOperand1 (@expr13059 ) , mSettings@var29 .@expr13060 library@var3738 , true , false ) ) {
3121: if (@expr1073754885 mSettings@var29 .@expr1073754886 severity@var3736 .@expr1073754887 isEnabled (@expr1073754888 Severity ::@expr1073754889 warning ) &&@expr1073754890
3122: isSameExpression (@expr1073754891 mTokenizer@var28 .@expr12942 isCPP (@expr12943 ) , true , tok@var3514 .@expr12975 astOperand1 (@expr12976 ) , parent@var3518 .@expr13058 astOperand1 (@expr13059 ) , mSettings@var29 .@expr13060 library@var3738 , true , false ) ) {
3123: selfAssignmentError (@expr1073754899 parent@var3518 , tok@var3514 .@expr12975 astOperand1 (@expr12976 ) .@expr1073754902 expressionString (@expr1073754903 ) ) ; }
3124: break ;
3125: }
3126:
3127:
3128: bool foundError@var3520 ; foundError@var3520 =@expr1073754904 false ;
3129: visitAstNodes (@expr1073754905 (@expr1073754906 parent@var3518 .@expr13058 astOperand1 (@expr13059 ) !=@expr1073754909 tok2@var3517 ) ?@expr1073754910 parent@var3518 .@expr13058 astOperand1 (@expr13059 ) :@expr1073754913 parent@var3518 .@expr13040 astOperand2 (@expr13041 ) ,
3130: [@expr1073754916 &@expr1073754917 ] (@expr1073754918 const Token *@expr12953 tok3@var3521 ) {
3131: if (@expr1073754920 tok3@var3521 .@expr13097 str (@expr13098 ) ==@expr1073754923 "&" &&@expr1073754924 !@expr1073754925 tok3@var3521 .@expr1073754926 astOperand2 (@expr1073754927 ) ) {
3132: return ChildrenToVisit ::@expr13104 none ; }
3133: if (@expr1073754929 tok3@var3521 .@expr13097 str (@expr13098 ) ==@expr1073754932 "(" &&@expr1073754933 Token ::@expr12997 simpleMatch (@expr1073754935 tok3@var3521 .@expr1073754936 previous (@expr1073754937 ) , "sizeof" ) ) {
3134: return ChildrenToVisit ::@expr13104 none ; }
3135: if (@expr1073754939 isSameExpression (@expr1073754940 mTokenizer@var28 .@expr12942 isCPP (@expr12943 ) , false , tok@var3514 .@expr12975 astOperand1 (@expr12976 ) , tok3@var3521 , mSettings@var29 .@expr13060 library@var3738 , true , false ) ) {
3136: foundError@var3520 =@expr1073754946 true ; }
3137: return foundError@var3520 ?@expr1073754947 ChildrenToVisit ::@expr1073754948 done :@expr1073754949 ChildrenToVisit ::@expr1073754950 op1_and_op2 ;
3138: } ) ;
3139:
3140: if (@expr1073754951 foundError@var3520 ) {
3141: unknownEvaluationOrder (@expr1073754952 parent@var3518 ) ;
3142: break ;
3143: }
3144: }
3145: }
3146: }
3147: }
3148:
3149: void CheckOther :: unknownEvaluationOrder ( const Token * tok@var3522 )
3150: {
3151: reportError (@expr1073754953 tok@var3522 , Severity ::@expr1073754954 error , "unknownEvaluationOrder" ,
3152: "Expression '" +@expr1073754955 (@expr1073754956 tok@var3522 ?@expr1073754957 tok@var3522 .@expr1073754958 expressionString (@expr1073754959 ) :@expr1073754960 std ::@expr1073754961 string (@expr1073754962 "x = x++;" ) ) +@expr1073754963 "' depends on order of evaluation of side effects" , CWE768@var2889 , Certainty ::@expr1073754964 normal ) ;
3153: }
3154:
3155: void CheckOther :: checkAccessOfMovedVariable ( )
3156: {
3157: if (@expr1073754967 !@expr1073754968 mTokenizer@var28 .@expr1073754969 isCPP (@expr1073754970 ) ||@expr1073754971 mSettings@var29 .@expr1073754972 standards@var3742 .@expr1073754973 cpp@var3743 <@expr1073754974 Standards ::@expr1073754975 CPP11 ||@expr1073754976 !@expr1073754977 mSettings@var29 .@expr1073754978 severity@var3736 .@expr1073754979 isEnabled (@expr1073754980 Severity ::@expr1073754981 warning ) ) {
3158: return ; }
3159: CheckUninitVar checkUninitVar@var3523 (@expr1073754982 mTokenizer@var28 , mSettings@var29 , mErrorLogger@var30 ) ;
3160: const bool reportInconclusive@var3524 =@expr1073754983 mSettings@var29 .@expr1073754984 certainty@var3737 .@expr1073754985 isEnabled (@expr1073754986 Certainty ::@expr1073754987 inconclusive@expr1073754965 ) ;
3161: const SymbolDatabase * symbolDatabase@var3525 ; symbolDatabase@var3525 =@expr1073754988 mTokenizer@var28 .@expr1073754989 getSymbolDatabase (@expr1073754990 ) ;
3162: for (@expr1073754991 const Scope *@expr13168 scope@var3526 :@expr1073754993 symbolDatabase@var3525 .@expr1073754994 functionScopes@var3527 ) {
3163: const Token * scopeStart@var3528 ; scopeStart@var3528 =@expr1073754995 scope@var3526 .@expr1073754996 bodyStart@var3529 ;
3164: if (@expr1073754997 scope@var3526 .@expr13174 function@var3530 ) {
3165: const Token * memberInitializationStart@var3531 ; memberInitializationStart@var3531 =@expr1073754999 scope@var3526 .@expr13174 function@var3530 .@expr1073755001 constructorMemberInitialization (@expr1073755002 ) ;
3166: if (@expr1073755003 memberInitializationStart@var3531 ) {
3167: scopeStart@var3528 =@expr1073755004 memberInitializationStart@var3531 ; }
3168: }
3169: for (@expr1073755005 const Token *@expr13168 tok@var3532 =@expr1073755007 scopeStart@var3528 .@expr1073755008 next (@expr1073755009 ) ; tok@var3532 !=@expr1073755010 scope@var3526 .@expr1073755011 bodyEnd@var3533 ; tok@var3532 =@expr1073755012 tok@var3532 .@expr13189 next (@expr13190 ) ) {
3170: const ValueFlow ::@expr13191 Value * movedValue@var3534 ; movedValue@var3534 =@expr1073755016 tok@var3532 .@expr1073755017 getMovedValue (@expr1073755018 ) ;
3171: if (@expr1073755019 !@expr1073755020 movedValue@var3534 ||@expr1073755021 movedValue@var3534 .@expr1073755022 moveKind@var3535 ==@expr1073755023 ValueFlow ::@expr13191 Value ::@expr1073755025 MoveKind ::@expr1073755026 NonMovedVariable@expr1073754966 ) {
3172: continue ; }
3173: if (@expr1073755027 movedValue@var3534 .@expr13204 isInconclusive (@expr13205 ) &&@expr1073755030 !@expr1073755031 reportInconclusive@var3524 ) {
3174: continue ; }
3175:
3176: bool inconclusive@var3536 ; inconclusive@var3536 =@expr1073755032 false ;
3177: bool accessOfMoved@var3537 ; accessOfMoved@var3537 =@expr1073755033 false ;
3178: if (@expr1073755034 tok@var3532 .@expr1073755035 strAt (@expr1073755036 1 ) ==@expr1073755037 "." ) {
3179: if (@expr1073755038 tok@var3532 .@expr13189 next (@expr13190 ) .@expr1073755041 originalName (@expr1073755042 ) ==@expr1073755043 "->" ) {
3180: accessOfMoved@var3537 =@expr1073755044 true ; }
3181: else {
3182: inconclusive@var3536 =@expr1073755045 true ; }
3183: } else {
3184: const bool variableChanged@var3538 =@expr1073755046 isVariableChangedByFunctionCall (@expr1073755047 tok@var3532 , 0 , mSettings@var29 , &@expr1073755048 inconclusive@var3536 ) ;
3185: accessOfMoved@var3537 =@expr1073755049 !@expr1073755050 variableChanged@var3538 &&@expr1073755051 checkUninitVar@var3523 .@expr1073755052 isVariableUsage (@expr1073755053 tok@var3532 , false , CheckUninitVar ::@expr1073755054 NO_ALLOC ) ;
3186: if (@expr1073755055 inconclusive@var3536 ) {
3187: accessOfMoved@var3537 =@expr1073755056 !@expr1073755057 isMovedParameterAllowedForInconclusiveFunction (@expr1073755058 tok@var3532 ) ;
3188: if (@expr1073755059 accessOfMoved@var3537 ) {
3189: inconclusive@var3536 =@expr1073755060 false ; }
3190: }
3191: }
3192: if (@expr1073755061 accessOfMoved@var3537 ||@expr1073755062 (@expr1073755063 inconclusive@var3536 &&@expr1073755064 reportInconclusive@var3524 ) ) {
3193: accessMovedError (@expr1073755065 tok@var3532 , tok@var3532 .@expr1073755066 str (@expr1073755067 ) , movedValue@var3534 , inconclusive@var3536 ||@expr1073755068 movedValue@var3534 .@expr13204 isInconclusive (@expr13205 ) ) ; }
3194: }
3195: }
3196: }
3197:
3198: bool CheckOther :: isMovedParameterAllowedForInconclusiveFunction ( const Token * tok@var3539 )
3199: {
3200: if (@expr1073755071 Token ::@expr13248 simpleMatch (@expr1073755073 tok@var3539 .@expr13250 tokAt (@expr1073755075 -4 ) , "std :: move (" ) ) {
3201: return false ; }
3202: const Token * tokAtM2@var3540 ; tokAtM2@var3540 =@expr1073755076 tok@var3539 .@expr13250 tokAt (@expr1073755078 -2 ) ;
3203: if (@expr1073755079 Token ::@expr13248 simpleMatch (@expr1073755081 tokAtM2@var3540 , "> (" ) &&@expr1073755082 tokAtM2@var3540 .@expr13259 link (@expr13260 ) ) {
3204: const Token * leftAngle@var3541 ; leftAngle@var3541 =@expr1073755085 tokAtM2@var3540 .@expr13259 link (@expr13260 ) ;
3205: if (@expr1073755088 Token ::@expr13248 simpleMatch (@expr1073755090 leftAngle@var3541 .@expr1073755091 tokAt (@expr1073755092 -3 ) , "std :: forward <" ) ) {
3206: return false ; }
3207: }
3208: return true ;
3209: }
3210:
3211: void CheckOther :: accessMovedError ( const Token * tok@var3542 , const std :: string & varname@var3543 , const ValueFlow :: Value * value@var3544 , bool inconclusive@var3545 )
3212: {
3213: if (@expr1073755093 !@expr1073755094 tok@var3542 ) {
3214: reportError (@expr1073755095 tok@var3542 , Severity ::@expr13272 warning , "accessMoved" , "Access of moved variable 'v'." , CWE672@var2883 , Certainty ::@expr13273 normal ) ;
3215: reportError (@expr1073755098 tok@var3542 , Severity ::@expr13272 warning , "accessForwarded" , "Access of forwarded variable 'v'." , CWE672@var2883 , Certainty ::@expr13273 normal ) ;
3216: return ;
3217: }
3218:
3219: const char * errorId@var3546 ; errorId@var3546 =@expr1073755101 nullptr ;
3220: std ::@expr1073755102 string kindString@var3547 ;
3221: switch (@expr1073755103 value@var3544 .@expr1073755104 moveKind@var3548 ) {
3222: case ValueFlow ::@expr13281 Value ::@expr13282 MoveKind ::@expr1073755107 MovedVariable :@expr13284 ;
3223: errorId@var3546 =@expr1073755109 "accessMoved" ;
3224: kindString@var3547 =@expr1073755110 "moved" ;
3225: break ;
3226: case ValueFlow ::@expr13281 Value ::@expr13282 MoveKind ::@expr1073755113 ForwardedVariable :@expr13284 ;
3227: errorId@var3546 =@expr1073755115 "accessForwarded" ;
3228: kindString@var3547 =@expr1073755116 "forwarded" ;
3229: break ;
3230: default :@expr13284 ;
3231: return ;
3232: }
3233: const std ::@expr1073755118 string errmsg@var3549 (@expr1073755119 "$symbol:" +@expr1073755120 varname@var3543 +@expr1073755121 "\nAccess of " +@expr1073755122 kindString@var3547 +@expr1073755123 " variable '$symbol'." ) ;
3234: const std ::@expr1073755124 list < std ::@expr13301 pair < const Token *@expr1073755126 , std ::@expr13301 string > > errorPath@var3550 =@expr1073755128 getErrorPath (@expr1073755129 tok@var3542 , value@var3544 , errmsg@var3549 ) ;
3235: reportError (@expr1073755130 errorPath@var3550 , Severity ::@expr13272 warning , errorId@var3546 , errmsg@var3549 , CWE672@var2883 , inconclusive@var3545 ?@expr1073755132 Certainty ::@expr1073755133 inconclusive :@expr1073755134 Certainty ::@expr13273 normal ) ;
3236: }
3237:
3238:
3239:
3240: void CheckOther :: checkFuncArgNamesDifferent ( )
3241: {
3242: const bool style@var3551 =@expr1073755137 mSettings@var29 .@expr13314 severity@var3736 .@expr13315 isEnabled (@expr1073755140 Severity ::@expr1073755141 style ) ;
3243: const bool inconclusive@var3552 =@expr1073755142 mSettings@var29 .@expr1073755143 certainty@var3737 .@expr1073755144 isEnabled (@expr1073755145 Certainty ::@expr1073755146 inconclusive@expr1073755136 ) ;
3244: const bool warning@var3553 =@expr1073755147 mSettings@var29 .@expr13314 severity@var3736 .@expr13315 isEnabled (@expr1073755150 Severity ::@expr1073755151 warning ) ;
3245:
3246: if (@expr1073755152 !@expr1073755153 (@expr1073755154 warning@var3553 ||@expr1073755155 (@expr1073755156 style@var3551 &&@expr13333 inconclusive@var3552 ) ) ) {
3247: return ; }
3248:
3249: const SymbolDatabase * symbolDatabase@var3554 ; symbolDatabase@var3554 =@expr1073755158 mTokenizer@var28 .@expr1073755159 getSymbolDatabase (@expr1073755160 ) ;
3250:
3251: for (@expr1073755161 const Scope *@expr13338 scope@var3555 :@expr1073755163 symbolDatabase@var3554 .@expr1073755164 functionScopes@var3556 ) {
3252: const Function * function@var3557 ; function@var3557 =@expr1073755165 scope@var3555 .@expr1073755166 function@var3558 ;
3253:
3254: if (@expr1073755167 !@expr1073755168 function@var3557 ||@expr1073755169 function@var3557 .@expr13346 argCount (@expr13347 ) ==@expr1073755172 0 ) {
3255: continue ; }
3256:
3257:
3258: if (@expr1073755173 function@var3557 .@expr13350 argDef@var3559 ==@expr1073755175 function@var3557 .@expr13352 arg@var3560 ) {
3259: continue ; }
3260:
3261:
3262: std ::@expr1073755177 vector < const Token *@expr13338 > declarations@var3561 (@expr1073755179 function@var3557 .@expr13346 argCount (@expr13347 ) ) ;
3263: std ::@expr1073755182 vector < const Token *@expr13338 > definitions@var3562 (@expr1073755184 function@var3557 .@expr13346 argCount (@expr13347 ) ) ;
3264: const Token * decl@var3563 ; decl@var3563 =@expr1073755187 function@var3557 .@expr13350 argDef@var3559 .@expr13365 next (@expr13366 ) ;
3265: for (@expr1073755191 int j@var3564 =@expr1073755192 0 ; j@var3564 <@expr1073755193 function@var3557 .@expr13346 argCount (@expr13347 ) ; ++@expr1073755196 j@var3564 ) {
3266: declarations@var3561 [@expr13373 j@var3564 ] =@expr1073755198 nullptr ;
3267: definitions@var3562 [@expr13375 j@var3564 ] =@expr1073755200 nullptr ;
3268:
3269: const Variable * variable@var3565 ; variable@var3565 =@expr1073755201 function@var3557 .@expr1073755202 getArgumentVar (@expr1073755203 j@var3564 ) ;
3270: if (@expr1073755204 variable@var3565 ) {
3271: definitions@var3562 [@expr13375 j@var3564 ] =@expr1073755206 variable@var3565 .@expr1073755207 nameToken (@expr1073755208 ) ;
3272: }
3273:
3274: while (@expr1073755209 decl@var3563 &&@expr1073755210 !@expr1073755211 Token ::@expr1073755212 Match (@expr1073755213 decl@var3563 , ",|)|;" ) ) {
3275:
3276:
3277:
3278: if (@expr1073755214 decl@var3563 .@expr1073755215 str (@expr1073755216 ) ==@expr1073755217 "=" ) {
3279: decl@var3563 =@expr1073755218 decl@var3563 .@expr1073755219 nextArgument (@expr1073755220 ) ;
3280: break ;
3281: }
3282:
3283: if (@expr1073755221 decl@var3563 .@expr13398 link (@expr13399 ) ) {
3284: decl@var3563 =@expr1073755224 decl@var3563 .@expr13398 link (@expr13399 ) ; }
3285: else { if (@expr1073755227 decl@var3563 .@expr1073755228 varId (@expr1073755229 ) ) {
3286: declarations@var3561 [@expr13373 j@var3564 ] =@expr1073755231 decl@var3563 ; } }
3287: decl@var3563 =@expr1073755232 decl@var3563 .@expr13409 next (@expr13410 ) ;
3288: }
3289: if (@expr1073755235 Token ::@expr1073755236 simpleMatch (@expr1073755237 decl@var3563 , "," ) ) {
3290: decl@var3563 =@expr1073755238 decl@var3563 .@expr13409 next (@expr13410 ) ; }
3291: }
3292:
3293: if (@expr1073755241 warning@var3553 ) {
3294: bool order_different@var3566 ; order_different@var3566 =@expr1073755242 false ;
3295: for (@expr1073755243 int j@var3567 =@expr1073755244 0 ; j@var3567 <@expr1073755245 function@var3557 .@expr13346 argCount (@expr13347 ) ; ++@expr1073755248 j@var3567 ) {
3296: if (@expr1073755249 !@expr1073755250 declarations@var3561 [@expr13427 j@var3567 ] ||@expr1073755252 !@expr1073755253 definitions@var3562 [@expr13430 j@var3567 ] ||@expr1073755255 declarations@var3561 [@expr13427 j@var3567 ] .@expr13433 str (@expr13434 ) ==@expr1073755259 definitions@var3562 [@expr13430 j@var3567 ] .@expr1073755261 str (@expr1073755262 ) ) {
3297: continue ; }
3298:
3299: for (@expr1073755263 int k@var3568 =@expr1073755264 0 ; k@var3568 <@expr1073755265 function@var3557 .@expr13346 argCount (@expr13347 ) ; ++@expr1073755268 k@var3568 ) {
3300: if (@expr1073755269 j@var3567 !=@expr1073755270 k@var3568 &&@expr1073755271 definitions@var3562 [@expr13448 k@var3568 ] &&@expr1073755273 declarations@var3561 [@expr13427 j@var3567 ] .@expr13433 str (@expr13434 ) ==@expr1073755277 definitions@var3562 [@expr13448 k@var3568 ] .@expr1073755279 str (@expr1073755280 ) ) {
3301: order_different@var3566 =@expr1073755281 true ;
3302: break ;
3303: }
3304: }
3305: }
3306: if (@expr1073755282 order_different@var3566 ) {
3307: funcArgOrderDifferent (@expr1073755283 function@var3557 .@expr13460 name (@expr13461 ) , function@var3557 .@expr13350 argDef@var3559 .@expr13365 next (@expr13366 ) , function@var3557 .@expr13352 arg@var3560 .@expr1073755290 next (@expr1073755291 ) , declarations@var3561 , definitions@var3562 ) ;
3308: continue ;
3309: }
3310: }
3311:
3312: if (@expr1073755292 style@var3551 &&@expr13333 inconclusive@var3552 ) {
3313: for (@expr1073755294 int j@var3569 =@expr1073755295 0 ; j@var3569 <@expr1073755296 function@var3557 .@expr13346 argCount (@expr13347 ) ; ++@expr1073755299 j@var3569 ) {
3314: if (@expr1073755300 declarations@var3561 [@expr13477 j@var3569 ] &&@expr1073755302 definitions@var3562 [@expr13479 j@var3569 ] &&@expr1073755304 declarations@var3561 [@expr13477 j@var3569 ] .@expr1073755306 str (@expr1073755307 ) !=@expr1073755308 definitions@var3562 [@expr13479 j@var3569 ] .@expr1073755310 str (@expr1073755311 ) ) {
3315: funcArgNamesDifferent (@expr1073755312 function@var3557 .@expr13460 name (@expr13461 ) , j@var3569 , declarations@var3561 [@expr13477 j@var3569 ] , definitions@var3562 [@expr13479 j@var3569 ] ) ; }
3316: }
3317: }
3318: }
3319: }
3320:
3321: void CheckOther :: funcArgNamesDifferent ( const std :: string & functionName@var3570 , int index@var3571 ,
3322: const Token * declaration@var3572 , const Token * definition@var3573 )
3323: {
3324: std ::@expr1073755318 list < const Token *@expr1073755319 > tokens@var3574 ; tokens@var3574 =@expr1073755320 {@expr1073755321 declaration@var3572 , definition@var3573 } ;
3325: reportError (@expr1073755322 tokens@var3574 , Severity ::@expr1073755323 style , "funcArgNamesDifferent" ,
3326: "$symbol:" +@expr1073755324 functionName@var3570 +@expr1073755325 "\nFunction '$symbol' argument "
3327: +@expr1073755326 MathLib ::@expr1073755327 toString (@expr1073755328 index@var3571 +@expr1073755329 1 ) +@expr1073755330 " names different: declaration '" +@expr1073755331
3328: (@expr1073755332 declaration@var3572 ?@expr1073755333 declaration@var3572 .@expr1073755334 str (@expr1073755335 ) :@expr1073755336 std ::@expr13513 string (@expr1073755338 "A" ) ) +@expr1073755339 "' definition '" +@expr1073755340
3329: (@expr1073755341 definition@var3573 ?@expr1073755342 definition@var3573 .@expr1073755343 str (@expr1073755344 ) :@expr1073755345 std ::@expr13513 string (@expr1073755347 "B" ) ) +@expr1073755348 "'." , CWE628@var2884 , Certainty ::@expr1073755349 inconclusive@expr1073755317 ) ;
3330: }
3331:
3332: void CheckOther :: funcArgOrderDifferent ( const std :: string & functionName@var3575 ,
3333: const Token * declaration@var3576 , const Token * definition@var3577 ,
3334: const std :: vector < const Token * > & declarations@var3578 ,
3335: const std :: vector < const Token * > & definitions@var3579 )
3336: {
3337: std ::@expr1073755350 list < const Token *@expr1073755351 > tokens@var3580 ; tokens@var3580 =@expr1073755352 {@expr1073755353
3338: declarations@var3578 .@expr13530 size (@expr13531 ) ?@expr1073755356 (@expr1073755357 declarations@var3578 [@expr13534 0 ] ?@expr1073755359 declarations@var3578 [@expr13534 0 ] :@expr1073755361 declaration@var3576 ) :@expr1073755362 nullptr ,
3339: definitions@var3579 .@expr13539 size (@expr13540 ) ?@expr1073755365 (@expr1073755366 definitions@var3579 [@expr13543 0 ] ?@expr1073755368 definitions@var3579 [@expr13543 0 ] :@expr1073755370 definition@var3577 ) :@expr1073755371 nullptr
3340: } ;
3341: std ::@expr1073755372 string msg@var3581 ; msg@var3581 =@expr1073755373 "$symbol:" +@expr1073755374 functionName@var3575 +@expr1073755375 "\nFunction '$symbol' argument order different: declaration '" ;
3342: for (@expr1073755376 int i@var3582 =@expr1073755377 0 ; i@var3582 <@expr1073755378 declarations@var3578 .@expr13530 size (@expr13531 ) ; ++@expr1073755381 i@var3582 ) {
3343: if (@expr1073755382 i@var3582 !=@expr1073755383 0 ) {
3344: msg@var3581 +=@expr1073755384 ", " ; }
3345: if (@expr1073755385 declarations@var3578 [@expr13562 i@var3582 ] ) {
3346: msg@var3581 +=@expr1073755387 declarations@var3578 [@expr13562 i@var3582 ] .@expr1073755389 str (@expr1073755390 ) ; }
3347: }
3348: msg@var3581 +=@expr1073755391 "' definition '" ;
3349: for (@expr1073755392 int i@var3583 =@expr1073755393 0 ; i@var3583 <@expr1073755394 definitions@var3579 .@expr13539 size (@expr13540 ) ; ++@expr1073755397 i@var3583 ) {
3350: if (@expr1073755398 i@var3583 !=@expr1073755399 0 ) {
3351: msg@var3581 +=@expr1073755400 ", " ; }
3352: if (@expr1073755401 definitions@var3579 [@expr13578 i@var3583 ] ) {
3353: msg@var3581 +=@expr1073755403 definitions@var3579 [@expr13578 i@var3583 ] .@expr1073755405 str (@expr1073755406 ) ; }
3354: }
3355: msg@var3581 +=@expr1073755407 "'" ;
3356: reportError (@expr1073755408 tokens@var3580 , Severity ::@expr1073755409 warning , "funcArgOrderDifferent" , msg@var3581 , CWE683@var2885 , Certainty ::@expr1073755410 normal ) ;
3357: }
3358:
3359: static const Token * findShadowed ( const Scope * scope@var3584 , const std :: string & varname@var3585 , int linenr@var3586 )
3360: {
3361: if (@expr1073755411 !@expr1073755412 scope@var3584 ) {
3362: return nullptr ; }
3363: for (@expr1073755413 const Variable &@expr13590 var@var3587 :@expr1073755415 scope@var3584 .@expr1073755416 varlist@var3588 ) {
3364: if (@expr1073755417 scope@var3584 .@expr1073755418 isExecutable (@expr1073755419 ) &&@expr1073755420 var@var3587 .@expr13597 nameToken (@expr13598 ) .@expr1073755423 linenr (@expr1073755424 ) >@expr1073755425 linenr@var3586 ) {
3365: continue ; }
3366: if (@expr1073755426 var@var3587 .@expr1073755427 name (@expr1073755428 ) ==@expr1073755429 varname@var3585 ) {
3367: return var@var3587 .@expr13597 nameToken (@expr13598 ) ; }
3368: }
3369: for (@expr1073755432 const Function &@expr13590 f@var3589 :@expr1073755434 scope@var3584 .@expr1073755435 functionList@var3590 ) {
3370: if (@expr1073755436 f@var3589 .@expr1073755437 type@var3591 ==@expr1073755438 Function ::@expr1073755439 Type ::@expr1073755440 eFunction &&@expr1073755441 f@var3589 .@expr1073755442 name (@expr1073755443 ) ==@expr1073755444 varname@var3585 ) {
3371: return f@var3589 .@expr1073755445 tokenDef@var3592 ; }
3372: }
3373: if (@expr1073755446 scope@var3584 .@expr1073755447 type@var3593 ==@expr1073755448 Scope ::@expr1073755449 eLambda ) {
3374: return nullptr ; }
3375: const Token * shadowed@var3594 ; shadowed@var3594 =@expr1073755450 findShadowed (@expr1073755451 scope@var3584 .@expr1073755452 nestedIn@var3595 , varname@var3585 , linenr@var3586 ) ;
3376: if (@expr1073755453 !@expr1073755454 shadowed@var3594 ) {
3377: shadowed@var3594 =@expr1073755455 findShadowed (@expr1073755456 scope@var3584 .@expr1073755457 functionOf@var3596 , varname@var3585 , linenr@var3586 ) ; }
3378: return shadowed@var3594 ;
3379: }
3380:
3381: void CheckOther :: checkShadowVariables ( )
3382: {
3383: if (@expr1073755458 !@expr1073755459 mSettings@var29 .@expr1073755460 severity@var3736 .@expr1073755461 isEnabled (@expr1073755462 Severity ::@expr1073755463 style ) ) {
3384: return ; }
3385: const SymbolDatabase * symbolDatabase@var3597 ; symbolDatabase@var3597 =@expr1073755464 mTokenizer@var28 .@expr1073755465 getSymbolDatabase (@expr1073755466 ) ;
3386: for (@expr1073755467 const Scope &@expr13644 scope@var3598 :@expr1073755469 symbolDatabase@var3597 .@expr1073755470 scopeList@var3599 ) {
3387: if (@expr1073755471 !@expr1073755472 scope@var3598 .@expr1073755473 isExecutable (@expr1073755474 ) ||@expr1073755475 scope@var3598 .@expr13652 type@var3600 ==@expr1073755477 Scope ::@expr1073755478 eLambda ) {
3388: continue ; }
3389: const Scope * functionScope@var3601 ; functionScope@var3601 =@expr1073755479 &@expr1073755480 scope@var3598 ;
3390: while (@expr1073755481 functionScope@var3601 &&@expr1073755482 functionScope@var3601 .@expr13659 type@var3602 !=@expr1073755484 Scope ::@expr13661 ScopeType ::@expr13662 eFunction &&@expr1073755487 functionScope@var3601 .@expr13659 type@var3602 !=@expr1073755489 Scope ::@expr13661 ScopeType ::@expr1073755491 eLambda ) {
3391: functionScope@var3601 =@expr1073755492 functionScope@var3601 .@expr1073755493 nestedIn@var3603 ; }
3392: for (@expr1073755494 const Variable &@expr13644 var@var3604 :@expr1073755496 scope@var3598 .@expr1073755497 varlist@var3605 ) {
3393: if (@expr1073755498 var@var3604 .@expr13675 nameToken (@expr13676 ) &&@expr1073755501 var@var3604 .@expr13675 nameToken (@expr13676 ) .@expr1073755504 isExpandedMacro (@expr1073755505 ) ) {
3394: continue ; }
3395:
3396: if (@expr1073755506 functionScope@var3601 &&@expr1073755507 functionScope@var3601 .@expr13659 type@var3602 ==@expr1073755509 Scope ::@expr13661 ScopeType ::@expr13662 eFunction &&@expr1073755512 functionScope@var3601 .@expr13689 function@var3606 ) {
3397: bool shadowArg@var3607 ; shadowArg@var3607 =@expr1073755514 false ;
3398: for (@expr1073755515 const Variable &@expr13644 arg@var3608 :@expr1073755517 functionScope@var3601 .@expr13689 function@var3606 .@expr1073755519 argumentList@var3609 ) {
3399: if (@expr1073755520 arg@var3608 .@expr13697 nameToken (@expr13698 ) &&@expr1073755523 var@var3604 .@expr13700 name (@expr13701 ) ==@expr1073755526 arg@var3608 .@expr1073755527 name (@expr1073755528 ) ) {
3400: shadowError (@expr1073755529 var@var3604 .@expr13675 nameToken (@expr13676 ) , arg@var3608 .@expr13697 nameToken (@expr13698 ) , "argument" ) ;
3401: shadowArg@var3607 =@expr1073755534 true ;
3402: break ;
3403: }
3404: }
3405: if (@expr1073755535 shadowArg@var3607 ) {
3406: continue ; }
3407: }
3408:
3409: const Token * shadowed@var3610 ; shadowed@var3610 =@expr1073755536 findShadowed (@expr1073755537 scope@var3598 .@expr1073755538 nestedIn@var3611 , var@var3604 .@expr13700 name (@expr13701 ) , var@var3604 .@expr13675 nameToken (@expr13676 ) .@expr13719 linenr (@expr13720 ) ) ;
3410: if (@expr13721 !@expr13722 shadowed@var3610 ) {
3411: shadowed@var3610 =@expr1073755547 findShadowed (@expr1073755548 scope@var3598 .@expr1073755549 functionOf@var3612 , var@var3604 .@expr13700 name (@expr13701 ) , var@var3604 .@expr13675 nameToken (@expr13676 ) .@expr13719 linenr (@expr13720 ) ) ; }
3412: if (@expr13721 !@expr13722 shadowed@var3610 ) {
3413: continue ; }
3414: if (@expr1073755558 scope@var3598 .@expr13652 type@var3600 ==@expr1073755560 Scope ::@expr1073755561 eFunction &&@expr1073755562 scope@var3598 .@expr1073755563 className@var3613 ==@expr1073755564 var@var3604 .@expr13700 name (@expr13701 ) ) {
3415: continue ; }
3416: if (@expr1073755567 functionScope@var3601 .@expr13744 functionOf@var3614 &&@expr1073755569 functionScope@var3601 .@expr13744 functionOf@var3614 .@expr1073755571 isClassOrStructOrUnion (@expr1073755572 ) &&@expr1073755573 functionScope@var3601 .@expr13689 function@var3606 &&@expr1073755575 functionScope@var3601 .@expr13689 function@var3606 .@expr1073755577 isStatic (@expr1073755578 ) &&@expr1073755579
3417: shadowed@var3610 .@expr13756 variable (@expr13757 ) &&@expr1073755582 !@expr1073755583 shadowed@var3610 .@expr13756 variable (@expr13757 ) .@expr1073755586 isLocal (@expr1073755587 ) ) {
3418: continue ; }
3419: shadowError (@expr1073755588 var@var3604 .@expr13675 nameToken (@expr13676 ) , shadowed@var3610 , (@expr1073755591 shadowed@var3610 .@expr1073755592 varId (@expr1073755593 ) !=@expr1073755594 0 ) ?@expr1073755595 "variable" :@expr1073755596 "function" ) ;
3420: }
3421: }
3422: }
3423:
3424: void CheckOther :: shadowError ( const Token * var@var3615 , const Token * shadowed@var3616 , std :: string type@var3617 )
3425: {
3426: std ::@expr1073755597 list < std ::@expr13774 pair < const Token *@expr13775 , std ::@expr13774 string > > errorPath@var3618 ;
3427: errorPath@var3618 .@expr13777 push_back (@expr1073755602 std ::@expr13779 pair < const Token *@expr13775 , std ::@expr13774 string > (@expr1073755606 shadowed@var3616 , "Shadowed declaration" ) ) ;
3428: errorPath@var3618 .@expr13777 push_back (@expr1073755608 std ::@expr13779 pair < const Token *@expr13775 , std ::@expr13774 string > (@expr1073755612 var@var3615 , "Shadow variable" ) ) ;
3429: const std ::@expr13774 string &@expr1073755614 varname@var3619 =@expr1073755615 var@var3615 ?@expr1073755616 var@var3615 .@expr1073755617 str (@expr1073755618 ) :@expr1073755619 type@var3617 ;
3430: const std ::@expr13774 string Type@var3620 =@expr1073755621 char (@expr1073755622 std ::@expr1073755623 toupper (@expr1073755624 type@var3617 [@expr1073755625 0 ] ) ) +@expr1073755626 type@var3617 .@expr1073755627 substr (@expr1073755628 1 ) ;
3431: const std ::@expr13774 string id@var3621 =@expr1073755630 "shadow" +@expr1073755631 Type@var3620 ;
3432: const std ::@expr13774 string message@var3622 =@expr1073755633 "$symbol:" +@expr1073755634 varname@var3619 +@expr1073755635 "\nLocal variable \'$symbol\' shadows outer " +@expr1073755636 type@var3617 ;
3433: reportError (@expr1073755637 errorPath@var3618 , Severity ::@expr1073755638 style , id@var3621 .@expr1073755639 c_str (@expr1073755640 ) , message@var3622 , CWE398@var2876 , Certainty ::@expr1073755641 normal ) ;
3434: }
3435:
3436: static bool isVariableExpression ( const Token * tok@var3623 )
3437: {
3438: if (@expr1073755642 Token ::@expr1073755643 Match (@expr1073755644 tok@var3623 , "%var%" ) ) {
3439: return true ; }
3440: if (@expr1073755645 Token ::@expr13822 simpleMatch (@expr1073755647 tok@var3623 , "." ) ) {
3441: return isVariableExpression (@expr13824 tok@var3623 .@expr13825 astOperand1 (@expr13826 ) ) &&@expr1073755651
3442: isVariableExpression (@expr1073755652 tok@var3623 .@expr13829 astOperand2 (@expr13830 ) ) ; }
3443: if (@expr1073755655 Token ::@expr13822 simpleMatch (@expr1073755657 tok@var3623 , "[" ) ) {
3444: return isVariableExpression (@expr13824 tok@var3623 .@expr13825 astOperand1 (@expr13826 ) ) &&@expr1073755661
3445: tok@var3623 .@expr13829 astOperand2 (@expr13830 ) &&@expr1073755664 tok@var3623 .@expr13829 astOperand2 (@expr13830 ) .@expr1073755667 hasKnownIntValue (@expr1073755668 ) ; }
3446: return false ;
3447: }
3448:
3449: void CheckOther :: checkKnownArgument ( )
3450: {
3451: if (@expr1073755670 !@expr1073755671 mSettings@var29 .@expr1073755672 severity@var3736 .@expr1073755673 isEnabled (@expr1073755674 Severity ::@expr1073755675 style ) ) {
3452: return ; }
3453: const SymbolDatabase * symbolDatabase@var3624 ; symbolDatabase@var3624 =@expr1073755676 mTokenizer@var28 .@expr1073755677 getSymbolDatabase (@expr1073755678 ) ;
3454: for (@expr1073755679 const Scope *@expr13856 functionScope@var3625 :@expr1073755681 symbolDatabase@var3624 .@expr1073755682 functionScopes@var3626 ) {
3455: for (@expr1073755683 const Token *@expr13856 tok@var3627 =@expr1073755685 functionScope@var3625 .@expr1073755686 bodyStart@var3628 ; tok@var3627 !=@expr1073755687 functionScope@var3625 .@expr1073755688 bodyEnd@var3629 ; tok@var3627 =@expr1073755689 tok@var3627 .@expr1073755690 next (@expr1073755691 ) ) {
3456: if (@expr1073755692 !@expr1073755693 Token ::@expr13870 simpleMatch (@expr1073755695 tok@var3627 .@expr13872 astParent (@expr13873 ) , "(" ) ) {
3457: continue ; }
3458: if (@expr1073755698 !@expr1073755699 Token ::@expr13876 Match (@expr1073755701 tok@var3627 .@expr13872 astParent (@expr13873 ) .@expr13880 previous (@expr13881 ) , "%name%" ) ) {
3459: continue ; }
3460: if (@expr1073755706 Token ::@expr13876 Match (@expr1073755708 tok@var3627 .@expr13872 astParent (@expr13873 ) .@expr13880 previous (@expr13881 ) , "if|while|switch|sizeof" ) ) {
3461: continue ; }
3462: if (@expr1073755713 tok@var3627 ==@expr1073755714 tok@var3627 .@expr13872 astParent (@expr13873 ) .@expr13880 previous (@expr13881 ) ) {
3463: continue ; }
3464: if (@expr1073755719 !@expr1073755720 tok@var3627 .@expr1073755721 hasKnownIntValue (@expr1073755722 ) ) {
3465: continue ; }
3466: if (@expr1073755723 Token ::@expr13876 Match (@expr1073755725 tok@var3627 , "++|--" ) ) {
3467: continue ; }
3468: if (@expr1073755726 isConstVarExpression (@expr1073755727 tok@var3627 ) ) {
3469: continue ; }
3470: const Token * tok2@var3630 ; tok2@var3630 =@expr1073755728 tok@var3627 ;
3471: if (@expr1073755729 isCPPCast (@expr1073755730 tok2@var3630 ) ) {
3472: tok2@var3630 =@expr1073755731 tok2@var3630 .@expr1073755732 astOperand2 (@expr1073755733 ) ; }
3473: if (@expr1073755734 isVariableExpression (@expr1073755735 tok2@var3630 ) ) {
3474: continue ; }
3475:
3476: std ::@expr1073755736 string varexpr@var3631 ;
3477: bool isVariableExprHidden@var3632 ; isVariableExprHidden@var3632 =@expr1073755737 false ;
3478: auto setVarExpr@var3633 ; setVarExpr@var3633 =@expr1073755738 [@expr1073755739 &@expr1073755740 varexpr@var3631 , &@expr1073755741 isVariableExprHidden@var3632 ] (@expr1073755742 const Token *@expr13856 child@var3634 ) {
3479: if (@expr1073755744 Token ::@expr13876 Match (@expr1073755746 child@var3634 , "%var%|.|[" ) ) {
3480: if (@expr1073755747 child@var3634 .@expr13924 valueType (@expr13925 ) &&@expr1073755750 child@var3634 .@expr13924 valueType (@expr13925 ) .@expr1073755753 pointer@var3766 ==@expr1073755754 0 &&@expr1073755755 child@var3634 .@expr13924 valueType (@expr13925 ) .@expr1073755758 isIntegral (@expr1073755759 ) &&@expr1073755760 child@var3634 .@expr1073755761 values (@expr1073755762 ) .@expr1073755763 empty (@expr1073755764 ) ) {
3481: varexpr@var3631 =@expr1073755765 child@var3634 .@expr1073755766 expressionString (@expr1073755767 ) ;
3482: return ChildrenToVisit ::@expr1073755768 done ;
3483: }
3484: return ChildrenToVisit ::@expr13945 none ;
3485: }
3486: if (@expr1073755770 Token ::@expr13870 simpleMatch (@expr1073755772 child@var3634 .@expr1073755773 previous (@expr1073755774 ) , "sizeof (" ) ) {
3487: return ChildrenToVisit ::@expr13945 none ; }
3488:
3489:
3490: if (@expr1073755776 !@expr1073755777 isVariableExprHidden@var3632 ) {
3491: if (@expr1073755778 Token ::@expr13870 simpleMatch (@expr1073755780 child@var3634 , "*" ) &&@expr1073755781 (@expr1073755782 Token ::@expr13870 simpleMatch (@expr1073755784 child@var3634 .@expr13961 astOperand1 (@expr13962 ) , "0" ) ||@expr1073755787 Token ::@expr13870 simpleMatch (@expr1073755789 child@var3634 .@expr13966 astOperand2 (@expr13967 ) , "0" ) ) ) {
3492: return ChildrenToVisit ::@expr13945 none ; }
3493: if (@expr1073755793 Token ::@expr13870 simpleMatch (@expr1073755795 child@var3634 , "&&" ) &&@expr1073755796 (@expr1073755797 Token ::@expr13870 simpleMatch (@expr1073755799 child@var3634 .@expr13961 astOperand1 (@expr13962 ) , "false" ) ||@expr1073755802 Token ::@expr13870 simpleMatch (@expr1073755804 child@var3634 .@expr13966 astOperand2 (@expr13967 ) , "false" ) ) ) {
3494: return ChildrenToVisit ::@expr13945 none ; }
3495: if (@expr1073755808 Token ::@expr13870 simpleMatch (@expr1073755810 child@var3634 , "||" ) &&@expr1073755811 (@expr1073755812 Token ::@expr13870 simpleMatch (@expr1073755814 child@var3634 .@expr13961 astOperand1 (@expr13962 ) , "true" ) ||@expr1073755817 Token ::@expr13870 simpleMatch (@expr1073755819 child@var3634 .@expr13966 astOperand2 (@expr13967 ) , "true" ) ) ) {
3496: return ChildrenToVisit ::@expr13945 none ; }
3497: }
3498:
3499: return ChildrenToVisit ::@expr1073755823 op1_and_op2 ;
3500: } ;
3501: visitAstNodes (@expr14000 tok@var3627 , setVarExpr@var3633 ) ;
3502: if (@expr14001 varexpr@var3631 .@expr14002 empty (@expr14003 ) ) {
3503: isVariableExprHidden@var3632 =@expr1073755828 true ;
3504: visitAstNodes (@expr14000 tok@var3627 , setVarExpr@var3633 ) ;
3505: }
3506: if (@expr14001 varexpr@var3631 .@expr14002 empty (@expr14003 ) ) {
3507: continue ; }
3508:
3509: std ::@expr1073755833 string funcname@var3635 ; funcname@var3635 =@expr1073755834 tok@var3627 .@expr13872 astParent (@expr13873 ) .@expr13880 previous (@expr13881 ) .@expr1073755839 str (@expr1073755840 ) ;
3510: strTolower (@expr1073755841 funcname@var3635 ) ;
3511: if (@expr1073755842 funcname@var3635 .@expr1073755843 find (@expr1073755844 "assert" ) !=@expr1073755845 std ::@expr1073755846 string ::@expr1073755847 npos@expr1073755669 ) {
3512: continue ; }
3513: knownArgumentError (@expr1073755848 tok@var3627 , tok@var3627 .@expr13872 astParent (@expr13873 ) .@expr13880 previous (@expr13881 ) , &@expr1073755853 tok@var3627 .@expr1073755854 values (@expr1073755855 ) .@expr1073755856 front (@expr1073755857 ) , varexpr@var3631 , isVariableExprHidden@var3632 ) ;
3514: }
3515: }
3516: }
3517:
3518: void CheckOther :: knownArgumentError ( const Token * tok@var3636 , const Token * ftok@var3637 , const ValueFlow :: Value * value@var3638 , const std :: string & varexpr@var3639 , bool isVariableExpressionHidden@var3640 )
3519: {
3520: if (@expr1073755858 !@expr1073755859 tok@var3636 ) {
3521: reportError (@expr1073755860 tok@var3636 , Severity ::@expr14037 style , "knownArgument" , "Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has." ) ;
3522: reportError (@expr1073755862 tok@var3636 , Severity ::@expr14037 style , "knownArgumentHiddenVariableExpression" , "Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'." ) ;
3523: return ;
3524: }
3525:
3526: const long long intvalue@var3641 =@expr1073755864 value@var3638 .@expr1073755865 intvalue@var3642 ;
3527: const std ::@expr14042 string &@expr14043 expr@var3643 =@expr1073755868 tok@var3636 .@expr1073755869 expressionString (@expr1073755870 ) ;
3528: const std ::@expr14042 string &@expr14043 fun@var3644 =@expr1073755873 ftok@var3637 .@expr1073755874 str (@expr1073755875 ) ;
3529:
3530: const char * id@var3645 ;
3531: std ::@expr1073755876 string errmsg@var3646 ; errmsg@var3646 =@expr1073755877 "Argument '" +@expr1073755878 expr@var3643 +@expr1073755879 "' to function " +@expr1073755880 fun@var3644 +@expr1073755881 " is always " +@expr1073755882 std ::@expr1073755883 to_string (@expr1073755884 intvalue@var3641 ) +@expr1073755885 ". " ;
3532: if (@expr1073755886 !@expr1073755887 isVariableExpressionHidden@var3640 ) {
3533: id@var3645 =@expr1073755888 "knownArgument" ;
3534: errmsg@var3646 +=@expr1073755889 "It does not matter what value '" +@expr1073755890 varexpr@var3639 +@expr1073755891 "' has." ;
3535: } else {
3536: id@var3645 =@expr1073755892 "knownArgumentHiddenVariableExpression" ;
3537: errmsg@var3646 +=@expr1073755893 "Constant literal calculation disable/hide variable expression '" +@expr1073755894 varexpr@var3639 +@expr1073755895 "'." ;
3538: }
3539:
3540: const std ::@expr1073755896 list < std ::@expr14042 pair < const Token *@expr1073755898 , std ::@expr14042 string > > errorPath@var3647 =@expr1073755900 getErrorPath (@expr1073755901 tok@var3636 , value@var3638 , errmsg@var3646 ) ;
3541: reportError (@expr1073755902 errorPath@var3647 , Severity ::@expr14037 style , id@var3645 , errmsg@var3646 , CWE570@var2881 , Certainty ::@expr1073755904 normal ) ;
3542: }
3543:
3544: void CheckOther :: checkComparePointers ( )
3545: {
3546: const SymbolDatabase * symbolDatabase@var3648 ; symbolDatabase@var3648 =@expr1073755905 mTokenizer@var28 .@expr1073755906 getSymbolDatabase (@expr1073755907 ) ;
3547: for (@expr1073755908 const Scope *@expr14085 functionScope@var3649 :@expr1073755910 symbolDatabase@var3648 .@expr1073755911 functionScopes@var3650 ) {
3548: for (@expr1073755912 const Token *@expr14085 tok@var3651 =@expr1073755914 functionScope@var3649 .@expr1073755915 bodyStart@var3652 ; tok@var3651 !=@expr1073755916 functionScope@var3649 .@expr1073755917 bodyEnd@var3653 ; tok@var3651 =@expr1073755918 tok@var3651 .@expr1073755919 next (@expr1073755920 ) ) {
3549: if (@expr1073755921 !@expr1073755922 Token ::@expr1073755923 Match (@expr1073755924 tok@var3651 , "<|>|<=|>=|-" ) ) {
3550: continue ; }
3551: const Token * tok1@var3654 ; tok1@var3654 =@expr1073755925 tok@var3651 .@expr1073755926 astOperand1 (@expr1073755927 ) ;
3552: const Token * tok2@var3655 ; tok2@var3655 =@expr1073755928 tok@var3651 .@expr1073755929 astOperand2 (@expr1073755930 ) ;
3553: if (@expr1073755931 !@expr1073755932 astIsPointer (@expr1073755933 tok1@var3654 ) ||@expr1073755934 !@expr1073755935 astIsPointer (@expr1073755936 tok2@var3655 ) ) {
3554: continue ; }
3555: ValueFlow ::@expr1073755937 Value v1@var3656 ; v1@var3656 =@expr1073755938 getLifetimeObjValue (@expr1073755939 tok1@var3654 ) ;
3556: ValueFlow ::@expr1073755940 Value v2@var3657 ; v2@var3657 =@expr1073755941 getLifetimeObjValue (@expr1073755942 tok2@var3655 ) ;
3557: if (@expr1073755943 !@expr1073755944 v1@var3656 .@expr1073755945 isLocalLifetimeValue (@expr1073755946 ) ||@expr1073755947 !@expr1073755948 v2@var3657 .@expr1073755949 isLocalLifetimeValue (@expr1073755950 ) ) {
3558: continue ; }
3559: const Variable * var1@var3658 ; var1@var3658 =@expr1073755951 v1@var3656 .@expr14128 tokvalue@var3659 .@expr1073755953 variable (@expr1073755954 ) ;
3560: const Variable * var2@var3660 ; var2@var3660 =@expr1073755955 v2@var3657 .@expr14132 tokvalue@var3661 .@expr1073755957 variable (@expr1073755958 ) ;
3561: if (@expr1073755959 !@expr1073755960 var1@var3658 ||@expr1073755961 !@expr1073755962 var2@var3660 ) {
3562: continue ; }
3563: if (@expr1073755963 v1@var3656 .@expr14128 tokvalue@var3659 .@expr1073755965 varId (@expr1073755966 ) ==@expr1073755967 v2@var3657 .@expr14132 tokvalue@var3661 .@expr1073755969 varId (@expr1073755970 ) ) {
3564: continue ; }
3565: if (@expr1073755971 var1@var3658 .@expr1073755972 isReference (@expr1073755973 ) ||@expr1073755974 var2@var3660 .@expr1073755975 isReference (@expr1073755976 ) ) {
3566: continue ; }
3567: if (@expr1073755977 var1@var3658 .@expr1073755978 isRValueReference (@expr1073755979 ) ||@expr1073755980 var2@var3660 .@expr1073755981 isRValueReference (@expr1073755982 ) ) {
3568: continue ; }
3569: comparePointersError (@expr1073755983 tok@var3651 , &@expr1073755984 v1@var3656 , &@expr1073755985 v2@var3657 ) ;
3570: }
3571: }
3572: }
3573:
3574: void CheckOther :: comparePointersError ( const Token * tok@var3662 , const ValueFlow :: Value * v1@var3663 , const ValueFlow :: Value * v2@var3664 )
3575: {
3576: std ::@expr1073755986 list < std ::@expr14163 pair < const Token *@expr1073755988 , std ::@expr14163 string > > errorPath@var3665 ;
3577: std ::@expr1073755990 string verb@var3666 ; verb@var3666 =@expr1073755991 "Comparing" ;
3578: if (@expr1073755992 Token ::@expr1073755993 simpleMatch (@expr1073755994 tok@var3662 , "-" ) ) {
3579: verb@var3666 =@expr1073755995 "Subtracting" ; }
3580: if (@expr1073755996 v1@var3663 ) {
3581: errorPath@var3665 .@expr14173 emplace_back (@expr1073755998 v1@var3663 .@expr1073755999 tokvalue@var3667 .@expr1073756000 variable (@expr1073756001 ) .@expr1073756002 nameToken (@expr1073756003 ) , "Variable declared here." ) ;
3582: errorPath@var3665 .@expr14180 insert (@expr1073756005 errorPath@var3665 .@expr14182 end (@expr14183 ) , v1@var3663 .@expr14184 errorPath@var3668 .@expr1073756009 begin (@expr1073756010 ) , v1@var3663 .@expr14184 errorPath@var3668 .@expr1073756012 end (@expr1073756013 ) ) ;
3583: }
3584: if (@expr1073756014 v2@var3664 ) {
3585: errorPath@var3665 .@expr14173 emplace_back (@expr1073756016 v2@var3664 .@expr1073756017 tokvalue@var3669 .@expr1073756018 variable (@expr1073756019 ) .@expr1073756020 nameToken (@expr1073756021 ) , "Variable declared here." ) ;
3586: errorPath@var3665 .@expr14180 insert (@expr1073756023 errorPath@var3665 .@expr14182 end (@expr14183 ) , v2@var3664 .@expr14202 errorPath@var3670 .@expr1073756027 begin (@expr1073756028 ) , v2@var3664 .@expr14202 errorPath@var3670 .@expr1073756030 end (@expr1073756031 ) ) ;
3587: }
3588: errorPath@var3665 .@expr14173 emplace_back (@expr1073756033 tok@var3662 , "" ) ;
3589: reportError (@expr1073756034
3590: errorPath@var3665 , Severity ::@expr1073756035 error , "comparePointers" , verb@var3666 +@expr1073756036 " pointers that point to different objects" , CWE570@var2881 , Certainty ::@expr1073756037 normal ) ;
3591: }
3592:
3593: void CheckOther :: checkModuloOfOne ( )
3594: {
3595: if (@expr1073756038 !@expr1073756039 mSettings@var29 .@expr1073756040 severity@var3736 .@expr1073756041 isEnabled (@expr1073756042 Severity ::@expr1073756043 style ) ) {
3596: return ; }
3597:
3598: for (@expr1073756044 const Token *@expr1073756045 tok@var3671 =@expr1073756046 mTokenizer@var28 .@expr1073756047 tokens (@expr1073756048 ) ; tok@var3671 ; tok@var3671 =@expr1073756049 tok@var3671 .@expr1073756050 next (@expr1073756051 ) ) {
3599: if (@expr1073756052 !@expr1073756053 tok@var3671 .@expr14230 astOperand2 (@expr14231 ) ||@expr1073756056 !@expr1073756057 tok@var3671 .@expr1073756058 astOperand1 (@expr1073756059 ) ) {
3600: continue ; }
3601: if (@expr1073756060 tok@var3671 .@expr1073756061 str (@expr1073756062 ) !=@expr1073756063 "%" ) {
3602: continue ; }
3603: if (@expr1073756064 !@expr1073756065 tok@var3671 .@expr14242 valueType (@expr14243 ) ||@expr1073756068 !@expr1073756069 tok@var3671 .@expr14242 valueType (@expr14243 ) .@expr1073756072 isIntegral (@expr1073756073 ) ) {
3604: continue ; }
3605:
3606:
3607: const ValueFlow ::@expr1073756074 Value * value@var3672 ; value@var3672 =@expr1073756075 tok@var3671 .@expr14230 astOperand2 (@expr14231 ) .@expr1073756078 getValue (@expr1073756079 1LL ) ;
3608: if (@expr1073756080 value@var3672 &&@expr1073756081 value@var3672 .@expr1073756082 isKnown (@expr1073756083 ) ) {
3609: checkModuloOfOneError (@expr1073756084 tok@var3671 ) ; }
3610: }
3611: }
3612:
3613: void CheckOther :: checkModuloOfOneError ( const Token * tok@var3673 )
3614: {
3615: reportError (@expr1073756085 tok@var3673 , Severity ::@expr1073756086 style , "moduloofone" , "Modulo of one is always equal to zero" ) ;
3616: }
3617:
|
3620:
3621: static bool getBufAndOffset ( const Token * expr@var3674 , const Token * * buf@var3675 , long long * offset@var3676 )
3622: {
3623: if (@expr1073756087 !@expr1073756088 expr@var3674 ) {
3624: return false ; }
3625: const Token * bufToken@var3677 ; const Token * offsetToken@var3678 ;
3626: if (@expr1073756089 expr@var3674 .@expr1073756090 isUnaryOp (@expr1073756091 "&" ) &&@expr1073756092 Token ::@expr1073756093 simpleMatch (@expr1073756094 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) , "[" ) ) {
3627: bufToken@var3677 =@expr1073756097 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) .@expr1073756100 astOperand1 (@expr1073756101 ) ;
3628: offsetToken@var3678 =@expr1073756102 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) .@expr1073756105 astOperand2 (@expr1073756106 ) ;
3629: } else { if (@expr1073756107 Token ::@expr1073756108 Match (@expr1073756109 expr@var3674 , "+|-" ) &&@expr1073756110 expr@var3674 .@expr1073756111 isBinaryOp (@expr1073756112 ) ) {
3630: const bool pointer1@var3679 =@expr1073756113 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) .@expr14292 valueType (@expr14293 ) &&@expr1073756118 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) .@expr14292 valueType (@expr14293 ) .@expr1073756123 pointer@var3770 >@expr1073756124 0 ;
3631: const bool pointer2@var3680 =@expr1073756125 expr@var3674 .@expr14302 astOperand2 (@expr14303 ) .@expr14304 valueType (@expr14305 ) &&@expr1073756130 expr@var3674 .@expr14302 astOperand2 (@expr14303 ) .@expr14304 valueType (@expr14305 ) .@expr1073756135 pointer@var3770 >@expr1073756136 0 ;
3632: if (@expr1073756137 pointer1@var3679 &&@expr1073756138 !@expr1073756139 pointer2@var3680 ) {
3633: bufToken@var3677 =@expr1073756140 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) ;
3634: offsetToken@var3678 =@expr1073756143 expr@var3674 .@expr14302 astOperand2 (@expr14303 ) ;
3635: } else { if (@expr1073756146 !@expr1073756147 pointer1@var3679 &&@expr1073756148 pointer2@var3680 ) {
3636: bufToken@var3677 =@expr1073756149 expr@var3674 .@expr14302 astOperand2 (@expr14303 ) ;
3637: offsetToken@var3678 =@expr1073756152 expr@var3674 .@expr14271 astOperand1 (@expr14272 ) ;
3638: } else {
3639: return false ;
3640: } }
3641: } else { if (@expr1073756155 expr@var3674 .@expr14332 valueType (@expr14333 ) &&@expr1073756158 expr@var3674 .@expr14332 valueType (@expr14333 ) .@expr1073756161 pointer@var3766 >@expr1073756162 0 ) {
3642: *@expr14339 buf@var3675 =@expr1073756164 expr@var3674 ;
3643: *@expr14341 offset@var3676 =@expr1073756166 0 ;
3644: return true ;
3645: } else {
3646: return false ;
3647: } } }
3648: if (@expr1073756167 !@expr1073756168 bufToken@var3677 .@expr14345 valueType (@expr14346 ) ||@expr1073756171 !@expr1073756172 bufToken@var3677 .@expr14345 valueType (@expr14346 ) .@expr1073756175 pointer@var3766 ) {
3649: return false ; }
3650: if (@expr1073756176 !@expr1073756177 offsetToken@var3678 .@expr1073756178 hasKnownIntValue (@expr1073756179 ) ) {
3651: return false ; }
3652: *@expr14339 buf@var3675 =@expr1073756181 bufToken@var3677 ;
3653: *@expr14341 offset@var3676 =@expr1073756183 offsetToken@var3678 .@expr1073756184 getKnownIntValue (@expr1073756185 ) ;
3654: return true ;
3655: }
3656:
3657: void CheckOther :: checkOverlappingWrite ( )
3658: {
3659: const SymbolDatabase * symbolDatabase@var3681 ; symbolDatabase@var3681 =@expr1073756186 mTokenizer@var28 .@expr1073756187 getSymbolDatabase (@expr1073756188 ) ;
3660: for (@expr1073756189 const Scope *@expr14366 functionScope@var3682 :@expr1073756191 symbolDatabase@var3681 .@expr1073756192 functionScopes@var3683 ) {
3661: for (@expr1073756193 const Token *@expr14366 tok@var3684 =@expr1073756195 functionScope@var3682 .@expr1073756196 bodyStart@var3685 ; tok@var3684 !=@expr1073756197 functionScope@var3682 .@expr1073756198 bodyEnd@var3686 ; tok@var3684 =@expr1073756199 tok@var3684 .@expr1073756200 next (@expr1073756201 ) ) {
3662: if (@expr1073756202 tok@var3684 .@expr1073756203 isAssignmentOp (@expr1073756204 ) ) {
3663:
3664: const Token * const lhs@var3687 ; lhs@var3687 =@expr1073756205 tok@var3684 .@expr1073756206 astOperand1 (@expr1073756207 ) ;
3665: if (@expr1073756208 !@expr1073756209 Token ::@expr14386 simpleMatch (@expr1073756211 lhs@var3687 , "." ) ||@expr1073756212 !@expr1073756213 lhs@var3687 .@expr1073756214 isBinaryOp (@expr1073756215 ) ) {
3666: continue ; }
3667: const Variable * const lhsvar@var3688 ; lhsvar@var3688 =@expr1073756216 lhs@var3687 .@expr1073756217 astOperand1 (@expr1073756218 ) .@expr1073756219 variable (@expr1073756220 ) ;
3668: if (@expr1073756221 !@expr1073756222 lhsvar@var3688 ||@expr1073756223 !@expr1073756224 lhsvar@var3688 .@expr14401 typeScope (@expr14402 ) ||@expr1073756227 lhsvar@var3688 .@expr14401 typeScope (@expr14402 ) .@expr1073756230 type@var3755 !=@expr1073756231 Scope ::@expr1073756232 ScopeType ::@expr1073756233 eUnion ) {
3669: continue ; }
3670: const Token * const lhsmember@var3689 ; lhsmember@var3689 =@expr1073756234 lhs@var3687 .@expr1073756235 astOperand2 (@expr1073756236 ) ;
3671: if (@expr1073756237 !@expr1073756238 lhsmember@var3689 ) {
3672: continue ; }
3673:
3674:
3675: const Token * errorToken@var3690 ; errorToken@var3690 =@expr1073756239 nullptr ;
3676: visitAstNodes (@expr1073756240 tok@var3684 .@expr1073756241 astOperand2 (@expr1073756242 ) , [@expr1073756243 lhsvar@var3688 , lhsmember@var3689 , &@expr1073756244 errorToken@var3690 ] (@expr1073756245 const Token *@expr14366 rhs@var3691 ) {
3677: if (@expr1073756247 !@expr1073756248 Token ::@expr14386 simpleMatch (@expr1073756250 rhs@var3691 , "." ) ) {
3678: return ChildrenToVisit ::@expr1073756251 op1_and_op2 ; }
3679: if (@expr1073756252 !@expr1073756253 rhs@var3691 .@expr1073756254 isBinaryOp (@expr1073756255 ) ||@expr1073756256 rhs@var3691 .@expr1073756257 astOperand1 (@expr1073756258 ) .@expr1073756259 variable (@expr1073756260 ) !=@expr1073756261 lhsvar@var3688 ) {
3680: return ChildrenToVisit ::@expr14438 none ; }
3681: if (@expr1073756263 lhsmember@var3689 .@expr1073756264 str (@expr1073756265 ) ==@expr1073756266 rhs@var3691 .@expr14443 astOperand2 (@expr14444 ) .@expr1073756269 str (@expr1073756270 ) ) {
3682: return ChildrenToVisit ::@expr14438 none ; }
3683: errorToken@var3690 =@expr1073756272 rhs@var3691 .@expr14443 astOperand2 (@expr14444 ) ;
3684: return ChildrenToVisit ::@expr1073756275 done ;
3685: } ) ;
3686: if (@expr1073756276 errorToken@var3690 ) {
3687: overlappingWriteUnion (@expr1073756277 tok@var3684 ) ; }
3688: } else { if (@expr1073756278 Token ::@expr1073756279 Match (@expr1073756280 tok@var3684 , "%name% (" ) ) {
3689: const Library ::@expr1073756281 NonOverlappingData * nonOverlappingData@var3692 ; nonOverlappingData@var3692 =@expr1073756282 mSettings@var29 .@expr14459 library@var3738 .@expr1073756284 getNonOverlappingData (@expr1073756285 tok@var3684 ) ;
3690: if (@expr1073756286 !@expr1073756287 nonOverlappingData@var3692 ) {
3691: continue ; }
3692: const std ::@expr1073756288 vector < const Token *@expr14366 > args@var3693 =@expr1073756290 getArguments (@expr1073756291 tok@var3684 ) ;
3693: if (@expr1073756292 nonOverlappingData@var3692 .@expr14469 ptr1Arg@var3694 <=@expr1073756294 0 ||@expr1073756295 nonOverlappingData@var3692 .@expr14469 ptr1Arg@var3694 >@expr1073756297 args@var3693 .@expr14474 size (@expr14475 ) ) {
3694: continue ; }
3695: if (@expr1073756300 nonOverlappingData@var3692 .@expr14477 ptr2Arg@var3695 <=@expr1073756302 0 ||@expr1073756303 nonOverlappingData@var3692 .@expr14477 ptr2Arg@var3695 >@expr1073756305 args@var3693 .@expr14474 size (@expr14475 ) ) {
3696: continue ; }
3697:
3698: const Token * ptr1@var3696 ; ptr1@var3696 =@expr1073756308 args@var3693 [@expr1073756309 nonOverlappingData@var3692 .@expr14469 ptr1Arg@var3694 -@expr1073756311 1 ] ;
3699: if (@expr1073756312 ptr1@var3696 .@expr1073756313 hasKnownIntValue (@expr1073756314 ) &&@expr1073756315 ptr1@var3696 .@expr1073756316 getKnownIntValue (@expr1073756317 ) ==@expr1073756318 0 ) {
3700: continue ; }
3701:
3702: const Token * ptr2@var3697 ; ptr2@var3697 =@expr1073756319 args@var3693 [@expr1073756320 nonOverlappingData@var3692 .@expr14477 ptr2Arg@var3695 -@expr1073756322 1 ] ;
3703: if (@expr1073756323 ptr2@var3697 .@expr1073756324 hasKnownIntValue (@expr1073756325 ) &&@expr1073756326 ptr2@var3697 .@expr1073756327 getKnownIntValue (@expr1073756328 ) ==@expr1073756329 0 ) {
3704: continue ; }
3705:
3706:
3707: if (@expr1073756330 nonOverlappingData@var3692 .@expr14507 sizeArg@var3698 <=@expr1073756332 0 ||@expr1073756333 nonOverlappingData@var3692 .@expr14507 sizeArg@var3698 >@expr1073756335 args@var3693 .@expr14474 size (@expr14475 ) ) {
3708: if (@expr1073756338 nonOverlappingData@var3692 .@expr14507 sizeArg@var3698 ==@expr1073756340 -1 ) {
3709: std ::@expr1073756341 list < std ::@expr14518 pair < const Token *@expr14366 , std ::@expr14518 string > > errorPath@var3699 ;
3710: const bool macro@var3700 =@expr1073756345 true ;
3711: const bool pure@var3701 =@expr1073756346 true ;
3712: const bool follow@var3702 =@expr1073756347 true ;
3713: if (@expr1073756348 !@expr1073756349 isSameExpression (@expr1073756350 mTokenizer@var28 .@expr14527 isCPP (@expr14528 ) , macro@var3700 , ptr1@var3696 , ptr2@var3697 , mSettings@var29 .@expr14459 library@var3738 , pure@var3701 , follow@var3702 , &@expr1073756354 errorPath@var3699 ) ) {
3714: continue ; }
3715: overlappingWriteFunction (@expr14531 tok@var3684 ) ;
3716: }
3717: continue ;
3718: }
3719: if (@expr1073756356 !@expr1073756357 args@var3693 [@expr14534 nonOverlappingData@var3692 .@expr14507 sizeArg@var3698 -@expr14536 1 ] .@expr1073756361 hasKnownIntValue (@expr1073756362 ) ) {
3720: continue ; }
3721: const long long sizeValue@var3703 =@expr1073756363 args@var3693 [@expr14534 nonOverlappingData@var3692 .@expr14507 sizeArg@var3698 -@expr14536 1 ] .@expr1073756367 getKnownIntValue (@expr1073756368 ) ;
3722: const Token * buf1@var3704 ; const Token * buf2@var3705 ;
3723: long long offset1@var3706 ; long long offset2@var3707 ;
3724: if (@expr1073756369 !@expr1073756370 getBufAndOffset (@expr1073756371 ptr1@var3696 , &@expr1073756372 buf1@var3704 , &@expr1073756373 offset1@var3706 ) ) {
3725: continue ; }
3726: if (@expr1073756374 !@expr1073756375 getBufAndOffset (@expr1073756376 ptr2@var3697 , &@expr1073756377 buf2@var3705 , &@expr1073756378 offset2@var3707 ) ) {
3727: continue ; }
3728:
3729: if (@expr1073756379 offset1@var3706 <@expr1073756380 offset2@var3707 &&@expr1073756381 offset1@var3706 +@expr1073756382 sizeValue@var3703 <=@expr1073756383 offset2@var3707 ) {
3730: continue ; }
3731: if (@expr1073756384 offset2@var3707 <@expr1073756385 offset1@var3706 &&@expr1073756386 offset2@var3707 +@expr1073756387 sizeValue@var3703 <=@expr1073756388 offset1@var3706 ) {
3732: continue ; }
3733:
3734: std ::@expr1073756389 list < std ::@expr14518 pair < const Token *@expr14366 , std ::@expr14518 string > > errorPath@var3708 ;
3735: const bool macro@var3709 =@expr1073756393 true ;
3736: const bool pure@var3710 =@expr1073756394 true ;
3737: const bool follow@var3711 =@expr1073756395 true ;
3738: if (@expr1073756396 !@expr1073756397 isSameExpression (@expr1073756398 mTokenizer@var28 .@expr14527 isCPP (@expr14528 ) , macro@var3709 , buf1@var3704 , buf2@var3705 , mSettings@var29 .@expr14459 library@var3738 , pure@var3710 , follow@var3711 , &@expr1073756402 errorPath@var3708 ) ) {
3739: continue ; }
3740: overlappingWriteFunction (@expr14531 tok@var3684 ) ;
3741: } }
3742: }
3743: }
3744: }
3745:
3746: void CheckOther :: overlappingWriteUnion ( const Token * tok@var3712 )
3747: {
3748: reportError (@expr1073756404 tok@var3712 , Severity ::@expr1073756405 error , "overlappingWriteUnion" , "Overlapping read/write of union is undefined behavior" ) ;
3749: }
3750:
3751: void CheckOther :: overlappingWriteFunction ( const Token * tok@var3713 )
3752: {
3753: const std ::@expr1073756406 string funcname@var3714 =@expr1073756407 tok@var3713 ?@expr1073756408 tok@var3713 .@expr1073756409 str (@expr1073756410 ) :@expr1073756411 "" ;
3754: reportError (@expr1073756412 tok@var3713 , Severity ::@expr1073756413 error , "overlappingWriteFunction" , "Overlapping read/write in " +@expr1073756414 funcname@var3714 +@expr1073756415 "() is undefined behavior" ) ;
3755: }

##file cppcheck-2.8/lib/settings.h

21:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3715 ; mFlags@var3715 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3715 ;
54: }
55: void clear ( ) {
56: mFlags@var3715 =@expr1073756416 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3715 =@expr1073756417 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3716 ) {
62: if (@expr1073756418 enabled@var3716 ) {
63: fill (@expr1073756419 ) ; }
64: else {
65: clear (@expr1073756420 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3717 ) const {
68: return (@expr14597 mFlags@var3715 &@expr1073756422 (@expr14597 1U <<@expr1073756424 (@expr1073756425 uint32_t ) flag@var3717 ) ) !=@expr1073756426 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3718 ) {
71: mFlags@var3715 |=@expr1073756427 (@expr1073756428 1U <<@expr1073756429 (@expr1073756430 uint32_t ) flag@var3718 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3719 ) {
74: mFlags@var3715 &=@expr1073756431 ~@expr1073756432 (@expr1073756433 1U <<@expr1073756434 (@expr1073756435 uint32_t ) flag@var3719 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3720 , bool enabled@var3721 ) {
77: if (@expr1073756436 enabled@var3721 ) {
78: enable (@expr1073756437 flag@var3720 ) ; }
79: else {
80: disable (@expr1073756438 flag@var3720 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3722 ; mFlags@var3722 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3722 ;
54: }
55: void clear ( ) {
56: mFlags@var3722 =@expr1073756439 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3722 =@expr1073756440 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3723 ) {
62: if (@expr1073756441 enabled@var3723 ) {
63: fill (@expr1073756442 ) ; }
64: else {
65: clear (@expr1073756443 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3724 ) const {
68: return (@expr14620 mFlags@var3722 &@expr1073756445 (@expr14620 1U <<@expr1073756447 (@expr1073756448 uint32_t ) flag@var3724 ) ) !=@expr1073756449 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3725 ) {
71: mFlags@var3722 |=@expr1073756450 (@expr1073756451 1U <<@expr1073756452 (@expr1073756453 uint32_t ) flag@var3725 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3726 ) {
74: mFlags@var3722 &=@expr1073756454 ~@expr1073756455 (@expr1073756456 1U <<@expr1073756457 (@expr1073756458 uint32_t ) flag@var3726 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3727 , bool enabled@var3728 ) {
77: if (@expr1073756459 enabled@var3728 ) {
78: enable (@expr1073756460 flag@var3727 ) ; }
79: else {
80: disable (@expr1073756461 flag@var3727 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3729 ; mFlags@var3729 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3729 ;
54: }
55: void clear ( ) {
56: mFlags@var3729 =@expr1073756462 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3729 =@expr1073756463 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3730 ) {
62: if (@expr1073756464 enabled@var3730 ) {
63: fill (@expr1073756465 ) ; }
64: else {
65: clear (@expr1073756466 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3731 ) const {
68: return (@expr14643 mFlags@var3729 &@expr1073756468 (@expr14643 1U <<@expr1073756470 (@expr1073756471 uint32_t ) flag@var3731 ) ) !=@expr1073756472 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3732 ) {
71: mFlags@var3729 |=@expr1073756473 (@expr1073756474 1U <<@expr1073756475 (@expr1073756476 uint32_t ) flag@var3732 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3733 ) {
74: mFlags@var3729 &=@expr1073756477 ~@expr1073756478 (@expr1073756479 1U <<@expr1073756480 (@expr1073756481 uint32_t ) flag@var3733 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3734 , bool enabled@var3735 ) {
77: if (@expr1073756482 enabled@var3735 ) {
78: enable (@expr1073756483 flag@var3734 ) ; }
79: else {
80: disable (@expr1073756484 flag@var3734 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  tok possible 0@105
  severity possible {1@14,3@72,7@21}
  id possible {"overlappingWriteFunction"@14,"overlappingWriteUnion"@15,"moduloofone"@72,"knownArgument"@105,"knownArgumentHiddenVariableExpression"@106,"debug"@21,"constParameter"@214,"constVariable"@215,"constParameterCallback"@216,"redundantBitwiseOperationInSwitch"@124}
  msg possible {"Overlapping read/write of union is undefined behavior"@15,"Modulo of one is always equal to zero"@72,"Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has."@105,"Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'."@106,"constStatementError not handled."@21,"Parameter 'x' can be declared with const"@214,"Variable 'x' can be declared with const"@215,"Parameter 'x' can be declared with const, however it seems that 'f' is a callback function."@216}
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
  tok possible 0@237
Line 141
  callstack always size=1
  severity possible {2@45,1@60,3@45,5@109}
  id {"accessMoved"@237,"accessForwarded"@238,"unknownEvaluationOrder"@1,"raceAfterInterlockedDecrement"@60,"varFuncNullUB"@109,"shiftNegativeLHS"@149,"shiftNegative"@150,"comparisonFunctionIsAlwaysTrueOrFalse"@229,"selfAssignment"@240,"duplicateValueTernary"@241}
  msg {"Access of moved variable 'v'."@237,"Access of forwarded variable 'v'."@238,"Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead."@60,"Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nPassing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nThe C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\nThe value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\nIn practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\nTo reproduce you might be able to use this little code example on 64bit platforms. If the output includes \"ERROR\", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the \"ERROR\" output go away.\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid f(char *s, ...) {\n    va_list ap;\n    va_start(ap,s);\n    for (;;) {\n        char *p = va_arg(ap,char*);\n        printf(\"%018p, %s\\n\", p, (long)p & 255 ? p : \"\");\n        if(!p) break;\n    }\n    va_end(ap);\n}\n\nvoid g() {\n    char *s2 = \"x\";\n    char *s3 = \"ERROR\";\n\n    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\n    f(\"first\", s2, s2, s2, s2, s2, 0, s3, (char*)0);\n}\n\nvoid h() {\n    int i;\n    volatile unsigned char a[1000];\n    for (i = 0; i<sizeof(a); i++)\n        a[i] = -1;\n}\n\nint main() {\n    h();\n    g();\n    return 0;\n}"@109,"Shifting a negative value is technically undefined behaviour"@149,"Shifting by a negative value is undefined behaviour"@150,"Same value in both branches of ternary operator.\nFinding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition."@241,"Using NaN/Inf in a computation.\nUsing NaN/Inf in a computation. Although nothing bad really happens, it is suspicious."@232,"Division by zero."@241,"When using 'char' variables in bit operations, sign extension can generate unexpected results.\nWhen using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\n    char c = 0x80;\n    int i = 0 | c;\n    if (i & 0x8000)\n        printf(\"not expected\");\nThe \"not expected\" will be printed on the screen."@176}
  certainty possible {0@45,2@220}
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 52
  ( always "Other"
Line 56
  ( always "Other"
Line 107
  ( always {!<=-1,!>=2}
Line 110
  ( always {!<=-1,!>=2}
Line 127
  ( always {!<=-1,!>=2}
Line 263
  , always 0
  = always 0
  false always 0
Line 282
  ( always {!<=-1,!>=2}
Line 292
  nullptr always 0
Line 297
  nullptr always 0
  nullptr always 0
Line 298
  nullptr always 0
  "varname" always "varname"
Line 299
  nullptr always 0
  "float *" always "float *"
  "double *" always "double *"
  false always 0
  false always 0
Line 300
  nullptr always 0
  1 always 1
Line 301
  nullptr always 0
  2 always 2
Line 302
  nullptr always 0
  "varname" always "varname"
  "dimension" always "dimension"
Line 303
  nullptr always 0
Line 304
  nullptr always 0
  "malloc" always "malloc"
  false always 0
Line 305
  nullptr always 0
Line 306
  nullptr always 0
Line 309
  nullptr always 0
  "varname" always "varname"
Line 310
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 313
  nullptr always 0
  "isless" always "isless"
  "varName" always "varName"
  false always 0
Line 314
  nullptr always 0
  "func_name" always "func_name"
Line 315
  nullptr always 0
Line 316
  nullptr always 0
  "parametername" always "parametername"
  false always 0
Line 317
  nullptr always 0
  nullptr always 0
Line 318
  nullptr always 0
  "type" always "type"
  false always 0
Line 319
  nullptr always 0
Line 320
  nullptr always 0
Line 321
  nullptr always 0
Line 322
  nullptr always 0
  "varname" always "varname"
Line 323
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 324
  nullptr always 0
  nullptr always 0
  "var" always "var"
Line 325
  nullptr always 0
  "||" always "||"
Line 326
  nullptr always 0
  "varname" always "varname"
Line 327
  nullptr always 0
  "+" always "+"
Line 328
  nullptr always 0
Line 329
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 330
  nullptr always 0
  nullptr always 0
  true always 1
Line 331
  nullptr always 0
  errorPath always size=0
Line 332
  nullptr always 0
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 333
  nullptr always 0
Line 334
  nullptr always 0
  errorPath always size=0
Line 335
  nullptr always 0
  false always 0
Line 336
  nullptr always 0
  false always 0
Line 337
  nullptr always 0
  nullptr always 0
  "varname" always "varname"
Line 338
  nullptr always 0
  nullptr always 0
  "varname" always "varname"
Line 339
  nullptr always 0
  nullptr always 0
Line 340
  nullptr always 0
  nullptr always 0
Line 341
  nullptr always 0
Line 342
  nullptr always 0
  "buffer" always "buffer"
  "memset" always "memset"
  false always 0
Line 343
  nullptr always 0
Line 344
  nullptr always 0
Line 345
  nullptr always 0
Line 346
  nullptr always 0
  "varname" always "varname"
  false always 0
  true always 1
Line 347
  nullptr always 0
  false always 0
  false always 0
Line 348
  nullptr always 0
  false always 0
  true always 1
Line 349
  nullptr always 0
  true always 1
  false always 0
Line 350
  nullptr always 0
  true always 1
  true always 1
Line 351
  nullptr always 0
Line 352
  nullptr always 0
  "v" always "v"
  nullptr always 0
  false always 0
Line 353
  "function" always "function"
  1 always 1
  nullptr always 0
  nullptr always 0
Line 354
  nullptr always 0
  "varname" always "varname"
Line 355
  nullptr always 0
  nullptr always 0
  "variable" always "variable"
Line 356
  nullptr always 0
  nullptr always 0
  "function" always "function"
Line 357
  nullptr always 0
  nullptr always 0
  "argument" always "argument"
Line 358
  nullptr always 0
  nullptr always 0
  nullptr always 0
  "x" always "x"
  false always 0
Line 359
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 360
  nullptr always 0
  nullptr always 0
  "var" always "var"
  false always 0
Line 361
  nullptr always 0
  nullptr always 0
  "var" always "var"
  false always 0
Line 364
  "function" always "function"
  nullptr always 0
  nullptr always 0
  nullvec always size=0
  nullvec always size=0
Line 365
  nullptr always 0
Line 369
  "Other" always "Other"
Line 373
  "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n" always "Other checks\n- division with zero\n- scoped object destroyed immediately after construction\n- assignment in an assert statement\n- free() or delete of an invalid memory location\n- bitwise operation with negative right operand\n- provide wrong dimensioned array to pipe() system command (--std=posix)\n- cast the return values of getc(),fgetc() and getchar() to character and compare it to EOF\n- race condition with non-interlocked access after InterlockedDecrement() call\n- expression 'x = x++;' depends on order of evaluation of side effects\n- overlapping write of union\n- either division by zero or useless condition\n- access of moved or forwarded variable.\n- redundant data copying for const variable\n- subsequent assignment or copying to a variable or buffer\n- passing parameter by value\n- Passing NULL pointer to function with variable number of arguments leads to UB.\n- C-style pointer cast in C++ code\n- casting between incompatible pointer types\n- [Incomplete statement](IncompleteStatement)\n- [check how signed char variables are used](CharVar)\n- variable scope can be limited\n- unusual pointer arithmetic. For example: \"abc\" + 'd'\n- redundant assignment, increment, or bitwise operation in a switch statement\n- redundant strcpy in a switch statement\n- Suspicious case labels in switch()\n- assignment of a variable to itself\n- Comparison of values leading always to true or false\n- Clarify calculation with parentheses\n- suspicious comparison of '\\0' with a char\\* variable\n- duplicate break statement\n- unreachable code\n- testing if unsigned variable is negative/positive\n- Suspicious use of ; at the end of 'if/for/while' statement.\n- Array filled incompletely using memset/memcpy/memmove.\n- NaN (not a number) value used in arithmetic expression.\n- comma in return statement (the comma can easily be misread as a semicolon).\n- prefer erfc, expm1 or log1p to avoid loss of precision.\n- identical code in both branches of if/else or ternary operator.\n- redundant pointer operation on pointer like &\\*some_ptr.\n- find unused 'goto' labels.\n- function declaration and definition argument names different.\n- function declaration and definition argument order different.\n- shadow variable.\n- variable can be declared const.\n- calculating modulo of one.\n- known function argument, suspicious calculation.\n"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 78
  value possible <=1@229
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@906,34@1162}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@3,34@4}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@3,""@4,""@5,"U"@6,"U"@7,"u"@8,"u"@9,"u8"@10,"u8"@11}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@135,34@136}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@132,34@134}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@93,128@94,64@95,32@96,16@97,8@98,4@99,2@100,1@101}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@102,128@103,64@104,32@105,16@106,8@107,4@108,2@109,1@110}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@102,4294967167@103,4294967231@104,4294967263@105,4294967279@106,4294967287@107,4294967291@108,4294967293@109,4294967294@110}
  flag {!<=-1,256@102,128@103,64@104,32@105,16@106,8@107,4@108,2@109,1@110}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->astOperand1())@20,symbolic=(parent)@10,0@10,symbolic=(valueTok)@7,symbolic=(tok->astParent())@241,symbolic=(parent->astParent())@246}
  pattern possible {"."@20,"."@29,"["@48,"-"@85,"("@111,"sizeof ("@126,"*"@128,"0"@129,"0"@131,"&&"@133}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@248,4@249,0@250}
  t possible {10@248,4@249,0@250}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@248,4@249,0@250}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@248,0@250}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@248,0@250}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@248}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@248}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@248}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@248}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@248}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"&"@47,"&"@92,"*"@94,"*"@95,"&"@97,"*"@62,"*"@65,"*"@240,"&"@244,"*"@245}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  startTok possible symbolic=(nextAssign->astOperand1())@31
  pattern {";"@254,";"@31,"{"@106}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@2,17179869184@13,8589934592@15,34359738368@17,4294967296@19,2147483648@21,1073741824@23,536870912@25,268435456@27}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,0@69,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@89,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@90}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@1,17179869184@12,8589934592@14,34359738368@16,4294967296@18,2147483648@20,1073741824@22,536870912@24,268435456@26}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@1,17179869184@12,8589934592@14,34359738368@16,4294967296@18,2147483648@20,1073741824@22,536870912@24,268435456@26}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@191,4096@194,16384@197,2048@198,1024@199,65536@200,512@201,256@202,128@203}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 550
  index_ possible 0@134
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@156,4194304@158,8388608@159,2097152@161,1048576@162,524288@163,262144@164,131072@165,65536@166}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@134,2097152@135,1048576@136,524288@137,262144@138,131072@139,65536@140,32768@141,16384@142}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@134,4292870143@135,4293918719@136,4294443007@137,4294705151@138,4294836223@139,4294901759@140,4294934527@141,4294950911@142}
  flag {!<=-1,8388608@134,2097152@135,1048576@136,524288@137,262144@138,131072@139,65536@140,32768@141,16384@142}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible {lifetime[Lambda]=(errorToken)@27,lifetime[Lambda]=(isVariableExprHidden)@143,lifetime[Lambda]=(varexpr)@143,lifetime[Lambda]=(tok)@31,lifetime[Lambda]=(foundError)@31,lifetime[Lambda]=(warn)@32,lifetime[Lambda]=(trivial)@175}
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 54
  null always 0
  uninit always 1
  bufferOverflow always 2
Line 63
  { always 0
Line 64
  { always 0
Line 71
  { always 0
Line 74
  { always 0
Line 87
  { always 0
Line 92
  ( always {!<=-1,!>=2}
Line 101
  warning always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 122
  { always 0
Line 136
  warning always {!<=-1,!>=2}
Line 148
  ( always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
Line 51
  = always 0
  0 always 0
  notEqual always {!<=-1,!>=2}
  false always 0
Line 53
  notEqual always {!<=-1,!>=2}
Line 65
  ( always "Uninitialized variables"
Line 69
  ( always "Uninitialized variables"
Line 78
  ( always {!<=-1,!>=2}
Line 83
  NO_ALLOC always 0
  NO_CTOR_CALL always 1
  CTOR_CALL always 2
  ARRAY always 3
Line 84
  ( always {!<=-1,!>=2}
Line 85
  , always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 86
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isuninit always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 88
  bailout always {!<=-1,!>=2}
Line 90
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 91
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 92
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 93
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 94
  ( always {!<=-1,!>=2}
Line 95
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isPointer always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 119
  , always {!<=-1,!>=2}
  strncpy_ always {!<=-1,!>=2}
Line 124
  errorPath always size=0
Line 127
  alloc possible 2
  == {!<=-1,!>=2,0}
  NO_CTOR_CALL always 1
  || always {!<=-1,!>=2}
  alloc always !1
  == always {!<=-1,!>=2}
  CTOR_CALL always 2
Line 137
  ( always {!<=-1,!>=2}
Line 141
  nullptr always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
  "varname" always "varname"
  true always 1
Line 148
  nullptr always 0
  "varname" always "varname"
Line 149
  nullptr always 0
  "a.b" always "a.b"
Line 153
  "Uninitialized variables" always "Uninitialized variables"
Line 157
  "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n" always "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
Line 56
  ( always "Class"
  nullptr always 0
Line 63
  ( always {!<=-1,!>=2}
Line 109
  , always {!<=-1,!>=2}
  allocation always {!<=-1,!>=2}
Line 164
  hash always !<=-1
Line 166
  ( always {!<=-1,!>=2}
Line 167
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 170
  ( always {!<=-1,!>=2}
Line 171
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 172
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 173
  == always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 197
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 198
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
Line 201
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 202
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 203
  , always {!<=-1,!>=2}
  isdefault always {!<=-1,!>=2}
Line 204
  , always {!<=-1,!>=2}
  isprivate always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  derived always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 207
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 214
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 218
  , always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
Line 220
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 221
  , always {!<=-1,!>=2}
  suggestStatic always {!<=-1,!>=2}
Line 227
  , always {!<=-1,!>=2}
  derivedIsStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  baseIsStruct always {!<=-1,!>=2}
Line 228
  , always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  hasCopyCtor always {!<=-1,!>=2}
Line 235
  nullptr always 0
Line 236
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 237
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 239
  nullptr always 0
  "var" always "var"
Line 240
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 241
  nullptr always 0
  false always 0
  nullptr always 0
  false always 0
Line 242
  nullptr always 0
  false always 0
  nullptr always 0
Line 243
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  false always 0
  false always 0
Line 244
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  false always 0
  false always 0
Line 245
  nullptr always 0
  false always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varname" always "varname"
  true always 1
  false always 0
Line 246
  nullptr always 0
  true always 1
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
  true always 1
  false always 0
Line 247
  nullptr always 0
  :: always 0
  eConstructor always 0
  "classname" always "classname"
  "varnamepriv" always "varnamepriv"
Line 248
  nullptr always 0
  "classname" always "classname"
  false always 0
Line 249
  nullptr always 0
  "classname" always "classname"
  "funcname" always "funcname"
Line 250
  nullptr always 0
  "memfunc" always "memfunc"
  "classname" always "classname"
  "class" always "class"
Line 251
  nullptr always 0
  "memfunc" always "memfunc"
  "class" always "class"
Line 252
  nullptr always 0
  "class" always "class"
Line 253
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
Line 254
  nullptr always 0
  "malloc" always "malloc"
  nullptr always 0
  "std::string" always "std::string"
Line 255
  nullptr always 0
  "Base" always "Base"
  "Derived" always "Derived"
  false always 0
Line 256
  nullptr always 0
Line 257
  nullptr always 0
Line 258
  nullptr always 0
  true always 1
Line 259
  nullptr always 0
Line 260
  nullptr always 0
Line 261
  nullptr always 0
  "class" always "class"
  "function" always "function"
  false always 0
Line 262
  nullptr always 0
  "class" always "class"
  "function" always "function"
  true always 1
Line 263
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "variable" always "variable"
Line 264
  nullptr always 0
  "variable" always "variable"
Line 265
  nullptr always 0
  "var" always "var"
Line 266
  nullptr always 0
  nullptr always 0
  "class" always "class"
  "class" always "class"
  "variable" always "variable"
  false always 0
  false always 0
Line 267
  nullptr always 0
  "class" always "class"
  false always 0
  false always 0
Line 268
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 269
  nullptr always 0
  ( always size=0
  "f" always "f"
Line 270
  nullptr always 0
  nullptr always 0
Line 271
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 272
  nullptr always 0
  "UnsafeClass::var" always "UnsafeClass::var"
Line 276
  "Class" always "Class"
Line 280
  "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n" always "Check the code for each class.\n- Missing constructors and copy constructors\n- Constructors which should be explicit\n- Are all variables initialized by the constructors?\n- Are all variables assigned by 'operator='?\n- Warn if memset, memcpy etc are used on a class\n- Warn if memory for classes is allocated with malloc()\n- If it's a base class, check that the destructor is virtual\n- Are there unused private functions?\n- 'operator=' should check for assignment to self\n- Constness for member functions\n- Order of initializations\n- Suggest usage of initialization list\n- Initialization of a member with itself\n- Suspicious subtraction from 'this'\n- Call of pure virtual function in constructor/destructor\n- Duplicated inherited data members\n- Check that arbitrary usage of public interface does not result in division by zero\n- Delete \"self pointer\" and then access 'this'\n- Check that the 'override' keyword is used when overriding virtual functions\n- Check that the 'one definition rule' is not violated\n"
Line 310
  ( always {!<=-1,!>=2}
Line 311
  ( always {!<=-1,!>=2}
Line 312
  ( always {!<=-1,!>=2}
Line 313
  ( always {!<=-1,!>=2}
Line 314
  TRUE always 0
  FALSE always 1
  BAILOUT always 2
Line 319
  ( always {!<=-1,!>=2}
Line 320
  ( always {!<=-1,!>=2}
Line 321
  ( always {!<=-1,!>=2}
Line 322
  ( always {!<=-1,!>=2}
  memberAccessed always {!<=-1,!>=2}
Line 327
  ( inconclusive lifetime[SubObject]=(var)
  assign always {!<=-1,!>=2}
  false always 0
  init always {!<=-1,!>=2}
  false always 0
Line 333
  assign always {!<=-1,!>=2}
Line 336
  init always {!<=-1,!>=2}
Line 339
  ( always {!<=-1,!>=2}
Line 404
  ( always {!<=-1,!>=2}
Line 406
  ( always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 53
  128U always 128
Line 54
  131U always 131
Line 55
  197U always 197
Line 56
  362U always 362
Line 57
  369U always 369
Line 58
  398U always 398
Line 59
  475U always 475
Line 60
  482U always 482
Line 61
  561U always 561
Line 62
  563U always 563
Line 63
  570U always 570
Line 64
  571U always 571
Line 65
  672U always 672
Line 66
  628U always 628
Line 67
  683U always 683
Line 68
  686U always 686
Line 69
  704U always 704
Line 70
  758U always 758
Line 71
  768U always 768
Line 72
  783U always 783
Line 88
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 92
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 93
  vars possible size=0
Line 94
  != always {!<=-1,!>=2}
Line 96
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%|EOF %comp%|=" always "%var%|EOF %comp%|="
Line 98
  ( always {!<=-1,!>=2}
  "%var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (" always "%var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc ("
Line 100
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 101
  2 always 2
Line 103
  ( always {!<=-1,!>=2}
  "EOF %comp% ( %var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc (" always "EOF %comp% ( %var% = fclose|fflush|fputc|fputs|fscanf|getchar|getc|fgetc|putchar|putc|puts|scanf|sscanf|ungetc ("
Line 104
  3 always 3
Line 106
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 107
  2 always 2
Line 109
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "EOF %comp% ( %var% = std :: cin . get (" always "EOF %comp% ( %var% = std :: cin . get ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "EOF %comp% ( %var% = cin . get (" always "EOF %comp% ( %var% = cin . get ("
Line 110
  3 always 3
Line 112
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 113
  "cin.get" always "cin.get"
Line 115
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% = std :: cin . get (" always "%var% = std :: cin . get ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% = cin . get (" always "%var% = cin . get ("
Line 117
  var {symbolic=(tok->variable()),0}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  == always {!<=-1,!>=2}
  "char" always "char"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 118
  = always "cin.get"
  "cin.get" always "cin.get"
Line 120
  ( always {!<=-1,!>=2}
  "%var% %comp% EOF" always "%var% %comp% EOF"
Line 121
  ( possible lifetime[Iterator]=(vars)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 124
  ( always {!<=-1,!>=2}
  "EOF %comp% %var%" always "EOF %comp% %var%"
Line 125
  2 always 2
Line 126
  ( possible lifetime[Iterator]=(vars)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(vars),end=0}
Line 137
  tok possible 0@154
Line 138
  :: always 2
  warning always 2
Line 139
  "checkCastIntToCharAndBack" always "checkCastIntToCharAndBack"
Line 140
  "$symbol:" always "$symbol:"
  strFunctionName possible {"cin.get"@98,"func_name"@154}
  "\nStoring $symbol() return value in char variable and then comparing with EOF.\nWhen saving $symbol() return value in char variable there is loss of precision.  When $symbol() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop \"while (EOF != (c = $symbol());\" loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character." always "\nStoring $symbol() return value in char variable and then comparing with EOF.\nWhen saving $symbol() return value in char variable there is loss of precision.  When $symbol() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop \"while (EOF != (c = $symbol());\" loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character."
Line 146
  :: always 0
  normal always 0
Line 156
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 160
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 161
  != always {!<=-1,!>=2}
Line 163
  != always {!<=-1,!>=2}
  "?" always "?"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 165
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
Line 169
  ( always !0
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%or%|&|%|*|/" always "%or%|&|%|*|/"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 173
  == always {!<=-1,!>=2}
  :: always 15
  eBitOp always 15
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%char%" always "%char%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%char%" always "%char%"
Line 177
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 179
  op always symbolic=(tok->astOperand1()->astOperand2())
  ( always {!<=-1,!>=2}
Line 181
  op always symbolic=(tok->astOperand1()->astOperand2())
  && always {!<=-1,!>=2}
  op always symbolic=(tok->astOperand1()->astOperand2())
  ( always !0
  ( always {!<=-1,!>=2}
Line 187
  tok2 possible symbolic=(tok->astOperand1())
Line 188
  tok2 possible symbolic=(tok->astOperand1())
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 190
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 192
  == always {!<=-1,!>=2}
  "?" always "?"
Line 204
  "'a" always "'a"
  op possible "+"@167
  "b?c:d'" always "b?c:d'"
Line 207
  "'(a" always "'(a"
  op possible "+"@167
  "b)?c:d'" always "b)?c:d'"
Line 210
  "'a" always "'a"
  op possible "+"@167
  "(b?c:d)'" always "(b?c:d)'"
Line 212
  tok possible 0@167
Line 213
  :: always 3
  style always 3
Line 214
  "clarifyCalculation" always "clarifyCalculation"
Line 215
  "Clarify calculation precedence for '" always "Clarify calculation precedence for '"
  op possible "+"@167
  "' and '?'.\nSuspicious calculation. Please use parentheses to clarify the code. The code '" always "' and '?'.\nSuspicious calculation. Please use parentheses to clarify the code. The code '"
Line 217
  "' should be written as either '" always "' should be written as either '"
  "' or '" always "' or '"
  "'." always "'."
  :: always 0
  normal always 0
Line 225
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 229
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 230
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 231
  ( always {!<=-1,!>=2}
  "* %name%" always "* %name%"
  && always {!<=-1,!>=2}
Line 234
  tok2 possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  tok2 {symbolic=(tok->previous()),!0}
  == always {!<=-1,!>=2}
  "*" always "*"
Line 235
  tok2 always !0
Line 237
  tok2 possible {symbolic=(tok->previous()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  "[{};]" always "[{};]"
Line 238
  = always !0
  ( always !0
Line 239
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->astOperand1()),!0}
  "++|-- [;,]" always "++|-- [;,]"
Line 240
  tok2 {symbolic=(tok->astOperand1()),!0}
Line 249
  tok possible {symbolic=(tok->astOperand1())@30,0@168}
  :: always 2
  warning always 2
  "clarifyStatement" always "clarifyStatement"
  "In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?\nA statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?" always "In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?\nA statement like '*A++;' might not do what you intended. Postfix 'operator++' is executed before 'operator*'. Thus, the dereference is meaningless. Did you intend to write '(*A)++;'?"
Line 251
  :: always 0
  normal always 0
Line 259
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 265
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 266
  . possible {7,9,8}
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  || {!<=-1,!>=2,0}
  . {9,8,!6}
  == {!<=-1,!>=2,0}
  :: always 7
  eElse always 7
  || {!<=-1,!>=2,0}
  . {8,!6,!7}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  . always {!7,!9}
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 269
  ( always {!<=-1,!>=2}
  "{ ; } {" always "{ ; } {"
  && always {!<=-1,!>=2}
Line 270
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 271
  1 always 1
  >= always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
Line 272
  ! always {!<=-1,!>=2}
  3 always 3
  ( always {!<=-1,!>=2}
Line 281
  tok possible 0
  :: always 2
  warning always 2
  "suspiciousSemicolon" always "suspiciousSemicolon"
Line 282
  "Suspicious use of ; at the end of '" always "Suspicious use of ; at the end of '"
  tok possible 0@181
  tok always !0
  "' statement." always "' statement."
  :: always 0
  normal always 0
Line 292
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 296
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 298
  && always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
Line 302
  tok possible {symbolic=(scope->classDef),symbolic=(scope->bodyStart)}
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 304
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( const|volatile| const|volatile|class|struct| %type% * *| *| const|&| ) (| %name%|%num%|%bool%|%char%|%str%" always "( const|volatile| const|volatile|class|struct| %type% * *| *| const|&| ) (| %name%|%num%|%bool%|%char%|%str%"
Line 306
  ( always {!<=-1,!>=2}
  "%type%" always "%type%"
Line 310
  ( always {!<=-1,!>=2}
  "const|volatile|class|struct" always "const|volatile|class|struct"
Line 314
  3 always 3
  == always {!<=-1,!>=2}
  "const" always "const"
Line 315
  = always symbolic=(typeTok)
  ( always symbolic=(typeTok)
Line 317
  tok possible symbolic=(typeTok)
  4 always 4
Line 318
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 321
  ( possible 4
  == {!<=-1,!>=2,0}
  :: always 1
  eType always 1
  || always {!<=-1,!>=2}
  ( always !1
  == always {!<=-1,!>=2}
  :: always 4
  eName always 4
Line 329
  tok possible 0@155
  :: always 3
  style always 3
  "cstyleCast" always "cstyleCast"
Line 330
  "C-style pointer casting\nC-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts." always "C-style pointer casting\nC-style pointer casting detected. C++ offers four different kinds of casts as replacements: static_cast, const_cast, dynamic_cast and reinterpret_cast. A C-style cast could evaluate to any of those automatically, thus it is considered safer if the programmer explicitly states which kind of cast is expected. See also: https://www.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not+use+C-style+casts."
Line 334
  :: always 0
  normal always 0
Line 343
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 346
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 348
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 349
  != always {!<=-1,!>=2}
Line 350
  = always 0
  nullptr always 0
Line 351
  = always 0
  nullptr always 0
Line 353
  ( always {!<=-1,!>=2}
  "( const|volatile| const|volatile| %type% %type%| const| * )" always "( const|volatile| const|volatile| %type% %type%| const| * )"
Line 355
  tok always symbolic=(toTok)
Line 356
  ( always {!<=-1,!>=2}
  "reinterpret_cast <" always "reinterpret_cast <"
  && always {!<=-1,!>=2}
  1 always 1
Line 357
  1 always 1
Line 360
  ! always {!<=-1,!>=2}
  fromTok possible {symbolic=(tok->astOperand1()),symbolic=(toTok->astOperand2())}
Line 363
  fromTok always !0
Line 365
  ! always {!<=-1,!>=2}
  fromType always symbolic=(fromTok->valueType())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  toType always symbolic=(toTok->valueType())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  fromType {symbolic=(fromTok->valueType()),!0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  toType {symbolic=(toTok->valueType()),!0}
Line 368
  fromType {symbolic=(fromTok->valueType()),!0}
  . possible {>=8,<=7}
  != {!<=-1,!>=2,0,1}
  toType {symbolic=(toTok->valueType()),!0}
  . possible {>=8,<=7,9}
  && always {!<=-1,!>=2}
  fromType {symbolic=(fromTok->valueType()),!0}
  . always !symbolic=(toType->type)
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  toType {symbolic=(toTok->valueType()),!0}
  . always !symbolic=(fromType->type)
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  toType {symbolic=(toTok->valueType()),!0}
  . {>=8,!<=7}
  != {!<=-1,!>=2,>=1}
  :: always 9
  CHAR always 9
  || always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
Line 369
  toType {symbolic=(toTok->valueType()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  fromType {symbolic=(fromTok->valueType()),!0}
  ( always {!<=-1,!>=2}
Line 372
  fromType always !0
  toType always !0
  toType always !0
  . always {!symbolic=(fromType->type),!<=7}
  == always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  toType always !0
  ( {!<=-1,!>=2,0}
Line 379
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  toIsInt always {!<=-1,!>=2}
Line 381
  toIsInt {!<=-1,!>=2,0@246}
Line 382
  :: always 5
  portability always 5
  "invalidPointerCast" always "invalidPointerCast"
  "Casting from " always "Casting from "
  " to " always " to "
  " is not portable due to different binary data representations on different platforms." always " is not portable due to different binary data representations on different platforms."
  inconclusive always {!<=-1,!>=2}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 384
  tok possible 0@143
  :: always 5
  portability always 5
  "invalidPointerCast" always "invalidPointerCast"
  "Casting between " always "Casting between "
  from possible "float *"@143
  " and " always " and "
  to possible "double *"@143
  " which have an incompatible binary data representation." always " which have an incompatible binary data representation."
  :: always 0
  normal always 0
Line 398
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 402
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 403
  != always {!<=-1,!>=2}
Line 404
  ( always {!<=-1,!>=2}
  "pipe ( %var% )" always "pipe ( %var% )"
  || always {!<=-1,!>=2}
Line 405
  ( always {!<=-1,!>=2}
  "pipe2 ( %var% ," always "pipe2 ( %var% ,"
Line 406
  2 always 2
Line 410
  var always symbolic=(varTok->variable())
  && always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
  0U always 0
  < always {!<=-1,!>=2}
  2 always 2
Line 411
  dim {<=1,!>=2}
Line 421
  tok possible 0@146
  :: always 1
  error always 1
Line 422
  "wrongPipeParameterSize" always "wrongPipeParameterSize"
Line 423
  "$symbol:" always "$symbol:"
  strVarName possible "varname"@146
  "\nBuffer '$symbol' must have size of 2 integers if used as parameter of pipe().\nThe pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\nThe variable '$symbol' is an array of size " always "\nBuffer '$symbol' must have size of 2 integers if used as parameter of pipe().\nThe pipe()/pipe2() system command takes an argument, which is an array of exactly two integers.\nThe variable '$symbol' is an array of size "
Line 426
  strDim possible "dimension"@146
  ", which does not match." always ", which does not match."
  :: always 2
  safe always 2
Line 435
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 438
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 439
  ! always {!<=-1,!>=2}
Line 441
  . always !0
  != always {!<=-1,!>=2}
Line 442
  ( always {!<=-1,!>=2}
  "] (" always "] ("
Line 445
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 447
  1 always 1
Line 448
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "++|--" always "++|--"
  && always {!<=-1,!>=2}
Line 454
  isInitialization always {!<=-1,!>=2}
  isInitialization always {!<=-1,!>=2}
  = always 0
  false always 0
Line 455
  ( always {!<=-1,!>=2}
  -2 always -2
  "; %var% =" always "; %var% ="
  && always {!<=-1,!>=2}
  -2 always -2
  ( always {!<=-1,!>=2}
Line 456
  isInitialization always {!<=-1,!>=2}
  = always 1
  true always 1
Line 457
  trivial {!<=-1,!>=2,1}
  trivial always {!<=-1,!>=2}
  = always 1
  true always 1
Line 459
  [ possible lifetime[Lambda]=(trivial)
Line 460
  ( always {!<=-1,!>=2}
  "{ 0 }" always "{ 0 }"
Line 461
  :: always 0
  none always 0
Line 462
  ( always {!<=-1,!>=2}
  "%str%|%num%|%name%" always "%str%|%num%|%name%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 463
  :: always 0
  none always 0
Line 464
  ( always {!<=-1,!>=2}
  ":: %name%" always ":: %name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 465
  :: always 0
  none always 0
Line 466
  ( always {!<=-1,!>=2}
Line 467
  :: always 2
  op2 always 2
Line 468
  trivial always {!<=-1,!>=2}
  = always 0
  false always 0
Line 469
  :: always 4
  done always 4
Line 471
  trivial always {!<=-1,!>=2}
Line 477
  rhs {symbolic=(tok->astOperand2()),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rhs {symbolic=(tok->astOperand2()),!0}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  rhs {symbolic=(tok->astOperand2()),0}
Line 480
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 484
  ( possible 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 488
  inconclusive {!<=-1,!>=2,0}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 489
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 491
  ( always !0
Line 492
  "operator" always "operator"
Line 493
  ( always !0
  . always !0
Line 494
  == always {!<=-1,!>=2}
  op always symbolic=("operator"+tok->str())
Line 495
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 501
  ( always !0
  == always {!<=-1,!>=2}
  :: always 4
  SMART_POINTER always 4
Line 504
  inconclusive {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 507
  ( always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 513
  ( always {!<=-1,!>=2}
Line 519
  start possible symbolic=(tok->next())
Line 521
  ! always {!<=-1,!>=2}
Line 525
  hasCase always {!<=-1,!>=2}
  hasCase always {!<=-1,!>=2}
  = always 0
  false always 0
Line 526
  != always {!<=-1,!>=2}
  nextAssign always !0
Line 527
  ( possible {size=6,size=4}
  == {!<=-1,!>=2,0}
  "break" always "break"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
Line 529
  == always {!<=-1,!>=2}
  "case" always "case"
Line 530
  hasCase always {!<=-1,!>=2}
  = always 1
  true always 1
Line 536
  hasCase {!<=-1,!>=2,0,1}
Line 538
  isInitialization always {!<=-1,!>=2}
Line 539
  inconclusive always {!<=-1,!>=2}
Line 541
  inconclusive always {!<=-1,!>=2}
Line 549
  tok1 possible 0@152
  tok2 inconclusive 0@152
Line 550
  callstack always {{,size=2}
  :: always 4
  performance always 4
  "redundantCopy" always "redundantCopy"
Line 551
  "$symbol:" always "$symbol:"
  var inconclusive "var"@152
  "\nBuffer '$symbol' is being written before its old content has been used." always "\nBuffer '$symbol' is being written before its old content has been used."
Line 552
  :: always 0
  normal always 0
Line 557
  tok1 possible 0@164
  tok2 inconclusive 0@164
Line 558
  callstack always {{,size=2}
  :: always 3
  style always 3
  "redundantCopyInSwitch" always "redundantCopyInSwitch"
Line 559
  "$symbol:" always "$symbol:"
  var inconclusive "var"@164
  "\nBuffer '$symbol' is being written before its old content has been used. 'break;' missing?" always "\nBuffer '$symbol' is being written before its old content has been used. 'break;' missing?"
Line 560
  :: always 0
  normal always 0
Line 563
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 565
  tok1 possible 0@200
  var inconclusive "var"@200
  " is assigned" always " is assigned"
  tok2 inconclusive 0@200
  var inconclusive "var"@200
  " is overwritten" always " is overwritten"
Line 566
  inconclusive {!<=-1,!>=2,0@200}
Line 567
  errorPath always {{,size=2}
  :: always 3
  style always 3
  "redundantAssignment" always "redundantAssignment"
Line 568
  "$symbol:" always "$symbol:"
  "\nVariable '$symbol' is reassigned a value before the old one has been used if variable is no semaphore variable.\nVariable '$symbol' is reassigned a value before the old one has been used. Make sure that this variable is not used like a semaphore in a threading environment before simplifying this code." always "\nVariable '$symbol' is reassigned a value before the old one has been used if variable is no semaphore variable.\nVariable '$symbol' is reassigned a value before the old one has been used. Make sure that this variable is not used like a semaphore in a threading environment before simplifying this code."
Line 572
  errorPath always {{,size=2}
  :: always 3
  style always 3
  "redundantAssignment" always "redundantAssignment"
Line 573
  "$symbol:" always "$symbol:"
  var inconclusive "var"@200
  "\nVariable '$symbol' is reassigned a value before the old one has been used." always "\nVariable '$symbol' is reassigned a value before the old one has been used."
Line 574
  :: always 0
  normal always 0
Line 577
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 579
  tok1 possible 0@201
  var inconclusive "var"@201
  " is initialized" always " is initialized"
  tok2 inconclusive 0@201
  var inconclusive "var"@201
  " is overwritten" always " is overwritten"
Line 580
  errorPath always {{,size=2}
  :: always 3
  style always 3
  "redundantInitialization" always "redundantInitialization"
Line 581
  "$symbol:" always "$symbol:"
  var inconclusive "var"@201
  "\nRedundant initialization for '$symbol'. The initialized value is overwritten before it is read." always "\nRedundant initialization for '$symbol'. The initialized value is overwritten before it is read."
Line 583
  inconclusive {!<=-1,!>=2,0@201}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 588
  tok1 possible 0@163
  "$symbol is assigned" always "$symbol is assigned"
  tok2 inconclusive 0@163
  "$symbol is overwritten" always "$symbol is overwritten"
Line 589
  errorPath always {{,size=2}
  :: always 3
  style always 3
  "redundantAssignInSwitch" always "redundantAssignInSwitch"
Line 590
  "$symbol:" always "$symbol:"
  var inconclusive "var"@163
  "\nVariable '$symbol' is reassigned a value before the old one has been used. 'break;' missing?" always "\nVariable '$symbol' is reassigned a value before the old one has been used. 'break;' missing?"
Line 591
  :: always 0
  normal always 0
Line 604
  ( always {!<=-1,!>=2}
Line 606
  ( always {!<=-1,!>=2}
  tok possible symbolic=(varsWithBitsSet[tok2->varId()])@164
  "%name% (" always "%name% ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "break|continue|return|exit|goto|throw" always "break|continue|return|exit|goto|throw"
Line 607
  return always {!<=-1,!>=2}
  true always 1
Line 609
  return always {!<=-1,!>=2}
  false always 0
Line 614
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 621
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 622
  != always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 629
  . always !0
  != always {!<=-1,!>=2}
Line 630
  == always {!<=-1,!>=2}
  "{" always "{"
Line 634
  ( always {!<=-1,!>=2}
  ")|else {" always ")|else {"
  && always {!<=-1,!>=2}
Line 635
  = always !0
  ( always !0
Line 636
  != always {!<=-1,!>=2}
  endOfConditional {symbolic=(tok2->link()),!0}
Line 637
  != always {!<=-1,!>=2}
  0 always 0
Line 638
  ( always !0
Line 640
  ( always {!<=-1,!>=2}
Line 641
  varsWithBitsSet always NonMovedVariable
Line 642
  bitOperations always NonMovedVariable
Line 645
  = {symbolic=(tok2->link()),!0}
  endOfConditional {symbolic=(tok2->link()),!0}
Line 653
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(endOfConditional),symbolic=(tok2->link())}
  ";|{|}|: %var% = %any% ;" always ";|{|}|: %var% = %any% ;"
Line 661
  ( always {!<=-1,!>=2}
  ";|{|}|: %var% %assign% %num% ;" always ";|{|}|: %var% %assign% %num% ;"
  && always {!<=-1,!>=2}
Line 662
  1 always 1
  == always {!<=-1,!>=2}
  "|=" always "|="
  || always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "&=" always "&="
  && always {!<=-1,!>=2}
Line 663
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
Line 664
  1 always 1
  0 always 0
  2 always 2
Line 665
  :: possible {symbolic=(varsWithBitsSet.end()),end=0}
  i2 possible {symbolic=(varsWithBitsSet.end()),end=0}
  = possible lifetime[Iterator]=(varsWithBitsSet)
  ( possible lifetime[Iterator]=(varsWithBitsSet)
Line 668
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varsWithBitsSet),end=0}
Line 670
  tok2 always symbolic=(varsWithBitsSet[tok2->varId()])
Line 674
  == always {!<=-1,!>=2}
Line 675
  i2 always {!symbolic=(varsWithBitsSet.end()),!end=0}
  i2 always {!symbolic=(varsWithBitsSet.end()),!end=0}
Line 687
  ( always {!<=-1,!>=2}
  ";|{|}|: %var% = %name% %or%|& %num% ;" always ";|{|}|: %var% = %name% %or%|& %num% ;"
  && always {!<=-1,!>=2}
Line 688
  == always {!<=-1,!>=2}
  2 always 2
Line 689
  3 always 3
  4 always 4
Line 690
  :: possible {symbolic=(varsWithBitsSet.end()),end=0}
  i2 possible {symbolic=(varsWithBitsSet.end()),end=0}
  = possible lifetime[Iterator]=(varsWithBitsSet)
  ( possible lifetime[Iterator]=(varsWithBitsSet)
Line 693
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(varsWithBitsSet),end=0}
Line 695
  tok2 always symbolic=(varsWithBitsSet[tok2->varId()])
Line 699
  == always {!<=-1,!>=2}
Line 700
  i2 always {!symbolic=(varsWithBitsSet.end()),!end=0}
  i2 always {!symbolic=(varsWithBitsSet.end()),!end=0}
Line 712
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "|" always "|"
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "&" always "&"
Line 713
  ( always !0
Line 719
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(varsWithBitsSet[tok2->varId()])
Line 720
  varsWithBitsSet always NonMovedVariable
Line 721
  bitOperations always NonMovedVariable
Line 729
  tok possible 0@194
  :: always 3
  style always 3
Line 730
  "redundantBitwiseOperationInSwitch" always "redundantBitwiseOperationInSwitch"
Line 731
  "$symbol:" always "$symbol:"
  varname possible "varname"@194
  "\nRedundant bitwise operation on '$symbol' in 'switch' statement. 'break;' missing?" always "\nRedundant bitwise operation on '$symbol' in 'switch' statement. 'break;' missing?"
Line 741
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 746
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 747
  != always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 750
  != always {!<=-1,!>=2}
Line 751
  == always {!<=-1,!>=2}
  "case" always "case"
Line 752
  = always 0
  nullptr always 0
Line 753
  tok2 possible symbolic=(finding)
Line 754
  ( possible size=1
  == always {!<=-1,!>=2}
  ":" always ":"
Line 756
  ( always {!<=-1,!>=2}
  "[;}{]" always "[;}{]"
Line 759
  == always {!<=-1,!>=2}
  "?" always "?"
Line 760
  = always 0
  nullptr always 0
Line 761
  ( always {!<=-1,!>=2}
  "&&|%oror%" always "&&|%oror%"
Line 764
  finding possible 0
Line 765
  finding always !0
  finding always !0
Line 773
  tok possible 0@165
  :: always 2
  warning always 2
  "suspiciousCase" always "suspiciousCase"
Line 774
  "Found suspicious case label in switch(). Operator '" always "Found suspicious case label in switch(). Operator '"
  operatorString inconclusive "||"@165
  "' probably doesn't work as intended.\nUsing an operator like '" always "' probably doesn't work as intended.\nUsing an operator like '"
Line 775
  operatorString inconclusive "||"@165
  "' in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?" always "' in a case label is suspicious. Did you intend to use a bitwise operator, multiple case labels or if/else instead?"
Line 786
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 788
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 790
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 791
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 792
  = always 0
  nullptr always 0
Line 793
  = always 0
  nullptr always 0
Line 794
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|[|<" always "(|[|<"
Line 795
  = always !0
  ( always !0
Line 796
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  "break|continue ;" always "break|continue ;"
Line 797
  2 always 2
Line 798
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  "[;{}:] return|throw" always "[;{}:] return|throw"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 799
  ( always {!<=-1,!>=2}
  "?" always "?"
Line 803
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
Line 805
  == always {!<=-1,!>=2}
  ";" always ";"
Line 810
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  "goto %any% ;" always "goto %any% ;"
Line 811
  3 always 3
Line 813
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?|:" always "?|:"
Line 814
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(tok->function()->token),symbolic=(tok->function()->tokenDef)}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(tok->function()->token)
  ( always !0
  != always {!<=-1,!>=2}
  tok always !symbolic=(tok->function()->token)
  && always {!<=-1,!>=2}
  1 always 1
  1 always 1
  != always {!<=-1,!>=2}
  "{" always "{"
Line 815
  1 always 1
  2 always 2
Line 816
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 824
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  secondBreak possible {symbolic=(tok2->next()),0}
  && always {!<=-1,!>=2}
  secondBreak always !0
  1 always 1
  > always {!<=-1,!>=2}
  secondBreak always !0
Line 826
  secondBreak possible 0
  && always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inconclusive {symbolic=(secondBreak&&(secondBreak->linenr()-1>secondBreak->previous()->linenr())),!<=-1,!>=2}
Line 827
  ( always {!<=-1,!>=2}
  secondBreak always !0
  "continue|goto|throw|return" always "continue|goto|throw|return"
  && always {!<=-1,!>=2}
  secondBreak always !0
  ( always {!<=-1,!>=2}
Line 828
  secondBreak always !0
  inconclusive {symbolic=(secondBreak&&(secondBreak->linenr()-1>secondBreak->previous()->linenr())),!<=-1,!>=2}
Line 829
  secondBreak always !0
  "[}:]" always "[}:]"
Line 830
  secondBreak always !0
  == always {!<=-1,!>=2}
  "break" always "break"
Line 831
  == always {!<=-1,!>=2}
  "break" always "break"
Line 832
  secondBreak always !0
  inconclusive {symbolic=(secondBreak&&(secondBreak->linenr()-1>secondBreak->previous()->linenr())),!<=-1,!>=2}
Line 834
  != always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 835
  secondBreak always !0
  inconclusive {symbolic=(secondBreak&&(secondBreak->linenr()-1>secondBreak->previous()->linenr())),!<=-1,!>=2}
Line 837
  secondBreak always !0
  "[}:]" always "[}:]"
Line 838
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  secondBreak always !0
  "return|}|case|default" always "return|}|case|default"
  && always {!<=-1,!>=2}
  secondBreak always !0
  1 always 1
  != always {!<=-1,!>=2}
  ":" always ":"
Line 841
  labelInFollowingLoop always {!<=-1,!>=2}
  labelInFollowingLoop always {!<=-1,!>=2}
  = always 0
  false always 0
Line 842
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  secondBreak always !0
  "while|do|for" always "while|do|for"
Line 843
  secondBreak always !0
  "{" always "{"
Line 844
  scope2 always symbolic=(Token::findsimplematch(secondBreak,"{"))
Line 845
  = {symbolic=(Token::findsimplematch(secondBreak,"{")),!0}
  scope2 {symbolic=(Token::findsimplematch(secondBreak,"{")),!0}
  tokIter possible symbolic=(Token::findsimplematch(secondBreak,"{"))
  != always {!<=-1,!>=2}
  scope2 {symbolic=(Token::findsimplematch(secondBreak,"{")),!0}
  && always {!<=-1,!>=2}
  tokIter {!symbolic=(scope2->link()),symbolic=(Token::findsimplematch(secondBreak,"{"))}
Line 846
  ( always {!<=-1,!>=2}
  "[;{}] %any% :" always "[;{}] %any% :"
  && always {!<=-1,!>=2}
  labelName always !0
  == always {!<=-1,!>=2}
  1 always 1
Line 847
  labelInFollowingLoop always {!<=-1,!>=2}
  = always 1
  true always 1
Line 855
  silencedCompilerWarningOnly always {!<=-1,!>=2}
  silencedCompilerWarningOnly always {!<=-1,!>=2}
  = always 0
  false always 0
Line 856
  = always !0
  secondBreak always !0
Line 858
  ( always {!<=-1,!>=2}
  silencedWarning possible {symbolic=(secondBreak),symbolic=(scope->bodyEnd),0}
  "( void ) %name% ;" always "( void ) %name% ;"
Line 859
  5 always 5
Line 861
  silencedWarning possible symbolic=(scope->bodyEnd)
  && always {!<=-1,!>=2}
  silencedWarning always !0
  == always {!<=-1,!>=2}
Line 862
  silencedCompilerWarningOnly always {!<=-1,!>=2}
  = always 1
  true always 1
Line 866
  silencedWarning possible {symbolic=(scope->bodyEnd),0}
Line 867
  = always !0
  silencedWarning always !0
Line 869
  ! always {!<=-1,!>=2}
  labelInFollowingLoop always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  silencedCompilerWarningOnly always {!<=-1,!>=2}
Line 870
  inconclusive always {!<=-1,!>=2}
Line 871
  "[}:]" always "[}:]"
Line 873
  = always !0
  secondBreak always !0
Line 875
  ! always {!<=-1,!>=2}
  tok possible symbolic=(secondBreak)
Line 877
  tok always !0
Line 883
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 885
  tok possible 0@175
  :: always 3
  style always 3
  "duplicateBreak" always "duplicateBreak"
Line 886
  "Consecutive return, break, continue, goto or throw statements are unnecessary.\nConsecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed." always "Consecutive return, break, continue, goto or throw statements are unnecessary.\nConsecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed."
Line 888
  inconclusive {!<=-1,!>=2,symbolic=(secondBreak&&(secondBreak->linenr()-1>secondBreak->previous()->linenr()))@100,0@175}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 891
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 893
  tok possible 0@176
  :: always 3
  style always 3
  "unreachableCode" always "unreachableCode"
Line 894
  "Statements following return, break, continue, goto or throw will never be executed." always "Statements following return, break, continue, goto or throw will never be executed."
  inconclusive {!<=-1,!>=2,0@176}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 902
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
Line 905
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 912
  . always {!<=-1,!>=2}
  daca always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 915
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 916
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 919
  isPtrOrRef always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 920
  isSimpleType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 921
  ! always {!<=-1,!>=2}
  isPtrOrRef {symbolic=(var->isPointer()||var->isReference()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isSimpleType {symbolic=(var->typeStartToken()->isStandardType()||var->typeStartToken()->isEnumType()||(mTokenizer->isC()&&var->type()&&var->type()->isStructType())),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
Line 924
  ( always {!<=-1,!>=2}
  var always !0
  var always !0
Line 928
  ( always {!<=-1,!>=2}
  "& %var% = %var% ." always "& %var% = %var% ."
Line 929
  2 always 2
Line 931
  otherVar always symbolic=(otherVarToken->variable())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  otherVar {symbolic=(otherVarToken->variable()),!0}
  "%var% :" always "%var% :"
  && always {!<=-1,!>=2}
Line 932
  otherVar {symbolic=(otherVarToken->variable()),!0}
  && always {!<=-1,!>=2}
Line 933
  ( always {!<=-1,!>=2}
  otherVar always symbolic=(otherVarToken->variable())
  ( always !0
  "for (" always "for ("
Line 937
  forHead always {!<=-1,!>=2}
  forHead always {!<=-1,!>=2}
  = always 0
  false always 0
Line 939
  == always {!<=-1,!>=2}
  "(" always "("
Line 940
  forHead always {!<=-1,!>=2}
  = always 1
  true always 1
Line 942
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 945
  forHead {!<=-1,!>=2,0,1}
Line 949
  ( always {!<=-1,!>=2}
  tok always symbolic=(var->nameToken()->next())
  "; %varid% = %any% ;" always "; %varid% = %any% ;"
Line 950
  tok always symbolic=(var->nameToken()->next())
  3 always 3
Line 951
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 6
  eString always 6
  && always {!<=-1,!>=2}
  ( always !6
  != always {!<=-1,!>=2}
  :: always 7
  eChar always 7
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 955
  ( always {!<=-1,!>=2}
  tok possible symbolic=(var->nameToken()->next())
  "[(=]" always "[(=]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 957
  reduce always {!<=-1,!>=2}
  reduce always {!<=-1,!>=2}
  = always 1
  true always 1
Line 958
  used always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
  = always 0
  false always 0
Line 959
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 960
  ( possible size=4
  == {!<=-1,!>=2,0}
  "{" always "{"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 961
  used always {!<=-1,!>=2}
Line 962
  used2 always {!<=-1,!>=2}
  used2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 963
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  used2 always 0
  || always {!<=-1,!>=2}
  used2 always {!<=-1,!>=2}
Line 964
  reduce always {!<=-1,!>=2}
  = always 0
  false always 0
Line 967
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  used always 0
Line 968
  reduce always {!<=-1,!>=2}
  = always 0
  false always 0
Line 975
  ( always {!<=-1,!>=2}
  "else { if (" always "else { if ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  ") {" always ") {"
Line 976
  3 always 3
  1 always 1
Line 977
  elseif {!<=-1,!>=2,0}
  elseif always {!<=-1,!>=2}
  = always 0
  false always 0
Line 978
  ( always {!<=-1,!>=2}
  "} }" always "} }"
Line 979
  elseif always {!<=-1,!>=2}
  = always 1
  true always 1
Line 980
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "} }" always "} }"
Line 981
  elseif always {!<=-1,!>=2}
  = always 1
  true always 1
Line 982
  elseif {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  1 always 1
Line 983
  reduce always {!<=-1,!>=2}
  = always 0
  false always 0
Line 986
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "goto" always "goto"
Line 987
  reduce always {!<=-1,!>=2}
  = always 0
  false always 0
Line 992
  reduce {!<=-1,!>=2,1,0}
  && always {!<=-1,!>=2}
  used {!<=-1,!>=2,0}
Line 997
  ( always {!<=-1,!>=2}
  used always {!<=-1,!>=2}
Line 1000
  loopVariable always {!<=-1,!>=2}
  loopVariable always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  scope always symbolic=(tok->next()->scope())
  ( always {!<=-1,!>=2}
Line 1001
  noContinue always {!<=-1,!>=2}
  noContinue always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1002
  = always 0
  nullptr always 0
Line 1004
  scope always symbolic=(tok->next()->scope())
  . possible {10,11}
  == {!<=-1,!>=2,0}
  :: always 12
  eUnconditional always 12
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1005
  loopVariable always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1007
  scope always symbolic=(tok->next()->scope())
  . possible {11,12}
  == {!<=-1,!>=2,0}
  :: always 10
  eDo always 10
Line 1008
  end always symbolic=(tok->link())
  2 always 2
Line 1009
  loopVariable {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1010
  -1 always -1
Line 1011
  scope always symbolic=(tok->next()->scope())
  . always !10
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 1012
  scope always symbolic=(tok->next()->scope())
Line 1013
  used always {!<=-1,!>=2}
Line 1014
  used2 always {!<=-1,!>=2}
  used2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1015
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  used2 always 0
  || always {!<=-1,!>=2}
  used2 always {!<=-1,!>=2}
Line 1016
  return always {!<=-1,!>=2}
  false always 0
Line 1018
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  used always 0
Line 1019
  return always {!<=-1,!>=2}
  false always 0
Line 1024
  bFirstAssignment always {!<=-1,!>=2}
  bFirstAssignment always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1025
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1026
  ( possible size=8
  == {!<=-1,!>=2,0}
  "goto" always "goto"
Line 1027
  return always {!<=-1,!>=2}
  false always 0
Line 1028
  == always {!<=-1,!>=2}
  "continue" always "continue"
Line 1029
  noContinue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1031
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 1032
  1 always 1
Line 1033
  == always {!<=-1,!>=2}
Line 1034
  = always 0
  nullptr always 0
Line 1036
  loopVariable always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  noContinue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
  != always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% =" always "%varid% ="
Line 1037
  loopVariable always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1038
  = always 0
  0 always 0
Line 1039
  2 always 2
Line 1040
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1042
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1043
  == always {!<=-1,!>=2}
  0 always 0
Line 1045
  indent always !0
  -- always !0
Line 1046
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1048
  == always {!<=-1,!>=2}
Line 1049
  loopVariable always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1055
  loopVariable {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% !!=" always "%varid% !!="
Line 1056
  return always {!<=-1,!>=2}
  false always 0
Line 1058
  ( always {!<=-1,!>=2}
  "& %varid%" always "& %varid%"
  ( possible symbolic=(tok->varId())
Line 1059
  return always {!<=-1,!>=2}
  false always 0
Line 1061
  ( always {!<=-1,!>=2}
  "%varid% =" always "%varid% ="
  ( possible symbolic=(tok->varId())
Line 1062
  bFirstAssignment always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1064
  ! {!<=-1,!>=2,0}
  bFirstAssignment {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "* %varid%" always "* %varid%"
Line 1065
  return always {!<=-1,!>=2}
  false always 0
Line 1067
  ( always {!<=-1,!>=2}
  "= %varid%" always "= %varid%"
  ( possible symbolic=(tok->varId())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 1068
  return always {!<=-1,!>=2}
  false always 0
Line 1070
  == always {!<=-1,!>=2}
Line 1071
  used always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1072
  == always {!<=-1,!>=2}
Line 1073
  scope always symbolic=(tok->scope())
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 1074
  return always {!<=-1,!>=2}
  false always 0
Line 1076
  scope always symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
  . always !0
  ( always {!<=-1,!>=2}
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1082
  return always {!<=-1,!>=2}
  true always 1
Line 1087
  tok possible 0@162
Line 1088
  :: always 3
  style always 3
Line 1089
  "variableScope" always "variableScope"
Line 1090
  "$symbol:" always "$symbol:"
  varname possible "varname"@162
  "\nThe scope of the variable '$symbol' can be reduced.\nThe scope of the variable '$symbol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:\nvoid f(int x)\n{\n    int i = 0;\n    if (x) {\n        // it's safe to move 'int i = 0;' here\n        for (int n = 0; n < 10; ++n) {\n            // it is possible but not safe to move 'int i = 0;' here\n            do_something(&i);\n        }\n    }\n}\nWhen you see this message it is always safe to reduce the variable scope 1 level." always "\nThe scope of the variable '$symbol' can be reduced.\nThe scope of the variable '$symbol' can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for 'i' can be reduced:\nvoid f(int x)\n{\n    int i = 0;\n    if (x) {\n        // it's safe to move 'int i = 0;' here\n        for (int n = 0; n < 10; ++n) {\n            // it is possible but not safe to move 'int i = 0;' here\n            do_something(&i);\n        }\n    }\n}\nWhen you see this message it is always safe to reduce the variable scope 1 level."
Line 1106
  :: always 0
  normal always 0
Line 1115
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  experimental always 3
Line 1118
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1122
  == always {!<=-1,!>=2}
  "return" always "return"
Line 1124
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1125
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "[([{<]" always "[([{<]"
Line 1126
  = always !0
  tok always !0
  ( always !0
Line 1128
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 1134
  ! always {!<=-1,!>=2}
Line 1142
  tok possible 0@185
Line 1143
  :: always 3
  style always 3
Line 1144
  "commaSeparatedReturn" always "commaSeparatedReturn"
Line 1145
  "Comma is used in return statement. The comma can easily be misread as a ';'.\nComma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon. For example in the code below the value of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is returned:\n    if (x)\n        return a + 1,\n    b++;\nHowever it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood." always "Comma is used in return statement. The comma can easily be misread as a ';'.\nComma is used in return statement. When comma is used in a return statement it can easily be misread as a semicolon. For example in the code below the value of 'b' is returned if the condition is true, but it is easy to think that 'a+1' is returned:\n    if (x)\n        return a + 1,\n    b++;\nHowever it can be useful to use comma in macros. Cppcheck does not warn when such a macro is then used in a return statement, it is less likely such code is misunderstood."
Line 1154
  :: always 0
  normal always 0
Line 1160
  , always 0
  = always 0
  0 always 0
Line 1162
  recursionDepth possible 0
  > {!<=-1,!>=2,0}
  20 always 20
Line 1163
  0 always 0
Line 1165
  = always 0
  0 always 0
Line 1166
  isUnion always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 1167
  isUnion always {!<=-1,!>=2}
Line 1168
  isUnion always {!<=-1,!>=2}
Line 1174
  = always 0
  0 always 0
Line 1175
  ( always {!<=-1,!>=2}
Line 1177
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1179
  && always {!<=-1,!>=2}
  ( always !0
Line 1180
  ( always !0
  1 always 1
Line 1181
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 1182
  3 always 3
Line 1186
  ( always {!<=-1,!>=2}
Line 1187
  ( {lifetime[Iterator]=(var.dimensions()),lifetime[Object]=(type->classScope->varlist),start=0}
  ( {lifetime[Iterator]=(var.dimensions()),lifetime[Object]=(type->classScope->varlist),end=0}
  1 always 1
Line 1191
  isUnion always {!<=-1,!>=2}
Line 1194
  && always {!<=-1,!>=2}
  . always !0
Line 1195
  . always !0
  1 always 1
Line 1200
  ( always {!<=-1,!>=2}
Line 1205
  func_scope always symbolic=(var->scope()->function)
  == always {!<=-1,!>=2}
  :: always 0
  eConstructor always 0
Line 1207
  func_scope always symbolic=(var->scope()->function)
  == always {!<=-1,!>=2}
  ":" always ":"
Line 1208
  func_scope always symbolic=(var->scope()->function)
  != always {!<=-1,!>=2}
Line 1209
  != always {!<=-1,!>=2}
Line 1212
  parent always symbolic=(tok2->astParent())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  "move (" always "move ("
Line 1213
  return always {!<=-1,!>=2}
  false always 0
Line 1218
  != always {!<=-1,!>=2}
Line 1219
  != always {!<=-1,!>=2}
Line 1223
  ! always {!<=-1,!>=2}
  parent always symbolic=(tok2->astParent())
Line 1225
  parent {symbolic=(tok2->astParent()),!0}
  ( possible {size=2,size=1}
  == {!<=-1,!>=2,0}
  "<<" always "<<"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  parent {symbolic=(tok2->astParent()),!0}
Line 1226
  parent {symbolic=(tok2->astParent()),!0}
  ( possible size=2
  == always {!<=-1,!>=2}
  "<<" always "<<"
  && always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  == always {!<=-1,!>=2}
Line 1227
  return always {!<=-1,!>=2}
  false always 0
Line 1228
  parent always !0
  == always {!<=-1,!>=2}
  ">>" always ">>"
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
Line 1229
  return always {!<=-1,!>=2}
  false always 0
Line 1230
  parent {symbolic=(tok2->astParent()),!0}
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  == always {!<=-1,!>=2}
  "(" always "("
Line 1232
  = always 0
  0 always 0
Line 1233
  tok3 possible symbolic=(tok2->previous())
  && always {!<=-1,!>=2}
  tok3 {symbolic=(tok2->previous()),!0}
  != always {!<=-1,!>=2}
  "(" always "("
Line 1234
  tok3 always !0
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok3 always !0
  ")|]|}|>" always ")|]|}|>"
Line 1235
  = always !0
  tok3 always !0
  ( always !0
Line 1236
  tok3 always !0
  ( possible 0
Line 1238
  tok3 always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1240
  tok3 always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 1244
  ! always {!<=-1,!>=2}
  tok3 possible symbolic=(tok2->previous())
  || always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
  "(" always "("
Line 1245
  return always {!<=-1,!>=2}
  false always 0
Line 1246
  tok3 always !0
Line 1247
  ! always {!<=-1,!>=2}
  functionTok always symbolic=(tok3->astOperand1())
Line 1248
  return always {!<=-1,!>=2}
  false always 0
Line 1249
  functionTok {symbolic=(tok3->astOperand1()),!0}
Line 1250
  ! {!<=-1,!>=2,1}
  tokFunction {symbolic=(functionTok->function()),0}
  && always {!<=-1,!>=2}
  functionTok {symbolic=(tok3->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  functionTok {symbolic=(tok3->astOperand1()),!0}
Line 1251
  functionTok always !0
Line 1252
  tokFunction possible symbolic=(functionTok->function())
Line 1253
  tokFunction always !0
Line 1254
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  argVar always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argVar always !0
  ( always {!<=-1,!>=2}
Line 1255
  return always {!<=-1,!>=2}
  false always 0
Line 1257
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1258
  return always {!<=-1,!>=2}
  false always 0
Line 1259
  parent {symbolic=(tok2->astParent()),!0}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1261
  return always {!<=-1,!>=2}
  false always 0
Line 1262
  parent {symbolic=(tok2->astParent()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1263
  parent {symbolic=(tok2->astParent()),!0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  ( always !0
Line 1265
  parent {symbolic=(tok2->astParent()),!0}
  ( always {!<=-1,!>=2}
Line 1266
  parent {symbolic=(tok2->astParent()),!0}
  == always {!<=-1,!>=2}
Line 1267
  return always {!<=-1,!>=2}
  false always 0
Line 1268
  parent always !0
  ( always !symbolic=(tok2)
  parent always !0
  ( always {!symbolic=(tok2),!0}
  : always 0
  nullptr always 0
Line 1269
  assignedVar always symbolic=(parent->astOperand1()?parent->astOperand1()->variable():nullptr)
  && always {!<=-1,!>=2}
Line 1270
  ! always {!<=-1,!>=2}
  assignedVar {symbolic=(parent->astOperand1()?parent->astOperand1()->variable():nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1271
  assignedVar {symbolic=(parent->astOperand1()?parent->astOperand1()->variable():nullptr),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1272
  assignedVar always symbolic=(parent->astOperand1()?parent->astOperand1()->variable():nullptr)
  == always {!<=-1,!>=2}
  parent always !0
  ( always !symbolic=(tok2)
Line 1273
  return always {!<=-1,!>=2}
  false always 0
Line 1274
  ( always {!<=-1,!>=2}
  "%var% . %name% (" always "%var% . %name% ("
Line 1275
  2 always 2
Line 1276
  && always {!<=-1,!>=2}
  func always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  func always !0
  ( always {!<=-1,!>=2}
Line 1279
  return always {!<=-1,!>=2}
  false always 0
Line 1281
  return always {!<=-1,!>=2}
  false always 0
Line 1284
  return always {!<=-1,!>=2}
  true always 1
Line 1289
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1294
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1295
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1298
  var always !0
  ( possible 0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  -1 always -1
  == always {!<=-1,!>=2}
  "..." always "..."
Line 1301
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1302
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  . always !0
  && always {!<=-1,!>=2}
  var always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 1305
  inconclusive {!<=-1,!>=2,0}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1307
  isContainer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always !0
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
Line 1308
  ! always {!<=-1,!>=2}
  isContainer {symbolic=(var->valueType()&&var->valueType()->type==ValueType::Type::CONTAINER&&var->valueType()->container&&!var->valueType()->container->view),!<=-1,!>=2}
Line 1309
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1311
  ! always {!<=-1,!>=2}
  ( always !0
Line 1312
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1313
  ( always !0
  <= always {!<=-1,!>=2}
  2 always 2
Line 1320
  inconclusive {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1323
  isConst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1324
  isConst {symbolic=(var->isConst()),!<=-1,!>=2}
Line 1325
  inconclusive always {!<=-1,!>=2}
Line 1330
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1333
  ( always {!<=-1,!>=2}
Line 1334
  inconclusive always {!<=-1,!>=2}
Line 1339
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1341
  tok possible 0@156
  :: always 4
  performance always 4
  "passedByValue" always "passedByValue"
Line 1342
  "$symbol:" always "$symbol:"
  parname inconclusive "parametername"@156
  "\nFunction parameter '$symbol' should be passed by const reference.\nParameter '$symbol' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++." always "\nFunction parameter '$symbol' should be passed by const reference.\nParameter '$symbol' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++."
Line 1345
  inconclusive {!<=-1,!>=2,0@156}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1348
  ( always {!<=-1,!>=2}
Line 1350
  ! always {!<=-1,!>=2}
Line 1351
  return always {!<=-1,!>=2}
  false always 0
Line 1352
  ! always {!<=-1,!>=2}
  var always !0
Line 1353
  return always {!<=-1,!>=2}
  false always 0
Line 1354
  var always !0
Line 1355
  ! always {!<=-1,!>=2}
  start always symbolic=(var->declEndToken())
Line 1356
  return always {!<=-1,!>=2}
  false always 0
Line 1357
  ( always {!<=-1,!>=2}
  start {symbolic=(var->declEndToken()),!0}
  "; %varid% =" always "; %varid% ="
Line 1358
  start {symbolic=(var->declEndToken()),!0}
  2 always 2
Line 1359
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  ( always !0
Line 1362
  ( always {!<=-1,!>=2}
Line 1364
  ! always {!<=-1,!>=2}
Line 1365
  return always {!<=-1,!>=2}
  false always 0
Line 1366
  ! always {!<=-1,!>=2}
Line 1367
  return always {!<=-1,!>=2}
  false always 0
Line 1368
  = always !0
  start always !0
  != always {!<=-1,!>=2}
  end always !0
Line 1369
  != always {!<=-1,!>=2}
Line 1372
  ( always !0
Line 1373
  ( always {!<=-1,!>=2}
  memberTok always symbolic=(tok->astParent()->previous())
  "%var% (" always "%var% ("
  && always {!<=-1,!>=2}
  memberTok always symbolic=(tok->astParent()->previous())
Line 1374
  = always !0
  memberTok always symbolic=(tok->astParent()->previous())
  ( always !0
Line 1375
  memberVar {symbolic=(memberTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1378
  return always {!<=-1,!>=2}
  true always 1
Line 1379
  ! always {!<=-1,!>=2}
  memberVar {symbolic=(memberTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1381
  ( always {!<=-1,!>=2}
Line 1384
  return always {!<=-1,!>=2}
  true always 1
Line 1386
  return always {!<=-1,!>=2}
  true always 1
Line 1389
  return always {!<=-1,!>=2}
  false always 0
Line 1394
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1399
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1400
  ! always {!<=-1,!>=2}
Line 1402
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1404
  var always !0
  ( always {!<=-1,!>=2}
Line 1406
  ( always {!<=-1,!>=2}
Line 1408
  ( always {!<=-1,!>=2}
Line 1410
  ! always {!<=-1,!>=2}
Line 1412
  = always !0
  ( always !0
Line 1413
  ! always {!<=-1,!>=2}
  scope {symbolic=(var->scope()),!0}
Line 1415
  = always !0
  scope {symbolic=(var->scope()),!0}
  . always !0
Line 1416
  ( always {!<=-1,!>=2}
Line 1417
  function {symbolic=(scope->function),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
Line 1419
  ( always {!<=-1,!>=2}
Line 1421
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1424
  ( always {!<=-1,!>=2}
Line 1426
  ( always {!<=-1,!>=2}
Line 1428
  ( always {!<=-1,!>=2}
Line 1430
  ( always {!<=-1,!>=2}
Line 1432
  ( always {!<=-1,!>=2}
Line 1434
  ( always {!<=-1,!>=2}
Line 1436
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1438
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1440
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(returns),start=0}
  ( {lifetime[Iterator]=(returns),end=0}
  [ possible lifetime[Lambda]=(var)
Line 1441
  == always {!<=-1,!>=2}
Line 1442
  true always 1
Line 1443
  && always {!<=-1,!>=2}
Line 1444
  retTok always !0
Line 1445
  ( always {!<=-1,!>=2}
  retTok possible 0
  "." always "."
Line 1447
  ( always {!<=-1,!>=2}
Line 1452
  "& %varid%" always "& %varid%"
Line 1457
  usedInAssignment always {!<=-1,!>=2}
  usedInAssignment always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1458
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(scope->bodyEnd)
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1459
  ( always {!<=-1,!>=2}
  "& %var% = %varid%" always "& %var% = %varid%"
Line 1461
  refvar always symbolic=(tok->next()->variable())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  refvar {symbolic=(tok->next()->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  refvar {symbolic=(tok->next()->variable()),!0}
  == always {!<=-1,!>=2}
Line 1462
  usedInAssignment always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1467
  usedInAssignment {!<=-1,!>=2,0,1}
Line 1472
  castToNonConst always {!<=-1,!>=2}
  castToNonConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1473
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(scope->bodyEnd)
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1474
  ( always {!<=-1,!>=2}
Line 1475
  ! always {!<=-1,!>=2}
Line 1476
  castToNonConst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1479
  isConst always {!<=-1,!>=2}
  isConst always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  0 always 0
  != always {!<=-1,!>=2}
  ( always !0
  1 always 1
  ( always !0
Line 1480
  ! always {!<=-1,!>=2}
  isConst {symbolic=(0!=(tok->valueType()->constness&(1<<tok->valueType()->pointer))),!<=-1,!>=2}
Line 1481
  castToNonConst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1486
  castToNonConst {!<=-1,!>=2,0,1}
Line 1491
  changeStructData always {!<=-1,!>=2}
  changeStructData always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1492
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(scope->bodyEnd)
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1493
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% ." always "%var% ."
Line 1495
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  "." always "."
  && always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  == always {!<=-1,!>=2}
  parent possible symbolic=(tok)
Line 1496
  parent always symbolic=(parent->astParent()->astOperand1())
Line 1497
  parent possible symbolic=(tok)
  && always {!<=-1,!>=2}
Line 1498
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1499
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1500
  ( always {!<=-1,!>=2}
  1 always 1
  ( always {!<=-1,!>=2}
Line 1501
  changeStructData always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1506
  changeStructData {!<=-1,!>=2,0,1}
Line 1510
  var possible symbolic=(tok->variable())
  ( always {!<=-1,!>=2}
Line 1511
  callNonConstMethod always {!<=-1,!>=2}
  callNonConstMethod always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1512
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !symbolic=(scope->bodyEnd)
  != always {!<=-1,!>=2}
  nullptr always 0
Line 1513
  == always {!<=-1,!>=2}
Line 1514
  ( always {!<=-1,!>=2}
  "%var% . * ( & %name% ::" always "%var% . * ( & %name% ::"
Line 1515
  3 always 3
Line 1516
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1517
  callNonConstMethod always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1520
  var always symbolic=(tok->variable())
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% [" always "%var% ["
Line 1521
  var always symbolic=(tok->variable())
  var always symbolic=(tok->variable())
  ( always !0
  2 always 2
  : always 0
  nullptr always 0
Line 1523
  && always {!<=-1,!>=2}
  notConst always symbolic=(CheckClass::stl_containers_not_const)
  ( possible {lifetime[Iterator]=(CheckClass::stl_containers_not_const),lifetime[Object]=(stl_containers_not_const)}
  typeTok always !0
  != always {!<=-1,!>=2}
  notConst always symbolic=(CheckClass::stl_containers_not_const)
  ( {lifetime[Iterator]=(CheckClass::stl_containers_not_const),lifetime[Object]=(stl_containers_not_const),end=0}
Line 1524
  callNonConstMethod always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1530
  callNonConstMethod {!<=-1,!>=2,0,1}
Line 1540
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1546
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 1548
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1550
  var always !0
Line 1552
  tok possible symbolic=(nameTok)
  == {!<=-1,!>=2,1}
  nameTok {symbolic=(var->nameToken()),symbolic=(tok)}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always {symbolic=(var->nameToken()),symbolic=(tok)}
  "[" always "["
  && always {!<=-1,!>=2}
Line 1554
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always {symbolic=(var->nameToken()),symbolic=(tok)}
  ":" always ":"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nameTok always {symbolic=(var->nameToken()),symbolic=(tok)}
  "(" always "("
Line 1556
  tok possible symbolic=(nameTok)
Line 1557
  ! always {!<=-1,!>=2}
  vt always symbolic=(tok->valueType())
Line 1559
  vt {symbolic=(tok->valueType()),!0}
  . possible 2
  != {!<=-1,!>=2,1}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  vt {symbolic=(tok->valueType()),!0}
  . always !1
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  vt {symbolic=(tok->valueType()),!0}
  & possible {0,1}
  1 always 1
  || always {!<=-1,!>=2}
  vt {symbolic=(tok->valueType()),!0}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 1561
  ( possible lifetime[Iterator]=(nonConstPointers)
  ( {lifetime[Iterator]=(nonConstPointers),start=0}
  ( {lifetime[Iterator]=(nonConstPointers),end=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(nonConstPointers),end=0}
Line 1564
  tok possible symbolic=(nameTok)
Line 1565
  deref {!<=-1,!>=2,0}
  deref always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1566
  parent always symbolic=(tok->astParent())
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 1567
  deref always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1568
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),0}
  "[" always "["
  && always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always symbolic=(parent->astOperand1())
  != always {!<=-1,!>=2}
Line 1569
  deref always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1570
  deref {!<=-1,!>=2,1}
Line 1571
  parent always symbolic=(tok->astParent())
Line 1572
  ( always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  "%cop%" always "%cop%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 1574
  ( always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  "return" always "return"
Line 1576
  ( always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
Line 1577
  takingRef {!<=-1,!>=2,0}
  takingRef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1578
  gparent always symbolic=(parent->astParent())
Line 1579
  lhs {symbolic=(gparent->astOperand1()),symbolic=(lhs->variable()->nameToken())}
  && always {!<=-1,!>=2}
  lhs {symbolic=(gparent->astOperand1()),!0}
  && always {!<=-1,!>=2}
  lhs {symbolic=(gparent->astOperand1()),!0}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lhs always symbolic=(gparent->astOperand1())
  ( always !0
  == always {!<=-1,!>=2}
  lhs always symbolic=(gparent->astOperand1())
Line 1580
  takingRef always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1581
  ! {!<=-1,!>=2,0}
  takingRef {!<=-1,!>=2,1}
Line 1583
  ( always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  "[" always "["
  && always {!<=-1,!>=2}
  gparent always symbolic=(parent->astParent())
  == always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
Line 1586
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "%oror%|%comp%|&&|?|!|-" always "%oror%|%comp%|&&|?|!|-"
Line 1588
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "if|while" always "if|while"
Line 1594
  ( always {!<=-1,!>=2}
Line 1595
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  || always {!<=-1,!>=2}
  ( always !0
  . always !0
  ( always {!<=-1,!>=2}
  true always 1
  || always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
Line 1598
  ( possible lifetime[Iterator]=(nonConstPointers)
  ( {lifetime[Iterator]=(nonConstPointers),start=0}
  ( {lifetime[Iterator]=(nonConstPointers),end=0}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(nonConstPointers),end=0}
Line 1599
  ( always {!<=-1,!>=2}
Line 1600
  = always !<=-1
  ( always {!<=-1,!>=2}
  ? always !<=-1
  ( always !<=-1
  : always 1
  1 always 1
Line 1601
  ( always {!<=-1,!>=2}
  start always symbolic=((p->isArgument())?p->scope()->bodyStart:p->nameToken()->next())
  false always 0
  ( always {!<=-1,!>=2}
Line 1603
  nullptr always 0
Line 1609
  ! {!<=-1,!>=2,1}
  var possible 0
Line 1610
  nullptr always 0
  :: always 3
  style always 3
  "constParameter" always "constParameter"
  "Parameter 'x' can be declared with const" always "Parameter 'x' can be declared with const"
Line 1611
  nullptr always 0
  :: always 3
  style always 3
  "constVariable" always "constVariable"
  "Variable 'x' can be declared with const" always "Variable 'x' can be declared with const"
Line 1612
  nullptr always 0
  :: always 3
  style always 3
  "constParameterCallback" always "constParameterCallback"
  "Parameter 'x' can be declared with const, however it seems that 'f' is a callback function." always "Parameter 'x' can be declared with const, however it seems that 'f' is a callback function."
Line 1616
  var always !0
  ( {!<=-1,!>=2,0}
  "Parameter" always "Parameter"
  : always "Variable"
  "Variable" always "Variable"
Line 1617
  var always !0
Line 1620
  "const" always "const"
Line 1621
  "$symbol:" always "$symbol:"
  "\n" always "\n"
  " '$symbol' can be declared with const" always " '$symbol' can be declared with const"
Line 1622
  errorPath always size=0
  var always 1
  ? possible 0
  var always !0
  : always 0
  nullptr always 0
  message always symbolic=("$symbol:"+varname+"\n"+vartype+" '$symbol' can be declared with const")
Line 1623
  var always 1
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  function always !0
Line 1624
  errorPath always size=1
  function always !0
  "You might need to cast the function pointer here" always "You might need to cast the function pointer here"
Line 1625
  "Callback" always "Callback"
Line 1626
  ". However it seems that '" always ". However it seems that '"
  function always !0
  "' is a callback function, if '$symbol' is declared with const you might also need to cast function pointer(s)." always "' is a callback function, if '$symbol' is declared with const you might also need to cast function pointer(s)."
Line 1629
  errorPath possible size=1
  :: always 3
  style always 3
  id possible symbolic=("const"+vartype)
  ( {lifetime[Object]=(id),!0}
  message inconclusive symbolic=("$symbol:"+varname+"\n"+vartype+" '$symbol' can be declared with const")
  :: always 0
  normal always 0
Line 1638
  warning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1639
  portability always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 1640
  ! {!<=-1,!>=2,1}
  warning {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  portability always {!<=-1,!>=2}
Line 1644
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1645
  != always {!<=-1,!>=2}
Line 1646
  ( always {!<=-1,!>=2}
  "%var% [" always "%var% ["
Line 1647
  ! always {!<=-1,!>=2}
Line 1649
  ! {!<=-1,!>=2,1}
  ( always !0
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1652
  warning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  index always symbolic=(tok->next()->astOperand2())
  && always {!<=-1,!>=2}
  index always symbolic=(tok->next()->astOperand2())
  0x80 always 128
Line 1654
  portability always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  index always symbolic=(tok->next()->astOperand2())
  && always {!<=-1,!>=2}
  index always symbolic=(tok->next()->astOperand2())
  0x80 always 128
Line 1656
  warning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[&|^]" always "[&|^]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1657
  warn {!<=-1,!>=2,0}
  warn always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1658
  ( always {!<=-1,!>=2}
Line 1659
  -1 always -1
Line 1660
  false always 0
Line 1661
  ! always {!<=-1,!>=2}
Line 1662
  0x80 always 128
Line 1663
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=0,!<=-1}
  < {!<=-1,!>=2,>=1}
  0x100 always 256
Line 1664
  warn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1665
  ( always {!<=-1,!>=2}
Line 1666
  -1 always -1
Line 1667
  false always 0
Line 1668
  ! always {!<=-1,!>=2}
Line 1669
  0x80 always 128
Line 1670
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=0,!<=-1}
  < {!<=-1,!>=2,>=1}
  0x100 always 256
Line 1671
  warn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1675
  warn {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 1677
  lhs always symbolic=(tok->astParent()->astOperand1())
  && always {!<=-1,!>=2}
  lhs {symbolic=(tok->astParent()->astOperand1()),!0}
  && always {!<=-1,!>=2}
  lhs {symbolic=(tok->astParent()->astOperand1()),!0}
  ( always !0
  >= always {!<=-1,!>=2}
  :: always 10
  SHORT always 10
Line 1687
  tok possible 0@159
Line 1688
  :: always 2
  warning always 2
Line 1689
  "signedCharArrayIndex" always "signedCharArrayIndex"
Line 1690
  "Signed 'char' type used as array index.\nSigned 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension." always "Signed 'char' type used as array index.\nSigned 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension."
Line 1693
  :: always 0
  normal always 0
Line 1698
  tok possible 0@160
Line 1699
  :: always 5
  portability always 5
Line 1700
  "unknownSignCharArrayIndex" always "unknownSignCharArrayIndex"
Line 1701
  "'char' type used as array index.\n'char' type used as array index. Values greater than 127 will be treated depending on whether 'char' is signed or unsigned on target platform." always "'char' type used as array index.\n'char' type used as array index. Values greater than 127 will be treated depending on whether 'char' is signed or unsigned on target platform."
Line 1703
  :: always 0
  normal always 0
Line 1708
  tok possible 0@161
Line 1709
  :: always 2
  warning always 2
Line 1710
  "charBitOp" always "charBitOp"
Line 1711
  "When using 'char' variables in bit operations, sign extension can generate unexpected results.\nWhen using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\n    char c = 0x80;\n    int i = 0 | c;\n    if (i & 0x8000)\n        printf(\"not expected\");\nThe \"not expected\" will be printed on the screen." always "When using 'char' variables in bit operations, sign extension can generate unexpected results.\nWhen using 'char' variables in bit operations, sign extension can generate unexpected results. For example:\n    char c = 0x80;\n    int i = 0 | c;\n    if (i & 0x8000)\n        printf(\"not expected\");\nThe \"not expected\" will be printed on the screen."
Line 1717
  :: always 0
  normal always 0
Line 1724
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 1726
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astOperand1())@170
  "%type%" always "%type%"
Line 1727
  return always {!<=-1,!>=2}
  true always 1
Line 1728
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astOperand1())@170
  "::" always "::"
Line 1729
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 1730
  ( always {!<=-1,!>=2}
  "<" always "<"
  && always {!<=-1,!>=2}
Line 1731
  return always {!<=-1,!>=2}
  true always 1
Line 1732
  unknown always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% !!(" always "%name% !!("
Line 1733
  return always {!<=-1,!>=2}
  true always 1
Line 1734
  return always {!<=-1,!>=2}
  false always 0
Line 1737
  ( always {!<=-1,!>=2}
Line 1739
  ! always {!<=-1,!>=2}
Line 1740
  return always {!<=-1,!>=2}
  false always 0
Line 1741
  tok always !0
Line 1742
  vartok {symbolic=(tok->astOperand2()),symbolic=(vartok->variable()->nameToken())}
  && always {!<=-1,!>=2}
  vartok {symbolic=(tok->astOperand2()),!0}
  && always {!<=-1,!>=2}
  vartok {symbolic=(tok->astOperand2()),!0}
  ( always !0
  == always {!<=-1,!>=2}
  vartok {symbolic=(tok->astOperand2()),!0}
Line 1743
  return always {!<=-1,!>=2}
  true always 1
Line 1744
  tok always !0
Line 1745
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  typetok always symbolic=(tok->astOperand1())
  ( always {!<=-1,!>=2}
  vartok {symbolic=(tok->astOperand2()),0}
  "%var%" always "%var%"
Line 1748
  ( always {!<=-1,!>=2}
Line 1750
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1751
  return always {!<=-1,!>=2}
  false always 0
Line 1752
  = always !0
  ( always !0
Line 1753
  tok always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 1754
  tok always !0
Line 1755
  ( always {!<=-1,!>=2}
  tok possible 0
  "[" always "["
Line 1757
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
Line 1758
  return always {!<=-1,!>=2}
  false always 0
Line 1759
  return always {!<=-1,!>=2}
  tok always !0
  ( always !0
  != always {!<=-1,!>=2}
  tok always !0
Line 1762
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1764
  ! always {!<=-1,!>=2}
Line 1765
  return always {!<=-1,!>=2}
  false always 0
Line 1766
  tok always !0
  ( always {!<=-1,!>=2}
Line 1767
  return always {!<=-1,!>=2}
  false always 0
Line 1768
  ( always {!<=-1,!>=2}
  tok always !0
  "%bool%|%num%|%str%|%char%|nullptr|NULL" always "%bool%|%num%|%str%|%char%|nullptr|NULL"
Line 1769
  return always {!<=-1,!>=2}
  true always 1
Line 1770
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 1771
  return always {!<=-1,!>=2}
  true always 1
Line 1772
  ( always {!<=-1,!>=2}
  "*|&|&&" always "*|&|&&"
  && always {!<=-1,!>=2}
Line 1773
  ( always {!<=-1,!>=2}
  "::|.|const|volatile|restrict" always "::|.|const|volatile|restrict"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1774
  return always {!<=-1,!>=2}
  false always 0
Line 1775
  ( always {!<=-1,!>=2}
  "<<|>>" always "<<|>>"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 1776
  return always {!<=-1,!>=2}
  false always 0
Line 1777
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "delete" always "delete"
Line 1778
  return always {!<=-1,!>=2}
  false always 0
Line 1779
  ( always {!<=-1,!>=2}
  "&&|%oror%" always "&&|%oror%"
Line 1780
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1781
  ( always {!<=-1,!>=2}
  "!|~|%cop%" always "!|~|%cop%"
  && always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1782
  return always {!<=-1,!>=2}
  true always 1
Line 1783
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 1784
  return always {!<=-1,!>=2}
  true always 1
Line 1785
  ( always {!<=-1,!>=2}
Line 1786
  ( always {!<=-1,!>=2}
  "dynamic_cast" always "dynamic_cast"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  "& >" always "& >"
Line 1787
  return always {!<=-1,!>=2}
  false always 0
Line 1788
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1790
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1791
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1792
  ( always {!<=-1,!>=2}
  "." always "."
Line 1793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1794
  ( always {!<=-1,!>=2}
  "," always ","
Line 1796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1800
  lml always !0
Line 1802
  stream possible symbolic=(lml)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  stream {symbolic=(lml),!0}
  ".|[|(|*" always ".|[|(|*"
Line 1803
  stream always !0
Line 1804
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  stream possible {symbolic=(lml),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  stream always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1807
  ( always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ":" always ":"
Line 1808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1809
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  true always 1
  false always 0
Line 1810
  ( always {!<=-1,!>=2}
  "[" always "["
Line 1811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1812
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1814
  return always {!<=-1,!>=2}
  false always 0
Line 1817
  ( always {!<=-1,!>=2}
Line 1819
  ( always {!<=-1,!>=2}
  "( void" always "( void"
Line 1820
  return always {!<=-1,!>=2}
  true always 1
Line 1821
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "< void *| >" always "< void *| >"
Line 1822
  return always {!<=-1,!>=2}
  true always 1
Line 1824
  tok2 possible symbolic=(tok)
Line 1825
  = always !0
  ( always !0
Line 1826
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  ")" always ")"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( void" always "( void"
Line 1827
  return always {!<=-1,!>=2}
  true always 1
Line 1828
  ( always {!<=-1,!>=2}
  "( void" always "( void"
Line 1829
  return always {!<=-1,!>=2}
  true always 1
Line 1830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete|throw|return" always "delete|throw|return"
Line 1833
  ( always {!<=-1,!>=2}
Line 1835
  ! always {!<=-1,!>=2}
Line 1836
  return always {!<=-1,!>=2}
  false always 0
Line 1837
  ! always {!<=-1,!>=2}
  tok always !0
Line 1838
  return always {!<=-1,!>=2}
  true always 1
Line 1839
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ";" always ";"
  && always {!<=-1,!>=2}
Line 1840
  ( always {!<=-1,!>=2}
  tok always !0
  "for|if (" always "for|if ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";" always ";"
Line 1841
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ";" always ";"
Line 1842
  return always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  tok always !0
Line 1844
  return always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  tok always !0
Line 1846
  ( always {!<=-1,!>=2}
  "[" always "["
Line 1848
  ( always {!<=-1,!>=2}
  bracTok possible symbolic=(tok)
  ( possible 0
  "[" always "["
Line 1850
  ! always {!<=-1,!>=2}
  bracTok possible symbolic=(tok)
Line 1851
  return always {!<=-1,!>=2}
  true always 1
Line 1853
  return always {!<=-1,!>=2}
  false always 0
Line 1858
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1863
  scope always symbolic=(tok->scope())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  scope {symbolic=(tok->scope()),!0}
  ( always {!<=-1,!>=2}
Line 1865
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1867
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 1872
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 1873
  warn always {!<=-1,!>=2}
  warn always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1874
  [ possible lifetime[Lambda]=(warn)
  & {lifetime[Address]=(warn),!0}
  warn always {!<=-1,!>=2}
Line 1875
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 1876
  :: always 3
  op1_and_op2 always 3
Line 1877
  ( always {!<=-1,!>=2}
Line 1878
  :: always 0
  none always 0
Line 1879
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 1880
  :: always 0
  none always 0
Line 1881
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1882
  :: always 0
  none always 0
Line 1883
  warn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1884
  :: always 4
  done always 4
Line 1886
  ! always {!<=-1,!>=2}
  warn always {!<=-1,!>=2}
Line 1891
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( possible 0
  ";" always ";"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 1892
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";|}|{ %any% ;" always ";|}|{ %any% ;"
  && always {!<=-1,!>=2}
Line 1893
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1894
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "for (" always "for ("
  && always {!<=-1,!>=2}
Line 1895
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "%var% [" always "%var% ["
Line 1898
  ( always {!<=-1,!>=2}
  "; } )" always "; } )"
Line 1900
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
Line 1902
  ( always {!<=-1,!>=2}
Line 1904
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1907
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%cop%" always "%cop%"
Line 1908
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1909
  ( always {!<=-1,!>=2}
  "numeric" always "numeric"
  : always "string"
  "string" always "string"
  inconclusive always {!<=-1,!>=2}
Line 1913
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1915
  = possible 0
  tok possible 0
Line 1916
  valueTok possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  valueTok {symbolic=(tok),!0}
  ( always {!<=-1,!>=2}
Line 1917
  valueTok always !0
  valueTok always !0
  ( always !0
  : always 1
  valueTok always !0
Line 1920
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(valueTok),0}
  "==" always "=="
Line 1921
  = always "Found suspicious equality comparison. Did you intend to assign a value instead?"
  "Found suspicious equality comparison. Did you intend to assign a value instead?" always "Found suspicious equality comparison. Did you intend to assign a value instead?"
Line 1922
  ( always {!<=-1,!>=2}
  tok possible 0
  ",|!|~|%cop%" always ",|!|~|%cop%"
Line 1923
  "Found suspicious operator '" always "Found suspicious operator '"
  "', result is not used." always "', result is not used."
Line 1924
  ( always {!<=-1,!>=2}
  tok possible 0
  "%var%" always "%var%"
Line 1925
  "Unused variable value '" always "Unused variable value '"
  "'" always "'"
Line 1926
  ( always {!<=-1,!>=2}
  "%str%|%num%|%bool%|%char%" always "%str%|%num%|%bool%|%char%"
Line 1927
  "string" always "string"
Line 1928
  ( always {!<=-1,!>=2}
Line 1929
  = always "numeric"
  "numeric" always "numeric"
Line 1930
  ( always {!<=-1,!>=2}
Line 1931
  = always "bool"
  "bool" always "bool"
Line 1932
  == always {!<=-1,!>=2}
  :: always 7
  eChar always 7
Line 1933
  = always "character"
  "character" always "character"
Line 1934
  = possible {size=68,size=65,size=70}
  "Redundant code: Found a statement that begins with " always "Redundant code: Found a statement that begins with "
  + possible {size=58,size=55,size=60}
  typeStr possible {"numeric",size=7,"bool",size=4,"character",size=9}
  + possible {size=68,size=65,size=70}
  " constant." always " constant."
Line 1936
  ! always {!<=-1,!>=2}
Line 1937
  "Redundant code: Found a statement that begins with " always "Redundant code: Found a statement that begins with "
  " constant." always " constant."
Line 1938
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  :: always 17
  eExtendedOp always 17
Line 1939
  = always "Redundant code: Found unused cast "
  "Redundant code: Found unused cast " always "Redundant code: Found unused cast "
Line 1940
  ? possible "expression."
  "of expression '" always "of expression '"
  valueTok always !0
  "'." always "'."
  : always "expression."
  "expression." always "expression."
Line 1942
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  :: always 17
  eExtendedOp always 17
Line 1943
  = always "Redundant code: Found unused result of ternary operator."
  "Redundant code: Found unused result of ternary operator." always "Redundant code: Found unused result of ternary operator."
Line 1944
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  :: always 21
  eOther always 21
Line 1945
  = always "Redundant code: Found unused member access."
  "Redundant code: Found unused member access." always "Redundant code: Found unused member access."
Line 1946
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  :: always 17
  eExtendedOp always 17
Line 1947
  = always "Redundant code: Found unused array access."
  "Redundant code: Found unused array access." always "Redundant code: Found unused array access."
Line 1949
  tok always !0
  :: always 7
  debug always 7
  "debug" always "debug"
  "constStatementError not handled." always "constStatementError not handled."
Line 1952
  tok possible 0
  :: always 2
  warning always 2
  "constStatement" always "constStatement"
  msg possible {symbolic=("Redundant code: Found a statement that begins with "+typeStr+" constant."),"Found suspicious equality comparison. Did you intend to assign a value instead?",size=79,"Redundant code: Found unused result of ternary operator.",size=56,"Redundant code: Found unused member access.",size=43,"Redundant code: Found unused array access.",size=42,size=68}
  inconclusive {!<=-1,!>=2,0@158}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1961
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1963
  ( possible {size=1,size=2}
  != {!<=-1,!>=2,1}
  "%" always "%"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "/" always "/"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "%=" always "%="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "/=" always "/="
Line 1965
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1969
  0LL always 0
Line 1970
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  value always !0
  false always 0
Line 1971
  value always !0
Line 1977
  ! {!<=-1,!>=2,1@141}
  tok possible 0@141
  && always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1@141}
  value possible 0@141
Line 1978
  tok always 0
  :: always 1
  error always 1
  "zerodiv" always "zerodiv"
  "Division by zero." always "Division by zero."
  :: always 0
  normal always 0
Line 1979
  tok always 0
  :: always 1
  error always 1
  "zerodivcond" always "zerodivcond"
  nullptr always 0
  " or there is division by zero." always " or there is division by zero."
  :: always 0
  normal always 0
Line 1983
  "Division by zero" always "Division by zero"
Line 1987
  = possible 0
  ? possible 0
  tok always !0
  : always 0
  0 always 0
Line 1988
  . always !0
Line 1989
  " or there is division by zero at line " always " or there is division by zero at line "
  line {symbolic=(tok?tok->linenr():0),0}
  "." always "."
Line 1991
  "Division by zero." always "Division by zero."
Line 1994
  ( always {!<=-1,!>=2}
  :: always 1
  error always 1
  : always 2
  :: always 2
  warning always 2
Line 1995
  "zerodivcond" always "zerodivcond"
  : always "zerodiv"
  "zerodiv" always "zerodiv"
Line 1996
  ( always {!<=-1,!>=2}
  : always 0
  :: always 0
  normal always 0
Line 2006
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2009
  != always {!<=-1,!>=2}
  "/" always "/"
Line 2011
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[+-]" always "[+-]"
Line 2013
  ( always {!<=-1,!>=2}
  "0.0" always "0.0"
Line 2020
  tok possible 0@184
  :: always 3
  style always 3
  "nanInArithmeticExpression" always "nanInArithmeticExpression"
Line 2021
  "Using NaN/Inf in a computation.\nUsing NaN/Inf in a computation. Although nothing bad really happens, it is suspicious." always "Using NaN/Inf in a computation.\nUsing NaN/Inf in a computation. Although nothing bad really happens, it is suspicious."
Line 2023
  :: always 0
  normal always 0
Line 2032
  ( always {!<=-1,!>=2}
Line 2035
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2039
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2040
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 2041
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2042
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %name% (" always "[;{}] %name% ("
Line 2043
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") ; !!}" always ") ; !!}"
Line 2044
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2045
  ( always !0
  ( always {!<=-1,!>=2}
Line 2056
  tok possible 0@142
  :: always 3
  style always 3
Line 2057
  "unusedScopedObject" always "unusedScopedObject"
Line 2058
  "$symbol:" always "$symbol:"
  varname possible "varname"@142
  "\nInstance of '$symbol' object is destroyed immediately." always "\nInstance of '$symbol' object is destroyed immediately."
Line 2059
  :: always 0
  normal always 0
Line 2064
  ! always {!<=-1,!>=2}
Line 2065
  nullptr always 0
Line 2066
  tok always !0
Line 2067
  ! always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
Line 2068
  nullptr always 0
Line 2069
  top {symbolic=(tok->astTop()),!0}
Line 2070
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "; }" always "; }"
Line 2071
  nullptr always 0
Line 2072
  top always !0
Line 2089
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2094
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2095
  != always {!<=-1,!>=2}
  :: always 6
  eIf always 6
Line 2099
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 2102
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2103
  != always {!<=-1,!>=2}
  2 always 2
Line 2104
  ( always {!<=-1,!>=2}
Line 2105
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2109
  macro {!<=-1,!>=2,0,1}
Line 2115
  ( always {!<=-1,!>=2}
Line 2119
  3 always 3
  2 always 2
Line 2123
  branch1 always !size=0
  == always {!<=-1,!>=2}
Line 2124
  errorPath always size=0
Line 2130
  3 always 3
Line 2131
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2133
  branchTop1 always !0
  != always {!<=-1,!>=2}
  branchTop2 always !0
Line 2135
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  branchTop1 always !0
  branchTop2 always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
  && always {!<=-1,!>=2}
Line 2136
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  branchTop1 always !0
  branchTop2 always !0
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 2144
  errors possible size=0@194
  tok2 possible 0@169
  "" always ""
Line 2145
  tok1 inconclusive 0@169
  "" always ""
Line 2147
  :: always 3
  style always 3
  "duplicateBranch" always "duplicateBranch"
  "Found duplicate branches for 'if' and 'else'.\nFinding the same code in an 'if' and related 'else' branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." always "Found duplicate branches for 'if' and 'else'.\nFinding the same code in an 'if' and related 'else' branch is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
Line 2164
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2166
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2167
  != always {!<=-1,!>=2}
Line 2170
  ( always {!<=-1,!>=2}
  "%var% = malloc|g_malloc|new" always "%var% = malloc|g_malloc|new"
Line 2171
  2 always 2
Line 2172
  false always 0
Line 2178
  ( always {!<=-1,!>=2}
  "%var% = %name% +|-" always "%var% = %name% +|-"
  && always {!<=-1,!>=2}
Line 2179
  == always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
Line 2180
  ( possible lifetime[Iterator]=(allocation)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(allocation),end=0}
Line 2181
  printInconclusive always {!<=-1,!>=2}
Line 2182
  [ always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2191
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
Line 2198
  ( always {!<=-1,!>=2}
  "free|g_free|delete ( %any% +|-" always "free|g_free|delete ( %any% +|-"
  || always {!<=-1,!>=2}
Line 2199
  ( always {!<=-1,!>=2}
  "delete [ ] ( %any% +|-" always "delete [ ] ( %any% +|-"
  || always {!<=-1,!>=2}
Line 2200
  ( always {!<=-1,!>=2}
  "delete %any% +|- %any%" always "delete %any% +|- %any%"
Line 2202
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  2 always 2
  : always 2
Line 2203
  3 always 3
  == always {!<=-1,!>=2}
  "(" always "("
  4 always 4
  : always 1
  1 always 1
Line 2205
  2 always 2
Line 2206
  :: possible {symbolic=(inconclusive.end()),end=0}
  alloc1 possible {symbolic=(inconclusive.end()),end=0}
  = possible lifetime[Iterator]=(inconclusive)
  ( possible lifetime[Iterator]=(inconclusive)
Line 2207
  :: possible {symbolic=(inconclusive.end()),end=0}
  alloc2 possible {symbolic=(inconclusive.end()),end=0}
  = possible lifetime[Iterator]=(inconclusive)
  ( possible lifetime[Iterator]=(inconclusive)
Line 2208
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(inconclusive),symbolic=(alloc2),end=0}
Line 2209
  alloc1 always {!symbolic=(inconclusive.end()),!end=0}
Line 2210
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(inconclusive),symbolic=(inconclusive.end()),symbolic=(alloc1),end=0}
Line 2211
  alloc2 always {!symbolic=(inconclusive.end()),!end=0,!symbolic=(alloc1)}
Line 2218
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
Line 2219
  "%var%" always "%var%"
  1 always 1
Line 2220
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2222
  tok2 always !0
Line 2223
  tok2 always !0
  "%var%" always "%var%"
  1 always 1
Line 2230
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2232
  = possible "malloc"@148
  allocation possible "malloc"@148
Line 2233
  alloc always symbolic=(allocation)
  != always {!<=-1,!>=2}
  "new" always "new"
Line 2234
  "()" always "()"
Line 2235
  = possible {"deleted","freed"}
  alloc possible {symbolic=(allocation),size=3}
  == always {!<=-1,!>=2}
  "new" always "new"
  ? possible {"deleted","freed"}
  "deleted" always "deleted"
  : always "freed"
  "freed" always "freed"
Line 2236
  tok possible 0@148
  :: always 1
  error always 1
  "invalidFree" always "invalidFree"
  "Mismatching address is " always "Mismatching address is "
  ". The address you get from " always ". The address you get from "
  " must be " always " must be "
  " without offset." always " without offset."
  0U always 0
  inconclusive {!<=-1,!>=2,0}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 2247
  ( always {!<=-1,!>=2}
Line 2249
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2254
  symbolDatabase possible symbolic=(mTokenizer->getSymbolDatabase())@250
Line 2260
  functionsByName possible size=0
  [ possible lifetime[Object]=(functionList)
  & {lifetime[Address]=(functionList),!0}
Line 2264
  == always {!<=-1,!>=2}
Line 2266
  ( {lifetime[Iterator]=(constFunctions),end=0}
Line 2275
  styleEnabled always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2276
  warningEnabled always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2277
  ! {!<=-1,!>=2,1}
  styleEnabled {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  warningEnabled always {!<=-1,!>=2}
Line 2284
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
  constFunctions always size=0
Line 2286
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2287
  != always {!<=-1,!>=2}
Line 2288
  ( possible {symbolic=(tok->astOperand1()->str()),size=2,size=1}
  == {!<=-1,!>=2,0}
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 2289
  ";" always ";"
Line 2290
  ( always {!<=-1,!>=2}
  endStatement always symbolic=(Token::findsimplematch(tok,";"))
  "; %type% %var% ;" always "; %type% %var% ;"
Line 2291
  endStatement always symbolic=(Token::findsimplematch(tok,";"))
  4 always 4
Line 2293
  ( always {!<=-1,!>=2}
  endStatement possible symbolic=(Token::findsimplematch(tok,";"))
  "%var% %assign%" always "%var% %assign%"
Line 2294
  1 always 1
Line 2297
  var1 {symbolic=(tok->astOperand1()),0}
  && always {!<=-1,!>=2}
  var2 always symbolic=(nextAssign->astOperand1())
  && always {!<=-1,!>=2}
Line 2298
  ( always {!<=-1,!>=2}
  var1 {symbolic=(tok->astOperand1()),!0}
  ";|{|} %var%" always ";|{|} %var%"
  && always {!<=-1,!>=2}
Line 2299
  ( always {!<=-1,!>=2}
  var2 {symbolic=(nextAssign->astOperand1()),!0}
  ";|{|} %var%" always ";|{|} %var%"
  && always {!<=-1,!>=2}
Line 2300
  var2 always symbolic=(nextAssign->astOperand1())
  && always {!<=-1,!>=2}
  var1 always symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
Line 2301
  var2 always symbolic=(nextAssign->astOperand1())
  ( always !0
  == always {!<=-1,!>=2}
  var1 always symbolic=(tok->astOperand1())
  ( always !0
  && always {!<=-1,!>=2}
Line 2302
  var2 always symbolic=(nextAssign->astOperand1())
  == always {!<=-1,!>=2}
  var1 always symbolic=(tok->astOperand1())
  ( always !0
  && always {!<=-1,!>=2}
Line 2303
  var2 always symbolic=(nextAssign->astOperand1())
  == always {!<=-1,!>=2}
  var1 always symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
Line 2304
  var2 always symbolic=(nextAssign->astOperand1())
  != always {!<=-1,!>=2}
  var1 always symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
Line 2305
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2306
  == always {!<=-1,!>=2}
  "." always "."
  || always {!<=-1,!>=2}
Line 2307
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 2308
  && always {!<=-1,!>=2}
Line 2309
  != always {!<=-1,!>=2}
  :: always 1
  eType always 1
  && always {!<=-1,!>=2}
Line 2310
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  false always 0
  && always {!<=-1,!>=2}
Line 2311
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  false always 0
  && always {!<=-1,!>=2}
Line 2312
  == always {!<=-1,!>=2}
Line 2313
  differentDomain always {!<=-1,!>=2}
  differentDomain always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2314
  var1 {symbolic=(tok->astOperand1()),!0}
  var1 {symbolic=(tok->astOperand1()),!0}
  ( always !0
  : always 1
Line 2315
  var2 {symbolic=(nextAssign->astOperand1()),!0}
  ";" always ";"
  && always {!<=-1,!>=2}
  assignTok always !0
  != always {!<=-1,!>=2}
  varScope always symbolic=(var1->scope()?var1->scope():scope)
Line 2316
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%assign%|%comp%" always "%assign%|%comp%"
Line 2318
  ! always {!<=-1,!>=2}
Line 2320
  ! always {!<=-1,!>=2}
Line 2323
  ( always !0
  ( possible symbolic=(var2->varId())
  != always {!<=-1,!>=2}
  ( possible symbolic=(assignTok->astOperand2()->varId())
  && always {!<=-1,!>=2}
Line 2324
  ( always !0
  ( always !symbolic=(var1->varId())
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2325
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2326
  true always 1
Line 2328
  ( always !0
Line 2330
  true always 1
Line 2331
  true always 1
Line 2333
  ( always !0
  ( possible symbolic=(var2->varId())
  != always {!<=-1,!>=2}
  ( possible symbolic=(assignTok->astOperand1()->varId())
  && always {!<=-1,!>=2}
Line 2334
  ( always !0
  ( always !symbolic=(var1->varId())
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2335
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2336
  true always 1
Line 2338
  ( always !0
Line 2340
  true always 1
Line 2341
  true always 1
Line 2343
  differentDomain always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2346
  ! {!<=-1,!>=2,1,0}
  differentDomain {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2347
  false always 0
Line 2348
  ( always {!<=-1,!>=2}
Line 2349
  true always 1
Line 2354
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+|*|<<|>>|+=|*=|<<=|>>=" always "+|*|<<|>>|+=|*=|<<=|>>="
Line 2355
  ( always {!<=-1,!>=2}
  "==|!=|-" always "==|!=|-"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  true always 1
Line 2357
  pointerDereference always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always 1
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
Line 2358
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 2359
  followVar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%|%oror%|&&" always "%comp%|%oror%|&&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  pointerDereference {symbolic=((tok->astOperand1()&&tok->astOperand1()->isUnaryOp("*"))||(tok->astOperand2()&&tok->astOperand2()->isUnaryOp("*"))),!<=-1,!>=2}
Line 2360
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2361
  true always 1
Line 2362
  ( always !0
Line 2363
  ( possible 0
Line 2365
  true always 1
Line 2366
  followVar always {!<=-1,!>=2}
Line 2367
  & {lifetime[Address]=(errorPath),!0}
Line 2368
  ( always {!<=-1,!>=2}
  ( {!<=-1,!>=2,0}
  ( always !0
Line 2369
  assignment always {!<=-1,!>=2}
  = {!<=-1,!>=2,0}
  ( possible size=2
  == {!<=-1,!>=2,0}
  "=" always "="
Line 2370
  assignment {symbolic=(tok->str()=="="),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  warningEnabled always {!<=-1,!>=2}
Line 2371
  ( always !0
Line 2372
  styleEnabled always {!<=-1,!>=2}
Line 2373
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "==" always "=="
Line 2375
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
Line 2376
  = always !0
  parent always !0
  ( always !0
Line 2378
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  parent always !0
  ( always !0
  == always {!<=-1,!>=2}
  "static_assert" always "static_assert"
Line 2382
  ( always !0
Line 2385
  ( possible symbolic=(tok->astOperand1()->str())
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 2386
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2387
  false always 0
Line 2388
  ( always !0
Line 2391
  true always 1
Line 2392
  false always 0
Line 2393
  warningEnabled always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 2394
  ( always !0
Line 2396
  styleEnabled {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 2397
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2398
  ( always !0
Line 2401
  false always 0
Line 2402
  true always 1
Line 2403
  & {lifetime[Address]=(errorPath),!0}
  && always {!<=-1,!>=2}
Line 2404
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=|-|-=|/|/=" always "=|-|-=|/|/="
  && always {!<=-1,!>=2}
Line 2405
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
Line 2407
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[-/%]" always "[-/%]"
Line 2408
  styleEnabled always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
Line 2409
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2410
  true always 1
Line 2411
  ( always !0
Line 2412
  ( always !0
Line 2414
  true always 1
Line 2415
  followVar always {!<=-1,!>=2}
Line 2416
  & {lifetime[Address]=(errorPath),!0}
  && always {!<=-1,!>=2}
Line 2417
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2418
  ( always !0
  ( always !0
Line 2419
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  true always 1
  ( always {!<=-1,!>=2}
Line 2420
  = possible {lifetime[Lambda]=(if(isSameExpression(mTokenizer->isCPP(),true,exp1,exp2,mSettings->library,true,true,&errorPath)&&isWithoutSideEffects(mTokenizer->isCPP(),exp1)&&isWithoutSideEffects(mTokenizer->isCPP(),ast1->astOperand2()))),lifetime[Lambda]=(errorPath)}
  [ possible {lifetime[Lambda]=(if(isSameExpression(mTokenizer->isCPP(),true,exp1,exp2,mSettings->library,true,true,&errorPath)&&isWithoutSideEffects(mTokenizer->isCPP(),exp1)&&isWithoutSideEffects(mTokenizer->isCPP(),ast1->astOperand2()))),lifetime[Lambda]=(errorPath)}
Line 2421
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  true always 1
  & {lifetime[Address]=(errorPath),!0}
  && always {!<=-1,!>=2}
Line 2422
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2423
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2424
  true always 1
Line 2426
  = always !0
  ( always !0
Line 2427
  ast1 inconclusive symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ast1 {symbolic=(tok->astOperand1()),!0}
Line 2428
  checkDuplicate possible {lifetime[Lambda]=(if(isSameExpression(mTokenizer->isCPP(),true,exp1,exp2,mSettings->library,true,true,&errorPath)&&isWithoutSideEffects(mTokenizer->isCPP(),exp1)&&isWithoutSideEffects(mTokenizer->isCPP(),ast1->astOperand2()))),lifetime[Lambda]=(errorPath)}
  ast1 {symbolic=(tok->astOperand1()),!0}
  ast1 {symbolic=(tok->astOperand1()),!0}
Line 2429
  ast1 inconclusive symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  ast1 inconclusive symbolic=(tok->astOperand1())
  ( always !0
  != always {!<=-1,!>=2}
Line 2430
  checkDuplicate possible {lifetime[Lambda]=(if(isSameExpression(mTokenizer->isCPP(),true,exp1,exp2,mSettings->library,true,true,&errorPath)&&isWithoutSideEffects(mTokenizer->isCPP(),exp1)&&isWithoutSideEffects(mTokenizer->isCPP(),ast1->astOperand2()))),lifetime[Lambda]=(errorPath)}
  ( always !0
Line 2431
  ast1 inconclusive symbolic=(tok->astOperand1())
Line 2435
  styleEnabled always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "?" always "?"
Line 2436
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ( always !0
  && always {!<=-1,!>=2}
Line 2437
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  0 always 0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2438
  ( always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2440
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  ( always !0
  ( always !0
  false always 0
  true always 1
  & {lifetime[Address]=(errorPath),!0}
Line 2449
  errors possible size=0@171
  opTok possible 0@171
  "" always ""
Line 2451
  = possible "&&"
  opTok inconclusive 0@171
  ? possible "&&"
  opTok always !0
  : always "&&"
  "&&" always "&&"
Line 2453
  :: always 3
  style always 3
  "oppositeExpression" always "oppositeExpression"
  "Opposite expression on both sides of \'" always "Opposite expression on both sides of \'"
  "\'.\nFinding the opposite expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." always "\'.\nFinding the opposite expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
Line 2456
  :: always 0
  normal always 0
Line 2459
  , always {!<=-1,!>=2}
  hasMultipleExpr always {!<=-1,!>=2}
Line 2461
  errors possible size=0@172
  opTok possible 0@172
  "" always ""
Line 2463
  = possible "x"
  tok1 inconclusive 0@172
  ? possible "x"
  tok1 always !0
  : always "x"
  "x" always "x"
Line 2464
  = possible "x"
  tok2 inconclusive 0@172
  ? possible "x"
  tok2 always !0
  : always "x"
  "x" always "x"
Line 2466
  = possible "&&"
  opTok possible 0
  ? possible "&&"
  opTok always !0
  : always "&&"
  "&&" always "&&"
Line 2467
  "Same expression " always "Same expression "
  hasMultipleExpr {!<=-1,!>=2,0,1@123}
  "\'" always "\'"
  expr1 {symbolic=(tok1?tok1->expressionString():"x"),symbolic=(expr2)}
  "\'" always "\'"
  " found multiple times in chain of \'" always " found multiple times in chain of \'"
  op always symbolic=(opTok?opTok->str():"&&")
  "\' operators" always "\' operators"
  "on both sides of \'" always "on both sides of \'"
  op always symbolic=(opTok?opTok->str():"&&")
  "\'" always "\'"
Line 2468
  = always "duplicateExpression"
  "duplicateExpression" always "duplicateExpression"
Line 2469
  expr1 always symbolic=(tok1?tok1->expressionString():"x")
  != always {!<=-1,!>=2}
  expr2 always symbolic=(tok2?tok2->expressionString():"x")
  && always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1@172}
  opTok inconclusive 0@172
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  opTok always !0
  ( always {!<=-1,!>=2}
Line 2470
  = always "knownConditionTrueFalse"
  "knownConditionTrueFalse" always "knownConditionTrueFalse"
Line 2471
  "The comparison \'" always "The comparison \'"
  expr1 {symbolic=(tok1?tok1->expressionString():"x"),!symbolic=(expr2)}
  " " always " "
  op always symbolic=(opTok?opTok->str():"&&")
  " " always " "
  expr2 {symbolic=(tok2?tok2->expressionString():"x"),!symbolic=(expr1)}
  "\' is always " always "\' is always "
Line 2472
  ( always {!<=-1,!>=2}
  "==|>=|<=" always "==|>=|<="
Line 2473
  "true" always "true"
Line 2474
  ( always {!<=-1,!>=2}
  "!=|>|<" always "!=|>|<"
Line 2475
  "false" always "false"
Line 2476
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%|NULL|nullptr" always "%num%|NULL|nullptr"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%num%|NULL|nullptr" always "%num%|NULL|nullptr"
Line 2477
  " because '" always " because '"
  "' and '" always "' and '"
  "' represent the same value" always "' represent the same value"
Line 2480
  :: always 3
  style always 3
Line 2481
  ".\nFinding the same expression " always ".\nFinding the same expression "
  hasMultipleExpr {!<=-1,!>=2,1@123}
  ? possible {"more than once in a condition","on both sides of an operator"}
  "more than once in a condition" always "more than once in a condition"
  : always "on both sides of an operator"
  "on both sides of an operator" always "on both sides of an operator"
Line 2482
  " is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." always " is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
Line 2483
  :: always 0
  normal always 0
Line 2486
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2488
  tok2 possible 0@170
  tok1 inconclusive 0@170
Line 2490
  = possible "x"
  tok1 inconclusive 0@170
  ? possible "x"
  tok1 always !0
  : always "x"
  "x" always "x"
Line 2491
  = possible "x"
  tok2 inconclusive 0@170
  ? possible "x"
  tok2 always !0
  : always "x"
  "x" always "x"
Line 2493
  toks always {{,size=2}
  :: always 3
  style always 3
  "duplicateAssignExpression" always "duplicateAssignExpression"
Line 2494
  "Same expression used in consecutive assignments of '" always "Same expression used in consecutive assignments of '"
  "' and '" always "' and '"
  "'.\nFinding variables '" always "'.\nFinding variables '"
Line 2495
  "' and '" always "' and '"
  "' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct." always "' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct."
Line 2497
  inconclusive {!<=-1,!>=2,0@54,1@56}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 2502
  errors possible size=0@174
  tok possible 0@174
  "" always ""
Line 2503
  :: always 3
  style always 3
  "duplicateExpressionTernary" always "duplicateExpressionTernary"
  "Same expression in both branches of ternary operator.\nFinding the same expression in both branches of ternary operator is suspicious as the same code is executed regardless of the condition." always "Same expression in both branches of ternary operator.\nFinding the same expression in both branches of ternary operator is suspicious as the same code is executed regardless of the condition."
Line 2505
  :: always 0
  normal always 0
Line 2510
  tok possible 0@173
  :: always 3
  style always 3
  "duplicateValueTernary" always "duplicateValueTernary"
  "Same value in both branches of ternary operator.\nFinding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition." always "Same value in both branches of ternary operator.\nFinding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition."
Line 2512
  :: always 0
  normal always 0
Line 2517
  tok possible 0@166
  :: always 2
  warning always 2
Line 2518
  "selfAssignment" always "selfAssignment"
Line 2519
  "$symbol:" always "$symbol:"
  varname possible "varname"@166
  "\nRedundant assignment of '$symbol' to itself." always "\nRedundant assignment of '$symbol' to itself."
Line 2520
  :: always 0
  normal always 0
Line 2534
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2538
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2539
  != always {!<=-1,!>=2}
Line 2540
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "isgreater|isless|islessgreater|isgreaterequal|islessequal ( %var% , %var% )" always "isgreater|isless|islessgreater|isgreaterequal|islessequal ( %var% , %var% )"
Line 2541
  2 always 2
Line 2542
  4 always 4
Line 2545
  == always {!<=-1,!>=2}
Line 2547
  2 always 2
Line 2548
  functionName possible {size=6,size=13}
  == {!<=-1,!>=2,0}
  "isgreater" always "isgreater"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "isless" always "isless"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "islessgreater" always "islessgreater"
Line 2550
  false always 0
Line 2553
  true always 1
Line 2560
  , always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
Line 2562
  = possible {"true","false"}
  result {!<=-1,!>=2,0@238,1@239}
  ? possible {"true","false"}
  "true" always "true"
  : always "false"
  "false" always "false"
Line 2563
  result {!<=-1,!>=2,0@238,1@239}
Line 2565
  tok possible 0@153
  :: always 2
  warning always 2
  "comparisonFunctionIsAlwaysTrueOrFalse" always "comparisonFunctionIsAlwaysTrueOrFalse"
Line 2566
  "$symbol:" always "$symbol:"
  functionName possible "isless"@153
  "\nComparison of two identical variables with $symbol(" always "\nComparison of two identical variables with $symbol("
Line 2567
  varName possible "varName"@153
  "," always ","
  varName possible "varName"@153
  ") always evaluates to " always ") always evaluates to "
  ".\nThe function $symbol is designed to compare two variables. Calling this function with one variable (" always ".\nThe function $symbol is designed to compare two variables. Calling this function with one variable ("
Line 2568
  varName possible "varName"@153
  ") for both parameters leads to a statement which is always " always ") for both parameters leads to a statement which is always "
Line 2569
  "." always "."
  :: always 0
  normal always 0
Line 2577
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2582
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2584
  != always {!<=-1,!>=2}
Line 2585
  = always 0
  nullptr always 0
Line 2586
  = always 0
  nullptr always 0
Line 2587
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(zeroValue),!0}
  zeroValue always 0
  & {lifetime[Address]=(nonZeroExpr),!0}
  nonZeroExpr always 0
Line 2589
  vt always symbolic=(nonZeroExpr->valueType())
Line 2593
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(zeroValue),!0}
  & {lifetime[Address]=(nonZeroExpr),!0}
Line 2595
  vt always symbolic=(nonZeroExpr->valueType())
Line 2604
  ( always {!<=-1,!>=2}
Line 2606
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2607
  return always {!<=-1,!>=2}
  false always 0
Line 2609
  ( always !0
  0 always 0
Line 2610
  ( always !0
  0 always 0
Line 2612
  ( always {!<=-1,!>=2}
  "<|<=" always "<|<="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  ( always {!<=-1,!>=2}
Line 2613
  = always !0
  v2 always !0
Line 2614
  = always !0
  ( always !0
Line 2615
  ( always {!<=-1,!>=2}
  ">|>=" always ">|>="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v1 always !0
  ( always {!<=-1,!>=2}
Line 2616
  = always !0
  v1 always !0
Line 2617
  = always !0
  ( always !0
Line 2619
  return always {!<=-1,!>=2}
  false always 0
Line 2622
  * possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
Line 2623
  return always {!<=-1,!>=2}
  vt always symbolic=((*nonZeroExpr)->valueType())
  && always {!<=-1,!>=2}
  vt {symbolic=((*nonZeroExpr)->valueType()),!0}
  || always {!<=-1,!>=2}
  vt {symbolic=((*nonZeroExpr)->valueType()),!0}
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 2626
  ( always {!<=-1,!>=2}
Line 2628
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2629
  return always {!<=-1,!>=2}
  false always 0
Line 2631
  ( always !0
  0 always 0
Line 2632
  ( always !0
  0 always 0
Line 2634
  ( always {!<=-1,!>=2}
  ">=" always ">="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v2 always !0
  ( always {!<=-1,!>=2}
Line 2635
  = always !0
  v2 always !0
Line 2636
  = always !0
  ( always !0
Line 2637
  ( always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  v1 always !0
  ( always {!<=-1,!>=2}
Line 2638
  = always !0
  v1 always !0
Line 2639
  = always !0
  ( always !0
Line 2641
  return always {!<=-1,!>=2}
  false always 0
Line 2644
  * possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
Line 2645
  return always {!<=-1,!>=2}
  vt always symbolic=((*nonZeroExpr)->valueType())
  && always {!<=-1,!>=2}
  vt {symbolic=((*nonZeroExpr)->valueType()),!0}
  || always {!<=-1,!>=2}
  vt {symbolic=((*nonZeroExpr)->valueType()),!0}
  == always {!<=-1,!>=2}
  :: always 2
  UNSIGNED always 2
Line 2650
  tok possible 0@177
  v possible 0@177
  "Unsigned less than zero" always "Unsigned less than zero"
  :: always 3
  style always 3
  "unsignedLessThanZero" always "unsignedLessThanZero"
Line 2651
  "$symbol:" always "$symbol:"
  varname possible "varname"@177
  "\nChecking if unsigned expression '$symbol' is less than zero.\nThe unsigned expression '$symbol' will never be negative so it is either pointless or an error to check if it is." always "\nChecking if unsigned expression '$symbol' is less than zero.\nThe unsigned expression '$symbol' will never be negative so it is either pointless or an error to check if it is."
Line 2654
  :: always 0
  normal always 0
Line 2659
  tok possible 0@179
  v possible 0@179
  "Pointer less than zero" always "Pointer less than zero"
  :: always 3
  style always 3
  "pointerLessThanZero" always "pointerLessThanZero"
Line 2660
  "A pointer can not be negative so it is either pointless or an error to check if it is." always "A pointer can not be negative so it is either pointless or an error to check if it is."
  :: always 0
  normal always 0
Line 2665
  tok possible 0@178
  v possible 0@178
  "Unsigned positive" always "Unsigned positive"
  :: always 3
  style always 3
  "unsignedPositive" always "unsignedPositive"
Line 2666
  "$symbol:" always "$symbol:"
  varname possible "varname"@178
  "\nUnsigned expression '$symbol' can't be negative so it is unnecessary to test it." always "\nUnsigned expression '$symbol' can't be negative so it is unnecessary to test it."
Line 2667
  :: always 0
  normal always 0
Line 2672
  tok possible 0@180
  v possible 0@180
  "Pointer positive" always "Pointer positive"
  :: always 3
  style always 3
  "pointerPositive" always "pointerPositive"
Line 2673
  "A pointer can not be negative so it is either pointless or an error to check if it is not." always "A pointer can not be negative so it is either pointless or an error to check if it is not."
  :: always 0
  normal always 0
Line 2677
  ( always {!<=-1,!>=2}
Line 2680
  ( always {!<=-1,!>=2}
Line 2681
  = always 0
  0U always 0
  argnr possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 2682
  argnr {<=symbolic=(constructor.argCount()-1),!>=symbolic=(constructor.argCount())}
Line 2683
  && always {!<=-1,!>=2}
  argVar always !0
  ( always {!<=-1,!>=2}
Line 2684
  return always {!<=-1,!>=2}
  true always 1
Line 2689
  return always {!<=-1,!>=2}
  false always 0
Line 2698
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2703
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2704
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2707
  var always !0
Line 2708
  startTok always symbolic=(var->nameToken())
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 2710
  startTok always symbolic=(var->nameToken())
  1 always 1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
Line 2712
  ( always {!<=-1,!>=2}
  var always !0
  ( always !0
Line 2717
  startTok always symbolic=(var->nameToken())
Line 2718
  ! always {!<=-1,!>=2}
  tok always symbolic=(startTok->next()->astOperand2())
Line 2720
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(startTok->next()->astOperand2()),!0}
  "%name% (" always "%name% ("
Line 2722
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ") )| ;" always ") )| ;"
Line 2726
  func always symbolic=(tok->previous()->function())
  && always {!<=-1,!>=2}
  func {symbolic=(tok->previous()->function()),!0}
  -1 always -1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 2733
  tok possible 0@151
  :: always 4
  performance always 4
  "redundantCopyLocalConst" always "redundantCopyLocalConst"
Line 2734
  "$symbol:" always "$symbol:"
  varname inconclusive "varname"@151
  "\nUse const reference for '$symbol' to avoid unnecessary data copying.\nThe const variable '$symbol' is assigned a copy of the data. You can avoid the unnecessary data copying by converting '$symbol' to const reference." always "\nUse const reference for '$symbol' to avoid unnecessary data copying.\nThe const variable '$symbol' is assigned a copy of the data. You can avoid the unnecessary data copying by converting '$symbol' to const reference."
Line 2746
  ( always {!<=-1,!>=2}
Line 2748
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  SIGNED always 1
  && always {!<=-1,!>=2}
  -1LL always -1
Line 2753
  portability always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 2756
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2759
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<<|>>|<<=|>>=" always "<<|>>|<<=|>>="
Line 2763
  ( always {!<=-1,!>=2}
Line 2764
  ( always !0
Line 2765
  ! always {!<=-1,!>=2}
  lhsType always symbolic=(tok->astOperand1()->valueType())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhsType {symbolic=(tok->astOperand1()->valueType()),!0}
  ( always {!<=-1,!>=2}
Line 2770
  ternary always {!<=-1,!>=2}
  ternary always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2772
  ( always {!<=-1,!>=2}
  "?|:" always "?|:"
Line 2773
  ternary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2777
  ternary {!<=-1,!>=2,0,1}
Line 2781
  portability always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2782
  1 always 1
Line 2783
  ( always {!<=-1,!>=2}
Line 2784
  2 always 2
Line 2791
  op possible {1@163,2@166}
  == always {!<=-1,!>=2}
  1 always 1
Line 2795
  tok possible 0@144
  :: always 5
  portability always 5
  "shiftNegativeLHS" always "shiftNegativeLHS"
  "Shifting a negative value is technically undefined behaviour" always "Shifting a negative value is technically undefined behaviour"
  :: always 0
  normal always 0
Line 2797
  tok possible 0@145
  :: always 1
  error always 1
  "shiftNegative" always "shiftNegative"
  "Shifting by a negative value is undefined behaviour" always "Shifting by a negative value is undefined behaviour"
  :: always 0
  normal always 0
Line 2805
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2807
  printWarning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2808
  printPortability always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 2809
  ! {!<=-1,!>=2,1}
  printPortability {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printWarning always {!<=-1,!>=2}
Line 2814
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2815
  != always {!<=-1,!>=2}
Line 2816
  ( always {!<=-1,!>=2}
  "memset|memcpy|memmove ( %var% ," always "memset|memcpy|memmove ( %var% ,"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  -2 always -2
  ", %num% )" always ", %num% )"
Line 2817
  2 always 2
Line 2818
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 2821
  1 always 1
  -1 always -1
  == always {!<=-1,!>=2}
  var always !0
  0 always 0
Line 2822
  var always !0
Line 2823
  size possible 0
  == {!<=-1,!>=2,1}
  0 always 0
  && always {!<=-1,!>=2}
  var always !0
Line 2825
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  var always !0
Line 2826
  var always !0
  ( always !0
Line 2827
  size possible {symbolic=(mSettings->sizeof_pointer),100,0}
  != {!<=-1,!>=2,1}
  1 always 1
  && always {!<=-1,!>=2}
  size {0,!1}
  != {!<=-1,!>=2,1}
  100 always 100
  && always {!<=-1,!>=2}
  size always {!1,!100}
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 2828
  printWarning always {!<=-1,!>=2}
Line 2829
  var always !0
  false always 0
Line 2830
  var always !0
  == always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  printPortability always {!<=-1,!>=2}
Line 2831
  var always !0
  true always 1
Line 2838
  , always {!<=-1,!>=2}
  boolean always {!<=-1,!>=2}
Line 2840
  boolean {!<=-1,!>=2,0@142,1@146}
Line 2841
  :: always 5
  portability always 5
  "incompleteArrayFill" always "incompleteArrayFill"
Line 2842
  "$symbol:" always "$symbol:"
  "\n$symbol:" always "\n$symbol:"
Line 2843
  "\nArray '" always "\nArray '"
Line 2844
  "' might be filled incompletely. Did you forget to multiply the size given to '" always "' might be filled incompletely. Did you forget to multiply the size given to '"
  "()' with 'sizeof(*" always "()' with 'sizeof(*"
  ")'?\nThe array '" always ")'?\nThe array '"
Line 2845
  "' is filled incompletely. The function '" always "' is filled incompletely. The function '"
  "()' needs the size given in bytes, but the type 'bool' is larger than 1 on some platforms. Did you forget to multiply the size with 'sizeof(*" always "()' needs the size given in bytes, but the type 'bool' is larger than 1 on some platforms. Did you forget to multiply the size with 'sizeof(*"
  ")'?" always ")'?"
Line 2847
  tok possible 0@182
  :: always 2
  warning always 2
  "incompleteArrayFill" always "incompleteArrayFill"
Line 2848
  "$symbol:" always "$symbol:"
  buffer inconclusive "buffer"@182
  "\n$symbol:" always "\n$symbol:"
Line 2849
  function inconclusive "memset"@182
  "\nArray '" always "\nArray '"
Line 2850
  buffer inconclusive "buffer"@182
  "' is filled incompletely. Did you forget to multiply the size given to '" always "' is filled incompletely. Did you forget to multiply the size given to '"
  function inconclusive "memset"@182
  "()' with 'sizeof(*" always "()' with 'sizeof(*"
  buffer inconclusive "buffer"@182
  ")'?\nThe array '" always ")'?\nThe array '"
Line 2851
  buffer inconclusive "buffer"@182
  "' is filled incompletely. The function '" always "' is filled incompletely. The function '"
  function inconclusive "memset"@182
  "()' needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with 'sizeof(*" always "()' needs the size given in bytes, but an element of the given array is larger than one byte. Did you forget to multiply the size with 'sizeof(*"
  buffer inconclusive "buffer"@182
  ")'?" always ")'?"
Line 2860
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 5
  portability always 5
Line 2864
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2865
  != always {!<=-1,!>=2}
Line 2867
  ( always {!<=-1,!>=2}
  "[(,] NULL [,)]" always "[(,] NULL [,)]"
Line 2870
  = always 1
  1 always 1
Line 2871
  ftok possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ftok {symbolic=(tok),!0}
  != always {!<=-1,!>=2}
  "(" always "("
Line 2872
  ftok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 2873
  ftok always !0
Line 2874
  ftok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 2878
  = possible 0
  ftok possible {symbolic=(tok),0}
  ? possible 0
  ftok always !0
  : always 0
  nullptr always 0
Line 2879
  ftok possible 0
  && always {!<=-1,!>=2}
  ftok always !0
  ( always {!<=-1,!>=2}
Line 2881
  ftok always !0
Line 2882
  f always symbolic=(ftok->function())
  && always {!<=-1,!>=2}
  f {symbolic=(ftok->function()),!0}
  ( always !<=-1
  <= always {!<=-1,!>=2}
Line 2883
  f {symbolic=(ftok->function()),!0}
Line 2884
  = possible 0
  tok2 {symbolic=(f->argDef),0}
  ? possible 0
  tok2 {symbolic=(f->argDef),!0}
  : always 0
  nullptr always 0
Line 2885
  tok2 possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  -1 always -1
  "..." always "..."
Line 2896
  tok possible 0@183
Line 2897
  :: always 5
  portability always 5
Line 2898
  "varFuncNullUB" always "varFuncNullUB"
Line 2899
  "Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nPassing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nThe C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\nThe value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\nIn practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\nTo reproduce you might be able to use this little code example on 64bit platforms. If the output includes \"ERROR\", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the \"ERROR\" output go away.\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid f(char *s, ...) {\n    va_list ap;\n    va_start(ap,s);\n    for (;;) {\n        char *p = va_arg(ap,char*);\n        printf(\"%018p, %s\\n\", p, (long)p & 255 ? p : \"\");\n        if(!p) break;\n    }\n    va_end(ap);\n}\n\nvoid g() {\n    char *s2 = \"x\";\n    char *s3 = \"ERROR\";\n\n    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\n    f(\"first\", s2, s2, s2, s2, s2, 0, s3, (char*)0);\n}\n\nvoid h() {\n    int i;\n    volatile unsigned char a[1000];\n    for (i = 0; i<sizeof(a); i++)\n        a[i] = -1;\n}\n\nint main() {\n    h();\n    g();\n    return 0;\n}" always "Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nPassing NULL after the last typed argument to a variadic function leads to undefined behaviour.\nThe C99 standard, in section 7.15.1.1, states that if the type used by va_arg() is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined.\nThe value of the NULL macro is an implementation-defined null pointer constant (7.17), which can be any integer constant expression with the value 0, or such an expression casted to (void*) (6.3.2.3). This includes values like 0, 0L, or even 0LL.\nIn practice on common architectures, this will cause real crashes if sizeof(int) != sizeof(void*), and NULL is defined to 0 or any other null pointer constant that promotes to int.\nTo reproduce you might be able to use this little code example on 64bit platforms. If the output includes \"ERROR\", the sentinel had only 4 out of 8 bytes initialized to zero and was not detected as the final argument to stop argument processing via va_arg(). Changing the 0 to (void*)0 or 0L will make the \"ERROR\" output go away.\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid f(char *s, ...) {\n    va_list ap;\n    va_start(ap,s);\n    for (;;) {\n        char *p = va_arg(ap,char*);\n        printf(\"%018p, %s\\n\", p, (long)p & 255 ? p : \"\");\n        if(!p) break;\n    }\n    va_end(ap);\n}\n\nvoid g() {\n    char *s2 = \"x\";\n    char *s3 = \"ERROR\";\n\n    // changing 0 to 0L for the 7th argument (which is intended to act as sentinel) makes the error go away on x86_64\n    f(\"first\", s2, s2, s2, s2, s2, 0, s3, (char*)0);\n}\n\nvoid h() {\n    int i;\n    volatile unsigned char a[1000];\n    for (i = 0; i<sizeof(a); i++)\n        a[i] = -1;\n}\n\nint main() {\n    h();\n    g();\n    return 0;\n}"
Line 2938
  :: always 0
  normal always 0
Line 2943
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2947
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 2950
  addressOfDeref always {!<=-1,!>=2}
  { always 0
Line 2951
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 2952
  addressOfDeref always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2953
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 2954
  addressOfDeref always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2960
  ! always {!<=-1,!>=2}
  varTok always symbolic=(tok->astOperand1()->astOperand1())
  || always {!<=-1,!>=2}
  varTok {symbolic=(tok->astOperand1()->astOperand1()),!0}
  ( always {!<=-1,!>=2}
Line 2963
  ! {!<=-1,!>=2,1}
  addressOfDeref {!<=-1,!>=2,0}
Line 2964
  ( always {!<=-1,!>=2}
Line 2966
  varTok always !0
  && always {!<=-1,!>=2}
  varTok always !0
  ( always !0
  && always {!<=-1,!>=2}
  varTok always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 1
  LValue always 1
Line 2970
  varTok {symbolic=(tok->astOperand1()->astOperand1()),!0}
Line 2971
  ! always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
  || always {!<=-1,!>=2}
  addressOfDeref always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(varTok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2974
  var {symbolic=(varTok->variable()),!0}
  false always 0
  addressOfDeref always {!<=-1,!>=2}
Line 2978
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  addressOfDeref always {!<=-1,!>=2}
Line 2980
  "$symbol:" always "$symbol:"
  varname possible "varname"@186
  "\nRedundant pointer operation on '$symbol' - it's already a " always "\nRedundant pointer operation on '$symbol' - it's already a "
Line 2981
  addressOfDeref {!<=-1,!>=2,1@186}
  ? possible {"pointer.","variable."}
  "pointer." always "pointer."
  : always "variable."
  "variable." always "variable."
Line 2982
  tok possible 0@186
  :: always 3
  style always 3
  "redundantPointerOp" always "redundantPointerOp"
  inconclusive {!<=-1,!>=2,0@107}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 2987
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2992
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "InterlockedDecrement ( & %name% ) ; if ( %name%|!|0" always "InterlockedDecrement ( & %name% ) ; if ( %name%|!|0"
Line 2993
  3 always 3
Line 2994
  5 always 5
Line 2995
  ( always {!<=-1,!>=2}
  "0 %comp% %name% )" always "0 %comp% %name% )"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2996
  ( always {!<=-1,!>=2}
  "! %name% )" always "! %name% )"
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2997
  ( always {!<=-1,!>=2}
  "%name% )" always "%name% )"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 2998
  ( always {!<=-1,!>=2}
  "%name% %comp% 0 )" always "%name% %comp% 0 )"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3001
  ( always {!<=-1,!>=2}
  "if ( ::| InterlockedDecrement ( & %name%" always "if ( ::| InterlockedDecrement ( & %name%"
Line 3003
  2 always 2
Line 3004
  == always {!<=-1,!>=2}
  "::" always "::"
  4 always 4
  3 always 3
Line 3005
  condEnd always symbolic=(tok->next()->link())
  && always {!<=-1,!>=2}
  condEnd {symbolic=(tok->next()->link()),!0}
  && always {!<=-1,!>=2}
  condEnd {symbolic=(tok->next()->link()),!0}
  ( always !0
Line 3006
  = always !0
  condEnd {symbolic=(tok->next()->link()),!0}
  ( always !0
  ( always !0
Line 3007
  ( always {!<=-1,!>=2}
  ifEndTok {symbolic=(condEnd->next()->link()),!0}
  "} return %name%" always "} return %name%"
Line 3008
  ifEndTok {symbolic=(condEnd->next()->link()),!0}
  2 always 2
Line 3009
  == always {!<=-1,!>=2}
Line 3012
  ( always {!<=-1,!>=2}
  ifEndTok {symbolic=(condEnd->next()->link()),!0}
  "} else { return %name%" always "} else { return %name%"
Line 3013
  ifEndTok {symbolic=(condEnd->next()->link()),!0}
  4 always 4
Line 3014
  == always {!<=-1,!>=2}
Line 3025
  tok possible 0@147
  :: always 1
  error always 1
  "raceAfterInterlockedDecrement" always "raceAfterInterlockedDecrement"
Line 3026
  "Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead." always "Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead."
  :: always 0
  normal always 0
Line 3031
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 3035
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3036
  hasIfdef always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3037
  != always {!<=-1,!>=2}
Line 3038
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3041
  ( always {!<=-1,!>=2}
  "{|}|; %name% :" always "{|}|; %name% :"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
  ( always {!<=-1,!>=2}
Line 3042
  "goto " always "goto "
  1 always 1
Line 3043
  ! always {!<=-1,!>=2}
  ( {lifetime[Object]=(tmp),!0}
  ( always !<=-1
Line 3044
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
  hasIfdef always {!<=-1,!>=2}
Line 3050
  , always {!<=-1,!>=2}
  inSwitch always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  hasIfdef always {!<=-1,!>=2}
Line 3052
  tok possible 0@187
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  inSwitch {!<=-1,!>=2,0@56,1@56}
  ? possible {2,3}
  :: always 2
  warning always 2
  : always 3
  :: always 3
  style always 3
Line 3055
  = always "unusedLabel"
  "unusedLabel" always "unusedLabel"
Line 3056
  inSwitch {!<=-1,!>=2,0,1@56}
Line 3057
  id always size=11
  "Switch" always "Switch"
Line 3058
  hasIfdef {!<=-1,!>=2,0,1@188}
Line 3059
  "Configuration" always "Configuration"
Line 3061
  "$symbol:" always "$symbol:"
  tok possible 0@187
  tok always !0
  "\nLabel '$symbol' is not used." always "\nLabel '$symbol' is not used."
Line 3062
  hasIfdef {!<=-1,!>=2,0@187,1@188}
Line 3063
  " There is #if in function body so the label might be used in code that is removed by the preprocessor." always " There is #if in function body so the label might be used in code that is removed by the preprocessor."
Line 3064
  inSwitch {!<=-1,!>=2,0,1@189}
Line 3065
  " Should this be a 'case' of the enclosing switch()?" always " Should this be a 'case' of the enclosing switch()?"
Line 3067
  tok possible 0@187
Line 3068
  inSwitch {!<=-1,!>=2,1,0}
  ? possible {2,3}
  :: always 2
  warning always 2
  : always 3
  :: always 3
  style always 3
Line 3072
  :: always 0
  normal always 0
Line 3079
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 3083
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3084
  != always {!<=-1,!>=2}
Line 3085
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok2)
  "++|--" always "++|--"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3087
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok2)
Line 3091
  tok2 possible symbolic=(tok)
Line 3092
  ! {!<=-1,!>=2,1}
  parent {symbolic=(tok2->astParent()),0}
Line 3094
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok2->astParent()),!0}
  "%oror%|&&|?|:|;" always "%oror%|&&|?|:|;"
Line 3096
  parent always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "," always ","
Line 3097
  = always !0
  parent always !0
Line 3098
  ( always {!<=-1,!>=2}
  par possible {symbolic=(parent),0}
  "," always ","
Line 3101
  ! always {!<=-1,!>=2}
  par possible symbolic=(parent)
  && always {!<=-1,!>=2}
  par always !0
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  par always !0
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "while" always "while"
Line 3104
  ( always {!<=-1,!>=2}
  par always !0
  ") {" always ") {"
Line 3107
  par always !0
Line 3108
  par possible 0
  && always {!<=-1,!>=2}
  par always !0
  != always {!<=-1,!>=2}
Line 3109
  par always !0
Line 3110
  ! {!<=-1,!>=2,1}
  par possible 0
Line 3113
  parent always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  parent always !0
Line 3117
  tok2 possible symbolic=(parent->astOperand1())
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3118
  tok always symbolic=(tok2)
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 3119
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
Line 3120
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  true always 1
  false always 0
Line 3121
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
  && always {!<=-1,!>=2}
Line 3122
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  tok always symbolic=(tok2)
  true always 1
  false always 0
Line 3123
  tok always symbolic=(tok2)
Line 3128
  foundError {!<=-1,!>=2,0}
  foundError always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3129
  != always {!<=-1,!>=2}
  ( always !symbolic=(tok2)
  : always !symbolic=(tok2)
Line 3130
  [ possible {lifetime[Lambda]=(if(isSameExpression(mTokenizer->isCPP(),false,tok->astOperand1(),tok3,mSettings->library,true,false))),lifetime[Lambda]=(tok),lifetime[Lambda]=(foundError)}
Line 3131
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 3132
  :: always 0
  none always 0
Line 3133
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "sizeof" always "sizeof"
Line 3134
  :: always 0
  none always 0
Line 3135
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  true always 1
  false always 0
Line 3136
  foundError always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3137
  foundError {!<=-1,!>=2,1}
  ? possible {4,3}
  :: always 4
  done always 4
  : always 3
  :: always 3
  op1_and_op2 always 3
Line 3140
  foundError always {!<=-1,!>=2}
Line 3151
  tok possible 0
  :: always 1
  error always 1
  "unknownEvaluationOrder" always "unknownEvaluationOrder"
Line 3152
  "Expression '" always "Expression '"
  tok possible 0@191
  tok always !0
  "x = x++;" always "x = x++;"
  "' depends on order of evaluation of side effects" always "' depends on order of evaluation of side effects"
  :: always 0
  normal always 0
Line 3157
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 3160
  reportInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3162
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3165
  . always !0
Line 3166
  memberInitializationStart always symbolic=(scope->function->constructorMemberInitialization())
Line 3167
  = {symbolic=(scope->function->constructorMemberInitialization()),!0}
  memberInitializationStart {symbolic=(scope->function->constructorMemberInitialization()),!0}
Line 3169
  scopeStart possible {symbolic=(scope->bodyStart),symbolic=(memberInitializationStart),symbolic=(scope->function->constructorMemberInitialization())}
  != always {!<=-1,!>=2}
Line 3171
  ! always {!<=-1,!>=2}
  movedValue always symbolic=(tok->getMovedValue())
  || always {!<=-1,!>=2}
  movedValue {symbolic=(tok->getMovedValue()),!0}
  == always {!<=-1,!>=2}
Line 3173
  movedValue {symbolic=(tok->getMovedValue()),!0}
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  reportInconclusive always {!<=-1,!>=2}
Line 3176
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3177
  accessOfMoved always {!<=-1,!>=2}
  accessOfMoved always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3178
  1 always 1
  == always {!<=-1,!>=2}
  "." always "."
Line 3179
  == always {!<=-1,!>=2}
  "->" always "->"
Line 3180
  accessOfMoved always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3182
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3184
  variableChanged always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  0 always 0
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
Line 3185
  accessOfMoved always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  variableChanged always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  false always 0
  :: always 0
  NO_ALLOC always 0
Line 3186
  inconclusive always {!<=-1,!>=2}
Line 3187
  accessOfMoved always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3188
  accessOfMoved always {!<=-1,!>=2}
Line 3189
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3192
  accessOfMoved {!<=-1,!>=2,1,0}
  || always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  reportInconclusive always {!<=-1,!>=2}
Line 3193
  movedValue always !0
  inconclusive {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  movedValue always !0
  ( always {!<=-1,!>=2}
Line 3198
  ( always {!<=-1,!>=2}
Line 3200
  ( always {!<=-1,!>=2}
  -4 always -4
  "std :: move (" always "std :: move ("
Line 3201
  return always {!<=-1,!>=2}
  false always 0
Line 3202
  -2 always -2
Line 3203
  ( always {!<=-1,!>=2}
  "> (" always "> ("
  && always {!<=-1,!>=2}
Line 3204
  = always !0
  ( always !0
Line 3205
  ( always {!<=-1,!>=2}
  leftAngle {symbolic=(tokAtM2->link()),!0}
  -3 always -3
  "std :: forward <" always "std :: forward <"
Line 3206
  return always {!<=-1,!>=2}
  false always 0
Line 3208
  return always {!<=-1,!>=2}
  true always 1
Line 3211
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3213
  ! {!<=-1,!>=2,1@192}
  tok possible 0@192
Line 3214
  tok always 0
  :: always 2
  warning always 2
  "accessMoved" always "accessMoved"
  "Access of moved variable 'v'." always "Access of moved variable 'v'."
  :: always 0
  normal always 0
Line 3215
  tok always 0
  :: always 2
  warning always 2
  "accessForwarded" always "accessForwarded"
  "Access of forwarded variable 'v'." always "Access of forwarded variable 'v'."
  :: always 0
  normal always 0
Line 3219
  = always 0
  nullptr always 0
Line 3222
  :: always 1
  MovedVariable always 1
Line 3223
  = always "accessMoved"
  "accessMoved" always "accessMoved"
Line 3224
  = always "moved"
  "moved" always "moved"
Line 3226
  :: always 2
  ForwardedVariable always 2
Line 3227
  = always "accessForwarded"
  "accessForwarded" always "accessForwarded"
Line 3228
  = always "forwarded"
  "forwarded" always "forwarded"
Line 3233
  "$symbol:" always "$symbol:"
  "\nAccess of " always "\nAccess of "
  kindString possible {"moved",size=5,"forwarded",size=9}
  " variable '$symbol'." always " variable '$symbol'."
Line 3235
  :: always 2
  warning always 2
  errorId possible {"accessMoved","accessForwarded"}
  inconclusive always {!<=-1,!>=2}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 3242
  style always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 3243
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3244
  warning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 3246
  ! always {!<=-1,!>=2}
  warning always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  style always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3251
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3254
  ! always {!<=-1,!>=2}
  function always symbolic=(scope->function)
  || always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 3258
  function {symbolic=(scope->function),!0}
  == always {!<=-1,!>=2}
  function {symbolic=(scope->function),!0}
Line 3262
  function always !0
  ( always !<=0
Line 3263
  function always !0
  ( always !<=-1
Line 3264
  function always !0
  . always !symbolic=(function->arg)
Line 3265
  = always 0
  0 always 0
  j possible 0
  < always {!<=-1,!>=2}
  function always !0
  ( always !<=-1
Line 3266
  j {<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
  = always 0
  nullptr always 0
Line 3267
  j {<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
  = always 0
  nullptr always 0
Line 3269
  function always !0
  j {<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
Line 3271
  j always !>=symbolic=(function->argCount())
  variable always !0
Line 3274
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  decl always !0
  ",|)|;" always ",|)|;"
Line 3278
  decl always !0
  == always {!<=-1,!>=2}
  "=" always "="
Line 3279
  decl always !0
Line 3283
  decl always !0
Line 3284
  = always !0
  decl always !0
  ( always !0
Line 3285
  decl always !0
Line 3286
  = always !0
  decl always !0
Line 3287
  decl possible symbolic=(declarations[j])
Line 3289
  ( always {!<=-1,!>=2}
  "," always ","
Line 3293
  warning always {!<=-1,!>=2}
Line 3294
  order_different always {!<=-1,!>=2}
  order_different always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3295
  = always 0
  0 always 0
  j possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 3296
  ! always {!<=-1,!>=2}
  j {symbolic=(k),<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  j always !>=symbolic=(function->argCount())
  || always {!<=-1,!>=2}
  j always !>=symbolic=(function->argCount())
  == always {!<=-1,!>=2}
  j always !>=symbolic=(function->argCount())
Line 3299
  = always 0
  0 always 0
  k possible {symbolic=(j),symbolic=(j+1),0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ possible symbolic=(j+1)
  k possible symbolic=(j)
Line 3300
  != always {!<=-1,!>=2}
  k {<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
  && always {!<=-1,!>=2}
  k always {!>=symbolic=(function->argCount()),!symbolic=(j)}
  && always {!<=-1,!>=2}
  j always !symbolic=(k)
  == always {!<=-1,!>=2}
  k always {!>=symbolic=(function->argCount()),!symbolic=(j)}
Line 3301
  order_different always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3306
  order_different {!<=-1,!>=2,0}
Line 3312
  style always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 3313
  = always 0
  0 always 0
  j possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 3314
  j {<=symbolic=(function->argCount()-1),!>=symbolic=(function->argCount())}
  && always {!<=-1,!>=2}
  j always !>=symbolic=(function->argCount())
  && always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(funcArgNamesDifferent(function->name(),j,declarations[j],definitions[j]))
  j always !>=symbolic=(function->argCount())
  != always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(funcArgNamesDifferent(function->name(),j,declarations[j],definitions[j]))
  j always !>=symbolic=(function->argCount())
Line 3315
  j always !>=symbolic=(function->argCount())
  j always !>=symbolic=(function->argCount())
  j always !>=symbolic=(function->argCount())
Line 3324
  declaration possible 0@193
  definition inconclusive 0
Line 3325
  tokens always {{,size=2}
  :: always 3
  style always 3
  "funcArgNamesDifferent" always "funcArgNamesDifferent"
Line 3326
  "$symbol:" always "$symbol:"
  functionName inconclusive "function"@193
  "\nFunction '$symbol' argument " always "\nFunction '$symbol' argument "
Line 3327
  index inconclusive 1@193
  1 always 1
  " names different: declaration '" always " names different: declaration '"
Line 3328
  declaration inconclusive 0@193
  declaration always !0
  "A" always "A"
  "' definition '" always "' definition '"
Line 3329
  definition inconclusive 0@193
  definition always !0
  "B" always "B"
  "'." always "'."
Line 3338
  declarations possible size=0@202
  ( {!<=-1,0@202}
  0 always 0
  0 always 0
  : always 0
  nullptr always 0
Line 3339
  definitions possible size=0@202
  ( {!<=-1,0@202}
  0 always 0
  0 always 0
  : always 0
  nullptr always 0
Line 3341
  "$symbol:" always "$symbol:"
  functionName possible "function"@202
  "\nFunction '$symbol' argument order different: declaration '" always "\nFunction '$symbol' argument order different: declaration '"
Line 3342
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  declarations possible size=0@202
  ( {!<=-1,0@202}
Line 3343
  i {<=symbolic=(declarations.size()-1),!>=symbolic=(declarations.size())}
  != always {!<=-1,!>=2}
  0 always 0
Line 3344
  ", " always ", "
Line 3345
  i {!>=symbolic=(declarations.size()),0}
Line 3346
  [ always !0
  i always !>=symbolic=(declarations.size())
Line 3348
  "' definition '" always "' definition '"
Line 3349
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  definitions possible size=0@202
  ( {!<=-1,0@202}
Line 3350
  i {<=symbolic=(definitions.size()-1),!>=symbolic=(definitions.size())}
  != always {!<=-1,!>=2}
  0 always 0
Line 3351
  ", " always ", "
Line 3352
  i {!>=symbolic=(definitions.size()),0}
Line 3353
  [ always !0
  i always !>=symbolic=(definitions.size())
Line 3355
  "'" always "'"
Line 3356
  tokens always {{,size=2}
  :: always 2
  warning always 2
  "funcArgOrderDifferent" always "funcArgOrderDifferent"
  msg always !<=size=0
  :: always 0
  normal always 0
Line 3361
  ! always {!<=-1,!>=2}
Line 3362
  nullptr always 0
Line 3363
  scope always !0
Line 3364
  scope always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 3366
  == always {!<=-1,!>=2}
Line 3370
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3373
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 3374
  nullptr always 0
Line 3376
  ! always {!<=-1,!>=2}
Line 3383
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 3386
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3387
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 3389
  = {&,lifetime[Address]=(symbolDatabase->scopeList),!0}
  & {&,lifetime[Address]=(symbolDatabase->scopeList),!0}
Line 3390
  functionScope possible {lifetime[Address]=(symbolDatabase->scopeList),symbolic=(&scope),&,0}
  && {!<=-1,!>=2,0}
  functionScope {lifetime[Address]=(symbolDatabase->scopeList),symbolic=(&scope),&,!0}
  . possible 5
  != {!<=-1,!>=2,0}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  functionScope {lifetime[Address]=(symbolDatabase->scopeList),symbolic=(&scope),!0}
  . always !5
  != always {!<=-1,!>=2}
  :: always 15
  eLambda always 15
Line 3391
  functionScope {lifetime[Address]=(symbolDatabase->scopeList),!0}
Line 3393
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 3396
  && always {!<=-1,!>=2}
  functionScope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  functionScope always !0
Line 3397
  shadowArg always {!<=-1,!>=2}
  shadowArg always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3398
  functionScope always !0
  . always !0
Line 3399
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3400
  "argument" always "argument"
Line 3401
  shadowArg always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3405
  shadowArg {!<=-1,!>=2,1}
Line 3410
  ! always {!<=-1,!>=2}
Line 3412
  ! always {!<=-1,!>=2}
Line 3414
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 3416
  && always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3417
  shadowed always !0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  shadowed always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 3419
  != always {!<=-1,!>=2}
  0 always 0
  "variable" always "variable"
  : always "function"
  "function" always "function"
Line 3427
  errorPath always size=0
  shadowed possible 0@195
  "Shadowed declaration" always "Shadowed declaration"
Line 3428
  errorPath always size=1
  var inconclusive 0@195
  "Shadow variable" always "Shadow variable"
Line 3429
  = {"argument"@172,"variable"@195,"function"@196,"argument"@197}
  var inconclusive 0@195
  ? {"argument"@172,"variable"@195,"function"@196,"argument"@197}
  var always !0
  : {"argument"@172,"variable"@195,"function"@196,"argument"@197}
  type {"argument"@172,"variable"@195,"function"@196,"argument"@197}
Line 3430
  ( {65,86,70}
  ( {65,86,70}
  type {"argument"@172,"variable"@195,"function"@196,"argument"@197}
  [ {97,118,102}
  0 always 0
  type {"argument"@172,"variable"@195,"function"@196,"argument"@197}
  1 always 1
Line 3431
  "shadow" always "shadow"
Line 3432
  "$symbol:" always "$symbol:"
  "\nLocal variable \'$symbol\' shadows outer " always "\nLocal variable \'$symbol\' shadows outer "
Line 3433
  errorPath always size=2
  :: always 3
  style always 3
  id always symbolic=("shadow"+Type)
  ( {lifetime[Object]=(id),!0}
  :: always 0
  normal always 0
Line 3436
  ( always {!<=-1,!>=2}
Line 3438
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok)@120
  "%var%" always "%var%"
Line 3439
  return always {!<=-1,!>=2}
  true always 1
Line 3440
  ( always {!<=-1,!>=2}
  "." always "."
Line 3441
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3442
  ( always {!<=-1,!>=2}
Line 3443
  ( always {!<=-1,!>=2}
  "[" always "["
Line 3444
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 3445
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 3446
  return always {!<=-1,!>=2}
  false always 0
Line 3451
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 3454
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3455
  tok possible symbolic=(tok->astParent()->previous())
  != always {!<=-1,!>=2}
Line 3456
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->previous())
  "(" always "("
Line 3458
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->previous())
  ( possible symbolic=(tok)
  "%name%" always "%name%"
Line 3460
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->previous())
  ( possible symbolic=(tok)
  "if|while|switch|sizeof" always "if|while|switch|sizeof"
Line 3462
  == always {!<=-1,!>=2}
Line 3464
  ! always {!<=-1,!>=2}
  tok always !symbolic=(tok->astParent()->previous())
  ( always {!<=-1,!>=2}
Line 3466
  ( always {!<=-1,!>=2}
  tok always !symbolic=(tok->astParent()->previous())
  "++|--" always "++|--"
Line 3468
  ( always {!<=-1,!>=2}
Line 3471
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok)
Line 3472
  tok2 always symbolic=(tok)
Line 3473
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
Line 3477
  isVariableExprHidden always {!<=-1,!>=2}
  isVariableExprHidden always {!<=-1,!>=2}
  = always 0
  false always 0
Line 3478
  = possible {lifetime[Lambda]=(isVariableExprHidden),lifetime[Lambda]=(varexpr)}
  [ possible {lifetime[Lambda]=(isVariableExprHidden),lifetime[Lambda]=(varexpr)}
  & {lifetime[Address]=(varexpr),!0}
  , {lifetime[Address]=(isVariableExprHidden),!0}
  & {lifetime[Address]=(isVariableExprHidden),!0}
  isVariableExprHidden always 0
Line 3479
  ( always {!<=-1,!>=2}
  "%var%|.|[" always "%var%|.|["
Line 3480
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3482
  :: always 4
  done always 4
Line 3484
  :: always 0
  none always 0
Line 3486
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 3487
  :: always 0
  none always 0
Line 3490
  ! always {!<=-1,!>=2}
  isVariableExprHidden always {!<=-1,!>=2}
Line 3491
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "0" always "0"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "0" always "0"
Line 3492
  :: always 0
  none always 0
Line 3493
  ( always {!<=-1,!>=2}
  "&&" always "&&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "false" always "false"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "false" always "false"
Line 3494
  :: always 0
  none always 0
Line 3495
  ( always {!<=-1,!>=2}
  "||" always "||"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "true" always "true"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "true" always "true"
Line 3496
  :: always 0
  none always 0
Line 3499
  :: always 3
  op1_and_op2 always 3
Line 3501
  setVarExpr possible {lifetime[Lambda]=(isVariableExprHidden),lifetime[Lambda]=(varexpr)}
Line 3502
  varexpr possible size=0
  ( {!<=-1,!>=2,0,1}
Line 3503
  isVariableExprHidden always {!<=-1,!>=2}
  = always 1
  true always 1
Line 3504
  setVarExpr possible {lifetime[Lambda]=(isVariableExprHidden),lifetime[Lambda]=(varexpr)}
Line 3506
  varexpr possible size=0
  ( {!<=-1,!>=2,1,0}
Line 3510
  funcname always symbolic=(tok->astParent()->previous()->str())
Line 3511
  ( always !<=-1
  "assert" always "assert"
  != always {!<=-1,!>=2}
Line 3513
  & always !0
  varexpr always !size=0
  isVariableExprHidden always {!<=-1,!>=2}
Line 3518
  , always {!<=-1,!>=2}
  isVariableExpressionHidden always {!<=-1,!>=2}
Line 3520
  ! {!<=-1,!>=2,1@198}
  tok possible 0@198
Line 3521
  tok always 0
  :: always 3
  style always 3
  "knownArgument" always "knownArgument"
  "Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has." always "Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has."
Line 3522
  tok always 0
  :: always 3
  style always 3
  "knownArgumentHiddenVariableExpression" always "knownArgumentHiddenVariableExpression"
  "Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'." always "Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'."
Line 3527
  tok always !0
Line 3531
  "Argument '" always "Argument '"
  expr always symbolic=(tok->expressionString())
  "' to function " always "' to function "
  fun always symbolic=(ftok->str())
  " is always " always " is always "
  intvalue always symbolic=(value->intvalue)
  ". " always ". "
Line 3532
  ! always {!<=-1,!>=2}
  isVariableExpressionHidden always {!<=-1,!>=2}
Line 3533
  = always "knownArgument"
  "knownArgument" always "knownArgument"
Line 3534
  "It does not matter what value '" always "It does not matter what value '"
  "' has." always "' has."
Line 3536
  = always "knownArgumentHiddenVariableExpression"
  "knownArgumentHiddenVariableExpression" always "knownArgumentHiddenVariableExpression"
Line 3537
  "Constant literal calculation disable/hide variable expression '" always "Constant literal calculation disable/hide variable expression '"
  "'." always "'."
Line 3540
  tok always !0
Line 3541
  :: always 3
  style always 3
  id possible {"knownArgument","knownArgumentHiddenVariableExpression"}
  :: always 0
  normal always 0
Line 3547
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3548
  != always {!<=-1,!>=2}
Line 3549
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|>|<=|>=|-" always "<|>|<=|>=|-"
Line 3553
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok1 always symbolic=(tok->astOperand1())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->astOperand2())
Line 3555
  tok1 always symbolic=(tok->astOperand1())
Line 3556
  tok2 always symbolic=(tok->astOperand2())
Line 3557
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3561
  ! always {!<=-1,!>=2}
  var1 always symbolic=(v1.tokvalue->variable())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var2 always symbolic=(v2.tokvalue->variable())
Line 3563
  == always {!<=-1,!>=2}
Line 3565
  var1 always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var2 always !0
  ( always {!<=-1,!>=2}
Line 3567
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3569
  & {lifetime[Address]=(v1),!0}
  & {lifetime[Address]=(v2),!0}
Line 3577
  = always "Comparing"
  "Comparing" always "Comparing"
Line 3578
  ( always {!<=-1,!>=2}
  tok possible 0@199
  "-" always "-"
Line 3579
  = always "Subtracting"
  "Subtracting" always "Subtracting"
Line 3580
  v1 possible {lifetime[Address]=(v1)@104,0@199}
Line 3581
  errorPath always size=0
  v1 {!0,lifetime[Address]=(v1)@104}
  "Variable declared here." always "Variable declared here."
Line 3582
  ( possible lifetime[Iterator]=(errorPath)
  ( {lifetime[Iterator]=(errorPath),end=0}
  v1 {!0,lifetime[Address]=(v1)@104}
  ( {lifetime[Iterator]=(v1->errorPath),start=0}
  v1 {!0,lifetime[Address]=(v1)@104}
  ( {lifetime[Iterator]=(v1->errorPath),end=0}
Line 3584
  v2 possible {lifetime[Address]=(v2)@104,0@199}
Line 3585
  v2 {!0,lifetime[Address]=(v2)@104}
  "Variable declared here." always "Variable declared here."
Line 3586
  ( possible lifetime[Iterator]=(errorPath)
  ( {lifetime[Iterator]=(errorPath),end=0}
  v2 {!0,lifetime[Address]=(v2)@104}
  ( {lifetime[Iterator]=(v2->errorPath),start=0}
  v2 {!0,lifetime[Address]=(v2)@104}
  ( {lifetime[Iterator]=(v2->errorPath),end=0}
Line 3588
  tok possible 0@199
  "" always ""
Line 3590
  :: always 1
  error always 1
  "comparePointers" always "comparePointers"
  " pointers that point to different objects" always " pointers that point to different objects"
  :: always 0
  normal always 0
Line 3595
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 3599
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 3601
  != always {!<=-1,!>=2}
  "%" always "%"
Line 3603
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 3607
  1LL always 1
Line 3608
  && always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
Line 3615
  tok possible 0@203
  :: always 3
  style always 3
  "moduloofone" always "moduloofone"
  "Modulo of one is always equal to zero" always "Modulo of one is always equal to zero"
Line 3621
  ( always {!<=-1,!>=2}
Line 3623
  ! always {!<=-1,!>=2}
Line 3624
  return always {!<=-1,!>=2}
  false always 0
Line 3626
  expr always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  expr always !0
  "[" always "["
Line 3627
  expr always !0
Line 3628
  expr always !0
Line 3629
  ( always {!<=-1,!>=2}
  expr always !0
  "+|-" always "+|-"
  && always {!<=-1,!>=2}
  expr always !0
  ( always {!<=-1,!>=2}
Line 3630
  pointer1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  expr always !0
  && always {!<=-1,!>=2}
  expr always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3631
  pointer2 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  expr always !0
  && always {!<=-1,!>=2}
  expr always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3632
  pointer1 {symbolic=(expr->astOperand1()->valueType()&&expr->astOperand1()->valueType()->pointer>0),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  pointer2 {symbolic=(expr->astOperand2()->valueType()&&expr->astOperand2()->valueType()->pointer>0),!<=-1,!>=2}
Line 3633
  expr always !0
Line 3634
  expr always !0
Line 3635
  ! {!<=-1,!>=2,1}
  pointer1 {symbolic=(expr->astOperand1()->valueType()&&expr->astOperand1()->valueType()->pointer>0),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  pointer2 {symbolic=(expr->astOperand2()->valueType()&&expr->astOperand2()->valueType()->pointer>0),!<=-1,!>=2}
Line 3636
  expr always !0
Line 3637
  expr always !0
Line 3639
  return always {!<=-1,!>=2}
  false always 0
Line 3641
  expr always !0
  && always {!<=-1,!>=2}
  expr always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 3642
  = always !0
  expr always !0
Line 3643
  = always 0
  0 always 0
Line 3644
  return always {!<=-1,!>=2}
  true always 1
Line 3646
  return always {!<=-1,!>=2}
  false always 0
Line 3648
  ! always {!<=-1,!>=2}
  bufToken possible {symbolic=(expr->astOperand1()->astOperand1()),symbolic=(expr->astOperand1()),symbolic=(expr->astOperand2())}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
Line 3649
  return always {!<=-1,!>=2}
  false always 0
Line 3650
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 3651
  return always {!<=-1,!>=2}
  false always 0
Line 3654
  return always {!<=-1,!>=2}
  true always 1
Line 3660
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 3661
  != always {!<=-1,!>=2}
Line 3662
  ( always {!<=-1,!>=2}
Line 3665
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  lhs always symbolic=(tok->astOperand1())
  "." always "."
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhs always symbolic=(tok->astOperand1())
  ( always {!<=-1,!>=2}
Line 3667
  lhs always symbolic=(tok->astOperand1())
Line 3668
  ! always {!<=-1,!>=2}
  lhsvar always symbolic=(lhs->astOperand1()->variable())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhsvar {symbolic=(lhs->astOperand1()->variable()),!0}
  || always {!<=-1,!>=2}
  lhsvar {symbolic=(lhs->astOperand1()->variable()),!0}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 3671
  ! always {!<=-1,!>=2}
  lhsmember always symbolic=(lhs->astOperand2())
Line 3675
  errorToken possible 0
  = always 0
  nullptr always 0
Line 3676
  [ possible lifetime[Lambda]=(errorToken)
  , {lifetime[Address]=(errorToken),!0}
  & {lifetime[Address]=(errorToken),!0}
  errorToken possible 0
Line 3677
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 3678
  :: always 3
  op1_and_op2 always 3
Line 3679
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 3680
  :: always 0
  none always 0
Line 3681
  == always {!<=-1,!>=2}
Line 3682
  :: always 0
  none always 0
Line 3684
  :: always 4
  done always 4
Line 3688
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 3690
  ! always {!<=-1,!>=2}
Line 3693
  nonOverlappingData always !0
  <= always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  nonOverlappingData always !0
  . {!<=0,>=1}
  > always {!<=-1,!>=2}
  ( always !<=-1
Line 3695
  nonOverlappingData always !0
  <= always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  nonOverlappingData always !0
  . {!<=0,>=1}
  > always {!<=-1,!>=2}
  ( always {!<=-1,!<=symbolic=(nonOverlappingData->ptr1Arg-1)}
Line 3698
  . always {!>=symbolic=(args.size()+1),!<=0}
  - always !<=-1
  1 always 1
Line 3699
  ptr1 always symbolic=(args[nonOverlappingData->ptr1Arg-1])
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ptr1 always symbolic=(args[nonOverlappingData->ptr1Arg-1])
  == always {!<=-1,!>=2}
  0 always 0
Line 3702
  . always {!>=symbolic=(args.size()+1),!<=0}
  - always !<=-1
  1 always 1
Line 3703
  ptr2 always symbolic=(args[nonOverlappingData->ptr2Arg-1])
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ptr2 always symbolic=(args[nonOverlappingData->ptr2Arg-1])
  == always {!<=-1,!>=2}
  0 always 0
Line 3707
  . possible -1
  <= {!<=-1,!>=2,1}
  0 always 0
  || always {!<=-1,!>=2}
  . {!<=0,>=1}
  > always {!<=-1,!>=2}
  ( always !<=-1
Line 3708
  . possible {>=symbolic=(args.size()+1),<=0}
  == {!<=-1,!>=2,<=0}
  -1 always -1
Line 3710
  macro always 1
  = always 1
  true always 1
Line 3711
  pure always 1
  = always 1
  true always 1
Line 3712
  follow always 1
  = always 1
  true always 1
Line 3713
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro always 1
  ptr2 always symbolic=(args[nonOverlappingData->ptr2Arg-1])
  pure always 1
  follow always 1
  & {lifetime[Address]=(errorPath),!0}
  errorPath always size=0
Line 3719
  ! always {!<=-1,!>=2}
  . {!>=symbolic=(args.size()+1),<=symbolic=(args.size()),!<=0,>=1}
  - {!<=-1,>=0}
  1 always 1
  ( always {!<=-1,!>=2}
Line 3721
  . always {!>=symbolic=(args.size()+1),!<=0}
  - always !<=-1
  1 always 1
Line 3724
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(buf1),!0,Uninit*}
  buf1 always Uninit
  & {lifetime[Address]=(offset1),!0,Uninit*}
  offset1 always Uninit
Line 3726
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(buf2),!0,Uninit*}
  buf2 always Uninit
  & {lifetime[Address]=(offset2),!0,Uninit*}
  offset2 {>=symbolic=(offset1+sizeValue),<=symbolic=(offset1+sizeValue-1),Uninit}
Line 3729
  offset1 possible {>=symbolic=(offset2+sizeValue),<=symbolic=(offset2+sizeValue-1)}
  < always {!<=-1,!>=2}
  offset2 possible {>=symbolic=(offset1+sizeValue),<=symbolic=(offset1+sizeValue-1)}
  && always {!<=-1,!>=2}
  offset1 {<=symbolic=(offset2-1),!>=symbolic=(offset2)}
  <= always {!<=-1,!>=2}
  offset2 {>=symbolic=(offset1+1),!<=symbolic=(offset1)}
Line 3731
  offset2 possible {<=symbolic=(offset1),<=symbolic=(offset1+sizeValue-1)}
  < always {!<=-1,!>=2}
  offset1 possible {>=symbolic=(offset2+sizeValue),<=symbolic=(offset2+sizeValue-1),>=symbolic=(offset2)}
  && always {!<=-1,!>=2}
  offset2 {<=symbolic=(offset1-1),!>=symbolic=(offset1)}
  <= always {!<=-1,!>=2}
  offset1 {>=symbolic=(offset2+1),!<=symbolic=(offset2)}
Line 3735
  macro always 1
  = always 1
  true always 1
Line 3736
  pure always 1
  = always 1
  true always 1
Line 3737
  follow always 1
  = always 1
  true always 1
Line 3738
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  macro always 1
  pure always 1
  follow always 1
  & {lifetime[Address]=(errorPath),!0}
  errorPath always size=0
Line 3748
  tok possible 0@149
  :: always 1
  error always 1
  "overlappingWriteUnion" always "overlappingWriteUnion"
  "Overlapping read/write of union is undefined behavior" always "Overlapping read/write of union is undefined behavior"
Line 3753
  = possible ""
  tok possible 0@150
  ? possible ""
  tok always !0
  : always ""
  "" always ""
Line 3754
  tok possible 0@150
  :: always 1
  error always 1
  "overlappingWriteFunction" always "overlappingWriteFunction"
  "Overlapping read/write in " always "Overlapping read/write in "
  funcname always symbolic=(tok?tok->str():"")
  "() is undefined behavior" always "() is undefined behavior"
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,3@73,2@207,5@110,4@169}
  flag possible {3@73,2@207,5@110,4@169}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,3@211}
  flag possible 3@211
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
