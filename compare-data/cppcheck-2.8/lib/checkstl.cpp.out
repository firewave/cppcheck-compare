

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073745122 !@expr1073745123 mTokenizer@var28 ) {
69: instances (@expr1073745124 ) .@expr1073745125 remove (@expr1073745126 this@expr1073745127 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073745128 string (@expr1073745129 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073745130 void ) tokenizer@var21 ;
108: (@expr1073745131 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073745132 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073745133 void ) ctu@var24 ;
120: (@expr1073745134 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073745135 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073745136 0U ) , Certainty ::@expr1073745137 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073745138 list < const Token *@expr1073745139 > callstack@var41 (@expr1073745140 1 , tok@var35 ) ;
141: reportError (@expr1073745141 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073745142 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073745143 0U ) , Certainty ::@expr1073745144 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var64 ;
42: double mDoubleValue@var65 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var66 ;
44: bool mIsUnsigned@var67 ;
45:
46: void promote ( const value & v@var68 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var69 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var66 !=@expr1073745145 Type ::@expr1073745146 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var66 ==@expr1073745147 Type ::@expr1073745148 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073745149 ) ?@expr1073745150 mDoubleValue@var65 :@expr1073745151 (@expr1073745152 double ) mIntValue@var64 ;
60: }
61:
62: static value calc ( char op@var70 , const value & v1@var71 , const value & v2@var72 ) ;
63: int compare ( const value & v@var73 ) const ;
64: value add ( int v@var74 ) const ;
65: value shiftLeft ( const value & v@var75 ) const ;
66: value shiftRight ( const value & v@var76 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var77 ;
72:
73: static long long toLongNumber ( const std :: string & str@var78 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var79 ) ;
75:
76: template < class T > static std :: string toString ( T value@var80 ) {
77: std ::@expr1073745153 ostringstream result@var81 ;
78: result@var81 <<@expr1073745154 value@var80 ;
79: return result@var81 .@expr1073745155 str (@expr1073745156 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var82 ) ;
82:
83: static bool isInt ( const std :: string & str@var83 ) ;
84: static bool isFloat ( const std :: string & str@var84 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var85 ) ;
86: static bool isNegative ( const std :: string & str@var86 ) ;
87: static bool isPositive ( const std :: string & str@var87 ) ;
88: static bool isDec ( const std :: string & str@var88 ) ;
89: static bool isFloatHex ( const std :: string & str@var89 ) ;
90: static bool isIntHex ( const std :: string & str@var90 ) ;
91: static bool isOct ( const std :: string & str@var91 ) ;
92: static bool isBin ( const std :: string & str@var92 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var93 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var94 , bool supportMicrosoftExtensions@var95 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var96 , const std :: string & second@var97 ) ;
105: static std :: string subtract ( const std :: string & first@var98 , const std :: string & second@var99 ) ;
106: static std :: string multiply ( const std :: string & first@var100 , const std :: string & second@var101 ) ;
107: static std :: string divide ( const std :: string & first@var102 , const std :: string & second@var103 ) ;
108: static std :: string mod ( const std :: string & first@var104 , const std :: string & second@var105 ) ;
109: static std :: string incdec ( const std :: string & var@var106 , const std :: string & op@var107 ) ;
110: static std :: string calculate ( const std :: string & first@var108 , const std :: string & second@var109 , char action@var110 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var111 ) ;
113: static std :: string cos ( const std :: string & tok@var112 ) ;
114: static std :: string tan ( const std :: string & tok@var113 ) ;
115: static std :: string abs ( const std :: string & tok@var114 ) ;
116: static bool isEqual ( const std :: string & first@var115 , const std :: string & second@var116 ) ;
117: static bool isNotEqual ( const std :: string & first@var117 , const std :: string & second@var118 ) ;
118: static bool isGreater ( const std :: string & first@var119 , const std :: string & second@var120 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var121 , const std :: string & second@var122 ) ;
120: static bool isLess ( const std :: string & first@var123 , const std :: string & second@var124 ) ;
121: static bool isLessEqual ( const std :: string & first@var125 , const std :: string & second@var126 ) ;
122: static bool isNullValue ( const std :: string & str@var127 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var128 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var129 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var130 , std :: string :: size_type iPos@var131 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var132 , const MathLib :: value & v2@var133 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var134 , const MathLib :: value & v2@var135 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var136 , const MathLib :: value & v2@var137 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var138 , const MathLib :: value & v2@var139 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var140 , const MathLib :: value & v2@var141 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var142 , const MathLib :: value & v2@var143 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var144 , const MathLib :: value & v2@var145 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var146 , const MathLib :: value & v2@var147 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var148 , const MathLib :: value & v2@var149 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var150 , const MathLib :: value & v2@var151 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var152 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var153 ) const {
54: x@var153 ++@expr1073745157 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var154 ) const {
60: x@var154 --@expr1073745158 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var155 , const U & y@var156 ) const {
67: return x@var155 <@expr1073745159 y@var156 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var157 , const U & y@var158 ) const {
74: return std ::@expr1073745160 abs (@expr1073745161 x@var157 -@expr1073745162 y@var158 ) ==@expr1073745163 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var159 , T x@var160 , U y@var161 ) const {
81: result@var159 =@expr1073745164 !@expr1073745165 (@expr1073745166 x@var160 >@expr1073745167 y@var161 ||@expr1073745168 x@var160 <@expr1073745169 y@var161 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var162 = 0 , Bound b@var163 = Bound :: Point )
91: : valueType@var203 ( ValueType :: INT ) ,
92: bound@var204 ( b@var163 ) ,
93: intvalue@var205 ( val@var162 ) ,
94: tokvalue@var206 ( nullptr ) ,
95: floatValue@var207 ( 0.0 ) ,
96: moveKind@var208 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var209 ( val@var162 ) ,
98: condition@var210 ( nullptr ) ,
99: varId@var212 ( 0U ) ,
100: safe@var213 ( false ) ,
101: conditional@var214 ( false ) ,
102: macro@var215 ( false ) ,
103: defaultArg@var216 ( false ) ,
104: indirect@var217 ( 0 ) ,
105: path@var218 ( 0 ) ,
106: wideintvalue@var219 ( val@var162 ) ,
107: subexpressions@var220 ( ) ,
108: capturetok@var221 ( nullptr ) ,
109: lifetimeKind@var222 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var223 ( LifetimeScope :: Local ) ,
111: valueKind@var228 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var164 , long long val@var165 , Bound b@var166 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var167 ) const {
118: if (@expr1073745170 valueType@var203 !=@expr1073745171 rhs@var167 .@expr1073745172 valueType@var168 ) {
119: return false ; }
120: switch (@expr1073745173 valueType@var203 ) {
121: case ValueType ::@expr1073745174 INT :@expr3351
122: case ValueType ::@expr1073745176 CONTAINER_SIZE :@expr3351
123: case ValueType ::@expr1073745178 BUFFER_SIZE :@expr3351
124: case ValueType ::@expr1073745180 ITERATOR_START :@expr3351
125: case ValueType ::@expr1073745182 ITERATOR_END :@expr3351 ;
126: if (@expr3360 intvalue@var205 !=@expr3361 rhs@var167 .@expr3362 intvalue@var169 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745187 TOK :@expr3351 ;
130: if (@expr3365 tokvalue@var206 !=@expr3366 rhs@var167 .@expr3367 tokvalue@var170 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745192 FLOAT :@expr3351 ;
134:
135: if (@expr1073745194 floatValue@var207 >@expr1073745195 rhs@var167 .@expr3372 floatValue@var171 ||@expr1073745197 floatValue@var207 <@expr1073745198 rhs@var167 .@expr3372 floatValue@var171 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745200 MOVED :@expr3351 ;
139: if (@expr1073745202 moveKind@var208 !=@expr1073745203 rhs@var167 .@expr1073745204 moveKind@var172 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745205 UNINIT :@expr3351 ;
143: break ;
144: case ValueType ::@expr1073745207 LIFETIME :@expr3351 ;
145: if (@expr3365 tokvalue@var206 !=@expr3366 rhs@var167 .@expr3367 tokvalue@var170 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745212 SYMBOLIC :@expr3351 ;
149: if (@expr1073745214 !@expr1073745215 sameToken (@expr1073745216 tokvalue@var206 , rhs@var167 .@expr3367 tokvalue@var170 ) ) {
150: return false ; }
151: if (@expr3360 intvalue@var205 !=@expr3361 rhs@var167 .@expr3362 intvalue@var169 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var173 , F f@var174 ) {
160: switch (@expr1073745221 self@var173 .@expr1073745222 valueType@var175 ) {
161: case ValueType ::@expr1073745223 INT :@expr3400
162: case ValueType ::@expr1073745225 SYMBOLIC :@expr3400
163: case ValueType ::@expr1073745227 BUFFER_SIZE :@expr3400
164: case ValueType ::@expr1073745229 CONTAINER_SIZE :@expr3400
165: case ValueType ::@expr1073745231 ITERATOR_START :@expr3400
166: case ValueType ::@expr1073745233 ITERATOR_END :@expr3400 ; {
167: f@var174 (@expr1073745235 self@var173 .@expr1073745236 intvalue@var176 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745237 FLOAT :@expr3400 ; {
171: f@var174 (@expr1073745239 self@var173 .@expr1073745240 floatValue@var177 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745241 UNINIT :@expr3400
175: case ValueType ::@expr1073745243 TOK :@expr3400
176: case ValueType ::@expr1073745245 LIFETIME :@expr3400
177: case ValueType ::@expr1073745247 MOVED :@expr3400 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var178 , Compare compare@var179 , T x@var180 , U y@var181 ) const {
186: result@var178 =@expr1073745249 compare@var179 (@expr1073745250 x@var180 , y@var181 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var182 , const Value & rhs@var183 , Compare compare@var184 , T x@var185 ) const {
191: visitValue (@expr1073745252 rhs@var183 ,
192: std ::@expr1073745253 bind (@expr1073745254 innerVisitor {@expr1073745255 } , std ::@expr1073745256 ref (@expr1073745257 result@var182 ) , std ::@expr1073745258 move (@expr1073745259 compare@var184 ) , x@var185 , std ::@expr1073745260 placeholders ::@expr1073745261 _1@expr1073745251 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var186 , Compare compare@var187 ) const {
198: assert (@expr1073745263 (@expr1073745264 !@expr1073745265 this@expr3442 .@expr1073745267 isSymbolicValue (@expr1073745268 ) &&@expr1073745269 !@expr1073745270 rhs@var186 .@expr1073745271 isSymbolicValue (@expr1073745272 ) ) ||@expr1073745273
199: (@expr1073745274 this@expr3442 .@expr1073745275 valueType@var203 ==@expr1073745276 rhs@var186 .@expr1073745277 valueType@var188 &&@expr1073745278 sameToken (@expr1073745279 this@expr3442 .@expr1073745280 tokvalue@var206 , rhs@var186 .@expr1073745281 tokvalue@var189 ) ) ) ;
200: bool result@var190 ; result@var190 =@expr1073745282 false ;
201: visitValue (@expr1073745283
202: *@expr1073745284 this@expr3442 ,
203: std ::@expr1073745285 bind (@expr1073745286 compareVisitor {@expr1073745287 } , std ::@expr3464 ref (@expr1073745289 result@var190 ) , std ::@expr3464 ref (@expr1073745291 rhs@var186 ) , std ::@expr1073745292 move (@expr1073745293 compare@var187 ) , std ::@expr1073745294 placeholders ::@expr1073745295 _1@expr1073745262 ) ) ;
204: return result@var190 ;
205: }
206:
207: bool operator== ( const Value & rhs@var191 ) const {
208: if (@expr1073745296 !@expr1073745297 equalValue (@expr1073745298 rhs@var191 ) ) {
209: return false ; }
210:
211: return varvalue@var209 ==@expr1073745299 rhs@var191 .@expr1073745300 varvalue@var192 &&@expr1073745301
212: condition@var210 ==@expr1073745302 rhs@var191 .@expr1073745303 condition@var193 &&@expr1073745304
213: varId@var212 ==@expr1073745305 rhs@var191 .@expr1073745306 varId@var194 &&@expr1073745307
214: conditional@var214 ==@expr1073745308 rhs@var191 .@expr1073745309 conditional@var195 &&@expr1073745310
215: defaultArg@var216 ==@expr1073745311 rhs@var191 .@expr1073745312 defaultArg@var196 &&@expr1073745313
216: indirect@var217 ==@expr1073745314 rhs@var191 .@expr1073745315 indirect@var197 &&@expr1073745316
217: valueKind@var228 ==@expr1073745317 rhs@var191 .@expr1073745318 valueKind@var198 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var199 ) const {
221: return !@expr1073745319 (@expr1073745320 *@expr1073745321 this@expr1073745322 ==@expr1073745323 rhs@var199 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var200 ) const {
226: bool result@var201 ; result@var201 =@expr1073745325 false ;
227: visitValue (@expr1073745326 *@expr1073745327 this@expr1073745328 , std ::@expr1073745329 bind (@expr1073745330 equalVisitor {@expr1073745331 } , std ::@expr1073745332 ref (@expr1073745333 result@var201 ) , x@var200 , std ::@expr1073745334 placeholders ::@expr1073745335 _1@expr1073745324 ) ) ;
228: return result@var201 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745336 bound@var204 ==@expr1073745337 Bound ::@expr1073745338 Lower ) {
233: visitValue (@expr1073745339 *@expr3516 this@expr3517 , increment {@expr1073745342 } ) ; }
234: else { if (@expr1073745343 bound@var204 ==@expr1073745344 Bound ::@expr1073745345 Upper ) {
235: visitValue (@expr1073745346 *@expr3516 this@expr3517 , decrement {@expr1073745348 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745349 bound@var204 ==@expr1073745350 Bound ::@expr3527 Lower ) {
240: bound@var204 =@expr1073745352 Bound ::@expr3529 Upper ; }
241: else { if (@expr1073745354 bound@var204 ==@expr1073745355 Bound ::@expr3529 Upper ) {
242: bound@var204 =@expr1073745357 Bound ::@expr3527 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745359 ) ;
247: decreaseRange (@expr1073745360 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var202 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var203 ;
267: bool isIntValue ( ) const {
268: return valueType@var203 ==@expr1073745361 ValueType ::@expr1073745362 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var203 ==@expr1073745363 ValueType ::@expr1073745364 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var203 ==@expr1073745365 ValueType ::@expr1073745366 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var203 ==@expr1073745367 ValueType ::@expr1073745368 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var203 ==@expr1073745369 ValueType ::@expr1073745370 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var203 ==@expr1073745371 ValueType ::@expr1073745372 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var203 ==@expr1073745373 ValueType ::@expr1073745374 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var203 ==@expr1073745375 ValueType ::@expr1073745376 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var203 ==@expr1073745377 ValueType ::@expr1073745378 ITERATOR_START ||@expr1073745379 valueType@var203 ==@expr1073745380 ValueType ::@expr1073745381 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var203 ==@expr1073745382 ValueType ::@expr1073745383 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var203 ==@expr1073745384 ValueType ::@expr1073745385 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var203 ==@expr1073745386 ValueType ::@expr1073745387 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var203 ==@expr1073745389 ValueType ::@expr1073745390 LIFETIME &&@expr1073745391 lifetimeScope@var223 ==@expr1073745392 LifetimeScope ::@expr1073745393 Local@expr1073745388 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var203 ==@expr1073745394 ValueType ::@expr1073745395 LIFETIME &&@expr1073745396 lifetimeScope@var223 ==@expr1073745397 LifetimeScope ::@expr1073745398 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var203 ==@expr1073745399 ValueType ::@expr1073745400 LIFETIME &&@expr1073745401 lifetimeScope@var223 ==@expr1073745402 LifetimeScope ::@expr1073745403 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745404 ) ||@expr1073745405 isUninitValue (@expr1073745406 ) ||@expr1073745407 isLifetimeValue (@expr1073745408 ) ;
318: }
319:
320:
321: Bound bound@var204 ;
322:
323:
324: long long intvalue@var205 ;
325:
326:
327: const Token * tokvalue@var206 ;
328:
329:
330: double floatValue@var207 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var208 ;
334:
335:
336: long long varvalue@var209 ;
337:
338:
339: const Token * condition@var210 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var211 ;
342:
343:
344: int varId@var212 ;
345:
346:
347: bool safe@var213 ;
348:
349:
350: bool conditional@var214 ;
351:
352:
353: bool macro@var215 ;
354:
355:
356: bool defaultArg@var216 ;
357:
358: int indirect@var217 ;
359:
360:
361: long long path@var218 ;
362:
363:
364: long long wideintvalue@var219 ;
365:
366: std :: vector < std :: string > subexpressions@var220 ;
367:
368:
369: const Token * capturetok@var221 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var222 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var223 ;
385:
386: static const char * toString ( MoveKind moveKind@var224 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var225 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var226 ) ;
389: static const char * toString ( Bound bound@var227 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var228 ;
402:
403: void setKnown ( ) {
404: valueKind@var228 =@expr1073745409 ValueKind ::@expr1073745410 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var228 ==@expr1073745411 ValueKind ::@expr1073745412 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var228 =@expr1073745414 ValueKind ::@expr1073745415 Possible@expr1073745413 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var228 ==@expr1073745417 ValueKind ::@expr1073745418 Possible@expr1073745416 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var228 ==@expr1073745419 ValueKind ::@expr1073745420 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var228 =@expr1073745421 ValueKind ::@expr1073745422 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var229 = true ) {
428: if (@expr1073745423 inconclusive@var229 ) {
429: valueKind@var228 =@expr1073745424 ValueKind ::@expr1073745425 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var228 ==@expr1073745426 ValueKind ::@expr1073745427 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745429 isKnown (@expr1073745430 ) ) {
438: valueKind@var228 =@expr1073745431 ValueKind ::@expr1073745432 Possible@expr1073745428 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745433 condition@var210 &&@expr1073745434 !@expr1073745435 defaultArg@var216 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var230 , const Token * tok2@var231 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var232 , const Settings * settings@var233 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var234 , SymbolDatabase * symboldatabase@var235 , ErrorLogger * errorLogger@var236 , const Settings * settings@var237 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var238 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var239 , const Settings * settings@var240 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var241 ,
459: const Settings * settings@var242 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var243 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var244 , const Token * indexTok@var245 , bool possible@var246 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var247 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var248 , const Settings * settings@var249 = nullptr , int depth@var250 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var251 ;
471: bool addressOf@var252 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var253 ;
473: bool inconclusive@var254 ;
474:
475: LifetimeToken ( ) : token@var251 ( nullptr ) , addressOf@var252 ( false ) , errorPath@var253 ( ) , inconclusive@var254 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var255 , ValueFlow :: Value :: ErrorPath errorPath@var256 )
478: : token@var251 ( token@var255 ) , addressOf@var252 ( false ) , errorPath@var253 ( std :: move ( errorPath@var256 ) ) , inconclusive@var254 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var257 , bool addressOf@var258 , ValueFlow :: Value :: ErrorPath errorPath@var259 )
482: : token@var251 ( token@var257 ) , addressOf@var252 ( addressOf@var258 ) , errorPath@var253 ( std :: move ( errorPath@var259 ) ) , inconclusive@var254 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var260 , bool b@var261 ) {
486: for (@expr1073745436 LifetimeToken &@expr1073745437 x@var262 :@expr1073745438 v@var260 ) {
487: x@var262 .@expr1073745439 addressOf@var263 =@expr1073745440 b@var261 ; }
488: return v@var260 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var264 , bool b@var265 ) {
492: for (@expr1073745441 LifetimeToken &@expr1073745442 x@var266 :@expr1073745443 v@var264 ) {
493: x@var266 .@expr1073745444 inconclusive@var267 =@expr1073745445 b@var265 ; }
494: return v@var264 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var268 , ValueFlow :: Value & true_value@var269 , ValueFlow :: Value & false_value@var270 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var271 ) ;
499: const Token * parseCompareInt ( const Token * tok@var272 , ValueFlow :: Value & true_value@var273 , ValueFlow :: Value & false_value@var274 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var275 , long long val@var276 , const Token * varTok@var277 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var278 , const Token * varTok@var279 , long long val@var280 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var281 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var282 ,
508: ValueFlow :: Value & value@var283 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var284 ,
511: bool escape@var285 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var286 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var287 , const Token * lifetime@var288 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var289 , ValueFlow :: Value :: ErrorPath & errorPath@var290 , bool * addressOf@var291 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var292 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var293 , const Settings * settings@var294 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var295 , const ValueFlow :: Value * val@var296 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var297 , const ValueFlow :: Value * val@var298 , ValueFlow :: Value :: ErrorPath & errorPath@var299 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var300 , bool inconclusive@var301 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var302 ,
529: bool inconclusive@var303 = false ,
530: long long path@var304 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var305 , const Scope * defaultScope@var306 = nullptr , bool smallest@var307 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var308 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var309 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var310 ;
69: std :: string mScope@var311 ;
70: std :: string mName@var312 ;
71: std :: string mFullName@var313 ;
72: const Token * mNameToken@var314 ;
73: const Token * mParamEnd@var315 ;
74: unsigned int mFlags@var316 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var317 ) {
90: setFlag (@expr1073745446 fIsClass , state@var317 ) ;
91: }
92: void isFunction ( bool state@var318 ) {
93: setFlag (@expr1073745447 fIsFunction , state@var318 ) ;
94: }
95: void isVariable ( bool state@var319 ) {
96: setFlag (@expr1073745448 fIsVariable , state@var319 ) ;
97: }
98: void isAlias ( bool state@var320 ) {
99: setFlag (@expr1073745449 fIsAlias , state@var320 ) ;
100: }
101: void isSpecialization ( bool state@var321 ) {
102: setFlag (@expr1073745450 fIsSpecialization , state@var321 ) ;
103: }
104: void isPartialSpecialization ( bool state@var322 ) {
105: setFlag (@expr1073745451 fIsPartialSpecialization , state@var322 ) ;
106: }
107: void isForwardDeclaration ( bool state@var323 ) {
108: setFlag (@expr1073745452 fIsForwardDeclaration , state@var323 ) ;
109: }
110: void isVariadic ( bool state@var324 ) {
111: setFlag (@expr1073745453 fIsVariadic , state@var324 ) ;
112: }
113: void isFriend ( bool state@var325 ) {
114: setFlag (@expr1073745454 fIsFriend , state@var325 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var326 ) const {
123: return (@expr3631 (@expr3631 mFlags@var316 &@expr1073745457 flag@var326 ) !=@expr1073745458 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var327 , bool state@var328 ) {
132: mFlags@var316 =@expr1073745459 state@var328 ?@expr1073745460 mFlags@var316 |@expr1073745461 flag@var327 :@expr1073745462 mFlags@var316 &@expr1073745463 ~@expr1073745464 flag@var327 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var329 , const std :: string & scope@var330 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var331 , const std :: string & scope@var332 , const Token * nameToken@var333 , const Token * paramEnd@var334 ) ;
150: TokenAndName ( const TokenAndName & other@var335 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var336 ) const {
154: return mToken@var310 ==@expr1073745465 rhs@var336 .@expr1073745466 mToken@var337 &&@expr1073745467 mScope@var311 ==@expr1073745468 rhs@var336 .@expr1073745469 mScope@var338 &&@expr1073745470 mName@var312 ==@expr1073745471 rhs@var336 .@expr1073745472 mName@var339 &&@expr1073745473 mFullName@var313 ==@expr1073745474 rhs@var336 .@expr1073745475 mFullName@var340 &&@expr1073745476
155: mNameToken@var314 ==@expr1073745477 rhs@var336 .@expr1073745478 mNameToken@var341 &&@expr1073745479 mParamEnd@var315 ==@expr1073745480 rhs@var336 .@expr1073745481 mParamEnd@var342 &&@expr1073745482 mFlags@var316 ==@expr1073745483 rhs@var336 .@expr1073745484 mFlags@var343 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var310 ;
160: }
161: void token ( Token * token@var344 ) {
162: mToken@var310 =@expr1073745485 token@var344 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var311 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var312 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var313 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var314 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var315 ;
178: }
179: void paramEnd ( const Token * end@var345 ) {
180: mParamEnd@var315 =@expr1073745486 end@var345 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745487 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745488 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745489 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745490 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745491 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745492 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745493 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745494 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745495 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var346 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var347 ) const {
243:
244:
245: return (@expr3672 (@expr3672 mFlags@var316 &@expr1073745498 fFamilyMask ) &@expr1073745499 (@expr3672 decl@var347 .@expr1073745501 mFlags@var348 &@expr1073745502 fFamilyMask ) ) !=@expr1073745503 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var349 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var350 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var351 , const unsigned long numberOfArguments@var352 , bool variadic@var353 , const char patternAfter@var354 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var355 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var356 , int & namepos@var357 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var358 , int & namepos@var359 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var360 , int & namepos@var361 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var362 ,
306: bool & codeWithTemplates@var363 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var364 , bool isTemplate@var365 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var366 = nullptr , Token * backToken@var367 = nullptr , bool isTemplate@var368 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var369 , Token * end@var370 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var371 , const std :: string & scope@var372 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var373 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var374 ,
393: const std :: list < const Token * > & specializations@var375 ,
394: const std :: time_t maxtime@var376 ,
395: std :: set < std :: string > & expandedtemplates@var377 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var378 , const Token * tok@var379 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var380 , const Token * tok@var381 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var382 ,
422: const TokenAndName & templateInstantiation@var383 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var384 ,
424: const std :: string & newName@var385 ,
425: bool copy@var386 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var387 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var388 ,
435: const std :: string & newName@var389 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var390 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var391 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var392 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var393 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var394 ,
458: const Token * templateInstantiationNameToken@var395 ,
459: const std :: list < const Token * > & specializations@var396 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var397 , const Token * end@var398 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var399 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var400 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var401 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var402 ,
487: const std :: string & indent@var403 = "    " ) const ;
488: void printOut ( const std :: string & text@var404 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var405 ;
491: TokenList & mTokenList@var406 ;
492: const Settings * mSettings@var407 ;
493: ErrorLogger * mErrorLogger@var408 ;
494: bool mChanged@var409 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var410 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var411 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var412 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var413 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var414 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var415 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var416 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var417 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var418 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var419 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var420 ;
507: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var421 ) const {
35: return p@var421 .@expr1073745504 first@var422 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var423 ) const {
42: return p@var423 .@expr1073745505 second@var424 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var425 , const T & x@var426 )
48: {
49: return std ::@expr1073745506 find (@expr1073745507 r@var425 .@expr1073745508 begin (@expr1073745509 ) , r@var425 .@expr3686 end (@expr3687 ) , x@var426 ) !=@expr1073745512 r@var425 .@expr3686 end (@expr3687 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var427 , const T & x@var428 )
54: {
55: return std ::@expr1073745515 find (@expr1073745516 r@var427 .@expr1073745517 begin (@expr1073745518 ) , r@var427 .@expr3695 end (@expr3696 ) , x@var428 ) !=@expr1073745521 r@var427 .@expr3695 end (@expr3696 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var429 , const U & x@var430 )
60: {
61: return std ::@expr1073745524 find (@expr1073745525 r@var429 .@expr1073745526 begin (@expr1073745527 ) , r@var429 .@expr3704 end (@expr3705 ) , x@var430 ) !=@expr1073745530 r@var429 .@expr3704 end (@expr3705 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var431 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745533 t@var431 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var432 , char c@var433 )
74: {
75: return !@expr1073745534 str@var432 .@expr1073745535 empty (@expr1073745536 ) &&@expr1073745537 str@var432 .@expr1073745538 back (@expr1073745539 ) ==@expr1073745540 c@var433 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var434 , const char end@var435 [ ] , unsigned long endlen@var436 )
79: {
80: return (@expr3717 str@var434 .@expr3718 size (@expr3719 ) >=@expr1073745544 endlen@var436 ) &&@expr1073745545 (@expr3717 str@var434 .@expr1073745547 compare (@expr1073745548 str@var434 .@expr3718 size (@expr3719 ) -@expr1073745551 endlen@var436 , endlen@var436 , end@var435 ) ==@expr1073745552 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var437 , const char ( & end@var438 ) [ N ] )
85: {
86: return endsWith (@expr1073745554 str@var437 , end@var438 , N@expr1073745553 -@expr1073745555 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var439 , char q@var440 , const std :: string & p@var441 )
90: {
91: if (@expr1073745556 !@expr1073745557 endsWith (@expr1073745558 str@var439 , q@var440 ) ) {
92: return false ; }
93: if (@expr1073745559 (@expr1073745560 str@var439 .@expr1073745561 length (@expr1073745562 ) +@expr1073745563 1 ) >@expr1073745564 p@var441 .@expr1073745565 length (@expr1073745566 ) &&@expr1073745567 (@expr1073745568 str@var439 .@expr1073745569 compare (@expr1073745570 0 , p@var441 .@expr1073745571 size (@expr1073745572 ) +@expr1073745573 1 , p@var441 +@expr1073745574 q@var440 ) ==@expr1073745575 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var442 , char q@var443 )
99: {
100: static const std ::@expr3752 vector < std ::@expr3752 string > suffixes@var444 {@expr1073745578 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745579 const std ::@expr3752 string &@expr1073745581 p@var445 :@expr1073745582 suffixes@var444 ) {
102: if (@expr1073745583 isPrefixStringCharLiteral (@expr1073745584 str@var442 , q@var443 , p@var445 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var446 )
109: {
110: return isStringCharLiteral (@expr1073745585 str@var446 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var447 )
114: {
115: return isStringCharLiteral (@expr1073745586 str@var447 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var448 , char q@var449 )
119: {
120: const unsigned long quotePos@var450 =@expr1073745587 str@var448 .@expr1073745588 find (@expr1073745589 q@var449 ) ;
121: return str@var448 .@expr1073745590 substr (@expr1073745591 quotePos@var450 +@expr1073745592 1U , str@var448 .@expr1073745593 size (@expr1073745594 ) -@expr1073745595 quotePos@var450 -@expr1073745596 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var451 )
125: {
126: if (@expr1073745597 isStringLiteral (@expr1073745598 str@var451 ) ) {
127: return getStringCharLiteral (@expr1073745599 str@var451 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var452 )
132: {
133: if (@expr1073745600 isCharLiteral (@expr1073745601 str@var452 ) ) {
134: return getStringCharLiteral (@expr1073745602 str@var452 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var453 )
139: {
140: if (@expr1073745603 i@var453 ==@expr1073745604 1 ) {
141: return "st" ; }
142: if (@expr1073745605 i@var453 ==@expr1073745606 2 ) {
143: return "nd" ; }
144: if (@expr1073745607 i@var453 ==@expr1073745608 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var454 , const std :: string & rhs@var455 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var456 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var457 , const std :: string & name@var458 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var459 , const std :: string & name@var460 ) ;
156:
157: void strTolower ( std :: string & str@var461 ) ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var462 ;
57: Token * back@var463 ;
58: const TokenList * list@var464 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var465 , const Token * bodyEnd_@var466 , const std :: set < std :: string > & usingNamespaces_@var467 = std :: set < std :: string > ( ) ) : name@var468 ( name_@var465 ) , bodyEnd@var469 ( bodyEnd_@var466 ) , usingNamespaces@var470 ( usingNamespaces_@var467 ) { }
63: std :: string name@var468 ;
64: const Token * const bodyEnd@var469 ;
65: std :: set < std :: string > usingNamespaces@var470 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var471 ;
70: int mFileIndex@var472 ;
71: int mLineNumber@var473 ;
72: int mColumn@var474 ;
73: int mExprId@var475 ;
74:
75:
76: Token * mAstOperand1@var476 ;
77: Token * mAstOperand2@var477 ;
78: Token * mAstParent@var478 ;
79:
80:
81: const Scope * mScope@var479 ;
82: union {
83: const Function * mFunction@var480 ;
84: const Variable * mVariable@var481 ;
85: const :: Type * mType@var482 ;
86: const Enumerator * mEnumerator@var483 ;
87: } ;
88:
|
92:
93: int mProgressValue@var484 ;
94:
|
97:
98: int mIndex@var485 ;
99:
100:
101: std :: string * mOriginalName@var486 ;
102:
103:
104: ValueType * mValueType@var487 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var488 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var489 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var490 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var491 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var492 ;
119: long long value@var493 ;
120: struct CppcheckAttributes * next@var494 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var495 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var496 ;
126:
127:
128: unsigned char mBits@var497 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var498 , long long value@var499 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var500 , long long * value@var501 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var471 ( 0 )
135: , mFileIndex@var472 ( 0 )
136: , mLineNumber@var473 ( 0 )
137: , mColumn@var474 ( 0 )
138: , mExprId@var475 ( 0 )
139: , mAstOperand1@var476 ( nullptr )
140: , mAstOperand2@var477 ( nullptr )
141: , mAstParent@var478 ( nullptr )
142: , mScope@var479 ( nullptr )
143: , mFunction@var480 ( nullptr )
144: , mProgressValue@var484 ( 0 )
145: , mIndex@var485 ( 0 )
146: , mOriginalName@var486 ( nullptr )
147: , mValueType@var487 ( nullptr )
148: , mValues@var488 ( nullptr )
149: , mTemplateSimplifierPointers@var490 ( nullptr )
150: , mScopeInfo@var491 ( nullptr )
151: , mCppcheckAttributes@var495 ( nullptr )
152: , mCpp11init@var496 ( Cpp11init :: UNKNOWN )
153: , mBits@var497 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var502 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var503 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var504 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var505 ) {
199: mStr@var717 =@expr1073745609 s@var505 ;
200: mImpl@var723 .@expr1073745610 mVarId@var754 =@expr1073745611 0 ;
201:
202: update_property_info (@expr1073745612 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var506 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var717 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var507 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var508 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var509 ) const ;
236: Token * tokAt ( int index@var510 ) {
237: return const_cast < Token *@expr3789 > (@expr1073745614 const_cast < const Token *@expr3789 > (@expr1073745616 this@expr1073745617 ) .@expr1073745618 tokAt (@expr1073745619 index@var510 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var511 ) const ;
245: Token * linkAt ( int index@var512 ) {
246: return const_cast < Token *@expr3796 > (@expr1073745621 const_cast < const Token *@expr3796 > (@expr1073745623 this@expr1073745624 ) .@expr1073745625 linkAt (@expr1073745626 index@var512 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var513 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var514 , const char ( & pattern@var515 ) [ count ] ) {
276: return simpleMatch (@expr1073745628 tok@var514 , pattern@var515 , count@expr1073745627 -@expr1073745629 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var516 , const char pattern@var517 [ ] , unsigned long pattern_len@var518 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var519 , const char pattern@var520 [ ] , int varid@var521 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var522 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var523 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var524 , const Settings * const settings@var525 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var526 , long long index@var527 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var723 .@expr1073745630 mValueType@var755 ;
366: }
367: void setValueType ( ValueType * vt@var528 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var529 ; top@var529 =@expr1073745631 this@expr1073745632 ;
371: while (@expr1073745633 top@var529 &&@expr1073745634 !@expr1073745635 Token ::@expr1073745636 Match (@expr1073745637 top@var529 .@expr3814 astParent (@expr3815 ) , ",|(" ) ) {
372: top@var529 =@expr1073745640 top@var529 .@expr3814 astParent (@expr3815 ) ; }
373: return top@var529 ?@expr1073745643 top@var529 .@expr1073745644 mImpl@var530 .@expr1073745645 mValueType@var531 :@expr1073745646 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var721 ;
378: }
379: void tokType ( Token :: Type t@var532 ) {
380: mTokType@var721 =@expr1073745647 t@var532 ;
381:
382: const bool memoizedIsName@var533 =@expr1073745648 mTokType@var721 ==@expr1073745649 eName ||@expr1073745650 mTokType@var721 ==@expr1073745651 eType ||@expr1073745652 mTokType@var721 ==@expr1073745653 eVariable ||@expr1073745654
383: mTokType@var721 ==@expr1073745655 eFunction ||@expr1073745656 mTokType@var721 ==@expr1073745657 eKeyword ||@expr1073745658 mTokType@var721 ==@expr3835 eBoolean ||@expr1073745660
384: mTokType@var721 ==@expr3837 eEnumerator ;
385: setFlag (@expr1073745662 fIsName , memoizedIsName@var533 ) ;
386:
387: const bool memoizedIsLiteral@var534 =@expr1073745663 mTokType@var721 ==@expr1073745664 eNumber ||@expr1073745665 mTokType@var721 ==@expr1073745666 eString ||@expr1073745667 mTokType@var721 ==@expr1073745668 eChar ||@expr1073745669
388: mTokType@var721 ==@expr3835 eBoolean ||@expr1073745671 mTokType@var721 ==@expr1073745672 eLiteral ||@expr1073745673 mTokType@var721 ==@expr3837 eEnumerator ;
389: setFlag (@expr1073745675 fIsLiteral , memoizedIsLiteral@var534 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var721 ==@expr1073745676 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745677 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var722 ==@expr1073745678 fIsName &&@expr1073745679 mTokType@var721 ==@expr1073745680 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745681 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var721 ==@expr1073745682 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var721 ==@expr1073745683 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745684 isConstOp (@expr1073745685 ) ||@expr1073745686
412: isAssignmentOp (@expr1073745687 ) ||@expr1073745688
413: mTokType@var721 ==@expr1073745689 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745690 isArithmeticalOp (@expr1073745691 ) ||@expr1073745692
417: mTokType@var721 ==@expr1073745693 eLogicalOp ||@expr1073745694
418: mTokType@var721 ==@expr1073745695 eComparisonOp ||@expr1073745696
419: mTokType@var721 ==@expr1073745697 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745698 ) ||@expr1073745699
423: mTokType@var721 ==@expr1073745700 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var721 ==@expr1073745701 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var721 ==@expr1073745702 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var721 ==@expr1073745703 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var721 ==@expr1073745704 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var721 ==@expr1073745705 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745706 ) !=@expr1073745707 nullptr &&@expr1073745708 astOperand2 (@expr1073745709 ) !=@expr1073745710 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var535 ) const {
444: return s@var535 ==@expr1073745711 mStr@var717 &&@expr1073745712 astOperand1 (@expr1073745713 ) !=@expr1073745714 nullptr &&@expr1073745715 astOperand2 (@expr1073745716 ) ==@expr1073745717 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var722 ;
450: }
451: void flags ( const unsigned int flags_@var536 ) {
452: mFlags@var722 =@expr1073745718 flags_@var536 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745719 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var537 ) {
458: setFlag (@expr1073745720 fIsUnsigned , sign@var537 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745721 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var538 ) {
464: setFlag (@expr1073745722 fIsSigned , sign@var538 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745723 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var539 ) {
470: setFlag (@expr1073745724 fIsPointerCompare , b@var539 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745725 fIsLong ) ;
474: }
475: void isLong ( bool size@var540 ) {
476: setFlag (@expr1073745726 fIsLong , size@var540 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745727 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var541 ) {
482: setFlag (@expr1073745728 fIsStandardType , b@var541 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745729 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var542 ) {
488: setFlag (@expr1073745730 fIsExpandedMacro , m@var542 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745731 fIsCast ) ;
492: }
493: void isCast ( bool c@var543 ) {
494: setFlag (@expr1073745732 fIsCast , c@var543 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745733 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var544 ) {
500: setFlag (@expr1073745734 fIsAttributeConstructor , ac@var544 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745735 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var545 ) {
506: setFlag (@expr1073745736 fIsAttributeDestructor , value@var545 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745737 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var546 ) {
512: setFlag (@expr1073745738 fIsAttributeUnused , unused@var546 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745739 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var547 ) {
518: setFlag (@expr1073745740 fIsAttributeUsed , unused@var547 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745741 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var548 ) {
524: setFlag (@expr1073745742 fIsAttributePure , value@var548 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745743 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var549 ) {
530: setFlag (@expr1073745744 fIsAttributeConst , value@var549 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745745 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var550 ) {
536: setFlag (@expr1073745746 fIsAttributeNoreturn , value@var550 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745747 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var551 ) {
542: setFlag (@expr1073745748 fIsAttributeNothrow , value@var551 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745749 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var552 ) {
548: setFlag (@expr1073745750 fIsAttributePacked , value@var552 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745751 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var553 ) {
554: setFlag (@expr1073745752 fIsAttributeNodiscard , value@var553 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745753 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var554 ) {
560: setFlag (@expr1073745754 fIsAttributeMaybeUnused , value@var554 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var555 , long long value@var556 ) {
563: mImpl@var723 .@expr1073745755 setCppcheckAttribute (@expr1073745756 type@var555 , value@var556 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var557 , long long * value@var558 ) const {
566: return mImpl@var723 .@expr1073745757 getCppcheckAttribute (@expr1073745758 type@var557 , value@var558 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745759 mImpl@var723 .@expr1073745760 mCppcheckAttributes@var756 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745761 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745762 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var559 ) {
578: setFlag (@expr1073745763 fIsOperatorKeyword , value@var559 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745764 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var560 ) {
584: setFlag (@expr1073745765 fIsComplex , value@var560 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745766 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var561 ) {
590: setFlag (@expr1073745767 fIsEnumType , value@var561 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745768 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var562 ) {
596: setFlag (@expr1073745769 fAtAddress , b@var562 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745770 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var563 ) {
602: setFlag (@expr1073745771 fIncompleteVar , b@var563 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745772 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var564 ) {
609: setFlag (@expr1073745773 fIsIncompleteConstant , b@var564 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745774 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var565 ) {
616: setFlag (@expr1073745775 fConstexpr , b@var565 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745776 fExternC ) ;
621: }
622: void isExternC ( bool b@var566 ) {
623: setFlag (@expr1073745777 fExternC , b@var566 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745778 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var567 ) {
630: setFlag (@expr1073745779 fIsSplitVarDeclComma , b@var567 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745780 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var568 ) {
637: setFlag (@expr1073745781 fIsSplitVarDeclEq , b@var568 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745782 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var569 ) {
644: setFlag (@expr1073745783 fIsImplicitInt , b@var569 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745784 fIsInline ) ;
649: }
650: void isInline ( bool b@var570 ) {
651: setFlag (@expr1073745785 fIsInline , b@var570 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745786 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var571 ) {
658: setFlag (@expr1073745787 fIsRemovedVoidParameter , b@var571 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745788 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var572 ) {
665: setFlag (@expr1073745789 fIsTemplate , b@var572 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745790 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var573 ) {
672: setFlag (@expr1073745791 fIsSimplifedScope , b@var573 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var723 .@expr1073745792 mBits@var757 >@expr1073745793 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var723 .@expr1073745794 mBits@var757 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var723 .@expr1073745795 mTemplateSimplifierPointers@var758 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var574 ) {
685: if (@expr1073745796 !@expr1073745797 mImpl@var723 .@expr3974 mTemplateSimplifierPointers@var758 ) {
686: mImpl@var723 .@expr3974 mTemplateSimplifierPointers@var758 =@expr1073745800 new std ::@expr1073745801 set < TemplateSimplifier ::@expr1073745802 TokenAndName *@expr1073745803 > ; }
687: mImpl@var723 .@expr3974 mTemplateSimplifierPointers@var758 .@expr1073745805 insert (@expr1073745806 tokenAndName@var574 ) ;
688: }
689: void setBits ( const unsigned char b@var575 ) {
690: mImpl@var723 .@expr1073745807 mBits@var757 =@expr1073745808 b@var575 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3985 (@expr3985 (@expr3985 mTokType@var721 ==@expr1073745812 eString ) &&@expr1073745813 isPrefixStringCharLiteral (@expr1073745814 mStr@var717 , '"' , "u8" ) ) ||@expr1073745815
695: (@expr3985 (@expr3985 mTokType@var721 ==@expr1073745818 eChar ) &&@expr1073745819 isPrefixStringCharLiteral (@expr1073745820 mStr@var717 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3997 (@expr3997 (@expr3997 mTokType@var721 ==@expr1073745824 eString ) &&@expr1073745825 isPrefixStringCharLiteral (@expr1073745826 mStr@var717 , '"' , "u" ) ) ||@expr1073745827
700: (@expr3997 (@expr3997 mTokType@var721 ==@expr1073745830 eChar ) &&@expr1073745831 isPrefixStringCharLiteral (@expr1073745832 mStr@var717 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4009 (@expr4009 (@expr4009 mTokType@var721 ==@expr1073745836 eString ) &&@expr1073745837 isPrefixStringCharLiteral (@expr1073745838 mStr@var717 , '"' , "U" ) ) ||@expr1073745839
705: (@expr4009 (@expr4009 mTokType@var721 ==@expr1073745842 eChar ) &&@expr1073745843 isPrefixStringCharLiteral (@expr1073745844 mStr@var717 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4021 (@expr4021 (@expr4021 mTokType@var721 ==@expr1073745848 eString ) &&@expr1073745849 isPrefixStringCharLiteral (@expr1073745850 mStr@var717 , '"' , "" ) ) ||@expr1073745851
710: (@expr4021 (@expr4021 mTokType@var721 ==@expr1073745854 eChar ) &&@expr1073745855 isPrefixStringCharLiteral (@expr1073745856 mStr@var717 , '\'' , "" ) &&@expr1073745857 mStr@var717 .@expr1073745858 length (@expr1073745859 ) ==@expr1073745860 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4037 (@expr4037 (@expr4037 mTokType@var721 ==@expr1073745864 eChar ) &&@expr1073745865 isPrefixStringCharLiteral (@expr1073745866 mStr@var717 , '\'' , "" ) ) &&@expr1073745867
715: (@expr4037 mStr@var717 .@expr1073745869 length (@expr1073745870 ) >@expr1073745871 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745872 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var576 ) {
738: setFlag (@expr1073745873 fIsTemplateArg , value@var576 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var577 , const char ( & pattern@var578 ) [ count ] ) {
743: return findsimplematch (@expr1073745875 startTok@var577 , pattern@var578 , count@expr1073745874 -@expr1073745876 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var579 , const char pattern@var580 [ ] , unsigned long pattern_len@var581 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var582 , const char ( & pattern@var583 ) [ count ] , const Token * const end@var584 ) {
749: return findsimplematch (@expr1073745878 startTok@var582 , pattern@var583 , count@expr1073745877 -@expr1073745879 1 , end@var584 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var585 , const char pattern@var586 [ ] , unsigned long pattern_len@var587 , const Token * const end@var588 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var589 , const char pattern@var590 [ ] , const int varId@var591 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var592 , const char pattern@var593 [ ] , const Token * const end@var594 , const int varId@var595 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var596 , const char ( & pattern@var597 ) [ count ] ) {
758: return findsimplematch (@expr1073745881 startTok@var596 , pattern@var597 , count@expr1073745880 -@expr1073745882 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var598 , const char pattern@var599 [ ] , unsigned long pattern_len@var600 ) {
761: return const_cast < Token *@expr4059 > (@expr1073745884 findsimplematch (@expr1073745885 const_cast < const Token *@expr4059 > (@expr1073745887 startTok@var598 ) , pattern@var599 , pattern_len@var600 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var601 , const char ( & pattern@var602 ) [ count ] , const Token * const end@var603 ) {
765: return findsimplematch (@expr1073745889 startTok@var601 , pattern@var602 , count@expr1073745888 -@expr1073745890 1 , end@var603 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var604 , const char pattern@var605 [ ] , unsigned long pattern_len@var606 , const Token * const end@var607 ) {
768: return const_cast < Token *@expr4067 > (@expr1073745892 findsimplematch (@expr1073745893 const_cast < const Token *@expr4067 > (@expr1073745895 startTok@var604 ) , pattern@var605 , pattern_len@var606 , end@var607 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var608 , const char pattern@var609 [ ] , const int varId@var610 = 0 ) {
772: return const_cast < Token *@expr4072 > (@expr1073745897 findmatch (@expr1073745898 const_cast < const Token *@expr4072 > (@expr1073745900 startTok@var608 ) , pattern@var609 , varId@var610 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var611 , const char pattern@var612 [ ] , const Token * const end@var613 , const int varId@var614 = 0 ) {
775: return const_cast < Token *@expr4077 > (@expr1073745902 findmatch (@expr1073745903 const_cast < const Token *@expr4077 > (@expr1073745905 startTok@var611 ) , pattern@var612 , end@var613 , varId@var614 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var615 , const char * haystack@var616 , int varid@var617 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var723 .@expr1073745906 mFileIndex@var759 ;
796: }
797: void fileIndex ( int indexOfFile@var618 ) {
798: mImpl@var723 .@expr1073745907 mFileIndex@var759 =@expr1073745908 indexOfFile@var618 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var723 .@expr1073745909 mLineNumber@var760 ;
803: }
804: void linenr ( int lineNumber@var619 ) {
805: mImpl@var723 .@expr1073745910 mLineNumber@var760 =@expr1073745911 lineNumber@var619 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var723 .@expr1073745912 mColumn@var761 ;
810: }
811: void column ( int c@var620 ) {
812: mImpl@var723 .@expr1073745913 mColumn@var761 =@expr1073745914 c@var620 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var718 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var621 , const Token * end@var622 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var623 , const std :: string & originalNameStr@var624 = emptyString@var1 , bool prepend@var625 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var626 , const std :: string & originalNameStr@var627 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745915 tokenStr@var626 , originalNameStr@var627 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var719 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var723 .@expr1073745916 mVarId@var754 ;
851: }
852: void varId ( int id@var628 ) {
853: mImpl@var723 .@expr1073745917 mVarId@var754 =@expr1073745918 id@var628 ;
854: if (@expr1073745919 id@var628 !=@expr1073745920 0 ) {
855: tokType (@expr1073745921 eVariable ) ;
856: isStandardType (@expr1073745922 false ) ;
857: } else {
858: update_property_info (@expr1073745923 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745924 mImpl@var723 .@expr4101 mExprId@var762 ) {
864: return mImpl@var723 .@expr4101 mExprId@var762 ; }
865: return mImpl@var723 .@expr1073745927 mVarId@var754 ;
866: }
867: void exprId ( int id@var629 ) {
868: mImpl@var723 .@expr1073745928 mExprId@var762 =@expr1073745929 id@var629 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var630 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var631 , const std :: vector < std :: string > & fileNames@var632 ) const ;
888:
|
891:
892: void printLines ( int lines@var633 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var634 , Token * start@var635 , Token * end@var636 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var637 ; varid@var637 = false ;
905: bool exprid@var638 ; exprid@var638 = false ;
906: bool idtype@var639 ; idtype@var639 = false ;
907: bool attributes@var640 ; attributes@var640 = false ;
908: bool macro@var641 ; macro@var641 = false ;
909: bool linenumbers@var642 ; linenumbers@var642 = false ;
910: bool linebreaks@var643 ; linebreaks@var643 = false ;
911: bool files@var644 ; files@var644 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var645 ;
914: options@var645 .@expr1073745930 attributes@var646 =@expr1073745931 true ;
915: options@var645 .@expr1073745932 macro@var647 =@expr1073745933 true ;
916: options@var645 .@expr1073745934 linenumbers@var648 =@expr1073745935 true ;
917: options@var645 .@expr1073745936 linebreaks@var649 =@expr1073745937 true ;
918: options@var645 .@expr1073745938 files@var650 =@expr1073745939 true ;
919: return options@var645 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var651 ; options@var651 =@expr1073745940 forDebug (@expr1073745941 ) ;
923: options@var651 .@expr1073745942 varid@var652 =@expr1073745943 true ;
924: return options@var651 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var653 ; options@var653 =@expr1073745944 forDebug (@expr1073745945 ) ;
928: options@var653 .@expr1073745946 exprid@var654 =@expr1073745947 true ;
929: return options@var653 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var655 ; options@var655 =@expr1073745948 forDebug (@expr1073745949 ) ;
933: options@var655 .@expr1073745950 exprid@var656 =@expr1073745951 true ;
934: options@var655 .@expr1073745952 varid@var657 =@expr1073745953 true ;
935: options@var655 .@expr1073745954 idtype@var658 =@expr1073745955 true ;
936: return options@var655 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var659 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var660 , bool attributes@var661 , bool macro@var662 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var663 , const std :: vector < std :: string > * fileNames@var664 = nullptr , const Token * end@var665 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var666 , bool attributes@var667 = true ) const ;
952: std :: string stringifyList ( bool varid@var668 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var669 , bool attributes@var670 , bool linenumbers@var671 , bool linebreaks@var672 , bool files@var673 , const std :: vector < std :: string > * fileNames@var674 = nullptr , const Token * end@var675 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var676 ) {
983: mLink@var720 =@expr1073745956 linkToToken@var676 ;
984: if (@expr1073745957 mStr@var717 ==@expr1073745958 "<" ||@expr1073745959 mStr@var717 ==@expr1073745960 ">" ) {
985: update_property_info (@expr1073745961 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var720 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var677 ) {
1006: mImpl@var723 .@expr1073745962 mScope@var763 =@expr1073745963 s@var677 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var723 .@expr1073745964 mScope@var763 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var678 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var721 ==@expr1073745965 eFunction ||@expr1073745966 mTokType@var721 ==@expr1073745967 eLambda ?@expr1073745968 mImpl@var723 .@expr1073745969 mFunction@var764 :@expr1073745970 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var679 ) {
1034: mImpl@var723 .@expr1073745971 mVariable@var765 =@expr1073745972 v@var679 ;
1035: if (@expr1073745973 v@var679 ||@expr1073745974 mImpl@var723 .@expr1073745975 mVarId@var754 ) {
1036: tokType (@expr1073745976 eVariable ) ; }
1037: else { if (@expr1073745977 mTokType@var721 ==@expr1073745978 eVariable ) {
1038: tokType (@expr1073745979 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var721 ==@expr1073745980 eVariable ?@expr1073745981 mImpl@var723 .@expr1073745982 mVariable@var765 :@expr1073745983 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var680 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var721 ==@expr1073745984 eType ?@expr1073745985 mImpl@var723 .@expr1073745986 mType@var766 :@expr1073745987 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var681 , const Token * * typeTok@var682 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var683 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var684 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var721 ==@expr1073745988 eEnumerator ?@expr1073745989 mImpl@var723 .@expr1073745990 mEnumerator@var767 :@expr1073745991 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var685 ) {
1079: mImpl@var723 .@expr1073745992 mEnumerator@var767 =@expr1073745993 e@var685 ;
1080: if (@expr1073745994 e@var685 ) {
1081: tokType (@expr1073745995 eEnumerator ) ; }
1082: else { if (@expr1073745996 mTokType@var721 ==@expr1073745997 eEnumerator ) {
1083: tokType (@expr1073745998 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var686 , Token * end@var687 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var688 , Token * srcEnd@var689 , Token * newLocation@var690 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var723 .@expr1073745999 mProgressValue@var768 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var691 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var723 .@expr4176 mOriginalName@var769 ?@expr1073746001 *@expr1073746002 mImpl@var723 .@expr4176 mOriginalName@var769 :@expr1073746004 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var723 .@expr4181 mValues@var742 ?@expr1073746006 *@expr1073746007 mImpl@var723 .@expr4181 mValues@var742 :@expr1073746009 TokenImpl ::@expr1073746010 mEmptyValueList@var489 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var692 ) {
1164: if (@expr1073746011 !@expr1073746012 mImpl@var723 .@expr4189 mOriginalName@var769 ) {
1165: mImpl@var723 .@expr4189 mOriginalName@var769 =@expr1073746015 new std ::@expr1073746016 string (@expr1073746017 name@var692 ) ; }
1166: else {
1167: *@expr1073746018 mImpl@var723 .@expr4189 mOriginalName@var769 =@expr1073746020 name@var692 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var693 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var694 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var695 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var723 .@expr1073746022 mValues@var742 .@expr1073746023 front (@expr1073746024 ) .@expr1073746025 intvalue@expr1073746021 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var696 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var697 , long long path@var698 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var699 , const Settings * settings@var700 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var701 , const Settings * settings@var702 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var703 , int argnr@var704 , const Settings * settings@var705 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var706 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var707 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var708 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var709 ) {
1200: if (@expr1073746026 mImpl@var723 .@expr4203 mValues@var742 ) {
1201: mImpl@var723 .@expr4203 mValues@var742 .@expr1073746029 remove_if (@expr1073746030 pred@var709 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var723 .@expr1073746031 mIndex@var770 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var710 ) {
1213: mNext@var718 =@expr1073746032 nextToken@var710 ;
1214: }
1215: void previous ( Token * previousToken@var711 ) {
1216: mPrevious@var719 =@expr1073746033 previousToken@var711 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var712 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var713 , const char * word@var714 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var715 , char c@var716 ) ;
1235:
1236: std :: string mStr@var717 ;
1237:
1238: Token * mNext@var718 ;
1239: Token * mPrevious@var719 ;
1240: Token * mLink@var720 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var721 ;
1283:
1284: uint64_t mFlags@var722 ;
1285:
1286: TokenImpl * mImpl@var723 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var724 ) const {
1294: return (@expr4210 (@expr4210 mFlags@var722 &@expr1073746036 flag_@var724 ) !=@expr1073746037 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var725 , bool state_@var726 ) {
1303: mFlags@var722 =@expr1073746038 state_@var726 ?@expr1073746039 mFlags@var722 |@expr1073746040 flag_@var725 :@expr1073746041 mFlags@var722 &@expr1073746042 ~@expr1073746043 flag_@var725 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var727 , const int indent1@var728 = 0 , const int indent2@var729 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var730 ) ;
1321: void astOperand2 ( Token * tok@var731 ) ;
1322: void astParent ( Token * tok@var732 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var723 .@expr1073746044 mAstOperand1@var733 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var723 .@expr1073746045 mAstOperand1@var733 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var723 .@expr1073746046 mAstOperand2@var734 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var723 .@expr1073746047 mAstOperand2@var734 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var723 .@expr1073746048 mAstParent@var735 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var723 .@expr1073746049 mAstParent@var735 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746050 !@expr1073746051 astParent (@expr4228 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746053 this@expr4230 ==@expr1073746055 astParent (@expr4228 ) .@expr4233 astOperand1 (@expr4234 ) ) {
1346: return astParent (@expr4228 ) .@expr4236 astOperand2 (@expr4237 ) ; }
1347: else { if (@expr1073746062 this@expr4230 ==@expr1073746063 astParent (@expr4228 ) .@expr4236 astOperand2 (@expr4237 ) ) {
1348: return astParent (@expr4228 ) .@expr4233 astOperand1 (@expr4234 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746070 !@expr1073746071 astParent (@expr4248 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746073 this@expr4250 ==@expr1073746075 astParent (@expr4248 ) .@expr4253 astOperand1 (@expr4254 ) ) {
1356: return astParent (@expr4248 ) .@expr4256 astOperand2 (@expr4257 ) ; }
1357: else { if (@expr1073746082 this@expr4250 ==@expr1073746083 astParent (@expr4248 ) .@expr4256 astOperand2 (@expr4257 ) ) {
1358: return astParent (@expr4248 ) .@expr4253 astOperand1 (@expr4254 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var736 ; ret@var736 =@expr1073746090 this@expr1073746091 ;
1364: while (@expr1073746092 ret@var736 .@expr4269 mImpl@var737 .@expr4270 mAstParent@var738 ) {
1365: ret@var736 =@expr1073746095 ret@var736 .@expr4269 mImpl@var737 .@expr4270 mAstParent@var738 ; }
1366: return ret@var736 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var739 ; ret@var739 =@expr1073746098 this@expr1073746099 ;
1371: while (@expr1073746100 ret@var739 .@expr4277 mImpl@var740 .@expr4278 mAstParent@var741 ) {
1372: ret@var739 =@expr1073746103 ret@var739 .@expr4277 mImpl@var740 .@expr4278 mAstParent@var741 ; }
1373: return ret@var739 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var723 .@expr1073746106 mAstOperand1@var733 =@expr1073746107 mImpl@var723 .@expr1073746108 mAstOperand2@var734 =@expr1073746109 mImpl@var723 .@expr1073746110 mAstParent@var735 =@expr1073746111 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var723 .@expr4288 mValues@var742 ;
1393: mImpl@var723 .@expr4288 mValues@var742 =@expr1073746114 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var743 = "" ) const {
1397: std ::@expr1073746115 string ret@var744 ;
1398: if (@expr1073746116 mImpl@var723 .@expr4293 mAstOperand1@var733 ) {
1399: ret@var744 =@expr1073746118 mImpl@var723 .@expr4293 mAstOperand1@var733 .@expr1073746120 astString (@expr1073746121 sep@var743 ) ; }
1400: if (@expr1073746122 mImpl@var723 .@expr4299 mAstOperand2@var734 ) {
1401: ret@var744 +=@expr1073746124 mImpl@var723 .@expr4299 mAstOperand2@var734 .@expr1073746126 astString (@expr1073746127 sep@var743 ) ; }
1402: return ret@var744 +@expr1073746128 sep@var743 +@expr1073746129 mStr@var717 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var745 , bool xml@var746 , const std :: vector < std :: string > & fileNames@var747 , std :: ostream & out@var748 ) const ;
1412:
1413: void printValueFlow ( bool xml@var749 , std :: ostream & out@var750 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var751 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var752 ) const {
1419: mImpl@var723 .@expr1073746130 mCpp11init@var753 =@expr1073746131 cpp11init@var752 ?@expr1073746132 TokenImpl ::@expr4309 Cpp11init ::@expr1073746134 CPP11INIT :@expr1073746135 TokenImpl ::@expr4309 Cpp11init ::@expr1073746137 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var723 .@expr1073746138 mCpp11init@var753 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var771 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var772 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var773 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var774 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var775 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var776 ) {
47: mSettings@var811 =@expr1073746139 settings@var776 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var811 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var813 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var814 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var777 ) ;
72:
73: void addtoken ( const std :: string & str@var778 , const int lineno@var779 , const int column@var780 , const int fileno@var781 , bool split@var782 = false ) ;
74: void addtoken ( const std :: string & str@var783 , const Token * locationTok@var784 ) ;
75:
76: void addtoken ( const Token * tok@var785 , const int lineno@var786 , const int column@var787 , const int fileno@var788 ) ;
77: void addtoken ( const Token * tok@var789 , const Token * locationTok@var790 ) ;
78: void addtoken ( const Token * tok@var791 ) ;
79:
80: static void insertTokens ( Token * dest@var792 , const Token * src@var793 , int n@var794 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var795 , const Token * first@var796 , const Token * last@var797 , bool one_line@var798 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var799 , const std :: string & file0@var800 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var801 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var802 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var808 .@expr1073746140 front@var815 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var808 .@expr1073746141 front@var815 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var808 .@expr1073746142 back@var816 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var808 .@expr1073746143 back@var816 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var809 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var803 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var804 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var805 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var806 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var807 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var808 ;
206:
207:
208: std :: vector < std :: string > mFiles@var809 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var810 ;
212:
213:
214: const Settings * mSettings@var811 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var812 ;
217:
218:
219: bool mIsC@var813 ;
220: bool mIsCpp@var814 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var817 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var818 ;
67: mutable int mVarId@var819 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var820 ) ;
73: bool hasVariable ( const std :: string & varname@var821 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var822 ) const {
75: return mVariableId@var817 .@expr1073746144 find (@expr1073746145 varname@var822 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var817 .@expr1073746146 end (@expr1073746147 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var817 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746148 mVarId@var819 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var823 , ErrorLogger * errorLogger@var824 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var825 ) {
95: mTimerResults@var945 =@expr1073746149 tr@var825 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var923 .@expr1073746150 isC (@expr1073746151 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var923 .@expr1073746152 isCPP (@expr1073746153 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var826 , bool * unknown@var827 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var828 , const std :: string & FileName@var829 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var830 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var831 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var832 ,
142: const char FileName@var833 [ ] ,
143: const std :: string & configuration@var834 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var835 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var836 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var837 , const Token * end@var838 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var839 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var840 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var841 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var842 , const Token * const tokEnd@var843 , const bool only_k_r_fpar@var844 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var845 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var846 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var847 , bool commandWithCondition@var848 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var849 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var850 , Token * * _tok2@var851 , Token * * _tok3@var852 , std :: string & value@var853 , int & valueVarId@var854 , bool & valueIsPointer@var855 , bool floatvar@var856 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var857 , Token * tok3@var858 , int varid@var859 , const std :: string & structname@var860 , std :: string & value@var861 , int valueVarId@var862 , bool valueIsPointer@var863 , const Token * const valueToken@var864 , int indentlevel@var865 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var866 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var867 , const std :: string & endsWith@var868 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var869 , const std :: string & endsWith@var870 , bool cpp@var871 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var872 ) {
585: mPreprocessor@var946 =@expr1073746154 preprocessor@var872 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var946 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var873 , const Token * end@var874 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var875 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var876 , const std :: string & code@var877 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var878 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var879 , const std :: string & what@var880 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var881 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var882 , const std :: string & msg@var883 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var884 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var885 , const std :: string & macroName@var886 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var887 , const Token * end@var888 , bool allowSemicolon@var889 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var890 , const Severity :: SeverityType severity@var891 , const std :: string & id@var892 , const std :: string & msg@var893 , bool inconclusive@var894 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var895 , Severity :: SeverityType severity@var896 , const std :: string & id@var897 , const std :: string & msg@var898 , bool inconclusive@var899 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var900 , const Token * name@var901 , const Token * typeDef@var902 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var903 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var904 ,
821: const VariableMap & variableMap@var905 ,
822: const int scopeStartVarId@var906 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var907 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var908 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var909 ,
827: int * varId@var910 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var911 ,
830: Token * const startToken@var912 ,
831: const Token * const endToken@var913 ,
832: const std :: map < std :: string , int > & varlist@var914 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var915 ,
834: int * varId_@var916 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var917 ) ;
849:
850: bool operatorEnd ( const Token * tok@var918 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var944 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var919 ) {
861: mSettings@var930 =@expr1073746155 settings@var919 ;
862: list@var923 .@expr1073746156 setSettings (@expr1073746157 settings@var919 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var932 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var920 ) const ;
877:
878: void dump ( std :: ostream & out@var921 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var922 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var942 ;
888: }
889:
|
892:
893: TokenList list@var923 ;
894:
895: const Token * tokens ( ) const {
896: return list@var923 .@expr1073746158 front (@expr1073746159 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var924 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var925 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var926 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var927 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var930 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var928 , bool inOperator@var929 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746160 mVarId@var942 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var930 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var931 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var932 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var933 ;
973:
974:
975:
976: std :: string mConfiguration@var934 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var935 ;
980:
981: struct TypedefInfo {
982: std :: string name@var936 ;
983: std :: string filename@var937 ;
984: int lineNumber@var938 ;
985: int column@var939 ;
986: bool used@var940 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var941 ;
989:
990:
991: int mVarId@var942 ;
992:
993:
994: int mUnnamedCount@var943 ;
995:
|
999:
1000: bool mCodeWithTemplates@var944 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var945 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var946 ;
1013: } ;

##file cppcheck-2.8/lib/checkstl.h

1:
|
32:
33: class Scope ;
34: class Settings ;
35: class Token ;
36: class Variable ;
37: class ErrorLogger ;
38:
|
44:
45: class CheckStl : public Check {
46: public:
47:
48: CheckStl ( ) : Check ( myName ( ) ) { }
49:
50:
51: CheckStl ( const Tokenizer * tokenizer@var947 , const Settings * settings@var948 , ErrorLogger * errorLogger@var949 )
52: : Check ( myName ( ) , tokenizer@var947 , settings@var948 , errorLogger@var949 ) { }
53:
54:
55: void runChecks ( const Tokenizer * tokenizer@var950 , const Settings * settings@var951 , ErrorLogger * errorLogger@var952 ) override {
56: if (@expr1073746161 !@expr1073746162 tokenizer@var950 .@expr1073746163 isCPP (@expr1073746164 ) ) {
57: return ;
58: }
59:
60: CheckStl checkStl@var953 (@expr1073746165 tokenizer@var950 , settings@var951 , errorLogger@var952 ) ;
61: checkStl@var953 .@expr1073746166 erase (@expr1073746167 ) ;
62: checkStl@var953 .@expr1073746168 if_find (@expr1073746169 ) ;
63: checkStl@var953 .@expr1073746170 checkFindInsert (@expr1073746171 ) ;
64: checkStl@var953 .@expr1073746172 iterators (@expr1073746173 ) ;
65: checkStl@var953 .@expr1073746174 missingComparison (@expr1073746175 ) ;
66: checkStl@var953 .@expr1073746176 outOfBounds (@expr1073746177 ) ;
67: checkStl@var953 .@expr1073746178 outOfBoundsIndexExpression (@expr1073746179 ) ;
68: checkStl@var953 .@expr1073746180 redundantCondition (@expr1073746181 ) ;
69: checkStl@var953 .@expr1073746182 string_c_str (@expr1073746183 ) ;
70: checkStl@var953 .@expr1073746184 uselessCalls (@expr1073746185 ) ;
71: checkStl@var953 .@expr1073746186 useStlAlgorithm (@expr1073746187 ) ;
72:
73: checkStl@var953 .@expr1073746188 stlOutOfBounds (@expr1073746189 ) ;
74: checkStl@var953 .@expr1073746190 negativeIndex (@expr1073746191 ) ;
75:
76: checkStl@var953 .@expr1073746192 invalidContainer (@expr1073746193 ) ;
77: checkStl@var953 .@expr1073746194 mismatchingContainers (@expr1073746195 ) ;
78: checkStl@var953 .@expr1073746196 mismatchingContainerIterator (@expr1073746197 ) ;
79: checkStl@var953 .@expr1073746198 knownEmptyContainer (@expr1073746199 ) ;
80:
81: checkStl@var953 .@expr1073746200 stlBoundaries (@expr1073746201 ) ;
82: checkStl@var953 .@expr1073746202 checkDereferenceInvalidIterator (@expr1073746203 ) ;
83: checkStl@var953 .@expr1073746204 checkDereferenceInvalidIterator2 (@expr1073746205 ) ;
84: checkStl@var953 .@expr1073746206 checkMutexes (@expr1073746207 ) ;
85:
86:
87: checkStl@var953 .@expr1073746208 size (@expr1073746209 ) ;
88: }
89:
90:
91: void outOfBounds ( ) ;
92:
93:
94: void outOfBoundsIndexExpression ( ) ;
95:
|
99:
100: void stlOutOfBounds ( ) ;
101:
|
104:
105: void negativeIndex ( ) ;
106:
|
110:
111: void iterators ( ) ;
112:
113: void invalidContainer ( ) ;
114:
115: bool checkIteratorPair ( const Token * tok1@var954 , const Token * tok2@var955 ) ;
116:
|
120:
121: void mismatchingContainers ( ) ;
122:
123: void mismatchingContainerIterator ( ) ;
124:
|
128:
129: void erase ( ) ;
130: void eraseCheckLoopVar ( const Scope & scope@var956 , const Variable * var@var957 ) ;
131:
|
134:
135: void stlBoundaries ( ) ;
136:
137:
138: void if_find ( ) ;
139:
140: void checkFindInsert ( ) ;
141:
|
145:
146: void size ( ) ;
147:
|
150:
151: void redundantCondition ( ) ;
152:
|
158:
159: void missingComparison ( ) ;
160:
161:
162: void string_c_str ( ) ;
163:
164:
165: void uselessCalls ( ) ;
166:
167:
168: void checkDereferenceInvalidIterator ( ) ;
169: void checkDereferenceInvalidIterator2 ( ) ;
170:
|
177:
178: void dereferenceErasedError ( const Token * erased@var958 , const Token * deref@var959 , const std :: string & itername@var960 , bool inconclusive@var961 ) ;
179:
180:
181: void useStlAlgorithm ( ) ;
182:
183: void knownEmptyContainer ( ) ;
184:
185: void checkMutexes ( ) ;
186:
187: private:
188: bool isContainerSize ( const Token * containerToken@var962 , const Token * expr@var963 ) const ;
189: bool isContainerSizeGE ( const Token * containerToken@var964 , const Token * expr@var965 ) const ;
190:
191: void missingComparisonError ( const Token * incrementToken1@var966 , const Token * incrementToken2@var967 ) ;
192: void string_c_strThrowError ( const Token * tok@var968 ) ;
193: void string_c_strError ( const Token * tok@var969 ) ;
194: void string_c_strReturn ( const Token * tok@var970 ) ;
195: void string_c_strParam ( const Token * tok@var971 , int number@var972 ) ;
196:
197: void outOfBoundsError ( const Token * tok@var973 , const std :: string & containerName@var974 , const ValueFlow :: Value * containerSize@var975 , const std :: string & index@var976 , const ValueFlow :: Value * indexValue@var977 ) ;
198: void outOfBoundsIndexExpressionError ( const Token * tok@var978 , const Token * index@var979 ) ;
199: void stlOutOfBoundsError ( const Token * tok@var980 , const std :: string & num@var981 , const std :: string & var@var982 , bool at@var983 ) ;
200: void negativeIndexError ( const Token * tok@var984 , const ValueFlow :: Value & index@var985 ) ;
201: void invalidIteratorError ( const Token * tok@var986 , const std :: string & iteratorName@var987 ) ;
202: void iteratorsError ( const Token * tok@var988 , const std :: string & containerName1@var989 , const std :: string & containerName2@var990 ) ;
203: void iteratorsError ( const Token * tok@var991 , const Token * containerTok@var992 , const std :: string & containerName1@var993 , const std :: string & containerName2@var994 ) ;
204: void iteratorsError ( const Token * tok@var995 , const Token * containerTok@var996 , const std :: string & containerName@var997 ) ;
205: void mismatchingContainerIteratorError ( const Token * tok@var998 , const Token * iterTok@var999 ) ;
206: void mismatchingContainersError ( const Token * tok1@var1000 , const Token * tok2@var1001 ) ;
207: void mismatchingContainerExpressionError ( const Token * tok1@var1002 , const Token * tok2@var1003 ) ;
208: void sameIteratorExpressionError ( const Token * tok@var1004 ) ;
209: void stlBoundariesError ( const Token * tok@var1005 ) ;
210: void if_findError ( const Token * tok@var1006 , bool str@var1007 ) ;
211: void checkFindInsertError ( const Token * tok@var1008 ) ;
212: void sizeError ( const Token * tok@var1009 ) ;
213: void redundantIfRemoveError ( const Token * tok@var1010 ) ;
214: void invalidContainerLoopError ( const Token * tok@var1011 , const Token * loopTok@var1012 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1013 ) ;
215: void invalidContainerError ( const Token * tok@var1014 , const Token * contTok@var1015 , const ValueFlow :: Value * val@var1016 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1017 ) ;
216: void invalidContainerReferenceError ( const Token * tok@var1018 , const Token * contTok@var1019 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1020 ) ;
217:
218: void uselessCallsReturnValueError ( const Token * tok@var1021 , const std :: string & varname@var1022 , const std :: string & function@var1023 ) ;
219: void uselessCallsSwapError ( const Token * tok@var1024 , const std :: string & varname@var1025 ) ;
220: void uselessCallsSubstrError ( const Token * tok@var1026 , bool empty@var1027 ) ;
221: void uselessCallsEmptyError ( const Token * tok@var1028 ) ;
222: void uselessCallsRemoveError ( const Token * tok@var1029 , const std :: string & function@var1030 ) ;
223:
224: void dereferenceInvalidIteratorError ( const Token * deref@var1031 , const std :: string & iterName@var1032 ) ;
225: void dereferenceInvalidIteratorError ( const Token * tok@var1033 , const ValueFlow :: Value * value@var1034 , bool inconclusive@var1035 ) ;
226:
227: void readingEmptyStlContainerError ( const Token * tok@var1036 , const ValueFlow :: Value * value@var1037 = nullptr ) ;
228:
229: void useStlAlgorithmError ( const Token * tok@var1038 , const std :: string & algoName@var1039 ) ;
230:
231: void knownEmptyContainerError ( const Token * tok@var1040 , const std :: string & algo@var1041 ) ;
232:
233: void globalLockGuardError ( const Token * tok@var1042 ) ;
234: void localMutexError ( const Token * tok@var1043 ) ;
235:
236: void getErrorMessages ( ErrorLogger * errorLogger@var1044 , const Settings * settings@var1045 ) const override {
237: std ::@expr1073746210 list < std ::@expr4387 pair < const Token *@expr1073746212 , std ::@expr4387 string > > errorPath@var1046 ;
238: CheckStl c@var1047 (@expr1073746214 nullptr , settings@var1045 , errorLogger@var1044 ) ;
239: c@var1047 .@expr1073746215 outOfBoundsError (@expr1073746216 nullptr , "container" , nullptr , "x" , nullptr ) ;
240: c@var1047 .@expr1073746217 invalidIteratorError (@expr1073746218 nullptr , "iterator" ) ;
241: c@var1047 .@expr4395 iteratorsError (@expr1073746220 nullptr , "container1" , "container2" ) ;
242: c@var1047 .@expr4395 iteratorsError (@expr1073746222 nullptr , nullptr , "container0" , "container1" ) ;
243: c@var1047 .@expr4395 iteratorsError (@expr1073746224 nullptr , nullptr , "container" ) ;
244: c@var1047 .@expr1073746225 invalidContainerLoopError (@expr1073746226 nullptr , nullptr , errorPath@var1046 ) ;
245: c@var1047 .@expr1073746227 invalidContainerError (@expr1073746228 nullptr , nullptr , nullptr , errorPath@var1046 ) ;
246: c@var1047 .@expr1073746229 mismatchingContainerIteratorError (@expr1073746230 nullptr , nullptr ) ;
247: c@var1047 .@expr1073746231 mismatchingContainersError (@expr1073746232 nullptr , nullptr ) ;
248: c@var1047 .@expr1073746233 mismatchingContainerExpressionError (@expr1073746234 nullptr , nullptr ) ;
249: c@var1047 .@expr1073746235 sameIteratorExpressionError (@expr1073746236 nullptr ) ;
250: c@var1047 .@expr1073746237 dereferenceErasedError (@expr1073746238 nullptr , nullptr , "iter" , false ) ;
251: c@var1047 .@expr1073746239 stlOutOfBoundsError (@expr1073746240 nullptr , "i" , "foo" , false ) ;
252: c@var1047 .@expr1073746241 negativeIndexError (@expr1073746242 nullptr , ValueFlow ::@expr1073746243 Value (@expr1073746244 -1 ) ) ;
253: c@var1047 .@expr1073746245 stlBoundariesError (@expr1073746246 nullptr ) ;
254: c@var1047 .@expr4423 if_findError (@expr1073746248 nullptr , false ) ;
255: c@var1047 .@expr4423 if_findError (@expr1073746250 nullptr , true ) ;
256: c@var1047 .@expr1073746251 checkFindInsertError (@expr1073746252 nullptr ) ;
257: c@var1047 .@expr1073746253 string_c_strError (@expr1073746254 nullptr ) ;
258: c@var1047 .@expr1073746255 string_c_strReturn (@expr1073746256 nullptr ) ;
259: c@var1047 .@expr1073746257 string_c_strParam (@expr1073746258 nullptr , 0 ) ;
260: c@var1047 .@expr1073746259 string_c_strThrowError (@expr1073746260 nullptr ) ;
261: c@var1047 .@expr1073746261 sizeError (@expr1073746262 nullptr ) ;
262: c@var1047 .@expr1073746263 missingComparisonError (@expr1073746264 nullptr , nullptr ) ;
263: c@var1047 .@expr1073746265 redundantIfRemoveError (@expr1073746266 nullptr ) ;
264: c@var1047 .@expr1073746267 uselessCallsReturnValueError (@expr1073746268 nullptr , "str" , "find" ) ;
265: c@var1047 .@expr1073746269 uselessCallsSwapError (@expr1073746270 nullptr , "str" ) ;
266: c@var1047 .@expr1073746271 uselessCallsSubstrError (@expr1073746272 nullptr , false ) ;
267: c@var1047 .@expr1073746273 uselessCallsEmptyError (@expr1073746274 nullptr ) ;
268: c@var1047 .@expr1073746275 uselessCallsRemoveError (@expr1073746276 nullptr , "remove" ) ;
269: c@var1047 .@expr1073746277 dereferenceInvalidIteratorError (@expr1073746278 nullptr , "i" ) ;
270: c@var1047 .@expr1073746279 readingEmptyStlContainerError (@expr1073746280 nullptr ) ;
271: c@var1047 .@expr1073746281 useStlAlgorithmError (@expr1073746282 nullptr , "" ) ;
272: c@var1047 .@expr1073746283 knownEmptyContainerError (@expr1073746284 nullptr , "" ) ;
273: c@var1047 .@expr1073746285 globalLockGuardError (@expr1073746286 nullptr ) ;
274: c@var1047 .@expr1073746287 localMutexError (@expr1073746288 nullptr ) ;
275: }
276:
277: static std :: string myName ( ) {
278: return "STL usage" ;
279: }
280:
281: std :: string classInfo ( ) const override {
282: return "Check for invalid usage of STL:\n- out of bounds errors\n- misuse of iterators when iterating through a container\n- mismatching containers in calls\n- same iterators in calls\n- dereferencing an erased iterator\n- for vectors: using iterator/pointer after push_back has been used\n- optimisation: use empty() instead of size() to guarantee fast code\n- suspicious condition when using find\n- unnecessary searching in associative containers\n- redundant condition\n- common mistakes when using string::c_str()\n- useless calls of string and STL functions\n- dereferencing an invalid iterator\n- reading from empty STL container\n- iterating over an empty STL container\n- consider using an STL algorithm instead of raw loop\n- incorrect locking with mutex\n"
283:
|
298:
299: ;
300: }
301: } ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var1048 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var1049 ;
42:
43:
44: std :: string stdValue@var1050 ;
45:
46:
47: Standards ( ) : c@var1048 ( CLatest ) , cpp@var1049 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var1051 ) {
50: stdValue@var1050 =@expr1073746289 str@var1051 ;
51: if (@expr1073746290 str@var1051 ==@expr1073746291 "c89" ||@expr1073746292 str@var1051 ==@expr1073746293 "C89" ) {
52: c@var1048 =@expr1073746294 C89 ;
53: return true ;
54: }
55: if (@expr1073746295 str@var1051 ==@expr1073746296 "c99" ||@expr1073746297 str@var1051 ==@expr1073746298 "C99" ) {
56: c@var1048 =@expr1073746299 C99 ;
57: return true ;
58: }
59: if (@expr1073746300 str@var1051 ==@expr1073746301 "c11" ||@expr1073746302 str@var1051 ==@expr1073746303 "C11" ) {
60: c@var1048 =@expr1073746304 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073746305 c@var1048 ) {
67: case C89 :@expr4482 ;
68: return "c89" ;
69: case C99 :@expr4482 ;
70: return "c99" ;
71: case C11 :@expr4482 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var1052 ) {
77: if (@expr1073746309 std@var1052 ==@expr1073746310 "c89" ) {
78: return Standards ::@expr1073746311 C89 ;
79: }
80: if (@expr1073746312 std@var1052 ==@expr1073746313 "c99" ) {
81: return Standards ::@expr1073746314 C99 ;
82: }
83: if (@expr1073746315 std@var1052 ==@expr1073746316 "c11" ) {
84: return Standards ::@expr1073746317 C11 ;
85: }
86: return Standards ::@expr1073746318 CLatest ;
87: }
88: bool setCPP ( std :: string str@var1053 ) {
89: stdValue@var1050 =@expr1073746319 str@var1053 ;
90: strTolower (@expr1073746320 str@var1053 ) ;
91: cpp@var1049 =@expr1073746321 getCPP (@expr1073746322 str@var1053 ) ;
92: return !@expr1073746323 stdValue@var1050 .@expr1073746324 empty (@expr1073746325 ) &&@expr1073746326 str@var1053 ==@expr1073746327 getCPP (@expr1073746328 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073746329 cpp@var1049 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var1054 ) {
98: switch (@expr1073746330 std@var1054 ) {
99: case CPP03 :@expr4507 ;
100: return "c++03" ;
101: case CPP11 :@expr4507 ;
102: return "c++11" ;
103: case CPP14 :@expr4507 ;
104: return "c++14" ;
105: case CPP17 :@expr4507 ;
106: return "c++17" ;
107: case CPP20 :@expr4507 ;
108: return "c++20" ;
109: case CPP23 :@expr4507 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var1055 ) {
115: if (@expr1073746337 std@var1055 ==@expr1073746338 "c++03" ) {
116: return Standards ::@expr1073746339 CPP03 ;
117: }
118: if (@expr1073746340 std@var1055 ==@expr1073746341 "c++11" ) {
119: return Standards ::@expr1073746342 CPP11 ;
120: }
121: if (@expr1073746343 std@var1055 ==@expr1073746344 "c++14" ) {
122: return Standards ::@expr1073746345 CPP14 ;
123: }
124: if (@expr1073746346 std@var1055 ==@expr1073746347 "c++17" ) {
125: return Standards ::@expr1073746348 CPP17 ;
126: }
127: if (@expr1073746349 std@var1055 ==@expr1073746350 "c++20" ) {
128: return Standards ::@expr1073746351 CPP20 ;
129: }
130: if (@expr1073746352 std@var1055 ==@expr1073746353 "c++23" ) {
131: return Standards ::@expr1073746354 CPP23 ;
132: }
133: return Standards ::@expr1073746355 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var1059 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var1056 ) : errorcode@var1059 ( e@var1056 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var1057 , T && r@var1058 ) : errorcode@var1059 ( e@var1057 ) , reason@var1060 ( r@var1058 ) { }
66: ErrorCode errorcode@var1059 ;
67: std :: string reason@var1060 ;
68: } ;
69:
70: Error load ( const char exename@var1061 [ ] , const char path@var1062 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var1063 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var1064 [ ] , unsigned long len@var1065 ) ;
75:
76: struct AllocFunc {
77: int groupId@var1066 ;
78: int arg@var1067 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var1068 ;
81: int bufferSizeArg1@var1069 ;
82: int bufferSizeArg2@var1070 ;
83: int reallocArg@var1071 ;
84: bool initData@var1072 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var1073 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var1074 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var1075 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var1076 , int arg@var1077 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var1078 , int arg@var1079 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var1080 , int arg@var1081 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var1082 [ ] ) const {
107: return getAllocDealloc (@expr1073746356 mAlloc@var1348 , name@var1082 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var1083 [ ] ) const {
112: return getAllocDealloc (@expr1073746357 mDealloc@var1349 , name@var1083 ) ;
113: }
114:
115:
116: int allocId ( const char name@var1084 [ ] ) const {
117: const AllocFunc * af@var1085 ; af@var1085 =@expr1073746358 getAllocDealloc (@expr1073746359 mAlloc@var1348 , name@var1084 ) ;
118: return af@var1085 ?@expr1073746360 af@var1085 .@expr1073746361 groupId@var1086 :@expr1073746362 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var1087 [ ] ) const {
123: const AllocFunc * af@var1088 ; af@var1088 =@expr1073746363 getAllocDealloc (@expr1073746364 mDealloc@var1349 , name@var1087 ) ;
124: return af@var1088 ?@expr1073746365 af@var1088 .@expr1073746366 groupId@var1089 :@expr1073746367 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var1090 , int id@var1091 , int arg@var1092 ) {
129: mAlloc@var1348 [@expr4544 functionname@var1090 ] .@expr1073746369 groupId@var3303 =@expr1073746370 id@var1091 ;
130: mAlloc@var1348 [@expr4544 functionname@var1090 ] .@expr1073746372 arg@var3304 =@expr1073746373 arg@var1092 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var1093 , int id@var1094 , int arg@var1095 ) {
134: mDealloc@var1349 [@expr4550 functionname@var1093 ] .@expr1073746375 groupId@var3305 =@expr1073746376 id@var1094 ;
135: mDealloc@var1349 [@expr4550 functionname@var1093 ] .@expr1073746378 arg@var3306 =@expr1073746379 arg@var1095 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var1096 , int id@var1097 , int arg@var1098 , int reallocArg@var1099 = 1 ) {
139: mRealloc@var1350 [@expr4556 functionname@var1096 ] .@expr1073746381 groupId@var3307 =@expr1073746382 id@var1097 ;
140: mRealloc@var1350 [@expr4556 functionname@var1096 ] .@expr1073746384 arg@var3308 =@expr1073746385 arg@var1098 ;
141: mRealloc@var1350 [@expr4556 functionname@var1096 ] .@expr1073746387 reallocArg@var3309 =@expr1073746388 reallocArg@var1099 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var1100 , bool noreturn@var1101 ) {
146: mNoReturn@var1351 [@expr1073746389 funcname@var1100 ] =@expr1073746390 noreturn@var1101 ?@expr1073746391 FalseTrueMaybe ::@expr1073746392 True :@expr1073746393 FalseTrueMaybe ::@expr1073746394 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var1102 ) ;
150:
151:
152: static bool ismemory ( const int id@var1103 ) {
153: return (@expr4571 (@expr4571 id@var1103 >@expr1073746397 0 ) &&@expr1073746398 (@expr4571 (@expr4571 id@var1103 &@expr1073746401 1 ) ==@expr1073746402 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var1104 ) {
156: return (@expr4579 (@expr4579 func@var1104 .@expr4581 groupId@var1105 >@expr1073746406 0 ) &&@expr1073746407 (@expr4579 (@expr4579 func@var1104 .@expr4581 groupId@var1105 &@expr1073746411 1 ) ==@expr1073746412 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var1106 ) {
161: return (@expr4589 (@expr4589 id@var1106 >@expr1073746415 0 ) &&@expr1073746416 (@expr4589 (@expr4589 id@var1106 &@expr1073746419 1 ) ==@expr1073746420 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var1107 ) {
164: return (@expr4597 (@expr4597 func@var1107 .@expr4599 groupId@var1108 >@expr1073746424 0 ) &&@expr1073746425 (@expr4597 (@expr4597 func@var1107 .@expr4599 groupId@var1108 &@expr1073746429 1 ) ==@expr1073746430 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var1109 ) const ;
168: int formatstr_argno ( const Token * ftok@var1110 ) const ;
169: bool formatstr_scan ( const Token * ftok@var1111 ) const ;
170: bool formatstr_secure ( const Token * ftok@var1112 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var1113 ;
174: int ptr2Arg@var1114 ;
175: int sizeArg@var1115 ;
176: int strlenArg@var1116 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var1117 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var1118 ;
182: Standards standards@var1119 ;
183: Severity :: SeverityType severity@var1120 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var1121 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var1122 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var1123 ) const ;
191: bool matchArguments ( const Token * ftok@var1124 , const std :: string & functionName@var1125 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var1126 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var1127 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var1128 ) const ;
198: int returnValueContainer ( const Token * ftok@var1129 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var1130 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var1131 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var1132 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var1133 , std :: string * unknownFunc@var1134 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var1144 ( -1 ) ,
210: size_templateArgNo@var1146 ( -1 ) ,
211: arrayLike_indexOp@var1147 ( false ) ,
212: stdStringLike@var1148 ( false ) ,
213: stdAssociativeLike@var1149 ( false ) ,
214: opLessAllowed@var1150 ( true ) ,
215: hasInitializerListConstructor@var1151 ( false ) ,
216: unstableErase@var1152 ( false ) ,
217: unstableInsert@var1153 ( false ) ,
218: view@var1154 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var1135 ;
248: Yield yield@var1136 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var1137 ;
252: int templateParameter@var1138 ;
253: } ;
254: std :: string startPattern@var1139 ; std :: string startPattern2@var1140 ; std :: string endPattern@var1141 ; std :: string itEndPattern@var1142 ;
255: std :: map < std :: string , Function > functions@var1143 ;
256: int type_templateArgNo@var1144 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var1145 ;
258: int size_templateArgNo@var1146 ;
259: bool arrayLike_indexOp@var1147 ;
260: bool stdStringLike@var1148 ;
261: bool stdAssociativeLike@var1149 ;
262: bool opLessAllowed@var1150 ;
263: bool hasInitializerListConstructor@var1151 ;
264: bool unstableErase@var1152 ;
265: bool unstableInsert@var1153 ;
266: bool view@var1154 ;
267:
268: Action getAction ( const std :: string & function@var1155 ) const {
269: const std ::@expr1073746431 map < std ::@expr1073746432 string , Function > ::@expr1073746433 const_iterator i@var1156 =@expr1073746434 functions@var1143 .@expr1073746435 find (@expr1073746436 function@var1155 ) ;
270: if (@expr1073746437 i@var1156 !=@expr1073746438 functions@var1143 .@expr1073746439 end (@expr1073746440 ) ) {
271: return i@var1156 .@expr1073746441 second@var1157 .@expr1073746442 action@var1158 ; }
272: return Action ::@expr1073746443 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var1159 ) const {
276: const std ::@expr1073746444 map < std ::@expr1073746445 string , Function > ::@expr1073746446 const_iterator i@var1160 =@expr1073746447 functions@var1143 .@expr1073746448 find (@expr1073746449 function@var1159 ) ;
277: if (@expr1073746450 i@var1160 !=@expr1073746451 functions@var1143 .@expr1073746452 end (@expr1073746453 ) ) {
278: return i@var1160 .@expr1073746454 second@var1161 .@expr1073746455 yield@var1162 ; }
279: return Yield ::@expr1073746456 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var1163 ) ;
283: static Action actionFrom ( const std :: string & actionName@var1164 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var1165 ;
286: const Container * detectContainer ( const Token * typeStart@var1166 , bool iterator@var1167 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var1168 , bool * isIterator@var1169 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var1170 ( false ) ,
293: notnull@var1171 ( false ) ,
294: notuninit@var1172 ( -1 ) ,
295: formatstr@var1173 ( false ) ,
296: strz@var1174 ( false ) ,
297: optional@var1175 ( false ) ,
298: variadic@var1176 ( false ) ,
299: iteratorInfo@var1182 ( ) ,
300: direction@var1190 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var1170 ;
303: bool notnull@var1171 ;
304: int notuninit@var1172 ;
305: bool formatstr@var1173 ;
306: bool strz@var1174 ;
307: bool optional@var1175 ;
308: bool variadic@var1176 ;
309: std :: string valid@var1177 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var1178 ( 0 ) , it@var1179 ( false ) , first@var1180 ( false ) , last@var1181 ( false ) { }
314:
315: int container@var1178 ;
316: bool it@var1179 ;
317: bool first@var1180 ;
318: bool last@var1181 ;
319: } ;
320: IteratorInfo iteratorInfo@var1182 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var1183 , int a@var1184 ) : type@var1185 ( t@var1183 ) , arg@var1186 ( a@var1184 ) , arg2@var1187 ( 0 ) , value@var1188 ( 0 ) { }
326: Type type@var1185 ;
327: int arg@var1186 ;
328: int arg2@var1187 ;
329: long long value@var1188 ;
330: } ;
331: std :: vector < MinSize > minsizes@var1189 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var1190 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var1191 ;
344: bool use@var1192 ;
345: bool leakignore@var1193 ;
346: bool isconst@var1194 ;
347: bool ispure@var1195 ;
348: UseRetValType useretval@var1196 ;
349: bool ignore@var1197 ;
350: bool formatstr@var1198 ;
351: bool formatstr_scan@var1199 ;
352: bool formatstr_secure@var1200 ;
353: Container :: Action containerAction@var1201 ;
354: Container :: Yield containerYield@var1202 ;
355: Function ( )
356: : use@var1192 ( false ) ,
357: leakignore@var1193 ( false ) ,
358: isconst@var1194 ( false ) ,
359: ispure@var1195 ( false ) ,
360: useretval@var1196 ( UseRetValType :: NONE ) ,
361: ignore@var1197 ( false ) ,
362: formatstr@var1198 ( false ) ,
363: formatstr_scan@var1199 ( false ) ,
364: formatstr_secure@var1200 ( false ) ,
365: containerAction@var1201 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var1202 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var1203 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var1204 ;
372: bool isUse ( const std :: string & functionName@var1205 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var1206 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var1207 , bool pure@var1208 ) const ;
375: bool isFunctionConst ( const Token * ftok@var1209 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var1210 , int argnr@var1211 ) const {
378: const ArgumentChecks * arg@var1212 ; arg@var1212 =@expr1073746457 getarg (@expr1073746458 ftok@var1210 , argnr@var1211 ) ;
379: return arg@var1212 &&@expr1073746459 arg@var1212 .@expr1073746460 notbool@var1213 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var1214 , int argnr@var1215 ) const ;
383: bool isuninitargbad ( const Token * ftok@var1216 , int argnr@var1217 , int indirect@var1218 = 0 , bool * hasIndirect@var1219 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var1220 , int argnr@var1221 ) const {
386: const ArgumentChecks * arg@var1222 ; arg@var1222 =@expr1073746461 getarg (@expr1073746462 ftok@var1220 , argnr@var1221 ) ;
387: return arg@var1222 &&@expr1073746463 arg@var1222 .@expr1073746464 formatstr@var1223 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var1224 , int argnr@var1225 ) const {
391: const ArgumentChecks * arg@var1226 ; arg@var1226 =@expr1073746465 getarg (@expr1073746466 ftok@var1224 , argnr@var1225 ) ;
392: return arg@var1226 &&@expr1073746467 arg@var1226 .@expr1073746468 strz@var1227 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var1228 , int argnr@var1229 , const long long argvalue@var1230 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var1231 , int argnr@var1232 , double argvalue@var1233 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var1234 , int argnr@var1235 ) const {
399: const ArgumentChecks * arg@var1236 ; arg@var1236 =@expr1073746469 getarg (@expr1073746470 ftok@var1234 , argnr@var1235 ) ;
400: return arg@var1236 ?@expr1073746471 arg@var1236 .@expr1073746472 valid@var1237 :@expr1073746473 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var1238 ;
405: std :: string op1@var1239 ;
406: std :: string op2@var1240 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073746474 isInt (@expr1073746475 op1@var1239 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var1241 , int argnr@var1242 ) const {
413: const ArgumentChecks * arg@var1243 ; arg@var1243 =@expr1073746476 getarg (@expr1073746477 ftok@var1241 , argnr@var1242 ) ;
414: return arg@var1243 &&@expr1073746478 arg@var1243 .@expr4655 iteratorInfo@var1244 .@expr1073746480 it@var1245 ?@expr1073746481 &@expr1073746482 arg@var1243 .@expr4655 iteratorInfo@var1244 :@expr1073746484 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var1246 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var1247 , int argnr@var1248 ) const {
420: const ArgumentChecks * arg@var1249 ; arg@var1249 =@expr1073746485 getarg (@expr1073746486 ftok@var1247 , argnr@var1248 ) ;
421: return arg@var1249 ?@expr1073746487 &@expr1073746488 arg@var1249 .@expr1073746489 minsizes@var1250 :@expr1073746490 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var1251 , int argnr@var1252 ) const ;
425:
426: bool markupFile ( const std :: string & path@var1253 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var1254 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var1358 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var1255 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var1256 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var1257 , const std :: string & token@var1258 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var1259 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var1260 ) const ;
443: const std :: string & blockend ( const std :: string & file@var1261 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var1262 , const std :: string & keyword@var1263 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var1264 ) const {
448: return mExporters@var1361 .@expr1073746491 find (@expr1073746492 prefix@var1264 ) !=@expr1073746493 mExporters@var1361 .@expr1073746494 end (@expr1073746495 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var1265 , const std :: string & token@var1266 ) const {
452: const std ::@expr1073746496 map < std ::@expr1073746497 string , ExportedFunctions > ::@expr1073746498 const_iterator it@var1267 =@expr1073746499 mExporters@var1361 .@expr1073746500 find (@expr1073746501 prefix@var1265 ) ;
453: return (@expr1073746502 it@var1267 !=@expr1073746503 mExporters@var1361 .@expr1073746504 end (@expr1073746505 ) &&@expr1073746506 it@var1267 .@expr1073746507 second@var1268 .@expr1073746508 isPrefix (@expr1073746509 token@var1266 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var1269 , const std :: string & token@var1270 ) const {
457: const std ::@expr1073746510 map < std ::@expr1073746511 string , ExportedFunctions > ::@expr1073746512 const_iterator it@var1271 =@expr1073746513 mExporters@var1361 .@expr1073746514 find (@expr1073746515 prefix@var1269 ) ;
458: return (@expr1073746516 it@var1271 !=@expr1073746517 mExporters@var1361 .@expr1073746518 end (@expr1073746519 ) &&@expr1073746520 it@var1271 .@expr1073746521 second@var1272 .@expr1073746522 isSuffix (@expr1073746523 token@var1270 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var1273 , const std :: string & importer@var1274 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var1275 , Container :: Yield yield@var1276 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var1277 , Container :: Action action@var1278 ) const ;
465:
466: bool isreflection ( const std :: string & token@var1279 ) const {
467: return mReflection@var1363 .@expr1073746524 find (@expr1073746525 token@var1279 ) !=@expr1073746526 mReflection@var1363 .@expr1073746527 end (@expr1073746528 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var1280 ) const {
471: const std ::@expr1073746529 map < std ::@expr1073746530 string , int > ::@expr1073746531 const_iterator it@var1281 =@expr1073746532 mReflection@var1363 .@expr1073746533 find (@expr1073746534 token@var1280 ) ;
472: if (@expr1073746535 it@var1281 !=@expr1073746536 mReflection@var1363 .@expr1073746537 end (@expr1073746538 ) ) {
473: return it@var1281 .@expr1073746539 second@var1282 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var1283 ;
478:
479: struct SmartPointer {
480: std :: string name@var1284 ; name@var1284 = "" ;
481: bool unique@var1285 ; unique@var1285 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var1286 ;
485: bool isSmartPointer ( const Token * tok@var1287 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var1288 ) const ;
487:
488: struct PodType {
489: unsigned int size@var1289 ;
490: char sign@var1290 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var1291 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var1292 ) const {
494: const std ::@expr1073746540 unordered_map < std ::@expr1073746541 string , PodType > ::@expr1073746542 const_iterator it@var1293 =@expr1073746543 mPodTypes@var1364 .@expr1073746544 find (@expr1073746545 name@var1292 ) ;
495: return (@expr4722 it@var1293 !=@expr1073746547 mPodTypes@var1364 .@expr1073746548 end (@expr1073746549 ) ) ?@expr1073746550 &@expr1073746551 (@expr4722 it@var1293 .@expr1073746553 second@var1294 ) :@expr1073746554 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var1305 ( false )
501: , mUnsigned@var1306 ( false )
502: , mLong@var1307 ( false )
503: , mPointer@var1308 ( false )
504: , mPtrPtr@var1309 ( false )
505: , mConstPtr@var1310 ( false ) { }
506: bool operator== ( const PlatformType & type@var1295 ) const {
507: return (@expr1073746555 mSigned@var1305 ==@expr1073746556 type@var1295 .@expr1073746557 mSigned@var1296 &&@expr1073746558
508: mUnsigned@var1306 ==@expr1073746559 type@var1295 .@expr1073746560 mUnsigned@var1297 &&@expr1073746561
509: mLong@var1307 ==@expr1073746562 type@var1295 .@expr1073746563 mLong@var1298 &&@expr1073746564
510: mPointer@var1308 ==@expr1073746565 type@var1295 .@expr1073746566 mPointer@var1299 &&@expr1073746567
511: mPtrPtr@var1309 ==@expr1073746568 type@var1295 .@expr1073746569 mPtrPtr@var1300 &&@expr1073746570
512: mConstPtr@var1310 ==@expr1073746571 type@var1295 .@expr1073746572 mConstPtr@var1301 &&@expr1073746573
513: mType@var1304 ==@expr1073746574 type@var1295 .@expr1073746575 mType@var1302 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var1303 ) const {
516: return !@expr1073746576 (@expr1073746577 *@expr1073746578 this@expr1073746579 ==@expr1073746580 type@var1303 ) ;
517: }
518: std :: string mType@var1304 ;
519: bool mSigned@var1305 ;
520: bool mUnsigned@var1306 ;
521: bool mLong@var1307 ;
522: bool mPointer@var1308 ;
523: bool mPtrPtr@var1309 ;
524: bool mConstPtr@var1310 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var1311 ) const {
529: const std ::@expr1073746581 map < std ::@expr1073746582 string , PlatformType > ::@expr1073746583 const_iterator it@var1312 =@expr1073746584 mPlatformTypes@var1314 .@expr1073746585 find (@expr1073746586 name@var1311 ) ;
530: return (@expr4763 it@var1312 !=@expr1073746588 mPlatformTypes@var1314 .@expr1073746589 end (@expr1073746590 ) ) ?@expr1073746591 &@expr1073746592 (@expr4763 it@var1312 .@expr1073746594 second@var1313 ) :@expr1073746595 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var1314 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var1315 , const std :: string & platform@var1316 ) const {
536: const std ::@expr1073746596 map < std ::@expr4773 string , Platform > ::@expr1073746598 const_iterator it@var1317 =@expr1073746599 mPlatforms@var1366 .@expr1073746600 find (@expr1073746601 platform@var1316 ) ;
537: if (@expr1073746602 it@var1317 !=@expr1073746603 mPlatforms@var1366 .@expr1073746604 end (@expr1073746605 ) ) {
538: const PlatformType * const type@var1318 ; type@var1318 =@expr1073746606 it@var1317 .@expr1073746607 second@var1319 .@expr1073746608 platform_type (@expr1073746609 name@var1315 ) ;
539: if (@expr1073746610 type@var1318 ) {
540: return type@var1318 ; }
541: }
542:
543: const std ::@expr1073746611 map < std ::@expr4773 string , PlatformType > ::@expr1073746613 const_iterator it2@var1320 =@expr1073746614 mPlatformTypes@var1365 .@expr1073746615 find (@expr1073746616 name@var1315 ) ;
544: return (@expr4793 it2@var1320 !=@expr1073746618 mPlatformTypes@var1365 .@expr1073746619 end (@expr1073746620 ) ) ?@expr1073746621 &@expr1073746622 (@expr4793 it2@var1320 .@expr1073746624 second@var1321 ) :@expr1073746625 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var1322 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var1323 , Library :: Container :: Yield y@var1324 , const std :: string & fallback@var1325 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var1326 , const std :: string & typeName@var1327 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var1328 , const std :: string & name@var1329 , std :: set < std :: string > & unknown_elements@var1330 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var1331 ) {
565: mPrefixes@var1335 .@expr1073746626 insert (@expr1073746627 prefix@var1331 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var1332 ) {
568: mSuffixes@var1336 .@expr1073746628 insert (@expr1073746629 suffix@var1332 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var1333 ) const {
571: return (@expr1073746630 mPrefixes@var1335 .@expr1073746631 find (@expr1073746632 prefix@var1333 ) !=@expr1073746633 mPrefixes@var1335 .@expr1073746634 end (@expr1073746635 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var1334 ) const {
574: return (@expr1073746636 mSuffixes@var1336 .@expr1073746637 find (@expr1073746638 suffix@var1334 ) !=@expr1073746639 mSuffixes@var1336 .@expr1073746640 end (@expr1073746641 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var1335 ;
579: std :: set < std :: string > mSuffixes@var1336 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var1344 ( 0 ) { }
584:
585: void setStart ( const char * s@var1337 ) {
586: mStart@var1342 =@expr1073746642 s@var1337 ;
587: }
588: void setEnd ( const char * e@var1338 ) {
589: mEnd@var1343 =@expr1073746643 e@var1338 ;
590: }
591: void setOffset ( const int o@var1339 ) {
592: mOffset@var1344 =@expr1073746644 o@var1339 ;
593: }
594: void addBlock ( const char * blockName@var1340 ) {
595: mBlocks@var1345 .@expr1073746645 insert (@expr1073746646 blockName@var1340 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var1342 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var1343 ;
602: }
603: int offset ( ) const {
604: return mOffset@var1344 ;
605: }
606: bool isBlock ( const std :: string & blockName@var1341 ) const {
607: return mBlocks@var1345 .@expr1073746647 find (@expr1073746648 blockName@var1341 ) !=@expr1073746649 mBlocks@var1345 .@expr1073746650 end (@expr1073746651 ) ;
608: }
609:
610: private:
611: std :: string mStart@var1342 ;
612: std :: string mEnd@var1343 ;
613: int mOffset@var1344 ;
614: std :: set < std :: string > mBlocks@var1345 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var1346 ;
618: std :: set < std :: string > mFiles@var1347 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var1348 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var1349 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var1350 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var1351 ;
623: std :: map < std :: string , std :: string > mReturnValue@var1352 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var1353 ;
625: std :: map < std :: string , int > mReturnValueContainer@var1354 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var1355 ;
627: std :: map < std :: string , bool > mReportErrors@var1356 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var1357 ;
629: std :: set < std :: string > mMarkupExtensions@var1358 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var1359 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var1360 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var1361 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var1362 ;
634: std :: map < std :: string , int > mReflection@var1363 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var1364 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var1365 ;
637: std :: map < std :: string , Platform > mPlatforms@var1366 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1367 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1368 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1369 , int argnr@var1370 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1371 , bool * error@var1372 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1373 , const std :: string & name@var1374 ) {
646: const std ::@expr1073746652 map < std ::@expr1073746653 string , AllocFunc > ::@expr1073746654 const_iterator it@var1375 =@expr1073746655 data@var1373 .@expr1073746656 find (@expr1073746657 name@var1374 ) ;
647: return (@expr1073746658 it@var1375 ==@expr1073746659 data@var1373 .@expr1073746660 end (@expr1073746661 ) ) ?@expr1073746662 nullptr :@expr1073746663 &@expr1073746664 it@var1375 .@expr1073746665 second@var1376 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1377 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1378 ,
654: const Settings * settings@var1379 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1380 = nullptr ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1381 ( nullptr ) , num@var1382 ( 0 ) , known@var1383 ( true ) { }
62:
63: const Token * tok@var1381 ;
64: long long num@var1382 ;
65: bool known@var1383 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1384 ;
72: const Scope * classScope@var1385 ;
73: const Scope * enclosingScope@var1386 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1387 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1389 ( nullptr ) , nameTok@var1390 ( nullptr ) , access@var1391 ( AccessControl :: Public ) , isVirtual@var1392 ( false ) { }
82:
83: std :: string name@var1388 ;
84: const Type * type@var1389 ;
85: const Token * nameTok@var1390 ;
86: AccessControl access@var1391 ;
87: bool isVirtual@var1392 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1393 ) const {
90: return this@expr1073746666 .@expr1073746667 type@var1389 <@expr1073746668 rhs@var1393 .@expr1073746669 type@var1394 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1395 ( nullptr ) , nameEnd@var1396 ( nullptr ) , type@var1397 ( nullptr ) { }
97:
98: const Token * nameStart@var1395 ;
99: const Token * nameEnd@var1396 ;
100: const Type * type@var1397 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1398 ;
104: std :: vector < FriendInfo > friendList@var1399 ;
105:
106: const Token * typeStart@var1400 ;
107: const Token * typeEnd@var1401 ;
108: long long sizeOf@var1402 ;
109:
110: Type ( const Token * classDef_@var1403 = nullptr , const Scope * classScope_@var1404 = nullptr , const Scope * enclosingScope_@var1405 = nullptr ) :
111: classDef@var1384 ( classDef_@var1403 ) ,
112: classScope@var1385 ( classScope_@var1404 ) ,
113: enclosingScope@var1386 ( enclosingScope_@var1405 ) ,
114: needInitialization@var1387 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1400 ( nullptr ) ,
116: typeEnd@var1401 ( nullptr ) ,
117: sizeOf@var1402 ( 0 ) {
118: if (@expr1073746670 classDef_@var1403 &&@expr1073746671 classDef_@var1403 .@expr4848 str (@expr4849 ) ==@expr1073746674 "enum" ) {
119: needInitialization@var1387 =@expr1073746675 NeedInitialization ::@expr1073746676 True ; }
120: else { if (@expr1073746677 classDef_@var1403 &&@expr1073746678 classDef_@var1403 .@expr4848 str (@expr4849 ) ==@expr1073746681 "using" ) {
121: typeStart@var1400 =@expr1073746682 classDef@var1384 .@expr1073746683 tokAt (@expr1073746684 3 ) ;
122: typeEnd@var1401 =@expr1073746685 typeStart@var1400 ;
123: while (@expr1073746686 typeEnd@var1401 .@expr4863 next (@expr4864 ) &&@expr1073746689 typeEnd@var1401 .@expr4863 next (@expr4864 ) .@expr1073746692 str (@expr1073746693 ) !=@expr1073746694 ";" ) {
124: typeEnd@var1401 =@expr1073746695 typeEnd@var1401 .@expr4863 next (@expr4864 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1384 ?@expr1073746698 classDef@var1384 .@expr1073746699 str (@expr1073746700 ) :@expr1073746701 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1384 &&@expr1073746702 classDef@var1384 .@expr1073746703 str (@expr1073746704 ) ==@expr1073746705 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1406 , const Token * tok1@var1407 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1408 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1409 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1410 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1411 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1412 ) : scope@var1413 ( scope_@var1412 ) , name@var1414 ( nullptr ) , value@var1415 ( 0 ) , start@var1416 ( nullptr ) , end@var1417 ( nullptr ) , value_known@var1418 ( false ) { }
167: const Scope * scope@var1413 ;
168: const Token * name@var1414 ;
169: long long value@var1415 ;
170: const Token * start@var1416 ;
171: const Token * end@var1417 ;
172: bool value_known@var1418 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1419 ) const {
204: return (@expr4882 (@expr4882 mFlags@var1455 &@expr1073746708 flag_@var1419 ) !=@expr1073746709 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1420 , bool state_@var1421 ) {
213: mFlags@var1455 =@expr1073746710 state_@var1421 ?@expr1073746711 mFlags@var1455 |@expr1073746712 flag_@var1420 :@expr1073746713 mFlags@var1455 &@expr1073746714 ~@expr1073746715 flag_@var1420 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1422 , bool * isContainer@var1423 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1424 , const Token * start_@var1425 , const Token * end_@var1426 ,
226: int index_@var1427 , AccessControl access_@var1428 , const Type * type_@var1429 ,
227: const Scope * scope_@var1430 , const Settings * settings@var1431 )
228: : mNameToken@var1450 ( name_@var1424 ) ,
229: mTypeStartToken@var1451 ( start_@var1425 ) ,
230: mTypeEndToken@var1452 ( end_@var1426 ) ,
231: mIndex@var1453 ( index_@var1427 ) ,
232: mAccess@var1454 ( access_@var1428 ) ,
233: mFlags@var1455 ( 0 ) ,
234: mType@var1456 ( type_@var1429 ) ,
235: mScope@var1457 ( scope_@var1430 ) ,
236: mValueType@var1458 ( nullptr ) {
237: evaluate (@expr1073746716 settings@var1431 ) ;
238: }
239:
240: Variable ( const Token * name_@var1432 , const std :: string & clangType@var1433 , const Token * typeStart@var1434 ,
241: const Token * typeEnd@var1435 , int index_@var1436 , AccessControl access_@var1437 ,
242: const Type * type_@var1438 , const Scope * scope_@var1439 ) ;
243:
244: Variable ( const Variable & var@var1440 , const Scope * scope@var1441 ) ;
245:
246: Variable ( const Variable & var@var1442 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1443 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1450 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1451 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1452 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746717 mNameToken@var1450 ) {
300: return mNameToken@var1450 .@expr1073746718 str (@expr1073746719 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746720 mNameToken@var1450 ) {
312: return mNameToken@var1450 .@expr1073746721 varId (@expr1073746722 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1453 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1454 ==@expr1073746723 AccessControl ::@expr1073746724 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1454 ==@expr1073746725 AccessControl ::@expr1073746726 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1454 ==@expr1073746727 AccessControl ::@expr1073746728 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1454 ==@expr1073746729 AccessControl ::@expr1073746730 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1454 ==@expr1073746731 AccessControl ::@expr1073746732 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1454 ==@expr1073746733 AccessControl ::@expr1073746734 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746736 mAccess@var1454 ==@expr1073746737 AccessControl ::@expr1073746738 Local@expr1073746735 ) &&@expr1073746739 !@expr1073746740 isExtern (@expr1073746741 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746742 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746743 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746744 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746745 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746746 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1454 ==@expr1073746747 AccessControl ::@expr1073746748 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746749 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746750 fIsArray ) &&@expr1073746751 !@expr1073746752 getFlag (@expr1073746753 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746754 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746755 ) &&@expr1073746756 getFlag (@expr1073746757 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746758 fIsArray ) ||@expr1073746759 getFlag (@expr1073746760 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746761 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746762 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746763 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746764 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1456 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1456 ?@expr1073746765 mType@var1456 .@expr1073746766 classScope@var1461 :@expr1073746767 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1457 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1459 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1444 ) const {
550: return mDimensions@var1459 [@expr1073746768 index_@var1444 ] .@expr1073746769 num@var3310 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1445 ) const {
558: return mDimensions@var1459 [@expr1073746770 index_@var1445 ] .@expr1073746771 known@var3311 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746772 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746773 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746774 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1446 ) const {
602: return isStlType (@expr1073746775 ) &&@expr1073746776 stlType@var1446 ==@expr1073746777 mTypeStartToken@var1451 .@expr1073746778 strAt (@expr1073746779 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1447 ) const {
616: return isStlType (@expr1073746780 ) &&@expr1073746781 stlTypes@var1447 .@expr1073746782 find (@expr1073746783 mTypeStartToken@var1451 .@expr1073746784 strAt (@expr1073746785 2 ) ) !=@expr1073746786 stlTypes@var1447 .@expr1073746787 end (@expr1073746788 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746789 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4966 ) &&@expr1073746791 type (@expr4966 ) .@expr1073746793 isEnumType (@expr1073746794 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746795 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1458 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1448 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1454 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1449 ) {
660: mType@var1456 =@expr1073746796 t@var1449 ;
661: }
662:
663:
664: const Token * mNameToken@var1450 ;
665:
666:
667: const Token * mTypeStartToken@var1451 ;
668:
669:
670: const Token * mTypeEndToken@var1452 ;
671:
672:
673: int mIndex@var1453 ;
674:
675:
676: AccessControl mAccess@var1454 ;
677:
678:
679: unsigned int mFlags@var1455 ;
680:
681:
682: const Type * mType@var1456 ;
683:
684:
685: const Scope * mScope@var1457 ;
686:
687: ValueType * mValueType@var1458 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1459 ;
691:
692:
693: void evaluate ( const Settings * settings@var1460 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1462 ) const {
735: return (@expr4973 (@expr4973 mFlags@var1511 &@expr1073746799 flag@var1462 ) !=@expr1073746800 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1463 , bool state@var1464 ) {
744: mFlags@var1511 =@expr1073746801 state@var1464 ?@expr1073746802 mFlags@var1511 |@expr1073746803 flag@var1463 :@expr1073746804 mFlags@var1511 &@expr1073746805 ~@expr1073746806 flag@var1463 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1465 , const Token * tok@var1466 , const Scope * scope@var1467 , const Token * tokDef@var1468 , const Token * tokArgDef@var1469 ) ;
751: Function ( const Token * tokenDef@var1470 , const std :: string & clangType@var1471 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1481 .@expr1073746807 str (@expr1073746808 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1489 .@expr1073746809 size (@expr1073746810 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1489 .@expr1073746811 size (@expr1073746812 ) -@expr1073746813 initArgCount@var1490 ;
764: }
765: const Variable * getArgumentVar ( int num@var1472 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1490 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1473 , const Scope * scope@var1474 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1475 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1476 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1491 ==@expr1073746814 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1491 ==@expr1073746815 eConstructor ||@expr1073746816
785: type@var1491 ==@expr1073746817 eCopyConstructor ||@expr1073746818
786: type@var1491 ==@expr1073746819 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1491 ==@expr1073746820 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1481 .@expr1073746821 isAttributeConstructor (@expr1073746822 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1481 .@expr1073746823 isAttributeDestructor (@expr1073746824 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1481 .@expr1073746825 isAttributePure (@expr1073746826 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1481 .@expr1073746827 isAttributeConst (@expr1073746828 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1481 .@expr1073746829 isAttributeNoreturn (@expr1073746830 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1481 .@expr1073746831 isAttributeNothrow (@expr1073746832 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1481 .@expr1073746833 isAttributeNodiscard (@expr1073746834 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746835 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746836 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746837 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746838 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746839 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746840 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746841 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746842 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746843 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746844 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746845 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746846 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746847 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746848 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746849 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746850 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746851 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746852 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746853 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746854 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746855 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746856 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1477 ) {
881: setFlag (@expr1073746857 fHasBody , state@var1477 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746858 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746859 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1478 ) {
891: setFlag (@expr1073746860 fIsEscapeFunction , state@var1478 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746861 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1479 ) {
898: setFlag (@expr1073746862 fIsConstexpr , state@var1479 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1480 ) const ;
901:
902: const Token * tokenDef@var1481 ;
903: const Token * argDef@var1482 ;
904: const Token * token@var1483 ;
905: const Token * arg@var1484 ;
906: const Token * retDef@var1485 ;
907: const :: Type * retType@var1486 ;
908: const Scope * functionScope@var1487 ;
909: const Scope * nestedIn@var1488 ;
910: std :: list < Variable > argumentList@var1489 ;
911: int initArgCount@var1490 ;
912: Type type@var1491 ;
913: AccessControl access@var1492 ;
914: const Token * noexceptArg@var1493 ;
915: const Token * throwArg@var1494 ;
916: const Token * templateDef@var1495 ;
917: const Token * functionPointerUsage@var1496 ;
918:
919: bool argsMatch ( const Scope * scope@var1497 , const Token * first@var1498 , const Token * second@var1499 , const std :: string & path@var1500 , int path_length@var1501 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1502 , bool unknown@var1503 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1504 , bool unknown@var1505 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1506 , bool unknown@var1507 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1508 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746863 this@expr1073746864 .@expr1073746865 hasTrailingReturnType (@expr1073746866 ) ) {
931: return Token ::@expr1073746867 findmatch (@expr1073746868 retDef@var1485 , "{|;" ) ;
932: } else {
933: return tokenDef@var1481 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1509 , bool * foundAllBaseClasses@var1510 ) const ;
946:
947: unsigned int mFlags@var1511 ;
948:
949: void isInline ( bool state@var1512 ) {
950: setFlag (@expr1073746869 fIsInline , state@var1512 ) ;
951: }
952: void isConst ( bool state@var1513 ) {
953: setFlag (@expr1073746870 fIsConst , state@var1513 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1514 ) {
956: setFlag (@expr1073746871 fHasVirtualSpecifier , state@var1514 ) ;
957: }
958: void isPure ( bool state@var1515 ) {
959: setFlag (@expr1073746872 fIsPure , state@var1515 ) ;
960: }
961: void isStatic ( bool state@var1516 ) {
962: setFlag (@expr1073746873 fIsStatic , state@var1516 ) ;
963: }
964: void isStaticLocal ( bool state@var1517 ) {
965: setFlag (@expr1073746874 fIsStaticLocal , state@var1517 ) ;
966: }
967: void isExtern ( bool state@var1518 ) {
968: setFlag (@expr1073746875 fIsExtern , state@var1518 ) ;
969: }
970: void isFriend ( bool state@var1519 ) {
971: setFlag (@expr1073746876 fIsFriend , state@var1519 ) ;
972: }
973: void isExplicit ( bool state@var1520 ) {
974: setFlag (@expr1073746877 fIsExplicit , state@var1520 ) ;
975: }
976: void isDefault ( bool state@var1521 ) {
977: setFlag (@expr1073746878 fIsDefault , state@var1521 ) ;
978: }
979: void isDelete ( bool state@var1522 ) {
980: setFlag (@expr1073746879 fIsDelete , state@var1522 ) ;
981: }
982: void isNoExcept ( bool state@var1523 ) {
983: setFlag (@expr1073746880 fIsNoExcept , state@var1523 ) ;
984: }
985: void isThrow ( bool state@var1524 ) {
986: setFlag (@expr1073746881 fIsThrow , state@var1524 ) ;
987: }
988: void isOperator ( bool state@var1525 ) {
989: setFlag (@expr1073746882 fIsOperator , state@var1525 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1526 ) {
992: setFlag (@expr1073746883 fHasLvalRefQual , state@var1526 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1527 ) {
995: setFlag (@expr1073746884 fHasRvalRefQual , state@var1527 ) ;
996: }
997: void isVariadic ( bool state@var1528 ) {
998: setFlag (@expr1073746885 fIsVariadic , state@var1528 ) ;
999: }
1000: void isVolatile ( bool state@var1529 ) {
1001: setFlag (@expr1073746886 fIsVolatile , state@var1529 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1530 ) {
1004: return setFlag (@expr1073746887 fHasTrailingReturnType , state@var1530 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1531 ) {
1007: setFlag (@expr1073746888 fIsInlineKeyword , state@var1531 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1532 , const Scope * scope@var1533 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1534 ;
1019: const Scope * scope@var1535 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1536 , const Token * classDef_@var1537 , const Scope * nestedIn_@var1538 ) ;
1025: Scope ( const SymbolDatabase * check_@var1539 , const Token * classDef_@var1540 , const Scope * nestedIn_@var1541 , ScopeType type_@var1542 , const Token * start_@var1543 ) ;
1026:
1027: const SymbolDatabase * check@var1544 ;
1028: std :: string className@var1545 ;
1029: const Token * classDef@var1546 ;
1030: const Token * bodyStart@var1547 ;
1031: const Token * bodyEnd@var1548 ;
1032: std :: list < Function > functionList@var1549 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1550 ;
1034: std :: list < Variable > varlist@var1551 ;
1035: const Scope * nestedIn@var1552 ;
1036: std :: list < Scope * > nestedList@var1553 ;
1037: int numConstructors@var1554 ;
1038: int numCopyOrMoveConstructors@var1555 ;
1039: std :: list < UsingInfo > usingList@var1556 ;
1040: ScopeType type@var1557 ;
1041: Type * definedType@var1558 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1559 ;
1043: std :: vector < const Token * > bodyStartList@var1560 ;
1044:
1045:
1046: const Scope * functionOf@var1561 ;
1047: Function * function@var1562 ;
1048:
1049:
1050: const Token * enumType@var1563 ;
1051: bool enumClass@var1564 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1565 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1566 ) {
1056: bodyStart@var1547 =@expr1073746889 start@var1566 ;
1057: bodyEnd@var1548 =@expr1073746890 start@var1566 ?@expr1073746891 start@var1566 .@expr1073746892 link (@expr1073746893 ) :@expr1073746894 nullptr ;
1058: if (@expr1073746895 start@var1566 ) {
1059: bodyStartList@var1560 .@expr1073746896 push_back (@expr1073746897 start@var1566 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1545 .@expr1073746898 size (@expr1073746899 ) >@expr1073746900 9 &&@expr1073746901 className@var1545 .@expr1073746902 compare (@expr1073746903 0 , 9 , "Anonymous" ) ==@expr1073746904 0 &&@expr1073746905 std ::@expr1073746906 isdigit (@expr1073746907 className@var1545 [@expr1073746908 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1567 ) const {
1068: for (@expr1073746909 const Enumerator &@expr1073746910 i@var1568 :@expr1073746911 enumeratorList@var1565 ) {
1069: if (@expr1073746912 i@var1568 .@expr1073746913 name@var1569 .@expr1073746914 str (@expr1073746915 ) ==@expr1073746916 name@var1567 ) {
1070: return &@expr1073746917 i@var1568 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1570 ) const {
1076: if (@expr1073746918 !@expr1073746919 outer@var1570 ) {
1077: return false ; }
1078: if (@expr1073746920 outer@var1570 ==@expr1073746921 this@expr1073746922 ) {
1079: return true ; }
1080: const Scope * parent@var1571 ; parent@var1571 =@expr1073746923 nestedIn@var1552 ;
1081: while (@expr1073746924 outer@var1570 !=@expr1073746925 parent@var1571 &&@expr1073746926 parent@var1571 ) {
1082: parent@var1571 =@expr1073746927 parent@var1571 .@expr1073746928 nestedIn@var1572 ; }
1083: if (@expr1073746929 parent@var1571 &&@expr1073746930 parent@var1571 ==@expr1073746931 outer@var1570 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1573 ) {
1089: while (@expr1073746932 scope@var1573 ) {
1090: if (@expr1073746933 scope@var1573 .@expr1073746934 type@var1574 ==@expr1073746935 Scope ::@expr1073746936 eFunction ) {
1091: break ; }
1092: scope@var1573 =@expr1073746937 scope@var1573 .@expr1073746938 nestedIn@var1575 ;
1093: }
1094: if (@expr1073746939 !@expr1073746940 scope@var1573 ) {
1095: return nullptr ; }
1096: return scope@var1573 .@expr1073746941 function@var1576 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746942 type@var1557 ==@expr1073746943 eClass ||@expr1073746944 type@var1557 ==@expr1073746945 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746946 type@var1557 ==@expr1073746947 eClass ||@expr1073746948 type@var1557 ==@expr1073746949 eStruct ||@expr1073746950 type@var1557 ==@expr1073746951 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1557 !=@expr1073746952 eClass &&@expr1073746953 type@var1557 !=@expr1073746954 eStruct &&@expr1073746955 type@var1557 !=@expr1073746956 eUnion &&@expr1073746957 type@var1557 !=@expr1073746958 eGlobal &&@expr1073746959 type@var1557 !=@expr1073746960 eNamespace &&@expr1073746961 type@var1557 !=@expr1073746962 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1557 ==@expr1073746963 Scope ::@expr5140 ScopeType ::@expr1073746965 eFor ||@expr1073746966 type@var1557 ==@expr1073746967 Scope ::@expr5140 ScopeType ::@expr1073746969 eWhile ||@expr1073746970 type@var1557 ==@expr1073746971 Scope ::@expr5140 ScopeType ::@expr1073746973 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746974 type@var1557 ==@expr1073746975 eIf ||@expr1073746976 type@var1557 ==@expr1073746977 eElse ||@expr1073746978
1117: type@var1557 ==@expr1073746979 eFor ||@expr1073746980 type@var1557 ==@expr1073746981 eWhile ||@expr1073746982 type@var1557 ==@expr1073746983 eDo ||@expr1073746984
1118: type@var1557 ==@expr1073746985 eSwitch ||@expr1073746986 type@var1557 ==@expr1073746987 eUnconditional ||@expr1073746988
1119: type@var1557 ==@expr1073746989 eTry ||@expr1073746990 type@var1557 ==@expr1073746991 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1577 , bool requireConst@var1578 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1579 , bool isC@var1580 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1581 ) {
1135: return const_cast < Scope *@expr5168 > (@expr1073746993 const_cast < const Scope *@expr5168 > (@expr1073746995 this@expr1073746996 ) .@expr1073746997 findRecordInNestedList (@expr1073746998 name@var1581 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1582 ) const ;
1139: Type * findType ( const std :: string & name@var1583 ) {
1140: return const_cast < Type *@expr5175 > (@expr1073747000 const_cast < const Scope *@expr5175 > (@expr1073747002 this@expr1073747003 ) .@expr1073747004 findType (@expr1073747005 name@var1583 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1584 ) ;
1148:
1149: void addVariable ( const Token * token_@var1585 , const Token * start_@var1586 ,
1150: const Token * end_@var1587 , AccessControl access_@var1588 , const Type * type_@var1589 ,
1151: const Scope * scope_@var1590 , const Settings * settings@var1591 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1592 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1593 ) {
1159: functionList@var1549 .@expr1073747006 push_back (@expr1073747007 func@var1593 ) ;
1160:
1161: const Function * back@var1594 ; back@var1594 =@expr1073747008 &@expr1073747009 functionList@var1549 .@expr1073747010 back (@expr1073747011 ) ;
1162:
1163: functionMap@var1550 .@expr1073747012 insert (@expr1073747013 make_pair (@expr1073747014 back@var1594 .@expr1073747015 tokenDef@var1595 .@expr1073747016 str (@expr1073747017 ) , back@var1594 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1596 , AccessControl varaccess@var1597 , const Settings * settings@var1598 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1599 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1600 , bool isCpp@var1601 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1602 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1603 , const Token * & vartok@var1604 , const Token * & typetok@var1605 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1606 , int args@var1607 , std :: vector < const Function * > & matches@var1608 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1609 , const Token * start@var1610 , const Token * end@var1611 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1612 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1613 ;
1239: int bits@var1614 ;
1240: int pointer@var1615 ;
1241: int constness@var1616 ;
1242: Reference reference@var1617 ; reference@var1617 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1618 ;
1245: const :: Type * smartPointerType@var1619 ;
1246: const Token * smartPointerTypeToken@var1620 ;
1247: const Library :: SmartPointer * smartPointer@var1621 ;
1248: const Library :: Container * container@var1622 ;
1249:
1250: const Token * containerTypeToken@var1623 ;
1251:
1252: std :: string originalTypeName@var1624 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1612 ( UNKNOWN_SIGN ) ,
1257: type@var1613 ( UNKNOWN_TYPE ) ,
1258: bits@var1614 ( 0 ) ,
1259: pointer@var1615 ( 0U ) ,
1260: constness@var1616 ( 0U ) ,
1261: typeScope@var1618 ( nullptr ) ,
1262: smartPointerType@var1619 ( nullptr ) ,
1263: smartPointerTypeToken@var1620 ( nullptr ) ,
1264: smartPointer@var1621 ( nullptr ) ,
1265: container@var1622 ( nullptr ) ,
1266: containerTypeToken@var1623 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1625 , enum Type t@var1626 , int p@var1627 )
1269: : sign@var1612 ( s@var1625 ) ,
1270: type@var1613 ( t@var1626 ) ,
1271: bits@var1614 ( 0 ) ,
1272: pointer@var1615 ( p@var1627 ) ,
1273: constness@var1616 ( 0U ) ,
1274: typeScope@var1618 ( nullptr ) ,
1275: smartPointerType@var1619 ( nullptr ) ,
1276: smartPointerTypeToken@var1620 ( nullptr ) ,
1277: smartPointer@var1621 ( nullptr ) ,
1278: container@var1622 ( nullptr ) ,
1279: containerTypeToken@var1623 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1628 , enum Type t@var1629 , int p@var1630 , int c@var1631 )
1282: : sign@var1612 ( s@var1628 ) ,
1283: type@var1613 ( t@var1629 ) ,
1284: bits@var1614 ( 0 ) ,
1285: pointer@var1615 ( p@var1630 ) ,
1286: constness@var1616 ( c@var1631 ) ,
1287: typeScope@var1618 ( nullptr ) ,
1288: smartPointerType@var1619 ( nullptr ) ,
1289: smartPointerTypeToken@var1620 ( nullptr ) ,
1290: smartPointer@var1621 ( nullptr ) ,
1291: container@var1622 ( nullptr ) ,
1292: containerTypeToken@var1623 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1632 , enum Type t@var1633 , int p@var1634 , int c@var1635 , const std :: string & otn@var1636 )
1295: : sign@var1612 ( s@var1632 ) ,
1296: type@var1613 ( t@var1633 ) ,
1297: bits@var1614 ( 0 ) ,
1298: pointer@var1615 ( p@var1634 ) ,
1299: constness@var1616 ( c@var1635 ) ,
1300: typeScope@var1618 ( nullptr ) ,
1301: smartPointerType@var1619 ( nullptr ) ,
1302: smartPointerTypeToken@var1620 ( nullptr ) ,
1303: smartPointer@var1621 ( nullptr ) ,
1304: container@var1622 ( nullptr ) ,
1305: containerTypeToken@var1623 ( nullptr ) ,
1306: originalTypeName@var1624 ( otn@var1636 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1637 , const Settings * settings@var1638 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1639 , bool longType@var1640 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1641 , const ValueType * func@var1642 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1643 , const Variable * callVar@var1644 , const Variable * funcVar@var1645 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073747018 type@var1613 >=@expr1073747019 ValueType ::@expr1073747020 Type ::@expr1073747021 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073747022 type@var1613 >=@expr1073747023 ValueType ::@expr5200 Type ::@expr1073747025 BOOL &&@expr1073747026 type@var1613 <=@expr1073747027 ValueType ::@expr5200 Type ::@expr1073747029 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073747030 type@var1613 >=@expr1073747031 ValueType ::@expr5208 Type ::@expr1073747033 FLOAT &&@expr1073747034 type@var1613 <=@expr1073747035 ValueType ::@expr5208 Type ::@expr1073747037 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1646 , const Settings * settings@var1647 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1618 &&@expr1073747038 typeScope@var1618 .@expr1073747039 type@var1648 ==@expr1073747040 Scope ::@expr1073747041 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1649 , bool p@var1650 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1651 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1652 , const Settings * settings@var1653 , ErrorLogger * errorLogger@var1654 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1655 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1656 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1657 ;
1359:
1360:
1361: std :: list < Type > typeList@var1658 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1659 , const Token * typeTok@var1660 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1661 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1662 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1663 , const Scope * startScope@var1664 , bool lookOutside@var1665 = false ) const ;
1382: Type * findType ( const Token * startTok@var1666 , Scope * startScope@var1667 , bool lookOutside@var1668 = false ) const {
1383: return const_cast < Type *@expr5218 > (@expr1073747043 this@expr1073747044 .@expr1073747045 findType (@expr1073747046 startTok@var1666 , const_cast < const Scope *@expr5218 > (@expr1073747048 startScope@var1667 ) , lookOutside@var1668 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1669 , const Scope * startScope@var1670 ) const ;
1387: Scope * findScope ( const Token * tok@var1671 , Scope * startScope@var1672 ) const {
1388: return const_cast < Scope *@expr5225 > (@expr1073747050 this@expr1073747051 .@expr1073747052 findScope (@expr1073747053 tok@var1671 , const_cast < const Scope *@expr5225 > (@expr1073747055 startScope@var1672 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1673 ) const {
1392: return varid@var1673 <@expr1073747056 mVariableList@var1730 .@expr1073747057 size (@expr1073747058 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1674 ) const {
1396: return mVariableList@var1730 .@expr1073747059 at (@expr1073747060 varId@var1674 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1730 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1675 , const std :: string & type@var1676 , const std :: string & msg@var1677 ) const ;
1407:
1408: void printOut ( const char * title@var1678 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1679 , const char * indent@var1680 ) const ;
1410: void printXml ( std :: ostream & out@var1681 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1682 , Token * tokens@var1683 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1684 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1685 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1686 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1687 , const Token * * tok@var1688 , const Token * argStart@var1689 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1690 , const Token * tok@var1691 , const Token * argStart@var1692 , const Token * funcStart@var1693 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1694 , const Token * & tok@var1695 , const Token * argStart@var1696 , const Token * funcStart@var1697 ) ;
1469: void addNewFunction ( Scope * * scope@var1698 , const Token * * tok@var1699 ) ;
1470: bool isFunction ( const Token * tok@var1700 , const Scope * outerScope@var1701 , const Token * * funcStart@var1702 , const Token * * argStart@var1703 , const Token * * declEnd@var1704 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1705 , const Scope * startScope@var1706 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1707 , const Scope * scope@var1708 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1709 , const Scope * ns@var1710 , const std :: string & path@var1711 , int path_length@var1712 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1713 , const Token * typeTok@var1714 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1715 , const Token * vartok@var1716 , Token * membertok@var1717 , const Variable * membervar@var1718 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1719 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1720 ) const ;
1485:
1486: void setValueType ( Token * tok@var1721 , const ValueType & valuetype@var1722 ) ;
1487: void setValueType ( Token * tok@var1723 , const Variable & var@var1724 ) ;
1488: void setValueType ( Token * tok@var1725 , const Enumerator & enumerator@var1726 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1727 ;
1491: const Settings * mSettings@var1728 ;
1492: ErrorLogger * mErrorLogger@var1729 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1730 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1731 ;
1499:
1500: bool mIsCpp@var1732 ;
1501: ValueType :: Sign mDefaultSignedness@var1733 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1734 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1735 , const TFunc & visitor@var1736 )
52: {
53: if (@expr1073747061 !@expr1073747062 ast@var1735 ) {
54: return ; }
55:
56: std ::@expr1073747063 stack < T *@expr5240 , std ::@expr1073747065 vector < T *@expr5240 > > tokens@var1737 ;
57: T * tok@var1738 ; tok@var1738 =@expr1073747067 ast@var1735 ;
58: do {
59: ChildrenToVisit c@var1739 ; c@var1739 =@expr1073747068 visitor@var1736 (@expr1073747069 tok@var1738 ) ;
60:
61: if (@expr1073747070 c@var1739 ==@expr1073747071 ChildrenToVisit ::@expr1073747072 done ) {
62: break ; }
63: if (@expr1073747073 c@var1739 ==@expr1073747074 ChildrenToVisit ::@expr1073747075 op2 ||@expr1073747076 c@var1739 ==@expr5253 ChildrenToVisit ::@expr5254 op1_and_op2 ) {
64: T * t2@var1740 ; t2@var1740 =@expr1073747079 tok@var1738 .@expr1073747080 astOperand2 (@expr1073747081 ) ;
65: if (@expr1073747082 t2@var1740 ) {
66: tokens@var1737 .@expr5259 push (@expr1073747084 t2@var1740 ) ; }
67: }
68: if (@expr1073747085 c@var1739 ==@expr1073747086 ChildrenToVisit ::@expr1073747087 op1 ||@expr1073747088 c@var1739 ==@expr5253 ChildrenToVisit ::@expr5254 op1_and_op2 ) {
69: T * t1@var1741 ; t1@var1741 =@expr1073747091 tok@var1738 .@expr1073747092 astOperand1 (@expr1073747093 ) ;
70: if (@expr1073747094 t1@var1741 ) {
71: tokens@var1737 .@expr5259 push (@expr1073747096 t1@var1741 ) ; }
72: }
73:
74: if (@expr1073747097 tokens@var1737 .@expr1073747098 empty (@expr1073747099 ) ) {
75: break ; }
76:
77: tok@var1738 =@expr1073747100 tokens@var1737 .@expr1073747101 top (@expr1073747102 ) ;
78: tokens@var1737 .@expr1073747103 pop (@expr1073747104 ) ;
79: } while (@expr1073747105 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1742 , const std :: function < bool ( const Token * ) > & pred@var1743 ) ;
83: const Token * findExpression ( const int exprid@var1744 ,
84: const Token * start@var1745 ,
85: const Token * end@var1746 ,
86: const std :: function < bool ( const Token * ) > & pred@var1747 ) ;
87: const Token * findExpression ( const Token * start@var1748 , const int exprid@var1749 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1750 , const char * op@var1751 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1752 , const char * op@var1753 ) ;
91:
92: int astCount ( const Token * tok@var1754 , const char * op@var1755 , int depth@var1756 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1757 , const Token * tok@var1758 ) ;
95:
96: bool astHasVar ( const Token * tok@var1759 , int varid@var1760 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1761 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1762 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1763 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1764 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1765 , bool unknown@var1766 ) ;
107: bool astIsUnsigned ( const Token * tok@var1767 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1768 , bool unknown@var1769 ) ;
110:
111: bool astIsBool ( const Token * tok@var1770 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1771 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1772 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1773 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1774 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1775 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1776 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1777 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1778 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1779 , const std :: string & comp@var1780 , const std :: string & rhs@var1781 , const Token * * vartok@var1782 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1783 ) ;
140:
141: bool isTemporary ( bool cpp@var1784 , const Token * tok@var1785 , const Library * library@var1786 , bool unknown@var1787 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1788 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1789 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1790 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1791 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1792 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1793 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1794 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1795 ) ;
155: const Token * getParentLifetime ( bool cpp@var1796 , const Token * tok@var1797 , const Library * library@var1798 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1799 ) ;
158: bool astIsRHS ( const Token * tok@var1800 ) ;
159:
160: Token * getCondTok ( Token * tok@var1801 ) ;
161: const Token * getCondTok ( const Token * tok@var1802 ) ;
162:
163: Token * getInitTok ( Token * tok@var1803 ) ;
164: const Token * getInitTok ( const Token * tok@var1804 ) ;
165:
166: Token * getStepTok ( Token * tok@var1805 ) ;
167: const Token * getStepTok ( const Token * tok@var1806 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1807 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1808 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1809 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1810 ,
180: int * const varid@var1811 ,
181: bool * const knownInitValue@var1812 ,
182: long long * const initValue@var1813 ,
183: bool * const partialCond@var1814 ,
184: long long * const stepValue@var1815 ,
185: long long * const lastValue@var1816 ) ;
186:
187: bool precedes ( const Token * tok1@var1817 , const Token * tok2@var1818 ) ;
188: bool succeeds ( const Token * tok1@var1819 , const Token * tok2@var1820 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1821 , bool onVar@var1822 = true , int depth@var1823 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1824 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1825 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1826 ,
198: bool temporary@var1827 = true ,
199: bool inconclusive@var1828 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1829 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1830 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1831 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1832 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1833 , bool macro@var1834 , const Token * tok1@var1835 , const Token * tok2@var1836 , const Library & library@var1837 , bool pure@var1838 , bool followVar@var1839 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1840 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1841 , const Token * const tok2@var1842 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1843 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1844 , bool cpp@var1845 , const Token * const cond1@var1846 , const Token * const cond2@var1847 , const Library & library@var1848 , bool pure@var1849 , bool followVar@var1850 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1851 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1852 , const Token * const tok1@var1853 , const Token * const tok2@var1854 , const Library & library@var1855 , bool pure@var1856 , bool followVar@var1857 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1858 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1859 , const Library & library@var1860 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1861 , const Library & library@var1862 , bool pure@var1863 , bool cpp@var1864 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1865 , const Token * tok@var1866 , bool checkArrayAccess@var1867 = false , bool checkReference@var1868 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1869 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1870 , const Library * library@var1871 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1872 ,
238: const Library * library@var1873 = nullptr ,
239: const Token * * unknownFunc@var1874 = nullptr ,
240: bool functionScope@var1875 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1876 ,
244: const Variable * var@var1877 ,
245: Scope :: ScopeType type@var1878 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1879 , int & argn@var1880 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1881 , int & argn@var1882 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1883 , int argnr@var1884 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1885 , int indirect@var1886 , int varid@var1887 , const Settings * settings@var1888 , bool * inconclusive@var1889 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1890 , int indirect@var1891 , const Settings * settings@var1892 , bool * inconclusive@var1893 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1894 , const Token * end@var1895 , const int exprid@var1896 , bool globalvar@var1897 , const Settings * settings@var1898 , bool cpp@var1899 , int depth@var1900 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1901 , const Token * end@var1902 , int indirect@var1903 , const int exprid@var1904 , bool globalvar@var1905 , const Settings * settings@var1906 , bool cpp@var1907 , int depth@var1908 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1909 , int indirect@var1910 , const Settings * settings@var1911 , bool cpp@var1912 , int depth@var1913 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1914 , const Settings * settings@var1915 , bool cpp@var1916 , int depth@var1917 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1918 ,
283: const Token * end@var1919 ,
284: int indirect@var1920 ,
285: std :: vector < const Variable * > vars@var1921 ,
286: const Settings * settings@var1922 ,
287: bool cpp@var1923 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1924 , int indirect@var1925 , const Settings * settings@var1926 , bool cpp@var1927 ) ;
290: bool isThisChanged ( const Token * start@var1928 , const Token * end@var1929 , int indirect@var1930 , const Settings * settings@var1931 , bool cpp@var1932 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1933 , const Token * end@var1934 , int indirect@var1935 , const int exprid@var1936 , bool globalvar@var1937 , const Settings * settings@var1938 , bool cpp@var1939 , int depth@var1940 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1941 , const Token * end@var1942 , int indirect@var1943 , const int exprid@var1944 , bool globalvar@var1945 , const Settings * settings@var1946 , bool cpp@var1947 , int depth@var1948 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1949 ,
296: const Token * start@var1950 ,
297: const Token * end@var1951 ,
298: const Settings * settings@var1952 ,
299: bool cpp@var1953 ,
300: int depth@var1954 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1955 ,
303: const Token * tok@var1956 ,
304: int indirect@var1957 ,
305: bool globalvar@var1958 ,
306: const Settings * settings@var1959 ,
307: bool cpp@var1960 ,
308: int depth@var1961 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1962 , int varid@var1963 , bool * inconclusive@var1964 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1965 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1966 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1967 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1968 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1969 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1970 , const Function * f@var1971 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1972 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1973 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1974 ) ;
346: Token * findLambdaEndToken ( Token * first@var1975 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1976 , const Token * stream@var1977 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1978 , const Token * op@var1979 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1980 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1981 , const char * skipMatch@var1982 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1983 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1984 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1985 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1986 , const Library & library@var1987 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1988 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1989 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1990 , bool cpp@var1991 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1992 , const Library & library@var1993 ) : mCpp@var2026 ( cpp@var1992 ) , mLibrary@var2027 ( library@var1993 ) , mWhat@var2028 ( What :: Reassign ) , mValueFlowKnown@var2030 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1994 , const Token * lhs@var1995 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1996 , const Token * startToken@var1997 , const Token * endToken@var1998 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1999 , const Token * startToken@var2000 , const Token * endToken@var2001 ) ;
404:
405: struct KnownAndToken {
406: bool known@var2002 ;
407: const Token * token@var2003 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var2004 , const Token * startToken@var2005 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var2006 , bool * localOut@var2007 = nullptr , bool * unknownVarIdOut@var2008 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var2009 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var2010 ;
420: explicit Result ( Type type@var2011 ) : type@var2010 ( type@var2011 ) , token@var2014 ( nullptr ) { }
421: Result ( Type type@var2012 , const Token * token@var2013 ) : type@var2010 ( type@var2012 ) , token@var2014 ( token@var2013 ) { }
422: const Token * token@var2014 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var2015 , const Token * startToken@var2016 , const Token * endToken@var2017 ) ;
426: struct Result checkRecursive ( const Token * expr@var2018 , const Token * startToken@var2019 , const Token * endToken@var2020 , const std :: set < int > & exprVarIds@var2021 , bool local@var2022 , bool inInnerClass@var2023 , int depth@var2024 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var2025 ) const ;
430:
431: const bool mCpp@var2026 ;
432: const Library & mLibrary@var2027 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var2028 ;
434: std :: vector < KnownAndToken > mValueFlow@var2029 ;
435: bool mValueFlowKnown@var2030 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var2031 ) ;

##file cppcheck-2.8/lib/pathanalysis.h

1:
|
27:
28: class Library ;
29: class Scope ;
30: class Token ;
31:
32: struct PathAnalysis {
33: enum class Progress {
34: Continue ,
35: Break
36: } ;
37: PathAnalysis ( const Token * start@var2032 , const Library & library@var2033 )
38: : start@var2034 ( start@var2032 ) , library@var2035 ( & library@var2033 )
39: { }
40: const Token * start@var2034 ;
41: const Library * library@var2035 ;
42:
43: struct Info {
44: const Token * tok@var2036 ;
45: std :: list < std :: pair < const Token * , std :: string > > errorPath@var2037 ;
46: bool known@var2038 ;
47: } ;
48:
49: void forward ( const std :: function < Progress ( const Info & ) > & f@var2039 ) const ;
50:
51: Info forwardFind ( std :: function < bool ( const Info & ) > pred@var2040 ) const {
52: Info result@var2041 {@expr1073747106 } ;
53: forward (@expr1073747107 [@expr1073747108 &@expr5285 ] (@expr1073747110 const Info &@expr5285 info@var2042 ) {
54: if (@expr1073747112 pred@var2040 (@expr1073747113 info@var2042 ) ) {
55: result@var2041 =@expr1073747114 info@var2042 ;
56: return Progress ::@expr1073747115 Break ;
57: }
58: return Progress ::@expr1073747116 Continue ;
59: } ) ;
60: return result@var2041 ;
61: }
62: private:
63:
64: Progress forwardRecursive ( const Token * tok@var2043 , Info info@var2044 , const std :: function < PathAnalysis :: Progress ( const Info & ) > & f@var2045 ) const ;
65: Progress forwardRange ( const Token * startToken@var2046 , const Token * endToken@var2047 , Info info@var2048 , const std :: function < Progress ( const Info & ) > & f@var2049 ) const ;
66:
67: static const Scope * findOuterScope ( const Scope * scope@var2050 ) ;
68:
69: static std :: pair < bool , bool > checkCond ( const Token * tok@var2051 , bool & known@var2052 ) ;
70: } ;
71:
|
78:
79: bool reaches ( const Token * start@var2053 , const Token * dest@var2054 , const Library & library@var2055 , std :: list < std :: pair < const Token * , std :: string > > * errorPath@var2056 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2057 ) {
44: if (@expr1073747117 bit@var2057 >=@expr1073747118 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073747119 (@expr1073747120 1LL <<@expr1073747121 (@expr1073747122 bit@var2057 -@expr1073747123 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var2058 ) {
50: if (@expr1073747124 bit@var2058 >=@expr1073747125 64 ) {
51: return (@expr5302 ~@expr1073747127 0ULL ) >>@expr1073747128 1 ; }
52: return (@expr5302 1LL <<@expr1073747130 (@expr5302 bit@var2058 -@expr1073747132 1 ) ) -@expr1073747133 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var2059 ) const {
59: return value@var2059 >=@expr1073747134 min_value (@expr1073747135 int_bit@var2069 ) &&@expr1073747136 value@var2059 <=@expr1073747137 max_value (@expr1073747138 int_bit@var2069 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var2060 ) const {
63: unsigned long long intMax@var2061 ; intMax@var2061 =@expr1073747139 max_value (@expr1073747140 int_bit@var2069 ) ;
64: return value@var2060 <=@expr1073747141 intMax@var2061 ;
65: }
66:
67: bool isLongValue ( long long value@var2062 ) const {
68: return value@var2062 >=@expr1073747142 min_value (@expr1073747143 long_bit@var2070 ) &&@expr1073747144 value@var2062 <=@expr1073747145 max_value (@expr1073747146 long_bit@var2070 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var2063 ) const {
72: unsigned long long longMax@var2064 ; longMax@var2064 =@expr1073747147 max_value (@expr1073747148 long_bit@var2070 ) ;
73: return value@var2063 <=@expr1073747149 longMax@var2064 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var2065 ) const {
77: unsigned long long longLongMax@var2066 ; longLongMax@var2066 =@expr1073747150 max_value (@expr1073747151 long_long_bit@var2071 ) ;
78: return value@var2065 <=@expr1073747152 longLongMax@var2066 ;
79: }
80:
81: int char_bit@var2067 ;
82: int short_bit@var2068 ;
83: int int_bit@var2069 ;
84: int long_bit@var2070 ;
85: int long_long_bit@var2071 ;
86:
87:
88: int sizeof_bool@var2072 ;
89: int sizeof_short@var2073 ;
90: int sizeof_int@var2074 ;
91: int sizeof_long@var2075 ;
92: int sizeof_long_long@var2076 ;
93: int sizeof_float@var2077 ;
94: int sizeof_double@var2078 ;
95: int sizeof_long_double@var2079 ;
96: int sizeof_wchar_t@var2080 ;
97: int sizeof_size_t@var2081 ;
98: int sizeof_pointer@var2082 ;
99:
100: char defaultSign@var2083 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var2084 ;
115:
116:
117: bool platform ( PlatformType type@var2085 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var2086 [ ] , const std :: string & filename@var2087 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var2088 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var2084 ==@expr1073747153 Win32A ||@expr1073747154
136: platformType@var2084 ==@expr1073747155 Win32W ||@expr1073747156
137: platformType@var2084 ==@expr1073747157 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073747158 platformType@var2084 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var2089 ) {
145: switch (@expr1073747159 pt@var2089 ) {
146: case Unspecified :@expr5336 ;
147: return "Unspecified" ;
148: case Native :@expr5336 ;
149: return "Native" ;
150: case Win32A :@expr5336 ;
151: return "win32A" ;
152: case Win32W :@expr5336 ;
153: return "win32W" ;
154: case Win64 :@expr5336 ;
155: return "win64" ;
156: case Unix32 :@expr5336 ;
157: return "unix32" ;
158: case Unix64 :@expr5336 ;
159: return "unix64" ;
160: case PlatformFile :@expr5336 ;
161: return "platformFile" ;
162: default :@expr5336 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073747169 char_bit@var2067 +@expr1073747170 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073747171 char_bit@var2067 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073747172 char_bit@var2067 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var2090 , const std :: string & rhs@var2091 ) const {
41: return caseInsensitiveStringCompare (@expr1073747173 lhs@var2090 , rhs@var2091 ) <@expr1073747174 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var2099 ( cppcheck :: Platform :: Unspecified ) , msc@var2100 ( false ) , useMfc@var2101 ( false ) { }
67: std :: string cfg@var2092 ;
68: std :: string filename@var2093 ;
69: std :: string defines@var2094 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var2094 +@expr1073747175 (@expr1073747176 msc@var2100 ?@expr1073747177 ";_MSC_VER=1900" :@expr1073747178 "" ) +@expr1073747179 (@expr1073747180 useMfc@var2101 ?@expr1073747181 ";__AFXWIN_H__=1" :@expr1073747182 "" ) ;
72: }
73: std :: set < std :: string > undefs@var2095 ;
74: std :: list < std :: string > includePaths@var2096 ;
75: std :: list < std :: string > systemIncludePaths@var2097 ;
76: std :: string standard@var2098 ;
77: cppcheck :: Platform :: PlatformType platformType@var2099 ;
78: bool msc@var2100 ;
79: bool useMfc@var2101 ;
80:
81: void parseCommand ( std :: string command@var2102 ) ;
82: void setDefines ( std :: string defs@var2103 ) ;
83: void setIncludePaths ( const std :: string & basepath@var2104 , const std :: list < std :: string > & in@var2105 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2106 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var2107 ;
86: Type projectType@var2108 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var2109 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var2110 ;
97: std :: vector < std :: string > pathNames@var2111 ;
98: std :: list < std :: string > libraries@var2112 ;
99: std :: list < std :: string > excludedPaths@var2113 ;
100: std :: list < std :: string > checkVsConfigs@var2114 ;
101: std :: string projectFile@var2115 ;
102: std :: string platform@var2116 ;
103: } ; struct Anonymous4 guiProject@var2117 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var2118 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var2119 ) ;
107:
108: Type import ( const std :: string & filename@var2120 , Settings * settings@var2121 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var2122 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var2123 , Settings * settings@var2124 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2125 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2126 , const std :: string & path@var2127 , const std :: vector < std :: string > & fileFilters@var2128 ) ;
115: bool importVcxproj ( const std :: string & filename@var2129 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2130 , const std :: string & additionalIncludeDirectories@var2131 , const std :: vector < std :: string > & fileFilters@var2132 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2133 ) ;
117:
118: static void printError ( const std :: string & message@var2134 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2135 ) ;
121:
122: std :: string mPath@var2136 ;
123: std :: set < std :: string > mAllVSConfigs@var2137 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2138 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2139 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2140 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2141 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2142 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2143 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2144 [ 7 ] = "parser" ;
135: const char BugHunting@var2145 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2146 [ 11 ] = "includedir" ;
137: const char DirElementName@var2147 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2148 [ 5 ] = "name" ;
139: const char DefinesElementName@var2149 [ 8 ] = "defines" ;
140: const char DefineName@var2150 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2151 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2152 [ 10 ] = "undefines" ;
143: const char UndefineName@var2153 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2154 [ 6 ] = "paths" ;
145: const char PathName@var2155 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2156 [ 5 ] = "name" ;
147: const char RootPathName@var2157 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2158 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2159 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2160 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2161 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2162 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2163 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2164 [ 5 ] = "name" ;
155: const char FunctionContracts@var2165 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2166 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2167 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2168 [ 8 ] = "library" ;
159: const char PlatformElementName@var2169 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2170 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2171 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2172 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2173 [ 7 ] = "addons" ;
164: const char ToolElementName@var2174 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2175 [ 6 ] = "tools" ;
166: const char TagsElementName@var2176 [ 5 ] = "tags" ;
167: const char TagElementName@var2177 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2178 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2179 [ 4 ] = "tag" ;
170: const char WarningElementName@var2180 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2181 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2182 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2183 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2184 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2185 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2186 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2187 [ 11 ] = "clang-tidy" ;
178: const char Name@var2188 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2189 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2190 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var2191 ;
43: std :: string errorId@var2192 ;
44: void setFileName ( const std :: string & s@var2193 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var2197 ;
47: }
48: int lineNumber@var2194 ;
49: Certainty :: CertaintyLevel certainty@var2195 ;
50: std :: string symbolNames@var2196 ;
51: private:
52: std :: string mFileName@var2197 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2231 ( NO_LINE ) , hash@var2233 ( 0 ) , thisAndNextLine@var2234 ( false ) , matched@var2235 ( false ) , checked@var2236 ( false ) { }
57: Suppression ( const Suppression & other@var2198 ) {
58: *@expr1073747183 this@expr1073747184 =@expr1073747185 other@var2198 ;
59: }
60: Suppression ( const std :: string & id@var2199 , const std :: string & file@var2200 , int line@var2201 = NO_LINE ) : errorId@var2229 ( id@var2199 ) , fileName@var2230 ( file@var2200 ) , lineNumber@var2231 ( line@var2201 ) , hash@var2233 ( 0 ) , thisAndNextLine@var2234 ( false ) , matched@var2235 ( false ) , checked@var2236 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var2202 ) {
63: errorId@var2229 =@expr1073747186 other@var2202 .@expr1073747187 errorId@var2203 ;
64: fileName@var2230 =@expr1073747188 other@var2202 .@expr1073747189 fileName@var2204 ;
65: lineNumber@var2231 =@expr1073747190 other@var2202 .@expr1073747191 lineNumber@var2205 ;
66: symbolName@var2232 =@expr1073747192 other@var2202 .@expr1073747193 symbolName@var2206 ;
67: hash@var2233 =@expr1073747194 other@var2202 .@expr1073747195 hash@var2207 ;
68: thisAndNextLine@var2234 =@expr1073747196 other@var2202 .@expr1073747197 thisAndNextLine@var2208 ;
69: matched@var2235 =@expr1073747198 other@var2202 .@expr1073747199 matched@var2209 ;
70: checked@var2236 =@expr1073747200 other@var2202 .@expr1073747201 checked@var2210 ;
71: return *@expr1073747202 this@expr1073747203 ;
72: }
73:
74: bool operator< ( const Suppression & other@var2211 ) const {
75: if (@expr1073747204 errorId@var2229 !=@expr1073747205 other@var2211 .@expr5382 errorId@var2212 ) {
76: return errorId@var2229 <@expr1073747207 other@var2211 .@expr5382 errorId@var2212 ; }
77: if (@expr1073747209 lineNumber@var2231 <@expr1073747210 other@var2211 .@expr1073747211 lineNumber@var2213 ) {
78: return true ; }
79: if (@expr1073747212 fileName@var2230 !=@expr1073747213 other@var2211 .@expr5390 fileName@var2214 ) {
80: return fileName@var2230 <@expr1073747215 other@var2211 .@expr5390 fileName@var2214 ; }
81: if (@expr1073747217 symbolName@var2232 !=@expr1073747218 other@var2211 .@expr5395 symbolName@var2215 ) {
82: return symbolName@var2232 <@expr1073747220 other@var2211 .@expr5395 symbolName@var2215 ; }
83: if (@expr1073747222 hash@var2233 !=@expr1073747223 other@var2211 .@expr5400 hash@var2216 ) {
84: return hash@var2233 <@expr1073747225 other@var2211 .@expr5400 hash@var2216 ; }
85: if (@expr1073747227 thisAndNextLine@var2234 !=@expr1073747228 other@var2211 .@expr1073747229 thisAndNextLine@var2217 ) {
86: return thisAndNextLine@var2234 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2218 , std :: string * errorMessage@var2219 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2220 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2221 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073747231 fileName@var2230 .@expr1073747232 empty (@expr1073747233 ) &&@expr1073747234 fileName@var2230 .@expr1073747235 find_first_of (@expr1073747236 "?*" ) ==@expr1073747237 std ::@expr1073747238 string ::@expr1073747239 npos@expr1073747230 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2222 ) const {
109: return errorId@var2229 ==@expr1073747240 other@var2222 .@expr1073747241 errorId@var2223 &&@expr1073747242
110: fileName@var2230 ==@expr1073747243 other@var2222 .@expr1073747244 fileName@var2224 &&@expr1073747245
111: lineNumber@var2231 ==@expr1073747246 other@var2222 .@expr1073747247 lineNumber@var2225 &&@expr1073747248
112: symbolName@var2232 ==@expr1073747249 other@var2222 .@expr1073747250 symbolName@var2226 &&@expr1073747251
113: hash@var2233 ==@expr1073747252 other@var2222 .@expr1073747253 hash@var2227 &&@expr1073747254
114: thisAndNextLine@var2234 ==@expr1073747255 other@var2222 .@expr1073747256 thisAndNextLine@var2228 ;
115: }
116:
117: std :: string errorId@var2229 ;
118: std :: string fileName@var2230 ;
119: int lineNumber@var2231 ;
120: std :: string symbolName@var2232 ;
121: unsigned long hash@var2233 ;
122: bool thisAndNextLine@var2234 ;
123: bool matched@var2235 ;
124: bool checked@var2236 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2237 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2238 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2239 , std :: string * errorMessage@var2240 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2241 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2242 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2243 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2244 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2245 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2246 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2247 , const bool unusedFunctionChecking@var2248 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2249 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2250 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2251 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2252 , std :: clock_t clocks@var2253 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2254 ;
45: long mNumberOfResults@var2255 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2254 ( 0 )
49: , mNumberOfResults@var2255 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2256 =@expr1073747258 (@expr1073747259 double ) (@expr1073747260 (@expr1073747261 unsigned long ) mClocks@var2254 ) /@expr1073747262 (@expr1073747263 double ) CLOCKS_PER_SEC@expr1073747257 ;
53: return ret@var2256 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2257 ) const ;
62: void addResults ( const std :: string & str@var2258 , std :: clock_t clocks@var2259 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2260 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2261 , SHOWTIME_MODES showtimeMode@var2262 , TimerResultsIntf * timerResults@var2263 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2264 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2265 ;
79: TimerResultsIntf * mTimerResults@var2266 ;
80: std :: clock_t mStart@var2267 ;
81: const SHOWTIME_MODES mShowTimeMode@var2268 ;
82: bool mStopped@var2269 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2270 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2271 ;
103:
104:
105: std :: string addonPython@var2272 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2273 ;
109:
110:
111: std :: string buildDir@var2274 ;
112:
113:
114: bool checkAllConfigurations@var2275 ;
115:
116:
117: bool checkConfiguration@var2276 ;
118:
|
121:
122: bool checkHeaders@var2277 ;
123:
124:
125: bool checkLibrary@var2278 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2279 ;
129:
130:
131: bool checkUnusedTemplates@var2280 ;
132:
133:
134: bool clang@var2281 ;
135:
136:
137: std :: string clangExecutable@var2282 ;
138:
139:
140: bool clangTidy@var2283 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2284 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2285 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2286 ;
150:
151:
152: bool daca@var2287 ;
153:
154:
155: bool debugnormal@var2288 ;
156:
157:
158: bool debugSimplified@var2289 ;
159:
160:
161: bool debugtemplate@var2290 ;
162:
163:
164: bool debugwarnings@var2291 ;
165:
166:
167: bool dump@var2292 ;
168: std :: string dumpFile@var2293 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2294 ;
176:
177:
178: bool exceptionHandling@var2295 ;
179:
180:
181: std :: string exename@var2296 ;
182:
183:
184:
185: int exitCode@var2297 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2298 ;
189:
190:
191: bool force@var2299 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2300 ;
196:
197:
198: bool inlineSuppressions@var2301 ;
199:
200:
201:
202: unsigned int jobs@var2302 ;
203:
|
206:
207: bool jointSuppressionReport@var2303 ;
208:
209:
210: std :: list < std :: string > libraries@var2304 ;
211:
212:
213: Library library@var2305 ;
214:
215:
216:
217: int loadAverage@var2306 ;
218:
|
221:
222: int maxConfigs@var2307 ;
223:
224:
225: int maxCtuDepth@var2308 ;
226:
227:
228: int maxTemplateRecursion@var2309 ;
229:
230:
231: Suppressions nofail@var2310 ;
232:
233:
234: Suppressions nomsg@var2311 ;
235:
236:
237: std :: string outputFile@var2312 ;
238:
239:
240: std :: string plistOutput@var2313 ;
241:
242:
243: bool preprocessOnly@var2314 ;
244:
245: ImportProject project@var2315 ;
246:
247:
248: bool quiet@var2316 ;
249:
250:
251: bool relativePaths@var2317 ;
252:
253:
254: bool reportProgress@var2318 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2319 ( "simple" )
261: , id@var2321 ( "rule" )
262: , severity@var2323 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2319 ;
266: std :: string pattern@var2320 ;
267: std :: string id@var2321 ;
268: std :: string summary@var2322 ;
269: Severity :: SeverityType severity@var2323 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2324 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2330 ( false ) , externalFunctions@var2331 ( false ) , internalFunctions@var2332 ( false ) , externalVariables@var2333 ( false ) { }
281:
282: static const char XmlRootName@var2325 [ ] ;
283: static const char XmlClasses@var2326 [ ] ;
284: static const char XmlExternalFunctions@var2327 [ ] ;
285: static const char XmlInternalFunctions@var2328 [ ] ;
286: static const char XmlExternalVariables@var2329 [ ] ;
287:
288: void clear ( ) {
289: classes@var2330 =@expr1073747264 externalFunctions@var2331 =@expr1073747265 internalFunctions@var2332 =@expr1073747266 externalVariables@var2333 =@expr1073747267 false ;
290: }
291:
|
297:
298: bool classes@var2330 ;
299:
|
304:
305: bool externalFunctions@var2331 ;
306:
|
310:
311: bool internalFunctions@var2332 ;
312:
|
316:
317: bool externalVariables@var2333 ;
318: } ;
319:
320: SafeChecks safeChecks@var2334 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2335 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2336 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2337 ;
325:
326:
327: SHOWTIME_MODES showtime@var2338 ;
328:
329:
330: Standards standards@var2339 ;
331:
332:
333:
334: std :: string templateFormat@var2340 ;
335:
336:
337:
338: std :: string templateLocation@var2341 ;
339:
340:
341: std :: string userDefines@var2342 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2343 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2344 ;
348:
349:
350: bool verbose@var2345 ;
351:
352:
353: bool xml@var2346 ;
354:
355:
356: int xml_version@var2347 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2348 ) const {
363: for (@expr1073747268 const std ::@expr1073747269 string &@expr1073747270 configExcludePath@var2349 :@expr1073747271 configExcludePaths@var2284 ) {
364: if (@expr1073747272 file@var2348 .@expr1073747273 length (@expr1073747274 ) >=@expr1073747275 configExcludePath@var2349 .@expr5452 length (@expr5453 ) &&@expr1073747278 file@var2348 .@expr1073747279 compare (@expr1073747280 0 , configExcludePath@var2349 .@expr5452 length (@expr5453 ) , configExcludePath@var2349 ) ==@expr1073747283 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2350 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2351 , bool inconclusiveCheck@var2352 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073747284 find (@expr1073747285 libraries@var2304 .@expr1073747286 begin (@expr1073747287 ) , libraries@var2304 .@expr5464 end (@expr5465 ) , "posix" ) !=@expr1073747290 libraries@var2304 .@expr5464 end (@expr5465 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2353 = true ) {
392: Settings ::@expr1073747293 mTerminated@var2270 =@expr1073747294 t@var2353 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073747295 mTerminated@var2270 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2354 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var2355 , const Color & c@var2356 ) ;
42:
43: std :: string toString ( const Color & c@var2357 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var2358 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var2359 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var2360 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var2361 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var2362 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var2378 ( 0 ) , line@var2379 ( 0 ) , column@var2380 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var2363 , int line@var2364 , unsigned int column@var2365 )
73: : fileIndex@var2378 ( 0 ) , line@var2379 ( line@var2364 ) , column@var2380 ( column@var2365 ) , mOrigFileName@var2382 ( file@var2363 ) , mFileName@var2383 ( file@var2363 ) { }
74:
75: FileLocation ( const std :: string & file@var2366 , const std :: string & info@var2367 , int line@var2368 , unsigned int column@var2369 )
76: : fileIndex@var2378 ( 0 ) , line@var2379 ( line@var2368 ) , column@var2380 ( column@var2369 ) , mOrigFileName@var2382 ( file@var2366 ) , mFileName@var2383 ( file@var2366 ) , mInfo@var2384 ( info@var2367 ) { }
77:
78: FileLocation ( const Token * tok@var2370 , const TokenList * tokenList@var2371 ) ;
79: FileLocation ( const Token * tok@var2372 , const std :: string & info@var2373 , const TokenList * tokenList@var2374 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var2375 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var2376 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var2377 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var2378 ;
107: int line@var2379 ;
108: unsigned int column@var2380 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var2384 ;
112: }
113: void setinfo ( const std :: string & i@var2381 ) {
114: mInfo@var2384 =@expr1073747296 i@var2381 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var2382 ;
119: std :: string mFileName@var2383 ;
120: std :: string mInfo@var2384 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var2385 ,
124: const std :: string & file1@var2386 ,
125: Severity :: SeverityType severity@var2387 ,
126: const std :: string & msg@var2388 ,
127: const std :: string & id@var2389 , Certainty :: CertaintyLevel certainty@var2390 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var2391 ,
129: const std :: string & file1@var2392 ,
130: Severity :: SeverityType severity@var2393 ,
131: const std :: string & msg@var2394 ,
132: const std :: string & id@var2395 ,
133: const CWE & cwe@var2396 ,
134: Certainty :: CertaintyLevel certainty@var2397 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var2398 ,
136: const TokenList * list@var2399 ,
137: Severity :: SeverityType severity@var2400 ,
138: const std :: string & id@var2401 ,
139: const std :: string & msg@var2402 ,
140: Certainty :: CertaintyLevel certainty@var2403 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var2404 ,
142: const TokenList * list@var2405 ,
143: Severity :: SeverityType severity@var2406 ,
144: const std :: string & id@var2407 ,
145: const std :: string & msg@var2408 ,
146: const CWE & cwe@var2409 ,
147: Certainty :: CertaintyLevel certainty@var2410 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var2411 ,
149: const TokenList * tokenList@var2412 ,
150: Severity :: SeverityType severity@var2413 ,
151: const char id@var2414 [ ] ,
152: const std :: string & msg@var2415 ,
153: const CWE & cwe@var2416 ,
154: Certainty :: CertaintyLevel certainty@var2417 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var2418 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var2419 ,
176: const std :: string & templateFormat@var2420 = emptyString@var1 ,
177: const std :: string & templateLocation@var2421 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var2422 ) ;
181:
182: std :: list < FileLocation > callStack@var2423 ;
183: std :: string id@var2424 ;
184:
185:
186: std :: string file0@var2425 ;
187:
188: std :: string function@var2426 ;
189:
190: bool incomplete@var2427 ;
191:
192: Severity :: SeverityType severity@var2428 ;
193: CWE cwe@var2429 ;
194: Certainty :: CertaintyLevel certainty@var2430 ;
195:
196:
197: unsigned long hash@var2431 ;
198:
199:
200: void setmsg ( const std :: string & msg@var2432 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var2434 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var2435 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var2436 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var2433 ) ;
221:
222:
223: std :: string mShortMessage@var2434 ;
224:
225:
226: std :: string mVerboseMessage@var2435 ;
227:
228:
229: std :: string mSymbolNames@var2436 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var2437 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073747297 plistFile@var2437 .@expr1073747298 is_open (@expr1073747299 ) ) {
243: plistFile@var2437 <<@expr1073747300 ErrorLogger ::@expr1073747301 plistFooter (@expr1073747302 ) ;
244: plistFile@var2437 .@expr1073747303 close (@expr1073747304 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var2438 , Color c@var2439 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var2440 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var2441 , const char stage@var2442 [ ] , const unsigned long value@var2443 ) {
271: (@expr1073747305 void ) filename@var2441 ;
272: (@expr1073747306 void ) stage@var2442 ;
273: (@expr1073747307 void ) value@var2443 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var2444 ) {
281: reportErr (@expr1073747308 msg@var2444 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var2445 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var2446 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var2447 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var2448 , const std :: vector < std :: string > & files@var2449 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var2450 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var2451 , const std :: string & from@var2452 , const std :: string & to@var2453 ) ;

##file cppcheck-2.8/lib/ctu.h

1:
|
36:
37: class Function ;
38: class Settings ;
39: class Token ;
40: class Tokenizer ;
41:
42: namespace tinyxml2 {
43: class XMLElement ;
44: }
45:
|
50:
51: namespace CTU {
52: class FileInfo : public Check :: FileInfo {
53: public:
54: enum class InvalidValueType { null , uninit , bufferOverflow } ;
55:
56: std :: string toString ( ) const override ;
57:
58: struct Location {
59: Location ( ) = default ;
60: Location ( const Tokenizer * tokenizer@var2454 , const Token * tok@var2455 ) ;
61: Location ( const std :: string & fileName@var2456 , int lineNumber@var2457 , int column@var2458 ) : fileName@var2459 ( fileName@var2456 ) , lineNumber@var2460 ( lineNumber@var2457 ) , column@var2461 ( column@var2458 ) { }
62: std :: string fileName@var2459 ;
63: int lineNumber@var2460 { } ;
64: int column@var2461 { } ;
65: } ;
66:
67: struct UnsafeUsage {
68: UnsafeUsage ( ) = default ;
69: UnsafeUsage ( const std :: string & myId@var2462 , int myArgNr@var2463 , const std :: string & myArgumentName@var2464 , const Location & location@var2465 , long long value@var2466 ) : myId@var2467 ( myId@var2462 ) , myArgNr@var2468 ( myArgNr@var2463 ) , myArgumentName@var2469 ( myArgumentName@var2464 ) , location@var2470 ( location@var2465 ) , value@var2471 ( value@var2466 ) { }
70: std :: string myId@var2467 ;
71: int myArgNr@var2468 { } ;
72: std :: string myArgumentName@var2469 ;
73: Location location@var2470 ;
74: long long value@var2471 { } ;
75: std :: string toString ( ) const ;
76: } ;
77:
78: class CallBase {
79: public:
80: CallBase ( ) = default ;
81: CallBase ( const std :: string & callId@var2472 , int callArgNr@var2473 , const std :: string & callFunctionName@var2474 , const Location & loc@var2475 )
82: : callId@var2478 ( callId@var2472 ) , callArgNr@var2479 ( callArgNr@var2473 ) , callFunctionName@var2480 ( callFunctionName@var2474 ) , location@var2481 ( loc@var2475 )
83: { }
84: CallBase ( const Tokenizer * tokenizer@var2476 , const Token * callToken@var2477 ) ;
85: virtual ~ CallBase ( ) { }
86: std :: string callId@var2478 ;
87: int callArgNr@var2479 { } ;
88: std :: string callFunctionName@var2480 ;
89: Location location@var2481 ;
90: protected:
91: std :: string toBaseXmlString ( ) const ;
92: bool loadBaseFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2482 ) ;
93: } ;
94:
95: class FunctionCall : public CallBase {
96: public:
97: std :: string callArgumentExpression@var2483 ;
98: long long callArgValue@var2484 ;
99: ValueFlow :: Value :: ValueType callValueType@var2485 ;
100: std :: vector < ErrorMessage :: FileLocation > callValuePath@var2486 ;
101: bool warning@var2487 ;
102:
103: std :: string toXmlString ( ) const ;
104: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2488 ) ;
105: } ;
106:
107: class NestedCall : public CallBase {
108: public:
109: NestedCall ( ) = default ;
110:
111: NestedCall ( const std :: string & myId@var2489 , int myArgNr@var2490 , const std :: string & callId@var2491 , int callArgnr@var2492 , const std :: string & callFunctionName@var2493 , const Location & location@var2494 )
112: : CallBase ( callId@var2491 , callArgnr@var2492 , callFunctionName@var2493 , location@var2494 ) ,
113: myId@var2499 ( myId@var2489 ) ,
114: myArgNr@var2500 ( myArgNr@var2490 ) { }
115:
116: NestedCall ( const Tokenizer * tokenizer@var2495 , const Function * myFunction@var2496 , const Token * callToken@var2497 ) ;
117:
118: std :: string toXmlString ( ) const ;
119: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2498 ) ;
120:
121: std :: string myId@var2499 ;
122: int myArgNr@var2500 { } ;
123: } ;
124:
125: std :: list < FunctionCall > functionCalls@var2501 ;
126: std :: list < NestedCall > nestedCalls@var2502 ;
127:
128: void loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2503 ) ;
129: std :: map < std :: string , std :: list < const CallBase * > > getCallsMap ( ) const ;
130:
131: static std :: list < ErrorMessage :: FileLocation > getErrorPath ( InvalidValueType invalidValue@var2504 ,
132: const UnsafeUsage & unsafeUsage@var2505 ,
133: const std :: map < std :: string , std :: list < const CallBase * > > & callsMap@var2506 ,
134: const char info@var2507 [ ] ,
135: const FunctionCall * * const functionCallPtr@var2508 ,
136: bool warning@var2509 ) ;
137: } ;
138:
139: extern int maxCtuDepth@var2510 ;
140:
141: std :: string toString ( const std :: list < FileInfo :: UnsafeUsage > & unsafeUsage@var2511 ) ;
142:
143: std :: string getFunctionId ( const Tokenizer * tokenizer@var2512 , const Function * function@var2513 ) ;
144:
145:
146: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2514 ) ;
147:
148: std :: list < FileInfo :: UnsafeUsage > getUnsafeUsage ( const Tokenizer * tokenizer@var2515 , const Settings * settings@var2516 , const Check * check@var2517 , bool ( * isUnsafeUsage@var2518 ) ( const Check * , const Token * , long long * ) ) ;
149:
150: std :: list < FileInfo :: UnsafeUsage > loadUnsafeUsageListFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2519 ) ;
151: }

##file cppcheck-2.8/lib/checknullpointer.h

1:
|
32:
33: class ErrorLogger ;
34: class Library ;
35: class Settings ;
36: class Token ;
37: class Tokenizer ;
38:
39: namespace tinyxml2 {
40: class XMLElement ;
41: }
42:
|
48:
49: class CheckNullPointer : public Check {
50: public:
51:
52: CheckNullPointer ( ) : Check ( myName ( ) ) { }
53:
54:
55: CheckNullPointer ( const Tokenizer * tokenizer@var2520 , const Settings * settings@var2521 , ErrorLogger * errorLogger@var2522 )
56: : Check ( myName ( ) , tokenizer@var2520 , settings@var2521 , errorLogger@var2522 ) { }
57:
58:
59: void runChecks ( const Tokenizer * tokenizer@var2523 , const Settings * settings@var2524 , ErrorLogger * errorLogger@var2525 ) override {
60: CheckNullPointer checkNullPointer@var2526 (@expr1073747309 tokenizer@var2523 , settings@var2524 , errorLogger@var2525 ) ;
61: checkNullPointer@var2526 .@expr1073747310 nullPointer (@expr1073747311 ) ;
62: checkNullPointer@var2526 .@expr1073747312 arithmetic (@expr1073747313 ) ;
63: checkNullPointer@var2526 .@expr1073747314 nullConstantDereference (@expr1073747315 ) ;
64: }
65:
|
71:
72: static void parseFunctionCall ( const Token & tok@var2527 ,
73: std :: list < const Token * > & var@var2528 ,
74: const Library * library@var2529 ) ;
75:
|
84:
85: bool isPointerDeRef ( const Token * tok@var2530 , bool & unknown@var2531 ) const ;
86:
87: static bool isPointerDeRef ( const Token * tok@var2532 , bool & unknown@var2533 , const Settings * settings@var2534 ) ;
88:
89:
90: void nullPointer ( ) ;
91:
92:
93: void nullConstantDereference ( ) ;
94:
95: void nullPointerError ( const Token * tok@var2535 ) {
96: ValueFlow ::@expr1073747316 Value v@var2536 (@expr1073747317 0 ) ;
97: v@var2536 .@expr1073747318 setKnown (@expr1073747319 ) ;
98: nullPointerError (@expr1073747320 tok@var2535 , "" , &@expr1073747321 v@var2536 , false ) ;
99: }
100: void nullPointerError ( const Token * tok@var2537 , const std :: string & varname@var2538 , const ValueFlow :: Value * value@var2539 , bool inconclusive@var2540 ) ;
101:
102:
103: class MyFileInfo : public Check :: FileInfo {
104: public:
105:
106: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var2541 ;
107:
108:
109: std :: string toString ( ) const override ;
110: } ;
111:
112:
113: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2542 , const Settings * settings@var2543 ) const override ;
114:
115: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2544 ) const override ;
116:
117:
118: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2545 , const std :: list < Check :: FileInfo * > & fileInfo@var2546 , const Settings & settings@var2547 , ErrorLogger & errorLogger@var2548 ) override ;
119:
120: private:
121:
122: void getErrorMessages ( ErrorLogger * errorLogger@var2549 , const Settings * settings@var2550 ) const override {
123: CheckNullPointer c@var2551 (@expr1073747322 nullptr , settings@var2550 , errorLogger@var2549 ) ;
124: c@var2551 .@expr1073747323 nullPointerError (@expr1073747324 nullptr , "pointer" , nullptr , false ) ;
125: c@var2551 .@expr1073747325 pointerArithmeticError (@expr1073747326 nullptr , nullptr , false ) ;
126: c@var2551 .@expr1073747327 redundantConditionWarning (@expr1073747328 nullptr , nullptr , nullptr , false ) ;
127: }
128:
129:
130: static std :: string myName ( ) {
131: return "Null pointer" ;
132: }
133:
134:
135: std :: string classInfo ( ) const override {
136: return "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
137:
138: ;
139: }
140:
|
144:
145: void nullPointerByDeRefAndChec ( ) ;
146:
147:
148: void arithmetic ( ) ;
149: void pointerArithmeticError ( const Token * tok@var2552 , const ValueFlow :: Value * value@var2553 , bool inconclusive@var2554 ) ;
150: void redundantConditionWarning ( const Token * tok@var2555 , const ValueFlow :: Value * value@var2556 , const Token * condition@var2557 , bool inconclusive@var2558 ) ;
151: } ;

##file cppcheck-2.8/lib/checkstl.cpp

1:
|
51:
52: namespace {
53: CheckStl instance@var2559 ;
54: }
55:
56:
57: static const struct CWE CWE398@var2560 ( 398U ) ;
58: static const struct CWE CWE597@var2561 ( 597U ) ;
59: static const struct CWE CWE628@var2562 ( 628U ) ;
60: static const struct CWE CWE664@var2563 ( 664U ) ;
61: static const struct CWE CWE667@var2564 ( 667U ) ;
62: static const struct CWE CWE704@var2565 ( 704U ) ;
63: static const struct CWE CWE762@var2566 ( 762U ) ;
64: static const struct CWE CWE786@var2567 ( 786U ) ;
65: static const struct CWE CWE788@var2568 ( 788U ) ;
66: static const struct CWE CWE825@var2569 ( 825U ) ;
67: static const struct CWE CWE833@var2570 ( 833U ) ;
68: static const struct CWE CWE834@var2571 ( 834U ) ;
69:
70: static bool isElementAccessYield ( const Library :: Container :: Yield & yield@var2572 )
71: {
72: return contains (@expr1073747329 {@expr1073747330 Library ::@expr5507 Container ::@expr5508 Yield ::@expr1073747333 ITEM , Library ::@expr5507 Container ::@expr5508 Yield ::@expr1073747336 AT_INDEX } , yield@var2572 ) ;
73: }
74:
75: static bool containerAppendsElement ( const Library :: Container * container@var2573 , const Token * parent@var2574 )
76: {
77: if (@expr1073747337 Token ::@expr1073747338 Match (@expr1073747339 parent@var2574 , ". %name% (" ) ) {
78: Library ::@expr5516 Container ::@expr1073747341 Action action@var2575 ; action@var2575 =@expr1073747342 container@var2573 .@expr1073747343 getAction (@expr1073747344 parent@var2574 .@expr1073747345 strAt (@expr1073747346 1 ) ) ;
79: if (@expr1073747347 contains (@expr1073747348 {@expr1073747349 Library ::@expr5516 Container ::@expr5527 Action ::@expr1073747352 INSERT ,
80: Library ::@expr5516 Container ::@expr5527 Action ::@expr1073747355 CHANGE ,
81: Library ::@expr5516 Container ::@expr5527 Action ::@expr1073747358 CHANGE_INTERNAL ,
82: Library ::@expr5516 Container ::@expr5527 Action ::@expr1073747361 PUSH ,
83: Library ::@expr5516 Container ::@expr5527 Action ::@expr1073747364 RESIZE } ,
84: action@var2575 ) ) {
85: return true ; }
86: }
87: return false ;
88: }
89:
90: static bool containerYieldsElement ( const Library :: Container * container@var2576 , const Token * parent@var2577 )
91: {
92: if (@expr1073747365 Token ::@expr1073747366 Match (@expr1073747367 parent@var2577 , ". %name% (" ) ) {
93: Library ::@expr1073747368 Container ::@expr1073747369 Yield yield@var2578 ; yield@var2578 =@expr1073747370 container@var2576 .@expr1073747371 getYield (@expr1073747372 parent@var2577 .@expr1073747373 strAt (@expr1073747374 1 ) ) ;
94: if (@expr1073747375 isElementAccessYield (@expr1073747376 yield@var2578 ) ) {
95: return true ; }
96: }
97: return false ;
98: }
99:
100: static const Token * getContainerIndex ( const Library :: Container * container@var2579 , const Token * parent@var2580 )
101: {
102: if (@expr1073747377 Token ::@expr1073747378 Match (@expr1073747379 parent@var2580 , ". %name% (" ) ) {
103: Library ::@expr5556 Container ::@expr1073747381 Yield yield@var2581 ; yield@var2581 =@expr1073747382 container@var2579 .@expr1073747383 getYield (@expr1073747384 parent@var2580 .@expr1073747385 strAt (@expr1073747386 1 ) ) ;
104: if (@expr1073747387 yield@var2581 ==@expr1073747388 Library ::@expr5556 Container ::@expr1073747390 Yield ::@expr1073747391 AT_INDEX &&@expr1073747392 !@expr1073747393 Token ::@expr5570 simpleMatch (@expr1073747395 parent@var2580 .@expr5572 tokAt (@expr5573 2 ) , "( )" ) ) {
105: return parent@var2580 .@expr5572 tokAt (@expr5573 2 ) .@expr1073747400 astOperand2 (@expr1073747401 ) ; }
106: }
107: if (@expr1073747402 !@expr1073747403 container@var2579 .@expr1073747404 arrayLike_indexOp@var2582 &&@expr1073747405 !@expr1073747406 container@var2579 .@expr1073747407 stdStringLike@var2583 ) {
108: return nullptr ; }
109: if (@expr1073747408 Token ::@expr5570 simpleMatch (@expr1073747410 parent@var2580 , "[" ) ) {
110: return parent@var2580 .@expr1073747411 astOperand2 (@expr1073747412 ) ; }
111: return nullptr ;
112: }
113:
114: static const Token * getContainerFromSize ( const Library :: Container * container@var2584 , const Token * tok@var2585 )
115: {
116: if (@expr1073747413 !@expr1073747414 tok@var2585 ) {
117: return nullptr ; }
118: if (@expr1073747415 Token ::@expr1073747416 Match (@expr1073747417 tok@var2585 .@expr5594 tokAt (@expr5595 -2 ) , ". %name% (" ) ) {
119: Library ::@expr5596 Container ::@expr1073747421 Yield yield@var2586 ; yield@var2586 =@expr1073747422 container@var2584 .@expr1073747423 getYield (@expr1073747424 tok@var2585 .@expr1073747425 strAt (@expr1073747426 -1 ) ) ;
120: if (@expr1073747427 yield@var2586 ==@expr1073747428 Library ::@expr5596 Container ::@expr1073747430 Yield ::@expr1073747431 SIZE ) {
121: return tok@var2585 .@expr5594 tokAt (@expr5595 -2 ) .@expr1073747434 astOperand1 (@expr1073747435 ) ; }
122: }
123: return nullptr ;
124: }
125:
126: void CheckStl :: outOfBounds ( )
127: {
128: for (@expr1073747437 const Scope *@expr5614 function@var2587 :@expr1073747439 mTokenizer@var28 .@expr1073747440 getSymbolDatabase (@expr1073747441 ) .@expr1073747442 functionScopes@var3312 ) {
129: for (@expr1073747443 const Token *@expr5614 tok@var2588 =@expr1073747445 function@var2587 .@expr1073747446 bodyStart@var2589 ; tok@var2588 !=@expr1073747447 function@var2587 .@expr1073747448 bodyEnd@var2590 ; tok@var2588 =@expr1073747449 tok@var2588 .@expr1073747450 next (@expr1073747451 ) ) {
130: const Library ::@expr1073747452 Container * container@var2591 ; container@var2591 =@expr1073747453 getLibraryContainer (@expr1073747454 tok@var2588 ) ;
131: if (@expr1073747455 !@expr1073747456 container@var2591 ) {
132: continue ; }
133: const Token * parent@var2592 ; parent@var2592 =@expr1073747457 astParentSkipParens (@expr1073747458 tok@var2588 ) ;
134: const Token * accessTok@var2593 ; accessTok@var2593 =@expr1073747459 parent@var2592 ;
135: if (@expr1073747460 Token ::@expr5637 simpleMatch (@expr1073747462 accessTok@var2593 , "." ) &&@expr1073747463 Token ::@expr5637 simpleMatch (@expr1073747465 accessTok@var2593 .@expr5642 astParent (@expr5643 ) , "(" ) ) {
136: accessTok@var2593 =@expr1073747468 accessTok@var2593 .@expr5642 astParent (@expr5643 ) ; }
137: if (@expr1073747471 astIsIterator (@expr1073747472 accessTok@var2593 ) &&@expr1073747473 Token ::@expr5637 simpleMatch (@expr1073747475 accessTok@var2593 .@expr5642 astParent (@expr5643 ) , "+" ) ) {
138: accessTok@var2593 =@expr1073747478 accessTok@var2593 .@expr5642 astParent (@expr5643 ) ; }
139: const Token * indexTok@var2594 ; indexTok@var2594 =@expr1073747481 getContainerIndex (@expr1073747482 container@var2591 , parent@var2592 ) ;
140: if (@expr1073747483 indexTok@var2594 ==@expr1073747484 tok@var2588 ) {
141: continue ; }
142: for (@expr1073747485 const ValueFlow ::@expr5662 Value &@expr5663 value@var2595 :@expr1073747488 tok@var2588 .@expr1073747489 values (@expr1073747490 ) ) {
143: if (@expr1073747491 !@expr1073747492 value@var2595 .@expr1073747493 isContainerSizeValue (@expr1073747494 ) ) {
144: continue ; }
145: if (@expr1073747495 value@var2595 .@expr1073747496 isImpossible (@expr1073747497 ) ) {
146: continue ; }
147: if (@expr1073747498 value@var2595 .@expr1073747499 isInconclusive (@expr1073747500 ) &&@expr1073747501 !@expr1073747502 mSettings@var29 .@expr1073747503 certainty@var3298 .@expr1073747504 isEnabled (@expr1073747505 Certainty ::@expr1073747506 inconclusive@expr1073747436 ) ) {
148: continue ; }
149: if (@expr1073747507 !@expr1073747508 value@var2595 .@expr1073747509 errorSeverity (@expr1073747510 ) &&@expr1073747511 !@expr1073747512 mSettings@var29 .@expr5689 severity@var3299 .@expr5690 isEnabled (@expr5691 Severity ::@expr5692 warning ) ) {
150: continue ; }
151: if (@expr1073747517 value@var2595 .@expr1073747518 intvalue@var2596 ==@expr1073747519 0 &&@expr1073747520 (@expr1073747521 indexTok@var2594 ||@expr1073747522 (@expr1073747523 containerYieldsElement (@expr1073747524 container@var2591 , parent@var2592 ) &&@expr1073747525
152: !@expr1073747526 containerAppendsElement (@expr1073747527 container@var2591 , parent@var2592 ) ) ) ) {
153: std ::@expr1073747528 string indexExpr@var2597 ;
154: if (@expr1073747529 indexTok@var2594 &&@expr1073747530 !@expr1073747531 indexTok@var2594 .@expr1073747532 hasKnownValue (@expr1073747533 ) ) {
155: indexExpr@var2597 =@expr1073747534 indexTok@var2594 .@expr5711 expressionString (@expr5712 ) ; }
156: outOfBoundsError (@expr1073747537 accessTok@var2593 , tok@var2588 .@expr5714 expressionString (@expr5715 ) , &@expr5716 value@var2595 , indexExpr@var2597 , nullptr ) ;
157: continue ;
158: }
159: if (@expr1073747541 indexTok@var2594 ) {
160: std ::@expr1073747542 vector < ValueFlow ::@expr5662 Value > indexValues@var2598 ; indexValues@var2598 =@expr1073747544
161: ValueFlow ::@expr1073747545 isOutOfBounds (@expr1073747546 value@var2595 , indexTok@var2594 , mSettings@var29 .@expr5689 severity@var3299 .@expr5690 isEnabled (@expr5691 Severity ::@expr5692 warning ) ) ;
162: if (@expr1073747551 !@expr1073747552 indexValues@var2598 .@expr1073747553 empty (@expr1073747554 ) ) {
163: outOfBoundsError (@expr1073747555
164: accessTok@var2593 , tok@var2588 .@expr5714 expressionString (@expr5715 ) , &@expr5716 value@var2595 , indexTok@var2594 .@expr5711 expressionString (@expr5712 ) , &@expr1073747561 indexValues@var2598 .@expr1073747562 front (@expr1073747563 ) ) ;
165: continue ;
166: }
167: }
168: }
169: if (@expr1073747564 indexTok@var2594 &&@expr1073747565 !@expr1073747566 indexTok@var2594 .@expr1073747567 hasKnownIntValue (@expr1073747568 ) ) {
170: const ValueFlow ::@expr1073747569 Value * value@var2599 ; value@var2599 =@expr1073747570
171: ValueFlow ::@expr1073747571 findValue (@expr1073747572 indexTok@var2594 .@expr1073747573 values (@expr1073747574 ) , mSettings@var29 , [@expr1073747575 &@expr5663 ] (@expr1073747577 const ValueFlow ::@expr5662 Value &@expr5663 v@var2600 ) {
172: if (@expr1073747580 !@expr1073747581 v@var2600 .@expr1073747582 isSymbolicValue (@expr1073747583 ) ) {
173: return false ; }
174: if (@expr1073747584 v@var2600 .@expr1073747585 isImpossible (@expr1073747586 ) ) {
175: return false ; }
176: if (@expr1073747587 v@var2600 .@expr1073747588 intvalue@var2601 <@expr1073747589 0 ) {
177: return false ; }
178: const Token * sizeTok@var2602 ; sizeTok@var2602 =@expr1073747590 v@var2600 .@expr1073747591 tokvalue@var2603 ;
179: if (@expr1073747592 sizeTok@var2602 &&@expr1073747593 sizeTok@var2602 .@expr1073747594 isCast (@expr1073747595 ) ) {
180: sizeTok@var2602 =@expr1073747596 sizeTok@var2602 .@expr1073747597 astOperand1 (@expr1073747598 ) ; }
181: const Token * containerTok@var2604 ; containerTok@var2604 =@expr1073747599 getContainerFromSize (@expr1073747600 container@var2591 , sizeTok@var2602 ) ;
182: if (@expr1073747601 !@expr1073747602 containerTok@var2604 ) {
183: return false ; }
184: return containerTok@var2604 .@expr1073747603 exprId (@expr1073747604 ) ==@expr1073747605 tok@var2588 .@expr1073747606 exprId (@expr1073747607 ) ;
185: } ) ;
186: if (@expr1073747608 !@expr1073747609 value@var2599 ) {
187: continue ; }
188: outOfBoundsError (@expr1073747610 accessTok@var2593 , tok@var2588 .@expr5714 expressionString (@expr5715 ) , nullptr , indexTok@var2594 .@expr5711 expressionString (@expr5712 ) , value@var2599 ) ;
189: }
190: }
191: }
192: }
193:
194: static std :: string indexValueString ( const ValueFlow :: Value & indexValue@var2605 , const std :: string & containerName@var2606 = "" )
195: {
196: if (@expr1073747615 indexValue@var2605 .@expr1073747616 isIteratorStartValue (@expr1073747617 ) ) {
197: return "at position " +@expr1073747618 MathLib ::@expr5795 toString (@expr5796 indexValue@var2605 .@expr5797 intvalue@var2607 ) +@expr1073747622 " from the beginning" ; }
198: if (@expr1073747623 indexValue@var2605 .@expr1073747624 isIteratorEndValue (@expr1073747625 ) ) {
199: return "at position " +@expr1073747626 MathLib ::@expr5795 toString (@expr1073747628 -@expr1073747629 indexValue@var2605 .@expr5797 intvalue@var2607 ) +@expr1073747631 " from the end" ; }
200: std ::@expr1073747632 string indexString@var2608 ; indexString@var2608 =@expr1073747633 MathLib ::@expr5795 toString (@expr5796 indexValue@var2605 .@expr5797 intvalue@var2607 ) ;
201: if (@expr1073747637 indexValue@var2605 .@expr1073747638 isSymbolicValue (@expr1073747639 ) ) {
202: indexString@var2608 =@expr1073747640 containerName@var2606 +@expr1073747641 ".size()" ;
203: if (@expr1073747642 indexValue@var2605 .@expr5797 intvalue@var2607 !=@expr1073747644 0 ) {
204: indexString@var2608 +=@expr1073747645 "+" +@expr1073747646 MathLib ::@expr5795 toString (@expr5796 indexValue@var2605 .@expr5797 intvalue@var2607 ) ; }
205: }
206: if (@expr1073747650 indexValue@var2605 .@expr1073747651 bound@var2609 ==@expr1073747652 ValueFlow ::@expr1073747653 Value ::@expr1073747654 Bound ::@expr1073747655 Lower ) {
207: return "greater or equal to " +@expr1073747656 indexString@var2608 ; }
208: return indexString@var2608 ;
209: }
210:
211: void CheckStl :: outOfBoundsError ( const Token * tok@var2610 , const std :: string & containerName@var2611 , const ValueFlow :: Value * containerSize@var2612 , const std :: string & index@var2613 , const ValueFlow :: Value * indexValue@var2614 )
212: {
213:
214: if (@expr1073747657 containerSize@var2612 &&@expr1073747658 indexValue@var2614 &&@expr1073747659 containerSize@var2612 .@expr1073747660 isPossible (@expr1073747661 ) &&@expr1073747662 indexValue@var2614 .@expr1073747663 isPossible (@expr1073747664 ) ) {
215: return ; }
216:
217: const std ::@expr5841 string expression@var2615 =@expr1073747666 tok@var2610 ?@expr1073747667 tok@var2610 .@expr1073747668 expressionString (@expr1073747669 ) :@expr1073747670 (@expr1073747671 containerName@var2611 +@expr1073747672 "[x]" ) ;
218:
219: std ::@expr1073747673 string errmsg@var2616 ;
220: if (@expr1073747674 !@expr1073747675 containerSize@var2612 ) {
221: if (@expr1073747676 indexValue@var2614 &&@expr1073747677 indexValue@var2614 .@expr5854 condition@var2617 ) {
222: errmsg@var2616 =@expr1073747679 ValueFlow ::@expr5856 eitherTheConditionIsRedundant (@expr5857 indexValue@var2614 .@expr5854 condition@var2617 ) +@expr5859 " or '" +@expr5860 index@var2613 +@expr5861
223: "' can have the value " +@expr1073747686 indexValueString (@expr1073747687 *@expr5864 indexValue@var2614 , containerName@var2611 ) +@expr1073747689 ". Expression '" +@expr1073747690
224: expression@var2615 +@expr1073747691 "' cause access out of bounds." ; }
225: else {
226: errmsg@var2616 =@expr1073747692 "Out of bounds access in expression '" +@expr5869 expression@var2615 +@expr1073747694 "'" ; }
227: } else { if (@expr1073747695 containerSize@var2612 .@expr5872 intvalue@var2618 ==@expr1073747697 0 ) {
228: if (@expr5874 containerSize@var2612 .@expr5875 condition@var2619 ) {
229: errmsg@var2616 =@expr1073747700 ValueFlow ::@expr5856 eitherTheConditionIsRedundant (@expr5878 containerSize@var2612 .@expr5875 condition@var2619 ) +@expr1073747704 " or expression '" +@expr1073747705 expression@var2615 +@expr1073747706 "' cause access out of bounds." ; }
230: else { if (@expr1073747707 indexValue@var2614 ==@expr1073747708 nullptr &&@expr1073747709 !@expr1073747710 index@var2613 .@expr1073747711 empty (@expr1073747712 ) ) {
231: errmsg@var2616 =@expr1073747713 "Out of bounds access in expression '" +@expr5869 expression@var2615 +@expr1073747715 "' because '$symbol' is empty and '" +@expr1073747716 index@var2613 +@expr1073747717 "' may be non-zero." ; }
232: else {
233: errmsg@var2616 =@expr1073747718 "Out of bounds access in expression '" +@expr5869 expression@var2615 +@expr1073747720 "' because '$symbol' is empty." ; } }
234: } else { if (@expr1073747721 indexValue@var2614 ) {
235: if (@expr5874 containerSize@var2612 .@expr5875 condition@var2619 ) {
236: errmsg@var2616 =@expr1073747724 ValueFlow ::@expr5856 eitherTheConditionIsRedundant (@expr5878 containerSize@var2612 .@expr5875 condition@var2619 ) +@expr1073747728 " or $symbol size can be " +@expr1073747729 MathLib ::@expr5906 toString (@expr5907 containerSize@var2612 .@expr5872 intvalue@var2618 ) +@expr1073747733 ". Expression '" +@expr1073747734 expression@var2615 +@expr1073747735 "' cause access out of bounds." ; }
237: else { if (@expr1073747736 indexValue@var2614 .@expr5854 condition@var2617 ) {
238: errmsg@var2616 =@expr1073747738 ValueFlow ::@expr5856 eitherTheConditionIsRedundant (@expr5857 indexValue@var2614 .@expr5854 condition@var2617 ) +@expr5859 " or '" +@expr5860 index@var2613 +@expr5861 "' can have the value " +@expr1073747745 indexValueString (@expr5922 *@expr5864 indexValue@var2614 ) +@expr1073747748 ". Expression '" +@expr1073747749 expression@var2615 +@expr1073747750 "' cause access out of bounds." ; }
239: else {
240: errmsg@var2616 =@expr1073747751 "Out of bounds access in '" +@expr1073747752 expression@var2615 +@expr1073747753 "', if '$symbol' size is " +@expr1073747754 MathLib ::@expr5906 toString (@expr5907 containerSize@var2612 .@expr5872 intvalue@var2618 ) +@expr1073747758 " and '" +@expr1073747759 index@var2613 +@expr1073747760 "' is " +@expr1073747761 indexValueString (@expr5922 *@expr5864 indexValue@var2614 ) ; } }
241: } else {
242:
243: return ;
244: } } }
245:
246: std ::@expr1073747764 list < std ::@expr5841 pair < const Token *@expr5942 , std ::@expr5841 string > > errorPath@var2620 ;
247: if (@expr1073747768 !@expr1073747769 indexValue@var2614 ) {
248: errorPath@var2620 =@expr1073747770 getErrorPath (@expr5947 tok@var2610 , containerSize@var2612 , "Access out of bounds" ) ; }
249: else {
250: std ::@expr1073747772 list < std ::@expr5841 pair < const Token *@expr5942 , std ::@expr5841 string > > errorPath1@var2621 ; errorPath1@var2621 =@expr1073747776 getErrorPath (@expr5947 tok@var2610 , containerSize@var2612 , "Access out of bounds" ) ;
251: std ::@expr1073747778 list < std ::@expr5841 pair < const Token *@expr5942 , std ::@expr5841 string > > errorPath2@var2622 ; errorPath2@var2622 =@expr1073747782 getErrorPath (@expr1073747783 tok@var2610 , indexValue@var2614 , "Access out of bounds" ) ;
252: if (@expr1073747784 errorPath1@var2621 .@expr1073747785 size (@expr1073747786 ) <=@expr1073747787 1 ) {
253: errorPath@var2620 =@expr1073747788 errorPath2@var2622 ; }
254: else { if (@expr1073747789 errorPath2@var2622 .@expr1073747790 size (@expr1073747791 ) <=@expr1073747792 1 ) {
255: errorPath@var2620 =@expr1073747793 errorPath1@var2621 ; }
256: else {
257: errorPath@var2620 =@expr1073747794 errorPath1@var2621 ;
258: errorPath@var2620 .@expr1073747795 splice (@expr1073747796 errorPath@var2620 .@expr1073747797 end (@expr1073747798 ) , errorPath2@var2622 ) ;
259: } }
260: }
261:
262: reportError (@expr1073747799 errorPath@var2620 ,
263: (@expr1073747800 containerSize@var2612 &&@expr1073747801 !@expr1073747802 containerSize@var2612 .@expr1073747803 errorSeverity (@expr1073747804 ) ) ||@expr1073747805 (@expr1073747806 indexValue@var2614 &&@expr1073747807 !@expr1073747808 indexValue@var2614 .@expr1073747809 errorSeverity (@expr1073747810 ) ) ?@expr1073747811 Severity ::@expr1073747812 warning :@expr1073747813 Severity ::@expr1073747814 error ,
264: "containerOutOfBounds" ,
265: "$symbol:" +@expr1073747815 containerName@var2611 +@expr1073747816 "\n" +@expr1073747817 errmsg@var2616 ,
266: CWE398@var2560 ,
267: (@expr1073747818 containerSize@var2612 &&@expr1073747819 containerSize@var2612 .@expr1073747820 isInconclusive (@expr1073747821 ) ) ||@expr1073747822 (@expr1073747823 indexValue@var2614 &&@expr1073747824 indexValue@var2614 .@expr1073747825 isInconclusive (@expr1073747826 ) ) ?@expr1073747827 Certainty ::@expr1073747828 inconclusive :@expr1073747829 Certainty ::@expr1073747830 normal ) ;
268: }
269:
270: bool CheckStl :: isContainerSize ( const Token * containerToken@var2623 , const Token * expr@var2624 ) const
271: {
272: if (@expr1073747831 !@expr1073747832 Token ::@expr1073747833 simpleMatch (@expr1073747834 expr@var2624 , "( )" ) ) {
273: return false ; }
274: if (@expr1073747835 !@expr1073747836 Token ::@expr1073747837 Match (@expr1073747838 expr@var2624 .@expr6015 astOperand1 (@expr6016 ) , ". %name% (" ) ) {
275: return false ; }
276: if (@expr1073747841 !@expr1073747842 isSameExpression (@expr1073747843 mTokenizer@var28 .@expr1073747844 isCPP (@expr1073747845 ) , false , containerToken@var2623 , expr@var2624 .@expr6015 astOperand1 (@expr6016 ) .@expr1073747848 astOperand1 (@expr1073747849 ) , mSettings@var29 .@expr1073747850 library@var3300 , false , false ) ) {
277: return false ; }
278: return containerToken@var2623 .@expr1073747851 valueType (@expr1073747852 ) .@expr1073747853 container@var3313 .@expr1073747854 getYield (@expr1073747855 expr@var2624 .@expr1073747856 previous (@expr1073747857 ) .@expr1073747858 str (@expr1073747859 ) ) ==@expr1073747860 Library ::@expr1073747861 Container ::@expr1073747862 Yield ::@expr1073747863 SIZE ;
279: }
280:
281: bool CheckStl :: isContainerSizeGE ( const Token * containerToken@var2625 , const Token * expr@var2626 ) const
282: {
283: if (@expr1073747865 !@expr1073747866 expr@var2626 ) {
284: return false ; }
285: if (@expr1073747867 isContainerSize (@expr1073747868 containerToken@var2625 , expr@var2626 ) ) {
286: return true ; }
287: if (@expr1073747869 expr@var2626 .@expr6046 str (@expr6047 ) ==@expr1073747872 "*" ) {
288: const Token * mul@var2627 ;
289: if (@expr6049 isContainerSize (@expr6050 containerToken@var2625 , expr@var2626 .@expr6051 astOperand1 (@expr6052 ) ) ) {
290: mul@var2627 =@expr1073747877 expr@var2626 .@expr6054 astOperand2 (@expr6055 ) ; }
291: else { if (@expr6056 isContainerSize (@expr6057 containerToken@var2625 , expr@var2626 .@expr6054 astOperand2 (@expr6055 ) ) ) {
292: mul@var2627 =@expr1073747884 expr@var2626 .@expr6051 astOperand1 (@expr6052 ) ; }
293: else {
294: return false ; } }
295: return mul@var2627 &&@expr1073747887 (@expr1073747888 !@expr1073747889 mul@var2627 .@expr1073747890 hasKnownIntValue (@expr1073747891 ) ||@expr1073747892 mul@var2627 .@expr1073747893 values (@expr1073747894 ) .@expr1073747895 front (@expr1073747896 ) .@expr1073747897 intvalue@expr1073747864 !=@expr1073747898 0 ) ;
296: }
297: if (@expr1073747899 expr@var2626 .@expr6046 str (@expr6047 ) ==@expr1073747902 "+" ) {
298: const Token * op@var2628 ;
299: if (@expr6049 isContainerSize (@expr6050 containerToken@var2625 , expr@var2626 .@expr6051 astOperand1 (@expr6052 ) ) ) {
300: op@var2628 =@expr1073747907 expr@var2626 .@expr6054 astOperand2 (@expr6055 ) ; }
301: else { if (@expr6056 isContainerSize (@expr6057 containerToken@var2625 , expr@var2626 .@expr6054 astOperand2 (@expr6055 ) ) ) {
302: op@var2628 =@expr1073747914 expr@var2626 .@expr6051 astOperand1 (@expr6052 ) ; }
303: else {
304: return false ; } }
305: return op@var2628 &&@expr1073747917 op@var2628 .@expr1073747918 getValueGE (@expr1073747919 0 , mSettings@var29 ) ;
306: }
307: return false ;
308: }
309:
310: void CheckStl :: outOfBoundsIndexExpression ( )
311: {
312: for (@expr1073747920 const Scope *@expr6097 function@var2629 :@expr1073747922 mTokenizer@var28 .@expr1073747923 getSymbolDatabase (@expr1073747924 ) .@expr1073747925 functionScopes@var3312 ) {
313: for (@expr1073747926 const Token *@expr6097 tok@var2630 =@expr1073747928 function@var2629 .@expr1073747929 bodyStart@var2631 ; tok@var2630 !=@expr1073747930 function@var2629 .@expr1073747931 bodyEnd@var2632 ; tok@var2630 =@expr1073747932 tok@var2630 .@expr6109 next (@expr6110 ) ) {
314: if (@expr1073747935 !@expr1073747936 tok@var2630 .@expr1073747937 isName (@expr1073747938 ) ||@expr1073747939 !@expr1073747940 tok@var2630 .@expr6117 valueType (@expr6118 ) ) {
315: continue ; }
316: const Library ::@expr1073747943 Container * container@var2633 ; container@var2633 =@expr1073747944 tok@var2630 .@expr6117 valueType (@expr6118 ) .@expr1073747947 container@var3313 ;
317: if (@expr1073747948 !@expr1073747949 container@var2633 ) {
318: continue ; }
319: if (@expr1073747950 !@expr1073747951 container@var2633 .@expr1073747952 arrayLike_indexOp@var2634 &&@expr1073747953 !@expr1073747954 container@var2633 .@expr1073747955 stdStringLike@var2635 ) {
320: continue ; }
321: if (@expr1073747956 !@expr1073747957 Token ::@expr1073747958 Match (@expr1073747959 tok@var2630 , "%name% [" ) ) {
322: continue ; }
323: if (@expr1073747960 isContainerSizeGE (@expr1073747961 tok@var2630 , tok@var2630 .@expr6109 next (@expr6110 ) .@expr6140 astOperand2 (@expr6141 ) ) ) {
324: outOfBoundsIndexExpressionError (@expr1073747966 tok@var2630 , tok@var2630 .@expr6109 next (@expr6110 ) .@expr6140 astOperand2 (@expr6141 ) ) ; }
325: }
326: }
327: }
328:
329: void CheckStl :: outOfBoundsIndexExpressionError ( const Token * tok@var2636 , const Token * index@var2637 )
330: {
331: const std ::@expr6147 string varname@var2638 =@expr1073747972 tok@var2636 ?@expr1073747973 tok@var2636 .@expr1073747974 str (@expr1073747975 ) :@expr1073747976 std ::@expr6153 string (@expr1073747978 "var" ) ;
332: const std ::@expr6147 string i@var2639 =@expr1073747980 index@var2637 ?@expr1073747981 index@var2637 .@expr1073747982 expressionString (@expr1073747983 ) :@expr1073747984 std ::@expr6153 string (@expr1073747986 varname@var2638 +@expr1073747987 ".size()" ) ;
333:
334: std ::@expr1073747988 string errmsg@var2640 ; errmsg@var2640 =@expr1073747989 "Out of bounds access of $symbol, index '" +@expr1073747990 i@var2639 +@expr1073747991 "' is out of bounds." ;
335:
336: reportError (@expr1073747992 tok@var2636 ,
337: Severity ::@expr1073747993 error ,
338: "containerOutOfBoundsIndexExpression" ,
339: "$symbol:" +@expr1073747994 varname@var2638 +@expr1073747995 "\n" +@expr1073747996 errmsg@var2640 ,
340: CWE398@var2560 ,
341: Certainty ::@expr1073747997 normal ) ;
342: }
343:
|
346:
347: void CheckStl :: invalidIteratorError ( const Token * tok@var2641 , const std :: string & iteratorName@var2642 )
348: {
349: reportError (@expr1073747998 tok@var2641 , Severity ::@expr1073747999 error , "invalidIterator1" , "$symbol:" +@expr1073748000 iteratorName@var2642 +@expr1073748001 "\nInvalid iterator: $symbol" , CWE664@var2563 , Certainty ::@expr1073748002 normal ) ;
350: }
351:
352: void CheckStl :: iteratorsError ( const Token * tok@var2643 , const std :: string & containerName1@var2644 , const std :: string & containerName2@var2645 )
353: {
354: reportError (@expr1073748003 tok@var2643 , Severity ::@expr1073748004 error , "iterators1" ,
355: "$symbol:" +@expr1073748005 containerName1@var2644 +@expr1073748006 "\n$symbol:"
356: +@expr1073748007 containerName2@var2645 +@expr1073748008 "\nSame iterator is used with different containers '"
357: +@expr1073748009 containerName1@var2644 +@expr1073748010 "' and '" +@expr1073748011 containerName2@var2645 +@expr1073748012 "'." , CWE664@var2563 , Certainty ::@expr1073748013 normal ) ;
358: }
359:
360: void CheckStl :: iteratorsError ( const Token * tok@var2646 , const Token * containerTok@var2647 , const std :: string & containerName1@var2648 , const std :: string & containerName2@var2649 )
361: {
362: std ::@expr1073748014 list < const Token *@expr1073748015 > callstack@var2650 ; callstack@var2650 =@expr1073748016 {@expr1073748017 tok@var2646 , containerTok@var2647 } ;
363: reportError (@expr1073748018 callstack@var2650 , Severity ::@expr1073748019 error , "iterators2" ,
364: "$symbol:" +@expr1073748020 containerName1@var2648 +@expr1073748021 "\n$symbol:"
365: +@expr1073748022 containerName2@var2649 +@expr1073748023 "\nSame iterator is used with different containers '"
366: +@expr1073748024 containerName1@var2648 +@expr1073748025 "' and '" +@expr1073748026 containerName2@var2649 +@expr1073748027 "'." , CWE664@var2563 , Certainty ::@expr1073748028 normal ) ;
367: }
368:
369: void CheckStl :: iteratorsError ( const Token * tok@var2651 , const Token * containerTok@var2652 , const std :: string & containerName@var2653 )
370: {
371: std ::@expr1073748029 list < const Token *@expr1073748030 > callstack@var2654 ; callstack@var2654 =@expr1073748031 {@expr1073748032 tok@var2651 , containerTok@var2652 } ;
372: reportError (@expr1073748033 callstack@var2654 ,
373: Severity ::@expr1073748034 error ,
374: "iterators3" ,
375: "$symbol:" +@expr1073748035 containerName@var2653 +@expr1073748036
376: "\nSame iterator is used with containers '$symbol' that are temporaries or defined in different scopes."
377: ,
378: CWE664@var2563 ,
379: Certainty ::@expr1073748037 normal ) ;
380: }
381:
382:
383: void CheckStl :: dereferenceErasedError ( const Token * erased@var2655 , const Token * deref@var2656 , const std :: string & itername@var2657 , bool inconclusive@var2658 )
384: {
385: if (@expr1073748038 erased@var2655 ) {
386: std ::@expr1073748039 list < const Token *@expr1073748040 > callstack@var2659 ; callstack@var2659 =@expr1073748041 {@expr1073748042 deref@var2656 , erased@var2655 } ;
387: reportError (@expr1073748043 callstack@var2659 , Severity ::@expr6220 error , "eraseDereference" ,
388: "$symbol:" +@expr6221 itername@var2657 +@expr1073748046 "\nIterator '$symbol' used after element has been erased.\nThe iterator '$symbol' is invalid after the element it pointed to has been erased. Dereferencing or comparing it with another iterator is invalid operation."
389:
390:
391: , CWE664@var2563 , inconclusive@var2658 ?@expr6223 Certainty ::@expr6224 inconclusive :@expr6225 Certainty ::@expr6226 normal ) ;
392: } else {
393: reportError (@expr1073748051 deref@var2656 , Severity ::@expr6220 error , "eraseDereference" ,
394: "$symbol:" +@expr6221 itername@var2657 +@expr1073748054 "\nInvalid iterator '$symbol' used.\nThe iterator '$symbol' is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation."
395:
396:
397: , CWE664@var2563 , inconclusive@var2658 ?@expr6223 Certainty ::@expr6224 inconclusive :@expr6225 Certainty ::@expr6226 normal ) ;
398: }
399: }
400:
401: static const Token * skipMembers ( const Token * tok@var2660 )
402: {
403: while (@expr1073748059 Token ::@expr1073748060 Match (@expr1073748061 tok@var2660 , "%name% ." ) ) {
404: tok@var2660 =@expr1073748062 tok@var2660 .@expr1073748063 tokAt (@expr1073748064 2 ) ; }
405: return tok@var2660 ;
406: }
407:
408: static bool isIterator ( const Variable * var@var2661 , bool & inconclusiveType@var2662 )
409: {
410:
411: if (@expr1073748065 !@expr1073748066 var@var2661 ||@expr1073748067 !@expr1073748068 var@var2661 .@expr1073748069 isLocal (@expr1073748070 ) ||@expr1073748071 !@expr1073748072 Token ::@expr1073748073 Match (@expr1073748074 var@var2661 .@expr6251 typeEndToken (@expr6252 ) , "iterator|const_iterator|reverse_iterator|const_reverse_iterator|auto" ) ) {
412: return false ; }
413:
414: inconclusiveType@var2662 =@expr1073748077 false ;
415: if (@expr1073748078 var@var2661 .@expr6251 typeEndToken (@expr6252 ) .@expr1073748081 str (@expr1073748082 ) ==@expr1073748083 "auto" ) {
416: return (@expr1073748084 var@var2661 .@expr6261 nameToken (@expr6262 ) .@expr6263 valueType (@expr6264 ) &&@expr1073748089 var@var2661 .@expr6261 nameToken (@expr6262 ) .@expr6263 valueType (@expr6264 ) .@expr1073748094 type@var3317 ==@expr1073748095 ValueType ::@expr1073748096 Type ::@expr1073748097 ITERATOR ) ; }
417:
418: if (@expr1073748098 var@var2661 .@expr6275 type (@expr6276 ) ) {
419:
420: const Function * end@var2663 ; end@var2663 =@expr1073748101 var@var2661 .@expr6275 type (@expr6276 ) .@expr6280 getFunction (@expr1073748105 "operator*" ) ;
421: const Function * incOperator@var2664 ; incOperator@var2664 =@expr1073748106 var@var2661 .@expr6275 type (@expr6276 ) .@expr6280 getFunction (@expr1073748110 "operator++" ) ;
422: if (@expr1073748111 !@expr1073748112 end@var2663 ||@expr1073748113 end@var2663 .@expr1073748114 argCount (@expr1073748115 ) >@expr1073748116 0 ||@expr1073748117 !@expr1073748118 incOperator@var2664 ) {
423: return false ;
424: } else {
425: inconclusiveType@var2662 =@expr1073748119 true ;
426: }
427: }
428:
429: return true ;
430: }
431:
432: static std :: string getContainerName ( const Token * containerToken@var2665 )
433: {
434: if (@expr1073748120 !@expr1073748121 containerToken@var2665 ) {
435: return std ::@expr1073748122 string (@expr1073748123 ) ; }
436: std ::@expr1073748124 string ret@var2666 (@expr1073748125 containerToken@var2665 .@expr1073748126 str (@expr1073748127 ) ) ;
437: for (@expr1073748128 const Token *@expr1073748129 nametok@var2667 =@expr1073748130 containerToken@var2665 ; nametok@var2667 ; nametok@var2667 =@expr1073748131 nametok@var2667 .@expr6308 tokAt (@expr6309 -2 ) ) {
438: if (@expr1073748134 !@expr1073748135 Token ::@expr1073748136 Match (@expr1073748137 nametok@var2667 .@expr6308 tokAt (@expr6309 -2 ) , "%name% ." ) ) {
439: break ; }
440: ret@var2666 =@expr1073748140 nametok@var2667 .@expr1073748141 strAt (@expr1073748142 -2 ) +@expr1073748143 '.' +@expr1073748144 ret@var2666 ;
441: }
442: return ret@var2666 ;
443: }
444:
445: enum OperandPosition {
446: Left ,
447: Right
448: } ;
449:
450: static bool isVector ( const Token * tok@var2668 )
451: {
452: if (@expr1073748145 !@expr1073748146 tok@var2668 ) {
453: return false ; }
454: const Variable * var@var2669 ; var@var2669 =@expr1073748147 tok@var2668 .@expr1073748148 variable (@expr1073748149 ) ;
455: const Token * decltok@var2670 ; decltok@var2670 =@expr1073748150 var@var2669 ?@expr1073748151 var@var2669 .@expr1073748152 typeStartToken (@expr1073748153 ) :@expr1073748154 nullptr ;
456: return Token ::@expr1073748155 simpleMatch (@expr1073748156 decltok@var2670 , "std :: vector" ) ;
457: }
458:
459: void CheckStl :: iterators ( )
460: {
461: const SymbolDatabase * symbolDatabase@var2671 ; symbolDatabase@var2671 =@expr1073748158 mTokenizer@var28 .@expr1073748159 getSymbolDatabase (@expr1073748160 ) ;
462:
463:
464: std ::@expr1073748161 map < int , const Token *@expr6338 > iteratorScopeBeginInfo@var2672 ;
465: for (@expr1073748163 const Variable *@expr6338 var@var2673 :@expr1073748165 symbolDatabase@var2671 .@expr6342 variableList (@expr6343 ) ) {
466: bool inconclusiveType@var2674 ; inconclusiveType@var2674 =@expr1073748168 false ;
467: if (@expr1073748169 !@expr1073748170 isIterator (@expr1073748171 var@var2673 , inconclusiveType@var2674 ) ) {
468: continue ; }
469: const int iteratorId@var2675 =@expr1073748172 var@var2673 .@expr1073748173 declarationId (@expr1073748174 ) ;
470: if (@expr1073748175 iteratorId@var2675 !=@expr1073748176 0 ) {
471: iteratorScopeBeginInfo@var2672 [@expr1073748177 iteratorId@var2675 ] =@expr1073748178 var@var2673 .@expr1073748179 nameToken (@expr1073748180 ) ; }
472: }
473:
474: for (@expr1073748181 const Variable *@expr6338 var@var2676 :@expr1073748183 symbolDatabase@var2671 .@expr6342 variableList (@expr6343 ) ) {
475: bool inconclusiveType@var2677 ; inconclusiveType@var2677 =@expr1073748186 false ;
476: if (@expr1073748187 !@expr1073748188 isIterator (@expr1073748189 var@var2676 , inconclusiveType@var2677 ) ) {
477: continue ; }
478: if (@expr1073748190 inconclusiveType@var2677 &&@expr1073748191 !@expr1073748192 mSettings@var29 .@expr1073748193 certainty@var3298 .@expr1073748194 isEnabled (@expr1073748195 Certainty ::@expr1073748196 inconclusive@expr1073748157 ) ) {
479: continue ; }
480:
481: const int iteratorId@var2678 =@expr1073748197 var@var2676 .@expr1073748198 declarationId (@expr1073748199 ) ;
482:
483:
484: bool validIterator@var2679 ; validIterator@var2679 =@expr1073748200 Token ::@expr6377 Match (@expr1073748202 var@var2676 .@expr6379 nameToken (@expr6380 ) .@expr1073748205 next (@expr1073748206 ) , "[(=:{]" ) ;
485: const Scope * invalidationScope@var2680 ; invalidationScope@var2680 =@expr1073748207 nullptr ;
486:
487:
488: const Token * containerToken@var2681 ; containerToken@var2681 =@expr1073748208 nullptr ;
489: const Scope * containerAssignScope@var2682 ; containerAssignScope@var2682 =@expr1073748209 nullptr ;
490:
491:
492: const Token * validatingToken@var2683 ; validatingToken@var2683 =@expr1073748210 nullptr ;
493:
494: const Token * eraseToken@var2684 ; eraseToken@var2684 =@expr1073748211 nullptr ;
495:
496:
497:
498: for (@expr1073748212 const Token *@expr6338 tok2@var2685 =@expr1073748214 var@var2676 .@expr6379 nameToken (@expr6380 ) ; tok2@var2685 &&@expr1073748217 tok2@var2685 !=@expr1073748218 var@var2676 .@expr1073748219 scope (@expr1073748220 ) .@expr1073748221 bodyEnd@var3314 ; tok2@var2685 =@expr1073748222 tok2@var2685 .@expr6399 next (@expr6400 ) ) {
499: if (@expr1073748225 invalidationScope@var2680 &&@expr1073748226 tok2@var2685 ==@expr1073748227 invalidationScope@var2680 .@expr1073748228 bodyEnd@var2686 ) {
500: validIterator@var2679 =@expr1073748229 true ; }
501: if (@expr1073748230 containerAssignScope@var2682 &&@expr1073748231 tok2@var2685 ==@expr1073748232 containerAssignScope@var2682 .@expr1073748233 bodyEnd@var2687 ) {
502: containerToken@var2681 =@expr1073748234 nullptr ; }
503:
504: if (@expr1073748235 tok2@var2685 ==@expr1073748236 validatingToken@var2683 ) {
505: validIterator@var2679 =@expr1073748237 true ;
506: eraseToken@var2684 =@expr1073748238 nullptr ;
507: invalidationScope@var2680 =@expr1073748239 nullptr ;
508: }
509:
510:
511: if (@expr1073748240 Token ::@expr6377 Match (@expr1073748242 tok2@var2685 , "%name% . insert|erase ( *| %varid% )|," , iteratorId@var2678 ) &&@expr1073748243 !@expr1073748244 isVector (@expr1073748245 tok2@var2685 ) ) {
512: const Token * itTok@var2688 ; itTok@var2688 =@expr1073748246 tok2@var2685 .@expr6423 tokAt (@expr1073748248 4 ) ;
513: if (@expr1073748249 itTok@var2688 .@expr6426 str (@expr6427 ) ==@expr1073748252 "*" ) {
514: if (@expr6429 tok2@var2685 .@expr6430 strAt (@expr6431 2 ) ==@expr6432 "insert" ) {
515: continue ; }
516:
517: itTok@var2688 =@expr1073748257 itTok@var2688 .@expr6434 next (@expr6435 ) ;
518: }
519:
520: if (@expr1073748260 !@expr6437 validIterator@var2679 ) {
521: invalidIteratorError (@expr1073748262 tok2@var2685 , itTok@var2688 .@expr6426 str (@expr6427 ) ) ; }
522:
523:
524:
525: if (@expr1073748265 containerToken@var2681 &&@expr1073748266 tok2@var2685 .@expr6443 varId (@expr6444 ) !=@expr1073748269 containerToken@var2681 .@expr6446 varId (@expr6447 ) ) {
526:
527: const Variable * variableInfo@var2689 ; variableInfo@var2689 =@expr1073748272 tok2@var2685 .@expr1073748273 variable (@expr1073748274 ) ;
528: const Token * decltok@var2690 ; decltok@var2690 =@expr1073748275 variableInfo@var2689 ?@expr1073748276 variableInfo@var2689 .@expr1073748277 typeStartToken (@expr1073748278 ) :@expr1073748279 nullptr ;
529:
530: if (@expr1073748280 Token ::@expr6457 simpleMatch (@expr1073748282 decltok@var2690 , "std :: set" ) ) {
531: continue ; }
532:
533:
534: if (@expr1073748283 itTok@var2688 .@expr1073748284 previous (@expr1073748285 ) .@expr1073748286 str (@expr1073748287 ) ==@expr1073748288 "*" ) {
535: continue ; }
536:
537:
538: if (@expr6429 tok2@var2685 .@expr6430 strAt (@expr6431 2 ) ==@expr6432 "insert" ) {
539: const Token * par2@var2691 ; par2@var2691 =@expr1073748293 itTok@var2688 .@expr1073748294 nextArgument (@expr1073748295 ) ;
540: if (@expr1073748296 !@expr1073748297 par2@var2691 ||@expr1073748298 par2@var2691 .@expr1073748299 nextArgument (@expr1073748300 ) ) {
541: continue ; }
542: while (@expr1073748301 par2@var2691 .@expr6478 str (@expr6479 ) !=@expr6480 ")" ) {
543: if (@expr1073748305 par2@var2691 .@expr1073748306 varId (@expr1073748307 ) ==@expr1073748308 containerToken@var2681 .@expr6446 varId (@expr6447 ) ) {
544: break ; }
545: bool inconclusiveType2@var2692 ; inconclusiveType2@var2692 =@expr1073748311 false ;
546: if (@expr1073748312 isIterator (@expr1073748313 par2@var2691 .@expr1073748314 variable (@expr1073748315 ) , inconclusiveType2@var2692 ) ) {
547: break ; }
548: if (@expr1073748316 par2@var2691 .@expr6478 str (@expr6479 ) ==@expr1073748319 "(" ) {
549: par2@var2691 =@expr1073748320 par2@var2691 .@expr1073748321 link (@expr1073748322 ) ; }
550: par2@var2691 =@expr1073748323 par2@var2691 .@expr1073748324 next (@expr1073748325 ) ;
551: }
552: if (@expr1073748326 par2@var2691 .@expr6478 str (@expr6479 ) !=@expr6480 ")" ) {
553: continue ; }
554: }
555:
556:
557: if (@expr1073748330 containerToken@var2681 &&@expr1073748331 containerToken@var2681 .@expr6508 variable (@expr6509 ) &&@expr1073748334 containerToken@var2681 .@expr6508 variable (@expr6509 ) .@expr1073748337 isReference (@expr1073748338 ) ) {
558: const Token * nameToken@var2693 ; nameToken@var2693 =@expr1073748339 containerToken@var2681 .@expr6508 variable (@expr6509 ) .@expr1073748342 nameToken (@expr1073748343 ) ;
559: if (@expr1073748344 Token ::@expr6377 Match (@expr1073748346 nameToken@var2693 , "%name% =" ) ) {
560: const Token * name1@var2694 ; name1@var2694 =@expr1073748347 nameToken@var2693 .@expr1073748348 tokAt (@expr1073748349 2 ) ;
561: const Token * name2@var2695 ; name2@var2695 =@expr1073748350 tok2@var2685 ;
562: while (@expr1073748351 Token ::@expr6377 Match (@expr1073748353 name1@var2694 , "%name%|.|::" ) &&@expr1073748354 name2@var2695 &&@expr1073748355 name1@var2694 .@expr1073748356 str (@expr1073748357 ) ==@expr1073748358 name2@var2695 .@expr1073748359 str (@expr1073748360 ) ) {
563: name1@var2694 =@expr1073748361 name1@var2694 .@expr1073748362 next (@expr1073748363 ) ;
564: name2@var2695 =@expr1073748364 name2@var2695 .@expr1073748365 next (@expr1073748366 ) ;
565: }
566: if (@expr1073748367 !@expr1073748368 Token ::@expr6457 simpleMatch (@expr1073748370 name1@var2694 , ";" ) ||@expr1073748371 !@expr1073748372 Token ::@expr6377 Match (@expr1073748374 name2@var2695 , "[;,()=]" ) ) {
567: continue ; }
568: }
569: }
570:
571:
572: iteratorsError (@expr1073748375 tok2@var2685 , getContainerName (@expr1073748376 containerToken@var2681 ) , getContainerName (@expr1073748377 tok2@var2685 ) ) ;
573: }
574:
575:
576: else { if (@expr1073748378 tok2@var2685 .@expr6430 strAt (@expr6431 2 ) ==@expr1073748381 "erase" &&@expr1073748382 (@expr1073748383 tok2@var2685 .@expr6430 strAt (@expr1073748385 4 ) !=@expr1073748386 "*" ||@expr1073748387 (@expr1073748388 containerToken@var2681 &&@expr1073748389 tok2@var2685 .@expr6443 varId (@expr6444 ) ==@expr1073748392 containerToken@var2681 .@expr6446 varId (@expr6447 ) ) ) ) {
577: validIterator@var2679 =@expr1073748395 false ;
578: eraseToken@var2684 =@expr1073748396 tok2@var2685 ;
579: invalidationScope@var2680 =@expr1073748397 tok2@var2685 .@expr6574 scope (@expr6575 ) ;
580: } }
581:
582:
583: tok2@var2685 =@expr1073748400 itTok@var2688 .@expr6434 next (@expr6435 ) ;
584: }
585:
586:
587:
588: else { if (@expr1073748403 Token ::@expr6377 Match (@expr6581 tok2@var2685 , "%varid% = %name% ." , iteratorId@var2678 ) &&@expr1073748406
589: Token ::@expr6457 simpleMatch (@expr1073748408 skipMembers (@expr6585 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ) , "erase (" ) ) {
590:
591: validatingToken@var2683 =@expr1073748412 skipMembers (@expr6585 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ) .@expr6592 linkAt (@expr6593 1 ) ;
592: tok2@var2685 =@expr1073748418 validatingToken@var2683 .@expr6595 link (@expr6596 ) ;
593: }
594:
595:
596: else { if (@expr1073748421 Token ::@expr6377 Match (@expr6581 tok2@var2685 , "%varid% = %name% ." , iteratorId@var2678 ) &&@expr1073748424
597: Token ::@expr6377 Match (@expr1073748426 skipMembers (@expr6585 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ) , "begin|rbegin|cbegin|crbegin|find (" ) ) {
598: validatingToken@var2683 =@expr1073748430 skipMembers (@expr6585 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ) .@expr6592 linkAt (@expr6593 1 ) ;
599: containerToken@var2681 =@expr1073748436 skipMembers (@expr6585 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ) .@expr1073748440 tokAt (@expr1073748441 -2 ) ;
600: if (@expr1073748442 containerToken@var2681 .@expr6446 varId (@expr6447 ) ==@expr1073748445 0 ||@expr1073748446 Token ::@expr6457 simpleMatch (@expr1073748448 validatingToken@var2683 , ") ." ) ) {
601: containerToken@var2681 =@expr1073748449 nullptr ; }
602: containerAssignScope@var2682 =@expr1073748450 tok2@var2685 .@expr6574 scope (@expr6575 ) ;
603:
604:
605: tok2@var2685 =@expr1073748453 validatingToken@var2683 .@expr6595 link (@expr6596 ) ;
606: }
607:
608:
609: else { if (@expr1073748456 Token ::@expr6377 Match (@expr1073748458 tok2@var2685 , "%varid% =" , iteratorId@var2678 ) ) {
610: break ;
611: }
612:
613:
614: else { if (@expr1073748459 Token ::@expr6377 Match (@expr1073748461 tok2@var2685 , "%varid% ,|)" , iteratorId@var2678 ) ) {
615: validIterator@var2679 =@expr1073748462 true ;
616: }
617:
618:
619: else { if (@expr1073748463 !@expr6437 validIterator@var2679 &&@expr1073748465 Token ::@expr6377 Match (@expr1073748467 tok2@var2685 , "* %varid%" , iteratorId@var2678 ) ) {
620: dereferenceErasedError (@expr1073748468 eraseToken@var2684 , tok2@var2685 , tok2@var2685 .@expr6430 strAt (@expr1073748470 1 ) , inconclusiveType@var2677 ) ;
621: tok2@var2685 =@expr1073748471 tok2@var2685 .@expr6399 next (@expr6400 ) ;
622: } else { if (@expr1073748474 !@expr6437 validIterator@var2679 &&@expr1073748476 Token ::@expr6377 Match (@expr1073748478 tok2@var2685 , "%varid% . %name%" , iteratorId@var2678 ) ) {
623: dereferenceErasedError (@expr1073748479 eraseToken@var2684 , tok2@var2685 , tok2@var2685 .@expr6656 str (@expr6657 ) , inconclusiveType@var2677 ) ;
624: tok2@var2685 =@expr1073748482 tok2@var2685 .@expr6423 tokAt (@expr6587 2 ) ;
625: }
626:
627:
628:
629: else { if (@expr1073748485 tok2@var2685 .@expr6574 scope (@expr6575 ) ==@expr1073748488 invalidationScope@var2680 &&@expr1073748489 Token ::@expr6377 Match (@expr1073748491 tok2@var2685 , "return|break|continue" ) ) {
630: validatingToken@var2683 =@expr1073748492 Token ::@expr1073748493 findsimplematch (@expr1073748494 tok2@var2685 .@expr6399 next (@expr6400 ) , ";" ) ;
631: }
632:
633:
634:
635: else { if (@expr1073748497 tok2@var2685 .@expr6656 str (@expr6657 ) ==@expr1073748500 "else" ) {
636: validIterator@var2679 =@expr1073748501 true ;
637: } } } } } } } } }
638: }
639: }
640: }
641:
642: void CheckStl :: mismatchingContainerIteratorError ( const Token * tok@var2696 , const Token * iterTok@var2697 )
643: {
644: const std ::@expr1073748502 string container@var2698 (@expr1073748503 tok@var2696 ?@expr1073748504 tok@var2696 .@expr1073748505 expressionString (@expr1073748506 ) :@expr1073748507 std ::@expr6684 string (@expr1073748509 "v1" ) ) ;
645: const std ::@expr1073748510 string iter@var2699 (@expr1073748511 iterTok@var2697 ?@expr1073748512 iterTok@var2697 .@expr1073748513 expressionString (@expr1073748514 ) :@expr1073748515 std ::@expr6684 string (@expr1073748517 "it" ) ) ;
646: reportError (@expr1073748518 tok@var2696 ,
647: Severity ::@expr1073748519 error ,
648: "mismatchingContainerIterator" ,
649: "Iterator '" +@expr1073748520 iter@var2699 +@expr1073748521 "' from different container '" +@expr1073748522 container@var2698 +@expr1073748523 "' are used together." ,
650: CWE664@var2563 ,
651: Certainty ::@expr1073748524 normal ) ;
652: }
653:
654:
655: void CheckStl :: mismatchingContainersError ( const Token * tok1@var2700 , const Token * tok2@var2701 )
656: {
657: const std ::@expr1073748525 string expr1@var2702 (@expr1073748526 tok1@var2700 ?@expr1073748527 tok1@var2700 .@expr1073748528 expressionString (@expr1073748529 ) :@expr1073748530 std ::@expr6707 string (@expr1073748532 "v1" ) ) ;
658: const std ::@expr1073748533 string expr2@var2703 (@expr1073748534 tok2@var2701 ?@expr1073748535 tok2@var2701 .@expr1073748536 expressionString (@expr1073748537 ) :@expr1073748538 std ::@expr6707 string (@expr1073748540 "v2" ) ) ;
659: reportError (@expr1073748541 tok1@var2700 ,
660: Severity ::@expr1073748542 error ,
661: "mismatchingContainers" ,
662: "Iterators of different containers '" +@expr1073748543 expr1@var2702 +@expr1073748544 "' and '" +@expr1073748545 expr2@var2703 +@expr1073748546 "' are used together." ,
663: CWE664@var2563 ,
664: Certainty ::@expr1073748547 normal ) ;
665: }
666:
667: void CheckStl :: mismatchingContainerExpressionError ( const Token * tok1@var2704 , const Token * tok2@var2705 )
668: {
669: const std ::@expr1073748548 string expr1@var2706 (@expr1073748549 tok1@var2704 ?@expr1073748550 tok1@var2704 .@expr1073748551 expressionString (@expr1073748552 ) :@expr1073748553 std ::@expr6730 string (@expr1073748555 "v1" ) ) ;
670: const std ::@expr1073748556 string expr2@var2707 (@expr1073748557 tok2@var2705 ?@expr1073748558 tok2@var2705 .@expr1073748559 expressionString (@expr1073748560 ) :@expr1073748561 std ::@expr6730 string (@expr1073748563 "v2" ) ) ;
671: reportError (@expr1073748564 tok1@var2704 , Severity ::@expr1073748565 warning , "mismatchingContainerExpression" ,
672: "Iterators to containers from different expressions '" +@expr1073748566
673: expr1@var2706 +@expr1073748567 "' and '" +@expr1073748568 expr2@var2707 +@expr1073748569 "' are used together." , CWE664@var2563 , Certainty ::@expr1073748570 normal ) ;
674: }
675:
676: void CheckStl :: sameIteratorExpressionError ( const Token * tok@var2708 )
677: {
678: reportError (@expr1073748571 tok@var2708 , Severity ::@expr1073748572 style , "sameIteratorExpression" , "Same iterators expression are used for algorithm." , CWE664@var2563 , Certainty ::@expr1073748573 normal ) ;
679: }
680:
681: static const Token * getIteratorExpression ( const Token * tok@var2709 )
682: {
683: if (@expr1073748574 !@expr1073748575 tok@var2709 ) {
684: return nullptr ; }
685: if (@expr1073748576 tok@var2709 .@expr1073748577 isUnaryOp (@expr1073748578 "*" ) ) {
686: return nullptr ; }
687: if (@expr1073748579 !@expr1073748580 tok@var2709 .@expr1073748581 isName (@expr1073748582 ) ) {
688: const Token * iter1@var2710 ; iter1@var2710 =@expr1073748583 getIteratorExpression (@expr1073748584 tok@var2709 .@expr1073748585 astOperand1 (@expr1073748586 ) ) ;
689: if (@expr1073748587 iter1@var2710 ) {
690: return iter1@var2710 ; }
691: if (@expr1073748588 tok@var2709 .@expr1073748589 str (@expr1073748590 ) ==@expr1073748591 "(" ) {
692: return nullptr ; }
693: const Token * iter2@var2711 ; iter2@var2711 =@expr1073748592 getIteratorExpression (@expr1073748593 tok@var2709 .@expr1073748594 astOperand2 (@expr1073748595 ) ) ;
694: if (@expr1073748596 iter2@var2711 ) {
695: return iter2@var2711 ; }
696: } else { if (@expr1073748597 Token ::@expr6774 Match (@expr1073748599 tok@var2709 , "begin|cbegin|rbegin|crbegin|end|cend|rend|crend (" ) ) {
697: if (@expr1073748600 Token ::@expr6774 Match (@expr1073748602 tok@var2709 .@expr6779 previous (@expr6780 ) , ". %name% ( ) !!." ) ) {
698: return tok@var2709 .@expr6779 previous (@expr6780 ) .@expr1073748607 astOperand1 (@expr1073748608 ) ; }
699: if (@expr1073748609 !@expr1073748610 Token ::@expr6787 simpleMatch (@expr1073748612 tok@var2709 .@expr6779 previous (@expr6780 ) , "." ) &&@expr1073748615 Token ::@expr6774 Match (@expr1073748617 tok@var2709 , "%name% ( !!)" ) &&@expr1073748618 !@expr1073748619 Token ::@expr6787 simpleMatch (@expr1073748621 tok@var2709 .@expr1073748622 linkAt (@expr1073748623 1 ) , ") ." ) ) {
700: return tok@var2709 .@expr1073748624 next (@expr1073748625 ) .@expr1073748626 astOperand2 (@expr1073748627 ) ; }
701: } }
702: return nullptr ;
703: }
704:
705: static const Token * getAddressContainer ( const Token * tok@var2712 )
706: {
707: if (@expr1073748628 Token ::@expr1073748629 simpleMatch (@expr1073748630 tok@var2712 , "[" ) &&@expr1073748631 tok@var2712 .@expr6808 astOperand1 (@expr6809 ) ) {
708: return tok@var2712 .@expr6808 astOperand1 (@expr6809 ) ; }
709: return tok@var2712 ;
710: }
711:
712: static bool isSameIteratorContainerExpression ( const Token * tok1@var2713 ,
713: const Token * tok2@var2714 ,
714: const Library & library@var2715 ,
715: ValueFlow :: Value :: LifetimeKind kind@var2716 = ValueFlow :: Value :: LifetimeKind :: Iterator )
716: {
717: if (@expr1073748636 isSameExpression (@expr1073748637 true , false , tok1@var2713 , tok2@var2714 , library@var2715 , false , false ) ) {
718: if (@expr1073748638 astIsContainerOwned (@expr1073748639 tok1@var2713 ) &&@expr1073748640 isTemporary (@expr1073748641 true , tok1@var2713 , &@expr1073748642 library@var2715 ) ) {
719: return false ; }
720: return true ;
721: }
722: if (@expr1073748643 kind@var2716 ==@expr1073748644 ValueFlow ::@expr1073748645 Value ::@expr1073748646 LifetimeKind ::@expr1073748647 Address ) {
723: return isSameExpression (@expr1073748648 true , false , getAddressContainer (@expr1073748649 tok1@var2713 ) , getAddressContainer (@expr1073748650 tok2@var2714 ) , library@var2715 , false , false ) ;
724: }
725: return false ;
726: }
727:
728: static ValueFlow :: Value getLifetimeIteratorValue ( const Token * tok@var2717 , long long path@var2718 = 0 )
729: {
730: std ::@expr1073748652 vector < ValueFlow ::@expr6829 Value > values@var2719 ; values@var2719 =@expr1073748654 getLifetimeObjValues (@expr1073748655 tok@var2717 , false , path@var2718 ) ;
731: auto it@var2720 ; it@var2720 =@expr1073748656 std ::@expr1073748657 find_if (@expr1073748658 values@var2719 .@expr1073748659 begin (@expr1073748660 ) , values@var2719 .@expr6837 end (@expr6838 ) , [@expr1073748663 ] (@expr1073748664 const ValueFlow ::@expr6829 Value &@expr1073748666 v@var2721 ) {
732: return v@var2721 .@expr1073748667 lifetimeKind@var2722 ==@expr1073748668 ValueFlow ::@expr6845 Value ::@expr1073748670 LifetimeKind ::@expr1073748671 Iterator@expr1073748651 ;
733: } ) ;
734: if (@expr1073748672 it@var2720 !=@expr1073748673 values@var2719 .@expr6837 end (@expr6838 ) ) {
735: return *@expr1073748676 it@var2720 ; }
736: if (@expr1073748677 values@var2719 .@expr1073748678 size (@expr1073748679 ) ==@expr1073748680 1 ) {
737: return values@var2719 .@expr1073748681 front (@expr1073748682 ) ; }
738: return ValueFlow ::@expr6845 Value {@expr1073748684 } ;
739: }
740:
741: bool CheckStl :: checkIteratorPair ( const Token * tok1@var2723 , const Token * tok2@var2724 )
742: {
743: if (@expr1073748686 !@expr1073748687 tok1@var2723 ) {
744: return false ; }
745: if (@expr1073748688 !@expr1073748689 tok2@var2724 ) {
746: return false ; }
747: ValueFlow ::@expr1073748690 Value val1@var2725 ; val1@var2725 =@expr1073748691 getLifetimeIteratorValue (@expr1073748692 tok1@var2723 ) ;
748: ValueFlow ::@expr1073748693 Value val2@var2726 ; val2@var2726 =@expr1073748694 getLifetimeIteratorValue (@expr1073748695 tok2@var2724 ) ;
749: if (@expr1073748696 val1@var2725 .@expr6873 tokvalue@var2727 &&@expr1073748698 val2@var2726 .@expr6875 tokvalue@var2728 &&@expr1073748700 val1@var2725 .@expr6877 lifetimeKind@var2729 ==@expr1073748702 val2@var2726 .@expr1073748703 lifetimeKind@var2730 ) {
750: if (@expr1073748704 val1@var2725 .@expr6877 lifetimeKind@var2729 ==@expr1073748706 ValueFlow ::@expr6883 Value ::@expr6884 LifetimeKind ::@expr1073748709 Lambda ) {
751: return false ; }
752: if (@expr1073748710 tok1@var2723 .@expr6887 astParent (@expr6888 ) ==@expr1073748713 tok2@var2724 .@expr1073748714 astParent (@expr1073748715 ) &&@expr1073748716 Token ::@expr6893 Match (@expr6894 tok1@var2723 .@expr6887 astParent (@expr6888 ) , "%comp%|-" ) ) {
753: if (@expr1073748721 val1@var2725 .@expr6877 lifetimeKind@var2729 ==@expr1073748723 ValueFlow ::@expr6883 Value ::@expr6884 LifetimeKind ::@expr1073748726 Address ) {
754: return false ; }
755: if (@expr1073748727 val1@var2725 .@expr6877 lifetimeKind@var2729 ==@expr1073748729 ValueFlow ::@expr6883 Value ::@expr6884 LifetimeKind ::@expr1073748732 Object@expr1073748685 &&@expr1073748733
756: (@expr1073748734 !@expr1073748735 astIsContainer (@expr1073748736 val1@var2725 .@expr6873 tokvalue@var2727 ) ||@expr1073748738 !@expr1073748739 astIsContainer (@expr1073748740 val2@var2726 .@expr6875 tokvalue@var2728 ) ) ) {
757: return false ; }
758: }
759: if (@expr1073748742 isSameIteratorContainerExpression (@expr1073748743 val1@var2725 .@expr6873 tokvalue@var2727 , val2@var2726 .@expr6875 tokvalue@var2728 , mSettings@var29 .@expr6922 library@var3300 , val1@var2725 .@expr6877 lifetimeKind@var2729 ) ) {
760: return false ; }
761: if (@expr1073748748 val1@var2725 .@expr6873 tokvalue@var2727 .@expr6926 expressionString (@expr6927 ) ==@expr1073748752 val2@var2726 .@expr6875 tokvalue@var2728 .@expr1073748754 expressionString (@expr1073748755 ) ) {
762: iteratorsError (@expr1073748756 tok1@var2723 , val1@var2725 .@expr6873 tokvalue@var2727 , val1@var2725 .@expr6873 tokvalue@var2727 .@expr6926 expressionString (@expr6927 ) ) ; }
763: else {
764: mismatchingContainersError (@expr1073748761 val1@var2725 .@expr6873 tokvalue@var2727 , val2@var2726 .@expr6875 tokvalue@var2728 ) ; }
765: return true ;
766: }
767:
768: if (@expr1073748764 Token ::@expr6893 Match (@expr6894 tok1@var2723 .@expr6887 astParent (@expr6888 ) , "%comp%|-" ) ) {
769: if (@expr1073748769 astIsIntegral (@expr1073748770 tok1@var2723 , false ) ||@expr1073748771 astIsIntegral (@expr1073748772 tok2@var2724 , false ) ||@expr1073748773 astIsFloat (@expr1073748774 tok1@var2723 , false ) ||@expr1073748775
770: astIsFloat (@expr1073748776 tok2@var2724 , false ) ) {
771: return false ; }
772: }
773: const Token * iter1@var2731 ; iter1@var2731 =@expr1073748777 getIteratorExpression (@expr1073748778 tok1@var2723 ) ;
774: const Token * iter2@var2732 ; iter2@var2732 =@expr1073748779 getIteratorExpression (@expr1073748780 tok2@var2724 ) ;
775: if (@expr1073748781 iter1@var2731 &&@expr1073748782 iter2@var2732 &&@expr1073748783 !@expr1073748784 isSameIteratorContainerExpression (@expr1073748785 iter1@var2731 , iter2@var2732 , mSettings@var29 .@expr6922 library@var3300 ) ) {
776: mismatchingContainerExpressionError (@expr1073748787 iter1@var2731 , iter2@var2732 ) ;
777: return true ;
778: }
779: return false ;
780: }
781:
782: struct ArgIteratorInfo {
783: const Token * tok@var2733 ;
784: const Library :: ArgumentChecks :: IteratorInfo * info@var2734 ;
785: } ;
786:
787: void CheckStl :: mismatchingContainers ( )
788: {
789:
790: const SymbolDatabase * symbolDatabase@var2735 ; symbolDatabase@var2735 =@expr1073748788 mTokenizer@var28 .@expr1073748789 getSymbolDatabase (@expr1073748790 ) ;
791: for (@expr1073748791 const Scope *@expr6968 scope@var2736 :@expr1073748793 symbolDatabase@var2735 .@expr1073748794 functionScopes@var2737 ) {
792: for (@expr1073748795 const Token *@expr6968 tok@var2738 =@expr1073748797 scope@var2736 .@expr1073748798 bodyStart@var2739 .@expr1073748799 next (@expr1073748800 ) ; tok@var2738 !=@expr1073748801 scope@var2736 .@expr1073748802 bodyEnd@var2740 ; tok@var2738 =@expr1073748803 tok@var2738 .@expr1073748804 next (@expr1073748805 ) ) {
793: if (@expr1073748806 Token ::@expr6983 Match (@expr1073748808 tok@var2738 , "%comp%|-" ) ) {
794: if (@expr1073748809 checkIteratorPair (@expr1073748810 tok@var2738 .@expr1073748811 astOperand1 (@expr1073748812 ) , tok@var2738 .@expr1073748813 astOperand2 (@expr1073748814 ) ) ) {
795: continue ; }
796: }
797: if (@expr1073748815 !@expr1073748816 Token ::@expr6983 Match (@expr1073748818 tok@var2738 , "%name% ( !!)" ) ) {
798: continue ; }
799: const Token * const ftok@var2741 ; ftok@var2741 =@expr1073748819 tok@var2738 ;
800:
801: const std ::@expr1073748820 vector < const Token *@expr6968 > args@var2742 =@expr1073748822 getArguments (@expr1073748823 ftok@var2741 ) ;
802: if (@expr1073748824 args@var2742 .@expr7001 size (@expr7002 ) <@expr1073748827 2 ) {
803: continue ; }
804:
805:
806: std ::@expr1073748828 map < int , std ::@expr1073748829 vector < ArgIteratorInfo > > containers@var2743 ;
807: for (@expr1073748830 int argnr@var2744 =@expr1073748831 1 ; argnr@var2744 <=@expr1073748832 args@var2742 .@expr7001 size (@expr7002 ) ; ++@expr1073748835 argnr@var2744 ) {
808: const Library ::@expr1073748836 ArgumentChecks ::@expr1073748837 IteratorInfo * i@var2745 ; i@var2745 =@expr1073748838 mSettings@var29 .@expr7015 library@var3300 .@expr1073748840 getArgIteratorInfo (@expr1073748841 ftok@var2741 , argnr@var2744 ) ;
809: if (@expr1073748842 !@expr1073748843 i@var2745 ) {
810: continue ; }
811: const Token * const argTok@var2746 ; argTok@var2746 =@expr1073748844 args@var2742 [@expr1073748845 argnr@var2744 -@expr1073748846 1 ] ;
812: containers@var2743 [@expr1073748847 i@var2745 .@expr1073748848 container@var2747 ] .@expr1073748849 push_back (@expr1073748850 {@expr1073748851 argTok@var2746 , i@var2745 } ) ;
813: }
814:
815:
816: [@expr1073748852 &@expr7029 ] {
817: for (@expr1073748854 const auto &@expr7029 p@var2748 :@expr1073748856 containers@var2743 )
818: {
819: const std ::@expr1073748857 vector < ArgIteratorInfo > & cargs@var2749 =@expr1073748858 p@var2748 .@expr1073748859 second@var2750 ;
820: for (@expr1073748860 ArgIteratorInfo iter1@var2751 :@expr1073748861 cargs@var2749 ) {
821: for (@expr1073748862 ArgIteratorInfo iter2@var2752 :@expr1073748863 cargs@var2749 ) {
822: if (@expr1073748864 iter1@var2751 .@expr7041 tok@var2753 ==@expr1073748866 iter2@var2752 .@expr7043 tok@var2754 ) {
823: continue ; }
824: if (@expr1073748868 iter1@var2751 .@expr1073748869 info@var2755 .@expr1073748870 first@var2756 &&@expr1073748871 iter2@var2752 .@expr1073748872 info@var2757 .@expr1073748873 last@var2758 &&@expr1073748874
825: isSameExpression (@expr1073748875 true , false , iter1@var2751 .@expr7041 tok@var2753 , iter2@var2752 .@expr7043 tok@var2754 , mSettings@var29 .@expr7015 library@var3300 , false , false ) ) {
826: sameIteratorExpressionError (@expr1073748879 iter1@var2751 .@expr7041 tok@var2753 ) ; }
827: if (@expr1073748881 checkIteratorPair (@expr1073748882 iter1@var2751 .@expr7041 tok@var2753 , iter2@var2752 .@expr7043 tok@var2754 ) ) {
828: return ; }
829: }
830: }
831: }
832: } (@expr1073748885 ) ;
833: }
834: }
835: for (@expr1073748886 const Variable *@expr6968 var@var2759 :@expr1073748888 symbolDatabase@var2735 .@expr1073748889 variableList (@expr1073748890 ) ) {
836: if (@expr1073748891 var@var2759 &&@expr1073748892 var@var2759 .@expr1073748893 isStlStringType (@expr1073748894 ) &&@expr1073748895 Token ::@expr6983 Match (@expr1073748897 var@var2759 .@expr7074 nameToken (@expr7075 ) , "%var% (" ) &&@expr1073748900
837: Token ::@expr6983 Match (@expr1073748902 var@var2759 .@expr7074 nameToken (@expr7075 ) .@expr7081 tokAt (@expr7082 2 ) , "%name% . begin|cbegin|rbegin|crbegin ( ) , %name% . end|cend|rend|crend ( ) ,|)" ) ) {
838: if (@expr1073748907 var@var2759 .@expr7074 nameToken (@expr7075 ) .@expr7086 strAt (@expr1073748911 2 ) !=@expr1073748912 var@var2759 .@expr7074 nameToken (@expr7075 ) .@expr7086 strAt (@expr1073748916 8 ) ) {
839: mismatchingContainersError (@expr1073748917 var@var2759 .@expr7074 nameToken (@expr7075 ) , var@var2759 .@expr7074 nameToken (@expr7075 ) .@expr7081 tokAt (@expr7082 2 ) ) ;
840: }
841: }
842: }
843: }
844:
845: void CheckStl :: mismatchingContainerIterator ( )
846: {
847:
848: const SymbolDatabase * symbolDatabase@var2760 ; symbolDatabase@var2760 =@expr1073748925 mTokenizer@var28 .@expr1073748926 getSymbolDatabase (@expr1073748927 ) ;
849: for (@expr1073748928 const Scope *@expr7105 scope@var2761 :@expr1073748930 symbolDatabase@var2760 .@expr1073748931 functionScopes@var2762 ) {
850: for (@expr1073748932 const Token *@expr7105 tok@var2763 =@expr1073748934 scope@var2761 .@expr1073748935 bodyStart@var2764 .@expr1073748936 next (@expr1073748937 ) ; tok@var2763 !=@expr1073748938 scope@var2761 .@expr1073748939 bodyEnd@var2765 ; tok@var2763 =@expr1073748940 tok@var2763 .@expr1073748941 next (@expr1073748942 ) ) {
851: if (@expr1073748943 !@expr1073748944 astIsContainer (@expr1073748945 tok@var2763 ) ) {
852: continue ; }
853: if (@expr1073748946 !@expr1073748947 astIsLHS (@expr1073748948 tok@var2763 ) ) {
854: continue ; }
855: if (@expr1073748949 !@expr1073748950 Token ::@expr1073748951 Match (@expr1073748952 tok@var2763 .@expr7129 astParent (@expr7130 ) , ". %name% ( !!)" ) ) {
856: continue ; }
857: const Token * const ftok@var2766 ; ftok@var2766 =@expr1073748955 tok@var2763 .@expr7129 astParent (@expr7130 ) .@expr1073748958 next (@expr1073748959 ) ;
858: const std ::@expr1073748960 vector < const Token *@expr7105 > args@var2767 =@expr1073748962 getArguments (@expr1073748963 ftok@var2766 ) ;
859:
860: const Library ::@expr7140 Container * c@var2768 ; c@var2768 =@expr1073748965 tok@var2763 .@expr1073748966 valueType (@expr1073748967 ) .@expr1073748968 container@var3313 ;
861: Library ::@expr7140 Container ::@expr1073748970 Action action@var2769 ; action@var2769 =@expr1073748971 c@var2768 .@expr1073748972 getAction (@expr1073748973 tok@var2763 .@expr1073748974 strAt (@expr1073748975 2 ) ) ;
862: const Token * iterTok@var2770 ; iterTok@var2770 =@expr1073748976 nullptr ;
863: if (@expr1073748977 action@var2769 ==@expr1073748978 Library ::@expr7140 Container ::@expr7156 Action ::@expr1073748981 INSERT &&@expr1073748982 args@var2767 .@expr1073748983 size (@expr1073748984 ) ==@expr1073748985 2 ) {
864:
865: if (@expr1073748986 astIsIterator (@expr1073748987 args@var2767 .@expr1073748988 back (@expr1073748989 ) ) ) {
866: continue ; }
867: if (@expr7166 !@expr7167 astIsIterator (@expr7168 args@var2767 .@expr7169 front (@expr7170 ) ) ) {
868: continue ; }
869: iterTok@var2770 =@expr1073748995 args@var2767 .@expr7169 front (@expr7170 ) ;
870: } else { if (@expr1073748998 action@var2769 ==@expr1073748999 Library ::@expr7140 Container ::@expr7156 Action ::@expr1073749002 ERASE ) {
871: if (@expr7166 !@expr7167 astIsIterator (@expr7168 args@var2767 .@expr7169 front (@expr7170 ) ) ) {
872: continue ; }
873: iterTok@var2770 =@expr1073749008 args@var2767 .@expr7169 front (@expr7170 ) ;
874: } else {
875: continue ;
876: } }
877:
878: ValueFlow ::@expr1073749011 Value val@var2771 ; val@var2771 =@expr1073749012 getLifetimeIteratorValue (@expr1073749013 iterTok@var2770 ) ;
879: if (@expr1073749014 !@expr1073749015 val@var2771 .@expr7192 tokvalue@var2772 ) {
880: continue ; }
881: if (@expr1073749017 val@var2771 .@expr1073749018 lifetimeKind@var2773 !=@expr1073749019 ValueFlow ::@expr1073749020 Value ::@expr1073749021 LifetimeKind ::@expr1073749022 Iterator@expr1073748924 ) {
882: continue ; }
883: if (@expr1073749023 isSameIteratorContainerExpression (@expr1073749024 tok@var2763 , val@var2771 .@expr7192 tokvalue@var2772 , mSettings@var29 .@expr1073749026 library@var3300 ) ) {
884: continue ; }
885: mismatchingContainerIteratorError (@expr1073749027 tok@var2763 , iterTok@var2770 ) ;
886: }
887: }
888: }
889:
890: static const Token * getInvalidMethod ( const Token * tok@var2774 )
891: {
892: if (@expr1073749028 !@expr1073749029 astIsLHS (@expr1073749030 tok@var2774 ) ) {
893: return nullptr ; }
894: if (@expr1073749031 Token ::@expr7208 Match (@expr1073749033 tok@var2774 .@expr7210 astParent (@expr7211 ) , ". assign|clear|swap" ) ) {
895: return tok@var2774 .@expr7210 astParent (@expr7211 ) .@expr7214 next (@expr7215 ) ; }
896: if (@expr1073749040 Token ::@expr7208 Match (@expr1073749042 tok@var2774 .@expr7210 astParent (@expr7211 ) , "%assign%" ) ) {
897: return tok@var2774 .@expr7210 astParent (@expr7211 ) ; }
898: const Token * ftok@var2775 ; ftok@var2775 =@expr1073749047 nullptr ;
899: if (@expr1073749048 Token ::@expr7208 Match (@expr1073749050 tok@var2774 .@expr7210 astParent (@expr7211 ) , ". %name% (" ) ) {
900: ftok@var2775 =@expr1073749053 tok@var2774 .@expr7210 astParent (@expr7211 ) .@expr7214 next (@expr7215 ) ; }
901: if (@expr1073749058 !@expr1073749059 ftok@var2775 ) {
902: return nullptr ; }
903: if (@expr1073749060 const Library ::@expr1073749061 Container *@expr1073749062 c@var2776 =@expr1073749063 tok@var2774 .@expr1073749064 valueType (@expr1073749065 ) .@expr1073749066 container@var3313 ) {
904: Library ::@expr7243 Container ::@expr1073749068 Action action@var2777 ; action@var2777 =@expr1073749069 c@var2776 .@expr1073749070 getAction (@expr1073749071 ftok@var2775 .@expr1073749072 str (@expr1073749073 ) ) ;
905: if (@expr1073749074 c@var2776 .@expr1073749075 unstableErase@var2778 ) {
906: if (@expr1073749076 action@var2777 ==@expr1073749077 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749080 ERASE ) {
907: return ftok@var2775 ; }
908: }
909: if (@expr1073749081 c@var2776 .@expr1073749082 unstableInsert@var2779 ) {
910: if (@expr1073749083 action@var2777 ==@expr1073749084 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749087 RESIZE ) {
911: return ftok@var2775 ; }
912: if (@expr1073749088 action@var2777 ==@expr1073749089 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749092 CLEAR ) {
913: return ftok@var2775 ; }
914: if (@expr1073749093 action@var2777 ==@expr1073749094 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749097 PUSH ) {
915: return ftok@var2775 ; }
916: if (@expr1073749098 action@var2777 ==@expr1073749099 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749102 POP ) {
917: return ftok@var2775 ; }
918: if (@expr1073749103 action@var2777 ==@expr1073749104 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749107 INSERT ) {
919: return ftok@var2775 ; }
920: if (@expr1073749108 action@var2777 ==@expr1073749109 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749112 CHANGE ) {
921: return ftok@var2775 ; }
922: if (@expr1073749113 action@var2777 ==@expr1073749114 Library ::@expr7243 Container ::@expr7255 Action ::@expr1073749117 CHANGE_INTERNAL ) {
923: return ftok@var2775 ; }
924: if (@expr1073749118 Token ::@expr7208 Match (@expr1073749120 ftok@var2775 , "insert|emplace" ) ) {
925: return ftok@var2775 ; }
926: }
927: }
928: return nullptr ;
929: }
930:
931: struct InvalidContainerAnalyzer {
932: struct Info {
933: struct Reference {
934: const Token * tok@var2780 ;
935: std :: list < std :: pair < const Token * , std :: string > > errorPath@var2781 ;
936: const Token * ftok@var2782 ;
937: } ;
938: std :: unordered_map < int , Reference > expressions@var2783 ;
939: std :: list < std :: pair < const Token * , std :: string > > errorPath@var2784 ;
940: void add ( const std :: vector < Reference > & refs@var2785 ) {
941: for (@expr1073749121 const Reference &@expr1073749122 r@var2786 :@expr1073749123 refs@var2785 ) {
942: add (@expr1073749124 r@var2786 ) ;
943: }
944: }
945: void add ( const Reference & r@var2787 ) {
946: if (@expr1073749125 !@expr1073749126 r@var2787 .@expr7303 tok@var2788 ) {
947: return ; }
948: expressions@var2783 .@expr1073749128 insert (@expr1073749129 std ::@expr1073749130 make_pair (@expr1073749131 r@var2787 .@expr7303 tok@var2788 .@expr1073749133 exprId (@expr1073749134 ) , r@var2787 ) ) ;
949: }
950:
951: std :: vector < Reference > invalidTokens ( ) const {
952: std ::@expr1073749135 vector < Reference > result@var2789 ;
953: std ::@expr1073749136 transform (@expr1073749137 expressions@var2783 .@expr1073749138 begin (@expr1073749139 ) , expressions@var2783 .@expr1073749140 end (@expr1073749141 ) , std ::@expr1073749142 back_inserter (@expr1073749143 result@var2789 ) , SelectMapValues {@expr1073749144 } ) ;
954: return result@var2789 ;
955: }
956: } ;
957: std :: unordered_map < const Function * , Info > invalidMethods@var2790 ;
958:
959: std :: vector < Info :: Reference > invalidatesContainer ( const Token * tok@var2791 ) const {
960: std ::@expr1073749145 vector < Info ::@expr7322 Reference > result@var2792 ;
961: if (@expr1073749147 Token ::@expr1073749148 Match (@expr1073749149 tok@var2791 , "%name% (" ) ) {
962: const Function * f@var2793 ; f@var2793 =@expr1073749150 tok@var2791 .@expr1073749151 function (@expr1073749152 ) ;
963: if (@expr1073749153 !@expr1073749154 f@var2793 ) {
964: return result@var2792 ; }
965: std ::@expr1073749155 pair < const Token *@expr7332 , std ::@expr7322 string > epi@var2794 ; epi@var2794 =@expr1073749158 std ::@expr1073749159 make_pair (@expr1073749160 tok@var2791 , "Calling function " +@expr1073749161 tok@var2791 .@expr1073749162 str (@expr1073749163 ) ) ;
966: const bool dependsOnThis@var2795 =@expr1073749164 exprDependsOnThis (@expr1073749165 tok@var2791 .@expr1073749166 next (@expr1073749167 ) ) ;
967: auto it@var2796 ; it@var2796 =@expr1073749168 invalidMethods@var2790 .@expr1073749169 find (@expr1073749170 f@var2793 ) ;
968: if (@expr1073749171 it@var2796 !=@expr1073749172 invalidMethods@var2790 .@expr1073749173 end (@expr1073749174 ) ) {
969: std ::@expr1073749175 vector < Info ::@expr7322 Reference > refs@var2797 ; refs@var2797 =@expr1073749177 it@var2796 .@expr1073749178 second@var2798 .@expr1073749179 invalidTokens (@expr1073749180 ) ;
970: std ::@expr1073749181 copy_if (@expr1073749182 refs@var2797 .@expr1073749183 begin (@expr1073749184 ) , refs@var2797 .@expr1073749185 end (@expr1073749186 ) , std ::@expr1073749187 back_inserter (@expr1073749188 result@var2792 ) , [@expr1073749189 &@expr7366 ] (@expr1073749191 const Info ::@expr7322 Reference &@expr7366 r@var2799 ) {
971: const Variable * var@var2800 ; var@var2800 =@expr1073749194 r@var2799 .@expr1073749195 tok@var2801 .@expr1073749196 variable (@expr1073749197 ) ;
972: if (@expr1073749198 !@expr1073749199 var@var2800 ) {
973: return false ; }
974: if (@expr1073749200 dependsOnThis@var2795 &&@expr1073749201 !@expr1073749202 var@var2800 .@expr1073749203 isLocal (@expr1073749204 ) &&@expr1073749205 !@expr1073749206 var@var2800 .@expr1073749207 isGlobal (@expr1073749208 ) &&@expr1073749209 !@expr1073749210 var@var2800 .@expr1073749211 isStatic (@expr1073749212 ) ) {
975: return true ; }
976: if (@expr1073749213 !@expr1073749214 var@var2800 .@expr1073749215 isArgument (@expr1073749216 ) ) {
977: return false ; }
978: if (@expr1073749217 !@expr1073749218 var@var2800 .@expr1073749219 isReference (@expr1073749220 ) ) {
979: return false ; }
980: return true ;
981: } ) ;
982: std ::@expr1073749221 vector < const Token *@expr7332 > args@var2802 ; args@var2802 =@expr1073749223 getArguments (@expr1073749224 tok@var2791 ) ;
983: for (@expr1073749225 Info ::@expr7322 Reference &@expr7366 r@var2803 :@expr1073749228 result@var2792 ) {
984: r@var2803 .@expr1073749229 errorPath@var2804 .@expr1073749230 push_front (@expr1073749231 epi@var2794 ) ;
985: r@var2803 .@expr1073749232 ftok@var2805 =@expr1073749233 tok@var2791 ;
986: const Variable * var@var2806 ; var@var2806 =@expr1073749234 r@var2803 .@expr7411 tok@var2807 .@expr1073749236 variable (@expr1073749237 ) ;
987: if (@expr1073749238 !@expr1073749239 var@var2806 ) {
988: continue ; }
989: if (@expr1073749240 var@var2806 .@expr1073749241 isArgument (@expr1073749242 ) ) {
990: int n@var2808 ; n@var2808 =@expr1073749243 getArgumentPos (@expr1073749244 var@var2806 , f@var2793 ) ;
991: const Token * tok2@var2809 ; tok2@var2809 =@expr1073749245 nullptr ;
992: if (@expr1073749246 n@var2808 >=@expr1073749247 0 &&@expr1073749248 n@var2808 <@expr1073749249 args@var2802 .@expr1073749250 size (@expr1073749251 ) ) {
993: tok2@var2809 =@expr1073749252 args@var2802 [@expr1073749253 n@var2808 ] ; }
994: r@var2803 .@expr7411 tok@var2807 =@expr1073749255 tok2@var2809 ;
995: }
996: }
997: }
998: } else { if (@expr1073749256 astIsContainer (@expr1073749257 tok@var2791 ) ) {
999: const Token * ftok@var2810 ; ftok@var2810 =@expr1073749258 getInvalidMethod (@expr1073749259 tok@var2791 ) ;
1000: if (@expr1073749260 ftok@var2810 ) {
1001: std ::@expr1073749261 list < std ::@expr7322 pair < const Token *@expr7332 , std ::@expr7322 string > > ep@var2811 ;
1002: ep@var2811 .@expr1073749265 emplace_front (@expr1073749266 ftok@var2810 ,
1003: "After calling '" +@expr1073749267 ftok@var2810 .@expr1073749268 expressionString (@expr1073749269 ) +@expr1073749270
1004: "', iterators or references to the container's data may be invalid ." ) ;
1005: result@var2792 .@expr1073749271 push_back (@expr1073749272 Info ::@expr1073749273 Reference {@expr1073749274 tok@var2791 , ep@var2811 , ftok@var2810 } ) ;
1006: }
1007: } }
1008: return result@var2792 ;
1009: }
1010:
1011: void analyze ( const SymbolDatabase * symboldatabase@var2812 ) {
1012: for (@expr1073749275 const Scope *@expr7452 scope@var2813 :@expr1073749277 symboldatabase@var2812 .@expr1073749278 functionScopes@var2814 ) {
1013: const Function * f@var2815 ; f@var2815 =@expr1073749279 scope@var2813 .@expr1073749280 function@var2816 ;
1014: if (@expr1073749281 !@expr1073749282 f@var2815 ) {
1015: continue ; }
1016: for (@expr1073749283 const Token *@expr7452 tok@var2817 =@expr1073749285 scope@var2813 .@expr1073749286 bodyStart@var2818 ; tok@var2817 !=@expr1073749287 scope@var2813 .@expr1073749288 bodyEnd@var2819 ; tok@var2817 =@expr1073749289 tok@var2817 .@expr1073749290 next (@expr1073749291 ) ) {
1017: if (@expr1073749292 Token ::@expr1073749293 Match (@expr1073749294 tok@var2817 , "if|while|for|goto|return" ) ) {
1018: break ; }
1019: std ::@expr1073749295 vector < Info ::@expr1073749296 Reference > c@var2820 ; c@var2820 =@expr1073749297 invalidatesContainer (@expr1073749298 tok@var2817 ) ;
1020: if (@expr1073749299 c@var2820 .@expr1073749300 empty (@expr1073749301 ) ) {
1021: continue ; }
1022: invalidMethods@var2790 [@expr1073749302 f@var2815 ] .@expr1073749303 add (@expr1073749304 c@var2820 ) ;
1023: }
1024: }
1025: }
1026: } ;
1027:
1028: static const Token * getLoopContainer ( const Token * tok@var2821 )
1029: {
1030: if (@expr1073749305 !@expr1073749306 Token ::@expr7483 simpleMatch (@expr1073749308 tok@var2821 , "for (" ) ) {
1031: return nullptr ; }
1032: const Token * sepTok@var2822 ; sepTok@var2822 =@expr1073749309 tok@var2821 .@expr1073749310 next (@expr1073749311 ) .@expr1073749312 astOperand2 (@expr1073749313 ) ;
1033: if (@expr1073749314 !@expr1073749315 Token ::@expr7483 simpleMatch (@expr1073749317 sepTok@var2822 , ":" ) ) {
1034: return nullptr ; }
1035: return sepTok@var2822 .@expr1073749318 astOperand2 (@expr1073749319 ) ;
1036: }
1037:
1038: static const ValueFlow :: Value * getInnerLifetime ( const Token * tok@var2823 ,
1039: int id@var2824 ,
1040: std :: list < std :: pair < const Token * , std :: string > > * errorPath@var2825 = nullptr ,
1041: int depth@var2826 = 4 )
1042: {
1043: if (@expr1073749320 depth@var2826 <@expr1073749321 0 ) {
1044: return nullptr ; }
1045: if (@expr1073749322 !@expr1073749323 tok@var2823 ) {
1046: return nullptr ; }
1047: for (@expr1073749324 const ValueFlow ::@expr1073749325 Value &@expr1073749326 val@var2827 :@expr1073749327 tok@var2823 .@expr1073749328 values (@expr1073749329 ) ) {
1048: if (@expr1073749330 !@expr1073749331 val@var2827 .@expr1073749332 isLocalLifetimeValue (@expr1073749333 ) ) {
1049: continue ; }
1050: if (@expr1073749334 contains (@expr1073749335 {@expr1073749336 ValueFlow ::@expr7513 Value ::@expr7514 LifetimeKind ::@expr1073749339 Address ,
1051: ValueFlow ::@expr7513 Value ::@expr7514 LifetimeKind ::@expr1073749342 SubObject ,
1052: ValueFlow ::@expr7513 Value ::@expr7514 LifetimeKind ::@expr1073749345 Lambda } ,
1053: val@var2827 .@expr1073749346 lifetimeKind@var2828 ) ) {
1054: if (@expr1073749347 val@var2827 .@expr1073749348 isInconclusive (@expr1073749349 ) ) {
1055: return nullptr ; }
1056: if (@expr1073749350 val@var2827 .@expr7527 capturetok@var2829 ) {
1057: return getInnerLifetime (@expr1073749352 val@var2827 .@expr7527 capturetok@var2829 , id@var2824 , errorPath@var2825 , depth@var2826 -@expr7530 1 ) ; }
1058: if (@expr1073749355 errorPath@var2825 ) {
1059: errorPath@var2825 .@expr1073749356 insert (@expr1073749357 errorPath@var2825 .@expr1073749358 end (@expr1073749359 ) , val@var2827 .@expr7536 errorPath@var2830 .@expr1073749361 begin (@expr1073749362 ) , val@var2827 .@expr7536 errorPath@var2830 .@expr1073749364 end (@expr1073749365 ) ) ; }
1060: return getInnerLifetime (@expr1073749366 val@var2827 .@expr7543 tokvalue@var2831 , id@var2824 , errorPath@var2825 , depth@var2826 -@expr7530 1 ) ;
1061: }
1062: if (@expr1073749369 !@expr1073749370 val@var2827 .@expr7543 tokvalue@var2831 .@expr1073749372 variable (@expr1073749373 ) ) {
1063: continue ; }
1064: if (@expr1073749374 val@var2827 .@expr7543 tokvalue@var2831 .@expr1073749376 varId (@expr1073749377 ) !=@expr1073749378 id@var2824 ) {
1065: continue ; }
1066: return &@expr1073749379 val@var2827 ;
1067: }
1068: return nullptr ;
1069: }
1070:
1071: void CheckStl :: invalidContainer ( )
1072: {
1073: const SymbolDatabase * symbolDatabase@var2832 ; symbolDatabase@var2832 =@expr1073749380 mTokenizer@var28 .@expr1073749381 getSymbolDatabase (@expr1073749382 ) ;
1074: const Library &@expr7559 library@var2833 =@expr1073749384 mSettings@var29 .@expr7561 library@var3300 ;
1075: InvalidContainerAnalyzer analyzer@var2834 ;
1076: analyzer@var2834 .@expr1073749386 analyze (@expr1073749387 symbolDatabase@var2832 ) ;
1077: for (@expr1073749388 const Scope *@expr7565 scope@var2835 :@expr1073749390 symbolDatabase@var2832 .@expr1073749391 functionScopes@var2836 ) {
1078: for (@expr1073749392 const Token *@expr7565 tok@var2837 =@expr1073749394 scope@var2835 .@expr1073749395 bodyStart@var2838 .@expr1073749396 next (@expr1073749397 ) ; tok@var2837 !=@expr1073749398 scope@var2835 .@expr1073749399 bodyEnd@var2839 ; tok@var2837 =@expr1073749400 tok@var2837 .@expr7577 next (@expr7578 ) ) {
1079: if (@expr1073749403 const Token *@expr7565 contTok@var2840 =@expr1073749405 getLoopContainer (@expr1073749406 tok@var2837 ) ) {
1080: const Token * blockStart@var2841 ; blockStart@var2841 =@expr1073749407 tok@var2837 .@expr7577 next (@expr7578 ) .@expr1073749410 link (@expr1073749411 ) .@expr1073749412 next (@expr1073749413 ) ;
1081: const Token * blockEnd@var2842 ; blockEnd@var2842 =@expr1073749414 blockStart@var2841 .@expr1073749415 link (@expr1073749416 ) ;
1082: if (@expr1073749417 contTok@var2840 .@expr7594 exprId (@expr7595 ) ==@expr1073749420 0 ) {
1083: continue ; }
1084: if (@expr1073749421 !@expr1073749422 astIsContainer (@expr1073749423 contTok@var2840 ) ) {
1085: continue ; }
1086: for (@expr1073749424 const Token *@expr7565 tok2@var2843 =@expr1073749426 blockStart@var2841 ; tok2@var2843 !=@expr1073749427 blockEnd@var2842 ; tok2@var2843 =@expr1073749428 tok2@var2843 .@expr1073749429 next (@expr1073749430 ) ) {
1087: bool bail@var2844 ; bail@var2844 =@expr1073749431 false ;
1088: for (@expr1073749432 const InvalidContainerAnalyzer ::@expr7609 Info ::@expr7609 Reference &@expr7559 r@var2845 :@expr1073749436 analyzer@var2834 .@expr7613 invalidatesContainer (@expr1073749438 tok2@var2843 ) ) {
1089: if (@expr1073749439 !@expr1073749440 astIsContainer (@expr1073749441 r@var2845 .@expr7618 tok@var2846 ) ) {
1090: continue ; }
1091: if (@expr1073749443 r@var2845 .@expr7618 tok@var2846 .@expr1073749445 exprId (@expr1073749446 ) !=@expr1073749447 contTok@var2840 .@expr7594 exprId (@expr7595 ) ) {
1092: continue ; }
1093: const Scope * s@var2847 ; s@var2847 =@expr1073749450 tok2@var2843 .@expr1073749451 scope (@expr1073749452 ) ;
1094: if (@expr1073749453 !@expr1073749454 s@var2847 ) {
1095: continue ; }
1096: if (@expr1073749455 isReturnScope (@expr1073749456 s@var2847 .@expr1073749457 bodyEnd@var2848 , &@expr1073749458 mSettings@var29 .@expr7561 library@var3300 ) ) {
1097: continue ; }
1098: invalidContainerLoopError (@expr1073749460 r@var2845 .@expr1073749461 ftok@var2849 , tok@var2837 , r@var2845 .@expr1073749462 errorPath@var2850 ) ;
1099: bail@var2844 =@expr1073749463 true ;
1100: break ;
1101: }
1102: if (@expr1073749464 bail@var2844 ) {
1103: break ; }
1104: }
1105: } else {
1106: for (@expr1073749465 const InvalidContainerAnalyzer ::@expr7609 Info ::@expr7609 Reference &@expr7559 r@var2851 :@expr1073749469 analyzer@var2834 .@expr7613 invalidatesContainer (@expr1073749471 tok@var2837 ) ) {
1107: if (@expr1073749472 !@expr1073749473 astIsContainer (@expr1073749474 r@var2851 .@expr7651 tok@var2852 ) ) {
1108: continue ; }
1109: std ::@expr1073749476 set < int > skipVarIds@var2853 ;
1110:
1111: const Token * assignExpr@var2854 ; assignExpr@var2854 =@expr1073749477 tok@var2837 ;
1112: while (@expr1073749478 assignExpr@var2854 .@expr7655 astParent (@expr7656 ) ) {
1113: bool isRHS@var2855 ; isRHS@var2855 =@expr1073749481 astIsRHS (@expr1073749482 assignExpr@var2854 ) ;
1114: assignExpr@var2854 =@expr1073749483 assignExpr@var2854 .@expr7655 astParent (@expr7656 ) ;
1115: if (@expr1073749486 Token ::@expr7663 Match (@expr7664 assignExpr@var2854 , "%assign%" ) ) {
1116: if (@expr1073749489 !@expr1073749490 isRHS@var2855 ) {
1117: assignExpr@var2854 =@expr1073749491 nullptr ; }
1118: break ;
1119: }
1120: }
1121: if (@expr1073749492 Token ::@expr7663 Match (@expr7664 assignExpr@var2854 , "%assign%" ) &&@expr1073749495 Token ::@expr7663 Match (@expr1073749497 assignExpr@var2854 .@expr7674 astOperand1 (@expr7675 ) , "%var%" ) ) {
1122: skipVarIds@var2853 .@expr7676 insert (@expr1073749501 assignExpr@var2854 .@expr7674 astOperand1 (@expr7675 ) .@expr1073749504 varId (@expr1073749505 ) ) ; }
1123: const Token * endToken@var2856 ; endToken@var2856 =@expr1073749506 nextAfterAstRightmostLeaf (@expr1073749507 tok@var2837 .@expr7577 next (@expr7578 ) .@expr1073749510 astParent (@expr1073749511 ) ) ;
1124: if (@expr1073749512 !@expr1073749513 endToken@var2856 ) {
1125: endToken@var2856 =@expr1073749514 tok@var2837 .@expr7577 next (@expr7578 ) ; }
1126: const ValueFlow ::@expr7693 Value * v@var2857 ; v@var2857 =@expr1073749518 nullptr ;
1127: std ::@expr1073749519 list < std ::@expr7609 pair < const Token *@expr7565 , std ::@expr7609 string > > errorPath@var2858 ;
1128: PathAnalysis ::@expr1073749523 Info info@var2859 ; info@var2859 =@expr1073749524
1129: PathAnalysis {@expr1073749525 endToken@var2856 , library@var2833 } .@expr1073749526 forwardFind (@expr1073749527 [@expr1073749528 &@expr7559 ] (@expr1073749530 const PathAnalysis ::@expr7609 Info &@expr7559 info@var2860 ) {
1130: if (@expr1073749533 !@expr1073749534 info@var2860 .@expr7711 tok@var2861 .@expr7712 variable (@expr7713 ) ) {
1131: return false ; }
1132: if (@expr1073749538 info@var2860 .@expr7711 tok@var2861 .@expr7716 varId (@expr7717 ) ==@expr1073749542 0 ) {
1133: return false ; }
1134: if (@expr1073749543 skipVarIds@var2853 .@expr1073749544 count (@expr1073749545 info@var2860 .@expr7711 tok@var2861 .@expr7716 varId (@expr7717 ) ) >@expr1073749549 0 ) {
1135: return false ; }
1136:
1137:
1138: if (@expr1073749550 Token ::@expr7663 Match (@expr1073749552 info@var2860 .@expr7711 tok@var2861 .@expr1073749554 astParent (@expr1073749555 ) , "%assign%" ) &&@expr1073749556 astIsLHS (@expr1073749557 info@var2860 .@expr7711 tok@var2861 ) ) {
1139: skipVarIds@var2853 .@expr7676 insert (@expr1073749560 info@var2860 .@expr7711 tok@var2861 .@expr7716 varId (@expr7717 ) ) ; }
1140: if (@expr1073749564 info@var2860 .@expr7711 tok@var2861 .@expr7712 variable (@expr7713 ) .@expr1073749568 isReference (@expr1073749569 ) &&@expr1073749570 !@expr1073749571 isVariableDecl (@expr1073749572 info@var2860 .@expr7711 tok@var2861 ) &&@expr1073749574
1141: reaches (@expr1073749575 info@var2860 .@expr7711 tok@var2861 .@expr7712 variable (@expr7713 ) .@expr1073749579 nameToken (@expr1073749580 ) , tok@var2837 , library@var2833 , nullptr ) ) {
1142:
1143: std ::@expr1073749581 list < std ::@expr7609 pair < const Token *@expr7565 , std ::@expr7609 string > > ep@var2862 ;
1144: bool addressOf@var2863 ; addressOf@var2863 =@expr1073749585 false ;
1145: const Variable * var@var2864 ; var@var2864 =@expr1073749586 getLifetimeVariable (@expr1073749587 info@var2860 .@expr7711 tok@var2861 , ep@var2862 , &@expr1073749589 addressOf@var2863 ) ;
1146:
1147: if (@expr1073749590 var@var2864 &&@expr1073749591 var@var2864 .@expr1073749592 declarationId (@expr1073749593 ) ==@expr1073749594 r@var2851 .@expr7651 tok@var2852 .@expr7772 varId (@expr7773 ) &&@expr1073749598 !@expr1073749599 addressOf@var2863 ) {
1148:
1149: if (@expr1073749600 var@var2864 .@expr1073749601 isArgument (@expr1073749602 ) ||@expr1073749603
1150: (@expr1073749604 !@expr1073749605 var@var2864 .@expr1073749606 isReference (@expr1073749607 ) &&@expr1073749608 !@expr1073749609 var@var2864 .@expr1073749610 isRValueReference (@expr1073749611 ) &&@expr1073749612 !@expr1073749613 isVariableDecl (@expr1073749614 tok@var2837 ) &&@expr1073749615
1151: reaches (@expr1073749616 var@var2864 .@expr1073749617 nameToken (@expr1073749618 ) , tok@var2837 , library@var2833 , &@expr1073749619 ep@var2862 ) ) ) {
1152: errorPath@var2858 =@expr1073749620 ep@var2862 ;
1153: return true ;
1154: }
1155: }
1156: }
1157: std ::@expr1073749621 list < std ::@expr7609 pair < const Token *@expr7565 , std ::@expr7609 string > > ep@var2865 ;
1158: const ValueFlow ::@expr7693 Value * val@var2866 ; val@var2866 =@expr1073749626 getInnerLifetime (@expr1073749627 info@var2860 .@expr7711 tok@var2861 , r@var2851 .@expr7651 tok@var2852 .@expr7772 varId (@expr7773 ) , &@expr7808 ep@var2865 ) ;
1159:
1160: if (@expr1073749633 val@var2866 &&@expr1073749634 val@var2866 .@expr7811 tokvalue@var2867 !=@expr1073749636 tok@var2837 &&@expr1073749637 reaches (@expr1073749638 val@var2866 .@expr7811 tokvalue@var2867 , tok@var2837 , library@var2833 , &@expr7808 ep@var2865 ) ) {
1161: v@var2857 =@expr1073749641 val@var2866 ;
1162: errorPath@var2858 =@expr1073749642 ep@var2865 ;
1163: return true ;
1164: }
1165: return false ;
1166: } ) ;
1167: if (@expr1073749643 !@expr1073749644 info@var2859 .@expr7821 tok@var2868 ) {
1168: continue ; }
1169: errorPath@var2858 .@expr7822 insert (@expr1073749647 errorPath@var2858 .@expr7824 end (@expr7825 ) , info@var2859 .@expr7826 errorPath@var2869 .@expr1073749651 begin (@expr1073749652 ) , info@var2859 .@expr7826 errorPath@var2869 .@expr1073749654 end (@expr1073749655 ) ) ;
1170: errorPath@var2858 .@expr7822 insert (@expr1073749657 errorPath@var2858 .@expr7824 end (@expr7825 ) , r@var2851 .@expr7836 errorPath@var2870 .@expr1073749661 begin (@expr1073749662 ) , r@var2851 .@expr7836 errorPath@var2870 .@expr1073749664 end (@expr1073749665 ) ) ;
1171: if (@expr1073749666 v@var2857 ) {
1172: invalidContainerError (@expr1073749667 info@var2859 .@expr7821 tok@var2868 , r@var2851 .@expr7651 tok@var2852 , v@var2857 , errorPath@var2858 ) ;
1173: } else {
1174: invalidContainerReferenceError (@expr1073749670 info@var2859 .@expr7821 tok@var2868 , r@var2851 .@expr7651 tok@var2852 , errorPath@var2858 ) ;
1175: }
1176: }
1177: }
1178: }
1179: }
1180: }
1181:
1182: void CheckStl :: invalidContainerLoopError ( const Token * tok@var2871 , const Token * loopTok@var2872 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2873 )
1183: {
1184: const std ::@expr7849 string method@var2874 =@expr1073749674 tok@var2871 ?@expr1073749675 tok@var2871 .@expr1073749676 str (@expr1073749677 ) :@expr1073749678 "erase" ;
1185: errorPath@var2873 .@expr7855 emplace_back (@expr1073749680 loopTok@var2872 , "Iterating container here." ) ;
1186:
1187:
1188: errorPath@var2873 .@expr1073749681 remove_if (@expr1073749682 [@expr1073749683 &@expr7860 ] (@expr1073749685 const std ::@expr7849 pair < const Token *@expr1073749687 , std ::@expr7849 string > &@expr7860 epi@var2875 ) {
1189: return epi@var2875 .@expr1073749690 first@var2876 ==@expr1073749691 tok@var2871 ;
1190: } ) ;
1191:
1192: const std ::@expr7849 string msg@var2877 =@expr1073749693 "Calling '" +@expr1073749694 method@var2874 +@expr1073749695 "' while iterating the container is invalid." ;
1193: errorPath@var2873 .@expr7855 emplace_back (@expr1073749697 tok@var2871 , "" ) ;
1194: reportError (@expr1073749698 errorPath@var2873 , Severity ::@expr1073749699 error , "invalidContainerLoop" , msg@var2877 , CWE664@var2563 , Certainty ::@expr1073749700 normal ) ;
1195: }
1196:
1197: void CheckStl :: invalidContainerError ( const Token * tok@var2878 , const Token * , const ValueFlow :: Value * val@var2879 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2880 )
1198: {
1199: const bool inconclusive@var2881 =@expr1073749701 val@var2879 ?@expr1073749702 val@var2879 .@expr1073749703 isInconclusive (@expr1073749704 ) :@expr1073749705 false ;
1200: if (@expr1073749706 val@var2879 ) {
1201: errorPath@var2880 .@expr1073749707 insert (@expr1073749708 errorPath@var2880 .@expr1073749709 begin (@expr1073749710 ) , val@var2879 .@expr7887 errorPath@var2882 .@expr1073749712 begin (@expr1073749713 ) , val@var2879 .@expr7887 errorPath@var2882 .@expr1073749715 end (@expr1073749716 ) ) ; }
1202: std ::@expr1073749717 string msg@var2883 ; msg@var2883 =@expr1073749718 "Using " +@expr1073749719 lifetimeMessage (@expr1073749720 tok@var2878 , val@var2879 , errorPath@var2880 ) ;
1203: errorPath@var2880 .@expr1073749721 emplace_back (@expr1073749722 tok@var2878 , "" ) ;
1204: reportError (@expr1073749723 errorPath@var2880 , Severity ::@expr1073749724 error , "invalidContainer" , msg@var2883 +@expr1073749725 " that may be invalid." , CWE664@var2563 , inconclusive@var2881 ?@expr1073749726 Certainty ::@expr1073749727 inconclusive :@expr1073749728 Certainty ::@expr1073749729 normal ) ;
1205: }
1206:
1207: void CheckStl :: invalidContainerReferenceError ( const Token * tok@var2884 , const Token * contTok@var2885 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2886 )
1208: {
1209: std ::@expr1073749730 string name@var2887 ; name@var2887 =@expr1073749731 contTok@var2885 ?@expr1073749732 contTok@var2885 .@expr1073749733 expressionString (@expr1073749734 ) :@expr1073749735 "x" ;
1210: std ::@expr1073749736 string msg@var2888 ; msg@var2888 =@expr1073749737 "Reference to " +@expr1073749738 name@var2887 ;
1211: errorPath@var2886 .@expr1073749739 emplace_back (@expr1073749740 tok@var2884 , "" ) ;
1212: reportError (@expr1073749741 errorPath@var2886 , Severity ::@expr1073749742 error , "invalidContainerReference" , msg@var2888 +@expr1073749743 " that may be invalid." , CWE664@var2563 , Certainty ::@expr1073749744 normal ) ;
1213: }
1214:
1215: void CheckStl :: stlOutOfBounds ( )
1216: {
1217: const SymbolDatabase * const symbolDatabase@var2889 ; symbolDatabase@var2889 =@expr1073749745 mTokenizer@var28 .@expr1073749746 getSymbolDatabase (@expr1073749747 ) ;
1218:
1219:
1220: for (@expr1073749748 const Scope &@expr7925 scope@var2890 :@expr1073749750 symbolDatabase@var2889 .@expr1073749751 scopeList@var2891 ) {
1221: const Token * tok@var2892 ; tok@var2892 =@expr1073749752 scope@var2890 .@expr1073749753 classDef@var2893 ;
1222:
1223: if (@expr1073749754 (@expr1073749755 !@expr1073749756 scope@var2890 .@expr1073749757 isLoopScope (@expr1073749758 ) &&@expr1073749759 scope@var2890 .@expr7936 type@var2894 !=@expr1073749761 Scope ::@expr1073749762 eIf ) ||@expr1073749763 !@expr1073749764 tok@var2892 ) {
1224: continue ; }
1225:
1226: const Token * condition@var2895 ; condition@var2895 =@expr1073749765 nullptr ;
1227: if (@expr1073749766 scope@var2890 .@expr7936 type@var2894 ==@expr1073749768 Scope ::@expr1073749769 eFor ) {
1228: if (@expr1073749770 Token ::@expr7947 simpleMatch (@expr1073749772 tok@var2892 .@expr7949 next (@expr7950 ) .@expr7951 astOperand2 (@expr7952 ) , ";" ) &&@expr1073749777 Token ::@expr7947 simpleMatch (@expr1073749779 tok@var2892 .@expr7949 next (@expr7950 ) .@expr7951 astOperand2 (@expr7952 ) .@expr7960 astOperand2 (@expr7961 ) , ";" ) ) {
1229: condition@var2895 =@expr1073749786 tok@var2892 .@expr7949 next (@expr7950 ) .@expr7951 astOperand2 (@expr7952 ) .@expr7960 astOperand2 (@expr7961 ) .@expr1073749793 astOperand1 (@expr1073749794 ) ; }
1230: } else { if (@expr1073749795 Token ::@expr7947 simpleMatch (@expr1073749797 tok@var2892 , "do {" ) &&@expr1073749798 Token ::@expr7947 simpleMatch (@expr1073749800 tok@var2892 .@expr7977 linkAt (@expr7978 1 ) , "} while (" ) ) {
1231: condition@var2895 =@expr1073749803 tok@var2892 .@expr7977 linkAt (@expr7978 1 ) .@expr1073749806 tokAt (@expr1073749807 2 ) .@expr1073749808 astOperand2 (@expr1073749809 ) ; }
1232: else {
1233: condition@var2895 =@expr1073749810 tok@var2892 .@expr7949 next (@expr7950 ) .@expr7951 astOperand2 (@expr7952 ) ; } }
1234:
1235: if (@expr1073749815 !@expr1073749816 condition@var2895 ) {
1236: continue ; }
1237:
1238: std ::@expr1073749817 vector < const Token *@expr7994 > conds@var2896 ;
1239:
1240: visitAstNodes (@expr1073749819 condition@var2895 ,
1241: [@expr1073749820 &@expr7925 ] (@expr1073749822 const Token *@expr7994 cond@var2897 ) {
1242: if (@expr1073749824 Token ::@expr8001 Match (@expr1073749826 cond@var2897 , "%oror%|&&" ) ) {
1243: return ChildrenToVisit ::@expr1073749827 op1_and_op2 ; }
1244: if (@expr1073749828 cond@var2897 .@expr1073749829 isComparisonOp (@expr1073749830 ) ) {
1245: conds@var2896 .@expr1073749831 emplace_back (@expr1073749832 cond@var2897 ) ; }
1246: return ChildrenToVisit ::@expr1073749833 none ;
1247: } ) ;
1248:
1249: for (@expr1073749834 const Token *@expr7994 cond@var2898 :@expr1073749836 conds@var2896 ) {
1250: const Token * vartok@var2899 ;
1251: const Token * containerToken@var2900 ;
1252:
1253: if (@expr1073749837 cond@var2898 .@expr1073749838 str (@expr1073749839 ) ==@expr1073749840 "<=" &&@expr1073749841 Token ::@expr8001 Match (@expr1073749843 cond@var2898 .@expr8020 astOperand1 (@expr8021 ) , "%var%" ) &&@expr1073749846
1254: cond@var2898 .@expr8023 astOperand2 (@expr8024 ) .@expr1073749849 str (@expr1073749850 ) ==@expr1073749851 "(" &&@expr1073749852 cond@var2898 .@expr8023 astOperand2 (@expr8024 ) .@expr8031 astOperand1 (@expr8032 ) .@expr1073749857 str (@expr1073749858 ) ==@expr1073749859 "." &&@expr1073749860
1255: Token ::@expr8001 Match (@expr1073749862 cond@var2898 .@expr8023 astOperand2 (@expr8024 ) .@expr8031 astOperand1 (@expr8032 ) .@expr1073749867 astOperand1 (@expr1073749868 ) , "%var%" ) &&@expr1073749869
1256: Token ::@expr8001 Match (@expr1073749871 cond@var2898 .@expr8023 astOperand2 (@expr8024 ) .@expr8031 astOperand1 (@expr8032 ) .@expr1073749876 astOperand2 (@expr1073749877 ) , "%name%" ) ) {
1257: vartok@var2899 =@expr1073749878 cond@var2898 .@expr8020 astOperand1 (@expr8021 ) ;
1258: containerToken@var2900 =@expr1073749881 cond@var2898 .@expr1073749882 next (@expr1073749883 ) ;
1259: } else {
1260: continue ;
1261: }
1262:
1263: if (@expr1073749884 containerToken@var2900 .@expr1073749885 hasKnownValue (@expr1073749886 ValueFlow ::@expr1073749887 Value ::@expr1073749888 ValueType ::@expr1073749889 CONTAINER_SIZE ) ) {
1264: continue ; }
1265:
1266:
1267: const Library ::@expr8066 Container * container@var2901 ; container@var2901 =@expr1073749891 containerToken@var2900 .@expr8068 valueType (@expr8069 ) ?@expr1073749894 containerToken@var2900 .@expr8068 valueType (@expr8069 ) .@expr1073749897 container@var3313 :@expr1073749898 nullptr ;
1268: if (@expr1073749899 !@expr1073749900 container@var2901 ) {
1269: continue ; }
1270: if (@expr1073749901 container@var2901 .@expr8078 getYield (@expr1073749903 containerToken@var2900 .@expr1073749904 strAt (@expr1073749905 2 ) ) !=@expr1073749906 Library ::@expr8066 Container ::@expr8084 Yield ::@expr8085 SIZE ) {
1271: continue ; }
1272:
1273:
1274: const int numId@var2902 =@expr1073749910 vartok@var2899 .@expr1073749911 varId (@expr1073749912 ) ;
1275:
1276:
1277: const int declarationId@var2903 =@expr1073749913 containerToken@var2900 .@expr1073749914 varId (@expr1073749915 ) ;
1278: const std ::@expr8092 string &@expr7925 containerName@var2904 =@expr1073749918 containerToken@var2900 .@expr1073749919 str (@expr1073749920 ) ;
1279:
1280: for (@expr1073749921 const Token *@expr7994 tok3@var2905 =@expr1073749923 scope@var2890 .@expr1073749924 bodyStart@var2906 ; tok3@var2905 &&@expr1073749925 tok3@var2905 !=@expr1073749926 scope@var2890 .@expr1073749927 bodyEnd@var2907 ; tok3@var2905 =@expr1073749928 tok3@var2905 .@expr8105 next (@expr8106 ) ) {
1281: if (@expr1073749931 tok3@var2905 .@expr1073749932 varId (@expr1073749933 ) ==@expr1073749934 declarationId@var2903 ) {
1282: tok3@var2905 =@expr1073749935 tok3@var2905 .@expr8105 next (@expr8106 ) ;
1283: if (@expr1073749938 Token ::@expr8001 Match (@expr1073749940 tok3@var2905 , ". %name% ( )" ) ) {
1284: if (@expr1073749941 container@var2901 .@expr8078 getYield (@expr8119 tok3@var2905 .@expr8120 strAt (@expr8121 1 ) ) ==@expr1073749946 Library ::@expr8066 Container ::@expr8084 Yield ::@expr8085 SIZE ) {
1285: break ; }
1286: } else { if (@expr1073749950 container@var2901 .@expr1073749951 arrayLike_indexOp@var2908 &&@expr1073749952 Token ::@expr8001 Match (@expr1073749954 tok3@var2905 , "[ %varid% ]" , numId@var2902 ) ) {
1287: stlOutOfBoundsError (@expr1073749955 tok3@var2905 , tok3@var2905 .@expr8120 strAt (@expr8121 1 ) , containerName@var2904 , false ) ; }
1288: else { if (@expr1073749958 Token ::@expr8001 Match (@expr1073749960 tok3@var2905 , ". %name% ( %varid% )" , numId@var2902 ) ) {
1289: const Library ::@expr8092 Container ::@expr8092 Yield yield@var2909 =@expr1073749963 container@var2901 .@expr8078 getYield (@expr8119 tok3@var2905 .@expr8120 strAt (@expr8121 1 ) ) ;
1290: if (@expr1073749968 yield@var2909 ==@expr1073749969 Library ::@expr8066 Container ::@expr8084 Yield ::@expr1073749972 AT_INDEX ) {
1291: stlOutOfBoundsError (@expr1073749973 tok3@var2905 , tok3@var2905 .@expr8120 strAt (@expr1073749975 3 ) , containerName@var2904 , true ) ; }
1292: } } }
1293: }
1294: }
1295: }
1296: }
1297: }
1298:
1299: void CheckStl :: stlOutOfBoundsError ( const Token * tok@var2910 , const std :: string & num@var2911 , const std :: string & var@var2912 , bool at@var2913 )
1300: {
1301: if (@expr1073749976 at@var2913 ) {
1302: reportError (@expr1073749977 tok@var2910 , Severity ::@expr8154 error , "stlOutOfBounds" , "$symbol:" +@expr8155 var@var2912 +@expr8156 "\nWhen " +@expr8157 num@var2911 +@expr1073749982 "==$symbol.size(), $symbol.at(" +@expr1073749983 num@var2911 +@expr1073749984 ") is out of bounds." , CWE788@var2568 , Certainty ::@expr8161 normal ) ; }
1303: else {
1304: reportError (@expr1073749986 tok@var2910 , Severity ::@expr8154 error , "stlOutOfBounds" , "$symbol:" +@expr8155 var@var2912 +@expr8156 "\nWhen " +@expr8157 num@var2911 +@expr1073749991 "==$symbol.size(), $symbol[" +@expr1073749992 num@var2911 +@expr1073749993 "] is out of bounds." , CWE788@var2568 , Certainty ::@expr8161 normal ) ; }
1305: }
1306:
1307: void CheckStl :: negativeIndex ( )
1308: {
1309:
1310: const SymbolDatabase * const symbolDatabase@var2914 ; symbolDatabase@var2914 =@expr1073749995 mTokenizer@var28 .@expr1073749996 getSymbolDatabase (@expr1073749997 ) ;
1311: for (@expr1073749998 const Scope *@expr8175 scope@var2915 :@expr1073750000 symbolDatabase@var2914 .@expr1073750001 functionScopes@var2916 ) {
1312: for (@expr1073750002 const Token *@expr8175 tok@var2917 =@expr1073750004 scope@var2915 .@expr1073750005 bodyStart@var2918 .@expr1073750006 next (@expr1073750007 ) ; tok@var2917 !=@expr1073750008 scope@var2915 .@expr1073750009 bodyEnd@var2919 ; tok@var2917 =@expr1073750010 tok@var2917 .@expr8187 next (@expr8188 ) ) {
1313: if (@expr1073750013 !@expr1073750014 Token ::@expr1073750015 Match (@expr1073750016 tok@var2917 , "%var% [" ) ||@expr1073750017 $(@expr1073750018 $(@expr1073750019 !@expr1073750020 tok@var2917 .@expr8187 next (@expr8188 ) .@expr8199 astOperand2 (@expr8200 ) $) $&&@expr1073750025 $wrongData $(@expr1073750026 tok@var2917 $, "!tok->next()->astOperand2()" $) $) ) {
1314: continue ; }
1315: const Variable * const var@var2920 ; var@var2920 =@expr1073750027 tok@var2917 .@expr1073750028 variable (@expr1073750029 ) ;
1316: if (@expr1073750030 !@expr1073750031 var@var2920 ||@expr1073750032 tok@var2917 ==@expr1073750033 var@var2920 .@expr1073750034 nameToken (@expr1073750035 ) ) {
1317: continue ; }
1318: const Library ::@expr1073750036 Container * const container@var2921 ; container@var2921 =@expr1073750037 mSettings@var29 .@expr1073750038 library@var3300 .@expr1073750039 detectContainer (@expr1073750040 var@var2920 .@expr1073750041 typeStartToken (@expr1073750042 ) ) ;
1319: if (@expr1073750043 !@expr1073750044 container@var2921 ||@expr1073750045 !@expr1073750046 container@var2921 .@expr1073750047 arrayLike_indexOp@var2922 ) {
1320: continue ; }
1321: const ValueFlow ::@expr1073750048 Value * index@var2923 ; index@var2923 =@expr1073750049 tok@var2917 .@expr8187 next (@expr8188 ) .@expr8199 astOperand2 (@expr8200 ) .@expr1073750054 getValueLE (@expr1073750055 -1 , mSettings@var29 ) ;
1322: if (@expr1073750056 !@expr1073750057 index@var2923 ) {
1323: continue ; }
1324: negativeIndexError (@expr1073750058 tok@var2917 , *@expr1073750059 index@var2923 ) ;
1325: }
1326: }
1327: }
1328:
1329: void CheckStl :: negativeIndexError ( const Token * tok@var2924 , const ValueFlow :: Value & index@var2925 )
1330: {
1331: const std ::@expr1073750060 list < std ::@expr8237 pair < const Token *@expr1073750062 , std ::@expr8237 string > > errorPath@var2926 =@expr1073750064 getErrorPath (@expr1073750065 tok@var2924 , &@expr1073750066 index@var2925 , "Negative array index" ) ;
1332: std ::@expr1073750067 ostringstream errmsg@var2927 ;
1333: if (@expr1073750068 index@var2925 .@expr8245 condition@var2928 ) {
1334: errmsg@var2927 <<@expr1073750070 ValueFlow ::@expr1073750071 eitherTheConditionIsRedundant (@expr1073750072 index@var2925 .@expr8245 condition@var2928 )
1335: <<@expr1073750074 ", otherwise there is negative array index " <<@expr1073750075 index@var2925 .@expr8252 intvalue@var2929 <<@expr1073750077 "." ; }
1336: else {
1337: errmsg@var2927 <<@expr1073750078 "Array index " <<@expr1073750079 index@var2925 .@expr8252 intvalue@var2929 <<@expr1073750081 " is out of bounds." ; }
1338: reportError (@expr1073750082 errorPath@var2926 , index@var2925 .@expr1073750083 errorSeverity (@expr1073750084 ) ?@expr1073750085 Severity ::@expr1073750086 error :@expr1073750087 Severity ::@expr1073750088 warning , "negativeContainerIndex" , errmsg@var2927 .@expr1073750089 str (@expr1073750090 ) , CWE786@var2567 , index@var2925 .@expr1073750091 isInconclusive (@expr1073750092 ) ?@expr1073750093 Certainty ::@expr1073750094 inconclusive :@expr1073750095 Certainty ::@expr1073750096 normal ) ;
1339: }
1340:
1341: void CheckStl :: erase ( )
1342: {
1343: const SymbolDatabase * const symbolDatabase@var2930 ; symbolDatabase@var2930 =@expr1073750097 mTokenizer@var28 .@expr1073750098 getSymbolDatabase (@expr1073750099 ) ;
1344:
1345: for (@expr1073750100 const Scope &@expr1073750101 scope@var2931 :@expr1073750102 symbolDatabase@var2930 .@expr1073750103 scopeList@var2932 ) {
1346: if (@expr1073750104 scope@var2931 .@expr8281 type@var2933 ==@expr1073750106 Scope ::@expr1073750107 eFor &&@expr1073750108 Token ::@expr1073750109 simpleMatch (@expr1073750110 scope@var2931 .@expr8287 classDef@var2934 , "for (" ) ) {
1347: const Token * tok@var2935 ; tok@var2935 =@expr1073750112 scope@var2931 .@expr8287 classDef@var2934 .@expr1073750114 linkAt (@expr1073750115 1 ) ;
1348: if (@expr1073750116 !@expr1073750117 Token ::@expr8294 Match (@expr1073750119 tok@var2935 .@expr1073750120 tokAt (@expr1073750121 -3 ) , "; ++| %var% ++| ) {" ) ) {
1349: continue ; }
1350: tok@var2935 =@expr1073750122 tok@var2935 .@expr8299 previous (@expr8300 ) ;
1351: if (@expr1073750125 !@expr1073750126 tok@var2935 .@expr1073750127 isName (@expr1073750128 ) ) {
1352: tok@var2935 =@expr1073750129 tok@var2935 .@expr8299 previous (@expr8300 ) ; }
1353: eraseCheckLoopVar (@expr1073750132 scope@var2931 , tok@var2935 .@expr1073750133 variable (@expr1073750134 ) ) ;
1354: } else { if (@expr1073750135 scope@var2931 .@expr8281 type@var2933 ==@expr1073750137 Scope ::@expr1073750138 eWhile &&@expr1073750139 Token ::@expr8294 Match (@expr1073750141 scope@var2931 .@expr8287 classDef@var2934 , "while ( %var% !=" ) ) {
1355: eraseCheckLoopVar (@expr1073750143 scope@var2931 , scope@var2931 .@expr8287 classDef@var2934 .@expr1073750145 tokAt (@expr1073750146 2 ) .@expr1073750147 variable (@expr1073750148 ) ) ;
1356: } }
1357: }
1358: }
1359:
1360: void CheckStl :: eraseCheckLoopVar ( const Scope & scope@var2936 , const Variable * var@var2937 )
1361: {
1362: bool inconclusiveType@var2938 ; inconclusiveType@var2938 =@expr1073750149 false ;
1363: if (@expr1073750150 !@expr1073750151 isIterator (@expr1073750152 var@var2937 , inconclusiveType@var2938 ) ) {
1364: return ; }
1365: for (@expr1073750153 const Token *@expr1073750154 tok@var2939 =@expr1073750155 scope@var2936 .@expr1073750156 bodyStart@var2940 ; tok@var2939 !=@expr1073750157 scope@var2936 .@expr8334 bodyEnd@var2941 ; tok@var2939 =@expr1073750159 tok@var2939 .@expr1073750160 next (@expr1073750161 ) ) {
1366: if (@expr1073750162 tok@var2939 .@expr1073750163 str (@expr1073750164 ) !=@expr1073750165 "(" ) {
1367: continue ; }
1368: if (@expr1073750166 !@expr1073750167 Token ::@expr8344 Match (@expr1073750169 tok@var2939 .@expr8346 tokAt (@expr1073750171 -2 ) , ". erase ( ++| %varid% )" , var@var2937 .@expr8348 declarationId (@expr8349 ) ) ) {
1369: continue ; }
1370:
1371: if (@expr1073750174 isVector (@expr1073750175 tok@var2939 .@expr8346 tokAt (@expr1073750177 -3 ) ) ) {
1372: continue ; }
1373: if (@expr1073750178 Token ::@expr8344 Match (@expr1073750180 tok@var2939 .@expr1073750181 astParent (@expr1073750182 ) , "=|return" ) ) {
1374: continue ; }
1375:
1376: int indentlevel@var2942 ; indentlevel@var2942 =@expr1073750183 0U ;
1377: const Token * tok2@var2943 ; tok2@var2943 =@expr1073750184 tok@var2939 .@expr1073750185 link (@expr1073750186 ) ;
1378: for (@expr1073750187 ; tok2@var2943 !=@expr1073750188 scope@var2936 .@expr8334 bodyEnd@var2941 ; tok2@var2943 =@expr1073750190 tok2@var2943 .@expr8367 next (@expr8368 ) ) {
1379: if (@expr1073750193 tok2@var2943 .@expr8370 str (@expr8371 ) ==@expr1073750196 "{" ) {
1380: ++@expr1073750197 indentlevel@var2942 ;
1381: continue ;
1382: }
1383: if (@expr1073750198 tok2@var2943 .@expr8370 str (@expr8371 ) ==@expr1073750201 "}" ) {
1384: if (@expr1073750202 indentlevel@var2942 >@expr1073750203 0U ) {
1385: --@expr1073750204 indentlevel@var2942 ; }
1386: else { if (@expr1073750205 Token ::@expr8382 simpleMatch (@expr1073750207 tok2@var2943 , "} else {" ) ) {
1387: tok2@var2943 =@expr1073750208 tok2@var2943 .@expr1073750209 linkAt (@expr1073750210 2 ) ; } }
1388: continue ;
1389: }
1390: if (@expr1073750211 tok2@var2943 .@expr1073750212 varId (@expr1073750213 ) ==@expr1073750214 var@var2937 .@expr8348 declarationId (@expr8349 ) ) {
1391: if (@expr1073750217 Token ::@expr8382 simpleMatch (@expr1073750219 tok2@var2943 .@expr8367 next (@expr8368 ) , "=" ) ) {
1392: break ; }
1393: dereferenceErasedError (@expr1073750222 tok@var2939 , tok2@var2943 , tok2@var2943 .@expr8370 str (@expr8371 ) , inconclusiveType@var2938 ) ;
1394: break ;
1395: }
1396: if (@expr1073750225 indentlevel@var2942 ==@expr1073750226 0U &&@expr1073750227 Token ::@expr8344 Match (@expr1073750229 tok2@var2943 , "break|return|goto" ) ) {
1397: break ; }
1398: }
1399: if (@expr1073750230 tok2@var2943 ==@expr1073750231 scope@var2936 .@expr8334 bodyEnd@var2941 ) {
1400: dereferenceErasedError (@expr1073750233 tok@var2939 , scope@var2936 .@expr1073750234 classDef@var2944 , var@var2937 .@expr1073750235 nameToken (@expr1073750236 ) .@expr1073750237 str (@expr1073750238 ) , inconclusiveType@var2938 ) ; }
1401: }
1402: }
1403:
1404: void CheckStl :: stlBoundaries ( )
1405: {
1406: const SymbolDatabase * const symbolDatabase@var2945 ; symbolDatabase@var2945 =@expr1073750239 mTokenizer@var28 .@expr1073750240 getSymbolDatabase (@expr1073750241 ) ;
1407: for (@expr1073750242 const Variable *@expr8419 var@var2946 :@expr1073750244 symbolDatabase@var2945 .@expr1073750245 variableList (@expr1073750246 ) ) {
1408: if (@expr1073750247 !@expr1073750248 var@var2946 ||@expr1073750249 !@expr1073750250 var@var2946 .@expr8427 scope (@expr8428 ) ||@expr1073750253 !@expr1073750254 var@var2946 .@expr8427 scope (@expr8428 ) .@expr1073750257 isExecutable (@expr1073750258 ) ) {
1409: continue ; }
1410:
1411: const Library ::@expr1073750259 Container * container@var2947 ; container@var2947 =@expr1073750260 mSettings@var29 .@expr1073750261 library@var3300 .@expr1073750262 detectContainer (@expr1073750263 var@var2946 .@expr1073750264 typeStartToken (@expr1073750265 ) , true ) ;
1412: if (@expr1073750266 !@expr1073750267 container@var2947 ||@expr1073750268 container@var2947 .@expr1073750269 opLessAllowed@var2948 ) {
1413: continue ; }
1414:
1415: const Token * const end@var2949 ; end@var2949 =@expr1073750270 var@var2946 .@expr8427 scope (@expr8428 ) .@expr1073750273 bodyEnd@var3314 ;
1416: for (@expr1073750274 const Token *@expr8419 tok@var2950 =@expr1073750276 var@var2946 .@expr1073750277 nameToken (@expr1073750278 ) ; tok@var2950 !=@expr1073750279 end@var2949 ; tok@var2950 =@expr1073750280 tok@var2950 .@expr1073750281 next (@expr1073750282 ) ) {
1417: if (@expr1073750283 Token ::@expr8460 Match (@expr1073750285 tok@var2950 , "!!* %varid% <" , var@var2946 .@expr8462 declarationId (@expr8463 ) ) ) {
1418: stlBoundariesError (@expr8464 tok@var2950 ) ;
1419: } else { if (@expr1073750289 Token ::@expr8460 Match (@expr1073750291 tok@var2950 , "> %varid% !!." , var@var2946 .@expr8462 declarationId (@expr8463 ) ) ) {
1420: stlBoundariesError (@expr8464 tok@var2950 ) ;
1421: } }
1422: }
1423: }
1424: }
1425:
1426:
1427: void CheckStl :: stlBoundariesError ( const Token * tok@var2951 )
1428: {
1429: reportError (@expr1073750295 tok@var2951 , Severity ::@expr1073750296 error , "stlBoundaries" ,
1430: "Dangerous comparison using operator< on iterator.\nIterator compared with operator<. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators."
1431:
1432: , CWE664@var2563 , Certainty ::@expr1073750297 normal ) ;
1433: }
1434:
1435: static bool if_findCompare ( const Token * const tokBack@var2952 , bool stdStringLike@var2953 )
1436: {
1437: const Token * tok@var2954 ; tok@var2954 =@expr1073750298 tokBack@var2952 .@expr1073750299 astParent (@expr1073750300 ) ;
1438: if (@expr1073750301 !@expr1073750302 tok@var2954 ) {
1439: return true ; }
1440: if (@expr1073750303 tok@var2954 .@expr1073750304 isComparisonOp (@expr1073750305 ) ) {
1441: if (@expr1073750306 stdStringLike@var2953 ) {
1442: const Token * const tokOther@var2955 ; tokOther@var2955 =@expr1073750307 tokBack@var2952 .@expr1073750308 astSibling (@expr1073750309 ) ;
1443: return !@expr1073750310 tokOther@var2955 ||@expr1073750311 !@expr1073750312 tokOther@var2955 .@expr1073750313 hasKnownIntValue (@expr1073750314 ) ||@expr1073750315 tokOther@var2955 .@expr1073750316 getKnownIntValue (@expr1073750317 ) !=@expr1073750318 0 ;
1444: }
1445: return (@expr1073750319 !@expr1073750320 tok@var2954 .@expr1073750321 astOperand1 (@expr1073750322 ) .@expr1073750323 isNumber (@expr1073750324 ) &&@expr1073750325 !@expr1073750326 tok@var2954 .@expr1073750327 astOperand2 (@expr1073750328 ) .@expr1073750329 isNumber (@expr1073750330 ) ) ;
1446: }
1447: if (@expr1073750331 tok@var2954 .@expr1073750332 isArithmeticalOp (@expr1073750333 ) ) {
1448: return true ; }
1449: if (@expr1073750334 tok@var2954 .@expr1073750335 str (@expr1073750336 ) ==@expr1073750337 "." ) {
1450: return true ; }
1451: if (@expr1073750338 tok@var2954 .@expr1073750339 isAssignmentOp (@expr1073750340 ) ) {
1452: return if_findCompare (@expr1073750341 tok@var2954 , stdStringLike@var2953 ) ; }
1453: return false ;
1454: }
1455:
1456: void CheckStl :: if_find ( )
1457: {
1458: const bool printWarning@var2956 =@expr1073750342 mSettings@var29 .@expr8519 severity@var3299 .@expr8520 isEnabled (@expr1073750345 Severity ::@expr1073750346 warning ) ;
1459: const bool printPerformance@var2957 =@expr1073750347 mSettings@var29 .@expr8519 severity@var3299 .@expr8520 isEnabled (@expr1073750350 Severity ::@expr1073750351 performance ) ;
1460: if (@expr1073750352 !@expr1073750353 printWarning@var2956 &&@expr1073750354 !@expr1073750355 printPerformance@var2957 ) {
1461: return ; }
1462:
1463: const SymbolDatabase * symbolDatabase@var2958 ; symbolDatabase@var2958 =@expr1073750356 mTokenizer@var28 .@expr1073750357 getSymbolDatabase (@expr1073750358 ) ;
1464:
1465: for (@expr1073750359 const Scope &@expr1073750360 scope@var2959 :@expr1073750361 symbolDatabase@var2958 .@expr1073750362 scopeList@var2960 ) {
1466: if (@expr1073750363 (@expr1073750364 scope@var2959 .@expr8541 type@var2961 !=@expr1073750366 Scope ::@expr1073750367 eIf &&@expr1073750368 scope@var2959 .@expr8541 type@var2961 !=@expr1073750370 Scope ::@expr1073750371 eWhile ) ||@expr1073750372 !@expr1073750373 scope@var2959 .@expr8550 classDef@var2962 ) {
1467: continue ; }
1468:
1469: const Token * conditionStart@var2963 ; conditionStart@var2963 =@expr1073750375 scope@var2959 .@expr8550 classDef@var2962 .@expr1073750377 next (@expr1073750378 ) ;
1470: if (@expr1073750379 Token ::@expr1073750380 simpleMatch (@expr1073750381 conditionStart@var2963 .@expr8558 astOperand2 (@expr8559 ) , ";" ) ) {
1471: conditionStart@var2963 =@expr1073750384 conditionStart@var2963 .@expr8558 astOperand2 (@expr8559 ) ; }
1472:
1473: for (@expr1073750387 const Token *@expr1073750388 tok@var2964 =@expr1073750389 conditionStart@var2963 ; tok@var2964 .@expr1073750390 str (@expr1073750391 ) !=@expr1073750392 "{" ; tok@var2964 =@expr1073750393 tok@var2964 .@expr1073750394 next (@expr1073750395 ) ) {
1474: const Token * funcTok@var2965 ; funcTok@var2965 =@expr1073750396 nullptr ;
1475: const Library ::@expr8573 Container * container@var2966 ; container@var2966 =@expr1073750398 nullptr ;
1476:
1477: if (@expr1073750399 Token ::@expr8576 Match (@expr1073750401 tok@var2964 , "%name% (" ) ) {
1478: tok@var2964 =@expr1073750402 tok@var2964 .@expr1073750403 linkAt (@expr1073750404 1 ) ; }
1479:
1480: else { if (@expr1073750405 tok@var2964 .@expr8582 variable (@expr8583 ) &&@expr1073750408 Token ::@expr8576 Match (@expr1073750410 tok@var2964 , "%var% . %name% (" ) ) {
1481: container@var2966 =@expr1073750411 mSettings@var29 .@expr8588 library@var3300 .@expr8589 detectContainer (@expr8590 tok@var2964 .@expr8582 variable (@expr8583 ) .@expr8593 typeStartToken (@expr8594 ) ) ;
1482: funcTok@var2965 =@expr1073750419 tok@var2964 .@expr8596 tokAt (@expr1073750421 2 ) ;
1483: }
1484:
1485:
1486: else { if (@expr1073750422 tok@var2964 .@expr8582 variable (@expr8583 ) &&@expr1073750425 tok@var2964 .@expr8602 astParent (@expr8603 ) &&@expr1073750428 (@expr1073750429 tok@var2964 .@expr8602 astParent (@expr8603 ) .@expr8608 str (@expr8609 ) ==@expr1073750434 "*" ||@expr1073750435 tok@var2964 .@expr8602 astParent (@expr8603 ) .@expr8608 str (@expr8609 ) ==@expr1073750440 "[" ) ) {
1487: const Token * tok2@var2967 ; tok2@var2967 =@expr1073750441 tok@var2964 .@expr8602 astParent (@expr8603 ) ;
1488:
1489: if (@expr1073750444 !@expr1073750445 Token ::@expr8576 Match (@expr1073750447 tok2@var2967 .@expr8624 astParent (@expr8625 ) , ". %name% (" ) ) {
1490: continue ; }
1491:
1492: funcTok@var2965 =@expr1073750450 tok2@var2967 .@expr8624 astParent (@expr8625 ) .@expr1073750453 next (@expr1073750454 ) ;
1493:
1494: if (@expr1073750455 tok@var2964 .@expr8582 variable (@expr8583 ) .@expr1073750458 isArrayOrPointer (@expr1073750459 ) ) {
1495: container@var2966 =@expr1073750460 mSettings@var29 .@expr8588 library@var3300 .@expr8589 detectContainer (@expr8590 tok@var2964 .@expr8582 variable (@expr8583 ) .@expr8593 typeStartToken (@expr8594 ) ) ; }
1496: else {
1497: container@var2966 =@expr1073750468 mSettings@var29 .@expr8588 library@var3300 .@expr8589 detectContainer (@expr8590 tok@var2964 .@expr8582 variable (@expr8583 ) .@expr8593 typeStartToken (@expr8594 ) ) ;
1498: tok2@var2967 =@expr1073750476 Token ::@expr1073750477 findsimplematch (@expr1073750478 tok@var2964 .@expr8582 variable (@expr8583 ) .@expr8593 typeStartToken (@expr8594 ) , "<" , tok@var2964 .@expr8582 variable (@expr8583 ) .@expr1073750485 typeEndToken (@expr1073750486 ) ) ;
1499: if (@expr1073750487 container@var2966 &&@expr1073750488 container@var2966 .@expr8665 type_templateArgNo@var2968 >=@expr1073750490 0 &&@expr1073750491 tok2@var2967 ) {
1500: tok2@var2967 =@expr1073750492 tok2@var2967 .@expr1073750493 next (@expr1073750494 ) ;
1501: for (@expr1073750495 int j@var2969 =@expr1073750496 0 ; j@var2969 <@expr1073750497 container@var2966 .@expr8665 type_templateArgNo@var2968 ; j@var2969 ++@expr1073750499 ) {
1502: tok2@var2967 =@expr1073750500 tok2@var2967 .@expr1073750501 nextTemplateArgument (@expr1073750502 ) ; }
1503:
1504: container@var2966 =@expr1073750503 mSettings@var29 .@expr8588 library@var3300 .@expr8589 detectContainer (@expr1073750506 tok2@var2967 ) ;
1505: } else {
1506: container@var2966 =@expr1073750507 nullptr ; }
1507: }
1508: } } }
1509:
1510: if (@expr1073750508 container@var2966 &&@expr1073750509 container@var2966 .@expr1073750510 getAction (@expr1073750511 funcTok@var2965 .@expr8688 str (@expr8689 ) ) ==@expr1073750514 Library ::@expr8573 Container ::@expr1073750516 Action ::@expr1073750517 FIND ) {
1511: if (@expr1073750518 if_findCompare (@expr1073750519 funcTok@var2965 .@expr1073750520 next (@expr1073750521 ) , container@var2966 .@expr8698 stdStringLike@var2970 ) ) {
1512: continue ; }
1513:
1514: if (@expr1073750523 printWarning@var2956 &&@expr1073750524 container@var2966 .@expr1073750525 getYield (@expr1073750526 funcTok@var2965 .@expr8688 str (@expr8689 ) ) ==@expr1073750529 Library ::@expr8573 Container ::@expr1073750531 Yield ::@expr1073750532 ITERATOR ) {
1515: if_findError (@expr8709 tok@var2964 , false ) ; }
1516: else { if (@expr1073750534 printPerformance@var2957 &&@expr1073750535 container@var2966 .@expr8698 stdStringLike@var2970 &&@expr1073750537 funcTok@var2965 .@expr8688 str (@expr8689 ) ==@expr1073750540 "find" ) {
1517: if_findError (@expr1073750541 tok@var2964 , true ) ; } }
1518: } else { if (@expr1073750542 printWarning@var2956 &&@expr1073750543 Token ::@expr8576 Match (@expr1073750545 tok@var2964 , "std :: find|find_if (" ) ) {
1519:
1520: if (@expr1073750546 !@expr1073750547 if_findCompare (@expr1073750548 tok@var2964 .@expr8596 tokAt (@expr1073750550 3 ) , false ) ) {
1521: if_findError (@expr8709 tok@var2964 , false ) ;
1522: }
1523: } }
1524: }
1525: }
1526: }
1527:
1528:
1529: void CheckStl :: if_findError ( const Token * tok@var2971 , bool str@var2972 )
1530: {
1531: if (@expr1073750552 str@var2972 &&@expr1073750553 mSettings@var29 .@expr1073750554 standards@var3301 .@expr1073750555 cpp@var3302 >=@expr1073750556 Standards ::@expr1073750557 CPP20 ) {
1532: reportError (@expr1073750558 tok@var2971 , Severity ::@expr1073750559 performance , "stlIfStrFind" ,
1533: "Inefficient usage of string::find() in condition; string::starts_with() could be faster.\nEither inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos."
1534:
1535:
1536:
1537: , CWE597@var2561 , Certainty ::@expr8736 normal ) ; }
1538: if (@expr1073750561 !@expr1073750562 str@var2972 ) {
1539: reportError (@expr1073750563 tok@var2971 , Severity ::@expr1073750564 warning , "stlIfFind" , "Suspicious condition. The result of find() is an iterator, but it is not properly checked." , CWE398@var2560 , Certainty ::@expr8736 normal ) ; }
1540: }
1541:
1542: static std :: pair < const Token * , const Token * > isMapFind ( const Token * tok@var2973 )
1543: {
1544: if (@expr1073750566 !@expr1073750567 Token ::@expr8744 simpleMatch (@expr1073750569 tok@var2973 , "(" ) ) {
1545: return { } ; }
1546: if (@expr1073750570 !@expr1073750571 Token ::@expr8744 simpleMatch (@expr1073750573 tok@var2973 .@expr8750 astOperand1 (@expr8751 ) , "." ) ) {
1547: return { } ; }
1548: if (@expr1073750576 !@expr1073750577 astIsContainer (@expr1073750578 tok@var2973 .@expr8750 astOperand1 (@expr8751 ) .@expr8757 astOperand1 (@expr8758 ) ) ) {
1549: return { } ; }
1550: const Token * contTok@var2974 ; contTok@var2974 =@expr1073750583 tok@var2973 .@expr8750 astOperand1 (@expr8751 ) .@expr8757 astOperand1 (@expr8758 ) ;
1551: const Library ::@expr1073750588 Container * container@var2975 ; container@var2975 =@expr1073750589 contTok@var2974 .@expr1073750590 valueType (@expr1073750591 ) .@expr1073750592 container@var3313 ;
1552: if (@expr1073750593 !@expr1073750594 container@var2975 ) {
1553: return { } ; }
1554: if (@expr1073750595 !@expr1073750596 container@var2975 .@expr1073750597 stdAssociativeLike@var2976 ) {
1555: return { } ; }
1556: if (@expr1073750598 !@expr1073750599 Token ::@expr1073750600 Match (@expr1073750601 tok@var2973 .@expr8750 astOperand1 (@expr8751 ) , ". find|count (" ) ) {
1557: return { } ; }
1558: if (@expr1073750604 !@expr1073750605 tok@var2973 .@expr8782 astOperand2 (@expr8783 ) ) {
1559: return { } ; }
1560: return {@expr1073750608 contTok@var2974 , tok@var2973 .@expr8782 astOperand2 (@expr8783 ) } ;
1561: }
1562:
1563: static const Token * skipLocalVars ( const Token * tok@var2977 )
1564: {
1565: if (@expr1073750611 !@expr1073750612 tok@var2977 ) {
1566: return tok@var2977 ; }
1567: if (@expr1073750613 Token ::@expr1073750614 simpleMatch (@expr1073750615 tok@var2977 , "{" ) ) {
1568: return skipLocalVars (@expr1073750616 tok@var2977 .@expr1073750617 next (@expr1073750618 ) ) ; }
1569: const Scope * scope@var2978 ; scope@var2978 =@expr1073750619 tok@var2977 .@expr1073750620 scope (@expr1073750621 ) ;
1570:
1571: const Token * top@var2979 ; top@var2979 =@expr1073750622 tok@var2977 .@expr1073750623 astTop (@expr1073750624 ) ;
1572: if (@expr1073750625 !@expr1073750626 top@var2979 ) {
1573: const Token * semi@var2980 ; semi@var2980 =@expr1073750627 Token ::@expr1073750628 findsimplematch (@expr1073750629 tok@var2977 , ";" ) ;
1574: if (@expr1073750630 !@expr1073750631 semi@var2980 ) {
1575: return tok@var2977 ; }
1576: if (@expr1073750632 !@expr1073750633 Token ::@expr8810 Match (@expr1073750635 semi@var2980 .@expr8812 previous (@expr8813 ) , "%var% ;" ) ) {
1577: return tok@var2977 ; }
1578: const Token * varTok@var2981 ; varTok@var2981 =@expr1073750638 semi@var2980 .@expr8812 previous (@expr8813 ) ;
1579: const Variable * var@var2982 ; var@var2982 =@expr1073750641 varTok@var2981 .@expr1073750642 variable (@expr1073750643 ) ;
1580: if (@expr1073750644 !@expr1073750645 var@var2982 ) {
1581: return tok@var2977 ; }
1582: if (@expr1073750646 var@var2982 .@expr1073750647 nameToken (@expr1073750648 ) !=@expr1073750649 varTok@var2981 ) {
1583: return tok@var2977 ; }
1584: return skipLocalVars (@expr1073750650 semi@var2980 .@expr1073750651 next (@expr1073750652 ) ) ;
1585: }
1586: if (@expr1073750653 Token ::@expr8810 Match (@expr1073750655 top@var2979 , "%assign%" ) ) {
1587: const Token * varTok@var2983 ; varTok@var2983 =@expr1073750656 top@var2979 .@expr1073750657 astOperand1 (@expr1073750658 ) ;
1588: if (@expr1073750659 !@expr1073750660 Token ::@expr8810 Match (@expr1073750662 varTok@var2983 , "%var%" ) ) {
1589: return tok@var2977 ; }
1590: const Variable * var@var2984 ; var@var2984 =@expr1073750663 varTok@var2983 .@expr1073750664 variable (@expr1073750665 ) ;
1591: if (@expr1073750666 !@expr1073750667 var@var2984 ) {
1592: return tok@var2977 ; }
1593: if (@expr1073750668 var@var2984 .@expr1073750669 scope (@expr1073750670 ) !=@expr1073750671 scope@var2978 ) {
1594: return tok@var2977 ; }
1595: const Token * endTok@var2985 ; endTok@var2985 =@expr1073750672 nextAfterAstRightmostLeaf (@expr1073750673 top@var2979 ) ;
1596: if (@expr1073750674 !@expr1073750675 endTok@var2985 ) {
1597: return tok@var2977 ; }
1598: return skipLocalVars (@expr1073750676 endTok@var2985 .@expr1073750677 next (@expr1073750678 ) ) ;
1599: }
1600: return tok@var2977 ;
1601: }
1602:
1603: static const Token * findInsertValue ( const Token * tok@var2986 , const Token * containerTok@var2987 , const Token * keyTok@var2988 , const Library & library@var2989 )
1604: {
1605: const Token * startTok@var2990 ; startTok@var2990 =@expr1073750679 skipLocalVars (@expr1073750680 tok@var2986 ) ;
1606: const Token * top@var2991 ; top@var2991 =@expr1073750681 startTok@var2990 .@expr1073750682 astTop (@expr1073750683 ) ;
1607:
1608: const Token * icontainerTok@var2992 ; icontainerTok@var2992 =@expr1073750684 nullptr ;
1609: const Token * ikeyTok@var2993 ; ikeyTok@var2993 =@expr1073750685 nullptr ;
1610: const Token * ivalueTok@var2994 ; ivalueTok@var2994 =@expr1073750686 nullptr ;
1611: if (@expr1073750687 Token ::@expr8864 simpleMatch (@expr1073750689 top@var2991 , "=" ) &&@expr1073750690 Token ::@expr8864 simpleMatch (@expr1073750692 top@var2991 .@expr8869 astOperand1 (@expr8870 ) , "[" ) ) {
1612: icontainerTok@var2992 =@expr1073750695 top@var2991 .@expr8869 astOperand1 (@expr8870 ) .@expr8874 astOperand1 (@expr8875 ) ;
1613: ikeyTok@var2993 =@expr1073750700 top@var2991 .@expr8869 astOperand1 (@expr8870 ) .@expr1073750703 astOperand2 (@expr1073750704 ) ;
1614: ivalueTok@var2994 =@expr1073750705 top@var2991 .@expr1073750706 astOperand2 (@expr1073750707 ) ;
1615: }
1616: if (@expr1073750708 Token ::@expr8864 simpleMatch (@expr1073750710 top@var2991 , "(" ) &&@expr1073750711 Token ::@expr1073750712 Match (@expr1073750713 top@var2991 .@expr8869 astOperand1 (@expr8870 ) , ". insert|emplace (" ) &&@expr1073750716 !@expr1073750717 astIsIterator (@expr1073750718 top@var2991 .@expr8869 astOperand1 (@expr8870 ) .@expr8897 tokAt (@expr8898 2 ) ) ) {
1617: icontainerTok@var2992 =@expr1073750723 top@var2991 .@expr8869 astOperand1 (@expr8870 ) .@expr8874 astOperand1 (@expr8875 ) ;
1618: const Token * itok@var2995 ; itok@var2995 =@expr1073750728 top@var2991 .@expr8869 astOperand1 (@expr8870 ) .@expr8897 tokAt (@expr8898 2 ) .@expr1073750733 astOperand2 (@expr1073750734 ) ;
1619: if (@expr1073750735 Token ::@expr8864 simpleMatch (@expr1073750737 itok@var2995 , "," ) ) {
1620: ikeyTok@var2993 =@expr1073750738 itok@var2995 .@expr1073750739 astOperand1 (@expr1073750740 ) ;
1621: ivalueTok@var2994 =@expr1073750741 itok@var2995 .@expr1073750742 astOperand2 (@expr1073750743 ) ;
1622: } else {
1623: ikeyTok@var2993 =@expr1073750744 itok@var2995 ;
1624: }
1625: }
1626: if (@expr1073750745 !@expr1073750746 ikeyTok@var2993 ||@expr1073750747 !@expr1073750748 icontainerTok@var2992 ) {
1627: return nullptr ; }
1628: if (@expr1073750749 isSameExpression (@expr1073750750 true , true , containerTok@var2987 , icontainerTok@var2992 , library@var2989 , true , false ) &&@expr1073750751
1629: isSameExpression (@expr1073750752 true , true , keyTok@var2988 , ikeyTok@var2993 , library@var2989 , true , true ) ) {
1630: if (@expr1073750753 ivalueTok@var2994 ) {
1631: return ivalueTok@var2994 ; }
1632: else {
1633: return ikeyTok@var2993 ; }
1634: }
1635: return nullptr ;
1636: }
1637:
1638: void CheckStl :: checkFindInsert ( )
1639: {
1640: if (@expr1073750754 !@expr1073750755 mSettings@var29 .@expr1073750756 severity@var3299 .@expr1073750757 isEnabled (@expr1073750758 Severity ::@expr1073750759 performance ) ) {
1641: return ; }
1642:
1643: const SymbolDatabase * const symbolDatabase@var2996 ; symbolDatabase@var2996 =@expr1073750760 mTokenizer@var28 .@expr1073750761 getSymbolDatabase (@expr1073750762 ) ;
1644: for (@expr1073750763 const Scope *@expr8940 scope@var2997 :@expr1073750765 symbolDatabase@var2996 .@expr1073750766 functionScopes@var2998 ) {
1645: for (@expr1073750767 const Token *@expr8940 tok@var2999 =@expr1073750769 scope@var2997 .@expr1073750770 bodyStart@var3000 .@expr1073750771 next (@expr1073750772 ) ; tok@var2999 !=@expr1073750773 scope@var2997 .@expr1073750774 bodyEnd@var3001 ; tok@var2999 =@expr1073750775 tok@var2999 .@expr8952 next (@expr8953 ) ) {
1646: if (@expr1073750778 !@expr1073750779 Token ::@expr8956 simpleMatch (@expr1073750781 tok@var2999 , "if (" ) ) {
1647: continue ; }
1648: if (@expr1073750782 !@expr1073750783 Token ::@expr8956 simpleMatch (@expr1073750785 tok@var2999 .@expr8952 next (@expr8953 ) .@expr8964 link (@expr8965 ) , ") {" ) ) {
1649: continue ; }
1650: if (@expr1073750790 !@expr1073750791 Token ::@expr1073750792 Match (@expr1073750793 tok@var2999 .@expr8952 next (@expr8953 ) .@expr8972 astOperand2 (@expr8973 ) , "%comp%" ) ) {
1651: continue ; }
1652: const Token * condTok@var3002 ; condTok@var3002 =@expr1073750798 tok@var2999 .@expr8952 next (@expr8953 ) .@expr8972 astOperand2 (@expr8973 ) ;
1653: const Token * containerTok@var3003 ;
1654: const Token * keyTok@var3004 ;
1655: std ::@expr1073750803 tie (@expr1073750804 containerTok@var3003 , keyTok@var3004 ) =@expr1073750805 isMapFind (@expr1073750806 condTok@var3002 .@expr1073750807 astOperand1 (@expr1073750808 ) ) ;
1656: if (@expr1073750809 !@expr1073750810 containerTok@var3003 ) {
1657: continue ; }
1658:
1659: if (@expr1073750811 mSettings@var29 .@expr1073750812 standards@var3301 .@expr1073750813 cpp@var3302 <@expr1073750814 Standards ::@expr1073750815 CPP17 &&@expr1073750816 !@expr1073750817 (@expr1073750818 keyTok@var3004 &&@expr1073750819 keyTok@var3004 .@expr8996 valueType (@expr8997 ) &&@expr1073750822 (@expr1073750823 keyTok@var3004 .@expr8996 valueType (@expr8997 ) .@expr1073750826 isIntegral (@expr1073750827 ) ||@expr1073750828 keyTok@var3004 .@expr8996 valueType (@expr8997 ) .@expr1073750831 pointer@var3315 >@expr1073750832 0 ) ) ) {
1660: continue ; }
1661:
1662: const Token * thenTok@var3005 ; thenTok@var3005 =@expr1073750833 tok@var2999 .@expr8952 next (@expr8953 ) .@expr8964 link (@expr8965 ) .@expr1073750838 next (@expr1073750839 ) ;
1663: const Token * valueTok@var3006 ; valueTok@var3006 =@expr1073750840 findInsertValue (@expr1073750841 thenTok@var3005 , containerTok@var3003 , keyTok@var3004 , mSettings@var29 .@expr9018 library@var3300 ) ;
1664: if (@expr1073750843 !@expr1073750844 valueTok@var3006 ) {
1665: continue ; }
1666:
1667: if (@expr1073750845 Token ::@expr8956 simpleMatch (@expr1073750847 thenTok@var3005 .@expr9024 link (@expr9025 ) , "} else {" ) ) {
1668: const Token * valueTok2@var3007 ; valueTok2@var3007 =@expr1073750850
1669: findInsertValue (@expr1073750851 thenTok@var3005 .@expr9024 link (@expr9025 ) .@expr1073750854 tokAt (@expr1073750855 2 ) , containerTok@var3003 , keyTok@var3004 , mSettings@var29 .@expr9018 library@var3300 ) ;
1670: if (@expr1073750857 !@expr1073750858 valueTok2@var3007 ) {
1671: continue ; }
1672: if (@expr1073750859 isSameExpression (@expr1073750860 true , true , valueTok@var3006 , valueTok2@var3007 , mSettings@var29 .@expr9018 library@var3300 , true , true ) ) {
1673: checkFindInsertError (@expr9038 valueTok@var3006 ) ;
1674: }
1675: } else {
1676: checkFindInsertError (@expr9038 valueTok@var3006 ) ;
1677: }
1678: }
1679: }
1680: }
1681:
1682: void CheckStl :: checkFindInsertError ( const Token * tok@var3008 )
1683: {
1684: std ::@expr1073750864 string replaceExpr@var3009 ;
1685: if (@expr1073750865 tok@var3008 &&@expr1073750866 Token ::@expr9043 simpleMatch (@expr1073750868 tok@var3008 .@expr9045 astParent (@expr9046 ) , "=" ) &&@expr1073750871 tok@var3008 ==@expr1073750872 tok@var3008 .@expr9045 astParent (@expr9046 ) .@expr1073750875 astOperand2 (@expr1073750876 ) &&@expr1073750877 Token ::@expr9043 simpleMatch (@expr1073750879 tok@var3008 .@expr9045 astParent (@expr9046 ) .@expr9058 astOperand1 (@expr9059 ) , "[" ) ) {
1686: if (@expr1073750884 mSettings@var29 .@expr9061 standards@var3301 .@expr9062 cpp@var3302 <@expr1073750887 Standards ::@expr1073750888 CPP11 ) {
1687:
1688: return ; }
1689: const std ::@expr1073750889 string f@var3010 =@expr1073750890 (@expr1073750891 mSettings@var29 .@expr9061 standards@var3301 .@expr9062 cpp@var3302 <@expr1073750894 Standards ::@expr1073750895 CPP17 ) ?@expr1073750896 "emplace" :@expr1073750897 "try_emplace" ;
1690: replaceExpr@var3009 =@expr1073750898 " Instead of '" +@expr1073750899 tok@var3008 .@expr9045 astParent (@expr9046 ) .@expr1073750902 expressionString (@expr1073750903 ) +@expr1073750904 "' consider using '" +@expr1073750905
1691: tok@var3008 .@expr9045 astParent (@expr9046 ) .@expr9058 astOperand1 (@expr9059 ) .@expr1073750910 astOperand1 (@expr1073750911 ) .@expr1073750912 expressionString (@expr1073750913 ) +@expr1073750914
1692: "." +@expr1073750915 f@var3010 +@expr1073750916 "(" +@expr1073750917
1693: tok@var3008 .@expr9045 astParent (@expr9046 ) .@expr9058 astOperand1 (@expr9059 ) .@expr1073750922 astOperand2 (@expr1073750923 ) .@expr1073750924 expressionString (@expr1073750925 ) +@expr1073750926
1694: ", " +@expr1073750927
1695: tok@var3008 .@expr1073750928 expressionString (@expr1073750929 ) +@expr1073750930
1696: ");'." ;
1697: }
1698:
1699: reportError (@expr1073750931
1700: tok@var3008 , Severity ::@expr1073750932 performance , "stlFindInsert" , "Searching before insertion is not necessary." +@expr1073750933 replaceExpr@var3009 , CWE398@var2560 , Certainty ::@expr1073750934 normal ) ;
1701: }
1702:
|
1705:
1706: static bool isCpp03ContainerSizeSlow ( const Token * tok@var3011 )
1707: {
1708: if (@expr1073750935 !@expr1073750936 tok@var3011 ) {
1709: return false ; }
1710: const Variable * var@var3012 ; var@var3012 =@expr1073750937 tok@var3011 .@expr1073750938 variable (@expr1073750939 ) ;
1711: return var@var3012 &&@expr1073750940 var@var3012 .@expr1073750941 isStlType (@expr1073750942 "list" ) ;
1712: }
1713:
1714: void CheckStl :: size ( )
1715: {
1716: if (@expr1073750943 !@expr1073750944 mSettings@var29 .@expr1073750945 severity@var3299 .@expr1073750946 isEnabled (@expr1073750947 Severity ::@expr1073750948 performance ) ) {
1717: return ; }
1718:
1719: if (@expr1073750949 mSettings@var29 .@expr1073750950 standards@var3301 .@expr1073750951 cpp@var3302 >=@expr1073750952 Standards ::@expr1073750953 CPP11 ) {
1720: return ; }
1721:
1722: const SymbolDatabase * const symbolDatabase@var3013 ; symbolDatabase@var3013 =@expr1073750954 mTokenizer@var28 .@expr1073750955 getSymbolDatabase (@expr1073750956 ) ;
1723: for (@expr1073750957 const Scope *@expr9134 scope@var3014 :@expr1073750959 symbolDatabase@var3013 .@expr1073750960 functionScopes@var3015 ) {
1724: for (@expr1073750961 const Token *@expr9134 tok@var3016 =@expr1073750963 scope@var3014 .@expr1073750964 bodyStart@var3017 .@expr1073750965 next (@expr1073750966 ) ; tok@var3016 !=@expr1073750967 scope@var3014 .@expr1073750968 bodyEnd@var3018 ; tok@var3016 =@expr1073750969 tok@var3016 .@expr1073750970 next (@expr1073750971 ) ) {
1725: if (@expr1073750972 Token ::@expr9149 Match (@expr1073750974 tok@var3016 , "%var% . size ( )" ) ||@expr1073750975
1726: Token ::@expr9149 Match (@expr1073750977 tok@var3016 , "%name% . %var% . size ( )" ) ) {
1727:
1728: const Token * varTok@var3019 ; varTok@var3019 =@expr1073750978 tok@var3016 ;
1729: if (@expr1073750979 tok@var3016 .@expr1073750980 strAt (@expr1073750981 2 ) !=@expr1073750982 "size" ) {
1730: varTok@var3019 =@expr1073750983 varTok@var3019 .@expr9160 tokAt (@expr1073750985 2 ) ; }
1731:
1732: const Token * const end@var3020 ; end@var3020 =@expr1073750986 varTok@var3019 .@expr9160 tokAt (@expr1073750988 5 ) ;
1733:
1734:
1735: if (@expr1073750989 (@expr1073750990 !@expr9167 tok@var3016 .@expr9168 previous (@expr9169 ) .@expr9170 isArithmeticalOp (@expr9171 ) &&@expr1073750996 Token ::@expr9149 Match (@expr1073750998 end@var3020 , "==|<=|!=|> 0" ) ) ||@expr1073750999
1736: (@expr1073751000 end@var3020 .@expr9177 next (@expr9178 ) &&@expr9179 !@expr9180 end@var3020 .@expr9177 next (@expr9178 ) .@expr9183 isArithmeticalOp (@expr9184 ) &&@expr1073751009 Token ::@expr9149 Match (@expr1073751011 tok@var3016 .@expr9188 tokAt (@expr9189 -2 ) , "0 ==|>=|!=|<" ) ) ) {
1737: if (@expr9190 isCpp03ContainerSizeSlow (@expr9191 varTok@var3019 ) ) {
1738: sizeError (@expr9192 varTok@var3019 ) ;
1739: continue ;
1740: }
1741: }
1742:
1743:
1744: if (@expr1073751017 (@expr1073751018 !@expr9167 tok@var3016 .@expr9168 previous (@expr9169 ) .@expr9170 isArithmeticalOp (@expr9171 ) &&@expr1073751024 Token ::@expr9149 Match (@expr1073751026 end@var3020 , ">=|< 1" ) &&@expr1073751027 !@expr1073751028 end@var3020 .@expr1073751029 tokAt (@expr1073751030 2 ) .@expr1073751031 isArithmeticalOp (@expr1073751032 ) ) ||@expr1073751033
1745: (@expr1073751034 end@var3020 .@expr9177 next (@expr9178 ) &&@expr9179 !@expr9180 end@var3020 .@expr9177 next (@expr9178 ) .@expr9183 isArithmeticalOp (@expr9184 ) &&@expr1073751043 Token ::@expr9149 Match (@expr1073751045 tok@var3016 .@expr9188 tokAt (@expr9189 -2 ) , "1 <=|>" ) &&@expr1073751048 !@expr1073751049 tok@var3016 .@expr9188 tokAt (@expr1073751051 -3 ) .@expr1073751052 isArithmeticalOp (@expr1073751053 ) ) ) {
1746: if (@expr9190 isCpp03ContainerSizeSlow (@expr9191 varTok@var3019 ) ) {
1747: sizeError (@expr9192 varTok@var3019 ) ; }
1748: }
1749:
1750:
1751: else { if (@expr1073751057 (@expr1073751058 Token ::@expr9149 Match (@expr1073751060 tok@var3016 .@expr9188 tokAt (@expr9189 -2 ) , "if|while (" ) &&@expr1073751063 end@var3020 .@expr1073751064 str (@expr1073751065 ) ==@expr1073751066 ")" ) ||@expr1073751067
1752: (@expr1073751068 tok@var3016 .@expr9168 previous (@expr9169 ) .@expr1073751071 tokType (@expr1073751072 ) ==@expr1073751073 Token ::@expr1073751074 eLogicalOp &&@expr1073751075 Token ::@expr9149 Match (@expr1073751077 end@var3020 , "&&|)|,|;|%oror%" ) ) ) {
1753: if (@expr9190 isCpp03ContainerSizeSlow (@expr9191 varTok@var3019 ) ) {
1754: sizeError (@expr9192 varTok@var3019 ) ; }
1755: } }
1756: }
1757: }
1758: }
1759: }
1760:
1761: void CheckStl :: sizeError ( const Token * tok@var3021 )
1762: {
1763: const std ::@expr1073751081 string varname@var3022 =@expr1073751082 tok@var3021 ?@expr1073751083 tok@var3021 .@expr1073751084 str (@expr1073751085 ) :@expr1073751086 std ::@expr1073751087 string (@expr1073751088 "list" ) ;
1764: reportError (@expr1073751089 tok@var3021 , Severity ::@expr1073751090 performance , "stlSize" ,
1765: "$symbol:" +@expr1073751091 varname@var3022 +@expr1073751092 "\nPossible inefficient checking for '$symbol' emptiness.\nChecking for '$symbol' emptiness might be inefficient. Using $symbol.empty() instead of $symbol.size() can be faster. $symbol.size() can take linear time but $symbol.empty() is guaranteed to take constant time."
1766:
|
1769:
1770: , CWE398@var2560 , Certainty ::@expr1073751093 normal ) ;
1771: }
1772:
1773: void CheckStl :: redundantCondition ( )
1774: {
1775: if (@expr1073751094 !@expr1073751095 mSettings@var29 .@expr1073751096 severity@var3299 .@expr1073751097 isEnabled (@expr1073751098 Severity ::@expr1073751099 style ) ) {
1776: return ; }
1777:
1778: const SymbolDatabase * symbolDatabase@var3023 ; symbolDatabase@var3023 =@expr1073751100 mTokenizer@var28 .@expr1073751101 getSymbolDatabase (@expr1073751102 ) ;
1779:
1780: for (@expr1073751103 const Scope &@expr1073751104 scope@var3024 :@expr1073751105 symbolDatabase@var3023 .@expr1073751106 scopeList@var3025 ) {
1781: if (@expr1073751107 scope@var3024 .@expr1073751108 type@var3026 !=@expr1073751109 Scope ::@expr1073751110 eIf ) {
1782: continue ; }
1783:
1784: const Token * tok@var3027 ; tok@var3027 =@expr1073751111 scope@var3024 .@expr1073751112 classDef@var3028 .@expr1073751113 tokAt (@expr1073751114 2 ) ;
1785: if (@expr1073751115 !@expr1073751116 Token ::@expr1073751117 Match (@expr1073751118 tok@var3027 , "%name% . find ( %any% ) != %name% . end|rend|cend|crend ( ) ) { %name% . remove|erase ( %any% ) ;" ) ) {
1786: continue ; }
1787:
1788:
1789: const Token * var1@var3029 ; var1@var3029 =@expr1073751119 tok@var3027 ;
1790: const Token * any1@var3030 ; any1@var3030 =@expr1073751120 var1@var3029 .@expr1073751121 tokAt (@expr1073751122 4 ) ;
1791: const Token * var2@var3031 ; var2@var3031 =@expr1073751123 any1@var3030 .@expr1073751124 tokAt (@expr1073751125 3 ) ;
1792: const Token * var3@var3032 ; var3@var3032 =@expr1073751126 var2@var3031 .@expr1073751127 tokAt (@expr1073751128 7 ) ;
1793: const Token * any2@var3033 ; any2@var3033 =@expr1073751129 var3@var3032 .@expr1073751130 tokAt (@expr1073751131 4 ) ;
1794:
1795:
1796: if (@expr1073751132 var1@var3029 .@expr1073751133 str (@expr1073751134 ) ==@expr1073751135 var2@var3031 .@expr9312 str (@expr9313 ) &&@expr1073751138
1797: var2@var3031 .@expr9312 str (@expr9313 ) ==@expr1073751141 var3@var3032 .@expr1073751142 str (@expr1073751143 ) &&@expr1073751144
1798: any1@var3030 .@expr1073751145 str (@expr1073751146 ) ==@expr1073751147 any2@var3033 .@expr1073751148 str (@expr1073751149 ) ) {
1799: redundantIfRemoveError (@expr1073751150 tok@var3027 ) ;
1800: }
1801: }
1802: }
1803:
1804: void CheckStl :: redundantIfRemoveError ( const Token * tok@var3034 )
1805: {
1806: reportError (@expr1073751151 tok@var3034 , Severity ::@expr1073751152 style , "redundantIfRemove" ,
1807: "Redundant checking of STL container element existence before removing it.\nRedundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element."
1808:
1809: , CWE398@var2560 , Certainty ::@expr1073751153 normal ) ;
1810: }
1811:
1812: void CheckStl :: missingComparison ( )
1813: {
1814: if (@expr1073751154 !@expr1073751155 mSettings@var29 .@expr1073751156 severity@var3299 .@expr1073751157 isEnabled (@expr1073751158 Severity ::@expr1073751159 warning ) ) {
1815: return ; }
1816:
1817: const SymbolDatabase * const symbolDatabase@var3035 ; symbolDatabase@var3035 =@expr1073751160 mTokenizer@var28 .@expr1073751161 getSymbolDatabase (@expr1073751162 ) ;
1818:
1819: for (@expr1073751163 const Scope &@expr1073751164 scope@var3036 :@expr1073751165 symbolDatabase@var3035 .@expr1073751166 scopeList@var3037 ) {
1820: if (@expr1073751167 scope@var3036 .@expr1073751168 type@var3038 !=@expr1073751169 Scope ::@expr1073751170 eFor ||@expr1073751171 !@expr1073751172 scope@var3036 .@expr9349 classDef@var3039 ) {
1821: continue ; }
1822:
1823: for (@expr1073751174 const Token *@expr9351 tok2@var3040 =@expr1073751176 scope@var3036 .@expr9349 classDef@var3039 .@expr1073751178 tokAt (@expr1073751179 2 ) ; tok2@var3040 !=@expr1073751180 scope@var3036 .@expr9357 bodyStart@var3041 ; tok2@var3040 =@expr1073751182 tok2@var3040 .@expr1073751183 next (@expr1073751184 ) ) {
1824: if (@expr1073751185 tok2@var3040 .@expr1073751186 str (@expr1073751187 ) ==@expr1073751188 ";" ) {
1825: break ; }
1826:
1827: if (@expr1073751189 !@expr1073751190 Token ::@expr9367 Match (@expr1073751192 tok2@var3040 , "%var% = %name% . begin|rbegin|cbegin|crbegin ( ) ; %name% != %name% . end|rend|cend|crend ( ) ; ++| %name% ++| ) {" ) ) {
1828: continue ; }
1829:
1830:
1831: if (@expr1073751193 tok2@var3040 .@expr9370 strAt (@expr1073751195 2 ) !=@expr1073751196 tok2@var3040 .@expr9370 strAt (@expr1073751198 10 ) ) {
1832: break ; }
1833:
1834: const int iteratorId@var3042 (@expr1073751199 tok2@var3040 .@expr1073751200 varId (@expr1073751201 ) ) ;
1835:
1836:
1837: if (@expr1073751202 iteratorId@var3042 ==@expr1073751203 tok2@var3040 .@expr9380 tokAt (@expr1073751205 10 ) .@expr1073751206 varId (@expr1073751207 ) ) {
1838: break ; }
1839:
1840:
1841: if (@expr1073751208 !@expr1073751209 Token ::@expr9367 Match (@expr1073751211 tok2@var3040 .@expr9380 tokAt (@expr9389 16 ) , "++ %varid% )" , iteratorId@var3042 ) &&@expr1073751214
1842: !@expr1073751215 Token ::@expr9367 Match (@expr1073751217 tok2@var3040 .@expr9380 tokAt (@expr9389 16 ) , "%varid% ++ )" , iteratorId@var3042 ) ) {
1843: break ;
1844: }
1845:
1846: const Token * incrementToken@var3043 ; incrementToken@var3043 =@expr1073751220 nullptr ;
1847:
1848: for (@expr1073751221 const Token *@expr9351 tok3@var3044 =@expr1073751223 scope@var3036 .@expr9357 bodyStart@var3041 ; tok3@var3044 !=@expr1073751225 scope@var3036 .@expr1073751226 bodyEnd@var3045 ; tok3@var3044 =@expr1073751227 tok3@var3044 .@expr1073751228 next (@expr1073751229 ) ) {
1849: if (@expr1073751230 tok3@var3044 .@expr1073751231 varId (@expr1073751232 ) ==@expr1073751233 iteratorId@var3042 ) {
1850: if (@expr1073751234 Token ::@expr9367 Match (@expr1073751236 tok3@var3044 , "%varid% = %name% . insert ( ++| %varid% ++| ," , iteratorId@var3042 ) ) {
1851:
1852: tok3@var3044 =@expr1073751237 tok3@var3044 .@expr1073751238 linkAt (@expr1073751239 6 ) ;
1853: if (@expr1073751240 !@expr1073751241 tok3@var3044 ) {
1854: break ; }
1855: } else { if (@expr1073751242 Token ::@expr9419 simpleMatch (@expr1073751244 tok3@var3044 .@expr9421 astParent (@expr9422 ) , "++" ) ) {
1856: incrementToken@var3043 =@expr1073751247 tok3@var3044 ; }
1857: else { if (@expr1073751248 Token ::@expr9419 simpleMatch (@expr1073751250 tok3@var3044 .@expr9421 astParent (@expr9422 ) , "+" ) ) {
1858: if (@expr1073751253 Token ::@expr9367 Match (@expr1073751255 tok3@var3044 .@expr1073751256 astSibling (@expr1073751257 ) , "%num%" ) ) {
1859: const Token * tokenGrandParent@var3046 ; tokenGrandParent@var3046 =@expr1073751258 tok3@var3044 .@expr9421 astParent (@expr9422 ) .@expr1073751261 astParent (@expr1073751262 ) ;
1860: if (@expr1073751263 Token ::@expr9367 Match (@expr1073751265 tokenGrandParent@var3046 , "==|!=" ) ) {
1861: break ; }
1862: }
1863: } else { if (@expr1073751266 Token ::@expr9367 Match (@expr1073751268 tok3@var3044 .@expr9421 astParent (@expr9422 ) , "==|!=" ) ) {
1864: incrementToken@var3043 =@expr1073751271 nullptr ; } } } }
1865: } else { if (@expr1073751272 tok3@var3044 .@expr9449 str (@expr9450 ) ==@expr1073751275 "break" ||@expr1073751276 tok3@var3044 .@expr9449 str (@expr9450 ) ==@expr1073751279 "return" ) {
1866: incrementToken@var3043 =@expr1073751280 nullptr ; } }
1867: }
1868: if (@expr1073751281 incrementToken@var3043 ) {
1869: missingComparisonError (@expr1073751282 incrementToken@var3043 , tok2@var3040 .@expr9380 tokAt (@expr9389 16 ) ) ; }
1870: }
1871: }
1872: }
1873:
1874: void CheckStl :: missingComparisonError ( const Token * incrementToken1@var3047 , const Token * incrementToken2@var3048 )
1875: {
1876: std ::@expr1073751285 list < const Token *@expr1073751286 > callstack@var3049 ; callstack@var3049 =@expr1073751287 {@expr1073751288 incrementToken1@var3047 , incrementToken2@var3048 } ;
1877:
1878: std ::@expr1073751289 ostringstream errmsg@var3050 ;
1879: errmsg@var3050 <<@expr1073751290 "Missing bounds check for extra iterator increment in loop.\n"
1880: <<@expr1073751291 "The iterator incrementing is suspicious - it is incremented at line " ;
1881: if (@expr1073751292 incrementToken1@var3047 ) {
1882: errmsg@var3050 <<@expr1073751293 incrementToken1@var3047 .@expr1073751294 linenr (@expr1073751295 ) ; }
1883: errmsg@var3050 <<@expr1073751296 " and then at line " ;
1884: if (@expr1073751297 incrementToken2@var3048 ) {
1885: errmsg@var3050 <<@expr1073751298 incrementToken2@var3048 .@expr1073751299 linenr (@expr1073751300 ) ; }
1886: errmsg@var3050 <<@expr1073751301 ". The loop might unintentionally skip an element in the container. "
1887: <<@expr1073751302 "There is no comparison between these increments to prevent that the iterator is "
1888: <<@expr1073751303 "incremented beyond the end." ;
1889:
1890: reportError (@expr1073751304 callstack@var3049 , Severity ::@expr1073751305 warning , "StlMissingComparison" , errmsg@var3050 .@expr1073751306 str (@expr1073751307 ) , CWE834@var2571 , Certainty ::@expr1073751308 normal ) ;
1891: }
1892:
1893:
1894: static bool isLocal ( const Token * tok@var3051 )
1895: {
1896: const Variable * var@var3052 ; var@var3052 =@expr1073751309 tok@var3051 .@expr1073751310 variable (@expr1073751311 ) ;
1897: return var@var3052 &&@expr1073751312 !@expr1073751313 var@var3052 .@expr1073751314 isStatic (@expr1073751315 ) &&@expr1073751316 var@var3052 .@expr1073751317 isLocal (@expr1073751318 ) ;
1898: }
1899:
1900: namespace {
1901: const std :: set < std :: string > stl_string_stream@var3053 = {
1902: "istringstream" , "ostringstream" , "stringstream" , "wstringstream"
1903: } ;
1904: }
1905:
1906: void CheckStl :: string_c_str ( )
1907: {
1908: const bool printInconclusive@var3054 =@expr1073751325 mSettings@var29 .@expr1073751326 certainty@var3298 .@expr1073751327 isEnabled (@expr1073751328 Certainty ::@expr1073751329 inconclusive@expr1073751319 ) ;
1909: const bool printPerformance@var3055 =@expr1073751330 mSettings@var29 .@expr1073751331 severity@var3299 .@expr1073751332 isEnabled (@expr1073751333 Severity ::@expr1073751334 performance ) ;
1910:
1911: const SymbolDatabase * symbolDatabase@var3056 ; symbolDatabase@var3056 =@expr1073751335 mTokenizer@var28 .@expr1073751336 getSymbolDatabase (@expr1073751337 ) ;
1912:
1913:
1914: std ::@expr1073751338 multimap < const Function *@expr9515 , int > c_strFuncParam@var3057 ;
1915: if (@expr1073751340 printPerformance@var3055 ) {
1916: for (@expr1073751341 const Scope &@expr9518 scope@var3058 :@expr1073751343 symbolDatabase@var3056 .@expr9520 scopeList@var3059 ) {
1917: for (@expr1073751345 const Function &@expr9518 func@var3060 :@expr1073751347 scope@var3058 .@expr1073751348 functionList@var3061 ) {
1918: int numpar@var3062 ; numpar@var3062 =@expr1073751349 0 ;
1919: for (@expr1073751350 const Variable &@expr9518 var@var3063 :@expr1073751352 func@var3060 .@expr1073751353 argumentList@var3064 ) {
1920: numpar@var3062 ++@expr1073751354 ;
1921: if (@expr1073751355 var@var3063 .@expr1073751356 isStlStringType (@expr1073751357 ) &&@expr1073751358 (@expr1073751359 !@expr1073751360 var@var3063 .@expr1073751361 isReference (@expr1073751362 ) ||@expr1073751363 var@var3063 .@expr1073751364 isConst (@expr1073751365 ) ) ) {
1922: c_strFuncParam@var3057 .@expr1073751366 insert (@expr1073751367 std ::@expr1073751368 make_pair (@expr1073751369 &@expr1073751370 func@var3060 , numpar@var3062 ) ) ; }
1923: }
1924: }
1925: }
1926: }
1927:
1928:
1929: for (@expr1073751371 const Scope &@expr9518 scope@var3065 :@expr1073751373 symbolDatabase@var3056 .@expr9520 scopeList@var3059 ) {
1930: if (@expr1073751375 scope@var3065 .@expr1073751376 type@var3066 !=@expr1073751377 Scope ::@expr1073751378 eFunction ||@expr1073751379 !@expr1073751380 scope@var3065 .@expr9557 function@var3067 ) {
1931: continue ; }
1932:
1933: enum {@expr1073751382 charPtr , stdString , stdStringConstRef , Other } returnType@expr9496 =@expr1073751383 Other@expr1073751321 ;
1934: if (@expr1073751384 Token ::@expr9561 Match (@expr1073751386 scope@var3065 .@expr9557 function@var3067 .@expr9564 tokenDef@var3068 .@expr9565 tokAt (@expr1073751390 -2 ) , "char|wchar_t *" ) ) {
1935: returnType@expr9496 =@expr1073751391 charPtr@expr9498 ; }
1936: else { if (@expr1073751392 Token ::@expr9561 Match (@expr1073751394 scope@var3065 .@expr9557 function@var3067 .@expr9564 tokenDef@var3068 .@expr9565 tokAt (@expr1073751398 -5 ) , "const std :: string|wstring &" ) ) {
1937: returnType@expr9496 =@expr1073751399 stdStringConstRef@expr9499 ; }
1938: else { if (@expr1073751400 Token ::@expr9561 Match (@expr1073751402 scope@var3065 .@expr9557 function@var3067 .@expr9564 tokenDef@var3068 .@expr9565 tokAt (@expr1073751406 -3 ) , "std :: string|wstring !!&" ) ) {
1939: returnType@expr9496 =@expr1073751407 stdString@expr9500 ; } } }
1940:
1941: for (@expr1073751408 const Token *@expr9515 tok@var3069 =@expr1073751410 scope@var3065 .@expr1073751411 bodyStart@var3070 ; tok@var3069 &&@expr1073751412 tok@var3069 !=@expr1073751413 scope@var3065 .@expr1073751414 bodyEnd@var3071 ; tok@var3069 =@expr1073751415 tok@var3069 .@expr9592 next (@expr9593 ) ) {
1942:
1943: if (@expr1073751418 Token ::@expr9561 Match (@expr1073751420 tok@var3069 , "throw %var% . c_str|data ( ) ;" ) &&@expr1073751421 isLocal (@expr1073751422 tok@var3069 .@expr9592 next (@expr9593 ) ) &&@expr1073751425
1944: tok@var3069 .@expr9592 next (@expr9593 ) .@expr9604 variable (@expr9605 ) &&@expr1073751430 tok@var3069 .@expr9592 next (@expr9593 ) .@expr9604 variable (@expr9605 ) .@expr1073751435 isStlStringType (@expr1073751436 ) ) {
1945: string_c_strThrowError (@expr1073751437 tok@var3069 ) ;
1946: } else { if (@expr1073751438 tok@var3069 .@expr9615 variable (@expr9616 ) &&@expr1073751441 tok@var3069 .@expr1073751442 strAt (@expr1073751443 1 ) ==@expr1073751444 "=" ) {
1947: if (@expr1073751445 Token ::@expr9561 Match (@expr1073751447 tok@var3069 .@expr9624 tokAt (@expr9625 2 ) , "%var% . str ( ) . c_str|data ( ) ;" ) ) {
1948: const Variable * var@var3072 ; var@var3072 =@expr1073751450 tok@var3069 .@expr9615 variable (@expr9616 ) ;
1949: const Variable * var2@var3073 ; var2@var3073 =@expr1073751453 tok@var3069 .@expr9624 tokAt (@expr9625 2 ) .@expr1073751456 variable (@expr1073751457 ) ;
1950: if (@expr1073751458 var@var3072 .@expr1073751459 isPointer (@expr1073751460 ) &&@expr1073751461 var2@var3073 &&@expr1073751462 var2@var3073 .@expr1073751463 isStlType (@expr1073751464 stl_string_stream@var3053 ) ) {
1951: string_c_strError (@expr9641 tok@var3069 ) ; }
1952: } else { if (@expr1073751466 Token ::@expr9561 Match (@expr1073751468 tok@var3069 .@expr9624 tokAt (@expr9625 2 ) , "%name% (" ) &&@expr1073751471
1953: Token ::@expr9561 Match (@expr1073751473 tok@var3069 .@expr1073751474 linkAt (@expr1073751475 3 ) , ") . c_str|data ( ) ;" ) &&@expr1073751476
1954: tok@var3069 .@expr9624 tokAt (@expr9625 2 ) .@expr9655 function (@expr9656 ) &&@expr1073751481 Token ::@expr9561 Match (@expr1073751483 tok@var3069 .@expr9624 tokAt (@expr9625 2 ) .@expr9655 function (@expr9656 ) .@expr1073751488 retDef@var3318 , "std :: string|wstring %name%" ) ) {
1955: const Variable * var@var3074 ; var@var3074 =@expr1073751489 tok@var3069 .@expr9615 variable (@expr9616 ) ;
1956: if (@expr1073751492 var@var3074 .@expr1073751493 isPointer (@expr1073751494 ) ) {
1957: string_c_strError (@expr9641 tok@var3069 ) ; }
1958: } }
1959: } else { if (@expr1073751496 printPerformance@var3055 &&@expr1073751497 tok@var3069 .@expr9674 function (@expr9675 ) &&@expr1073751500 Token ::@expr9561 Match (@expr1073751502 tok@var3069 , "%name% ( !!)" ) &&@expr1073751503 c_strFuncParam@var3057 .@expr1073751504 find (@expr1073751505 tok@var3069 .@expr9674 function (@expr9675 ) ) !=@expr1073751508 c_strFuncParam@var3057 .@expr1073751509 end (@expr1073751510 ) &&@expr1073751511
1960: tok@var3069 .@expr9688 str (@expr9689 ) !=@expr1073751514 scope@var3065 .@expr1073751515 className@var3075 ) {
1961: const std ::@expr1073751516 pair < std ::@expr9693 multimap < const Function *@expr9515 , int > ::@expr9693 const_iterator , std ::@expr9693 multimap < const Function *@expr9515 , int > ::@expr9693 const_iterator > range@var3076 =@expr1073751523 c_strFuncParam@var3057 .@expr1073751524 equal_range (@expr1073751525 tok@var3069 .@expr9674 function (@expr9675 ) ) ;
1962: for (@expr1073751528 std ::@expr9693 multimap < const Function *@expr9515 , int > ::@expr9693 const_iterator i@var3077 =@expr1073751532 range@var3076 .@expr1073751533 first@var3078 ; i@var3077 !=@expr1073751534 range@var3076 .@expr1073751535 second@var3079 ; ++@expr1073751536 i@var3077 ) {
1963: if (@expr1073751537 i@var3077 .@expr9714 second@var3080 ==@expr1073751539 0 ) {
1964: continue ; }
1965:
1966: const Token * tok2@var3081 ; tok2@var3081 =@expr1073751540 tok@var3069 .@expr9624 tokAt (@expr9625 2 ) ;
1967: int j@var3082 ;
1968: for (@expr1073751543 j@var3082 =@expr1073751544 0 ; tok2@var3081 &&@expr1073751545 j@var3082 <@expr1073751546 i@var3077 .@expr9714 second@var3080 -@expr9724 1 ; j@var3082 ++@expr1073751549 ) {
1969: tok2@var3081 =@expr1073751550 tok2@var3081 .@expr9727 nextArgument (@expr9728 ) ; }
1970: if (@expr9729 tok2@var3081 ) {
1971: tok2@var3081 =@expr1073751554 tok2@var3081 .@expr9727 nextArgument (@expr9728 ) ; }
1972: else {
1973: break ; }
1974: if (@expr1073751557 !@expr1073751558 tok2@var3081 &&@expr1073751559 j@var3082 ==@expr1073751560 i@var3077 .@expr9714 second@var3080 -@expr9724 1 ) {
1975: tok2@var3081 =@expr1073751563 tok@var3069 .@expr9592 next (@expr9593 ) .@expr1073751566 link (@expr1073751567 ) ; }
1976: else { if (@expr9729 tok2@var3081 ) {
1977: tok2@var3081 =@expr1073751569 tok2@var3081 .@expr1073751570 previous (@expr1073751571 ) ; }
1978: else {
1979: break ; } }
1980: if (@expr1073751572 tok2@var3081 &&@expr1073751573 Token ::@expr9561 Match (@expr1073751575 tok2@var3081 .@expr9752 tokAt (@expr1073751577 -4 ) , ". c_str|data ( )" ) ) {
1981: const Variable * var@var3083 ; var@var3083 =@expr1073751578 tok2@var3081 .@expr9752 tokAt (@expr1073751580 -5 ) .@expr1073751581 variable (@expr1073751582 ) ;
1982: if (@expr1073751583 var@var3083 &&@expr1073751584 var@var3083 .@expr1073751585 isStlStringType (@expr1073751586 ) ) {
1983: string_c_strParam (@expr9763 tok@var3069 , i@var3077 .@expr9714 second@var3080 ) ;
1984: } else { if (@expr1073751589 Token ::@expr9561 Match (@expr1073751591 tok2@var3081 .@expr9752 tokAt (@expr9769 -9 ) , "%name% . str ( )" ) ) {
1985: const Variable * ssVar@var3084 ; ssVar@var3084 =@expr1073751594 tok2@var3081 .@expr9752 tokAt (@expr9769 -9 ) .@expr1073751597 variable (@expr1073751598 ) ;
1986: if (@expr1073751599 ssVar@var3084 &&@expr1073751600 ssVar@var3084 .@expr1073751601 isStlType (@expr1073751602 stl_string_stream@var3053 ) ) {
1987: string_c_strParam (@expr9763 tok@var3069 , i@var3077 .@expr9714 second@var3080 ) ; }
1988: } }
1989:
1990: }
1991: }
1992: }
1993:
1994:
1995: else { if (@expr1073751605 (@expr1073751606 returnType@expr9496 ==@expr9783 charPtr@expr9498 ||@expr1073751608 (@expr1073751609 printPerformance@var3055 &&@expr1073751610 (@expr1073751611 returnType@expr9496 ==@expr1073751612 stdString@expr9500 ||@expr1073751613 returnType@expr9496 ==@expr1073751614 stdStringConstRef@expr9499 ) ) ) &&@expr1073751615 tok@var3069 .@expr9688 str (@expr9689 ) ==@expr1073751618 "return" ) {
1996: bool err@var3085 ; err@var3085 =@expr1073751619 false ;
1997:
1998: const Token * tok2@var3086 ; tok2@var3086 =@expr1073751620 tok@var3069 .@expr9592 next (@expr9593 ) ;
1999: if (@expr1073751623 Token ::@expr9561 Match (@expr1073751625 tok2@var3086 , "std :: string|wstring (" ) &&@expr1073751626
2000: Token ::@expr9561 Match (@expr1073751628 tok2@var3086 .@expr9805 linkAt (@expr1073751630 3 ) , ") . c_str|data ( ) ;" ) ) {
2001: err@var3085 =@expr1073751631 true ;
2002: } else { if (@expr1073751632 Token ::@expr9809 simpleMatch (@expr1073751634 tok2@var3086 , "(" ) &&@expr1073751635
2003: Token ::@expr9561 Match (@expr1073751637 tok2@var3086 .@expr9814 link (@expr9815 ) , ") . c_str|data ( ) ;" ) ) {
2004:
2005: bool is_implicit_std_string@var3087 ; is_implicit_std_string@var3087 =@expr1073751640 printInconclusive@var3054 ;
2006: const Token * search_end@var3088 ; search_end@var3088 =@expr1073751641 tok2@var3086 .@expr9814 link (@expr9815 ) ;
2007: for (@expr1073751644 const Token *@expr9515 search_tok@var3089 =@expr1073751646 tok2@var3086 .@expr1073751647 next (@expr1073751648 ) ; search_tok@var3089 !=@expr1073751649 search_end@var3088 ; search_tok@var3089 =@expr1073751650 search_tok@var3089 .@expr9827 next (@expr9828 ) ) {
2008: if (@expr1073751653 Token ::@expr9561 Match (@expr1073751655 search_tok@var3089 , "+ %var%" ) &&@expr1073751656 isLocal (@expr1073751657 search_tok@var3089 .@expr9827 next (@expr9828 ) ) &&@expr1073751660
2009: search_tok@var3089 .@expr9827 next (@expr9828 ) .@expr9839 variable (@expr9840 ) &&@expr1073751665 search_tok@var3089 .@expr9827 next (@expr9828 ) .@expr9839 variable (@expr9840 ) .@expr1073751670 isStlStringType (@expr1073751671 ) ) {
2010: is_implicit_std_string@var3087 =@expr1073751672 true ;
2011: break ;
2012: } else { if (@expr1073751673 Token ::@expr9561 Match (@expr1073751675 search_tok@var3089 , "+ std :: string|wstring (" ) ) {
2013: is_implicit_std_string@var3087 =@expr1073751676 true ;
2014: break ;
2015: } }
2016: }
2017:
2018: if (@expr1073751677 is_implicit_std_string@var3087 ) {
2019: err@var3085 =@expr1073751678 true ; }
2020: } }
2021:
2022: bool local@var3090 ; local@var3090 =@expr1073751679 false ;
2023: bool ptrOrRef@var3091 ; ptrOrRef@var3091 =@expr1073751680 false ;
2024: const Variable * lastVar@var3092 ; lastVar@var3092 =@expr1073751681 nullptr ;
2025: const Function * lastFunc@var3093 ; lastFunc@var3093 =@expr1073751682 nullptr ;
2026: bool funcStr@var3094 ; funcStr@var3094 =@expr1073751683 false ;
2027: if (@expr1073751684 Token ::@expr9561 Match (@expr1073751686 tok2@var3086 , "%var% ." ) ) {
2028: local@var3090 =@expr1073751687 isLocal (@expr1073751688 tok2@var3086 ) ;
2029: bool refToNonLocal@var3095 ; refToNonLocal@var3095 =@expr1073751689 false ;
2030: if (@expr1073751690 tok2@var3086 .@expr9867 variable (@expr9868 ) &&@expr1073751693 tok2@var3086 .@expr9867 variable (@expr9868 ) .@expr1073751696 isReference (@expr1073751697 ) ) {
2031: const Token * refTok@var3096 ; refTok@var3096 =@expr1073751698 tok2@var3086 .@expr9867 variable (@expr9868 ) .@expr1073751701 nameToken (@expr1073751702 ) ;
2032: refToNonLocal@var3095 =@expr1073751703 true ;
2033: if (@expr1073751704 Token ::@expr9561 Match (@expr1073751706 refTok@var3096 , "%var% = %var% .|;|[" ) ) {
2034: refToNonLocal@var3095 =@expr1073751707 !@expr1073751708 isLocal (@expr1073751709 refTok@var3096 .@expr1073751710 tokAt (@expr1073751711 2 ) ) ; }
2035: }
2036: ptrOrRef@var3091 =@expr1073751712 refToNonLocal@var3095 ||@expr1073751713 (@expr1073751714 tok2@var3086 .@expr9867 variable (@expr9868 ) &&@expr1073751717 tok2@var3086 .@expr9867 variable (@expr9868 ) .@expr1073751720 isPointer (@expr1073751721 ) ) ;
2037: }
2038: while (@expr1073751722 tok2@var3086 ) {
2039: if (@expr1073751723 Token ::@expr9561 Match (@expr1073751725 tok2@var3086 , "%var% .|::" ) ) {
2040: if (@expr1073751726 ptrOrRef@var3091 ) {
2041: local@var3090 =@expr1073751727 false ; }
2042: lastVar@var3092 =@expr1073751728 tok2@var3086 .@expr9867 variable (@expr9868 ) ;
2043: tok2@var3086 =@expr1073751731 tok2@var3086 .@expr1073751732 tokAt (@expr1073751733 2 ) ;
2044: } else { if (@expr1073751734 Token ::@expr9561 Match (@expr1073751736 tok2@var3086 , "%name% (" ) &&@expr1073751737 Token ::@expr9809 simpleMatch (@expr1073751739 tok2@var3086 .@expr9805 linkAt (@expr9917 1 ) , ") ." ) ) {
2045: lastFunc@var3093 =@expr1073751742 tok2@var3086 .@expr1073751743 function (@expr1073751744 ) ;
2046: local@var3090 =@expr1073751745 false ;
2047: funcStr@var3094 =@expr1073751746 tok2@var3086 .@expr1073751747 str (@expr1073751748 ) ==@expr1073751749 "str" ;
2048: tok2@var3086 =@expr1073751750 tok2@var3086 .@expr9805 linkAt (@expr9917 1 ) .@expr1073751753 tokAt (@expr1073751754 2 ) ;
2049: } else {
2050: break ; } }
2051: }
2052:
2053: if (@expr1073751755 Token ::@expr9561 Match (@expr1073751757 tok2@var3086 , "c_str|data ( ) ;" ) ) {
2054: if (@expr1073751758 (@expr1073751759 local@var3090 ||@expr1073751760 returnType@expr9496 !=@expr1073751761 charPtr@expr9498 ) &&@expr1073751762 lastVar@var3092 &&@expr1073751763 lastVar@var3092 .@expr1073751764 isStlStringType (@expr1073751765 ) ) {
2055: err@var3085 =@expr1073751766 true ; }
2056: else { if (@expr1073751767 funcStr@var3094 &&@expr1073751768 lastVar@var3092 &&@expr1073751769 lastVar@var3092 .@expr1073751770 isStlType (@expr1073751771 stl_string_stream@var3053 ) ) {
2057: err@var3085 =@expr1073751772 true ; }
2058: else { if (@expr1073751773 lastFunc@var3093 &&@expr1073751774 Token ::@expr9561 Match (@expr1073751776 lastFunc@var3093 .@expr1073751777 tokenDef@var3097 .@expr1073751778 tokAt (@expr1073751779 -3 ) , "std :: string|wstring" ) ) {
2059: err@var3085 =@expr1073751780 true ; } } }
2060: }
2061:
2062: if (@expr1073751781 err@var3085 ) {
2063: if (@expr1073751782 returnType@expr9496 ==@expr9783 charPtr@expr9498 ) {
2064: string_c_strError (@expr9641 tok@var3069 ) ; }
2065: else {
2066: string_c_strReturn (@expr1073751785 tok@var3069 ) ; }
2067: }
2068: } } } }
2069: }
2070: }
2071: }
2072:
2073: void CheckStl :: string_c_strThrowError ( const Token * tok@var3098 )
2074: {
2075: reportError (@expr1073751786 tok@var3098 , Severity ::@expr1073751787 error , "stlcstrthrow" , "Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception.\nDangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid."
2076: ) ;
2077: }
2078:
2079: void CheckStl :: string_c_strError ( const Token * tok@var3099 )
2080: {
2081: reportError (@expr1073751788 tok@var3099 , Severity ::@expr1073751789 error , "stlcstr" , "Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.\nDangerous usage of c_str(). The c_str() return value is only valid until its string is deleted."
2082: , CWE664@var2563 , Certainty ::@expr1073751790 normal ) ;
2083: }
2084:
2085: void CheckStl :: string_c_strReturn ( const Token * tok@var3100 )
2086: {
2087: reportError (@expr1073751791 tok@var3100 , Severity ::@expr1073751792 performance , "stlcstrReturn" , "Returning the result of c_str() in a function that returns std::string is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string."
2088: , CWE704@var2565 , Certainty ::@expr1073751793 normal ) ;
2089: }
2090:
2091: void CheckStl :: string_c_strParam ( const Token * tok@var3101 , int number@var3102 )
2092: {
2093: std ::@expr1073751794 ostringstream oss@var3103 ;
2094: oss@var3103 <<@expr1073751795 "Passing the result of c_str() to a function that takes std::string as argument no. " <<@expr1073751796 number@var3102 <<@expr1073751797 " is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly passing the string."
2095: ;
2096: reportError (@expr1073751798 tok@var3101 , Severity ::@expr1073751799 performance , "stlcstrParam" , oss@var3103 .@expr1073751800 str (@expr1073751801 ) , CWE704@var2565 , Certainty ::@expr1073751802 normal ) ;
2097: }
2098:
|
2102:
2103: namespace {
2104: const std :: set < std :: string > stl_containers_with_empty_and_clear@var3104 = {
2105: "deque" , "forward_list" , "list" ,
2106: "map" , "multimap" , "multiset" , "set" , "string" ,
2107: "unordered_map" , "unordered_multimap" , "unordered_multiset" ,
2108: "unordered_set" , "vector" , "wstring"
2109: } ;
2110:
2111: }
2112:
2113: void CheckStl :: uselessCalls ( )
2114: {
2115: const bool printPerformance@var3105 =@expr1073751803 mSettings@var29 .@expr9980 severity@var3299 .@expr9981 isEnabled (@expr1073751806 Severity ::@expr1073751807 performance ) ;
2116: const bool printWarning@var3106 =@expr1073751808 mSettings@var29 .@expr9980 severity@var3299 .@expr9981 isEnabled (@expr1073751811 Severity ::@expr1073751812 warning ) ;
2117: if (@expr1073751813 !@expr1073751814 printPerformance@var3105 &&@expr1073751815 !@expr1073751816 printWarning@var3106 ) {
2118: return ; }
2119:
2120: const SymbolDatabase * symbolDatabase@var3107 ; symbolDatabase@var3107 =@expr1073751817 mTokenizer@var28 .@expr1073751818 getSymbolDatabase (@expr1073751819 ) ;
2121: for (@expr1073751820 const Scope *@expr9997 scope@var3108 :@expr1073751822 symbolDatabase@var3107 .@expr1073751823 functionScopes@var3109 ) {
2122: for (@expr1073751824 const Token *@expr9997 tok@var3110 =@expr1073751826 scope@var3108 .@expr1073751827 bodyStart@var3111 ; tok@var3110 !=@expr1073751828 scope@var3108 .@expr1073751829 bodyEnd@var3112 ; tok@var3110 =@expr1073751830 tok@var3110 .@expr10007 next (@expr10008 ) ) {
2123: if (@expr1073751833 printWarning@var3106 &&@expr1073751834 Token ::@expr10011 Match (@expr1073751836 tok@var3110 , "%var% . compare|find|rfind|find_first_not_of|find_first_of|find_last_not_of|find_last_of ( %name% [,)]" ) &&@expr1073751837
2124: tok@var3110 .@expr10014 varId (@expr10015 ) ==@expr10016 tok@var3110 .@expr10017 tokAt (@expr10018 4 ) .@expr10019 varId (@expr10020 ) ) {
2125: const Variable * var@var3113 ; var@var3113 =@expr1073751845 tok@var3110 .@expr10022 variable (@expr10023 ) ;
2126: if (@expr1073751848 !@expr1073751849 var@var3113 ||@expr1073751850 !@expr1073751851 var@var3113 .@expr1073751852 isStlType (@expr1073751853 ) ) {
2127: continue ; }
2128: uselessCallsReturnValueError (@expr1073751854 tok@var3110 .@expr10017 tokAt (@expr10018 4 ) , tok@var3110 .@expr10033 str (@expr10034 ) , tok@var3110 .@expr10035 strAt (@expr1073751860 2 ) ) ;
2129: } else { if (@expr1073751861 printPerformance@var3105 &&@expr1073751862 Token ::@expr10011 Match (@expr1073751864 tok@var3110 , "%var% . swap ( %name% )" ) &&@expr1073751865
2130: tok@var3110 .@expr10014 varId (@expr10015 ) ==@expr10016 tok@var3110 .@expr10017 tokAt (@expr10018 4 ) .@expr10019 varId (@expr10020 ) ) {
2131: const Variable * var@var3114 ; var@var3114 =@expr1073751873 tok@var3110 .@expr10022 variable (@expr10023 ) ;
2132: if (@expr1073751876 !@expr1073751877 var@var3114 ||@expr1073751878 !@expr1073751879 var@var3114 .@expr1073751880 isStlType (@expr1073751881 ) ) {
2133: continue ; }
2134: uselessCallsSwapError (@expr1073751882 tok@var3110 , tok@var3110 .@expr10033 str (@expr10034 ) ) ;
2135: } else { if (@expr1073751885 printPerformance@var3105 &&@expr1073751886 Token ::@expr10011 Match (@expr1073751888 tok@var3110 , "%var% . substr (" ) &&@expr1073751889
2136: tok@var3110 .@expr10022 variable (@expr10023 ) &&@expr1073751892 tok@var3110 .@expr10022 variable (@expr10023 ) .@expr1073751895 isStlStringType (@expr1073751896 ) ) {
2137: if (@expr1073751897 Token ::@expr10011 Match (@expr1073751899 tok@var3110 .@expr10017 tokAt (@expr10018 4 ) , "0| )" ) ) {
2138: uselessCallsSubstrError (@expr10078 tok@var3110 , false ) ;
2139: } else { if (@expr1073751903 tok@var3110 .@expr10035 strAt (@expr1073751905 4 ) ==@expr1073751906 "0" &&@expr1073751907 tok@var3110 .@expr10084 linkAt (@expr10085 3 ) .@expr1073751910 strAt (@expr1073751911 -1 ) ==@expr1073751912 "npos" ) {
2140: if (@expr1073751913 !@expr1073751914 tok@var3110 .@expr10084 linkAt (@expr10085 3 ) .@expr1073751917 previous (@expr1073751918 ) .@expr1073751919 variable (@expr1073751920 ) ) {
2141: uselessCallsSubstrError (@expr10078 tok@var3110 , false ) ; }
2142: } else { if (@expr1073751922 Token ::@expr1073751923 simpleMatch (@expr1073751924 tok@var3110 .@expr10084 linkAt (@expr10085 3 ) .@expr1073751927 tokAt (@expr1073751928 -2 ) , ", 0 )" ) ) {
2143: uselessCallsSubstrError (@expr1073751929 tok@var3110 , true ) ; } } }
2144: } else { if (@expr1073751930 printWarning@var3106 &&@expr1073751931 Token ::@expr10011 Match (@expr1073751933 tok@var3110 , "[{};] %var% . empty ( ) ;" ) &&@expr1073751934
2145: !@expr1073751935 tok@var3110 .@expr10017 tokAt (@expr10018 4 ) .@expr1073751938 astParent (@expr1073751939 ) &&@expr1073751940
2146: tok@var3110 .@expr10007 next (@expr10008 ) .@expr10119 variable (@expr10120 ) &&@expr1073751945 tok@var3110 .@expr10007 next (@expr10008 ) .@expr10119 variable (@expr10120 ) .@expr1073751950 isStlType (@expr1073751951 stl_containers_with_empty_and_clear@var3104 ) ) {
2147: uselessCallsEmptyError (@expr1073751952 tok@var3110 .@expr10007 next (@expr10008 ) ) ; }
2148: else { if (@expr1073751955 Token ::@expr10011 Match (@expr1073751957 tok@var3110 , "[{};] std :: remove|remove_if|unique (" ) &&@expr1073751958 tok@var3110 .@expr10017 tokAt (@expr1073751960 5 ) .@expr1073751961 nextArgument (@expr1073751962 ) ) {
2149: uselessCallsRemoveError (@expr1073751963 tok@var3110 .@expr10007 next (@expr10008 ) , tok@var3110 .@expr10035 strAt (@expr1073751967 3 ) ) ; } } } } }
2150: }
2151: }
2152: }
2153:
2154:
2155: void CheckStl :: uselessCallsReturnValueError ( const Token * tok@var3115 , const std :: string & varname@var3116 , const std :: string & function@var3117 )
2156: {
2157: std ::@expr1073751968 ostringstream errmsg@var3118 ;
2158: errmsg@var3118 <<@expr10145 "$symbol:" <<@expr1073751970 varname@var3116 <<@expr1073751971 '\n' ;
2159: errmsg@var3118 <<@expr10145 "$symbol:" <<@expr1073751973 function@var3117 <<@expr1073751974 '\n' ;
2160: errmsg@var3118 <<@expr1073751975 "It is inefficient to call '" <<@expr1073751976 varname@var3116 <<@expr1073751977 "." <<@expr1073751978 function@var3117 <<@expr1073751979 "(" <<@expr1073751980 varname@var3116 <<@expr1073751981 ")' as it always returns 0.\n"
2161: <<@expr1073751982 "'std::string::" <<@expr1073751983 function@var3117 <<@expr1073751984 "()' returns zero when given itself as parameter "
2162: <<@expr1073751985 "(" <<@expr1073751986 varname@var3116 <<@expr1073751987 "." <<@expr1073751988 function@var3117 <<@expr1073751989 "(" <<@expr1073751990 varname@var3116 <<@expr1073751991 ")). As it is currently the "
2163: <<@expr1073751992 "code is inefficient. It is possible either the string searched ('"
2164: <<@expr1073751993 varname@var3116 <<@expr1073751994 "') or searched for ('" <<@expr1073751995 varname@var3116 <<@expr1073751996 "') is wrong." ;
2165: reportError (@expr1073751997 tok@var3115 , Severity ::@expr1073751998 warning , "uselessCallsCompare" , errmsg@var3118 .@expr1073751999 str (@expr1073752000 ) , CWE628@var2562 , Certainty ::@expr1073752001 normal ) ;
2166: }
2167:
2168: void CheckStl :: uselessCallsSwapError ( const Token * tok@var3119 , const std :: string & varname@var3120 )
2169: {
2170: reportError (@expr1073752002 tok@var3119 , Severity ::@expr1073752003 performance , "uselessCallsSwap" ,
2171: "$symbol:" +@expr1073752004 varname@var3120 +@expr1073752005 "\nIt is inefficient to swap a object with itself by calling '$symbol.swap($symbol)'\nThe 'swap()' function has no logical effect when given itself as parameter ($symbol.swap($symbol)). As it is currently the code is inefficient. Is the object or the parameter wrong here?"
2172:
2173:
2174:
2175: , CWE628@var2562 , Certainty ::@expr1073752006 normal ) ;
2176: }
2177:
2178: void CheckStl :: uselessCallsSubstrError ( const Token * tok@var3121 , bool empty@var3122 )
2179: {
2180: if (@expr1073752007 empty@var3122 ) {
2181: reportError (@expr1073752008 tok@var3121 , Severity ::@expr10185 performance , "uselessCallsSubstr" , "Ineffective call of function 'substr' because it returns an empty string." , CWE398@var2560 , Certainty ::@expr10186 normal ) ; }
2182: else {
2183: reportError (@expr1073752011 tok@var3121 , Severity ::@expr10185 performance , "uselessCallsSubstr" , "Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead." , CWE398@var2560 , Certainty ::@expr10186 normal ) ; }
2184: }
2185:
2186: void CheckStl :: uselessCallsEmptyError ( const Token * tok@var3123 )
2187: {
2188: reportError (@expr1073752014 tok@var3123 , Severity ::@expr1073752015 warning , "uselessCallsEmpty" , "Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?" , CWE398@var2560 , Certainty ::@expr1073752016 normal ) ;
2189: }
2190:
2191: void CheckStl :: uselessCallsRemoveError ( const Token * tok@var3124 , const std :: string & function@var3125 )
2192: {
2193: reportError (@expr1073752017 tok@var3124 , Severity ::@expr1073752018 warning , "uselessCallsRemove" ,
2194: "$symbol:" +@expr1073752019 function@var3125 +@expr1073752020 "\nReturn value of std::$symbol() ignored. Elements remain in container.\nThe return value of std::$symbol() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them."
2195:
2196:
2197: , CWE762@var2566 , Certainty ::@expr1073752021 normal ) ;
2198: }
2199:
2200:
2201:
2202: void CheckStl :: checkDereferenceInvalidIterator ( )
2203: {
2204: if (@expr1073752022 !@expr1073752023 mSettings@var29 .@expr1073752024 severity@var3299 .@expr1073752025 isEnabled (@expr1073752026 Severity ::@expr1073752027 warning ) ) {
2205: return ; }
2206:
2207:
2208:
2209: for (@expr1073752028 const Scope &@expr1073752029 scope@var3126 :@expr1073752030 mTokenizer@var28 .@expr1073752031 getSymbolDatabase (@expr1073752032 ) .@expr1073752033 scopeList@var3316 ) {
2210: if (@expr1073752034 !@expr1073752035 (@expr1073752036 scope@var3126 .@expr10213 type@var3127 ==@expr1073752038 Scope ::@expr1073752039 eIf ||@expr1073752040 scope@var3126 .@expr1073752041 isLoopScope (@expr1073752042 ) ) ) {
2211: continue ; }
2212:
2213: const Token * const tok@var3128 ; tok@var3128 =@expr1073752043 scope@var3126 .@expr1073752044 classDef@var3129 ;
2214: const Token * startOfCondition@var3130 ; startOfCondition@var3130 =@expr1073752045 tok@var3128 .@expr1073752046 next (@expr1073752047 ) ;
2215: if (@expr1073752048 scope@var3126 .@expr10213 type@var3127 ==@expr1073752050 Scope ::@expr1073752051 eDo ) {
2216: startOfCondition@var3130 =@expr1073752052 startOfCondition@var3130 .@expr10229 link (@expr10230 ) .@expr1073752055 tokAt (@expr1073752056 2 ) ; }
2217: if (@expr10233 !@expr10234 startOfCondition@var3130 ) {
2218: continue ; }
2219: const Token * endOfCondition@var3131 ; endOfCondition@var3131 =@expr1073752059 startOfCondition@var3130 .@expr10229 link (@expr10230 ) ;
2220: if (@expr10238 !@expr10239 endOfCondition@var3131 ) {
2221: continue ; }
2222:
2223:
2224: if (@expr1073752064 scope@var3126 .@expr10213 type@var3127 ==@expr1073752066 Scope ::@expr1073752067 eFor ) {
2225: startOfCondition@var3130 =@expr1073752068 Token ::@expr10245 findsimplematch (@expr1073752070 tok@var3128 .@expr1073752071 tokAt (@expr1073752072 2 ) , ";" , endOfCondition@var3131 ) ;
2226: if (@expr10233 !@expr10234 startOfCondition@var3130 ) {
2227: continue ; }
2228: endOfCondition@var3131 =@expr1073752075 Token ::@expr10245 findsimplematch (@expr1073752077 startOfCondition@var3130 .@expr1073752078 next (@expr1073752079 ) , ";" , endOfCondition@var3131 ) ;
2229: if (@expr10238 !@expr10239 endOfCondition@var3131 ) {
2230: continue ; }
2231: }
2232:
2233:
2234:
2235: const bool isOrExpression@var3132 =@expr1073752082
2236: Token ::@expr10245 findsimplematch (@expr1073752084 startOfCondition@var3130 , "||" , endOfCondition@var3131 ) !=@expr1073752085 nullptr ;
2237: const bool isAndExpression@var3133 =@expr1073752086
2238: Token ::@expr10245 findsimplematch (@expr1073752088 startOfCondition@var3130 , "&&" , endOfCondition@var3131 ) !=@expr1073752089 nullptr ;
2239:
2240:
2241: const Token * validityCheckTok@var3134 ; validityCheckTok@var3134 =@expr1073752090 nullptr ;
2242: if (@expr1073752091 !@expr1073752092 isOrExpression@var3132 &&@expr1073752093 isAndExpression@var3133 ) {
2243: validityCheckTok@var3134 =@expr1073752094
2244: Token ::@expr10271 findmatch (@expr1073752096 startOfCondition@var3130 , "&& %var% != %name% . end|rend|cend|crend ( )" , endOfCondition@var3131 ) ;
2245: } else { if (@expr1073752097 isOrExpression@var3132 &&@expr1073752098 !@expr1073752099 isAndExpression@var3133 ) {
2246: validityCheckTok@var3134 =@expr1073752100
2247: Token ::@expr10271 findmatch (@expr1073752102 startOfCondition@var3130 , "%oror% %var% == %name% . end|rend|cend|crend ( )" , endOfCondition@var3131 ) ;
2248: } }
2249:
2250: if (@expr1073752103 !@expr1073752104 validityCheckTok@var3134 ) {
2251: continue ; }
2252: const int iteratorVarId@var3135 =@expr1073752105 validityCheckTok@var3134 .@expr1073752106 next (@expr1073752107 ) .@expr1073752108 varId (@expr1073752109 ) ;
2253:
2254:
2255:
2256: const Token * const dereferenceTok@var3136 ; dereferenceTok@var3136 =@expr1073752110
2257: Token ::@expr10271 findmatch (@expr1073752112 startOfCondition@var3130 , "* %varid%" , validityCheckTok@var3134 , iteratorVarId@var3135 ) ;
2258: if (@expr1073752113 dereferenceTok@var3136 ) {
2259: dereferenceInvalidIteratorError (@expr1073752114 dereferenceTok@var3136 , dereferenceTok@var3136 .@expr1073752115 strAt (@expr1073752116 1 ) ) ; }
2260: }
2261: }
2262:
2263:
2264: void CheckStl :: checkDereferenceInvalidIterator2 ( )
2265: {
2266: const bool printInconclusive@var3137 =@expr1073752119 mSettings@var29 .@expr1073752120 certainty@var3298 .@expr1073752121 isEnabled (@expr1073752122 Certainty ::@expr1073752123 inconclusive@expr1073752117 ) ;
2267:
2268: for (@expr1073752124 const Token *@expr1073752125 tok@var3138 =@expr1073752126 mTokenizer@var28 .@expr1073752127 tokens (@expr1073752128 ) ; tok@var3138 ; tok@var3138 =@expr1073752129 tok@var3138 .@expr10306 next (@expr10307 ) ) {
2269: if (@expr1073752132 Token ::@expr10309 Match (@expr1073752134 tok@var3138 , "sizeof|decltype|typeid|typeof (" ) ) {
2270: tok@var3138 =@expr1073752135 tok@var3138 .@expr10306 next (@expr10307 ) .@expr1073752138 link (@expr1073752139 ) ;
2271: continue ;
2272: }
2273:
2274: if (@expr1073752140 Token ::@expr10309 Match (@expr1073752142 tok@var3138 , "%assign%" ) ) {
2275: continue ; }
2276:
2277: std ::@expr1073752143 vector < ValueFlow ::@expr10320 Value > contValues@var3139 ;
2278: std ::@expr1073752145 copy_if (@expr1073752146 tok@var3138 .@expr10323 values (@expr10324 ) .@expr1073752149 begin (@expr1073752150 ) , tok@var3138 .@expr10323 values (@expr10324 ) .@expr1073752153 end (@expr1073752154 ) , std ::@expr1073752155 back_inserter (@expr1073752156 contValues@var3139 ) , [@expr1073752157 &@expr10334 ] (@expr1073752159 const ValueFlow ::@expr10320 Value &@expr10334 value@var3140 ) {
2279: if (@expr1073752162 value@var3140 .@expr1073752163 isImpossible (@expr1073752164 ) ) {
2280: return false ; }
2281: if (@expr1073752165 !@expr10342 printInconclusive@var3137 &&@expr1073752167 value@var3140 .@expr1073752168 isInconclusive (@expr1073752169 ) ) {
2282: return false ; }
2283: return value@var3140 .@expr1073752170 isContainerSizeValue (@expr1073752171 ) ;
2284: } ) ;
2285:
2286:
2287:
2288: for (@expr1073752172 const ValueFlow ::@expr10320 Value &@expr10334 value@var3141 :@expr1073752175 tok@var3138 .@expr10323 values (@expr10324 ) ) {
2289: if (@expr1073752178 value@var3141 .@expr1073752179 isImpossible (@expr1073752180 ) ) {
2290: continue ; }
2291: if (@expr1073752181 !@expr10342 printInconclusive@var3137 &&@expr1073752183 value@var3141 .@expr10360 isInconclusive (@expr10361 ) ) {
2292: continue ; }
2293: if (@expr1073752186 !@expr1073752187 value@var3141 .@expr1073752188 isIteratorValue (@expr1073752189 ) ) {
2294: continue ; }
2295: bool isInvalidIterator@var3142 ; isInvalidIterator@var3142 =@expr1073752190 false ;
2296: const ValueFlow ::@expr1073752191 Value * cValue@var3143 ; cValue@var3143 =@expr1073752192 nullptr ;
2297: if (@expr1073752193 value@var3141 .@expr10370 isIteratorEndValue (@expr10371 ) &&@expr1073752196 value@var3141 .@expr10373 intvalue@var3144 >=@expr1073752198 0 ) {
2298: isInvalidIterator@var3142 =@expr1073752199 value@var3141 .@expr10373 intvalue@var3144 >@expr1073752201 0 ;
2299: } else { if (@expr1073752202 value@var3141 .@expr10379 isIteratorStartValue (@expr10380 ) &&@expr1073752205 value@var3141 .@expr10373 intvalue@var3144 <@expr1073752207 0 ) {
2300: isInvalidIterator@var3142 =@expr1073752208 true ;
2301: } else {
2302: auto it@var3145 ; it@var3145 =@expr1073752209 std ::@expr1073752210 find_if (@expr1073752211 contValues@var3139 .@expr1073752212 begin (@expr1073752213 ) , contValues@var3139 .@expr10390 end (@expr10391 ) , [@expr1073752216 &@expr10334 ] (@expr1073752218 const ValueFlow ::@expr10320 Value &@expr10334 c@var3146 ) {
2303: if (@expr1073752221 value@var3141 .@expr1073752222 path@var3147 !=@expr1073752223 c@var3146 .@expr1073752224 path@var3148 ) {
2304: return false ; }
2305: if (@expr1073752225 value@var3141 .@expr10379 isIteratorStartValue (@expr10380 ) &&@expr1073752228 value@var3141 .@expr10373 intvalue@var3144 >=@expr1073752230 c@var3146 .@expr10407 intvalue@var3149 ) {
2306: return true ; }
2307: if (@expr1073752232 value@var3141 .@expr10370 isIteratorEndValue (@expr10371 ) &&@expr1073752235 -@expr1073752236 value@var3141 .@expr10373 intvalue@var3144 >@expr1073752238 c@var3146 .@expr10407 intvalue@var3149 ) {
2308: return true ; }
2309: return false ;
2310: } ) ;
2311: if (@expr1073752240 it@var3145 ==@expr1073752241 contValues@var3139 .@expr10390 end (@expr10391 ) ) {
2312: continue ; }
2313: cValue@var3143 =@expr1073752244 &@expr1073752245 *@expr1073752246 it@var3145 ;
2314: if (@expr1073752247 value@var3141 .@expr10379 isIteratorStartValue (@expr10380 ) &&@expr1073752250 value@var3141 .@expr10373 intvalue@var3144 >@expr1073752252 cValue@var3143 .@expr10429 intvalue@var3150 ) {
2315: isInvalidIterator@var3142 =@expr1073752254 true ; }
2316: } }
2317: bool inconclusive@var3151 ; inconclusive@var3151 =@expr1073752255 false ;
2318: bool unknown@var3152 ; unknown@var3152 =@expr1073752256 false ;
2319: const Token * emptyAdvance@var3153 ; emptyAdvance@var3153 =@expr1073752257 nullptr ;
2320: const Token * advanceIndex@var3154 ; advanceIndex@var3154 =@expr1073752258 nullptr ;
2321: if (@expr1073752259 cValue@var3143 &&@expr1073752260 cValue@var3143 .@expr10429 intvalue@var3150 ==@expr1073752262 0 ) {
2322: if (@expr1073752263 Token ::@expr10309 Match (@expr1073752265 tok@var3138 .@expr10442 astParent (@expr10443 ) , "+|-" ) &&@expr1073752268 astIsIntegral (@expr1073752269 tok@var3138 .@expr10446 astSibling (@expr10447 ) , false ) ) {
2323: if (@expr1073752272 tok@var3138 .@expr10446 astSibling (@expr10447 ) &&@expr1073752275 tok@var3138 .@expr10446 astSibling (@expr10447 ) .@expr1073752278 hasKnownIntValue (@expr1073752279 ) ) {
2324: if (@expr1073752280 tok@var3138 .@expr10446 astSibling (@expr10447 ) .@expr1073752283 values (@expr1073752284 ) .@expr1073752285 front (@expr1073752286 ) .@expr1073752287 intvalue@expr1073752118 ==@expr1073752288 0 ) {
2325: continue ; }
2326: } else {
2327: advanceIndex@var3154 =@expr1073752289 tok@var3138 .@expr10446 astSibling (@expr10447 ) ;
2328: }
2329: emptyAdvance@var3153 =@expr1073752292 tok@var3138 .@expr10442 astParent (@expr10443 ) ;
2330: } else { if (@expr1073752295 Token ::@expr10309 Match (@expr1073752297 tok@var3138 .@expr10442 astParent (@expr10443 ) , "++|--" ) ) {
2331: emptyAdvance@var3153 =@expr1073752300 tok@var3138 .@expr10442 astParent (@expr10443 ) ;
2332: } }
2333: }
2334: if (@expr1073752303 !@expr1073752304 CheckNullPointer ::@expr1073752305 isPointerDeRef (@expr1073752306 tok@var3138 , unknown@var3152 , mSettings@var29 ) &&@expr1073752307 !@expr1073752308 isInvalidIterator@var3142 &&@expr1073752309 !@expr1073752310 emptyAdvance@var3153 ) {
2335: if (@expr1073752311 !@expr1073752312 unknown@var3152 ) {
2336: continue ; }
2337: inconclusive@var3151 =@expr1073752313 true ;
2338: }
2339: if (@expr1073752314 cValue@var3143 ) {
2340: const ValueFlow ::@expr10320 Value &@expr10334 lValue@var3155 =@expr1073752317 getLifetimeIteratorValue (@expr1073752318 tok@var3138 , cValue@var3143 .@expr1073752319 path@var3156 ) ;
2341: assert (@expr1073752320 cValue@var3143 .@expr1073752321 isInconclusive (@expr1073752322 ) ||@expr1073752323 value@var3141 .@expr10360 isInconclusive (@expr10361 ) ||@expr1073752326 lValue@var3155 .@expr10503 isLifetimeValue (@expr10504 ) ) ;
2342: if (@expr1073752329 !@expr1073752330 lValue@var3155 .@expr10503 isLifetimeValue (@expr10504 ) ) {
2343: continue ; }
2344: if (@expr1073752333 emptyAdvance@var3153 ) {
2345: outOfBoundsError (@expr1073752334 emptyAdvance@var3153 ,
2346: lValue@var3155 .@expr10511 tokvalue@var3157 .@expr10512 expressionString (@expr10513 ) ,
2347: cValue@var3143 ,
2348: advanceIndex@var3154 ?@expr1073752338 advanceIndex@var3154 .@expr1073752339 expressionString (@expr1073752340 ) :@expr1073752341 "" ,
2349: nullptr ) ; }
2350: else {
2351: outOfBoundsError (@expr1073752342 tok@var3138 , lValue@var3155 .@expr10511 tokvalue@var3157 .@expr10512 expressionString (@expr10513 ) , cValue@var3143 , tok@var3138 .@expr1073752346 expressionString (@expr1073752347 ) , &@expr10524 value@var3141 ) ; }
2352: } else {
2353: dereferenceInvalidIteratorError (@expr1073752349 tok@var3138 , &@expr10524 value@var3141 , inconclusive@var3151 ) ;
2354: }
2355: }
2356: }
2357: }
2358:
2359: void CheckStl :: dereferenceInvalidIteratorError ( const Token * tok@var3158 , const ValueFlow :: Value * value@var3159 , bool inconclusive@var3160 )
2360: {
2361: const std ::@expr10527 string &@expr1073752352 varname@var3161 =@expr1073752353 tok@var3158 ?@expr1073752354 tok@var3158 .@expr1073752355 expressionString (@expr1073752356 ) :@expr1073752357 "var" ;
2362: const std ::@expr1073752358 string errmsgcond@var3162 (@expr1073752359 "$symbol:" +@expr10536 varname@var3161 +@expr10537 '\n' +@expr1073752362 ValueFlow ::@expr1073752363 eitherTheConditionIsRedundant (@expr1073752364 value@var3159 ?@expr1073752365 value@var3159 .@expr10542 condition@var3163 :@expr1073752367 nullptr ) +@expr1073752368 " or there is possible dereference of an invalid iterator: $symbol." ) ;
2363: if (@expr1073752369 !@expr1073752370 tok@var3158 ||@expr1073752371 !@expr1073752372 value@var3159 ) {
2364: reportError (@expr1073752373 tok@var3158 , Severity ::@expr10550 error , "derefInvalidIterator" , "Dereference of an invalid iterator" , CWE825@var2569 , Certainty ::@expr10551 normal ) ;
2365: reportError (@expr1073752376 tok@var3158 , Severity ::@expr10553 warning , "derefInvalidIteratorRedundantCheck" , errmsgcond@var3162 , CWE825@var2569 , Certainty ::@expr10551 normal ) ;
2366: return ;
2367: }
2368: if (@expr1073752379 !@expr1073752380 mSettings@var29 .@expr1073752381 isEnabled (@expr1073752382 value@var3159 , inconclusive@var3160 ) ) {
2369: return ; }
2370:
2371: const std ::@expr1073752383 list < std ::@expr10527 pair < const Token *@expr1073752385 , std ::@expr10527 string > > errorPath@var3164 =@expr1073752387 getErrorPath (@expr1073752388 tok@var3158 , value@var3159 , "Dereference of an invalid iterator" ) ;
2372:
2373: if (@expr1073752389 value@var3159 .@expr10542 condition@var3163 ) {
2374: reportError (@expr1073752391 errorPath@var3164 , Severity ::@expr10553 warning , "derefInvalidIteratorRedundantCheck" , errmsgcond@var3162 , CWE825@var2569 , (@expr1073752393 inconclusive@var3160 ||@expr10570 value@var3159 .@expr10571 isInconclusive (@expr10572 ) ) ?@expr10573 Certainty ::@expr10574 inconclusive :@expr10575 Certainty ::@expr10551 normal ) ;
2375: } else {
2376: std ::@expr1073752401 string errmsg@var3165 ;
2377: errmsg@var3165 =@expr1073752402 std ::@expr1073752403 string (@expr1073752404 value@var3159 .@expr10581 isKnown (@expr10582 ) ?@expr1073752407 "Dereference" :@expr1073752408 "Possible dereference" ) +@expr1073752409 " of an invalid iterator" ;
2378: if (@expr1073752410 !@expr1073752411 varname@var3161 .@expr1073752412 empty (@expr1073752413 ) ) {
2379: errmsg@var3165 =@expr1073752414 "$symbol:" +@expr10536 varname@var3161 +@expr10537 '\n' +@expr1073752417 errmsg@var3165 +@expr1073752418 ": $symbol" ; }
2380:
2381: reportError (@expr1073752419 errorPath@var3164 ,
2382: value@var3159 .@expr10581 isKnown (@expr10582 ) ?@expr1073752422 Severity ::@expr10550 error :@expr1073752424 Severity ::@expr10553 warning ,
2383: "derefInvalidIterator" ,
2384: errmsg@var3165 ,
2385: CWE825@var2569 , (@expr1073752426 inconclusive@var3160 ||@expr10570 value@var3159 .@expr10571 isInconclusive (@expr10572 ) ) ?@expr10573 Certainty ::@expr10574 inconclusive :@expr10575 Certainty ::@expr10551 normal ) ;
2386: }
2387: }
2388:
2389: void CheckStl :: dereferenceInvalidIteratorError ( const Token * deref@var3166 , const std :: string & iterName@var3167 )
2390: {
2391: reportError (@expr1073752434 deref@var3166 , Severity ::@expr1073752435 warning ,
2392: "derefInvalidIterator" ,
2393: "$symbol:" +@expr1073752436 iterName@var3167 +@expr1073752437 "\nPossible dereference of an invalid iterator: $symbol\nPossible dereference of an invalid iterator: $symbol. Make sure to check that the iterator is valid before dereferencing it - not after."
2394:
2395: , CWE825@var2569 , Certainty ::@expr1073752438 normal ) ;
2396: }
2397:
2398: void CheckStl :: readingEmptyStlContainerError ( const Token * tok@var3168 , const ValueFlow :: Value * value@var3169 )
2399: {
2400: const std ::@expr10615 string varname@var3170 =@expr1073752440 tok@var3168 ?@expr1073752441 tok@var3168 .@expr1073752442 str (@expr1073752443 ) :@expr1073752444 std ::@expr1073752445 string (@expr1073752446 "var" ) ;
2401:
2402: std ::@expr1073752447 string errmsg@var3171 ;
2403: if (@expr1073752448 value@var3169 &&@expr1073752449 value@var3169 .@expr10626 condition@var3172 ) {
2404: errmsg@var3171 =@expr1073752451 "Reading from container '$symbol'. " +@expr1073752452 ValueFlow ::@expr1073752453 eitherTheConditionIsRedundant (@expr1073752454 value@var3169 .@expr10626 condition@var3172 ) +@expr1073752456 " or '$symbol' can be empty." ; }
2405: else {
2406: errmsg@var3171 =@expr1073752457 "Reading from empty STL container '$symbol'" ; }
2407:
2408: const std ::@expr1073752458 list < std ::@expr10615 pair < const Token *@expr1073752460 , std ::@expr10615 string > > errorPath@var3173 =@expr1073752462 getErrorPath (@expr1073752463 tok@var3168 , value@var3169 , "Reading from empty container" ) ;
2409:
2410: reportError (@expr1073752464 errorPath@var3173 , value@var3169 ?@expr1073752465 (@expr1073752466 value@var3169 .@expr1073752467 errorSeverity (@expr1073752468 ) ?@expr1073752469 Severity ::@expr1073752470 error :@expr1073752471 Severity ::@expr1073752472 warning ) :@expr1073752473 Severity ::@expr1073752474 style , "reademptycontainer" , "$symbol:" +@expr1073752475 varname@var3170 +@expr1073752476 "\n" +@expr1073752477 errmsg@var3171 , CWE398@var2560 , !@expr1073752478 value@var3169 ?@expr1073752479 Certainty ::@expr1073752480 inconclusive :@expr1073752481 Certainty ::@expr1073752482 normal ) ;
2411: }
2412:
2413: void CheckStl :: useStlAlgorithmError ( const Token * tok@var3174 , const std :: string & algoName@var3175 )
2414: {
2415: reportError (@expr1073752483 tok@var3174 , Severity ::@expr1073752484 style , "useStlAlgorithm" ,
2416: "Consider using " +@expr1073752485 algoName@var3175 +@expr1073752486 " algorithm instead of a raw loop." , CWE398@var2560 , Certainty ::@expr1073752487 normal ) ;
2417: }
2418:
2419: static bool isEarlyExit ( const Token * start@var3176 )
2420: {
2421: if (@expr1073752488 start@var3176 .@expr1073752489 str (@expr1073752490 ) !=@expr1073752491 "{" ) {
2422: return false ; }
2423: const Token * endToken@var3177 ; endToken@var3177 =@expr1073752492 start@var3176 .@expr1073752493 link (@expr1073752494 ) ;
2424: const Token * tok@var3178 ; tok@var3178 =@expr1073752495 Token ::@expr1073752496 findmatch (@expr1073752497 start@var3176 , "return|throw|break" , endToken@var3177 ) ;
2425: if (@expr1073752498 !@expr1073752499 tok@var3178 ) {
2426: return false ; }
2427: const Token * endStatement@var3179 ; endStatement@var3179 =@expr1073752500 Token ::@expr1073752501 findsimplematch (@expr1073752502 tok@var3178 , "; }" , endToken@var3177 ) ;
2428: if (@expr1073752503 !@expr1073752504 endStatement@var3179 ) {
2429: return false ; }
2430: if (@expr1073752505 endStatement@var3179 .@expr1073752506 next (@expr1073752507 ) !=@expr1073752508 endToken@var3177 ) {
2431: return false ; }
2432: return true ;
2433: }
2434:
2435: static const Token * singleStatement ( const Token * start@var3180 )
2436: {
2437: if (@expr1073752509 start@var3180 .@expr1073752510 str (@expr1073752511 ) !=@expr1073752512 "{" ) {
2438: return nullptr ; }
2439: const Token * endToken@var3181 ; endToken@var3181 =@expr1073752513 start@var3180 .@expr1073752514 link (@expr1073752515 ) ;
2440: const Token * endStatement@var3182 ; endStatement@var3182 =@expr1073752516 Token ::@expr1073752517 findsimplematch (@expr1073752518 start@var3180 .@expr1073752519 next (@expr1073752520 ) , ";" ) ;
2441: if (@expr1073752521 !@expr1073752522 Token ::@expr1073752523 simpleMatch (@expr1073752524 endStatement@var3182 , "; }" ) ) {
2442: return nullptr ; }
2443: if (@expr1073752525 endStatement@var3182 .@expr1073752526 next (@expr1073752527 ) !=@expr1073752528 endToken@var3181 ) {
2444: return nullptr ; }
2445: return endStatement@var3182 ;
2446: }
2447:
2448: static const Token * singleAssignInScope ( const Token * start@var3183 , int varid@var3184 , bool & input@var3185 )
2449: {
2450: const Token * endStatement@var3186 ; endStatement@var3186 =@expr1073752529 singleStatement (@expr1073752530 start@var3183 ) ;
2451: if (@expr1073752531 !@expr1073752532 endStatement@var3186 ) {
2452: return nullptr ; }
2453: if (@expr1073752533 !@expr1073752534 Token ::@expr10711 Match (@expr1073752536 start@var3183 .@expr10713 next (@expr10714 ) , "%var% %assign%" ) ) {
2454: return nullptr ; }
2455: const Token * assignTok@var3187 ; assignTok@var3187 =@expr1073752539 start@var3183 .@expr1073752540 tokAt (@expr1073752541 2 ) ;
2456: if (@expr1073752542 isVariableChanged (@expr1073752543 assignTok@var3187 .@expr10720 next (@expr10721 ) , endStatement@var3186 , assignTok@var3187 .@expr1073752546 astOperand1 (@expr1073752547 ) .@expr1073752548 varId (@expr1073752549 ) , false , nullptr , true ) ) {
2457: return nullptr ; }
2458: if (@expr1073752550 isVariableChanged (@expr1073752551 assignTok@var3187 .@expr10720 next (@expr10721 ) , endStatement@var3186 , varid@var3184 , false , nullptr , true ) ) {
2459: return nullptr ; }
2460: input@var3185 =@expr1073752554 Token ::@expr1073752555 findmatch (@expr1073752556 assignTok@var3187 .@expr10720 next (@expr10721 ) , "%varid%" , endStatement@var3186 , varid@var3184 ) ||@expr1073752559 !@expr1073752560 Token ::@expr10711 Match (@expr1073752562 start@var3183 .@expr10713 next (@expr10714 ) , "%var% =" ) ;
2461: return assignTok@var3187 ;
2462: }
2463:
2464: static const Token * singleMemberCallInScope ( const Token * start@var3188 , int varid@var3189 , bool & input@var3190 )
2465: {
2466: if (@expr1073752565 start@var3188 .@expr1073752566 str (@expr1073752567 ) !=@expr1073752568 "{" ) {
2467: return nullptr ; }
2468: const Token * endToken@var3191 ; endToken@var3191 =@expr1073752569 start@var3188 .@expr1073752570 link (@expr1073752571 ) ;
2469: if (@expr1073752572 !@expr1073752573 Token ::@expr10750 Match (@expr1073752575 start@var3188 .@expr10752 next (@expr10753 ) , "%var% . %name% (" ) ) {
2470: return nullptr ; }
2471: if (@expr1073752578 !@expr1073752579 Token ::@expr1073752580 simpleMatch (@expr1073752581 start@var3188 .@expr10758 linkAt (@expr10759 4 ) , ") ; }" ) ) {
2472: return nullptr ; }
2473: const Token * endStatement@var3192 ; endStatement@var3192 =@expr1073752584 start@var3188 .@expr10758 linkAt (@expr10759 4 ) .@expr1073752587 next (@expr1073752588 ) ;
2474: if (@expr1073752589 endStatement@var3192 .@expr1073752590 next (@expr1073752591 ) !=@expr1073752592 endToken@var3191 ) {
2475: return nullptr ; }
2476:
2477: const Token * dotTok@var3193 ; dotTok@var3193 =@expr1073752593 start@var3188 .@expr1073752594 tokAt (@expr1073752595 2 ) ;
2478: if (@expr1073752596 !@expr1073752597 Token ::@expr1073752598 findmatch (@expr1073752599 dotTok@var3193 .@expr1073752600 tokAt (@expr1073752601 2 ) , "%varid%" , endStatement@var3192 , varid@var3189 ) ) {
2479: return nullptr ; }
2480: input@var3190 =@expr1073752602 Token ::@expr10750 Match (@expr1073752604 start@var3188 .@expr10752 next (@expr10753 ) , "%var% . %name% ( %varid% )" , varid@var3189 ) ;
2481: if (@expr1073752607 isVariableChanged (@expr1073752608 dotTok@var3193 .@expr1073752609 next (@expr1073752610 ) , endStatement@var3192 , dotTok@var3193 .@expr1073752611 astOperand1 (@expr1073752612 ) .@expr1073752613 varId (@expr1073752614 ) , false , nullptr , true ) ) {
2482: return nullptr ; }
2483: return dotTok@var3193 ;
2484: }
2485:
2486: static const Token * singleIncrementInScope ( const Token * start@var3194 , int varid@var3195 , bool & input@var3196 )
2487: {
2488: if (@expr1073752615 start@var3194 .@expr1073752616 str (@expr1073752617 ) !=@expr1073752618 "{" ) {
2489: return nullptr ; }
2490: const Token * varTok@var3197 ; varTok@var3197 =@expr1073752619 nullptr ;
2491: if (@expr1073752620 Token ::@expr10797 Match (@expr1073752622 start@var3194 .@expr10799 next (@expr10800 ) , "++ %var% ; }" ) ) {
2492: varTok@var3197 =@expr1073752625 start@var3194 .@expr10802 tokAt (@expr1073752627 2 ) ; }
2493: else { if (@expr1073752628 Token ::@expr10797 Match (@expr1073752630 start@var3194 .@expr10799 next (@expr10800 ) , "%var% ++ ; }" ) ) {
2494: varTok@var3197 =@expr1073752633 start@var3194 .@expr10802 tokAt (@expr1073752635 1 ) ; } }
2495: if (@expr1073752636 !@expr1073752637 varTok@var3197 ) {
2496: return nullptr ; }
2497: input@var3196 =@expr1073752638 varTok@var3197 .@expr1073752639 varId (@expr1073752640 ) ==@expr1073752641 varid@var3195 ;
2498: return varTok@var3197 ;
2499: }
2500:
2501: static const Token * singleConditionalInScope ( const Token * start@var3198 , int varid@var3199 )
2502: {
2503: if (@expr1073752642 start@var3198 .@expr1073752643 str (@expr1073752644 ) !=@expr1073752645 "{" ) {
2504: return nullptr ; }
2505: const Token * endToken@var3200 ; endToken@var3200 =@expr1073752646 start@var3198 .@expr1073752647 link (@expr1073752648 ) ;
2506: if (@expr1073752649 !@expr1073752650 Token ::@expr10827 simpleMatch (@expr1073752652 start@var3198 .@expr1073752653 next (@expr1073752654 ) , "if (" ) ) {
2507: return nullptr ; }
2508: if (@expr1073752655 !@expr1073752656 Token ::@expr10827 simpleMatch (@expr1073752658 start@var3198 .@expr10835 linkAt (@expr10836 2 ) , ") {" ) ) {
2509: return nullptr ; }
2510: const Token * bodyTok@var3201 ; bodyTok@var3201 =@expr1073752661 start@var3198 .@expr10835 linkAt (@expr10836 2 ) .@expr1073752664 next (@expr1073752665 ) ;
2511: const Token * endBodyTok@var3202 ; endBodyTok@var3202 =@expr1073752666 bodyTok@var3201 .@expr1073752667 link (@expr1073752668 ) ;
2512: if (@expr1073752669 !@expr1073752670 Token ::@expr10827 simpleMatch (@expr1073752672 endBodyTok@var3202 , "} }" ) ) {
2513: return nullptr ; }
2514: if (@expr1073752673 endBodyTok@var3202 .@expr1073752674 next (@expr1073752675 ) !=@expr1073752676 endToken@var3200 ) {
2515: return nullptr ; }
2516: if (@expr1073752677 !@expr1073752678 Token ::@expr1073752679 findmatch (@expr1073752680 start@var3198 , "%varid%" , bodyTok@var3201 , varid@var3199 ) ) {
2517: return nullptr ; }
2518: if (@expr1073752681 isVariableChanged (@expr1073752682 start@var3198 , bodyTok@var3201 , varid@var3199 , false , nullptr , true ) ) {
2519: return nullptr ; }
2520: return bodyTok@var3201 ;
2521: }
2522:
2523: static bool addByOne ( const Token * tok@var3203 , int varid@var3204 )
2524: {
2525: if (@expr1073752683 Token ::@expr10860 Match (@expr1073752685 tok@var3203 , "+= %any% ;" ) &&@expr1073752686
2526: tok@var3203 .@expr10863 tokAt (@expr10864 1 ) .@expr1073752689 hasKnownIntValue (@expr1073752690 ) &&@expr1073752691
2527: tok@var3203 .@expr10863 tokAt (@expr10864 1 ) .@expr1073752694 getValue (@expr1073752695 1 ) ) {
2528: return true ;
2529: }
2530: if (@expr1073752696 Token ::@expr10860 Match (@expr1073752698 tok@var3203 , "= %varid% + %any% ;" , varid@var3204 ) &&@expr1073752699
2531: tok@var3203 .@expr10863 tokAt (@expr10877 3 ) .@expr1073752702 hasKnownIntValue (@expr1073752703 ) &&@expr1073752704
2532: tok@var3203 .@expr10863 tokAt (@expr10877 3 ) .@expr1073752707 getValue (@expr1073752708 1 ) ) {
2533: return true ;
2534: }
2535: return false ;
2536: }
2537:
2538: static bool accumulateBoolLiteral ( const Token * tok@var3205 , int varid@var3206 )
2539: {
2540: if (@expr1073752709 Token ::@expr10886 Match (@expr1073752711 tok@var3205 , "%assign% %bool% ;" ) &&@expr1073752712
2541: tok@var3205 .@expr10889 tokAt (@expr1073752714 1 ) .@expr1073752715 hasKnownIntValue (@expr1073752716 ) ) {
2542: return true ;
2543: }
2544: if (@expr1073752717 Token ::@expr10886 Match (@expr1073752719 tok@var3205 , "= %varid% %oror%|%or%|&&|& %bool% ;" , varid@var3206 ) &&@expr1073752720
2545: tok@var3205 .@expr10889 tokAt (@expr1073752722 3 ) .@expr1073752723 hasKnownIntValue (@expr1073752724 ) ) {
2546: return true ;
2547: }
2548: return false ;
2549: }
2550:
2551: static bool accumulateBool ( const Token * tok@var3207 , int varid@var3208 )
2552: {
2553:
2554: if (@expr1073752725 Token ::@expr10902 simpleMatch (@expr1073752727 tok@var3207 , "&=" ) ||@expr1073752728 Token ::@expr10902 simpleMatch (@expr1073752730 tok@var3207 , "|=" ) ) {
2555: return true ;
2556: }
2557: if (@expr1073752731 Token ::@expr1073752732 Match (@expr1073752733 tok@var3207 , "= %varid% %oror%|%or%|&&|&" , varid@var3208 ) ) {
2558: return true ;
2559: }
2560: return false ;
2561: }
2562:
2563: static bool hasVarIds ( const Token * tok@var3209 , int var1@var3210 , int var2@var3211 )
2564: {
2565: if (@expr1073752734 tok@var3209 .@expr10911 astOperand1 (@expr10912 ) .@expr10913 varId (@expr10914 ) ==@expr1073752739 tok@var3209 .@expr10916 astOperand2 (@expr10917 ) .@expr10918 varId (@expr10919 ) ) {
2566: return false ; }
2567: if (@expr1073752744 tok@var3209 .@expr10911 astOperand1 (@expr10912 ) .@expr10913 varId (@expr10914 ) ==@expr1073752749 var1@var3210 ||@expr1073752750 tok@var3209 .@expr10911 astOperand1 (@expr10912 ) .@expr10913 varId (@expr10914 ) ==@expr1073752755 var2@var3211 ) {
2568: if (@expr1073752756 tok@var3209 .@expr10916 astOperand2 (@expr10917 ) .@expr10918 varId (@expr10919 ) ==@expr1073752761 var1@var3210 ||@expr1073752762 tok@var3209 .@expr10916 astOperand2 (@expr10917 ) .@expr10918 varId (@expr10919 ) ==@expr1073752767 var2@var3211 ) {
2569: return true ;
2570: }
2571: }
2572: return false ;
2573: }
2574:
2575: static std :: string flipMinMax ( const std :: string & algo@var3212 )
2576: {
2577: if (@expr1073752768 algo@var3212 ==@expr1073752769 "std::max_element" ) {
2578: return "std::min_element" ; }
2579: if (@expr1073752770 algo@var3212 ==@expr1073752771 "std::min_element" ) {
2580: return "std::max_element" ; }
2581: return algo@var3212 ;
2582: }
2583:
2584: static std :: string minmaxCompare ( const Token * condTok@var3213 , int loopVar@var3214 , int assignVar@var3215 , bool invert@var3216 = false )
2585: {
2586: if (@expr1073752772 !@expr1073752773 Token ::@expr10950 Match (@expr1073752775 condTok@var3213 , "<|<=|>=|>" ) ) {
2587: return "std::accumulate" ; }
2588: if (@expr1073752776 !@expr1073752777 hasVarIds (@expr1073752778 condTok@var3213 , loopVar@var3214 , assignVar@var3215 ) ) {
2589: return "std::accumulate" ; }
2590: std ::@expr1073752779 string algo@var3217 ; algo@var3217 =@expr1073752780 "std::max_element" ;
2591: if (@expr1073752781 Token ::@expr10950 Match (@expr1073752783 condTok@var3213 , "<|<=" ) ) {
2592: algo@var3217 =@expr1073752784 "std::min_element" ; }
2593: if (@expr1073752785 condTok@var3213 .@expr1073752786 astOperand1 (@expr1073752787 ) .@expr1073752788 varId (@expr1073752789 ) ==@expr1073752790 assignVar@var3215 ) {
2594: algo@var3217 =@expr1073752791 flipMinMax (@expr10968 algo@var3217 ) ; }
2595: if (@expr1073752793 invert@var3216 ) {
2596: algo@var3217 =@expr1073752794 flipMinMax (@expr10968 algo@var3217 ) ; }
2597: return algo@var3217 ;
2598: }
2599:
2600: void CheckStl :: useStlAlgorithm ( )
2601: {
2602: if (@expr1073752796 !@expr1073752797 mSettings@var29 .@expr1073752798 severity@var3299 .@expr1073752799 isEnabled (@expr1073752800 Severity ::@expr1073752801 style ) ) {
2603: return ; }
2604: for (@expr1073752802 const Scope *@expr10979 function@var3218 :@expr1073752804 mTokenizer@var28 .@expr1073752805 getSymbolDatabase (@expr1073752806 ) .@expr1073752807 functionScopes@var3312 ) {
2605: for (@expr1073752808 const Token *@expr10979 tok@var3219 =@expr1073752810 function@var3218 .@expr1073752811 bodyStart@var3220 ; tok@var3219 !=@expr1073752812 function@var3218 .@expr1073752813 bodyEnd@var3221 ; tok@var3219 =@expr1073752814 tok@var3219 .@expr10991 next (@expr10992 ) ) {
2606:
2607: if (@expr1073752817 !@expr1073752818 Token ::@expr10995 simpleMatch (@expr1073752820 tok@var3219 , "for (" ) ) {
2608: continue ; }
2609: if (@expr1073752821 !@expr1073752822 Token ::@expr10995 simpleMatch (@expr1073752824 tok@var3219 .@expr10991 next (@expr10992 ) .@expr11003 link (@expr11004 ) , ") {" ) ) {
2610: continue ; }
2611: const Token * bodyTok@var3222 ; bodyTok@var3222 =@expr1073752829 tok@var3219 .@expr10991 next (@expr10992 ) .@expr11003 link (@expr11004 ) .@expr1073752834 next (@expr1073752835 ) ;
2612: const Token * splitTok@var3223 ; splitTok@var3223 =@expr1073752836 tok@var3219 .@expr10991 next (@expr10992 ) .@expr1073752839 astOperand2 (@expr1073752840 ) ;
2613: if (@expr1073752841 !@expr1073752842 Token ::@expr10995 simpleMatch (@expr1073752844 splitTok@var3223 , ":" ) ) {
2614: continue ; }
2615: const Token * loopVar@var3224 ; loopVar@var3224 =@expr1073752845 splitTok@var3223 .@expr1073752846 previous (@expr1073752847 ) ;
2616: if (@expr1073752848 !@expr1073752849 Token ::@expr11026 Match (@expr1073752851 loopVar@var3224 , "%var%" ) ) {
2617: continue ; }
2618:
2619:
2620: bool useLoopVarInAssign@var3225 ;
2621: const Token * assignTok@var3226 ; assignTok@var3226 =@expr1073752852 singleAssignInScope (@expr1073752853 bodyTok@var3222 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInAssign@var3225 ) ;
2622: if (@expr11032 assignTok@var3226 ) {
2623: int assignVarId@var3227 ; assignVarId@var3227 =@expr1073752857 assignTok@var3226 .@expr11034 astOperand1 (@expr11035 ) .@expr11036 varId (@expr11037 ) ;
2624: std ::@expr1073752862 string algo@var3228 ;
2625: if (@expr1073752863 assignVarId@var3227 ==@expr1073752864 loopVar@var3224 .@expr11030 varId (@expr11031 ) ) {
2626: if (@expr11043 useLoopVarInAssign@var3225 ) {
2627: algo@var3228 =@expr1073752868 "std::transform" ; }
2628: else { if (@expr1073752869 Token ::@expr11026 Match (@expr1073752871 assignTok@var3226 .@expr11048 next (@expr11049 ) , "%var%|%bool%|%num%|%char% ;" ) ) {
2629: algo@var3228 =@expr1073752874 "std::fill" ; }
2630: else { if (@expr1073752875 Token ::@expr11026 Match (@expr1073752877 assignTok@var3226 .@expr11048 next (@expr11049 ) , "%name% ( )" ) ) {
2631: algo@var3228 =@expr1073752880 "std::generate" ; }
2632: else {
2633: algo@var3228 =@expr1073752881 "std::fill or std::generate" ; } } }
2634: } else {
2635: if (@expr1073752882 addByOne (@expr1073752883 assignTok@var3226 , assignVarId@var3227 ) ) {
2636: algo@var3228 =@expr1073752884 "std::distance" ; }
2637: else { if (@expr1073752885 accumulateBool (@expr1073752886 assignTok@var3226 , assignVarId@var3227 ) ) {
2638: algo@var3228 =@expr1073752887 "std::any_of, std::all_of, std::none_of, or std::accumulate" ; }
2639: else { if (@expr1073752888 Token ::@expr11026 Match (@expr1073752890 assignTok@var3226 , "= %var% <|<=|>=|> %var% ? %var% : %var%" ) &&@expr1073752891 hasVarIds (@expr1073752892 assignTok@var3226 .@expr11069 tokAt (@expr1073752894 6 ) , loopVar@var3224 .@expr11030 varId (@expr11031 ) , assignVarId@var3227 ) ) {
2640: algo@var3228 =@expr1073752897 minmaxCompare (@expr1073752898 assignTok@var3226 .@expr11069 tokAt (@expr1073752900 2 ) , loopVar@var3224 .@expr11030 varId (@expr11031 ) , assignVarId@var3227 , assignTok@var3226 .@expr11069 tokAt (@expr1073752904 5 ) .@expr1073752905 varId (@expr1073752906 ) ==@expr1073752907 assignVarId@var3227 ) ; }
2641: else {
2642: algo@var3228 =@expr1073752908 "std::accumulate" ; } } }
2643: }
2644: useStlAlgorithmError (@expr1073752909 assignTok@var3226 , algo@var3228 ) ;
2645: continue ;
2646: }
2647:
2648: bool useLoopVarInMemCall@var3229 ;
2649: const Token * memberAccessTok@var3230 ; memberAccessTok@var3230 =@expr1073752910 singleMemberCallInScope (@expr1073752911 bodyTok@var3222 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInMemCall@var3229 ) ;
2650: if (@expr11090 memberAccessTok@var3230 ) {
2651: const Token * memberCallTok@var3231 ; memberCallTok@var3231 =@expr1073752915 memberAccessTok@var3230 .@expr11092 astOperand2 (@expr11093 ) ;
2652: const int contVarId@var3232 =@expr1073752918 memberAccessTok@var3230 .@expr11095 astOperand1 (@expr11096 ) .@expr11097 varId (@expr11098 ) ;
2653: if (@expr1073752923 contVarId@var3232 ==@expr1073752924 loopVar@var3224 .@expr11030 varId (@expr11031 ) ) {
2654: continue ; }
2655: if (@expr1073752927 memberCallTok@var3231 .@expr11104 str (@expr11105 ) ==@expr1073752930 "push_back" ||@expr1073752931
2656: memberCallTok@var3231 .@expr11104 str (@expr11105 ) ==@expr1073752934 "push_front" ||@expr1073752935
2657: memberCallTok@var3231 .@expr11104 str (@expr11105 ) ==@expr1073752938 "emplace_back" ) {
2658: std ::@expr1073752939 string algo@var3233 ;
2659: if (@expr11116 useLoopVarInMemCall@var3229 ) {
2660: algo@var3233 =@expr1073752941 "std::copy" ; }
2661: else {
2662: algo@var3233 =@expr1073752942 "std::transform" ; }
2663: useStlAlgorithmError (@expr1073752943 memberCallTok@var3231 , algo@var3233 ) ;
2664: }
2665: continue ;
2666: }
2667:
2668:
2669: bool useLoopVarInIncrement@var3234 ;
2670: const Token * incrementTok@var3235 ; incrementTok@var3235 =@expr1073752944 singleIncrementInScope (@expr1073752945 bodyTok@var3222 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInIncrement@var3234 ) ;
2671: if (@expr11124 incrementTok@var3235 ) {
2672: std ::@expr1073752949 string algo@var3236 ;
2673: if (@expr11126 useLoopVarInIncrement@var3234 ) {
2674: algo@var3236 =@expr1073752951 "std::transform" ; }
2675: else {
2676: algo@var3236 =@expr1073752952 "std::distance" ; }
2677: useStlAlgorithmError (@expr1073752953 incrementTok@var3235 , algo@var3236 ) ;
2678: continue ;
2679: }
2680:
2681:
2682: const Token * condBodyTok@var3237 ; condBodyTok@var3237 =@expr1073752954 singleConditionalInScope (@expr1073752955 bodyTok@var3222 , loopVar@var3224 .@expr11030 varId (@expr11031 ) ) ;
2683: if (@expr1073752958 condBodyTok@var3237 ) {
2684:
2685: assignTok@var3226 =@expr1073752959 singleAssignInScope (@expr1073752960 condBodyTok@var3237 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInAssign@var3225 ) ;
2686: if (@expr11032 assignTok@var3226 ) {
2687: const int assignVarId@var3238 =@expr1073752964 assignTok@var3226 .@expr11034 astOperand1 (@expr11035 ) .@expr11036 varId (@expr11037 ) ;
2688: std ::@expr1073752969 string algo@var3239 ;
2689: if (@expr1073752970 assignVarId@var3238 ==@expr1073752971 loopVar@var3224 .@expr11030 varId (@expr11031 ) ) {
2690: if (@expr11043 useLoopVarInAssign@var3225 ) {
2691: algo@var3239 =@expr1073752975 "std::transform" ; }
2692: else {
2693: algo@var3239 =@expr1073752976 "std::replace_if" ; }
2694: } else {
2695: if (@expr1073752977 addByOne (@expr1073752978 assignTok@var3226 , assignVarId@var3238 ) ) {
2696: algo@var3239 =@expr1073752979 "std::count_if" ; }
2697: else { if (@expr1073752980 accumulateBoolLiteral (@expr1073752981 assignTok@var3226 , assignVarId@var3238 ) ) {
2698: algo@var3239 =@expr1073752982 "std::any_of, std::all_of, std::none_of, or std::accumulate" ; }
2699: else {
2700: algo@var3239 =@expr1073752983 "std::accumulate" ; } }
2701: }
2702: useStlAlgorithmError (@expr1073752984 assignTok@var3226 , algo@var3239 ) ;
2703: continue ;
2704: }
2705:
2706:
2707: memberAccessTok@var3230 =@expr1073752985 singleMemberCallInScope (@expr1073752986 condBodyTok@var3237 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInMemCall@var3229 ) ;
2708: if (@expr11090 memberAccessTok@var3230 ) {
2709: const Token * memberCallTok@var3240 ; memberCallTok@var3240 =@expr1073752990 memberAccessTok@var3230 .@expr11092 astOperand2 (@expr11093 ) ;
2710: const int contVarId@var3241 =@expr1073752993 memberAccessTok@var3230 .@expr11095 astOperand1 (@expr11096 ) .@expr11097 varId (@expr11098 ) ;
2711: if (@expr1073752998 contVarId@var3241 ==@expr1073752999 loopVar@var3224 .@expr11030 varId (@expr11031 ) ) {
2712: continue ; }
2713: if (@expr1073753002 memberCallTok@var3240 .@expr11179 str (@expr11180 ) ==@expr1073753005 "push_back" ||@expr1073753006
2714: memberCallTok@var3240 .@expr11179 str (@expr11180 ) ==@expr1073753009 "push_front" ||@expr1073753010
2715: memberCallTok@var3240 .@expr11179 str (@expr11180 ) ==@expr1073753013 "emplace_back" ) {
2716: if (@expr11116 useLoopVarInMemCall@var3229 ) {
2717: useStlAlgorithmError (@expr1073753015 memberAccessTok@var3230 , "std::copy_if" ) ; }
2718:
2719: }
2720: continue ;
2721: }
2722:
2723:
2724: incrementTok@var3235 =@expr1073753016 singleIncrementInScope (@expr1073753017 condBodyTok@var3237 , loopVar@var3224 .@expr11030 varId (@expr11031 ) , useLoopVarInIncrement@var3234 ) ;
2725: if (@expr11124 incrementTok@var3235 ) {
2726: std ::@expr1073753021 string algo@var3242 ;
2727: if (@expr11126 useLoopVarInIncrement@var3234 ) {
2728: algo@var3242 =@expr1073753023 "std::transform" ; }
2729: else {
2730: algo@var3242 =@expr1073753024 "std::count_if" ; }
2731: useStlAlgorithmError (@expr1073753025 incrementTok@var3235 , algo@var3242 ) ;
2732: continue ;
2733: }
2734:
2735:
2736: if (@expr1073753026 isEarlyExit (@expr1073753027 condBodyTok@var3237 ) ) {
2737: const Token * loopVar2@var3243 ; loopVar2@var3243 =@expr1073753028 Token ::@expr1073753029 findmatch (@expr1073753030 condBodyTok@var3237 , "%varid%" , condBodyTok@var3237 .@expr1073753031 link (@expr1073753032 ) , loopVar@var3224 .@expr11030 varId (@expr11031 ) ) ;
2738: std ::@expr1073753035 string algo@var3244 ;
2739: if (@expr1073753036 loopVar2@var3243 ) {
2740: algo@var3244 =@expr1073753037 "std::find_if" ; }
2741: else {
2742: algo@var3244 =@expr1073753038 "std::any_of" ; }
2743: useStlAlgorithmError (@expr1073753039 condBodyTok@var3237 , algo@var3244 ) ;
2744: continue ;
2745: }
2746: }
2747: }
2748: }
2749: }
2750:
2751: void CheckStl :: knownEmptyContainerError ( const Token * tok@var3245 , const std :: string & algo@var3246 )
2752: {
2753: const std ::@expr1073753040 string var@var3247 =@expr1073753041 tok@var3245 ?@expr1073753042 tok@var3245 .@expr1073753043 expressionString (@expr1073753044 ) :@expr1073753045 std ::@expr1073753046 string (@expr1073753047 "var" ) ;
2754:
2755: std ::@expr1073753048 string msg@var3248 ;
2756: if (@expr1073753049 astIsIterator (@expr1073753050 tok@var3245 ) ) {
2757: msg@var3248 =@expr1073753051 "Using " +@expr1073753052 algo@var3246 +@expr1073753053 " with iterator '" +@expr1073753054 var@var3247 +@expr1073753055 "' that is always empty." ;
2758: } else {
2759: msg@var3248 =@expr1073753056 "Iterating over container '" +@expr1073753057 var@var3247 +@expr1073753058 "' that is always empty." ;
2760: }
2761:
2762: reportError (@expr1073753059 tok@var3245 , Severity ::@expr1073753060 style ,
2763: "knownEmptyContainer" ,
2764: msg@var3248 , CWE398@var2560 , Certainty ::@expr1073753061 normal ) ;
2765: }
2766:
2767: static bool isKnownEmptyContainer ( const Token * tok@var3249 )
2768: {
2769: if (@expr1073753062 !@expr1073753063 tok@var3249 ) {
2770: return false ; }
2771: for (@expr1073753064 const ValueFlow ::@expr1073753065 Value &@expr1073753066 v@var3250 :@expr1073753067 tok@var3249 .@expr1073753068 values (@expr1073753069 ) ) {
2772: if (@expr1073753070 !@expr1073753071 v@var3250 .@expr1073753072 isKnown (@expr1073753073 ) ) {
2773: continue ; }
2774: if (@expr1073753074 !@expr1073753075 v@var3250 .@expr1073753076 isContainerSizeValue (@expr1073753077 ) ) {
2775: continue ; }
2776: if (@expr1073753078 v@var3250 .@expr1073753079 intvalue@var3251 !=@expr1073753080 0 ) {
2777: continue ; }
2778: return true ;
2779: }
2780: return false ;
2781: }
2782:
2783: void CheckStl :: knownEmptyContainer ( )
2784: {
2785: if (@expr1073753081 !@expr1073753082 mSettings@var29 .@expr1073753083 severity@var3299 .@expr1073753084 isEnabled (@expr1073753085 Severity ::@expr1073753086 style ) ) {
2786: return ; }
2787: for (@expr1073753087 const Scope *@expr11264 function@var3252 :@expr1073753089 mTokenizer@var28 .@expr1073753090 getSymbolDatabase (@expr1073753091 ) .@expr1073753092 functionScopes@var3312 ) {
2788: for (@expr1073753093 const Token *@expr11264 tok@var3253 =@expr1073753095 function@var3252 .@expr1073753096 bodyStart@var3254 ; tok@var3253 !=@expr1073753097 function@var3252 .@expr1073753098 bodyEnd@var3255 ; tok@var3253 =@expr1073753099 tok@var3253 .@expr11276 next (@expr11277 ) ) {
2789:
2790: if (@expr1073753102 !@expr1073753103 Token ::@expr1073753104 Match (@expr1073753105 tok@var3253 , "%name% ( !!)" ) ) {
2791: continue ; }
2792:
2793:
2794: if (@expr1073753106 tok@var3253 .@expr11283 str (@expr11284 ) ==@expr1073753109 "for" ) {
2795: if (@expr1073753110 !@expr1073753111 Token ::@expr11288 simpleMatch (@expr1073753113 tok@var3253 .@expr11276 next (@expr11277 ) .@expr1073753116 link (@expr1073753117 ) , ") {" ) ) {
2796: continue ; }
2797: const Token * splitTok@var3256 ; splitTok@var3256 =@expr1073753118 tok@var3253 .@expr11276 next (@expr11277 ) .@expr1073753121 astOperand2 (@expr1073753122 ) ;
2798: if (@expr1073753123 !@expr1073753124 Token ::@expr11288 simpleMatch (@expr1073753126 splitTok@var3256 , ":" ) ) {
2799: continue ; }
2800: const Token * contTok@var3257 ; contTok@var3257 =@expr1073753127 splitTok@var3256 .@expr1073753128 astOperand2 (@expr1073753129 ) ;
2801: if (@expr1073753130 !@expr1073753131 isKnownEmptyContainer (@expr1073753132 contTok@var3257 ) ) {
2802: continue ; }
2803: knownEmptyContainerError (@expr1073753133 contTok@var3257 , "" ) ;
2804: } else {
2805: const std ::@expr1073753134 vector < const Token *@expr11264 > args@var3258 =@expr1073753136 getArguments (@expr1073753137 tok@var3253 ) ;
2806: if (@expr1073753138 args@var3258 .@expr1073753139 empty (@expr1073753140 ) ) {
2807: continue ; }
2808:
2809: for (@expr1073753141 int argnr@var3259 =@expr1073753142 1 ; argnr@var3259 <=@expr1073753143 args@var3258 .@expr1073753144 size (@expr1073753145 ) ; ++@expr1073753146 argnr@var3259 ) {
2810: const Library ::@expr1073753147 ArgumentChecks ::@expr1073753148 IteratorInfo * i@var3260 ; i@var3260 =@expr1073753149 mSettings@var29 .@expr1073753150 library@var3300 .@expr1073753151 getArgIteratorInfo (@expr1073753152 tok@var3253 , argnr@var3259 ) ;
2811: if (@expr1073753153 !@expr1073753154 i@var3260 ) {
2812: continue ; }
2813: const Token * const argTok@var3261 ; argTok@var3261 =@expr1073753155 args@var3258 [@expr1073753156 argnr@var3259 -@expr1073753157 1 ] ;
2814: if (@expr1073753158 !@expr1073753159 isKnownEmptyContainer (@expr1073753160 argTok@var3261 ) ) {
2815: continue ; }
2816: knownEmptyContainerError (@expr1073753161 argTok@var3261 , tok@var3253 .@expr11283 str (@expr11284 ) ) ;
2817: break ;
2818:
2819: }
2820: }
2821: }
2822: }
2823: }
2824:
2825: static bool isMutex ( const Variable * var@var3262 )
2826: {
2827: const Token * tok@var3263 ; tok@var3263 =@expr1073753165 Token ::@expr1073753166 typeDecl (@expr1073753167 var@var3262 .@expr1073753168 nameToken (@expr1073753169 ) ) .@expr1073753170 first@expr1073753164 ;
2828: return Token ::@expr1073753171 Match (@expr1073753172 tok@var3263 , "std :: mutex|recursive_mutex|timed_mutex|recursive_timed_mutex|shared_mutex" ) ;
2829: }
2830:
2831: static bool isLockGuard ( const Variable * var@var3264 )
2832: {
2833: const Token * tok@var3265 ; tok@var3265 =@expr1073753174 Token ::@expr1073753175 typeDecl (@expr1073753176 var@var3264 .@expr1073753177 nameToken (@expr1073753178 ) ) .@expr1073753179 first@expr1073753173 ;
2834: return Token ::@expr1073753180 Match (@expr1073753181 tok@var3265 , "std :: lock_guard|unique_lock|scoped_lock|shared_lock" ) ;
2835: }
2836:
2837: static bool isLocalMutex ( const Variable * var@var3266 , const Scope * scope@var3267 )
2838: {
2839: if (@expr1073753182 !@expr1073753183 var@var3266 ) {
2840: return false ; }
2841: if (@expr1073753184 isLockGuard (@expr1073753185 var@var3266 ) ) {
2842: return false ; }
2843: return !@expr1073753186 var@var3266 .@expr1073753187 isReference (@expr1073753188 ) &&@expr1073753189 !@expr1073753190 var@var3266 .@expr1073753191 isRValueReference (@expr1073753192 ) &&@expr1073753193 !@expr1073753194 var@var3266 .@expr1073753195 isStatic (@expr1073753196 ) &&@expr1073753197 var@var3266 .@expr1073753198 scope (@expr1073753199 ) ==@expr1073753200 scope@var3267 ;
2844: }
2845:
2846: void CheckStl :: globalLockGuardError ( const Token * tok@var3268 )
2847: {
2848: reportError (@expr1073753201 tok@var3268 , Severity ::@expr1073753202 warning ,
2849: "globalLockGuard" ,
2850: "Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program." , CWE833@var2570 , Certainty ::@expr1073753203 normal ) ;
2851: }
2852:
2853: void CheckStl :: localMutexError ( const Token * tok@var3269 )
2854: {
2855: reportError (@expr1073753204 tok@var3269 , Severity ::@expr1073753205 warning ,
2856: "localMutex" ,
2857: "The lock is ineffective because the mutex is locked at the same scope as the mutex itself." , CWE667@var2564 , Certainty ::@expr1073753206 normal ) ;
2858: }
2859:
2860: void CheckStl :: checkMutexes ( )
2861: {
2862: if (@expr1073753209 !@expr1073753210 mSettings@var29 .@expr1073753211 severity@var3299 .@expr1073753212 isEnabled (@expr1073753213 Severity ::@expr1073753214 warning ) ) {
2863: return ; }
2864:
2865: for (@expr1073753215 const Scope *@expr11392 function@var3270 :@expr1073753217 mTokenizer@var28 .@expr1073753218 getSymbolDatabase (@expr1073753219 ) .@expr1073753220 functionScopes@var3312 ) {
2866: std ::@expr1073753221 set < int > checkedVars@var3271 ;
2867: for (@expr1073753222 const Token *@expr11392 tok@var3272 =@expr1073753224 function@var3270 .@expr1073753225 bodyStart@var3273 ; tok@var3272 !=@expr1073753226 function@var3270 .@expr1073753227 bodyEnd@var3274 ; tok@var3272 =@expr1073753228 tok@var3272 .@expr1073753229 next (@expr1073753230 ) ) {
2868: if (@expr1073753231 !@expr1073753232 Token ::@expr11409 Match (@expr1073753234 tok@var3272 , "%var%" ) ) {
2869: continue ; }
2870: const Variable * var@var3275 ; var@var3275 =@expr1073753235 tok@var3272 .@expr1073753236 variable (@expr1073753237 ) ;
2871: if (@expr1073753238 !@expr1073753239 var@var3275 ) {
2872: continue ; }
2873: if (@expr1073753240 Token ::@expr11409 Match (@expr1073753242 tok@var3272 , "%var% . lock ( )" ) ) {
2874: if (@expr1073753243 !@expr1073753244 isMutex (@expr1073753245 var@var3275 ) ) {
2875: continue ; }
2876: if (@expr1073753246 !@expr1073753247 checkedVars@var3271 .@expr11424 insert (@expr1073753249 var@var3275 .@expr1073753250 declarationId (@expr1073753251 ) ) .@expr1073753252 second@expr1073753207 ) {
2877: continue ; }
2878: if (@expr1073753253 isLocalMutex (@expr1073753254 var@var3275 , tok@var3272 .@expr11431 scope (@expr11432 ) ) ) {
2879: localMutexError (@expr11433 tok@var3272 ) ; }
2880: } else { if (@expr1073753258 Token ::@expr11409 Match (@expr1073753260 tok@var3272 , "%var% (|{ %var% )|}|," ) ) {
2881: if (@expr1073753261 !@expr1073753262 isLockGuard (@expr1073753263 var@var3275 ) ) {
2882: continue ; }
2883: const Variable * mvar@var3276 ; mvar@var3276 =@expr1073753264 tok@var3272 .@expr1073753265 tokAt (@expr1073753266 2 ) .@expr1073753267 variable (@expr1073753268 ) ;
2884: if (@expr1073753269 !@expr1073753270 mvar@var3276 ) {
2885: continue ; }
2886: if (@expr1073753271 !@expr1073753272 checkedVars@var3271 .@expr11424 insert (@expr1073753274 mvar@var3276 .@expr1073753275 declarationId (@expr1073753276 ) ) .@expr1073753277 second@expr1073753208 ) {
2887: continue ; }
2888: if (@expr1073753278 var@var3275 .@expr1073753279 isStatic (@expr1073753280 ) ||@expr1073753281 var@var3275 .@expr1073753282 isGlobal (@expr1073753283 ) ) {
2889: globalLockGuardError (@expr1073753284 tok@var3272 ) ; }
2890: else { if (@expr1073753285 isLocalMutex (@expr1073753286 mvar@var3276 , tok@var3272 .@expr11431 scope (@expr11432 ) ) ) {
2891: localMutexError (@expr11433 tok@var3272 ) ; } }
2892: } }
2893: }
2894: }
2895: }

##file cppcheck-2.8/lib/settings.h

21:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var3277 ; mFlags@var3277 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3277 ;
54: }
55: void clear ( ) {
56: mFlags@var3277 =@expr1073753290 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3277 =@expr1073753291 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3278 ) {
62: if (@expr1073753292 enabled@var3278 ) {
63: fill (@expr1073753293 ) ; }
64: else {
65: clear (@expr1073753294 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var3279 ) const {
68: return (@expr11471 mFlags@var3277 &@expr1073753296 (@expr11471 1U <<@expr1073753298 (@expr1073753299 uint32_t ) flag@var3279 ) ) !=@expr1073753300 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var3280 ) {
71: mFlags@var3277 |=@expr1073753301 (@expr1073753302 1U <<@expr1073753303 (@expr1073753304 uint32_t ) flag@var3280 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var3281 ) {
74: mFlags@var3277 &=@expr1073753305 ~@expr1073753306 (@expr1073753307 1U <<@expr1073753308 (@expr1073753309 uint32_t ) flag@var3281 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var3282 , bool enabled@var3283 ) {
77: if (@expr1073753310 enabled@var3283 ) {
78: enable (@expr1073753311 flag@var3282 ) ; }
79: else {
80: disable (@expr1073753312 flag@var3282 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var3284 ; mFlags@var3284 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3284 ;
54: }
55: void clear ( ) {
56: mFlags@var3284 =@expr1073753313 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3284 =@expr1073753314 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3285 ) {
62: if (@expr1073753315 enabled@var3285 ) {
63: fill (@expr1073753316 ) ; }
64: else {
65: clear (@expr1073753317 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var3286 ) const {
68: return (@expr11494 mFlags@var3284 &@expr1073753319 (@expr11494 1U <<@expr1073753321 (@expr1073753322 uint32_t ) flag@var3286 ) ) !=@expr1073753323 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var3287 ) {
71: mFlags@var3284 |=@expr1073753324 (@expr1073753325 1U <<@expr1073753326 (@expr1073753327 uint32_t ) flag@var3287 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var3288 ) {
74: mFlags@var3284 &=@expr1073753328 ~@expr1073753329 (@expr1073753330 1U <<@expr1073753331 (@expr1073753332 uint32_t ) flag@var3288 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var3289 , bool enabled@var3290 ) {
77: if (@expr1073753333 enabled@var3290 ) {
78: enable (@expr1073753334 flag@var3289 ) ; }
79: else {
80: disable (@expr1073753335 flag@var3289 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var3291 ; mFlags@var3291 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var3291 ;
54: }
55: void clear ( ) {
56: mFlags@var3291 =@expr1073753336 0 ;
57: }
58: void fill ( ) {
59: mFlags@var3291 =@expr1073753337 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var3292 ) {
62: if (@expr1073753338 enabled@var3292 ) {
63: fill (@expr1073753339 ) ; }
64: else {
65: clear (@expr1073753340 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var3293 ) const {
68: return (@expr11517 mFlags@var3291 &@expr1073753342 (@expr11517 1U <<@expr1073753344 (@expr1073753345 uint32_t ) flag@var3293 ) ) !=@expr1073753346 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var3294 ) {
71: mFlags@var3291 |=@expr1073753347 (@expr1073753348 1U <<@expr1073753349 (@expr1073753350 uint32_t ) flag@var3294 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var3295 ) {
74: mFlags@var3291 &=@expr1073753351 ~@expr1073753352 (@expr1073753353 1U <<@expr1073753354 (@expr1073753355 uint32_t ) flag@var3295 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var3296 , bool enabled@var3297 ) {
77: if (@expr1073753356 enabled@var3297 ) {
78: enable (@expr1073753357 flag@var3296 ) ; }
79: else {
80: disable (@expr1073753358 flag@var3296 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  severity possible 1@41
  id possible "stlcstrthrow"@41
  msg possible "Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception.\nDangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid."@41
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
  tok possible {0@194,symbolic=(tok->astParent()->astOperand2())@191}
Line 141
  callstack always size=1
  severity possible {2@31,3@60,1@40,4@255}
  id {"localMutex"@31,"globalLockGuard"@32,"knownEmptyContainer"@60,"derefInvalidIterator"@193,"derefInvalidIterator"@194,"derefInvalidIteratorRedundantCheck"@195,"uselessCallsRemove"@253,"uselessCallsEmpty"@254,"uselessCallsSubstr"@255,"uselessCallsSubstr"}
  msg {"The lock is ineffective because the mutex is locked at the same scope as the mutex itself."@31,"Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program."@32,symbolic=("Iterating over container '"+var+"' that is always empty.")@60,"Dereference of an invalid iterator"@194,"Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?"@254,"Ineffective call of function 'substr' because it returns an empty string."@255,"Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead.","Returning the result of c_str() in a function that returns std::string is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string."@39,"Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.\nDangerous usage of c_str(). The c_str() return value is only valid until its string is deleted."@40,"Redundant checking of STL container element existence before removing it.\nRedundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element."@137}
  certainty possible 0@31
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@56,128@57,64@58,32@59,16@60,8@61,4@62,2@63,1@64}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@65,128@66,64@67,32@68,16@69,8@70,4@71,2@72,1@73}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@65,4294967167@66,4294967231@67,4294967263@68,4294967279@69,4294967287@70,4294967291@71,4294967293@72,4294967294@73}
  flag {!<=-1,256@65,128@66,64@67,32@68,16@69,8@70,4@71,2@72,1@73}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@54582,34@54838}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@213,34@214}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@213,""@214,""@215,"U"@216,"U"@217,"u"@218,"u"@219,"u8"@220,"u8"@221}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@51,34@52}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@48,34@50}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible 2@242
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->next()->astOperand2())@49,symbolic=(tok->next()->astOperand2())@73,symbolic=(bodyTok->link())@156,symbolic=(Token::findsimplematch(start->next(),";"))@184,symbolic=(tok->next())@83,symbolic=(startTok->astTop())@223,symbolic=(scope.classDef)@143,symbolic=(tok->next()->astOperand2())@235,symbolic=(variableInfo?variableInfo->typeStartToken():nullptr)@98,0@98}
  pattern possible {") {"@44,":"@49,"for ("@64,") {"@65,":"@73,"&="@147,"|="@148,"if ("@151,") {"@153,"} }"@156}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@202,4@203,0@204}
  t possible {10@202,4@203,0@204}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@202,4@203,0@204}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@202,0@204}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@202,0@204}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@202}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@202}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@202}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@202}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@202}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible "*"@56
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@210}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  pattern possible {";"@182,";"@246,";"@143}
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible {"; }"@188,";"@244,";"@246,"||"@248,"&&"@249,"<"@43}
  1 always 1
  end inconclusive {symbolic=(start->link())@188,symbolic=(startOfCondition->link())@244}
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@212,17179869184@223,8589934592@225,34359738368@227,4294967296@229,2147483648@231,1073741824@233,536870912@235,268435456@237}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@43,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@44}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@211,17179869184@222,8589934592@224,34359738368@226,4294967296@228,2147483648@230,1073741824@232,536870912@234,268435456@236}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@211,17179869184@222,8589934592@224,34359738368@226,4294967296@228,2147483648@230,1073741824@232,536870912@234,268435456@236}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 48
  ( always "STL usage"
Line 52
  ( always "STL usage"
Line 56
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 189
  ( always {!<=-1,!>=2}
Line 227
  , always 0
  = always 0
  nullptr always 0
Line 238
  nullptr always 0
Line 239
  nullptr always 0
  "container" always "container"
  nullptr always 0
  "x" always "x"
  nullptr always 0
Line 240
  nullptr always 0
  "iterator" always "iterator"
Line 241
  nullptr always 0
  "container1" always "container1"
  "container2" always "container2"
Line 242
  nullptr always 0
  nullptr always 0
  "container0" always "container0"
  "container1" always "container1"
Line 243
  nullptr always 0
  nullptr always 0
  "container" always "container"
Line 244
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 245
  nullptr always 0
  nullptr always 0
  nullptr always 0
  errorPath always size=0
Line 246
  nullptr always 0
  nullptr always 0
Line 247
  nullptr always 0
  nullptr always 0
Line 248
  nullptr always 0
  nullptr always 0
Line 249
  nullptr always 0
Line 250
  nullptr always 0
  nullptr always 0
  "iter" always "iter"
  false always 0
Line 251
  nullptr always 0
  "i" always "i"
  "foo" always "foo"
  false always 0
Line 252
  nullptr always 0
  -1 always -1
Line 253
  nullptr always 0
Line 254
  nullptr always 0
  false always 0
Line 255
  nullptr always 0
  true always 1
Line 256
  nullptr always 0
Line 257
  nullptr always 0
Line 258
  nullptr always 0
Line 259
  nullptr always 0
  0 always 0
Line 260
  nullptr always 0
Line 261
  nullptr always 0
Line 262
  nullptr always 0
  nullptr always 0
Line 263
  nullptr always 0
Line 264
  nullptr always 0
  "str" always "str"
  "find" always "find"
Line 265
  nullptr always 0
  "str" always "str"
Line 266
  nullptr always 0
  false always 0
Line 267
  nullptr always 0
Line 268
  nullptr always 0
  "remove" always "remove"
Line 269
  nullptr always 0
  "i" always "i"
Line 270
  nullptr always 0
Line 271
  nullptr always 0
  "" always ""
Line 272
  nullptr always 0
  "" always ""
Line 273
  nullptr always 0
Line 274
  nullptr always 0
Line 278
  "STL usage" always "STL usage"
Line 282
  "Check for invalid usage of STL:\n- out of bounds errors\n- misuse of iterators when iterating through a container\n- mismatching containers in calls\n- same iterators in calls\n- dereferencing an erased iterator\n- for vectors: using iterator/pointer after push_back has been used\n- optimisation: use empty() instead of size() to guarantee fast code\n- suspicious condition when using find\n- unnecessary searching in associative containers\n- redundant condition\n- common mistakes when using string::c_str()\n- useless calls of string and STL functions\n- dereferencing an invalid iterator\n- reading from empty STL container\n- iterating over an empty STL container\n- consider using an STL algorithm instead of raw loop\n- incorrect locking with mutex\n" always "Check for invalid usage of STL:\n- out of bounds errors\n- misuse of iterators when iterating through a container\n- mismatching containers in calls\n- same iterators in calls\n- dereferencing an erased iterator\n- for vectors: using iterator/pointer after push_back has been used\n- optimisation: use empty() instead of size() to guarantee fast code\n- suspicious condition when using find\n- unnecessary searching in associative containers\n- redundant condition\n- common mistakes when using string::c_str()\n- useless calls of string and STL functions\n- dereferencing an invalid iterator\n- reading from empty STL container\n- iterating over an empty STL container\n- consider using an STL algorithm instead of raw loop\n- incorrect locking with mutex\n"
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 413
  ftok possible symbolic=(tok)@26
  argnr possible {<=symbolic=(args.size())@53,1@53,<=symbolic=(args.size())@26}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@78,4096@81,16384@84,2048@85,1024@86,65536@87,512@88,256@89,128@90}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  stlType possible "list"@176
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@43,4194304@45,8388608@46,2097152@48,1048576@49,524288@50,262144@51,131072@52,65536@53}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@21,2097152@22,1048576@23,524288@24,262144@25,131072@26,65536@27,32768@28,16384@29}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@21,4292870143@22,4293918719@23,4294443007@24,4294705151@25,4294836223@26,4294901759@27,4294934527@28,4294950911@29}
  flag {!<=-1,8388608@21,2097152@22,1048576@23,524288@24,262144@25,131072@26,65536@27,32768@28,16384@29}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible lifetime[Lambda]=(conds)@148
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 34
  Continue always 0
Line 35
  Break always 1
Line 38
  & {lifetime[Address]=(library),!0}
Line 46
  known always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 53
  [ possible lifetime[Lambda]=(pred)
Line 54
  pred possible {lifetime[Lambda]=(skipVarIds)@205,lifetime[Lambda]=(tok)@205}
Line 56
  :: always 1
  Break always 1
Line 58
  :: always 0
  Continue always 0
Line 69
  known always {!<=-1,!>=2}
Line 79
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 54
  null always 0
  uninit always 1
  bufferOverflow always 2
Line 63
  { always 0
Line 64
  { always 0
Line 71
  { always 0
Line 74
  { always 0
Line 87
  { always 0
Line 92
  ( always {!<=-1,!>=2}
Line 101
  warning always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 122
  { always 0
Line 136
  warning always {!<=-1,!>=2}
Line 148
  ( always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
Line 52
  ( always "Null pointer"
Line 56
  ( always "Null pointer"
Line 85
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 96
  0 always 0
Line 98
  "" always ""
  & {lifetime[Address]=(v),!0}
  false always 0
Line 100
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 123
  nullptr always 0
Line 124
  nullptr always 0
  "pointer" always "pointer"
  nullptr always 0
  false always 0
Line 125
  nullptr always 0
  nullptr always 0
  false always 0
Line 126
  nullptr always 0
  nullptr always 0
  nullptr always 0
  false always 0
Line 131
  "Null pointer" always "Null pointer"
Line 136
  "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n" always "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
Line 149
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 150
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 57
  398U always 398
Line 58
  597U always 597
Line 59
  628U always 628
Line 60
  664U always 664
Line 61
  667U always 667
Line 62
  704U always 704
Line 63
  762U always 762
Line 64
  786U always 786
Line 65
  788U always 788
Line 66
  825U always 825
Line 67
  833U always 833
Line 68
  834U always 834
Line 70
  ( always {!<=-1,!>=2}
Line 72
  return always {!<=-1,!>=2}
  :: always 1
  ITEM always 1
  :: always 0
  AT_INDEX always 0
Line 75
  ( always {!<=-1,!>=2}
Line 77
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 78
  1 always 1
Line 79
  :: always 5
  INSERT always 5
Line 80
  :: always 8
  CHANGE always 8
Line 81
  :: always 9
  CHANGE_INTERNAL always 9
Line 82
  :: always 2
  PUSH always 2
Line 83
  :: always 0
  RESIZE always 0
Line 85
  return always {!<=-1,!>=2}
  true always 1
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 90
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 93
  1 always 1
Line 94
  ( always {!<=-1,!>=2}
Line 95
  return always {!<=-1,!>=2}
  true always 1
Line 97
  return always {!<=-1,!>=2}
  false always 0
Line 102
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 103
  1 always 1
Line 104
  == always {!<=-1,!>=2}
  :: always 0
  AT_INDEX always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "( )" always "( )"
Line 105
  2 always 2
Line 107
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 108
  nullptr always 0
Line 109
  ( always {!<=-1,!>=2}
  "[" always "["
Line 111
  nullptr always 0
Line 116
  ! always {!<=-1,!>=2}
  tok possible symbolic=(v.tokvalue)@247
Line 117
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  ". %name% (" always ". %name% ("
Line 119
  tok always !0
  -1 always -1
Line 120
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 121
  tok always !0
  -2 always -2
Line 123
  nullptr always 0
Line 129
  != always {!<=-1,!>=2}
Line 131
  ! always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
  accessTok always symbolic=(parent)
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  accessTok always symbolic=(parent)
  "(" always "("
Line 136
  accessTok always symbolic=(parent)
Line 137
  ( always {!<=-1,!>=2}
  accessTok possible symbolic=(parent)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "+" always "+"
Line 139
  container always !0
Line 140
  indexTok possible 0
  == always {!<=-1,!>=2}
Line 142
  tok always !symbolic=(indexTok)
Line 143
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 145
  ( always {!<=-1,!>=2}
Line 147
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 151
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 152
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 154
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  indexTok always !0
  ( always {!<=-1,!>=2}
Line 155
  indexTok always !0
Line 156
  & always !0
  indexExpr possible symbolic=(indexTok->expressionString())
  nullptr always 0
Line 161
  indexTok always !0
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 162
  ! {!<=-1,!>=2,0}
  indexValues possible size=0
  ( {!<=-1,!>=2,1}
Line 164
  & always !0
  indexTok always !0
  & {lifetime[Object]=(indexValues),!0}
  indexValues always !size=0
Line 169
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  indexTok always !0
  ( always {!<=-1,!>=2}
Line 171
  indexTok always !0
  [ possible lifetime[Lambda]=(container)
Line 172
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 173
  false always 0
Line 174
  ( always {!<=-1,!>=2}
Line 175
  false always 0
Line 176
  < always {!<=-1,!>=2}
  0 always 0
Line 177
  false always 0
Line 179
  sizeTok always symbolic=(v.tokvalue)
  && always {!<=-1,!>=2}
  sizeTok {symbolic=(v.tokvalue),!0}
  ( always {!<=-1,!>=2}
Line 180
  sizeTok {symbolic=(v.tokvalue),!0}
Line 181
  sizeTok possible symbolic=(v.tokvalue)
Line 182
  ! always {!<=-1,!>=2}
Line 183
  false always 0
Line 184
  containerTok always !0
  == always {!<=-1,!>=2}
Line 186
  ! always {!<=-1,!>=2}
Line 188
  nullptr always 0
  indexTok always !0
  value always !0
Line 194
  , always ""
  = always ""
  "" always ""
Line 196
  ( always {!<=-1,!>=2}
Line 197
  "at position " always "at position "
  " from the beginning" always " from the beginning"
Line 198
  ( always {!<=-1,!>=2}
Line 199
  "at position " always "at position "
  " from the end" always " from the end"
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ".size()" always ".size()"
Line 203
  != always {!<=-1,!>=2}
  0 always 0
Line 204
  "+" always "+"
  . always !0
Line 206
  == always {!<=-1,!>=2}
  :: always 1
  Lower always 1
Line 207
  "greater or equal to " always "greater or equal to "
Line 214
  containerSize possible 0
  && always {!<=-1,!>=2}
  indexValue possible lifetime[Object]=(indexValues)@241
  && always {!<=-1,!>=2}
  containerSize always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  indexValue {!0,lifetime[Object]=(indexValues)@241}
  ( always {!<=-1,!>=2}
Line 217
  tok possible 0@121
  tok always !0
  containerName possible "container"@121
  "[x]" always "[x]"
Line 220
  ! {!<=-1,!>=2,1@250}
  containerSize possible 0@250
Line 221
  indexValue possible 0@121
  && always {!<=-1,!>=2}
  indexValue always !0
Line 222
  indexValue always !0
  . always !0
  " or '" always " or '"
Line 223
  "' can have the value " always "' can have the value "
  indexValue always !0
  ". Expression '" always ". Expression '"
Line 224
  "' cause access out of bounds." always "' cause access out of bounds."
Line 226
  "Out of bounds access in expression '" always "Out of bounds access in expression '"
  expression always symbolic=(tok?tok->expressionString():(containerName+"[x]"))
  "'" always "'"
Line 227
  containerSize always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 228
  containerSize always !0
Line 229
  containerSize always !0
  . always !0
  " or expression '" always " or expression '"
  "' cause access out of bounds." always "' cause access out of bounds."
Line 230
  == always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 231
  "Out of bounds access in expression '" always "Out of bounds access in expression '"
  expression always symbolic=(tok?tok->expressionString():(containerName+"[x]"))
  "' because '$symbol' is empty and '" always "' because '$symbol' is empty and '"
  index always !size=0
  "' may be non-zero." always "' may be non-zero."
Line 233
  "Out of bounds access in expression '" always "Out of bounds access in expression '"
  expression always symbolic=(tok?tok->expressionString():(containerName+"[x]"))
  "' because '$symbol' is empty." always "' because '$symbol' is empty."
Line 235
  containerSize always !0
Line 236
  containerSize always !0
  . always !0
  " or $symbol size can be " always " or $symbol size can be "
  containerSize always !0
  . always !0
  ". Expression '" always ". Expression '"
  "' cause access out of bounds." always "' cause access out of bounds."
Line 237
  indexValue always !0
Line 238
  indexValue always !0
  . always !0
  " or '" always " or '"
  "' can have the value " always "' can have the value "
  indexValue always !0
  ". Expression '" always ". Expression '"
  "' cause access out of bounds." always "' cause access out of bounds."
Line 240
  "Out of bounds access in '" always "Out of bounds access in '"
  expression always symbolic=(tok?tok->expressionString():(containerName+"[x]"))
  "', if '$symbol' size is " always "', if '$symbol' size is "
  containerSize always !0
  . always !0
  " and '" always " and '"
  "' is " always "' is "
  indexValue always !0
Line 247
  ! {!<=-1,!>=2,1}
  indexValue possible 0
Line 248
  tok possible 0@121
  containerSize possible 0@250
  "Access out of bounds" always "Access out of bounds"
Line 250
  containerSize possible 0@250
  "Access out of bounds" always "Access out of bounds"
Line 251
  indexValue always !0
  "Access out of bounds" always "Access out of bounds"
Line 252
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1 always 1
Line 254
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1 always 1
Line 255
  = always !<=size=1
  errorPath1 always !<=size=1
Line 257
  = always !<=size=1
  errorPath1 always !<=size=1
Line 258
  errorPath {symbolic=(errorPath1),!<=size=1}
  ( {lifetime[Iterator]=(errorPath),end=0}
  errorPath2 {!<=size=1,>=size=2}
Line 262
  errorPath possible {symbolic=(errorPath2),symbolic=(errorPath1)}
Line 263
  containerSize possible 0@250
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  containerSize always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  indexValue possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  indexValue always !0
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
  : always 1
  :: always 1
  error always 1
Line 264
  "containerOutOfBounds" always "containerOutOfBounds"
Line 265
  "$symbol:" always "$symbol:"
  "\n" always "\n"
Line 267
  && always {!<=-1,!>=2}
  containerSize always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  indexValue always !0
  ( always {!<=-1,!>=2}
  : always 0
  :: always 0
  normal always 0
Line 270
  ( always {!<=-1,!>=2}
Line 272
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "( )" always "( )"
Line 273
  return always {!<=-1,!>=2}
  false always 0
Line 274
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 275
  return always {!<=-1,!>=2}
  false always 0
Line 276
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  false always 0
  false always 0
Line 277
  return always {!<=-1,!>=2}
  false always 0
Line 278
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 281
  ( always {!<=-1,!>=2}
Line 283
  ! always {!<=-1,!>=2}
Line 284
  return always {!<=-1,!>=2}
  false always 0
Line 285
  ( always {!<=-1,!>=2}
  expr always !0
Line 286
  return always {!<=-1,!>=2}
  true always 1
Line 287
  expr always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 289
  ( always {!<=-1,!>=2}
  expr always !0
Line 290
  expr always !0
Line 291
  ( always {!<=-1,!>=2}
  expr always !0
Line 292
  expr always !0
Line 294
  return always {!<=-1,!>=2}
  false always 0
Line 295
  return always {!<=-1,!>=2}
  mul possible {symbolic=(expr->astOperand2()),symbolic=(expr->astOperand1())}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mul always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  mul always !0
  != always {!<=-1,!>=2}
  0 always 0
Line 297
  == always {!<=-1,!>=2}
  "+" always "+"
Line 299
  ( always {!<=-1,!>=2}
Line 301
  ( always {!<=-1,!>=2}
Line 304
  return always {!<=-1,!>=2}
  false always 0
Line 305
  return always {!<=-1,!>=2}
  op possible {symbolic=(expr->astOperand2()),symbolic=(expr->astOperand1())}
  && always {!<=-1,!>=2}
  op always !0
  0 always 0
Line 307
  return always {!<=-1,!>=2}
  false always 0
Line 313
  != always {!<=-1,!>=2}
Line 314
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 316
  ( always !0
Line 317
  ! always {!<=-1,!>=2}
  container always symbolic=(tok->valueType()->container)
Line 319
  ! always {!<=-1,!>=2}
  container {symbolic=(tok->valueType()->container),!0}
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  container {symbolic=(tok->valueType()->container),!0}
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 321
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
Line 323
  ( always {!<=-1,!>=2}
Line 331
  tok always !0
  "var" always "var"
Line 332
  index always !0
  ".size()" always ".size()"
Line 334
  "Out of bounds access of $symbol, index '" always "Out of bounds access of $symbol, index '"
  "' is out of bounds." always "' is out of bounds."
Line 337
  :: always 1
  error always 1
Line 338
  "containerOutOfBoundsIndexExpression" always "containerOutOfBoundsIndexExpression"
Line 339
  "$symbol:" always "$symbol:"
  "\n" always "\n"
  errmsg always symbolic=("Out of bounds access of $symbol, index '"+i+"' is out of bounds.")
Line 341
  :: always 0
  normal always 0
Line 349
  tok possible 0@122
  :: always 1
  error always 1
  "invalidIterator1" always "invalidIterator1"
  "$symbol:" always "$symbol:"
  iteratorName possible "iterator"@122
  "\nInvalid iterator: $symbol" always "\nInvalid iterator: $symbol"
  :: always 0
  normal always 0
Line 354
  :: always 1
  error always 1
  "iterators1" always "iterators1"
Line 355
  "$symbol:" always "$symbol:"
  "\n$symbol:" always "\n$symbol:"
Line 356
  "\nSame iterator is used with different containers '" always "\nSame iterator is used with different containers '"
Line 357
  "' and '" always "' and '"
  "'." always "'."
  :: always 0
  normal always 0
Line 362
  tok possible 0@123
  containerTok inconclusive 0@123
Line 363
  callstack always {{,size=2}
  :: always 1
  error always 1
  "iterators2" always "iterators2"
Line 364
  "$symbol:" always "$symbol:"
  containerName1 inconclusive "container0"@123
  "\n$symbol:" always "\n$symbol:"
Line 365
  containerName2 inconclusive "container1"@123
  "\nSame iterator is used with different containers '" always "\nSame iterator is used with different containers '"
Line 366
  containerName1 inconclusive "container0"@123
  "' and '" always "' and '"
  containerName2 inconclusive "container1"@123
  "'." always "'."
  :: always 0
  normal always 0
Line 372
  callstack always {{,size=2}
Line 373
  :: always 1
  error always 1
Line 374
  "iterators3" always "iterators3"
Line 375
  "$symbol:" always "$symbol:"
Line 376
  "\nSame iterator is used with containers '$symbol' that are temporaries or defined in different scopes." always "\nSame iterator is used with containers '$symbol' that are temporaries or defined in different scopes."
Line 379
  :: always 0
  normal always 0
Line 383
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 385
  erased possible 0@130
Line 386
  erased always !0
Line 387
  callstack always {{,size=2}
  :: always 1
  error always 1
  "eraseDereference" always "eraseDereference"
Line 388
  "$symbol:" always "$symbol:"
  "\nIterator '$symbol' used after element has been erased.\nThe iterator '$symbol' is invalid after the element it pointed to has been erased. Dereferencing or comparing it with another iterator is invalid operation." always "\nIterator '$symbol' used after element has been erased.\nThe iterator '$symbol' is invalid after the element it pointed to has been erased. Dereferencing or comparing it with another iterator is invalid operation."
Line 391
  inconclusive always {!<=-1,!>=2}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 393
  deref possible 0@130
  :: always 1
  error always 1
  "eraseDereference" always "eraseDereference"
Line 394
  "$symbol:" always "$symbol:"
  itername inconclusive "iter"@130
  "\nInvalid iterator '$symbol' used.\nThe iterator '$symbol' is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation." always "\nInvalid iterator '$symbol' used.\nThe iterator '$symbol' is invalid before being assigned. Dereferencing or comparing it with another iterator is invalid operation."
Line 397
  inconclusive {!<=-1,!>=2,0@130}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 403
  ( always {!<=-1,!>=2}
  "%name% ." always "%name% ."
Line 404
  2 always 2
Line 408
  ( always {!<=-1,!>=2}
  inconclusiveType always {!<=-1,!>=2}
Line 411
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
  "iterator|const_iterator|reverse_iterator|const_reverse_iterator|auto" always "iterator|const_iterator|reverse_iterator|const_reverse_iterator|auto"
Line 412
  return always {!<=-1,!>=2}
  false always 0
Line 414
  inconclusiveType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 415
  var always !0
  == always {!<=-1,!>=2}
  "auto" always "auto"
Line 416
  return always {!<=-1,!>=2}
  var always !0
  && always {!<=-1,!>=2}
  var always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 418
  var always !0
Line 420
  var always !0
  ( always !0
  "operator*" always "operator*"
Line 421
  var always !0
  ( always !0
  "operator++" always "operator++"
Line 422
  ! always {!<=-1,!>=2}
  end always symbolic=(var->type()->getFunction("operator*"))
  || always {!<=-1,!>=2}
  end {symbolic=(var->type()->getFunction("operator*")),!0}
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  incOperator always symbolic=(var->type()->getFunction("operator++"))
Line 423
  return always {!<=-1,!>=2}
  false always 0
Line 425
  inconclusiveType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 429
  return always {!<=-1,!>=2}
  true always 1
Line 434
  ! {!<=-1,!>=2,1@121}
  containerToken possible 0@121
Line 436
  containerToken always !0
Line 437
  = always !0
  containerToken always !0
  -2 always -2
Line 438
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ." always "%name% ."
Line 440
  -2 always -2
  '.' always 46
Line 446
  Left always 0
Line 447
  Right always 1
Line 450
  ( always {!<=-1,!>=2}
Line 452
  ! always {!<=-1,!>=2}
Line 453
  return always {!<=-1,!>=2}
  false always 0
Line 454
  tok always !0
Line 455
  = possible 0
  var always symbolic=(tok->variable())
  ? possible 0
  var {symbolic=(tok->variable()),!0}
  : always 0
  nullptr always 0
Line 456
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  decltok {symbolic=(var?var->typeStartToken():nullptr),0}
  "std :: vector" always "std :: vector"
Line 465
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 466
  inconclusiveType always {!<=-1,!>=2}
  inconclusiveType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 467
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  inconclusiveType always 0
Line 470
  iteratorId always symbolic=(var->declarationId())
  != always {!<=-1,!>=2}
  0 always 0
Line 471
  iteratorId {symbolic=(var->declarationId()),!0}
Line 475
  inconclusiveType always {!<=-1,!>=2}
  inconclusiveType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 476
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  inconclusiveType always 0
Line 478
  inconclusiveType always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 484
  validIterator always {!<=-1,!>=2}
  validIterator always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(=:{]" always "[(=:{]"
Line 485
  = always 0
  nullptr always 0
Line 488
  = always 0
  nullptr always 0
Line 489
  = always 0
  nullptr always 0
Line 492
  = always 0
  nullptr always 0
Line 494
  = always 0
  nullptr always 0
Line 498
  && always {!<=-1,!>=2}
  tok2 always !0
  != always {!<=-1,!>=2}
  tok2 possible {symbolic=(itTok->next()),symbolic=(validatingToken->link())}
Line 499
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  invalidationScope always !0
Line 500
  validIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 501
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  containerAssignScope always !0
Line 502
  = always 0
  nullptr always 0
Line 504
  tok2 possible symbolic=(containerAssignScope->bodyEnd)
  == always {!<=-1,!>=2}
Line 505
  validIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 506
  = always 0
  nullptr always 0
Line 507
  = always 0
  nullptr always 0
Line 511
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(validatingToken)
  "%name% . insert|erase ( *| %varid% )|," always "%name% . insert|erase ( *| %varid% )|,"
  iteratorId always symbolic=(var->declarationId())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 512
  4 always 4
Line 513
  == always {!<=-1,!>=2}
  "*" always "*"
Line 514
  2 always 2
  == always {!<=-1,!>=2}
  "insert" always "insert"
Line 520
  ! always {!<=-1,!>=2}
  validIterator always {!<=-1,!>=2}
Line 525
  containerToken possible 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  containerToken always !0
Line 528
  = possible 0
  variableInfo always symbolic=(tok2->variable())
  ? possible 0
  variableInfo {symbolic=(tok2->variable()),!0}
  : always 0
  nullptr always 0
Line 530
  ( always {!<=-1,!>=2}
  decltok {symbolic=(variableInfo?variableInfo->typeStartToken():nullptr),0}
  "std :: set" always "std :: set"
Line 534
  == always {!<=-1,!>=2}
  "*" always "*"
Line 538
  2 always 2
  == always {!<=-1,!>=2}
  "insert" always "insert"
Line 540
  ! always {!<=-1,!>=2}
  par2 always symbolic=(itTok->nextArgument())
  || always {!<=-1,!>=2}
  par2 {symbolic=(itTok->nextArgument()),!0}
Line 542
  par2 possible symbolic=(itTok->nextArgument())
  != always {!<=-1,!>=2}
  ")" always ")"
Line 543
  == always {!<=-1,!>=2}
Line 545
  inconclusiveType2 always {!<=-1,!>=2}
  inconclusiveType2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 546
  ( always {!<=-1,!>=2}
  inconclusiveType2 always 0
Line 548
  == always {!<=-1,!>=2}
  "(" always "("
Line 552
  ( possible size=1
  != always {!<=-1,!>=2}
  ")" always ")"
Line 557
  && always {!<=-1,!>=2}
  containerToken always !0
  && always {!<=-1,!>=2}
  containerToken always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 558
  containerToken always !0
  ( always !0
Line 559
  ( always {!<=-1,!>=2}
  nameToken always symbolic=(containerToken->variable()->nameToken())
  "%name% =" always "%name% ="
Line 560
  nameToken always symbolic=(containerToken->variable()->nameToken())
  2 always 2
Line 562
  ( always {!<=-1,!>=2}
  "%name%|.|::" always "%name%|.|::"
  && always {!<=-1,!>=2}
  name2 possible symbolic=(tok2)
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  name2 {symbolic=(tok2),!0}
Line 564
  name2 always !0
Line 566
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;,()=]" always "[;,()=]"
Line 572
  containerToken possible 0
Line 576
  2 always 2
  == always {!<=-1,!>=2}
  "erase" always "erase"
  && always {!<=-1,!>=2}
  4 always 4
  != always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  containerToken always !0
Line 577
  validIterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 579
  tok2 always symbolic=(eraseToken)
Line 588
  ( always {!<=-1,!>=2}
  "%varid% = %name% ." always "%varid% = %name% ."
  iteratorId always symbolic=(var->declarationId())
  && always {!<=-1,!>=2}
Line 589
  ( always {!<=-1,!>=2}
  2 always 2
  "erase (" always "erase ("
Line 591
  2 always 2
  1 always 1
Line 596
  ( always {!<=-1,!>=2}
  "%varid% = %name% ." always "%varid% = %name% ."
  iteratorId always symbolic=(var->declarationId())
  && always {!<=-1,!>=2}
Line 597
  ( always {!<=-1,!>=2}
  2 always 2
  "begin|rbegin|cbegin|crbegin|find (" always "begin|rbegin|cbegin|crbegin|find ("
Line 598
  2 always 2
  1 always 1
Line 599
  2 always 2
  -2 always -2
Line 600
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") ." always ") ."
Line 601
  = always 0
  nullptr always 0
Line 609
  ( always {!<=-1,!>=2}
  "%varid% =" always "%varid% ="
  iteratorId always symbolic=(var->declarationId())
Line 614
  ( always {!<=-1,!>=2}
  "%varid% ,|)" always "%varid% ,|)"
  iteratorId always symbolic=(var->declarationId())
Line 615
  validIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 619
  ! {!<=-1,!>=2,1}
  validIterator {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "* %varid%" always "* %varid%"
  iteratorId always symbolic=(var->declarationId())
Line 620
  1 always 1
  inconclusiveType always {!<=-1,!>=2}
Line 622
  ! always {!<=-1,!>=2}
  validIterator always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% . %name%" always "%varid% . %name%"
  iteratorId always symbolic=(var->declarationId())
Line 623
  inconclusiveType always {!<=-1,!>=2}
Line 624
  2 always 2
Line 629
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|break|continue" always "return|break|continue"
Line 630
  ";" always ";"
Line 635
  == always {!<=-1,!>=2}
  "else" always "else"
Line 636
  validIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 644
  tok possible 0@126
  tok always !0
  "v1" always "v1"
Line 645
  iterTok possible 0@126
  iterTok always !0
  "it" always "it"
Line 646
  tok possible 0@126
Line 647
  :: always 1
  error always 1
Line 648
  "mismatchingContainerIterator" always "mismatchingContainerIterator"
Line 649
  "Iterator '" always "Iterator '"
  "' from different container '" always "' from different container '"
  "' are used together." always "' are used together."
Line 651
  :: always 0
  normal always 0
Line 657
  tok1 possible 0@127
  tok1 always !0
  "v1" always "v1"
Line 658
  tok2 possible 0@127
  tok2 always !0
  "v2" always "v2"
Line 659
  tok1 possible 0@127
Line 660
  :: always 1
  error always 1
Line 661
  "mismatchingContainers" always "mismatchingContainers"
Line 662
  "Iterators of different containers '" always "Iterators of different containers '"
  "' and '" always "' and '"
  "' are used together." always "' are used together."
Line 664
  :: always 0
  normal always 0
Line 669
  tok1 possible 0@128
  tok1 always !0
  "v1" always "v1"
Line 670
  tok2 possible 0@128
  tok2 always !0
  "v2" always "v2"
Line 671
  tok1 possible 0@128
  :: always 2
  warning always 2
  "mismatchingContainerExpression" always "mismatchingContainerExpression"
Line 672
  "Iterators to containers from different expressions '" always "Iterators to containers from different expressions '"
Line 673
  "' and '" always "' and '"
  "' are used together." always "' are used together."
  :: always 0
  normal always 0
Line 678
  tok possible 0@129
  :: always 3
  style always 3
  "sameIteratorExpression" always "sameIteratorExpression"
  "Same iterators expression are used for algorithm." always "Same iterators expression are used for algorithm."
  :: always 0
  normal always 0
Line 683
  ! always {!<=-1,!>=2}
Line 684
  nullptr always 0
Line 685
  tok always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 686
  nullptr always 0
Line 687
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 688
  tok always !0
Line 690
  iter1 always !0
Line 691
  == always {!<=-1,!>=2}
  "(" always "("
Line 692
  nullptr always 0
Line 695
  iter2 always !0
Line 696
  ( always {!<=-1,!>=2}
  tok always !0
  "begin|cbegin|rbegin|crbegin|end|cend|rend|crend (" always "begin|cbegin|rbegin|crbegin|end|cend|rend|crend ("
Line 697
  ( always {!<=-1,!>=2}
  tok always !0
  ". %name% ( ) !!." always ". %name% ( ) !!."
Line 698
  tok always !0
Line 699
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ( !!)" always "%name% ( !!)"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  ") ." always ") ."
Line 702
  nullptr always 0
Line 707
  ( always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
Line 708
  ( always !0
Line 712
  ( always {!<=-1,!>=2}
Line 717
  ( always {!<=-1,!>=2}
  true always 1
  false always 0
  false always 0
  false always 0
Line 718
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  & {lifetime[Address]=(library),!0}
Line 719
  return always {!<=-1,!>=2}
  false always 0
Line 720
  return always {!<=-1,!>=2}
  true always 1
Line 722
  == always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 723
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  true always 1
  false always 0
  ( inconclusive lifetime[Object]=(tok1)
  ( inconclusive lifetime[Object]=(tok2)
  false always 0
  false always 0
Line 725
  return always {!<=-1,!>=2}
  false always 0
Line 728
  , always 0
  = always 0
  0 always 0
Line 730
  tok possible symbolic=(args.front())@17
  false always 0
  path possible 0
Line 731
  = possible lifetime[Iterator]=(values)
  ( possible lifetime[Iterator]=(values)
  ( {lifetime[Iterator]=(values),start=0}
  ( {lifetime[Iterator]=(values),end=0}
Line 732
  == always {!<=-1,!>=2}
Line 734
  it possible lifetime[Iterator]=(values)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(values),end=0}
Line 735
  it {lifetime[Iterator]=(values),!symbolic=(values.end()),!end=0}
Line 736
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 737
  values always size=1
Line 741
  ( always {!<=-1,!>=2}
Line 743
  ! always {!<=-1,!>=2}
Line 744
  return always {!<=-1,!>=2}
  false always 0
Line 745
  ! always {!<=-1,!>=2}
Line 746
  return always {!<=-1,!>=2}
  false always 0
Line 747
  tok1 always !0
Line 748
  tok2 always !0
Line 749
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 750
  . {4,symbolic=(val2.lifetimeKind)}
  == {!<=-1,!>=2,0}
  :: always 2
  Lambda always 2
Line 751
  return always {!<=-1,!>=2}
  false always 0
Line 752
  == always {!<=-1,!>=2}
  tok2 always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always symbolic=(tok2->astParent())
  "%comp%|-" always "%comp%|-"
Line 753
  . {!2,symbolic=(val2.lifetimeKind)}
  == always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 754
  return always {!<=-1,!>=2}
  false always 0
Line 755
  . always {!2,!4}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 756
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 757
  return always {!<=-1,!>=2}
  false always 0
Line 759
  ( always {!<=-1,!>=2}
  . always !0
  . always !0
  . {!2,symbolic=(val2.lifetimeKind)}
Line 760
  return always {!<=-1,!>=2}
  false always 0
Line 761
  == always {!<=-1,!>=2}
Line 765
  return always {!<=-1,!>=2}
  true always 1
Line 768
  ( always {!<=-1,!>=2}
  "%comp%|-" always "%comp%|-"
Line 769
  ( always {!<=-1,!>=2}
  false always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  false always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  || always {!<=-1,!>=2}
Line 770
  ( always {!<=-1,!>=2}
  tok2 always !0
  false always 0
Line 771
  return always {!<=-1,!>=2}
  false always 0
Line 774
  tok2 always !0
Line 775
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  iter1 always !0
  iter2 always !0
Line 776
  iter1 always !0
  iter2 always !0
Line 777
  return always {!<=-1,!>=2}
  true always 1
Line 779
  return always {!<=-1,!>=2}
  false always 0
Line 791
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 792
  != always {!<=-1,!>=2}
Line 793
  ( always {!<=-1,!>=2}
  "%comp%|-" always "%comp%|-"
Line 794
  ( always {!<=-1,!>=2}
Line 797
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ( !!)" always "%name% ( !!)"
Line 801
  ftok always symbolic=(tok)
Line 802
  ( always !<=-1
  < always {!<=-1,!>=2}
  2 always 2
Line 807
  = always 1
  1 always 1
  argnr possible 1
  <= {!<=-1,!>=2,>=1}
  args {!<=size=1,>=size=2}
  ( {!<=1,>=2}
Line 808
  ftok always symbolic=(tok)
  argnr {<=symbolic=(args.size()),!>=symbolic=(args.size()+1),1}
Line 809
  ! always {!<=-1,!>=2}
Line 811
  args always !<=size=1
  argnr possible 1
  - possible 0
  1 always 1
Line 812
  i always !0
  argTok always symbolic=(args[argnr-1])
  i always !0
Line 816
  [ possible lifetime[Lambda]=(if(iter1.info->first&&iter2.info->last&&isSameExpression(true,false,iter1.tok,iter2.tok,mSettings->library,false,false)))
Line 822
  == always {!<=-1,!>=2}
Line 824
  . always {!<=-1,!>=2}
  first always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  last always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 825
  ( always {!<=-1,!>=2}
  true always 1
  false always 0
  . always !symbolic=(iter2.tok)
  . always !symbolic=(iter1.tok)
  false always 0
  false always 0
Line 826
  . always !symbolic=(iter2.tok)
Line 827
  ( always {!<=-1,!>=2}
  . always !symbolic=(iter2.tok)
  . always !symbolic=(iter1.tok)
Line 836
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
  "%var% (" always "%var% ("
  && always {!<=-1,!>=2}
Line 837
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% . begin|cbegin|rbegin|crbegin ( ) , %name% . end|cend|rend|crend ( ) ,|)" always "%name% . begin|cbegin|rbegin|crbegin ( ) , %name% . end|cend|rend|crend ( ) ,|)"
Line 838
  var always !0
  2 always 2
  != always {!<=-1,!>=2}
  var always !0
  8 always 8
Line 839
  var always !0
  var always !0
  2 always 2
Line 849
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 850
  != always {!<=-1,!>=2}
Line 851
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 853
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 855
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% ( !!)" always ". %name% ( !!)"
Line 858
  args possible size=2
  ftok always symbolic=(tok->astParent()->next())
Line 861
  c always symbolic=(tok->valueType()->container)
  2 always 2
Line 862
  = always 0
  nullptr always 0
Line 863
  action possible 6
  == {!<=-1,!>=2,0}
  :: always 5
  INSERT always 5
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
Line 865
  ( always {!<=-1,!>=2}
  args always size=2
Line 867
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 870
  == always {!<=-1,!>=2}
  :: always 6
  ERASE always 6
Line 871
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 878
  iterTok possible symbolic=(args.front())
Line 879
  ! always {!<=-1,!>=2}
Line 881
  != always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
  . always !0
Line 892
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 893
  nullptr always 0
Line 894
  ( always {!<=-1,!>=2}
  ". assign|clear|swap" always ". assign|clear|swap"
Line 896
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 898
  = always 0
  nullptr always 0
Line 899
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
Line 901
  ! {!<=-1,!>=2,1}
  ftok possible {symbolic=(tok->astParent()->next()),0}
Line 902
  nullptr always 0
Line 904
  c always !0
  ftok always !0
Line 905
  c always !0
  . always {!<=-1,!>=2}
  unstableErase always {!<=-1,!>=2}
Line 906
  action always symbolic=(c->getAction(ftok->str()))
  == always {!<=-1,!>=2}
  :: always 6
  ERASE always 6
Line 907
  ftok always !0
Line 909
  c always !0
  . always {!<=-1,!>=2}
  unstableInsert always {!<=-1,!>=2}
Line 910
  action {symbolic=(c->getAction(ftok->str())),1,2,3,5,8,9}
  == {!<=-1,!>=2,0}
  :: always 0
  RESIZE always 0
Line 911
  ftok always !0
Line 912
  action {symbolic=(c->getAction(ftok->str())),2,3,5,8,9,!0}
  == {!<=-1,!>=2,0}
  :: always 1
  CLEAR always 1
Line 913
  ftok always !0
Line 914
  action {3,5,8,9,!0,!1}
  == {!<=-1,!>=2,0}
  :: always 2
  PUSH always 2
Line 916
  action {5,8,9,!1,!2}
  == {!<=-1,!>=2,0}
  :: always 3
  POP always 3
Line 918
  action {8,9,!2,!3}
  == {!<=-1,!>=2,0}
  :: always 5
  INSERT always 5
Line 920
  action {9,!3,!5}
  == {!<=-1,!>=2,0}
  :: always 8
  CHANGE always 8
Line 922
  action always {!5,!8}
  == always {!<=-1,!>=2}
  :: always 9
  CHANGE_INTERNAL always 9
Line 924
  ( always {!<=-1,!>=2}
  "insert|emplace" always "insert|emplace"
Line 928
  nullptr always 0
Line 946
  ! always {!<=-1,!>=2}
Line 948
  expressions possible lifetime[Object]=(r)
  ( possible lifetime[Object]=(r)
  . always !0
Line 953
  ( {lifetime[Iterator]=(expressions),start=0}
  ( {lifetime[Iterator]=(expressions),end=0}
  ( possible lifetime[Object]=(result)
  result always size=0
Line 961
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 963
  ! always {!<=-1,!>=2}
  f always symbolic=(tok->function())
Line 965
  = possible lifetime[Object]=(tok)
  ( possible lifetime[Object]=(tok)
  "Calling function " always "Calling function "
Line 966
  dependsOnThis always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 967
  = possible lifetime[Iterator]=(invalidMethods)
  ( possible lifetime[Iterator]=(invalidMethods)
  f always !0
Line 968
  it {lifetime[Iterator]=(invalidMethods),symbolic=(invalidMethods.find(f))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(invalidMethods),end=0}
Line 969
  it {lifetime[Iterator]=(invalidMethods),symbolic=(invalidMethods.find(f)),!symbolic=(invalidMethods.end()),!end=0}
Line 970
  ( {lifetime[Iterator]=(refs),start=0}
  ( {lifetime[Iterator]=(refs),end=0}
  ( possible lifetime[Object]=(result)
  [ possible lifetime[Lambda]=(dependsOnThis)
Line 972
  ! always {!<=-1,!>=2}
  var always symbolic=(r.tok->variable())
Line 973
  false always 0
Line 974
  dependsOnThis always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(r.tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(r.tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(r.tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 975
  true always 1
Line 976
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 977
  false always 0
Line 978
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 979
  false always 0
Line 980
  true always 1
Line 984
  . inconclusive lifetime[Object]=(tok)
  epi inconclusive lifetime[Object]=(tok)
Line 987
  ! always {!<=-1,!>=2}
  var always symbolic=(r.tok->variable())
Line 989
  var {symbolic=(r.tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 990
  var {symbolic=(r.tok->variable()),!0}
Line 991
  = always 0
  nullptr always 0
Line 992
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  n {>=0,!<=-1}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 993
  n {<=symbolic=(args.size()-1),!>=symbolic=(args.size()),>=0,!<=-1}
Line 994
  = possible {symbolic=(args[n]),0}
  tok2 possible {symbolic=(args[n]),0}
Line 998
  ( always {!<=-1,!>=2}
Line 1002
  ep always size=0
  ftok always !0
Line 1003
  "After calling '" always "After calling '"
Line 1004
  "', iterators or references to the container's data may be invalid ." always "', iterators or references to the container's data may be invalid ."
Line 1005
  result {lifetime[Object]=(tok),size=0}
  { possible lifetime[SubObject]=(tok)
  ep always !size=0
Line 1008
  result possible lifetime[Object]=(tok)
Line 1012
  symboldatabase possible symbolic=(mTokenizer->getSymbolDatabase())@181
Line 1014
  ! always {!<=-1,!>=2}
  f always symbolic=(scope->function)
Line 1016
  != always {!<=-1,!>=2}
Line 1017
  ( always {!<=-1,!>=2}
  "if|while|for|goto|return" always "if|while|for|goto|return"
Line 1020
  ( always {!<=-1,!>=2}
Line 1022
  c always !size=0
Line 1030
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 1031
  nullptr always 0
Line 1033
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  sepTok always symbolic=(tok->next()->astOperand2())
  ":" always ":"
Line 1034
  nullptr always 0
Line 1035
  sepTok always symbolic=(tok->next()->astOperand2())
Line 1039
  , always 0
Line 1040
  = always 0
  nullptr always 0
  , always 4
Line 1041
  = always 4
  4 always 4
Line 1043
  depth possible 4
  < {!<=-1,!>=2,0}
  0 always 0
Line 1044
  nullptr always 0
Line 1045
  ! always {!<=-1,!>=2}
Line 1046
  nullptr always 0
Line 1047
  tok always !0
Line 1048
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1050
  :: always 4
  Address always 4
Line 1051
  :: always 1
  SubObject always 1
Line 1052
  :: always 2
  Lambda always 2
Line 1054
  ( always {!<=-1,!>=2}
Line 1055
  nullptr always 0
Line 1057
  . always !0
  1 always 1
Line 1059
  errorPath always !0
  errorPath always !0
  ( always end=0
  ( {lifetime[Iterator]=(val.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(val.errorPath),lifetime[Object]=(errorPath),end=0}
Line 1060
  errorPath possible 0
  1 always 1
Line 1062
  ! always {!<=-1,!>=2}
Line 1064
  != always {!<=-1,!>=2}
Line 1066
  & always !0
Line 1068
  nullptr always 0
Line 1076
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1077
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1078
  != always {!<=-1,!>=2}
Line 1081
  blockStart always symbolic=(tok->next()->link()->next())
Line 1082
  contTok always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1084
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  contTok always !0
Line 1086
  != always {!<=-1,!>=2}
Line 1087
  bail always {!<=-1,!>=2}
  bail always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1089
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1091
  != always {!<=-1,!>=2}
Line 1094
  ! always {!<=-1,!>=2}
  s always symbolic=(tok2->scope())
Line 1096
  ( always {!<=-1,!>=2}
  s {symbolic=(tok2->scope()),!0}
  & {lifetime[Address]=(mSettings->library),!0}
Line 1099
  bail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1102
  bail {!<=-1,!>=2,1}
Line 1107
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1112
  assignExpr possible symbolic=(tok)
Line 1113
  isRHS always {!<=-1,!>=2}
  isRHS always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1114
  = always !0
  ( always !0
Line 1115
  ( always {!<=-1,!>=2}
  assignExpr always !0
  "%assign%" always "%assign%"
Line 1116
  ! always {!<=-1,!>=2}
  isRHS always {!<=-1,!>=2}
Line 1117
  = always 0
  nullptr always 0
Line 1121
  ( always {!<=-1,!>=2}
  assignExpr possible {symbolic=(tok),0}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 1124
  ! always {!<=-1,!>=2}
Line 1126
  v possible 0
  = always 0
  nullptr always 0
Line 1129
  endToken possible symbolic=(tok->next())
  [ possible {lifetime[Lambda]=(skipVarIds),lifetime[Lambda]=(tok)}
Line 1130
  ! always {!<=-1,!>=2}
Line 1131
  false always 0
Line 1132
  == always {!<=-1,!>=2}
  0 always 0
Line 1133
  false always 0
Line 1134
  ( always !<=-1
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 1135
  false always 0
Line 1138
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1140
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1141
  ( always {!<=-1,!>=2}
  nullptr always 0
Line 1144
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1145
  ep always size=0
  & {lifetime[Address]=(addressOf),!0}
  addressOf always 0
Line 1147
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
Line 1149
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1150
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1151
  ( always {!<=-1,!>=2}
  var always !0
  & {lifetime[Address]=(ep),!0}
Line 1153
  true always 1
Line 1158
  & {lifetime[Address]=(ep),!0}
  ep always size=0
Line 1160
  && always {!<=-1,!>=2}
  val always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  val always !0
  . always !symbolic=(tok)
  tok always !symbolic=(val->tokvalue)
  & {lifetime[Address]=(ep),!0}
Line 1161
  = always !0
  val always !0
Line 1163
  true always 1
Line 1165
  false always 0
Line 1167
  ! always {!<=-1,!>=2}
Line 1169
  ( possible lifetime[Iterator]=(errorPath)
  ( {lifetime[Iterator]=(errorPath),end=0}
  ( {lifetime[Iterator]=(info.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(info.errorPath),lifetime[Object]=(errorPath),end=0}
Line 1170
  ( possible lifetime[Iterator]=(errorPath)
  ( {lifetime[Iterator]=(errorPath),end=0}
  ( {lifetime[Iterator]=(r.errorPath),lifetime[Object]=(errorPath),start=0}
  ( {lifetime[Iterator]=(r.errorPath),lifetime[Object]=(errorPath),end=0}
Line 1172
  v always !0
Line 1184
  = possible "erase"
  tok possible 0@124
  ? possible "erase"
  tok always !0
  : always "erase"
  "erase" always "erase"
Line 1185
  errorPath possible size=0@124
  loopTok possible 0@124
  "Iterating container here." always "Iterating container here."
Line 1188
  [ possible lifetime[Lambda]=(tok)
Line 1189
  == always {!<=-1,!>=2}
Line 1192
  "Calling '" always "Calling '"
  method always symbolic=(tok?tok->str():"erase")
  "' while iterating the container is invalid." always "' while iterating the container is invalid."
Line 1193
  tok inconclusive 0@124
  "" always ""
Line 1194
  :: always 1
  error always 1
  "invalidContainerLoop" always "invalidContainerLoop"
  msg always symbolic=("Calling '"+method+"' while iterating the container is invalid.")
  :: always 0
  normal always 0
Line 1199
  inconclusive always {!<=-1,!>=2}
  = {0,!<=-1,!>=2}
  val possible 0
  ? {0,!<=-1,!>=2}
  val always !0
  ( always {!<=-1,!>=2}
  : always 0
  false always 0
Line 1200
  val possible 0@125
Line 1201
  ( possible lifetime[Iterator]=(errorPath)
  ( {lifetime[Iterator]=(errorPath),start=0}
  val always !0
  ( {lifetime[Iterator]=(val->errorPath),start=0}
  val always !0
  ( {lifetime[Iterator]=(val->errorPath),end=0}
Line 1202
  "Using " always "Using "
  tok possible 0@125
  val possible 0
  errorPath possible size=0@125
Line 1203
  tok possible 0@125
  "" always ""
Line 1204
  :: always 1
  error always 1
  "invalidContainer" always "invalidContainer"
  " that may be invalid." always " that may be invalid."
  inconclusive {symbolic=(val?val->isInconclusive():false),!<=-1,!>=2,0}
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 1209
  = possible "x"
  ? possible "x"
  contTok always !0
  : always "x"
  "x" always "x"
Line 1210
  "Reference to " always "Reference to "
  name always symbolic=(contTok?contTok->expressionString():"x")
Line 1211
  "" always ""
Line 1212
  :: always 1
  error always 1
  "invalidContainerReference" always "invalidContainerReference"
  msg always symbolic=("Reference to "+name)
  " that may be invalid." always " that may be invalid."
  :: always 0
  normal always 0
Line 1220
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1223
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 6
  eIf always 6
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always symbolic=(scope.classDef)
Line 1226
  = always 0
  nullptr always 0
Line 1227
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 1228
  ( always {!<=-1,!>=2}
  tok {symbolic=(scope.classDef),!0}
  ";" always ";"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ";" always ";"
Line 1229
  tok always !0
Line 1230
  ( always {!<=-1,!>=2}
  tok {symbolic=(scope.classDef),!0}
  "do {" always "do {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  1 always 1
  "} while (" always "} while ("
Line 1231
  tok always !0
  1 always 1
  2 always 2
Line 1233
  tok always !0
Line 1235
  ! always {!<=-1,!>=2}
  condition possible {symbolic=(tok->next()->astOperand2()->astOperand2()->astOperand1()),symbolic=(tok->next()->astOperand2())}
Line 1240
  condition always !0
Line 1241
  [ possible lifetime[Lambda]=(conds)
Line 1242
  ( always {!<=-1,!>=2}
  "%oror%|&&" always "%oror%|&&"
Line 1243
  :: always 3
  op1_and_op2 always 3
Line 1244
  ( always {!<=-1,!>=2}
Line 1246
  :: always 0
  none always 0
Line 1253
  == always {!<=-1,!>=2}
  "<=" always "<="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
  && always {!<=-1,!>=2}
Line 1254
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 1255
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
  && always {!<=-1,!>=2}
Line 1256
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
Line 1263
  containerToken possible symbolic=(cond->next())
  ( always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 1267
  ( always !0
  : always 0
  nullptr always 0
Line 1268
  ! always {!<=-1,!>=2}
  container always symbolic=(containerToken->valueType()?containerToken->valueType()->container:nullptr)
Line 1270
  container {symbolic=(containerToken->valueType()?containerToken->valueType()->container:nullptr),!0}
  2 always 2
  != always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 1280
  && always {!<=-1,!>=2}
  tok3 always !0
  != always {!<=-1,!>=2}
Line 1281
  == always {!<=-1,!>=2}
  declarationId always symbolic=(containerToken->varId())
Line 1283
  ( always {!<=-1,!>=2}
  ". %name% ( )" always ". %name% ( )"
Line 1284
  container always !0
  1 always 1
  == always {!<=-1,!>=2}
  :: always 7
  SIZE always 7
Line 1286
  container always !0
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[ %varid% ]" always "[ %varid% ]"
  numId always symbolic=(vartok->varId())
Line 1287
  1 always 1
  false always 0
Line 1288
  ( always {!<=-1,!>=2}
  ". %name% ( %varid% )" always ". %name% ( %varid% )"
  numId always symbolic=(vartok->varId())
Line 1289
  container always !0
  1 always 1
Line 1290
  == always {!<=-1,!>=2}
  :: always 0
  AT_INDEX always 0
Line 1291
  3 always 3
  true always 1
Line 1299
  , always {!<=-1,!>=2}
  at always {!<=-1,!>=2}
Line 1301
  at {!<=-1,!>=2,0@175,1@177}
Line 1302
  :: always 1
  error always 1
  "stlOutOfBounds" always "stlOutOfBounds"
  "$symbol:" always "$symbol:"
  "\nWhen " always "\nWhen "
  "==$symbol.size(), $symbol.at(" always "==$symbol.size(), $symbol.at("
  ") is out of bounds." always ") is out of bounds."
  :: always 0
  normal always 0
Line 1304
  tok possible 0@131
  :: always 1
  error always 1
  "stlOutOfBounds" always "stlOutOfBounds"
  "$symbol:" always "$symbol:"
  var possible "foo"@131
  "\nWhen " always "\nWhen "
  num possible "i"@131
  "==$symbol.size(), $symbol[" always "==$symbol.size(), $symbol["
  num possible "i"@131
  "] is out of bounds." always "] is out of bounds."
  :: always 0
  normal always 0
Line 1311
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1312
  != always {!<=-1,!>=2}
Line 1313
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% [" always "%var% ["
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!tok->next()->astOperand2()" always "!tok->next()->astOperand2()"
Line 1316
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 1318
  var {symbolic=(tok->variable()),!0}
Line 1319
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
Line 1321
  tok always !symbolic=(var->nameToken())
  -1 always -1
Line 1322
  ! always {!<=-1,!>=2}
Line 1324
  index always !0
Line 1331
  tok possible 0@132
  & {lifetime[Address]=(index),!0}
  "Negative array index" always "Negative array index"
Line 1335
  ", otherwise there is negative array index " always ", otherwise there is negative array index "
  "." always "."
Line 1337
  "Array index " always "Array index "
  " is out of bounds." always " is out of bounds."
Line 1338
  ( always {!<=-1,!>=2}
  :: always 1
  error always 1
  : always 2
  :: always 2
  warning always 2
  "negativeContainerIndex" always "negativeContainerIndex"
  ( always {!<=-1,!>=2}
  : always 0
  :: always 0
  normal always 0
Line 1345
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1346
  . possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 1347
  1 always 1
Line 1348
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -3 always -3
  "; ++| %var% ++| ) {" always "; ++| %var% ++| ) {"
Line 1351
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1354
  == always {!<=-1,!>=2}
  :: always 9
  eWhile always 9
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "while ( %var% !=" always "while ( %var% !="
Line 1355
  2 always 2
Line 1362
  inconclusiveType always {!<=-1,!>=2}
  inconclusiveType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1363
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  inconclusiveType always 0
Line 1365
  != always {!<=-1,!>=2}
Line 1366
  != always {!<=-1,!>=2}
  "(" always "("
Line 1368
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ". erase ( ++| %varid% )" always ". erase ( ++| %varid% )"
Line 1371
  ( always {!<=-1,!>=2}
  -3 always -3
Line 1373
  ( always {!<=-1,!>=2}
  "=|return" always "=|return"
Line 1376
  = always 0
  0U always 0
Line 1378
  tok2 possible symbolic=(tok->link())
  != always {!<=-1,!>=2}
Line 1379
  ( possible size=1
  == always {!<=-1,!>=2}
  "{" always "{"
Line 1383
  == always {!<=-1,!>=2}
  "}" always "}"
Line 1384
  > always {!<=-1,!>=2}
  0U always 0
Line 1385
  -- {>=0,!<=-1}
  indentlevel {>=1,!<=0}
Line 1386
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 1387
  2 always 2
Line 1390
  == always {!<=-1,!>=2}
Line 1391
  ( always {!<=-1,!>=2}
  "=" always "="
Line 1393
  inconclusiveType always {!<=-1,!>=2}
Line 1396
  == always {!<=-1,!>=2}
  0U always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "break|return|goto" always "break|return|goto"
Line 1399
  tok2 possible symbolic=(tok->link())
  == always {!<=-1,!>=2}
Line 1400
  inconclusiveType always {!<=-1,!>=2}
Line 1407
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1408
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 1411
  var always !0
  true always 1
Line 1412
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  opLessAllowed always {!<=-1,!>=2}
Line 1415
  var always !0
  ( always !0
Line 1416
  var always !0
  != always {!<=-1,!>=2}
  end always symbolic=(var->scope()->bodyEnd)
Line 1417
  ( always {!<=-1,!>=2}
  "!!* %varid% <" always "!!* %varid% <"
  var always !0
Line 1419
  ( always {!<=-1,!>=2}
  "> %varid% !!." always "> %varid% !!."
  var always !0
Line 1429
  tok possible 0@133
  :: always 1
  error always 1
  "stlBoundaries" always "stlBoundaries"
Line 1430
  "Dangerous comparison using operator< on iterator.\nIterator compared with operator<. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators." always "Dangerous comparison using operator< on iterator.\nIterator compared with operator<. This is dangerous since the order of items in the container is not guaranteed. One should use operator!= instead to compare iterators."
Line 1432
  :: always 0
  normal always 0
Line 1435
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 1438
  ! always {!<=-1,!>=2}
  tok always symbolic=(tokBack->astParent())
Line 1439
  return always {!<=-1,!>=2}
  true always 1
Line 1440
  tok {symbolic=(tokBack->astParent()),!0}
  ( always {!<=-1,!>=2}
Line 1441
  stdStringLike always {!<=-1,!>=2}
Line 1443
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokOther always symbolic=(tokBack->astSibling())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokOther {symbolic=(tokBack->astSibling()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tokOther {symbolic=(tokBack->astSibling()),!0}
  != always {!<=-1,!>=2}
  0 always 0
Line 1445
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 1447
  tok always !0
  ( always {!<=-1,!>=2}
Line 1448
  return always {!<=-1,!>=2}
  true always 1
Line 1449
  == always {!<=-1,!>=2}
  "." always "."
Line 1450
  return always {!<=-1,!>=2}
  true always 1
Line 1451
  ( always {!<=-1,!>=2}
Line 1452
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
Line 1453
  return always {!<=-1,!>=2}
  false always 0
Line 1458
  printWarning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1459
  printPerformance always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 1460
  ! {!<=-1,!>=2,1}
  printWarning {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printPerformance always {!<=-1,!>=2}
Line 1465
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1466
  . possible 9
  != {!<=-1,!>=2,1}
  :: always 6
  eIf always 6
  && always {!<=-1,!>=2}
  . always !6
  != always {!<=-1,!>=2}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1469
  . always !0
Line 1470
  ( always {!<=-1,!>=2}
  conditionStart always symbolic=(scope.classDef->next())
  ";" always ";"
Line 1473
  != always {!<=-1,!>=2}
  "{" always "{"
Line 1474
  = always 0
  nullptr always 0
Line 1475
  = always 0
  nullptr always 0
Line 1477
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1478
  1 always 1
Line 1480
  ( possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . %name% (" always "%var% . %name% ("
Line 1481
  ( always !0
Line 1482
  2 always 2
Line 1486
  ( possible 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 1487
  = always !0
  ( always !0
Line 1489
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->astParent()),!0}
  ". %name% (" always ". %name% ("
Line 1492
  tok2 {symbolic=(tok->astParent()),!0}
Line 1494
  ( always !0
  ( always {!<=-1,!>=2}
Line 1495
  ( always !0
Line 1497
  ( always !0
Line 1498
  ( always !0
  "<" always "<"
  ( always !0
Line 1499
  && always {!<=-1,!>=2}
  container always !0
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  tok2 always symbolic=(Token::findsimplematch(tok->variable()->typeStartToken(),"<",tok->variable()->typeEndToken()))
Line 1500
  tok2 {symbolic=(Token::findsimplematch(tok->variable()->typeStartToken(),"<",tok->variable()->typeEndToken())),!0}
Line 1501
  = always 0
  0 always 0
  j possible 0
  < {!<=-1,!>=2,>=0}
  container always !0
  . {>=0,!<=-1}
Line 1506
  = always 0
  nullptr always 0
Line 1510
  container possible 0
  && always {!<=-1,!>=2}
  container always !0
  == always {!<=-1,!>=2}
  :: always 4
  FIND always 4
Line 1511
  ( always {!<=-1,!>=2}
  container always !0
  . {!<=-1,!>=2,0}
  stdStringLike always {!<=-1,!>=2}
Line 1514
  printWarning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  container always !0
  == always {!<=-1,!>=2}
  :: always 6
  ITERATOR always 6
Line 1515
  false always 0
Line 1516
  printPerformance always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  container always !0
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "find" always "find"
Line 1517
  true always 1
Line 1518
  printWarning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: find|find_if (" always "std :: find|find_if ("
Line 1520
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  false always 0
Line 1521
  false always 0
Line 1529
  , always {!<=-1,!>=2}
  str always {!<=-1,!>=2}
Line 1531
  str {!<=-1,!>=2,0,1@57}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 4
  CPP20 always 4
Line 1532
  :: always 4
  performance always 4
  "stlIfStrFind" always "stlIfStrFind"
Line 1533
  "Inefficient usage of string::find() in condition; string::starts_with() could be faster.\nEither inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos." always "Inefficient usage of string::find() in condition; string::starts_with() could be faster.\nEither inefficient or wrong usage of string::find(). string::starts_with() will be faster if string::find's result is compared with 0, because it will not scan the whole string. If your intention is to check that there are no findings in the string, you should compare with std::string::npos."
Line 1537
  :: always 0
  normal always 0
Line 1538
  ! {!<=-1,!>=2,0,1}
  str {!<=-1,!>=2,1,0}
Line 1539
  tok possible 0@134
  :: always 2
  warning always 2
  "stlIfFind" always "stlIfFind"
  "Suspicious condition. The result of find() is an iterator, but it is not properly checked." always "Suspicious condition. The result of find() is an iterator, but it is not properly checked."
  :: always 0
  normal always 0
Line 1544
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 1546
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
Line 1548
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1551
  contTok always symbolic=(tok->astOperand1()->astOperand1())
Line 1552
  ! always {!<=-1,!>=2}
  container always symbolic=(contTok->valueType()->container)
Line 1554
  ! always {!<=-1,!>=2}
  container {symbolic=(contTok->valueType()->container),!0}
  . always {!<=-1,!>=2}
  stdAssociativeLike always {!<=-1,!>=2}
Line 1556
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". find|count (" always ". find|count ("
Line 1558
  ! always {!<=-1,!>=2}
Line 1560
  ( always !0
Line 1565
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->next()->link()->next())@54749
Line 1566
  tok {0,symbolic=(tok->next()->link()->next())@54749}
Line 1567
  ( always {!<=-1,!>=2}
  tok {!0,symbolic=(tok->next()->link()->next())@54749}
  "{" always "{"
Line 1568
  tok always !0
Line 1569
  tok always !0
Line 1571
  tok always !0
Line 1572
  ! always {!<=-1,!>=2}
  top always symbolic=(tok->astTop())
Line 1573
  tok always !0
  ";" always ";"
Line 1574
  ! always {!<=-1,!>=2}
  semi always symbolic=(Token::findsimplematch(tok,";"))
Line 1575
  tok always !0
Line 1576
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  semi {symbolic=(Token::findsimplematch(tok,";")),!0}
  "%var% ;" always "%var% ;"
Line 1578
  semi always !0
Line 1579
  varTok always symbolic=(semi->previous())
Line 1580
  ! always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
Line 1582
  var {symbolic=(varTok->variable()),!0}
  != always {!<=-1,!>=2}
  varTok always symbolic=(semi->previous())
Line 1586
  ( always {!<=-1,!>=2}
  top {symbolic=(tok->astTop()),!0}
  "%assign%" always "%assign%"
Line 1587
  top {symbolic=(tok->astTop()),!0}
Line 1588
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  varTok always symbolic=(top->astOperand1())
  "%var%" always "%var%"
Line 1590
  varTok always symbolic=(top->astOperand1())
Line 1591
  ! always {!<=-1,!>=2}
  var always symbolic=(varTok->variable())
Line 1593
  var {symbolic=(varTok->variable()),!0}
  != always {!<=-1,!>=2}
Line 1596
  ! always {!<=-1,!>=2}
Line 1598
  endTok always !0
Line 1605
  = inconclusive lifetime[Object]=(tok)
  ( inconclusive lifetime[Object]=(tok)
  tok possible symbolic=(tok->next()->link()->next())@213
Line 1606
  startTok inconclusive lifetime[Object]=(tok)
Line 1608
  = always 0
  nullptr always 0
Line 1609
  = always 0
  nullptr always 0
Line 1610
  = always 0
  nullptr always 0
Line 1611
  ( always {!<=-1,!>=2}
  top always symbolic=(startTok->astTop())
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always symbolic=(startTok->astTop())
  "[" always "["
Line 1612
  top always symbolic=(startTok->astTop())
Line 1613
  top always symbolic=(startTok->astTop())
Line 1614
  top always symbolic=(startTok->astTop())
Line 1616
  ( always {!<=-1,!>=2}
  top always symbolic=(startTok->astTop())
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always symbolic=(startTok->astTop())
  ". insert|emplace (" always ". insert|emplace ("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always symbolic=(startTok->astTop())
  2 always 2
Line 1617
  top always symbolic=(startTok->astTop())
Line 1618
  top always symbolic=(startTok->astTop())
  2 always 2
Line 1619
  ( always {!<=-1,!>=2}
  "," always ","
Line 1626
  ! always {!<=-1,!>=2}
  ikeyTok possible {symbolic=(itok->astOperand1()),symbolic=(itok)}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1627
  nullptr always 0
Line 1628
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  icontainerTok always !0
  true always 1
  false always 0
  && always {!<=-1,!>=2}
Line 1629
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  ikeyTok always !0
  true always 1
  true always 1
Line 1631
  ivalueTok always !0
Line 1633
  ikeyTok always !0
Line 1635
  nullptr always 0
Line 1640
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 1644
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1645
  != always {!<=-1,!>=2}
Line 1646
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 1648
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 1650
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%comp%" always "%comp%"
Line 1655
  ( possible {lifetime[Object]=(containerTok),lifetime[Object]=(keyTok)}
  containerTok always Uninit
  keyTok always Uninit
  condTok always symbolic=(tok->next()->astOperand2())
Line 1656
  ! always {!<=-1,!>=2}
Line 1659
  < always {!<=-1,!>=2}
  :: always 3
  CPP17 always 3
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  keyTok always !0
  && always {!<=-1,!>=2}
  keyTok always !0
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  keyTok always !0
  ( always !0
  > always {!<=-1,!>=2}
  0 always 0
Line 1663
  thenTok always symbolic=(tok->next()->link()->next())
  containerTok always !0
Line 1664
  ! always {!<=-1,!>=2}
Line 1667
  ( always {!<=-1,!>=2}
  thenTok always symbolic=(tok->next()->link()->next())
  "} else {" always "} else {"
Line 1669
  thenTok always symbolic=(tok->next()->link()->next())
  2 always 2
Line 1670
  ! always {!<=-1,!>=2}
Line 1672
  ( always {!<=-1,!>=2}
  true always 1
  true always 1
  valueTok always !0
  valueTok2 always !0
  true always 1
  true always 1
Line 1673
  valueTok always !0
Line 1676
  valueTok always !0
Line 1685
  tok possible {symbolic=(tok->astParent()->astOperand2()),0@136}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  "=" always "="
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok->astParent()->astOperand2())
  "[" always "["
Line 1686
  < always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 1689
  . {!<=0,>=1}
  < {!<=-1,!>=2,>=1}
  :: always 3
  CPP17 always 3
  "emplace" always "emplace"
  : always "try_emplace"
  "try_emplace" always "try_emplace"
Line 1690
  " Instead of '" always " Instead of '"
  tok {!0,symbolic=(tok->astParent()->astOperand2())}
  "' consider using '" always "' consider using '"
Line 1691
  tok {!0,symbolic=(tok->astParent()->astOperand2())}
Line 1692
  "." always "."
  "(" always "("
Line 1693
  tok {!0,symbolic=(tok->astParent()->astOperand2())}
Line 1694
  ", " always ", "
Line 1695
  tok {!0,symbolic=(tok->astParent()->astOperand2())}
Line 1696
  ");'." always ");'."
Line 1700
  tok possible {symbolic=(tok->astParent()->astOperand2()),0}
  :: always 4
  performance always 4
  "stlFindInsert" always "stlFindInsert"
  "Searching before insertion is not necessary." always "Searching before insertion is not necessary."
  + possible size=44
  replaceExpr possible {symbolic=(" Instead of '"+tok->astParent()->expressionString()+"' consider using '"+tok->astParent()->astOperand1()->astOperand1()->expressionString()+"."+f+"("+tok->astParent()->astOperand1()->astOperand2()->expressionString()+", "+tok->expressionString()+");'."),size=0}
  :: always 0
  normal always 0
Line 1706
  ( always {!<=-1,!>=2}
Line 1708
  ! always {!<=-1,!>=2}
Line 1709
  return always {!<=-1,!>=2}
  false always 0
Line 1710
  tok always !0
Line 1711
  return always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  "list" always "list"
Line 1716
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 1719
  >= always {!<=-1,!>=2}
  :: always 1
  CPP11 always 1
Line 1723
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1724
  != always {!<=-1,!>=2}
Line 1725
  ( always {!<=-1,!>=2}
  "%var% . size ( )" always "%var% . size ( )"
  || always {!<=-1,!>=2}
Line 1726
  ( always {!<=-1,!>=2}
  "%name% . %var% . size ( )" always "%name% . %var% . size ( )"
Line 1729
  tok always symbolic=(varTok)
  2 always 2
  != always {!<=-1,!>=2}
  "size" always "size"
Line 1730
  varTok always symbolic=(tok)
  2 always 2
Line 1732
  varTok possible symbolic=(tok)
  5 always 5
Line 1735
  ! {!<=-1,!>=2,1}
  tok possible symbolic=(varTok)
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "==|<=|!=|> 0" always "==|<=|!=|> 0"
  || always {!<=-1,!>=2}
Line 1736
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "0 ==|>=|!=|<" always "0 ==|>=|!=|<"
Line 1737
  ( always {!<=-1,!>=2}
Line 1744
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ">=|< 1" always ">=|< 1"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  2 always 2
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1745
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "1 <=|>" always "1 <=|>"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  -3 always -3
  ( always {!<=-1,!>=2}
Line 1746
  ( always {!<=-1,!>=2}
Line 1751
  ( always {!<=-1,!>=2}
  -2 always -2
  "if|while (" always "if|while ("
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
Line 1752
  == always {!<=-1,!>=2}
  :: always 14
  eLogicalOp always 14
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&&|)|,|;|%oror%" always "&&|)|,|;|%oror%"
Line 1753
  ( always {!<=-1,!>=2}
Line 1763
  tok possible 0@141
  tok always !0
  "list" always "list"
Line 1764
  tok possible 0@141
  :: always 4
  performance always 4
  "stlSize" always "stlSize"
Line 1765
  "$symbol:" always "$symbol:"
  "\nPossible inefficient checking for '$symbol' emptiness.\nChecking for '$symbol' emptiness might be inefficient. Using $symbol.empty() instead of $symbol.size() can be faster. $symbol.size() can take linear time but $symbol.empty() is guaranteed to take constant time." always "\nPossible inefficient checking for '$symbol' emptiness.\nChecking for '$symbol' emptiness might be inefficient. Using $symbol.empty() instead of $symbol.size() can be faster. $symbol.size() can take linear time but $symbol.empty() is guaranteed to take constant time."
Line 1770
  :: always 0
  normal always 0
Line 1775
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1780
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1781
  != always {!<=-1,!>=2}
  :: always 6
  eIf always 6
Line 1784
  2 always 2
Line 1785
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% . find ( %any% ) != %name% . end|rend|cend|crend ( ) ) { %name% . remove|erase ( %any% ) ;" always "%name% . find ( %any% ) != %name% . end|rend|cend|crend ( ) ) { %name% . remove|erase ( %any% ) ;"
Line 1790
  var1 always symbolic=(tok)
  4 always 4
Line 1791
  3 always 3
Line 1792
  7 always 7
Line 1793
  4 always 4
Line 1796
  var1 always symbolic=(tok)
  == always {!<=-1,!>=2}
  ( possible symbolic=(var3->str())
  && always {!<=-1,!>=2}
Line 1797
  ( always symbolic=(var1->str())
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1798
  == always {!<=-1,!>=2}
Line 1799
  tok always symbolic=(var1)
Line 1806
  tok possible {symbolic=(var1)@146,0@143}
  :: always 3
  style always 3
  "redundantIfRemove" always "redundantIfRemove"
Line 1807
  "Redundant checking of STL container element existence before removing it.\nRedundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element." always "Redundant checking of STL container element existence before removing it.\nRedundant checking of STL container element existence before removing it. It is safe to call the remove method on a non-existing element."
Line 1809
  :: always 0
  normal always 0
Line 1814
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 1819
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1820
  != always {!<=-1,!>=2}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1823
  . always !0
  2 always 2
  != always {!<=-1,!>=2}
Line 1824
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1827
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% = %name% . begin|rbegin|cbegin|crbegin ( ) ; %name% != %name% . end|rend|cend|crend ( ) ; ++| %name% ++| ) {" always "%var% = %name% . begin|rbegin|cbegin|crbegin ( ) ; %name% != %name% . end|rend|cend|crend ( ) ; ++| %name% ++| ) {"
Line 1831
  2 always 2
  != always {!<=-1,!>=2}
  10 always 10
Line 1837
  == always {!<=-1,!>=2}
  10 always 10
Line 1841
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  16 always 16
  "++ %varid% )" always "++ %varid% )"
  && always {!<=-1,!>=2}
Line 1842
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  16 always 16
  "%varid% ++ )" always "%varid% ++ )"
Line 1846
  = always 0
  nullptr always 0
Line 1848
  != always {!<=-1,!>=2}
  tok3 possible symbolic=(incrementToken)
Line 1849
  == always {!<=-1,!>=2}
Line 1850
  ( always {!<=-1,!>=2}
  "%varid% = %name% . insert ( ++| %varid% ++| ," always "%varid% = %name% . insert ( ++| %varid% ++| ,"
  iteratorId always symbolic=(tok3->varId())
Line 1852
  6 always 6
Line 1853
  ! always {!<=-1,!>=2}
Line 1855
  ( always {!<=-1,!>=2}
  "++" always "++"
Line 1857
  ( always {!<=-1,!>=2}
  "+" always "+"
Line 1858
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
Line 1860
  ( always {!<=-1,!>=2}
  tokenGrandParent always symbolic=(tok3->astParent()->astParent())
  "==|!=" always "==|!="
Line 1863
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 1864
  = always 0
  nullptr always 0
Line 1865
  ( possible size=6
  == {!<=-1,!>=2,0}
  "break" always "break"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
Line 1866
  = always 0
  nullptr always 0
Line 1868
  incrementToken possible 0
Line 1869
  incrementToken always !0
  16 always 16
Line 1876
  incrementToken1 possible 0@142
  incrementToken2 inconclusive 0
Line 1879
  "Missing bounds check for extra iterator increment in loop.\n" always "Missing bounds check for extra iterator increment in loop.\n"
Line 1880
  "The iterator incrementing is suspicious - it is incremented at line " always "The iterator incrementing is suspicious - it is incremented at line "
Line 1881
  incrementToken1 inconclusive 0@142
Line 1882
  incrementToken1 always !0
Line 1883
  " and then at line " always " and then at line "
Line 1884
  incrementToken2 inconclusive 0@142
Line 1885
  incrementToken2 always !0
Line 1886
  ". The loop might unintentionally skip an element in the container. " always ". The loop might unintentionally skip an element in the container. "
Line 1887
  "There is no comparison between these increments to prevent that the iterator is " always "There is no comparison between these increments to prevent that the iterator is "
Line 1888
  "incremented beyond the end." always "incremented beyond the end."
Line 1890
  callstack always {{,size=2}
  :: always 2
  warning always 2
  "StlMissingComparison" always "StlMissingComparison"
  :: always 0
  normal always 0
Line 1894
  ( always {!<=-1,!>=2}
Line 1896
  tok possible symbolic=(tok->next())@95
Line 1897
  return always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1902
  "istringstream" always "istringstream"
  "ostringstream" always "ostringstream"
  "stringstream" always "stringstream"
  "wstringstream" always "wstringstream"
Line 1908
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1909
  printPerformance always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 1915
  printPerformance always {!<=-1,!>=2}
Line 1916
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1918
  = always 0
  0 always 0
Line 1920
  numpar possible 0
  ++ possible 0
Line 1921
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1922
  c_strFuncParam possible lifetime[Object]=(functionList)
  ( possible lifetime[Iterator]=(c_strFuncParam)
  ( possible lifetime[Object]=(functionList)
  & {lifetime[Address]=(functionList),!0}
Line 1929
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1930
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1934
  ( always {!<=-1,!>=2}
  . always !0
  -2 always -2
  "char|wchar_t *" always "char|wchar_t *"
Line 1936
  ( always {!<=-1,!>=2}
  -5 always -5
  "const std :: string|wstring &" always "const std :: string|wstring &"
Line 1938
  ( always {!<=-1,!>=2}
  -3 always -3
  "std :: string|wstring !!&" always "std :: string|wstring !!&"
Line 1941
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 1943
  ( always {!<=-1,!>=2}
  "throw %var% . c_str|data ( ) ;" always "throw %var% . c_str|data ( ) ;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1944
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1946
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1947
  ( always {!<=-1,!>=2}
  2 always 2
  "%var% . str ( ) . c_str|data ( ) ;" always "%var% . str ( ) . c_str|data ( ) ;"
Line 1948
  = always !0
  ( always !0
Line 1949
  2 always 2
Line 1950
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var2 always !0
  ( always {!<=-1,!>=2}
Line 1952
  ( always {!<=-1,!>=2}
  2 always 2
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
Line 1953
  ( always {!<=-1,!>=2}
  3 always 3
  ") . c_str|data ( ) ;" always ") . c_str|data ( ) ;"
  && always {!<=-1,!>=2}
Line 1954
  2 always 2
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  "std :: string|wstring %name%" always "std :: string|wstring %name%"
Line 1955
  = always !0
  ( always !0
Line 1956
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1959
  printPerformance {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ( !!)" always "%name% ( !!)"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(c_strFuncParam)
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(c_strFuncParam),end=0}
  && always {!<=-1,!>=2}
Line 1960
  != always {!<=-1,!>=2}
Line 1962
  != always {!<=-1,!>=2}
Line 1963
  i always !symbolic=(range.second)
  == always {!<=-1,!>=2}
  0 always 0
Line 1966
  2 always 2
Line 1967
  j possible symbolic=(i->second-1)
Line 1968
  = always 0
  0 always 0
  tok2 possible 0
  && always {!<=-1,!>=2}
  j possible 0
  < always {!<=-1,!>=2}
  . always !0
  - always !-1
  1 always 1
Line 1971
  tok2 always !0
Line 1974
  ! {!<=-1,!>=2,1}
  tok2 possible 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always !0
  - always !-1
  1 always 1
Line 1977
  tok2 always !0
Line 1980
  tok2 possible symbolic=(tok->next()->link())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  -4 always -4
  ". c_str|data ( )" always ". c_str|data ( )"
Line 1981
  tok2 always !0
  -5 always -5
Line 1982
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1983
  . always !0
Line 1984
  ( always {!<=-1,!>=2}
  tok2 always !0
  -9 always -9
  "%name% . str ( )" always "%name% . str ( )"
Line 1985
  tok2 always !0
  -9 always -9
Line 1986
  && always {!<=-1,!>=2}
  ssVar always !0
  ( always {!<=-1,!>=2}
Line 1987
  . always !0
Line 1995
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  printPerformance always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "return" always "return"
Line 1996
  err always {!<=-1,!>=2}
  err always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1999
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  "std :: string|wstring (" always "std :: string|wstring ("
  && always {!<=-1,!>=2}
Line 2000
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  3 always 3
  ") . c_str|data ( ) ;" always ") . c_str|data ( ) ;"
Line 2001
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2002
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  "(" always "("
  && always {!<=-1,!>=2}
Line 2003
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  ") . c_str|data ( ) ;" always ") . c_str|data ( ) ;"
Line 2005
  is_implicit_std_string always {!<=-1,!>=2}
  is_implicit_std_string always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
Line 2006
  tok2 always symbolic=(tok->next())
Line 2007
  tok2 always symbolic=(tok->next())
  != always {!<=-1,!>=2}
  search_end always symbolic=(tok2->link())
Line 2008
  ( always {!<=-1,!>=2}
  "+ %var%" always "+ %var%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2009
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2010
  is_implicit_std_string always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2012
  ( always {!<=-1,!>=2}
  "+ std :: string|wstring (" always "+ std :: string|wstring ("
Line 2013
  is_implicit_std_string always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2018
  is_implicit_std_string {symbolic=(printInconclusive),!<=-1,!>=2,1}
Line 2019
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2022
  local always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2023
  ptrOrRef always {!<=-1,!>=2}
  ptrOrRef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2024
  = always 0
  nullptr always 0
Line 2025
  = always 0
  nullptr always 0
Line 2026
  funcStr always {!<=-1,!>=2}
  funcStr always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2027
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  "%var% ." always "%var% ."
Line 2028
  local always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
Line 2029
  refToNonLocal always {!<=-1,!>=2}
  refToNonLocal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2030
  tok2 always symbolic=(tok->next())
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  ( always !0
  ( always {!<=-1,!>=2}
Line 2031
  tok2 always symbolic=(tok->next())
  ( always !0
Line 2032
  refToNonLocal always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2033
  ( always {!<=-1,!>=2}
  refTok always symbolic=(tok2->variable()->nameToken())
  "%var% = %var% .|;|[" always "%var% = %var% .|;|["
Line 2034
  refToNonLocal always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  refTok always symbolic=(tok2->variable()->nameToken())
  2 always 2
Line 2036
  ptrOrRef always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  refToNonLocal {!<=-1,!>=2,0,1}
  || always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  && always {!<=-1,!>=2}
  tok2 always symbolic=(tok->next())
  ( always !0
  ( always {!<=-1,!>=2}
Line 2038
  tok2 possible symbolic=(tok->next())
Line 2039
  ( always {!<=-1,!>=2}
  tok2 {symbolic=(tok->next()),!0}
  "%var% .|::" always "%var% .|::"
Line 2040
  ptrOrRef always {!<=-1,!>=2}
Line 2041
  local always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2042
  tok2 always !0
Line 2043
  tok2 always !0
  2 always 2
Line 2044
  ( always {!<=-1,!>=2}
  tok2 always !0
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always !0
  1 always 1
  ") ." always ") ."
Line 2045
  tok2 always !0
Line 2046
  local always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2047
  funcStr always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok2 always !0
  == always {!<=-1,!>=2}
  "str" always "str"
Line 2048
  tok2 always !0
  1 always 1
  2 always 2
Line 2053
  ( always {!<=-1,!>=2}
  tok2 possible {symbolic=(tok->next()),0}
  "c_str|data ( ) ;" always "c_str|data ( ) ;"
Line 2054
  local always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lastVar always !0
  ( always {!<=-1,!>=2}
Line 2055
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2056
  funcStr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lastVar always !0
  ( always {!<=-1,!>=2}
Line 2057
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2058
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  lastFunc always !0
  -3 always -3
  "std :: string|wstring" always "std :: string|wstring"
Line 2059
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2062
  err {!<=-1,!>=2,1}
Line 2063
  == always {!<=-1,!>=2}
Line 2075
  tok possible 0@140
  :: always 1
  error always 1
  "stlcstrthrow" always "stlcstrthrow"
  "Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception.\nDangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid." always "Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception.\nDangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid."
Line 2081
  tok possible 0@137
  :: always 1
  error always 1
  "stlcstr" always "stlcstr"
  "Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.\nDangerous usage of c_str(). The c_str() return value is only valid until its string is deleted." always "Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.\nDangerous usage of c_str(). The c_str() return value is only valid until its string is deleted."
Line 2082
  :: always 0
  normal always 0
Line 2087
  tok possible 0@138
  :: always 4
  performance always 4
  "stlcstrReturn" always "stlcstrReturn"
  "Returning the result of c_str() in a function that returns std::string is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string." always "Returning the result of c_str() in a function that returns std::string is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly returning the string."
Line 2088
  :: always 0
  normal always 0
Line 2094
  "Passing the result of c_str() to a function that takes std::string as argument no. " always "Passing the result of c_str() to a function that takes std::string as argument no. "
  number possible 0@139
  " is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly passing the string." always " is slow and redundant.\nThe conversion from const char* as returned by c_str() to std::string creates an unnecessary string copy. Solve that by directly passing the string."
Line 2096
  tok possible 0@139
  :: always 4
  performance always 4
  "stlcstrParam" always "stlcstrParam"
  :: always 0
  normal always 0
Line 2105
  "deque" always "deque"
  "forward_list" always "forward_list"
  "list" always "list"
Line 2106
  "map" always "map"
  "multimap" always "multimap"
  "multiset" always "multiset"
  "set" always "set"
  "string" always "string"
Line 2107
  "unordered_map" always "unordered_map"
  "unordered_multimap" always "unordered_multimap"
  "unordered_multiset" always "unordered_multiset"
Line 2108
  "unordered_set" always "unordered_set"
  "vector" always "vector"
  "wstring" always "wstring"
Line 2115
  printPerformance always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 4
  performance always 4
Line 2116
  printWarning always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2117
  ! {!<=-1,!>=2,1}
  printPerformance {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  printWarning always {!<=-1,!>=2}
Line 2121
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 2122
  != always {!<=-1,!>=2}
Line 2123
  printWarning {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . compare|find|rfind|find_first_not_of|find_first_of|find_last_not_of|find_last_of ( %name% [,)]" always "%var% . compare|find|rfind|find_first_not_of|find_first_of|find_last_not_of|find_last_of ( %name% [,)]"
  && always {!<=-1,!>=2}
Line 2124
  == always {!<=-1,!>=2}
  4 always 4
Line 2126
  ! {!<=-1,!>=2,1}
  var {symbolic=(tok->variable()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2128
  4 always 4
  2 always 2
Line 2129
  printPerformance {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . swap ( %name% )" always "%var% . swap ( %name% )"
  && always {!<=-1,!>=2}
Line 2130
  == always {!<=-1,!>=2}
  4 always 4
Line 2132
  ! {!<=-1,!>=2,1}
  var {symbolic=(tok->variable()),0}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
  ( always {!<=-1,!>=2}
Line 2135
  printPerformance {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . substr (" always "%var% . substr ("
  && always {!<=-1,!>=2}
Line 2136
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2137
  ( always {!<=-1,!>=2}
  4 always 4
  "0| )" always "0| )"
Line 2138
  false always 0
Line 2139
  4 always 4
  == always {!<=-1,!>=2}
  "0" always "0"
  && always {!<=-1,!>=2}
  3 always 3
  -1 always -1
  == always {!<=-1,!>=2}
  "npos" always "npos"
Line 2140
  ! always {!<=-1,!>=2}
  3 always 3
Line 2141
  false always 0
Line 2142
  ( always {!<=-1,!>=2}
  3 always 3
  -2 always -2
  ", 0 )" always ", 0 )"
Line 2143
  true always 1
Line 2144
  printWarning always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{};] %var% . empty ( ) ;" always "[{};] %var% . empty ( ) ;"
  && always {!<=-1,!>=2}
Line 2145
  ! always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
Line 2146
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2148
  ( always {!<=-1,!>=2}
  "[{};] std :: remove|remove_if|unique (" always "[{};] std :: remove|remove_if|unique ("
  && always {!<=-1,!>=2}
  5 always 5
Line 2149
  3 always 3
Line 2158
  "$symbol:" always "$symbol:"
  varname possible "str"@144
  '\n' always 10
Line 2159
  "$symbol:" always "$symbol:"
  function possible "find"@144
  '\n' always 10
Line 2160
  "It is inefficient to call '" always "It is inefficient to call '"
  varname possible "str"@144
  "." always "."
  function possible "find"@144
  "(" always "("
  varname possible "str"@144
  ")' as it always returns 0.\n" always ")' as it always returns 0.\n"
Line 2161
  "'std::string::" always "'std::string::"
  function possible "find"@144
  "()' returns zero when given itself as parameter " always "()' returns zero when given itself as parameter "
Line 2162
  "(" always "("
  varname possible "str"@144
  "." always "."
  function possible "find"@144
  "(" always "("
  varname possible "str"@144
  ")). As it is currently the " always ")). As it is currently the "
Line 2163
  "code is inefficient. It is possible either the string searched ('" always "code is inefficient. It is possible either the string searched ('"
Line 2164
  varname possible "str"@144
  "') or searched for ('" always "') or searched for ('"
  varname possible "str"@144
  "') is wrong." always "') is wrong."
Line 2165
  tok possible 0@144
  :: always 2
  warning always 2
  "uselessCallsCompare" always "uselessCallsCompare"
  :: always 0
  normal always 0
Line 2170
  tok possible 0@145
  :: always 4
  performance always 4
  "uselessCallsSwap" always "uselessCallsSwap"
Line 2171
  "$symbol:" always "$symbol:"
  varname possible "str"@145
  "\nIt is inefficient to swap a object with itself by calling '$symbol.swap($symbol)'\nThe 'swap()' function has no logical effect when given itself as parameter ($symbol.swap($symbol)). As it is currently the code is inefficient. Is the object or the parameter wrong here?" always "\nIt is inefficient to swap a object with itself by calling '$symbol.swap($symbol)'\nThe 'swap()' function has no logical effect when given itself as parameter ($symbol.swap($symbol)). As it is currently the code is inefficient. Is the object or the parameter wrong here?"
Line 2175
  :: always 0
  normal always 0
Line 2178
  , always {!<=-1,!>=2}
  empty always {!<=-1,!>=2}
Line 2180
  empty {!<=-1,!>=2,0@22,1@27}
Line 2181
  :: always 4
  performance always 4
  "uselessCallsSubstr" always "uselessCallsSubstr"
  "Ineffective call of function 'substr' because it returns an empty string." always "Ineffective call of function 'substr' because it returns an empty string."
  :: always 0
  normal always 0
Line 2183
  tok possible 0@146
  :: always 4
  performance always 4
  "uselessCallsSubstr" always "uselessCallsSubstr"
  "Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead." always "Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead."
  :: always 0
  normal always 0
Line 2188
  tok possible 0@147
  :: always 2
  warning always 2
  "uselessCallsEmpty" always "uselessCallsEmpty"
  "Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?" always "Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?"
  :: always 0
  normal always 0
Line 2193
  tok possible 0@148
  :: always 2
  warning always 2
  "uselessCallsRemove" always "uselessCallsRemove"
Line 2194
  "$symbol:" always "$symbol:"
  function possible "remove"@148
  "\nReturn value of std::$symbol() ignored. Elements remain in container.\nThe return value of std::$symbol() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them." always "\nReturn value of std::$symbol() ignored. Elements remain in container.\nThe return value of std::$symbol() is ignored. This function returns an iterator to the end of the range containing those elements that should be kept. Elements past new end remain valid but with unspecified values. Use the erase method of the container to delete them."
Line 2197
  :: always 0
  normal always 0
Line 2204
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2210
  ! always {!<=-1,!>=2}
  . possible 10
  == {!<=-1,!>=2,0}
  :: always 6
  eIf always 6
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2214
  tok always symbolic=(scope.classDef)
Line 2215
  . possible 6
  == {!<=-1,!>=2,0}
  :: always 10
  eDo always 10
Line 2216
  startOfCondition always symbolic=(tok->next())
  2 always 2
Line 2217
  ! always {!<=-1,!>=2}
  startOfCondition possible symbolic=(tok->next())
Line 2219
  startOfCondition always !0
Line 2220
  ! {!<=-1,!>=2,1}
  endOfCondition {symbolic=(startOfCondition->link()),0}
Line 2224
  == always {!<=-1,!>=2}
  :: always 8
  eFor always 8
Line 2225
  2 always 2
  ";" always ";"
  endOfCondition {symbolic=(startOfCondition->link()),!0}
Line 2226
  ! always {!<=-1,!>=2}
Line 2228
  startOfCondition always !0
  ";" always ";"
  endOfCondition always !0
Line 2229
  ! always {!<=-1,!>=2}
Line 2235
  isOrExpression always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 2236
  "||" always "||"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2237
  isAndExpression always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 2238
  "&&" always "&&"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 2241
  = always 0
  nullptr always 0
Line 2242
  ! {!<=-1,!>=2,1}
  isOrExpression {symbolic=(Token::findsimplematch(startOfCondition,"||",endOfCondition)!=nullptr),!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  isAndExpression {symbolic=(Token::findsimplematch(startOfCondition,"&&",endOfCondition)!=nullptr),!<=-1,!>=2}
Line 2244
  "&& %var% != %name% . end|rend|cend|crend ( )" always "&& %var% != %name% . end|rend|cend|crend ( )"
Line 2245
  isOrExpression {symbolic=(Token::findsimplematch(startOfCondition,"||",endOfCondition)!=nullptr),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isAndExpression {symbolic=(Token::findsimplematch(startOfCondition,"&&",endOfCondition)!=nullptr),!<=-1,!>=2}
Line 2247
  "%oror% %var% == %name% . end|rend|cend|crend ( )" always "%oror% %var% == %name% . end|rend|cend|crend ( )"
Line 2250
  ! always {!<=-1,!>=2}
Line 2252
  validityCheckTok always !0
Line 2257
  "* %varid%" always "* %varid%"
  validityCheckTok always !0
  iteratorVarId always symbolic=(validityCheckTok->next()->varId())
Line 2259
  dereferenceTok always !0
  dereferenceTok always !0
  1 always 1
Line 2266
  printInconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2269
  ( always {!<=-1,!>=2}
  "sizeof|decltype|typeid|typeof (" always "sizeof|decltype|typeid|typeof ("
Line 2274
  ( always {!<=-1,!>=2}
  "%assign%" always "%assign%"
Line 2278
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  ( possible lifetime[Object]=(contValues)
  contValues always size=0
  [ possible lifetime[Lambda]=(printInconclusive)
Line 2279
  ( always {!<=-1,!>=2}
Line 2280
  false always 0
Line 2281
  ! always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2282
  false always 0
Line 2283
  ( always {!<=-1,!>=2}
Line 2289
  ( always {!<=-1,!>=2}
Line 2291
  ! always {!<=-1,!>=2}
  printInconclusive always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2293
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2295
  isInvalidIterator always {!<=-1,!>=2}
  isInvalidIterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2296
  = always 0
  nullptr always 0
Line 2297
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0 always 0
Line 2298
  isInvalidIterator always {!<=-1,!>=2}
  = {!<=-1,!>=2,>=0}
  . {>=0,!<=-1}
  > {!<=-1,!>=2,>=0}
  0 always 0
Line 2299
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 2300
  isInvalidIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2302
  = possible lifetime[Iterator]=(contValues)
  ( possible lifetime[Iterator]=(contValues)
  ( {lifetime[Iterator]=(contValues),start=0}
  ( {lifetime[Iterator]=(contValues),end=0}
Line 2303
  != always {!<=-1,!>=2}
Line 2304
  false always 0
Line 2305
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 2306
  true always 1
Line 2307
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 2308
  true always 1
Line 2309
  false always 0
Line 2311
  it possible lifetime[Iterator]=(contValues)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(contValues),end=0}
Line 2313
  = {lifetime[Object]=(contValues),!0}
  & {lifetime[Object]=(contValues),!0}
  it {lifetime[Iterator]=(contValues),!symbolic=(contValues.end()),!end=0}
Line 2314
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  cValue {lifetime[Object]=(contValues),symbolic=(&*it),!0}
Line 2315
  isInvalidIterator always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2317
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2318
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2319
  = always 0
  nullptr always 0
Line 2320
  = always 0
  nullptr always 0
Line 2321
  cValue possible {lifetime[Object]=(contValues),symbolic=(&*it),0}
  && always {!<=-1,!>=2}
  cValue {lifetime[Object]=(contValues),!0}
  == always {!<=-1,!>=2}
  0 always 0
Line 2322
  ( always {!<=-1,!>=2}
  "+|-" always "+|-"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 2323
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 2324
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 2327
  = possible 0
  ( possible 0
Line 2330
  ( always {!<=-1,!>=2}
  "++|--" always "++|--"
Line 2334
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unknown {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isInvalidIterator always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2335
  ! always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 2337
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 2339
  cValue possible lifetime[Object]=(contValues)
Line 2340
  cValue {lifetime[Object]=(contValues),!0}
Line 2341
  cValue {lifetime[Object]=(contValues),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2342
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2345
  emptyAdvance always !0
Line 2347
  cValue always !0
Line 2348
  advanceIndex possible 0
  ? possible ""
  advanceIndex always !0
  : always ""
  "" always ""
Line 2349
  nullptr always 0
Line 2351
  cValue always !0
  & always !0
Line 2353
  & always !0
  inconclusive always {!<=-1,!>=2}
Line 2359
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 2361
  = possible "var"
  tok possible 0
  ? possible "var"
  tok always !0
  : always "var"
  "var" always "var"
Line 2362
  "$symbol:" always "$symbol:"
  '\n' always 10
  value possible 0
  ? possible 0
  value always !0
  . possible 0
  : always 0
  nullptr always 0
  " or there is possible dereference of an invalid iterator: $symbol." always " or there is possible dereference of an invalid iterator: $symbol."
Line 2363
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 2364
  tok possible 0
  :: always 1
  error always 1
  "derefInvalidIterator" always "derefInvalidIterator"
  "Dereference of an invalid iterator" always "Dereference of an invalid iterator"
  :: always 0
  normal always 0
Line 2365
  tok possible 0
  :: always 2
  warning always 2
  "derefInvalidIteratorRedundantCheck" always "derefInvalidIteratorRedundantCheck"
  :: always 0
  normal always 0
Line 2368
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  value always !0
  inconclusive {!<=-1,!>=2,0}
Line 2371
  tok always !0
  value always !0
  "Dereference of an invalid iterator" always "Dereference of an invalid iterator"
Line 2373
  value always !0
Line 2374
  :: always 2
  warning always 2
  "derefInvalidIteratorRedundantCheck" always "derefInvalidIteratorRedundantCheck"
  inconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  : always 0
  :: always 0
  normal always 0
Line 2377
  value always !0
  ( {!<=-1,!>=2,0}
  "Dereference" always "Dereference"
  : always "Possible dereference"
  "Possible dereference" always "Possible dereference"
  " of an invalid iterator" always " of an invalid iterator"
Line 2378
  ! {!<=-1,!>=2,0}
  varname possible size=0
  ( {!<=-1,!>=2,1}
Line 2379
  "$symbol:" always "$symbol:"
  varname always !size=0
  '\n' always 10
  ": $symbol" always ": $symbol"
Line 2382
  value always !0
  ( always {!<=-1,!>=2}
  :: always 1
  error always 1
  : always 2
  :: always 2
  warning always 2
Line 2383
  "derefInvalidIterator" always "derefInvalidIterator"
Line 2385
  inconclusive always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  value always !0
  ( always {!<=-1,!>=2}
  : always 0
  :: always 0
  normal always 0
Line 2391
  deref possible 0@149
  :: always 2
  warning always 2
Line 2392
  "derefInvalidIterator" always "derefInvalidIterator"
Line 2393
  "$symbol:" always "$symbol:"
  iterName possible "i"@149
  "\nPossible dereference of an invalid iterator: $symbol\nPossible dereference of an invalid iterator: $symbol. Make sure to check that the iterator is valid before dereferencing it - not after." always "\nPossible dereference of an invalid iterator: $symbol\nPossible dereference of an invalid iterator: $symbol. Make sure to check that the iterator is valid before dereferencing it - not after."
Line 2395
  :: always 0
  normal always 0
Line 2400
  tok possible 0@150
  tok always !0
  "var" always "var"
Line 2403
  && always {!<=-1,!>=2}
  value always !0
Line 2404
  "Reading from container '$symbol'. " always "Reading from container '$symbol'. "
  value always !0
  . always !0
  " or '$symbol' can be empty." always " or '$symbol' can be empty."
Line 2406
  = always "Reading from empty STL container '$symbol'"
  "Reading from empty STL container '$symbol'" always "Reading from empty STL container '$symbol'"
Line 2408
  tok possible 0@150
  value possible 0
  "Reading from empty container" always "Reading from empty container"
Line 2410
  value possible 0
  ? possible 3
  value always !0
  ( always {!<=-1,!>=2}
  :: always 1
  error always 1
  : always 2
  :: always 2
  warning always 2
  : always 3
  :: always 3
  style always 3
  "reademptycontainer" always "reademptycontainer"
  "$symbol:" always "$symbol:"
  "\n" always "\n"
  ! {!<=-1,!>=2,1}
  value possible 0
  ? possible 0
  : always 0
  :: always 0
  normal always 0
Line 2415
  tok possible {symbolic=(memberAccessTok->astOperand2())@99,0@151}
  :: always 3
  style always 3
  "useStlAlgorithm" always "useStlAlgorithm"
Line 2416
  "Consider using " always "Consider using "
  algoName possible {"std::copy_if"@122,""@151,"std::transform"@89,size=14@89,"std::fill"@89,size=9@89,"std::copy"@99,"std::transform"@99,"std::transform"@102,"std::distance"@102}
  " algorithm instead of a raw loop." always " algorithm instead of a raw loop."
  :: always 0
  normal always 0
Line 2419
  ( always {!<=-1,!>=2}
Line 2421
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2422
  return always {!<=-1,!>=2}
  false always 0
Line 2424
  "return|throw|break" always "return|throw|break"
  endToken always symbolic=(start->link())
Line 2425
  ! always {!<=-1,!>=2}
Line 2426
  return always {!<=-1,!>=2}
  false always 0
Line 2427
  tok always !0
  "; }" always "; }"
  endToken always symbolic=(start->link())
Line 2428
  ! always {!<=-1,!>=2}
  endStatement always symbolic=(Token::findsimplematch(tok,"; }",endToken))
Line 2429
  return always {!<=-1,!>=2}
  false always 0
Line 2430
  endStatement {symbolic=(Token::findsimplematch(tok,"; }",endToken)),!0}
  != always {!<=-1,!>=2}
Line 2431
  return always {!<=-1,!>=2}
  false always 0
Line 2432
  return always {!<=-1,!>=2}
  true always 1
Line 2437
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2438
  nullptr always 0
Line 2440
  ";" always ";"
Line 2441
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endStatement always symbolic=(Token::findsimplematch(start->next(),";"))
  "; }" always "; }"
Line 2442
  nullptr always 0
Line 2443
  endStatement always symbolic=(Token::findsimplematch(start->next(),";"))
  != always {!<=-1,!>=2}
  endToken always symbolic=(start->link())
Line 2444
  nullptr always 0
Line 2448
  input always {!<=-1,!>=2}
Line 2451
  ! always {!<=-1,!>=2}
Line 2452
  nullptr always 0
Line 2453
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% %assign%" always "%var% %assign%"
Line 2454
  nullptr always 0
Line 2455
  2 always 2
Line 2456
  ( always {!<=-1,!>=2}
  endStatement always !0
  false always 0
  nullptr always 0
  true always 1
Line 2457
  nullptr always 0
Line 2458
  ( always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  true always 1
Line 2459
  nullptr always 0
Line 2460
  input always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% =" always "%var% ="
Line 2464
  input always {!<=-1,!>=2}
Line 2466
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2467
  nullptr always 0
Line 2469
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . %name% (" always "%var% . %name% ("
Line 2470
  nullptr always 0
Line 2471
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  4 always 4
  ") ; }" always ") ; }"
Line 2472
  nullptr always 0
Line 2473
  4 always 4
Line 2474
  != always {!<=-1,!>=2}
Line 2475
  nullptr always 0
Line 2477
  2 always 2
Line 2478
  ! always {!<=-1,!>=2}
  2 always 2
  "%varid%" always "%varid%"
Line 2479
  nullptr always 0
Line 2480
  input always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% . %name% ( %varid% )" always "%var% . %name% ( %varid% )"
Line 2481
  ( always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  true always 1
Line 2482
  nullptr always 0
Line 2486
  input always {!<=-1,!>=2}
Line 2488
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2489
  nullptr always 0
Line 2490
  = always 0
  nullptr always 0
Line 2491
  ( always {!<=-1,!>=2}
  "++ %var% ; }" always "++ %var% ; }"
Line 2492
  2 always 2
Line 2493
  ( always {!<=-1,!>=2}
  "%var% ++ ; }" always "%var% ++ ; }"
Line 2494
  1 always 1
Line 2495
  ! always {!<=-1,!>=2}
Line 2496
  nullptr always 0
Line 2497
  input always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  varTok always !0
  == always {!<=-1,!>=2}
Line 2498
  varTok always !0
Line 2503
  != always {!<=-1,!>=2}
  "{" always "{"
Line 2504
  nullptr always 0
Line 2506
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 2507
  nullptr always 0
Line 2508
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") {" always ") {"
Line 2509
  nullptr always 0
Line 2510
  2 always 2
Line 2512
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  endBodyTok always symbolic=(bodyTok->link())
  "} }" always "} }"
Line 2513
  nullptr always 0
Line 2514
  endBodyTok always symbolic=(bodyTok->link())
  != always {!<=-1,!>=2}
Line 2515
  nullptr always 0
Line 2516
  ! always {!<=-1,!>=2}
  "%varid%" always "%varid%"
Line 2517
  nullptr always 0
Line 2518
  ( always {!<=-1,!>=2}
  false always 0
  nullptr always 0
  true always 1
Line 2519
  nullptr always 0
Line 2523
  ( always {!<=-1,!>=2}
Line 2525
  ( always {!<=-1,!>=2}
  "+= %any% ;" always "+= %any% ;"
  && always {!<=-1,!>=2}
Line 2526
  1 always 1
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2527
  1 always 1
  1 always 1
Line 2528
  return always {!<=-1,!>=2}
  true always 1
Line 2530
  ( always {!<=-1,!>=2}
  "= %varid% + %any% ;" always "= %varid% + %any% ;"
  varid possible symbolic=(assignTok->astOperand1()->varId())@82
  && always {!<=-1,!>=2}
Line 2531
  3 always 3
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 2532
  3 always 3
  1 always 1
Line 2533
  return always {!<=-1,!>=2}
  true always 1
Line 2535
  return always {!<=-1,!>=2}
  false always 0
Line 2538
  ( always {!<=-1,!>=2}
Line 2540
  ( always {!<=-1,!>=2}
  "%assign% %bool% ;" always "%assign% %bool% ;"
  && always {!<=-1,!>=2}
Line 2541
  1 always 1
  ( always {!<=-1,!>=2}
Line 2542
  return always {!<=-1,!>=2}
  true always 1
Line 2544
  ( always {!<=-1,!>=2}
  "= %varid% %oror%|%or%|&&|& %bool% ;" always "= %varid% %oror%|%or%|&&|& %bool% ;"
  varid possible symbolic=(assignTok->astOperand1()->varId())@111
  && always {!<=-1,!>=2}
Line 2545
  3 always 3
  ( always {!<=-1,!>=2}
Line 2546
  return always {!<=-1,!>=2}
  true always 1
Line 2548
  return always {!<=-1,!>=2}
  false always 0
Line 2551
  ( always {!<=-1,!>=2}
Line 2554
  ( always {!<=-1,!>=2}
  "&=" always "&="
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "|=" always "|="
Line 2555
  return always {!<=-1,!>=2}
  true always 1
Line 2557
  ( always {!<=-1,!>=2}
  "= %varid% %oror%|%or%|&&|&" always "= %varid% %oror%|%or%|&&|&"
  varid possible symbolic=(assignTok->astOperand1()->varId())@83
Line 2558
  return always {!<=-1,!>=2}
  true always 1
Line 2560
  return always {!<=-1,!>=2}
  false always 0
Line 2563
  ( always {!<=-1,!>=2}
Line 2565
  ( possible {symbolic=(var1),symbolic=(var2)}
  == always {!<=-1,!>=2}
  ( possible {symbolic=(var1),symbolic=(var2)}
Line 2566
  return always {!<=-1,!>=2}
  false always 0
Line 2567
  ( {symbolic=(var2),!symbolic=(tok->astOperand2()->varId())}
  == always {!<=-1,!>=2}
  var1 possible symbolic=(tok->astOperand2()->varId())
  || always {!<=-1,!>=2}
  ( always {!symbolic=(tok->astOperand2()->varId()),!symbolic=(var1)}
  == always {!<=-1,!>=2}
Line 2568
  ( {symbolic=(var2),!symbolic=(tok->astOperand1()->varId())}
  == always {!<=-1,!>=2}
  var1 possible symbolic=(tok->astOperand1()->varId())
  || always {!<=-1,!>=2}
  ( always {!symbolic=(tok->astOperand1()->varId()),!symbolic=(var1)}
  == always {!<=-1,!>=2}
Line 2569
  return always {!<=-1,!>=2}
  true always 1
Line 2572
  return always {!<=-1,!>=2}
  false always 0
Line 2577
  algo possible size=16
  == always {!<=-1,!>=2}
  "std::max_element" always "std::max_element"
Line 2578
  "std::min_element" always "std::min_element"
Line 2579
  == always {!<=-1,!>=2}
  "std::min_element" always "std::min_element"
Line 2580
  "std::max_element" always "std::max_element"
Line 2584
  , always 0
  invert always {!<=-1,!>=2}
  = always 0
  false always 0
Line 2586
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<|<=|>=|>" always "<|<=|>=|>"
Line 2587
  "std::accumulate" always "std::accumulate"
Line 2588
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  assignVar possible {symbolic=(condTok->astOperand1()->varId()),symbolic=(assignTok->astOperand1()->varId())@86}
Line 2589
  "std::accumulate" always "std::accumulate"
Line 2590
  = always "std::max_element"
  "std::max_element" always "std::max_element"
Line 2591
  ( always {!<=-1,!>=2}
  "<|<=" always "<|<="
Line 2592
  = always "std::min_element"
  "std::min_element" always "std::min_element"
Line 2593
  == always {!<=-1,!>=2}
Line 2595
  invert always {!<=-1,!>=2}
Line 2602
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2605
  != always {!<=-1,!>=2}
Line 2607
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for (" always "for ("
Line 2609
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 2613
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  splitTok always symbolic=(tok->next()->astOperand2())
  ":" always ":"
Line 2615
  splitTok always symbolic=(tok->next()->astOperand2())
Line 2616
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  loopVar always symbolic=(splitTok->previous())
  "%var%" always "%var%"
Line 2620
  useLoopVarInAssign always {!<=-1,!>=2}
Line 2621
  loopVar always symbolic=(splitTok->previous())
  useLoopVarInAssign {!<=-1,!>=2,Uninit}
Line 2623
  assignTok always !0
Line 2625
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),symbolic=(loopVar->varId())}
  == {!<=-1,!>=2,1}
  loopVar always symbolic=(splitTok->previous())
Line 2626
  useLoopVarInAssign always {!<=-1,!>=2}
Line 2627
  = always "std::transform"
  "std::transform" always "std::transform"
Line 2628
  ( always {!<=-1,!>=2}
  assignTok always !0
  "%var%|%bool%|%num%|%char% ;" always "%var%|%bool%|%num%|%char% ;"
Line 2629
  = always "std::fill"
  "std::fill" always "std::fill"
Line 2630
  ( always {!<=-1,!>=2}
  assignTok always !0
  "%name% ( )" always "%name% ( )"
Line 2631
  = always "std::generate"
  "std::generate" always "std::generate"
Line 2633
  = always "std::fill or std::generate"
  "std::fill or std::generate" always "std::fill or std::generate"
Line 2635
  ( always {!<=-1,!>=2}
  assignTok always !0
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2636
  = always "std::distance"
  "std::distance" always "std::distance"
Line 2637
  ( always {!<=-1,!>=2}
  assignTok always !0
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2638
  = always "std::any_of, std::all_of, std::none_of, or std::accumulate"
  "std::any_of, std::all_of, std::none_of, or std::accumulate" always "std::any_of, std::all_of, std::none_of, or std::accumulate"
Line 2639
  ( always {!<=-1,!>=2}
  assignTok always !0
  "= %var% <|<=|>=|> %var% ? %var% : %var%" always "= %var% <|<=|>=|> %var% ? %var% : %var%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  assignTok always !0
  6 always 6
  loopVar always symbolic=(splitTok->previous())
  ( always !symbolic=(assignVarId)
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2640
  assignTok always !0
  2 always 2
  loopVar always symbolic=(splitTok->previous())
  ( always !symbolic=(assignVarId)
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
  assignTok always !0
  5 always 5
  == always {!<=-1,!>=2}
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2642
  = always "std::accumulate"
  "std::accumulate" always "std::accumulate"
Line 2644
  assignTok always !0
  algo possible {"std::transform",size=14,"std::fill",size=9,"std::generate",size=13,"std::fill or std::generate",size=26,"std::distance","std::any_of, std::all_of, std::none_of, or std::accumulate"}
Line 2648
  useLoopVarInMemCall always {!<=-1,!>=2}
Line 2649
  useLoopVarInMemCall {!<=-1,!>=2,Uninit}
Line 2651
  memberAccessTok always !0
Line 2652
  memberAccessTok always !0
Line 2653
  contVarId {symbolic=(memberAccessTok->astOperand1()->varId()),symbolic=(loopVar->varId())}
  == {!<=-1,!>=2,1}
Line 2655
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  ( possible {size=10,size=12}
  == {!<=-1,!>=2,0}
  "push_back" always "push_back"
  || always {!<=-1,!>=2}
Line 2656
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  == always {!<=-1,!>=2}
  "push_front" always "push_front"
  || always {!<=-1,!>=2}
Line 2657
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  == always {!<=-1,!>=2}
  "emplace_back" always "emplace_back"
Line 2659
  useLoopVarInMemCall always {!<=-1,!>=2}
Line 2660
  = always "std::copy"
  "std::copy" always "std::copy"
Line 2662
  = always "std::transform"
  "std::transform" always "std::transform"
Line 2663
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  algo possible {"std::copy",size=9,"std::transform",size=14}
Line 2669
  useLoopVarInIncrement always {!<=-1,!>=2}
Line 2670
  useLoopVarInIncrement {!<=-1,!>=2,Uninit}
Line 2673
  useLoopVarInIncrement always {!<=-1,!>=2}
Line 2674
  = always "std::transform"
  "std::transform" always "std::transform"
Line 2676
  = always "std::distance"
  "std::distance" always "std::distance"
Line 2677
  incrementTok always !0
  algo possible {"std::transform",size=14,"std::distance",size=13}
Line 2685
  condBodyTok always !0
  useLoopVarInAssign always {!<=-1,!>=2}
Line 2687
  assignTok always !0
Line 2689
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),symbolic=(loopVar->varId())}
  == {!<=-1,!>=2,1}
Line 2690
  useLoopVarInAssign always {!<=-1,!>=2}
Line 2691
  = always "std::transform"
  "std::transform" always "std::transform"
Line 2693
  = always "std::replace_if"
  "std::replace_if" always "std::replace_if"
Line 2695
  ( always {!<=-1,!>=2}
  assignTok always !0
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2696
  = always "std::count_if"
  "std::count_if" always "std::count_if"
Line 2697
  ( always {!<=-1,!>=2}
  assignTok always !0
  assignVarId {symbolic=(assignTok->astOperand1()->varId()),!symbolic=(loopVar->varId())}
Line 2698
  = always "std::any_of, std::all_of, std::none_of, or std::accumulate"
  "std::any_of, std::all_of, std::none_of, or std::accumulate" always "std::any_of, std::all_of, std::none_of, or std::accumulate"
Line 2700
  = always "std::accumulate"
  "std::accumulate" always "std::accumulate"
Line 2702
  assignTok always !0
  algo possible {"std::transform",size=14,"std::replace_if",size=15,"std::count_if",size=13,"std::any_of, std::all_of, std::none_of, or std::accumulate",size=58,"std::accumulate"}
Line 2707
  condBodyTok always !0
  useLoopVarInMemCall always {!<=-1,!>=2}
Line 2709
  memberAccessTok always !0
Line 2710
  memberAccessTok always !0
Line 2711
  contVarId {symbolic=(memberAccessTok->astOperand1()->varId()),symbolic=(loopVar->varId())}
  == {!<=-1,!>=2,1}
Line 2713
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  ( possible {size=10,size=12}
  == {!<=-1,!>=2,0}
  "push_back" always "push_back"
  || always {!<=-1,!>=2}
Line 2714
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  == always {!<=-1,!>=2}
  "push_front" always "push_front"
  || always {!<=-1,!>=2}
Line 2715
  memberCallTok always symbolic=(memberAccessTok->astOperand2())
  == always {!<=-1,!>=2}
  "emplace_back" always "emplace_back"
Line 2716
  useLoopVarInMemCall always {!<=-1,!>=2}
Line 2717
  memberAccessTok always !0
  "std::copy_if" always "std::copy_if"
Line 2724
  useLoopVarInIncrement always {!<=-1,!>=2}
Line 2727
  useLoopVarInIncrement always {!<=-1,!>=2}
Line 2728
  = always "std::transform"
  "std::transform" always "std::transform"
Line 2730
  = always "std::count_if"
  "std::count_if" always "std::count_if"
Line 2731
  incrementTok always !0
  algo possible {"std::transform",size=14,"std::count_if",size=13}
Line 2736
  ( always {!<=-1,!>=2}
Line 2737
  "%varid%" always "%varid%"
Line 2740
  = always "std::find_if"
  "std::find_if" always "std::find_if"
Line 2742
  = always "std::any_of"
  "std::any_of" always "std::any_of"
Line 2743
  algo possible {"std::find_if",size=12,"std::any_of",size=11}
Line 2753
  tok possible {symbolic=(splitTok->astOperand2())@52,symbolic=(args[argnr-1])@55,0@152}
  tok always !0
  "var" always "var"
Line 2756
  ( always {!<=-1,!>=2}
  tok possible 0@152
Line 2757
  "Using " always "Using "
  " with iterator '" always " with iterator '"
  "' that is always empty." always "' that is always empty."
Line 2759
  "Iterating over container '" always "Iterating over container '"
  "' that is always empty." always "' that is always empty."
Line 2762
  tok possible 0@152
  :: always 3
  style always 3
Line 2763
  "knownEmptyContainer" always "knownEmptyContainer"
Line 2764
  msg possible symbolic=("Iterating over container '"+var+"' that is always empty.")
  :: always 0
  normal always 0
Line 2767
  ( always {!<=-1,!>=2}
Line 2769
  ! always {!<=-1,!>=2}
  tok possible {symbolic=(splitTok->astOperand2())@51,symbolic=(args[argnr-1])@54}
Line 2770
  return always {!<=-1,!>=2}
  false always 0
Line 2771
  tok {!0,symbolic=(splitTok->astOperand2())@51,symbolic=(args[argnr-1])@54}
Line 2772
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2774
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2776
  != always {!<=-1,!>=2}
  0 always 0
Line 2778
  return always {!<=-1,!>=2}
  true always 1
Line 2780
  return always {!<=-1,!>=2}
  false always 0
Line 2785
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 2788
  != always {!<=-1,!>=2}
Line 2790
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ( !!)" always "%name% ( !!)"
Line 2794
  == always {!<=-1,!>=2}
  "for" always "for"
Line 2795
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 2798
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  splitTok always symbolic=(tok->next()->astOperand2())
  ":" always ":"
Line 2800
  splitTok always symbolic=(tok->next()->astOperand2())
Line 2801
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  contTok always symbolic=(splitTok->astOperand2())
Line 2803
  contTok always symbolic=(splitTok->astOperand2())
  "" always ""
Line 2805
  args possible size=0
Line 2806
  ( always {!<=-1,!>=2}
Line 2809
  = always 1
  1 always 1
  argnr possible 1
  <= {!<=-1,!>=2,1}
  args always !size=0
  ( always !<=0
Line 2810
  argnr {<=symbolic=(args.size()),!>=symbolic=(args.size()+1),1}
Line 2811
  ! always {!<=-1,!>=2}
Line 2813
  args always !size=0
  argnr possible 1
  - possible 0
  1 always 1
Line 2814
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argTok always symbolic=(args[argnr-1])
Line 2816
  argTok always symbolic=(args[argnr-1])
Line 2825
  ( always {!<=-1,!>=2}
Line 2827
  var possible symbolic=(tok->variable())@17
Line 2828
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: mutex|recursive_mutex|timed_mutex|recursive_timed_mutex|shared_mutex" always "std :: mutex|recursive_mutex|timed_mutex|recursive_timed_mutex|shared_mutex"
Line 2831
  ( always {!<=-1,!>=2}
Line 2833
  var possible symbolic=(tok->variable())@22
Line 2834
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: lock_guard|unique_lock|scoped_lock|shared_lock" always "std :: lock_guard|unique_lock|scoped_lock|shared_lock"
Line 2837
  ( always {!<=-1,!>=2}
Line 2839
  ! always {!<=-1,!>=2}
Line 2840
  return always {!<=-1,!>=2}
  false always 0
Line 2841
  ( always {!<=-1,!>=2}
  var always !0
Line 2842
  return always {!<=-1,!>=2}
  false always 0
Line 2843
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
Line 2848
  tok possible 0@153
  :: always 2
  warning always 2
Line 2849
  "globalLockGuard" always "globalLockGuard"
Line 2850
  "Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program." always "Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program."
  :: always 0
  normal always 0
Line 2855
  tok possible 0@154
  :: always 2
  warning always 2
Line 2856
  "localMutex" always "localMutex"
Line 2857
  "The lock is ineffective because the mutex is locked at the same scope as the mutex itself." always "The lock is ineffective because the mutex is locked at the same scope as the mutex itself."
  :: always 0
  normal always 0
Line 2862
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 2
  warning always 2
Line 2867
  != always {!<=-1,!>=2}
Line 2868
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var%" always "%var%"
Line 2871
  ! always {!<=-1,!>=2}
  var always symbolic=(tok->variable())
Line 2873
  ( always {!<=-1,!>=2}
  "%var% . lock ( )" always "%var% . lock ( )"
Line 2874
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 2876
  ! always {!<=-1,!>=2}
  var always !0
Line 2878
  ( always {!<=-1,!>=2}
Line 2880
  ( always {!<=-1,!>=2}
  "%var% (|{ %var% )|}|," always "%var% (|{ %var% )|}|,"
Line 2881
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var {symbolic=(tok->variable()),!0}
Line 2883
  2 always 2
Line 2884
  ! always {!<=-1,!>=2}
Line 2886
  ! always {!<=-1,!>=2}
  mvar always !0
Line 2888
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 2890
  ( always {!<=-1,!>=2}
  mvar always !0
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,2@13,3@40,4@3}
  flag possible {2@13,3@40,4@3}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
