

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073744749 !@expr1073744750 mTokenizer@var28 ) {
69: instances (@expr1073744751 ) .@expr1073744752 remove (@expr1073744753 this@expr1073744754 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073744755 string (@expr1073744756 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073744757 void ) tokenizer@var21 ;
108: (@expr1073744758 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073744759 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073744760 void ) ctu@var24 ;
120: (@expr1073744761 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073744762 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073744763 0U ) , Certainty ::@expr1073744764 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073744765 list < const Token *@expr1073744766 > callstack@var41 (@expr1073744767 1 , tok@var35 ) ;
141: reportError (@expr1073744768 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073744769 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073744770 0U ) , Certainty ::@expr1073744771 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var64 ;
43: std :: string errorId@var65 ;
44: void setFileName ( const std :: string & s@var66 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var70 ;
47: }
48: int lineNumber@var67 ;
49: Certainty :: CertaintyLevel certainty@var68 ;
50: std :: string symbolNames@var69 ;
51: private:
52: std :: string mFileName@var70 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var104 ( NO_LINE ) , hash@var106 ( 0 ) , thisAndNextLine@var107 ( false ) , matched@var108 ( false ) , checked@var109 ( false ) { }
57: Suppression ( const Suppression & other@var71 ) {
58: *@expr1073744772 this@expr1073744773 =@expr1073744774 other@var71 ;
59: }
60: Suppression ( const std :: string & id@var72 , const std :: string & file@var73 , int line@var74 = NO_LINE ) : errorId@var102 ( id@var72 ) , fileName@var103 ( file@var73 ) , lineNumber@var104 ( line@var74 ) , hash@var106 ( 0 ) , thisAndNextLine@var107 ( false ) , matched@var108 ( false ) , checked@var109 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var75 ) {
63: errorId@var102 =@expr1073744775 other@var75 .@expr1073744776 errorId@var76 ;
64: fileName@var103 =@expr1073744777 other@var75 .@expr1073744778 fileName@var77 ;
65: lineNumber@var104 =@expr1073744779 other@var75 .@expr1073744780 lineNumber@var78 ;
66: symbolName@var105 =@expr1073744781 other@var75 .@expr1073744782 symbolName@var79 ;
67: hash@var106 =@expr1073744783 other@var75 .@expr1073744784 hash@var80 ;
68: thisAndNextLine@var107 =@expr1073744785 other@var75 .@expr1073744786 thisAndNextLine@var81 ;
69: matched@var108 =@expr1073744787 other@var75 .@expr1073744788 matched@var82 ;
70: checked@var109 =@expr1073744789 other@var75 .@expr1073744790 checked@var83 ;
71: return *@expr1073744791 this@expr1073744792 ;
72: }
73:
74: bool operator< ( const Suppression & other@var84 ) const {
75: if (@expr1073744793 errorId@var102 !=@expr1073744794 other@var84 .@expr2971 errorId@var85 ) {
76: return errorId@var102 <@expr1073744796 other@var84 .@expr2971 errorId@var85 ; }
77: if (@expr1073744798 lineNumber@var104 <@expr1073744799 other@var84 .@expr1073744800 lineNumber@var86 ) {
78: return true ; }
79: if (@expr1073744801 fileName@var103 !=@expr1073744802 other@var84 .@expr2979 fileName@var87 ) {
80: return fileName@var103 <@expr1073744804 other@var84 .@expr2979 fileName@var87 ; }
81: if (@expr1073744806 symbolName@var105 !=@expr1073744807 other@var84 .@expr2984 symbolName@var88 ) {
82: return symbolName@var105 <@expr1073744809 other@var84 .@expr2984 symbolName@var88 ; }
83: if (@expr1073744811 hash@var106 !=@expr1073744812 other@var84 .@expr2989 hash@var89 ) {
84: return hash@var106 <@expr1073744814 other@var84 .@expr2989 hash@var89 ; }
85: if (@expr1073744816 thisAndNextLine@var107 !=@expr1073744817 other@var84 .@expr1073744818 thisAndNextLine@var90 ) {
86: return thisAndNextLine@var107 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var91 , std :: string * errorMessage@var92 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var93 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var94 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073744820 fileName@var103 .@expr1073744821 empty (@expr1073744822 ) &&@expr1073744823 fileName@var103 .@expr1073744824 find_first_of (@expr1073744825 "?*" ) ==@expr1073744826 std ::@expr1073744827 string ::@expr1073744828 npos@expr1073744819 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var95 ) const {
109: return errorId@var102 ==@expr1073744829 other@var95 .@expr1073744830 errorId@var96 &&@expr1073744831
110: fileName@var103 ==@expr1073744832 other@var95 .@expr1073744833 fileName@var97 &&@expr1073744834
111: lineNumber@var104 ==@expr1073744835 other@var95 .@expr1073744836 lineNumber@var98 &&@expr1073744837
112: symbolName@var105 ==@expr1073744838 other@var95 .@expr1073744839 symbolName@var99 &&@expr1073744840
113: hash@var106 ==@expr1073744841 other@var95 .@expr1073744842 hash@var100 &&@expr1073744843
114: thisAndNextLine@var107 ==@expr1073744844 other@var95 .@expr1073744845 thisAndNextLine@var101 ;
115: }
116:
117: std :: string errorId@var102 ;
118: std :: string fileName@var103 ;
119: int lineNumber@var104 ;
120: std :: string symbolName@var105 ;
121: unsigned long hash@var106 ;
122: bool thisAndNextLine@var107 ;
123: bool matched@var108 ;
124: bool checked@var109 ;
125:
126: enum Anonymous0 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var110 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var111 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var112 , std :: string * errorMessage@var113 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var114 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var115 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var116 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var117 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var118 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var119 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var120 , const bool unusedFunctionChecking@var121 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var122 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var123 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var124 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var125 , const Color & c@var126 ) ;
42:
43: std :: string toString ( const Color & c@var127 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var129 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var130 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var131 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var132 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var148 ( 0 ) , line@var149 ( 0 ) , column@var150 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var133 , int line@var134 , unsigned int column@var135 )
73: : fileIndex@var148 ( 0 ) , line@var149 ( line@var134 ) , column@var150 ( column@var135 ) , mOrigFileName@var152 ( file@var133 ) , mFileName@var153 ( file@var133 ) { }
74:
75: FileLocation ( const std :: string & file@var136 , const std :: string & info@var137 , int line@var138 , unsigned int column@var139 )
76: : fileIndex@var148 ( 0 ) , line@var149 ( line@var138 ) , column@var150 ( column@var139 ) , mOrigFileName@var152 ( file@var136 ) , mFileName@var153 ( file@var136 ) , mInfo@var154 ( info@var137 ) { }
77:
78: FileLocation ( const Token * tok@var140 , const TokenList * tokenList@var141 ) ;
79: FileLocation ( const Token * tok@var142 , const std :: string & info@var143 , const TokenList * tokenList@var144 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var145 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var146 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var147 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var148 ;
107: int line@var149 ;
108: unsigned int column@var150 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var154 ;
112: }
113: void setinfo ( const std :: string & i@var151 ) {
114: mInfo@var154 =@expr1073744846 i@var151 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var152 ;
119: std :: string mFileName@var153 ;
120: std :: string mInfo@var154 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var155 ,
124: const std :: string & file1@var156 ,
125: Severity :: SeverityType severity@var157 ,
126: const std :: string & msg@var158 ,
127: const std :: string & id@var159 , Certainty :: CertaintyLevel certainty@var160 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var161 ,
129: const std :: string & file1@var162 ,
130: Severity :: SeverityType severity@var163 ,
131: const std :: string & msg@var164 ,
132: const std :: string & id@var165 ,
133: const CWE & cwe@var166 ,
134: Certainty :: CertaintyLevel certainty@var167 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var168 ,
136: const TokenList * list@var169 ,
137: Severity :: SeverityType severity@var170 ,
138: const std :: string & id@var171 ,
139: const std :: string & msg@var172 ,
140: Certainty :: CertaintyLevel certainty@var173 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var174 ,
142: const TokenList * list@var175 ,
143: Severity :: SeverityType severity@var176 ,
144: const std :: string & id@var177 ,
145: const std :: string & msg@var178 ,
146: const CWE & cwe@var179 ,
147: Certainty :: CertaintyLevel certainty@var180 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var181 ,
149: const TokenList * tokenList@var182 ,
150: Severity :: SeverityType severity@var183 ,
151: const char id@var184 [ ] ,
152: const std :: string & msg@var185 ,
153: const CWE & cwe@var186 ,
154: Certainty :: CertaintyLevel certainty@var187 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var188 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var189 ,
176: const std :: string & templateFormat@var190 = emptyString@var1 ,
177: const std :: string & templateLocation@var191 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var192 ) ;
181:
182: std :: list < FileLocation > callStack@var193 ;
183: std :: string id@var194 ;
184:
185:
186: std :: string file0@var195 ;
187:
188: std :: string function@var196 ;
189:
190: bool incomplete@var197 ;
191:
192: Severity :: SeverityType severity@var198 ;
193: CWE cwe@var199 ;
194: Certainty :: CertaintyLevel certainty@var200 ;
195:
196:
197: unsigned long hash@var201 ;
198:
199:
200: void setmsg ( const std :: string & msg@var202 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var204 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var205 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var206 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var203 ) ;
221:
222:
223: std :: string mShortMessage@var204 ;
224:
225:
226: std :: string mVerboseMessage@var205 ;
227:
228:
229: std :: string mSymbolNames@var206 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var207 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073744847 plistFile@var207 .@expr1073744848 is_open (@expr1073744849 ) ) {
243: plistFile@var207 <<@expr1073744850 ErrorLogger ::@expr1073744851 plistFooter (@expr1073744852 ) ;
244: plistFile@var207 .@expr1073744853 close (@expr1073744854 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var208 , Color c@var209 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var210 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var211 , const char stage@var212 [ ] , const unsigned long value@var213 ) {
271: (@expr1073744855 void ) filename@var211 ;
272: (@expr1073744856 void ) stage@var212 ;
273: (@expr1073744857 void ) value@var213 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var214 ) {
281: reportErr (@expr1073744858 msg@var214 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var215 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var216 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var217 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var218 , const std :: vector < std :: string > & files@var219 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var220 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var221 , const std :: string & from@var222 , const std :: string & to@var223 ) ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var224 ;
42: double mDoubleValue@var225 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var226 ;
44: bool mIsUnsigned@var227 ;
45:
46: void promote ( const value & v@var228 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var229 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var226 !=@expr1073744859 Type ::@expr1073744860 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var226 ==@expr1073744861 Type ::@expr1073744862 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744863 ) ?@expr1073744864 mDoubleValue@var225 :@expr1073744865 (@expr1073744866 double ) mIntValue@var224 ;
60: }
61:
62: static value calc ( char op@var230 , const value & v1@var231 , const value & v2@var232 ) ;
63: int compare ( const value & v@var233 ) const ;
64: value add ( int v@var234 ) const ;
65: value shiftLeft ( const value & v@var235 ) const ;
66: value shiftRight ( const value & v@var236 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var237 ;
72:
73: static long long toLongNumber ( const std :: string & str@var238 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var239 ) ;
75:
76: template < class T > static std :: string toString ( T value@var240 ) {
77: std ::@expr1073744867 ostringstream result@var241 ;
78: result@var241 <<@expr1073744868 value@var240 ;
79: return result@var241 .@expr1073744869 str (@expr1073744870 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var242 ) ;
82:
83: static bool isInt ( const std :: string & str@var243 ) ;
84: static bool isFloat ( const std :: string & str@var244 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var245 ) ;
86: static bool isNegative ( const std :: string & str@var246 ) ;
87: static bool isPositive ( const std :: string & str@var247 ) ;
88: static bool isDec ( const std :: string & str@var248 ) ;
89: static bool isFloatHex ( const std :: string & str@var249 ) ;
90: static bool isIntHex ( const std :: string & str@var250 ) ;
91: static bool isOct ( const std :: string & str@var251 ) ;
92: static bool isBin ( const std :: string & str@var252 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var253 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var254 , bool supportMicrosoftExtensions@var255 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var256 , const std :: string & second@var257 ) ;
105: static std :: string subtract ( const std :: string & first@var258 , const std :: string & second@var259 ) ;
106: static std :: string multiply ( const std :: string & first@var260 , const std :: string & second@var261 ) ;
107: static std :: string divide ( const std :: string & first@var262 , const std :: string & second@var263 ) ;
108: static std :: string mod ( const std :: string & first@var264 , const std :: string & second@var265 ) ;
109: static std :: string incdec ( const std :: string & var@var266 , const std :: string & op@var267 ) ;
110: static std :: string calculate ( const std :: string & first@var268 , const std :: string & second@var269 , char action@var270 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var271 ) ;
113: static std :: string cos ( const std :: string & tok@var272 ) ;
114: static std :: string tan ( const std :: string & tok@var273 ) ;
115: static std :: string abs ( const std :: string & tok@var274 ) ;
116: static bool isEqual ( const std :: string & first@var275 , const std :: string & second@var276 ) ;
117: static bool isNotEqual ( const std :: string & first@var277 , const std :: string & second@var278 ) ;
118: static bool isGreater ( const std :: string & first@var279 , const std :: string & second@var280 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var281 , const std :: string & second@var282 ) ;
120: static bool isLess ( const std :: string & first@var283 , const std :: string & second@var284 ) ;
121: static bool isLessEqual ( const std :: string & first@var285 , const std :: string & second@var286 ) ;
122: static bool isNullValue ( const std :: string & str@var287 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var288 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var289 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var290 , std :: string :: size_type iPos@var291 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var292 , const MathLib :: value & v2@var293 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var294 , const MathLib :: value & v2@var295 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var296 , const MathLib :: value & v2@var297 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var298 , const MathLib :: value & v2@var299 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var300 , const MathLib :: value & v2@var301 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var302 , const MathLib :: value & v2@var303 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var304 , const MathLib :: value & v2@var305 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var306 , const MathLib :: value & v2@var307 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var308 , const MathLib :: value & v2@var309 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var310 , const MathLib :: value & v2@var311 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var312 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var313 ) const {
54: x@var313 ++@expr1073744871 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var314 ) const {
60: x@var314 --@expr1073744872 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var315 , const U & y@var316 ) const {
67: return x@var315 <@expr1073744873 y@var316 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var317 , const U & y@var318 ) const {
74: return std ::@expr1073744874 abs (@expr1073744875 x@var317 -@expr1073744876 y@var318 ) ==@expr1073744877 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var319 , T x@var320 , U y@var321 ) const {
81: result@var319 =@expr1073744878 !@expr1073744879 (@expr1073744880 x@var320 >@expr1073744881 y@var321 ||@expr1073744882 x@var320 <@expr1073744883 y@var321 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var322 = 0 , Bound b@var323 = Bound :: Point )
91: : valueType@var363 ( ValueType :: INT ) ,
92: bound@var364 ( b@var323 ) ,
93: intvalue@var365 ( val@var322 ) ,
94: tokvalue@var366 ( nullptr ) ,
95: floatValue@var367 ( 0.0 ) ,
96: moveKind@var368 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var369 ( val@var322 ) ,
98: condition@var370 ( nullptr ) ,
99: varId@var372 ( 0U ) ,
100: safe@var373 ( false ) ,
101: conditional@var374 ( false ) ,
102: macro@var375 ( false ) ,
103: defaultArg@var376 ( false ) ,
104: indirect@var377 ( 0 ) ,
105: path@var378 ( 0 ) ,
106: wideintvalue@var379 ( val@var322 ) ,
107: subexpressions@var380 ( ) ,
108: capturetok@var381 ( nullptr ) ,
109: lifetimeKind@var382 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var383 ( LifetimeScope :: Local ) ,
111: valueKind@var388 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var324 , long long val@var325 , Bound b@var326 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var327 ) const {
118: if (@expr1073744884 valueType@var363 !=@expr1073744885 rhs@var327 .@expr1073744886 valueType@var328 ) {
119: return false ; }
120: switch (@expr1073744887 valueType@var363 ) {
121: case ValueType ::@expr1073744888 INT :@expr3065
122: case ValueType ::@expr1073744890 CONTAINER_SIZE :@expr3065
123: case ValueType ::@expr1073744892 BUFFER_SIZE :@expr3065
124: case ValueType ::@expr1073744894 ITERATOR_START :@expr3065
125: case ValueType ::@expr1073744896 ITERATOR_END :@expr3065 ;
126: if (@expr3074 intvalue@var365 !=@expr3075 rhs@var327 .@expr3076 intvalue@var329 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744901 TOK :@expr3065 ;
130: if (@expr3079 tokvalue@var366 !=@expr3080 rhs@var327 .@expr3081 tokvalue@var330 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744906 FLOAT :@expr3065 ;
134:
135: if (@expr1073744908 floatValue@var367 >@expr1073744909 rhs@var327 .@expr3086 floatValue@var331 ||@expr1073744911 floatValue@var367 <@expr1073744912 rhs@var327 .@expr3086 floatValue@var331 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744914 MOVED :@expr3065 ;
139: if (@expr1073744916 moveKind@var368 !=@expr1073744917 rhs@var327 .@expr1073744918 moveKind@var332 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744919 UNINIT :@expr3065 ;
143: break ;
144: case ValueType ::@expr1073744921 LIFETIME :@expr3065 ;
145: if (@expr3079 tokvalue@var366 !=@expr3080 rhs@var327 .@expr3081 tokvalue@var330 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744926 SYMBOLIC :@expr3065 ;
149: if (@expr1073744928 !@expr1073744929 sameToken (@expr1073744930 tokvalue@var366 , rhs@var327 .@expr3081 tokvalue@var330 ) ) {
150: return false ; }
151: if (@expr3074 intvalue@var365 !=@expr3075 rhs@var327 .@expr3076 intvalue@var329 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var333 , F f@var334 ) {
160: switch (@expr1073744935 self@var333 .@expr1073744936 valueType@var335 ) {
161: case ValueType ::@expr1073744937 INT :@expr3114
162: case ValueType ::@expr1073744939 SYMBOLIC :@expr3114
163: case ValueType ::@expr1073744941 BUFFER_SIZE :@expr3114
164: case ValueType ::@expr1073744943 CONTAINER_SIZE :@expr3114
165: case ValueType ::@expr1073744945 ITERATOR_START :@expr3114
166: case ValueType ::@expr1073744947 ITERATOR_END :@expr3114 ; {
167: f@var334 (@expr1073744949 self@var333 .@expr1073744950 intvalue@var336 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744951 FLOAT :@expr3114 ; {
171: f@var334 (@expr1073744953 self@var333 .@expr1073744954 floatValue@var337 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744955 UNINIT :@expr3114
175: case ValueType ::@expr1073744957 TOK :@expr3114
176: case ValueType ::@expr1073744959 LIFETIME :@expr3114
177: case ValueType ::@expr1073744961 MOVED :@expr3114 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var338 , Compare compare@var339 , T x@var340 , U y@var341 ) const {
186: result@var338 =@expr1073744963 compare@var339 (@expr1073744964 x@var340 , y@var341 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var342 , const Value & rhs@var343 , Compare compare@var344 , T x@var345 ) const {
191: visitValue (@expr1073744966 rhs@var343 ,
192: std ::@expr1073744967 bind (@expr1073744968 innerVisitor {@expr1073744969 } , std ::@expr1073744970 ref (@expr1073744971 result@var342 ) , std ::@expr1073744972 move (@expr1073744973 compare@var344 ) , x@var345 , std ::@expr1073744974 placeholders ::@expr1073744975 _1@expr1073744965 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var346 , Compare compare@var347 ) const {
198: assert (@expr1073744977 (@expr1073744978 !@expr1073744979 this@expr3156 .@expr1073744981 isSymbolicValue (@expr1073744982 ) &&@expr1073744983 !@expr1073744984 rhs@var346 .@expr1073744985 isSymbolicValue (@expr1073744986 ) ) ||@expr1073744987
199: (@expr1073744988 this@expr3156 .@expr1073744989 valueType@var363 ==@expr1073744990 rhs@var346 .@expr1073744991 valueType@var348 &&@expr1073744992 sameToken (@expr1073744993 this@expr3156 .@expr1073744994 tokvalue@var366 , rhs@var346 .@expr1073744995 tokvalue@var349 ) ) ) ;
200: bool result@var350 ; result@var350 =@expr1073744996 false ;
201: visitValue (@expr1073744997
202: *@expr1073744998 this@expr3156 ,
203: std ::@expr1073744999 bind (@expr1073745000 compareVisitor {@expr1073745001 } , std ::@expr3178 ref (@expr1073745003 result@var350 ) , std ::@expr3178 ref (@expr1073745005 rhs@var346 ) , std ::@expr1073745006 move (@expr1073745007 compare@var347 ) , std ::@expr1073745008 placeholders ::@expr1073745009 _1@expr1073744976 ) ) ;
204: return result@var350 ;
205: }
206:
207: bool operator== ( const Value & rhs@var351 ) const {
208: if (@expr1073745010 !@expr1073745011 equalValue (@expr1073745012 rhs@var351 ) ) {
209: return false ; }
210:
211: return varvalue@var369 ==@expr1073745013 rhs@var351 .@expr1073745014 varvalue@var352 &&@expr1073745015
212: condition@var370 ==@expr1073745016 rhs@var351 .@expr1073745017 condition@var353 &&@expr1073745018
213: varId@var372 ==@expr1073745019 rhs@var351 .@expr1073745020 varId@var354 &&@expr1073745021
214: conditional@var374 ==@expr1073745022 rhs@var351 .@expr1073745023 conditional@var355 &&@expr1073745024
215: defaultArg@var376 ==@expr1073745025 rhs@var351 .@expr1073745026 defaultArg@var356 &&@expr1073745027
216: indirect@var377 ==@expr1073745028 rhs@var351 .@expr1073745029 indirect@var357 &&@expr1073745030
217: valueKind@var388 ==@expr1073745031 rhs@var351 .@expr1073745032 valueKind@var358 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var359 ) const {
221: return !@expr1073745033 (@expr1073745034 *@expr1073745035 this@expr1073745036 ==@expr1073745037 rhs@var359 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var360 ) const {
226: bool result@var361 ; result@var361 =@expr1073745039 false ;
227: visitValue (@expr1073745040 *@expr1073745041 this@expr1073745042 , std ::@expr1073745043 bind (@expr1073745044 equalVisitor {@expr1073745045 } , std ::@expr1073745046 ref (@expr1073745047 result@var361 ) , x@var360 , std ::@expr1073745048 placeholders ::@expr1073745049 _1@expr1073745038 ) ) ;
228: return result@var361 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745050 bound@var364 ==@expr1073745051 Bound ::@expr1073745052 Lower ) {
233: visitValue (@expr1073745053 *@expr3230 this@expr3231 , increment {@expr1073745056 } ) ; }
234: else { if (@expr1073745057 bound@var364 ==@expr1073745058 Bound ::@expr1073745059 Upper ) {
235: visitValue (@expr1073745060 *@expr3230 this@expr3231 , decrement {@expr1073745062 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745063 bound@var364 ==@expr1073745064 Bound ::@expr3241 Lower ) {
240: bound@var364 =@expr1073745066 Bound ::@expr3243 Upper ; }
241: else { if (@expr1073745068 bound@var364 ==@expr1073745069 Bound ::@expr3243 Upper ) {
242: bound@var364 =@expr1073745071 Bound ::@expr3241 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745073 ) ;
247: decreaseRange (@expr1073745074 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var362 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var363 ;
267: bool isIntValue ( ) const {
268: return valueType@var363 ==@expr1073745075 ValueType ::@expr1073745076 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var363 ==@expr1073745077 ValueType ::@expr1073745078 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var363 ==@expr1073745079 ValueType ::@expr1073745080 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var363 ==@expr1073745081 ValueType ::@expr1073745082 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var363 ==@expr1073745083 ValueType ::@expr1073745084 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var363 ==@expr1073745085 ValueType ::@expr1073745086 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var363 ==@expr1073745087 ValueType ::@expr1073745088 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var363 ==@expr1073745089 ValueType ::@expr1073745090 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var363 ==@expr1073745091 ValueType ::@expr1073745092 ITERATOR_START ||@expr1073745093 valueType@var363 ==@expr1073745094 ValueType ::@expr1073745095 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var363 ==@expr1073745096 ValueType ::@expr1073745097 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var363 ==@expr1073745098 ValueType ::@expr1073745099 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var363 ==@expr1073745100 ValueType ::@expr1073745101 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var363 ==@expr1073745103 ValueType ::@expr1073745104 LIFETIME &&@expr1073745105 lifetimeScope@var383 ==@expr1073745106 LifetimeScope ::@expr1073745107 Local@expr1073745102 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var363 ==@expr1073745108 ValueType ::@expr1073745109 LIFETIME &&@expr1073745110 lifetimeScope@var383 ==@expr1073745111 LifetimeScope ::@expr1073745112 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var363 ==@expr1073745113 ValueType ::@expr1073745114 LIFETIME &&@expr1073745115 lifetimeScope@var383 ==@expr1073745116 LifetimeScope ::@expr1073745117 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745118 ) ||@expr1073745119 isUninitValue (@expr1073745120 ) ||@expr1073745121 isLifetimeValue (@expr1073745122 ) ;
318: }
319:
320:
321: Bound bound@var364 ;
322:
323:
324: long long intvalue@var365 ;
325:
326:
327: const Token * tokvalue@var366 ;
328:
329:
330: double floatValue@var367 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var368 ;
334:
335:
336: long long varvalue@var369 ;
337:
338:
339: const Token * condition@var370 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var371 ;
342:
343:
344: int varId@var372 ;
345:
346:
347: bool safe@var373 ;
348:
349:
350: bool conditional@var374 ;
351:
352:
353: bool macro@var375 ;
354:
355:
356: bool defaultArg@var376 ;
357:
358: int indirect@var377 ;
359:
360:
361: long long path@var378 ;
362:
363:
364: long long wideintvalue@var379 ;
365:
366: std :: vector < std :: string > subexpressions@var380 ;
367:
368:
369: const Token * capturetok@var381 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var382 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var383 ;
385:
386: static const char * toString ( MoveKind moveKind@var384 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var385 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var386 ) ;
389: static const char * toString ( Bound bound@var387 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var388 ;
402:
403: void setKnown ( ) {
404: valueKind@var388 =@expr1073745123 ValueKind ::@expr1073745124 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var388 ==@expr1073745125 ValueKind ::@expr1073745126 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var388 =@expr1073745128 ValueKind ::@expr1073745129 Possible@expr1073745127 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var388 ==@expr1073745131 ValueKind ::@expr1073745132 Possible@expr1073745130 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var388 ==@expr1073745133 ValueKind ::@expr1073745134 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var388 =@expr1073745135 ValueKind ::@expr1073745136 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var389 = true ) {
428: if (@expr1073745137 inconclusive@var389 ) {
429: valueKind@var388 =@expr1073745138 ValueKind ::@expr1073745139 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var388 ==@expr1073745140 ValueKind ::@expr1073745141 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745143 isKnown (@expr1073745144 ) ) {
438: valueKind@var388 =@expr1073745145 ValueKind ::@expr1073745146 Possible@expr1073745142 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745147 condition@var370 &&@expr1073745148 !@expr1073745149 defaultArg@var376 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var390 , const Token * tok2@var391 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var392 , const Settings * settings@var393 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var394 , SymbolDatabase * symboldatabase@var395 , ErrorLogger * errorLogger@var396 , const Settings * settings@var397 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var398 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var399 , const Settings * settings@var400 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var401 ,
459: const Settings * settings@var402 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var403 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var404 , const Token * indexTok@var405 , bool possible@var406 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var407 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var408 , const Settings * settings@var409 = nullptr , int depth@var410 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var411 ;
471: bool addressOf@var412 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var413 ;
473: bool inconclusive@var414 ;
474:
475: LifetimeToken ( ) : token@var411 ( nullptr ) , addressOf@var412 ( false ) , errorPath@var413 ( ) , inconclusive@var414 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var415 , ValueFlow :: Value :: ErrorPath errorPath@var416 )
478: : token@var411 ( token@var415 ) , addressOf@var412 ( false ) , errorPath@var413 ( std :: move ( errorPath@var416 ) ) , inconclusive@var414 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var417 , bool addressOf@var418 , ValueFlow :: Value :: ErrorPath errorPath@var419 )
482: : token@var411 ( token@var417 ) , addressOf@var412 ( addressOf@var418 ) , errorPath@var413 ( std :: move ( errorPath@var419 ) ) , inconclusive@var414 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var420 , bool b@var421 ) {
486: for (@expr1073745150 LifetimeToken &@expr1073745151 x@var422 :@expr1073745152 v@var420 ) {
487: x@var422 .@expr1073745153 addressOf@var423 =@expr1073745154 b@var421 ; }
488: return v@var420 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var424 , bool b@var425 ) {
492: for (@expr1073745155 LifetimeToken &@expr1073745156 x@var426 :@expr1073745157 v@var424 ) {
493: x@var426 .@expr1073745158 inconclusive@var427 =@expr1073745159 b@var425 ; }
494: return v@var424 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var428 , ValueFlow :: Value & true_value@var429 , ValueFlow :: Value & false_value@var430 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var431 ) ;
499: const Token * parseCompareInt ( const Token * tok@var432 , ValueFlow :: Value & true_value@var433 , ValueFlow :: Value & false_value@var434 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var435 , long long val@var436 , const Token * varTok@var437 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var438 , const Token * varTok@var439 , long long val@var440 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var441 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var442 ,
508: ValueFlow :: Value & value@var443 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var444 ,
511: bool escape@var445 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var446 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var447 , const Token * lifetime@var448 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var449 , ValueFlow :: Value :: ErrorPath & errorPath@var450 , bool * addressOf@var451 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var452 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var453 , const Settings * settings@var454 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var455 , const ValueFlow :: Value * val@var456 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var457 , const ValueFlow :: Value * val@var458 , ValueFlow :: Value :: ErrorPath & errorPath@var459 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var460 , bool inconclusive@var461 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var462 ,
529: bool inconclusive@var463 = false ,
530: long long path@var464 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var465 , const Scope * defaultScope@var466 = nullptr , bool smallest@var467 = true ) ;

##file cppcheck-2.8/lib/ctu.h

1:
|
36:
37: class Function ;
38: class Settings ;
39: class Token ;
40: class Tokenizer ;
41:
42: namespace tinyxml2 {
43: class XMLElement ;
44: }
45:
|
50:
51: namespace CTU {
52: class FileInfo : public Check :: FileInfo {
53: public:
54: enum class InvalidValueType { null , uninit , bufferOverflow } ;
55:
56: std :: string toString ( ) const override ;
57:
58: struct Location {
59: Location ( ) = default ;
60: Location ( const Tokenizer * tokenizer@var468 , const Token * tok@var469 ) ;
61: Location ( const std :: string & fileName@var470 , int lineNumber@var471 , int column@var472 ) : fileName@var473 ( fileName@var470 ) , lineNumber@var474 ( lineNumber@var471 ) , column@var475 ( column@var472 ) { }
62: std :: string fileName@var473 ;
63: int lineNumber@var474 { } ;
64: int column@var475 { } ;
65: } ;
66:
67: struct UnsafeUsage {
68: UnsafeUsage ( ) = default ;
69: UnsafeUsage ( const std :: string & myId@var476 , int myArgNr@var477 , const std :: string & myArgumentName@var478 , const Location & location@var479 , long long value@var480 ) : myId@var481 ( myId@var476 ) , myArgNr@var482 ( myArgNr@var477 ) , myArgumentName@var483 ( myArgumentName@var478 ) , location@var484 ( location@var479 ) , value@var485 ( value@var480 ) { }
70: std :: string myId@var481 ;
71: int myArgNr@var482 { } ;
72: std :: string myArgumentName@var483 ;
73: Location location@var484 ;
74: long long value@var485 { } ;
75: std :: string toString ( ) const ;
76: } ;
77:
78: class CallBase {
79: public:
80: CallBase ( ) = default ;
81: CallBase ( const std :: string & callId@var486 , int callArgNr@var487 , const std :: string & callFunctionName@var488 , const Location & loc@var489 )
82: : callId@var492 ( callId@var486 ) , callArgNr@var493 ( callArgNr@var487 ) , callFunctionName@var494 ( callFunctionName@var488 ) , location@var495 ( loc@var489 )
83: { }
84: CallBase ( const Tokenizer * tokenizer@var490 , const Token * callToken@var491 ) ;
85: virtual ~ CallBase ( ) { }
86: std :: string callId@var492 ;
87: int callArgNr@var493 { } ;
88: std :: string callFunctionName@var494 ;
89: Location location@var495 ;
90: protected:
91: std :: string toBaseXmlString ( ) const ;
92: bool loadBaseFromXml ( const tinyxml2 :: XMLElement * xmlElement@var496 ) ;
93: } ;
94:
95: class FunctionCall : public CallBase {
96: public:
97: std :: string callArgumentExpression@var497 ;
98: long long callArgValue@var498 ;
99: ValueFlow :: Value :: ValueType callValueType@var499 ;
100: std :: vector < ErrorMessage :: FileLocation > callValuePath@var500 ;
101: bool warning@var501 ;
102:
103: std :: string toXmlString ( ) const ;
104: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var502 ) ;
105: } ;
106:
107: class NestedCall : public CallBase {
108: public:
109: NestedCall ( ) = default ;
110:
111: NestedCall ( const std :: string & myId@var503 , int myArgNr@var504 , const std :: string & callId@var505 , int callArgnr@var506 , const std :: string & callFunctionName@var507 , const Location & location@var508 )
112: : CallBase ( callId@var505 , callArgnr@var506 , callFunctionName@var507 , location@var508 ) ,
113: myId@var513 ( myId@var503 ) ,
114: myArgNr@var514 ( myArgNr@var504 ) { }
115:
116: NestedCall ( const Tokenizer * tokenizer@var509 , const Function * myFunction@var510 , const Token * callToken@var511 ) ;
117:
118: std :: string toXmlString ( ) const ;
119: bool loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var512 ) ;
120:
121: std :: string myId@var513 ;
122: int myArgNr@var514 { } ;
123: } ;
124:
125: std :: list < FunctionCall > functionCalls@var515 ;
126: std :: list < NestedCall > nestedCalls@var516 ;
127:
128: void loadFromXml ( const tinyxml2 :: XMLElement * xmlElement@var517 ) ;
129: std :: map < std :: string , std :: list < const CallBase * > > getCallsMap ( ) const ;
130:
131: static std :: list < ErrorMessage :: FileLocation > getErrorPath ( InvalidValueType invalidValue@var518 ,
132: const UnsafeUsage & unsafeUsage@var519 ,
133: const std :: map < std :: string , std :: list < const CallBase * > > & callsMap@var520 ,
134: const char info@var521 [ ] ,
135: const FunctionCall * * const functionCallPtr@var522 ,
136: bool warning@var523 ) ;
137: } ;
138:
139: extern int maxCtuDepth@var524 ;
140:
141: std :: string toString ( const std :: list < FileInfo :: UnsafeUsage > & unsafeUsage@var525 ) ;
142:
143: std :: string getFunctionId ( const Tokenizer * tokenizer@var526 , const Function * function@var527 ) ;
144:
145:
146: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var528 ) ;
147:
148: std :: list < FileInfo :: UnsafeUsage > getUnsafeUsage ( const Tokenizer * tokenizer@var529 , const Settings * settings@var530 , const Check * check@var531 , bool ( * isUnsafeUsage@var532 ) ( const Check * , const Token * , long long * ) ) ;
149:
150: std :: list < FileInfo :: UnsafeUsage > loadUnsafeUsageListFromXml ( const tinyxml2 :: XMLElement * xmlElement@var533 ) ;
151: }

##file cppcheck-2.8/lib/checkuninitvar.h

1:
|
36:
37: class Scope ;
38: class Token ;
39: class Tokenizer ;
40: class Variable ;
41: class ErrorLogger ;
42: class Settings ;
43: class Library ;
44:
45: namespace tinyxml2 {
46: class XMLElement ;
47: }
48:
49:
50: struct VariableValue {
51: explicit VariableValue ( long long val@var534 = 0 ) : value@var535 ( val@var534 ) , notEqual@var536 ( false ) { }
52: long long value@var535 ;
53: bool notEqual@var536 ;
54: } ;
55:
|
61:
62: class CheckUninitVar : public Check {
63: public:
64:
65: CheckUninitVar ( ) : Check ( myName ( ) ) { }
66:
67:
68: CheckUninitVar ( const Tokenizer * tokenizer@var537 , const Settings * settings@var538 , ErrorLogger * errorLogger@var539 )
69: : Check ( myName ( ) , tokenizer@var537 , settings@var538 , errorLogger@var539 ) { }
70:
71:
72: void runChecks ( const Tokenizer * tokenizer@var540 , const Settings * settings@var541 , ErrorLogger * errorLogger@var542 ) override {
73: CheckUninitVar checkUninitVar@var543 (@expr1073745160 tokenizer@var540 , settings@var541 , errorLogger@var542 ) ;
74: checkUninitVar@var543 .@expr1073745161 valueFlowUninit (@expr1073745162 ) ;
75: checkUninitVar@var543 .@expr1073745163 check (@expr1073745164 ) ;
76: }
77:
78: bool diag ( const Token * tok@var544 ) ;
79:
80: void check ( ) ;
81: void checkScope ( const Scope * scope@var545 , const std :: set < std :: string > & arrayTypeDefs@var546 ) ;
82: void checkStruct ( const Token * tok@var547 , const Variable & structvar@var548 ) ;
83: enum Alloc { NO_ALLOC , NO_CTOR_CALL , CTOR_CALL , ARRAY } ;
84: bool checkScopeForVariable ( const Token * tok@var549 , const Variable & var@var550 , bool * const possibleInit@var551 , bool * const noreturn@var552 , Alloc * const alloc@var553 , const std :: string & membervar@var554 , std :: map < int , VariableValue > variableValue@var555 ) ;
85: const Token * checkExpr ( const Token * tok@var556 , const Variable & var@var557 , const Alloc alloc@var558 , bool known@var559 , bool * bailout@var560 = nullptr ) ;
86: bool checkIfForWhileHead ( const Token * startparentheses@var561 , const Variable & var@var562 , bool suppressErrors@var563 , bool isuninit@var564 , Alloc alloc@var565 , const std :: string & membervar@var566 ) ;
87: bool checkLoopBody ( const Token * tok@var567 , const Variable & var@var568 , const Alloc alloc@var569 , const std :: string & membervar@var570 , const bool suppressErrors@var571 ) ;
88: const Token * checkLoopBodyRecursive ( const Token * start@var572 , const Variable & var@var573 , const Alloc alloc@var574 , const std :: string & membervar@var575 , bool & bailout@var576 ) const ;
89: void checkRhs ( const Token * tok@var577 , const Variable & var@var578 , Alloc alloc@var579 , int number_of_if@var580 , const std :: string & membervar@var581 ) ;
90: static const Token * isVariableUsage ( bool cpp@var582 , const Token * vartok@var583 , const Library & library@var584 , bool pointer@var585 , Alloc alloc@var586 , int indirect@var587 = 0 ) ;
91: const Token * isVariableUsage ( const Token * vartok@var588 , bool pointer@var589 , Alloc alloc@var590 , int indirect@var591 = 0 ) const ;
92: static int isFunctionParUsage ( const Token * vartok@var592 , const Library & library@var593 , bool pointer@var594 , Alloc alloc@var595 , int indirect@var596 = 0 ) ;
93: int isFunctionParUsage ( const Token * vartok@var597 , bool pointer@var598 , Alloc alloc@var599 , int indirect@var600 = 0 ) const ;
94: bool isMemberVariableAssignment ( const Token * tok@var601 , const std :: string & membervar@var602 ) const ;
95: bool isMemberVariableUsage ( const Token * tok@var603 , bool isPointer@var604 , Alloc alloc@var605 , const std :: string & membervar@var606 ) const ;
96:
97:
98: void valueFlowUninit ( ) ;
99:
100:
101: class MyFileInfo : public Check :: FileInfo {
102: public:
103:
104: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var607 ;
105:
106:
107: std :: string toString ( ) const override ;
108: } ;
109:
110:
111: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var608 , const Settings * settings@var609 ) const override ;
112:
113: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var610 ) const override ;
114:
115:
116: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var611 , const std :: list < Check :: FileInfo * > & fileInfo@var612 , const Settings & settings@var613 , ErrorLogger & errorLogger@var614 ) override ;
117:
118: void uninitvarError ( const Token * tok@var615 , const ValueFlow :: Value & v@var616 ) ;
119: void uninitstringError ( const Token * tok@var617 , const std :: string & varname@var618 , bool strncpy_@var619 ) ;
120: void uninitdataError ( const Token * tok@var620 , const std :: string & varname@var621 ) ;
121: void uninitvarError ( const Token * tok@var622 , const std :: string & varname@var623 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var624 ) ;
122: void uninitvarError ( const Token * tok@var625 , const std :: string & varname@var626 ) {
123: std ::@expr1073745165 list < std ::@expr3342 pair < const Token *@expr1073745167 , std ::@expr3342 string > > errorPath@var627 ;
124: uninitvarError (@expr1073745169 tok@var625 , varname@var626 , errorPath@var627 ) ;
125: }
126: void uninitvarError ( const Token * tok@var628 , const std :: string & varname@var629 , Alloc alloc@var630 ) {
127: if (@expr1073745170 alloc@var630 ==@expr1073745171 NO_CTOR_CALL ||@expr1073745172 alloc@var630 ==@expr1073745173 CTOR_CALL ) {
128: uninitdataError (@expr1073745174 tok@var628 , varname@var629 ) ; }
129: else {
130: uninitvarError (@expr1073745175 tok@var628 , varname@var629 ) ; }
131: }
132: void uninitStructMemberError ( const Token * tok@var631 , const std :: string & membername@var632 ) ;
133:
134: private:
135: std :: set < const Token * > mUninitDiags@var633 ;
136: Check :: FileInfo * getFileInfo ( ) const ;
137: bool isUnsafeFunction ( const Scope * scope@var634 , int argnr@var635 , const Token * * tok@var636 ) const ;
138:
139: void getErrorMessages ( ErrorLogger * errorLogger@var637 , const Settings * settings@var638 ) const override
140: {
141: CheckUninitVar c@var639 (@expr1073745176 nullptr , settings@var638 , errorLogger@var637 ) ;
142:
143: ValueFlow ::@expr1073745177 Value v@var640 {@expr1073745178 } ;
144:
145:
146: c@var639 .@expr1073745179 uninitvarError (@expr1073745180 nullptr , v@var640 ) ;
147: c@var639 .@expr1073745181 uninitstringError (@expr1073745182 nullptr , "varname" , true ) ;
148: c@var639 .@expr1073745183 uninitdataError (@expr1073745184 nullptr , "varname" ) ;
149: c@var639 .@expr1073745185 uninitStructMemberError (@expr1073745186 nullptr , "a.b" ) ;
150: }
151:
152: static std :: string myName ( ) {
153: return "Uninitialized variables" ;
154: }
155:
156: std :: string classInfo ( ) const override {
157: return "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
158:
159: ;
160: }
161: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var641 ) const {
35: return p@var641 .@expr1073745187 first@var642 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var643 ) const {
42: return p@var643 .@expr1073745188 second@var644 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var645 , const T & x@var646 )
48: {
49: return std ::@expr1073745189 find (@expr1073745190 r@var645 .@expr1073745191 begin (@expr1073745192 ) , r@var645 .@expr3369 end (@expr3370 ) , x@var646 ) !=@expr1073745195 r@var645 .@expr3369 end (@expr3370 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var647 , const T & x@var648 )
54: {
55: return std ::@expr1073745198 find (@expr1073745199 r@var647 .@expr1073745200 begin (@expr1073745201 ) , r@var647 .@expr3378 end (@expr3379 ) , x@var648 ) !=@expr1073745204 r@var647 .@expr3378 end (@expr3379 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var649 , const U & x@var650 )
60: {
61: return std ::@expr1073745207 find (@expr1073745208 r@var649 .@expr1073745209 begin (@expr1073745210 ) , r@var649 .@expr3387 end (@expr3388 ) , x@var650 ) !=@expr1073745213 r@var649 .@expr3387 end (@expr3388 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var651 ) const
68: {
69: return static_cast < unsigned long > (@expr1073745216 t@var651 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var652 , char c@var653 )
74: {
75: return !@expr1073745217 str@var652 .@expr1073745218 empty (@expr1073745219 ) &&@expr1073745220 str@var652 .@expr1073745221 back (@expr1073745222 ) ==@expr1073745223 c@var653 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var654 , const char end@var655 [ ] , unsigned long endlen@var656 )
79: {
80: return (@expr3400 str@var654 .@expr3401 size (@expr3402 ) >=@expr1073745227 endlen@var656 ) &&@expr1073745228 (@expr3400 str@var654 .@expr1073745230 compare (@expr1073745231 str@var654 .@expr3401 size (@expr3402 ) -@expr1073745234 endlen@var656 , endlen@var656 , end@var655 ) ==@expr1073745235 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var657 , const char ( & end@var658 ) [ N ] )
85: {
86: return endsWith (@expr1073745237 str@var657 , end@var658 , N@expr1073745236 -@expr1073745238 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var659 , char q@var660 , const std :: string & p@var661 )
90: {
91: if (@expr1073745239 !@expr1073745240 endsWith (@expr1073745241 str@var659 , q@var660 ) ) {
92: return false ; }
93: if (@expr1073745242 (@expr1073745243 str@var659 .@expr1073745244 length (@expr1073745245 ) +@expr1073745246 1 ) >@expr1073745247 p@var661 .@expr1073745248 length (@expr1073745249 ) &&@expr1073745250 (@expr1073745251 str@var659 .@expr1073745252 compare (@expr1073745253 0 , p@var661 .@expr1073745254 size (@expr1073745255 ) +@expr1073745256 1 , p@var661 +@expr1073745257 q@var660 ) ==@expr1073745258 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var662 , char q@var663 )
99: {
100: static const std ::@expr3435 vector < std ::@expr3435 string > suffixes@var664 {@expr1073745261 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073745262 const std ::@expr3435 string &@expr1073745264 p@var665 :@expr1073745265 suffixes@var664 ) {
102: if (@expr1073745266 isPrefixStringCharLiteral (@expr1073745267 str@var662 , q@var663 , p@var665 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var666 )
109: {
110: return isStringCharLiteral (@expr1073745268 str@var666 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var667 )
114: {
115: return isStringCharLiteral (@expr1073745269 str@var667 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var668 , char q@var669 )
119: {
120: const unsigned long quotePos@var670 =@expr1073745270 str@var668 .@expr1073745271 find (@expr1073745272 q@var669 ) ;
121: return str@var668 .@expr1073745273 substr (@expr1073745274 quotePos@var670 +@expr1073745275 1U , str@var668 .@expr1073745276 size (@expr1073745277 ) -@expr1073745278 quotePos@var670 -@expr1073745279 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var671 )
125: {
126: if (@expr1073745280 isStringLiteral (@expr1073745281 str@var671 ) ) {
127: return getStringCharLiteral (@expr1073745282 str@var671 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var672 )
132: {
133: if (@expr1073745283 isCharLiteral (@expr1073745284 str@var672 ) ) {
134: return getStringCharLiteral (@expr1073745285 str@var672 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var673 )
139: {
140: if (@expr1073745286 i@var673 ==@expr1073745287 1 ) {
141: return "st" ; }
142: if (@expr1073745288 i@var673 ==@expr1073745289 2 ) {
143: return "nd" ; }
144: if (@expr1073745290 i@var673 ==@expr1073745291 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var674 , const std :: string & rhs@var675 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var676 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var677 , const std :: string & name@var678 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var679 , const std :: string & name@var680 ) ;
156:
157: void strTolower ( std :: string & str@var681 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var682 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var683 ;
42:
43:
44: std :: string stdValue@var684 ;
45:
46:
47: Standards ( ) : c@var682 ( CLatest ) , cpp@var683 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var685 ) {
50: stdValue@var684 =@expr1073745292 str@var685 ;
51: if (@expr1073745293 str@var685 ==@expr1073745294 "c89" ||@expr1073745295 str@var685 ==@expr1073745296 "C89" ) {
52: c@var682 =@expr1073745297 C89 ;
53: return true ;
54: }
55: if (@expr1073745298 str@var685 ==@expr1073745299 "c99" ||@expr1073745300 str@var685 ==@expr1073745301 "C99" ) {
56: c@var682 =@expr1073745302 C99 ;
57: return true ;
58: }
59: if (@expr1073745303 str@var685 ==@expr1073745304 "c11" ||@expr1073745305 str@var685 ==@expr1073745306 "C11" ) {
60: c@var682 =@expr1073745307 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073745308 c@var682 ) {
67: case C89 :@expr3485 ;
68: return "c89" ;
69: case C99 :@expr3485 ;
70: return "c99" ;
71: case C11 :@expr3485 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var686 ) {
77: if (@expr1073745312 std@var686 ==@expr1073745313 "c89" ) {
78: return Standards ::@expr1073745314 C89 ;
79: }
80: if (@expr1073745315 std@var686 ==@expr1073745316 "c99" ) {
81: return Standards ::@expr1073745317 C99 ;
82: }
83: if (@expr1073745318 std@var686 ==@expr1073745319 "c11" ) {
84: return Standards ::@expr1073745320 C11 ;
85: }
86: return Standards ::@expr1073745321 CLatest ;
87: }
88: bool setCPP ( std :: string str@var687 ) {
89: stdValue@var684 =@expr1073745322 str@var687 ;
90: strTolower (@expr1073745323 str@var687 ) ;
91: cpp@var683 =@expr1073745324 getCPP (@expr1073745325 str@var687 ) ;
92: return !@expr1073745326 stdValue@var684 .@expr1073745327 empty (@expr1073745328 ) &&@expr1073745329 str@var687 ==@expr1073745330 getCPP (@expr1073745331 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073745332 cpp@var683 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var688 ) {
98: switch (@expr1073745333 std@var688 ) {
99: case CPP03 :@expr3510 ;
100: return "c++03" ;
101: case CPP11 :@expr3510 ;
102: return "c++11" ;
103: case CPP14 :@expr3510 ;
104: return "c++14" ;
105: case CPP17 :@expr3510 ;
106: return "c++17" ;
107: case CPP20 :@expr3510 ;
108: return "c++20" ;
109: case CPP23 :@expr3510 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var689 ) {
115: if (@expr1073745340 std@var689 ==@expr1073745341 "c++03" ) {
116: return Standards ::@expr1073745342 CPP03 ;
117: }
118: if (@expr1073745343 std@var689 ==@expr1073745344 "c++11" ) {
119: return Standards ::@expr1073745345 CPP11 ;
120: }
121: if (@expr1073745346 std@var689 ==@expr1073745347 "c++14" ) {
122: return Standards ::@expr1073745348 CPP14 ;
123: }
124: if (@expr1073745349 std@var689 ==@expr1073745350 "c++17" ) {
125: return Standards ::@expr1073745351 CPP17 ;
126: }
127: if (@expr1073745352 std@var689 ==@expr1073745353 "c++20" ) {
128: return Standards ::@expr1073745354 CPP20 ;
129: }
130: if (@expr1073745355 std@var689 ==@expr1073745356 "c++23" ) {
131: return Standards ::@expr1073745357 CPP23 ;
132: }
133: return Standards ::@expr1073745358 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var693 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var690 ) : errorcode@var693 ( e@var690 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var691 , T && r@var692 ) : errorcode@var693 ( e@var691 ) , reason@var694 ( r@var692 ) { }
66: ErrorCode errorcode@var693 ;
67: std :: string reason@var694 ;
68: } ;
69:
70: Error load ( const char exename@var695 [ ] , const char path@var696 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var697 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var698 [ ] , unsigned long len@var699 ) ;
75:
76: struct AllocFunc {
77: int groupId@var700 ;
78: int arg@var701 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var702 ;
81: int bufferSizeArg1@var703 ;
82: int bufferSizeArg2@var704 ;
83: int reallocArg@var705 ;
84: bool initData@var706 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var707 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var708 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var709 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var710 , int arg@var711 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var712 , int arg@var713 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var714 , int arg@var715 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var716 [ ] ) const {
107: return getAllocDealloc (@expr1073745359 mAlloc@var982 , name@var716 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var717 [ ] ) const {
112: return getAllocDealloc (@expr1073745360 mDealloc@var983 , name@var717 ) ;
113: }
114:
115:
116: int allocId ( const char name@var718 [ ] ) const {
117: const AllocFunc * af@var719 ; af@var719 =@expr1073745361 getAllocDealloc (@expr1073745362 mAlloc@var982 , name@var718 ) ;
118: return af@var719 ?@expr1073745363 af@var719 .@expr1073745364 groupId@var720 :@expr1073745365 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var721 [ ] ) const {
123: const AllocFunc * af@var722 ; af@var722 =@expr1073745366 getAllocDealloc (@expr1073745367 mDealloc@var983 , name@var721 ) ;
124: return af@var722 ?@expr1073745368 af@var722 .@expr1073745369 groupId@var723 :@expr1073745370 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var724 , int id@var725 , int arg@var726 ) {
129: mAlloc@var982 [@expr3547 functionname@var724 ] .@expr1073745372 groupId@var2928 =@expr1073745373 id@var725 ;
130: mAlloc@var982 [@expr3547 functionname@var724 ] .@expr1073745375 arg@var2929 =@expr1073745376 arg@var726 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var727 , int id@var728 , int arg@var729 ) {
134: mDealloc@var983 [@expr3553 functionname@var727 ] .@expr1073745378 groupId@var2930 =@expr1073745379 id@var728 ;
135: mDealloc@var983 [@expr3553 functionname@var727 ] .@expr1073745381 arg@var2931 =@expr1073745382 arg@var729 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var730 , int id@var731 , int arg@var732 , int reallocArg@var733 = 1 ) {
139: mRealloc@var984 [@expr3559 functionname@var730 ] .@expr1073745384 groupId@var2932 =@expr1073745385 id@var731 ;
140: mRealloc@var984 [@expr3559 functionname@var730 ] .@expr1073745387 arg@var2933 =@expr1073745388 arg@var732 ;
141: mRealloc@var984 [@expr3559 functionname@var730 ] .@expr1073745390 reallocArg@var2934 =@expr1073745391 reallocArg@var733 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var734 , bool noreturn@var735 ) {
146: mNoReturn@var985 [@expr1073745392 funcname@var734 ] =@expr1073745393 noreturn@var735 ?@expr1073745394 FalseTrueMaybe ::@expr1073745395 True :@expr1073745396 FalseTrueMaybe ::@expr1073745397 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var736 ) ;
150:
151:
152: static bool ismemory ( const int id@var737 ) {
153: return (@expr3574 (@expr3574 id@var737 >@expr1073745400 0 ) &&@expr1073745401 (@expr3574 (@expr3574 id@var737 &@expr1073745404 1 ) ==@expr1073745405 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var738 ) {
156: return (@expr3582 (@expr3582 func@var738 .@expr3584 groupId@var739 >@expr1073745409 0 ) &&@expr1073745410 (@expr3582 (@expr3582 func@var738 .@expr3584 groupId@var739 &@expr1073745414 1 ) ==@expr1073745415 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var740 ) {
161: return (@expr3592 (@expr3592 id@var740 >@expr1073745418 0 ) &&@expr1073745419 (@expr3592 (@expr3592 id@var740 &@expr1073745422 1 ) ==@expr1073745423 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var741 ) {
164: return (@expr3600 (@expr3600 func@var741 .@expr3602 groupId@var742 >@expr1073745427 0 ) &&@expr1073745428 (@expr3600 (@expr3600 func@var741 .@expr3602 groupId@var742 &@expr1073745432 1 ) ==@expr1073745433 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var743 ) const ;
168: int formatstr_argno ( const Token * ftok@var744 ) const ;
169: bool formatstr_scan ( const Token * ftok@var745 ) const ;
170: bool formatstr_secure ( const Token * ftok@var746 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var747 ;
174: int ptr2Arg@var748 ;
175: int sizeArg@var749 ;
176: int strlenArg@var750 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var751 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var752 ;
182: Standards standards@var753 ;
183: Severity :: SeverityType severity@var754 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var755 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var756 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var757 ) const ;
191: bool matchArguments ( const Token * ftok@var758 , const std :: string & functionName@var759 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var760 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var761 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var762 ) const ;
198: int returnValueContainer ( const Token * ftok@var763 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var764 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var765 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var766 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var767 , std :: string * unknownFunc@var768 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var778 ( -1 ) ,
210: size_templateArgNo@var780 ( -1 ) ,
211: arrayLike_indexOp@var781 ( false ) ,
212: stdStringLike@var782 ( false ) ,
213: stdAssociativeLike@var783 ( false ) ,
214: opLessAllowed@var784 ( true ) ,
215: hasInitializerListConstructor@var785 ( false ) ,
216: unstableErase@var786 ( false ) ,
217: unstableInsert@var787 ( false ) ,
218: view@var788 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var769 ;
248: Yield yield@var770 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var771 ;
252: int templateParameter@var772 ;
253: } ;
254: std :: string startPattern@var773 ; std :: string startPattern2@var774 ; std :: string endPattern@var775 ; std :: string itEndPattern@var776 ;
255: std :: map < std :: string , Function > functions@var777 ;
256: int type_templateArgNo@var778 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var779 ;
258: int size_templateArgNo@var780 ;
259: bool arrayLike_indexOp@var781 ;
260: bool stdStringLike@var782 ;
261: bool stdAssociativeLike@var783 ;
262: bool opLessAllowed@var784 ;
263: bool hasInitializerListConstructor@var785 ;
264: bool unstableErase@var786 ;
265: bool unstableInsert@var787 ;
266: bool view@var788 ;
267:
268: Action getAction ( const std :: string & function@var789 ) const {
269: const std ::@expr1073745434 map < std ::@expr1073745435 string , Function > ::@expr1073745436 const_iterator i@var790 =@expr1073745437 functions@var777 .@expr1073745438 find (@expr1073745439 function@var789 ) ;
270: if (@expr1073745440 i@var790 !=@expr1073745441 functions@var777 .@expr1073745442 end (@expr1073745443 ) ) {
271: return i@var790 .@expr1073745444 second@var791 .@expr1073745445 action@var792 ; }
272: return Action ::@expr1073745446 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var793 ) const {
276: const std ::@expr1073745447 map < std ::@expr1073745448 string , Function > ::@expr1073745449 const_iterator i@var794 =@expr1073745450 functions@var777 .@expr1073745451 find (@expr1073745452 function@var793 ) ;
277: if (@expr1073745453 i@var794 !=@expr1073745454 functions@var777 .@expr1073745455 end (@expr1073745456 ) ) {
278: return i@var794 .@expr1073745457 second@var795 .@expr1073745458 yield@var796 ; }
279: return Yield ::@expr1073745459 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var797 ) ;
283: static Action actionFrom ( const std :: string & actionName@var798 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var799 ;
286: const Container * detectContainer ( const Token * typeStart@var800 , bool iterator@var801 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var802 , bool * isIterator@var803 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var804 ( false ) ,
293: notnull@var805 ( false ) ,
294: notuninit@var806 ( -1 ) ,
295: formatstr@var807 ( false ) ,
296: strz@var808 ( false ) ,
297: optional@var809 ( false ) ,
298: variadic@var810 ( false ) ,
299: iteratorInfo@var816 ( ) ,
300: direction@var824 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var804 ;
303: bool notnull@var805 ;
304: int notuninit@var806 ;
305: bool formatstr@var807 ;
306: bool strz@var808 ;
307: bool optional@var809 ;
308: bool variadic@var810 ;
309: std :: string valid@var811 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var812 ( 0 ) , it@var813 ( false ) , first@var814 ( false ) , last@var815 ( false ) { }
314:
315: int container@var812 ;
316: bool it@var813 ;
317: bool first@var814 ;
318: bool last@var815 ;
319: } ;
320: IteratorInfo iteratorInfo@var816 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var817 , int a@var818 ) : type@var819 ( t@var817 ) , arg@var820 ( a@var818 ) , arg2@var821 ( 0 ) , value@var822 ( 0 ) { }
326: Type type@var819 ;
327: int arg@var820 ;
328: int arg2@var821 ;
329: long long value@var822 ;
330: } ;
331: std :: vector < MinSize > minsizes@var823 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var824 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var825 ;
344: bool use@var826 ;
345: bool leakignore@var827 ;
346: bool isconst@var828 ;
347: bool ispure@var829 ;
348: UseRetValType useretval@var830 ;
349: bool ignore@var831 ;
350: bool formatstr@var832 ;
351: bool formatstr_scan@var833 ;
352: bool formatstr_secure@var834 ;
353: Container :: Action containerAction@var835 ;
354: Container :: Yield containerYield@var836 ;
355: Function ( )
356: : use@var826 ( false ) ,
357: leakignore@var827 ( false ) ,
358: isconst@var828 ( false ) ,
359: ispure@var829 ( false ) ,
360: useretval@var830 ( UseRetValType :: NONE ) ,
361: ignore@var831 ( false ) ,
362: formatstr@var832 ( false ) ,
363: formatstr_scan@var833 ( false ) ,
364: formatstr_secure@var834 ( false ) ,
365: containerAction@var835 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var836 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var837 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var838 ;
372: bool isUse ( const std :: string & functionName@var839 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var840 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var841 , bool pure@var842 ) const ;
375: bool isFunctionConst ( const Token * ftok@var843 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var844 , int argnr@var845 ) const {
378: const ArgumentChecks * arg@var846 ; arg@var846 =@expr1073745460 getarg (@expr1073745461 ftok@var844 , argnr@var845 ) ;
379: return arg@var846 &&@expr1073745462 arg@var846 .@expr1073745463 notbool@var847 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var848 , int argnr@var849 ) const ;
383: bool isuninitargbad ( const Token * ftok@var850 , int argnr@var851 , int indirect@var852 = 0 , bool * hasIndirect@var853 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var854 , int argnr@var855 ) const {
386: const ArgumentChecks * arg@var856 ; arg@var856 =@expr1073745464 getarg (@expr1073745465 ftok@var854 , argnr@var855 ) ;
387: return arg@var856 &&@expr1073745466 arg@var856 .@expr1073745467 formatstr@var857 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var858 , int argnr@var859 ) const {
391: const ArgumentChecks * arg@var860 ; arg@var860 =@expr1073745468 getarg (@expr1073745469 ftok@var858 , argnr@var859 ) ;
392: return arg@var860 &&@expr1073745470 arg@var860 .@expr1073745471 strz@var861 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var862 , int argnr@var863 , const long long argvalue@var864 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var865 , int argnr@var866 , double argvalue@var867 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var868 , int argnr@var869 ) const {
399: const ArgumentChecks * arg@var870 ; arg@var870 =@expr1073745472 getarg (@expr1073745473 ftok@var868 , argnr@var869 ) ;
400: return arg@var870 ?@expr1073745474 arg@var870 .@expr1073745475 valid@var871 :@expr1073745476 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var872 ;
405: std :: string op1@var873 ;
406: std :: string op2@var874 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073745477 isInt (@expr1073745478 op1@var873 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var875 , int argnr@var876 ) const {
413: const ArgumentChecks * arg@var877 ; arg@var877 =@expr1073745479 getarg (@expr1073745480 ftok@var875 , argnr@var876 ) ;
414: return arg@var877 &&@expr1073745481 arg@var877 .@expr3658 iteratorInfo@var878 .@expr1073745483 it@var879 ?@expr1073745484 &@expr1073745485 arg@var877 .@expr3658 iteratorInfo@var878 :@expr1073745487 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var880 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var881 , int argnr@var882 ) const {
420: const ArgumentChecks * arg@var883 ; arg@var883 =@expr1073745488 getarg (@expr1073745489 ftok@var881 , argnr@var882 ) ;
421: return arg@var883 ?@expr1073745490 &@expr1073745491 arg@var883 .@expr1073745492 minsizes@var884 :@expr1073745493 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var885 , int argnr@var886 ) const ;
425:
426: bool markupFile ( const std :: string & path@var887 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var888 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var992 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var889 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var890 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var891 , const std :: string & token@var892 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var893 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var894 ) const ;
443: const std :: string & blockend ( const std :: string & file@var895 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var896 , const std :: string & keyword@var897 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var898 ) const {
448: return mExporters@var995 .@expr1073745494 find (@expr1073745495 prefix@var898 ) !=@expr1073745496 mExporters@var995 .@expr1073745497 end (@expr1073745498 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var899 , const std :: string & token@var900 ) const {
452: const std ::@expr1073745499 map < std ::@expr1073745500 string , ExportedFunctions > ::@expr1073745501 const_iterator it@var901 =@expr1073745502 mExporters@var995 .@expr1073745503 find (@expr1073745504 prefix@var899 ) ;
453: return (@expr1073745505 it@var901 !=@expr1073745506 mExporters@var995 .@expr1073745507 end (@expr1073745508 ) &&@expr1073745509 it@var901 .@expr1073745510 second@var902 .@expr1073745511 isPrefix (@expr1073745512 token@var900 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var903 , const std :: string & token@var904 ) const {
457: const std ::@expr1073745513 map < std ::@expr1073745514 string , ExportedFunctions > ::@expr1073745515 const_iterator it@var905 =@expr1073745516 mExporters@var995 .@expr1073745517 find (@expr1073745518 prefix@var903 ) ;
458: return (@expr1073745519 it@var905 !=@expr1073745520 mExporters@var995 .@expr1073745521 end (@expr1073745522 ) &&@expr1073745523 it@var905 .@expr1073745524 second@var906 .@expr1073745525 isSuffix (@expr1073745526 token@var904 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var907 , const std :: string & importer@var908 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var909 , Container :: Yield yield@var910 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var911 , Container :: Action action@var912 ) const ;
465:
466: bool isreflection ( const std :: string & token@var913 ) const {
467: return mReflection@var997 .@expr1073745527 find (@expr1073745528 token@var913 ) !=@expr1073745529 mReflection@var997 .@expr1073745530 end (@expr1073745531 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var914 ) const {
471: const std ::@expr1073745532 map < std ::@expr1073745533 string , int > ::@expr1073745534 const_iterator it@var915 =@expr1073745535 mReflection@var997 .@expr1073745536 find (@expr1073745537 token@var914 ) ;
472: if (@expr1073745538 it@var915 !=@expr1073745539 mReflection@var997 .@expr1073745540 end (@expr1073745541 ) ) {
473: return it@var915 .@expr1073745542 second@var916 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var917 ;
478:
479: struct SmartPointer {
480: std :: string name@var918 ; name@var918 = "" ;
481: bool unique@var919 ; unique@var919 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var920 ;
485: bool isSmartPointer ( const Token * tok@var921 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var922 ) const ;
487:
488: struct PodType {
489: unsigned int size@var923 ;
490: char sign@var924 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var925 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var926 ) const {
494: const std ::@expr1073745543 unordered_map < std ::@expr1073745544 string , PodType > ::@expr1073745545 const_iterator it@var927 =@expr1073745546 mPodTypes@var998 .@expr1073745547 find (@expr1073745548 name@var926 ) ;
495: return (@expr3725 it@var927 !=@expr1073745550 mPodTypes@var998 .@expr1073745551 end (@expr1073745552 ) ) ?@expr1073745553 &@expr1073745554 (@expr3725 it@var927 .@expr1073745556 second@var928 ) :@expr1073745557 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var939 ( false )
501: , mUnsigned@var940 ( false )
502: , mLong@var941 ( false )
503: , mPointer@var942 ( false )
504: , mPtrPtr@var943 ( false )
505: , mConstPtr@var944 ( false ) { }
506: bool operator== ( const PlatformType & type@var929 ) const {
507: return (@expr1073745558 mSigned@var939 ==@expr1073745559 type@var929 .@expr1073745560 mSigned@var930 &&@expr1073745561
508: mUnsigned@var940 ==@expr1073745562 type@var929 .@expr1073745563 mUnsigned@var931 &&@expr1073745564
509: mLong@var941 ==@expr1073745565 type@var929 .@expr1073745566 mLong@var932 &&@expr1073745567
510: mPointer@var942 ==@expr1073745568 type@var929 .@expr1073745569 mPointer@var933 &&@expr1073745570
511: mPtrPtr@var943 ==@expr1073745571 type@var929 .@expr1073745572 mPtrPtr@var934 &&@expr1073745573
512: mConstPtr@var944 ==@expr1073745574 type@var929 .@expr1073745575 mConstPtr@var935 &&@expr1073745576
513: mType@var938 ==@expr1073745577 type@var929 .@expr1073745578 mType@var936 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var937 ) const {
516: return !@expr1073745579 (@expr1073745580 *@expr1073745581 this@expr1073745582 ==@expr1073745583 type@var937 ) ;
517: }
518: std :: string mType@var938 ;
519: bool mSigned@var939 ;
520: bool mUnsigned@var940 ;
521: bool mLong@var941 ;
522: bool mPointer@var942 ;
523: bool mPtrPtr@var943 ;
524: bool mConstPtr@var944 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var945 ) const {
529: const std ::@expr1073745584 map < std ::@expr1073745585 string , PlatformType > ::@expr1073745586 const_iterator it@var946 =@expr1073745587 mPlatformTypes@var948 .@expr1073745588 find (@expr1073745589 name@var945 ) ;
530: return (@expr3766 it@var946 !=@expr1073745591 mPlatformTypes@var948 .@expr1073745592 end (@expr1073745593 ) ) ?@expr1073745594 &@expr1073745595 (@expr3766 it@var946 .@expr1073745597 second@var947 ) :@expr1073745598 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var948 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var949 , const std :: string & platform@var950 ) const {
536: const std ::@expr1073745599 map < std ::@expr3776 string , Platform > ::@expr1073745601 const_iterator it@var951 =@expr1073745602 mPlatforms@var1000 .@expr1073745603 find (@expr1073745604 platform@var950 ) ;
537: if (@expr1073745605 it@var951 !=@expr1073745606 mPlatforms@var1000 .@expr1073745607 end (@expr1073745608 ) ) {
538: const PlatformType * const type@var952 ; type@var952 =@expr1073745609 it@var951 .@expr1073745610 second@var953 .@expr1073745611 platform_type (@expr1073745612 name@var949 ) ;
539: if (@expr1073745613 type@var952 ) {
540: return type@var952 ; }
541: }
542:
543: const std ::@expr1073745614 map < std ::@expr3776 string , PlatformType > ::@expr1073745616 const_iterator it2@var954 =@expr1073745617 mPlatformTypes@var999 .@expr1073745618 find (@expr1073745619 name@var949 ) ;
544: return (@expr3796 it2@var954 !=@expr1073745621 mPlatformTypes@var999 .@expr1073745622 end (@expr1073745623 ) ) ?@expr1073745624 &@expr1073745625 (@expr3796 it2@var954 .@expr1073745627 second@var955 ) :@expr1073745628 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var956 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var957 , Library :: Container :: Yield y@var958 , const std :: string & fallback@var959 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var960 , const std :: string & typeName@var961 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var962 , const std :: string & name@var963 , std :: set < std :: string > & unknown_elements@var964 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var965 ) {
565: mPrefixes@var969 .@expr1073745629 insert (@expr1073745630 prefix@var965 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var966 ) {
568: mSuffixes@var970 .@expr1073745631 insert (@expr1073745632 suffix@var966 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var967 ) const {
571: return (@expr1073745633 mPrefixes@var969 .@expr1073745634 find (@expr1073745635 prefix@var967 ) !=@expr1073745636 mPrefixes@var969 .@expr1073745637 end (@expr1073745638 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var968 ) const {
574: return (@expr1073745639 mSuffixes@var970 .@expr1073745640 find (@expr1073745641 suffix@var968 ) !=@expr1073745642 mSuffixes@var970 .@expr1073745643 end (@expr1073745644 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var969 ;
579: std :: set < std :: string > mSuffixes@var970 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var978 ( 0 ) { }
584:
585: void setStart ( const char * s@var971 ) {
586: mStart@var976 =@expr1073745645 s@var971 ;
587: }
588: void setEnd ( const char * e@var972 ) {
589: mEnd@var977 =@expr1073745646 e@var972 ;
590: }
591: void setOffset ( const int o@var973 ) {
592: mOffset@var978 =@expr1073745647 o@var973 ;
593: }
594: void addBlock ( const char * blockName@var974 ) {
595: mBlocks@var979 .@expr1073745648 insert (@expr1073745649 blockName@var974 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var976 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var977 ;
602: }
603: int offset ( ) const {
604: return mOffset@var978 ;
605: }
606: bool isBlock ( const std :: string & blockName@var975 ) const {
607: return mBlocks@var979 .@expr1073745650 find (@expr1073745651 blockName@var975 ) !=@expr1073745652 mBlocks@var979 .@expr1073745653 end (@expr1073745654 ) ;
608: }
609:
610: private:
611: std :: string mStart@var976 ;
612: std :: string mEnd@var977 ;
613: int mOffset@var978 ;
614: std :: set < std :: string > mBlocks@var979 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var980 ;
618: std :: set < std :: string > mFiles@var981 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var982 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var983 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var984 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var985 ;
623: std :: map < std :: string , std :: string > mReturnValue@var986 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var987 ;
625: std :: map < std :: string , int > mReturnValueContainer@var988 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var989 ;
627: std :: map < std :: string , bool > mReportErrors@var990 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var991 ;
629: std :: set < std :: string > mMarkupExtensions@var992 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var993 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var994 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var995 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var996 ;
634: std :: map < std :: string , int > mReflection@var997 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var998 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var999 ;
637: std :: map < std :: string , Platform > mPlatforms@var1000 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var1001 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var1002 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var1003 , int argnr@var1004 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var1005 , bool * error@var1006 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var1007 , const std :: string & name@var1008 ) {
646: const std ::@expr1073745655 map < std ::@expr1073745656 string , AllocFunc > ::@expr1073745657 const_iterator it@var1009 =@expr1073745658 data@var1007 .@expr1073745659 find (@expr1073745660 name@var1008 ) ;
647: return (@expr1073745661 it@var1009 ==@expr1073745662 data@var1007 .@expr1073745663 end (@expr1073745664 ) ) ?@expr1073745665 nullptr :@expr1073745666 &@expr1073745667 it@var1009 .@expr1073745668 second@var1010 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var1011 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var1012 ,
654: const Settings * settings@var1013 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var1014 = nullptr ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var1015 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var1016 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var1017 ;
69: std :: string mScope@var1018 ;
70: std :: string mName@var1019 ;
71: std :: string mFullName@var1020 ;
72: const Token * mNameToken@var1021 ;
73: const Token * mParamEnd@var1022 ;
74: unsigned int mFlags@var1023 ;
75:
76: enum Anonymous1 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var1024 ) {
90: setFlag (@expr1073745669 fIsClass , state@var1024 ) ;
91: }
92: void isFunction ( bool state@var1025 ) {
93: setFlag (@expr1073745670 fIsFunction , state@var1025 ) ;
94: }
95: void isVariable ( bool state@var1026 ) {
96: setFlag (@expr1073745671 fIsVariable , state@var1026 ) ;
97: }
98: void isAlias ( bool state@var1027 ) {
99: setFlag (@expr1073745672 fIsAlias , state@var1027 ) ;
100: }
101: void isSpecialization ( bool state@var1028 ) {
102: setFlag (@expr1073745673 fIsSpecialization , state@var1028 ) ;
103: }
104: void isPartialSpecialization ( bool state@var1029 ) {
105: setFlag (@expr1073745674 fIsPartialSpecialization , state@var1029 ) ;
106: }
107: void isForwardDeclaration ( bool state@var1030 ) {
108: setFlag (@expr1073745675 fIsForwardDeclaration , state@var1030 ) ;
109: }
110: void isVariadic ( bool state@var1031 ) {
111: setFlag (@expr1073745676 fIsVariadic , state@var1031 ) ;
112: }
113: void isFriend ( bool state@var1032 ) {
114: setFlag (@expr1073745677 fIsFriend , state@var1032 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var1033 ) const {
123: return (@expr3854 (@expr3854 mFlags@var1023 &@expr1073745680 flag@var1033 ) !=@expr1073745681 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var1034 , bool state@var1035 ) {
132: mFlags@var1023 =@expr1073745682 state@var1035 ?@expr1073745683 mFlags@var1023 |@expr1073745684 flag@var1034 :@expr1073745685 mFlags@var1023 &@expr1073745686 ~@expr1073745687 flag@var1034 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var1036 , const std :: string & scope@var1037 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var1038 , const std :: string & scope@var1039 , const Token * nameToken@var1040 , const Token * paramEnd@var1041 ) ;
150: TokenAndName ( const TokenAndName & other@var1042 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var1043 ) const {
154: return mToken@var1017 ==@expr1073745688 rhs@var1043 .@expr1073745689 mToken@var1044 &&@expr1073745690 mScope@var1018 ==@expr1073745691 rhs@var1043 .@expr1073745692 mScope@var1045 &&@expr1073745693 mName@var1019 ==@expr1073745694 rhs@var1043 .@expr1073745695 mName@var1046 &&@expr1073745696 mFullName@var1020 ==@expr1073745697 rhs@var1043 .@expr1073745698 mFullName@var1047 &&@expr1073745699
155: mNameToken@var1021 ==@expr1073745700 rhs@var1043 .@expr1073745701 mNameToken@var1048 &&@expr1073745702 mParamEnd@var1022 ==@expr1073745703 rhs@var1043 .@expr1073745704 mParamEnd@var1049 &&@expr1073745705 mFlags@var1023 ==@expr1073745706 rhs@var1043 .@expr1073745707 mFlags@var1050 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var1017 ;
160: }
161: void token ( Token * token@var1051 ) {
162: mToken@var1017 =@expr1073745708 token@var1051 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var1018 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var1019 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var1020 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var1021 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var1022 ;
178: }
179: void paramEnd ( const Token * end@var1052 ) {
180: mParamEnd@var1022 =@expr1073745709 end@var1052 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745710 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745711 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745712 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745713 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745714 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745715 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745716 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745717 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745718 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var1053 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var1054 ) const {
243:
244:
245: return (@expr3895 (@expr3895 mFlags@var1023 &@expr1073745721 fFamilyMask ) &@expr1073745722 (@expr3895 decl@var1054 .@expr1073745724 mFlags@var1055 &@expr1073745725 fFamilyMask ) ) !=@expr1073745726 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var1056 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var1057 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var1058 , const unsigned long numberOfArguments@var1059 , bool variadic@var1060 , const char patternAfter@var1061 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var1062 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var1063 , int & namepos@var1064 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var1065 , int & namepos@var1066 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var1067 , int & namepos@var1068 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var1069 ,
306: bool & codeWithTemplates@var1070 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var1071 , bool isTemplate@var1072 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var1073 = nullptr , Token * backToken@var1074 = nullptr , bool isTemplate@var1075 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var1076 , Token * end@var1077 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var1078 , const std :: string & scope@var1079 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var1080 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var1081 ,
393: const std :: list < const Token * > & specializations@var1082 ,
394: const std :: time_t maxtime@var1083 ,
395: std :: set < std :: string > & expandedtemplates@var1084 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var1085 , const Token * tok@var1086 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1087 , const Token * tok@var1088 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var1089 ,
422: const TokenAndName & templateInstantiation@var1090 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var1091 ,
424: const std :: string & newName@var1092 ,
425: bool copy@var1093 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var1094 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1095 ,
435: const std :: string & newName@var1096 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var1097 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var1098 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var1099 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var1100 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var1101 ,
458: const Token * templateInstantiationNameToken@var1102 ,
459: const std :: list < const Token * > & specializations@var1103 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var1104 , const Token * end@var1105 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var1106 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var1107 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1108 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var1109 ,
487: const std :: string & indent@var1110 = "    " ) const ;
488: void printOut ( const std :: string & text@var1111 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var1112 ;
491: TokenList & mTokenList@var1113 ;
492: const Settings * mSettings@var1114 ;
493: ErrorLogger * mErrorLogger@var1115 ;
494: bool mChanged@var1116 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var1117 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var1118 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var1119 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var1120 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var1121 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var1122 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var1123 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var1124 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var1125 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var1126 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var1127 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1128 ;
57: Token * back@var1129 ;
58: const TokenList * list@var1130 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1131 , const Token * bodyEnd_@var1132 , const std :: set < std :: string > & usingNamespaces_@var1133 = std :: set < std :: string > ( ) ) : name@var1134 ( name_@var1131 ) , bodyEnd@var1135 ( bodyEnd_@var1132 ) , usingNamespaces@var1136 ( usingNamespaces_@var1133 ) { }
63: std :: string name@var1134 ;
64: const Token * const bodyEnd@var1135 ;
65: std :: set < std :: string > usingNamespaces@var1136 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1137 ;
70: int mFileIndex@var1138 ;
71: int mLineNumber@var1139 ;
72: int mColumn@var1140 ;
73: int mExprId@var1141 ;
74:
75:
76: Token * mAstOperand1@var1142 ;
77: Token * mAstOperand2@var1143 ;
78: Token * mAstParent@var1144 ;
79:
80:
81: const Scope * mScope@var1145 ;
82: union {
83: const Function * mFunction@var1146 ;
84: const Variable * mVariable@var1147 ;
85: const :: Type * mType@var1148 ;
86: const Enumerator * mEnumerator@var1149 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1150 ;
94:
|
97:
98: int mIndex@var1151 ;
99:
100:
101: std :: string * mOriginalName@var1152 ;
102:
103:
104: ValueType * mValueType@var1153 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1154 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1155 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1156 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1157 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1158 ;
119: long long value@var1159 ;
120: struct CppcheckAttributes * next@var1160 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1161 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1162 ;
126:
127:
128: unsigned char mBits@var1163 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1164 , long long value@var1165 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1166 , long long * value@var1167 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1137 ( 0 )
135: , mFileIndex@var1138 ( 0 )
136: , mLineNumber@var1139 ( 0 )
137: , mColumn@var1140 ( 0 )
138: , mExprId@var1141 ( 0 )
139: , mAstOperand1@var1142 ( nullptr )
140: , mAstOperand2@var1143 ( nullptr )
141: , mAstParent@var1144 ( nullptr )
142: , mScope@var1145 ( nullptr )
143: , mFunction@var1146 ( nullptr )
144: , mProgressValue@var1150 ( 0 )
145: , mIndex@var1151 ( 0 )
146: , mOriginalName@var1152 ( nullptr )
147: , mValueType@var1153 ( nullptr )
148: , mValues@var1154 ( nullptr )
149: , mTemplateSimplifierPointers@var1156 ( nullptr )
150: , mScopeInfo@var1157 ( nullptr )
151: , mCppcheckAttributes@var1161 ( nullptr )
152: , mCpp11init@var1162 ( Cpp11init :: UNKNOWN )
153: , mBits@var1163 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1168 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1169 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1170 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1171 ) {
199: mStr@var1383 =@expr1073745727 s@var1171 ;
200: mImpl@var1389 .@expr1073745728 mVarId@var1420 =@expr1073745729 0 ;
201:
202: update_property_info (@expr1073745730 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1172 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1383 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1173 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1174 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1175 ) const ;
236: Token * tokAt ( int index@var1176 ) {
237: return const_cast < Token *@expr3907 > (@expr1073745732 const_cast < const Token *@expr3907 > (@expr1073745734 this@expr1073745735 ) .@expr1073745736 tokAt (@expr1073745737 index@var1176 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1177 ) const ;
245: Token * linkAt ( int index@var1178 ) {
246: return const_cast < Token *@expr3914 > (@expr1073745739 const_cast < const Token *@expr3914 > (@expr1073745741 this@expr1073745742 ) .@expr1073745743 linkAt (@expr1073745744 index@var1178 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1179 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1180 , const char ( & pattern@var1181 ) [ count ] ) {
276: return simpleMatch (@expr1073745746 tok@var1180 , pattern@var1181 , count@expr1073745745 -@expr1073745747 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1182 , const char pattern@var1183 [ ] , unsigned long pattern_len@var1184 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1185 , const char pattern@var1186 [ ] , int varid@var1187 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1188 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1189 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1190 , const Settings * const settings@var1191 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1192 , long long index@var1193 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1389 .@expr1073745748 mValueType@var1421 ;
366: }
367: void setValueType ( ValueType * vt@var1194 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1195 ; top@var1195 =@expr1073745749 this@expr1073745750 ;
371: while (@expr1073745751 top@var1195 &&@expr1073745752 !@expr1073745753 Token ::@expr1073745754 Match (@expr1073745755 top@var1195 .@expr3932 astParent (@expr3933 ) , ",|(" ) ) {
372: top@var1195 =@expr1073745758 top@var1195 .@expr3932 astParent (@expr3933 ) ; }
373: return top@var1195 ?@expr1073745761 top@var1195 .@expr1073745762 mImpl@var1196 .@expr1073745763 mValueType@var1197 :@expr1073745764 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1387 ;
378: }
379: void tokType ( Token :: Type t@var1198 ) {
380: mTokType@var1387 =@expr1073745765 t@var1198 ;
381:
382: const bool memoizedIsName@var1199 =@expr1073745766 mTokType@var1387 ==@expr1073745767 eName ||@expr1073745768 mTokType@var1387 ==@expr1073745769 eType ||@expr1073745770 mTokType@var1387 ==@expr1073745771 eVariable ||@expr1073745772
383: mTokType@var1387 ==@expr1073745773 eFunction ||@expr1073745774 mTokType@var1387 ==@expr1073745775 eKeyword ||@expr1073745776 mTokType@var1387 ==@expr3953 eBoolean ||@expr1073745778
384: mTokType@var1387 ==@expr3955 eEnumerator ;
385: setFlag (@expr1073745780 fIsName , memoizedIsName@var1199 ) ;
386:
387: const bool memoizedIsLiteral@var1200 =@expr1073745781 mTokType@var1387 ==@expr1073745782 eNumber ||@expr1073745783 mTokType@var1387 ==@expr1073745784 eString ||@expr1073745785 mTokType@var1387 ==@expr1073745786 eChar ||@expr1073745787
388: mTokType@var1387 ==@expr3953 eBoolean ||@expr1073745789 mTokType@var1387 ==@expr1073745790 eLiteral ||@expr1073745791 mTokType@var1387 ==@expr3955 eEnumerator ;
389: setFlag (@expr1073745793 fIsLiteral , memoizedIsLiteral@var1200 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1387 ==@expr1073745794 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745795 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1388 ==@expr1073745796 fIsName &&@expr1073745797 mTokType@var1387 ==@expr1073745798 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745799 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1387 ==@expr1073745800 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1387 ==@expr1073745801 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745802 isConstOp (@expr1073745803 ) ||@expr1073745804
412: isAssignmentOp (@expr1073745805 ) ||@expr1073745806
413: mTokType@var1387 ==@expr1073745807 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745808 isArithmeticalOp (@expr1073745809 ) ||@expr1073745810
417: mTokType@var1387 ==@expr1073745811 eLogicalOp ||@expr1073745812
418: mTokType@var1387 ==@expr1073745813 eComparisonOp ||@expr1073745814
419: mTokType@var1387 ==@expr1073745815 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745816 ) ||@expr1073745817
423: mTokType@var1387 ==@expr1073745818 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1387 ==@expr1073745819 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1387 ==@expr1073745820 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1387 ==@expr1073745821 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1387 ==@expr1073745822 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1387 ==@expr1073745823 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745824 ) !=@expr1073745825 nullptr &&@expr1073745826 astOperand2 (@expr1073745827 ) !=@expr1073745828 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1201 ) const {
444: return s@var1201 ==@expr1073745829 mStr@var1383 &&@expr1073745830 astOperand1 (@expr1073745831 ) !=@expr1073745832 nullptr &&@expr1073745833 astOperand2 (@expr1073745834 ) ==@expr1073745835 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1388 ;
450: }
451: void flags ( const unsigned int flags_@var1202 ) {
452: mFlags@var1388 =@expr1073745836 flags_@var1202 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745837 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1203 ) {
458: setFlag (@expr1073745838 fIsUnsigned , sign@var1203 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745839 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1204 ) {
464: setFlag (@expr1073745840 fIsSigned , sign@var1204 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745841 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1205 ) {
470: setFlag (@expr1073745842 fIsPointerCompare , b@var1205 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745843 fIsLong ) ;
474: }
475: void isLong ( bool size@var1206 ) {
476: setFlag (@expr1073745844 fIsLong , size@var1206 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745845 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1207 ) {
482: setFlag (@expr1073745846 fIsStandardType , b@var1207 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745847 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1208 ) {
488: setFlag (@expr1073745848 fIsExpandedMacro , m@var1208 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745849 fIsCast ) ;
492: }
493: void isCast ( bool c@var1209 ) {
494: setFlag (@expr1073745850 fIsCast , c@var1209 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745851 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1210 ) {
500: setFlag (@expr1073745852 fIsAttributeConstructor , ac@var1210 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745853 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1211 ) {
506: setFlag (@expr1073745854 fIsAttributeDestructor , value@var1211 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745855 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1212 ) {
512: setFlag (@expr1073745856 fIsAttributeUnused , unused@var1212 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745857 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1213 ) {
518: setFlag (@expr1073745858 fIsAttributeUsed , unused@var1213 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745859 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1214 ) {
524: setFlag (@expr1073745860 fIsAttributePure , value@var1214 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745861 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1215 ) {
530: setFlag (@expr1073745862 fIsAttributeConst , value@var1215 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745863 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1216 ) {
536: setFlag (@expr1073745864 fIsAttributeNoreturn , value@var1216 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745865 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1217 ) {
542: setFlag (@expr1073745866 fIsAttributeNothrow , value@var1217 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745867 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1218 ) {
548: setFlag (@expr1073745868 fIsAttributePacked , value@var1218 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745869 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1219 ) {
554: setFlag (@expr1073745870 fIsAttributeNodiscard , value@var1219 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745871 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1220 ) {
560: setFlag (@expr1073745872 fIsAttributeMaybeUnused , value@var1220 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1221 , long long value@var1222 ) {
563: mImpl@var1389 .@expr1073745873 setCppcheckAttribute (@expr1073745874 type@var1221 , value@var1222 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1223 , long long * value@var1224 ) const {
566: return mImpl@var1389 .@expr1073745875 getCppcheckAttribute (@expr1073745876 type@var1223 , value@var1224 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745877 mImpl@var1389 .@expr1073745878 mCppcheckAttributes@var1422 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745879 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745880 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1225 ) {
578: setFlag (@expr1073745881 fIsOperatorKeyword , value@var1225 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745882 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1226 ) {
584: setFlag (@expr1073745883 fIsComplex , value@var1226 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745884 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1227 ) {
590: setFlag (@expr1073745885 fIsEnumType , value@var1227 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745886 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1228 ) {
596: setFlag (@expr1073745887 fAtAddress , b@var1228 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745888 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1229 ) {
602: setFlag (@expr1073745889 fIncompleteVar , b@var1229 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745890 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1230 ) {
609: setFlag (@expr1073745891 fIsIncompleteConstant , b@var1230 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745892 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1231 ) {
616: setFlag (@expr1073745893 fConstexpr , b@var1231 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745894 fExternC ) ;
621: }
622: void isExternC ( bool b@var1232 ) {
623: setFlag (@expr1073745895 fExternC , b@var1232 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745896 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1233 ) {
630: setFlag (@expr1073745897 fIsSplitVarDeclComma , b@var1233 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745898 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1234 ) {
637: setFlag (@expr1073745899 fIsSplitVarDeclEq , b@var1234 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745900 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1235 ) {
644: setFlag (@expr1073745901 fIsImplicitInt , b@var1235 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745902 fIsInline ) ;
649: }
650: void isInline ( bool b@var1236 ) {
651: setFlag (@expr1073745903 fIsInline , b@var1236 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745904 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1237 ) {
658: setFlag (@expr1073745905 fIsRemovedVoidParameter , b@var1237 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745906 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1238 ) {
665: setFlag (@expr1073745907 fIsTemplate , b@var1238 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745908 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1239 ) {
672: setFlag (@expr1073745909 fIsSimplifedScope , b@var1239 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1389 .@expr1073745910 mBits@var1423 >@expr1073745911 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1389 .@expr1073745912 mBits@var1423 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1389 .@expr1073745913 mTemplateSimplifierPointers@var1424 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1240 ) {
685: if (@expr1073745914 !@expr1073745915 mImpl@var1389 .@expr4092 mTemplateSimplifierPointers@var1424 ) {
686: mImpl@var1389 .@expr4092 mTemplateSimplifierPointers@var1424 =@expr1073745918 new std ::@expr1073745919 set < TemplateSimplifier ::@expr1073745920 TokenAndName *@expr1073745921 > ; }
687: mImpl@var1389 .@expr4092 mTemplateSimplifierPointers@var1424 .@expr1073745923 insert (@expr1073745924 tokenAndName@var1240 ) ;
688: }
689: void setBits ( const unsigned char b@var1241 ) {
690: mImpl@var1389 .@expr1073745925 mBits@var1423 =@expr1073745926 b@var1241 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr4103 (@expr4103 (@expr4103 mTokType@var1387 ==@expr1073745930 eString ) &&@expr1073745931 isPrefixStringCharLiteral (@expr1073745932 mStr@var1383 , '"' , "u8" ) ) ||@expr1073745933
695: (@expr4103 (@expr4103 mTokType@var1387 ==@expr1073745936 eChar ) &&@expr1073745937 isPrefixStringCharLiteral (@expr1073745938 mStr@var1383 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr4115 (@expr4115 (@expr4115 mTokType@var1387 ==@expr1073745942 eString ) &&@expr1073745943 isPrefixStringCharLiteral (@expr1073745944 mStr@var1383 , '"' , "u" ) ) ||@expr1073745945
700: (@expr4115 (@expr4115 mTokType@var1387 ==@expr1073745948 eChar ) &&@expr1073745949 isPrefixStringCharLiteral (@expr1073745950 mStr@var1383 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr4127 (@expr4127 (@expr4127 mTokType@var1387 ==@expr1073745954 eString ) &&@expr1073745955 isPrefixStringCharLiteral (@expr1073745956 mStr@var1383 , '"' , "U" ) ) ||@expr1073745957
705: (@expr4127 (@expr4127 mTokType@var1387 ==@expr1073745960 eChar ) &&@expr1073745961 isPrefixStringCharLiteral (@expr1073745962 mStr@var1383 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr4139 (@expr4139 (@expr4139 mTokType@var1387 ==@expr1073745966 eString ) &&@expr1073745967 isPrefixStringCharLiteral (@expr1073745968 mStr@var1383 , '"' , "" ) ) ||@expr1073745969
710: (@expr4139 (@expr4139 mTokType@var1387 ==@expr1073745972 eChar ) &&@expr1073745973 isPrefixStringCharLiteral (@expr1073745974 mStr@var1383 , '\'' , "" ) &&@expr1073745975 mStr@var1383 .@expr1073745976 length (@expr1073745977 ) ==@expr1073745978 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr4155 (@expr4155 (@expr4155 mTokType@var1387 ==@expr1073745982 eChar ) &&@expr1073745983 isPrefixStringCharLiteral (@expr1073745984 mStr@var1383 , '\'' , "" ) ) &&@expr1073745985
715: (@expr4155 mStr@var1383 .@expr1073745987 length (@expr1073745988 ) >@expr1073745989 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745990 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1242 ) {
738: setFlag (@expr1073745991 fIsTemplateArg , value@var1242 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1243 , const char ( & pattern@var1244 ) [ count ] ) {
743: return findsimplematch (@expr1073745993 startTok@var1243 , pattern@var1244 , count@expr1073745992 -@expr1073745994 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1245 , const char pattern@var1246 [ ] , unsigned long pattern_len@var1247 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1248 , const char ( & pattern@var1249 ) [ count ] , const Token * const end@var1250 ) {
749: return findsimplematch (@expr1073745996 startTok@var1248 , pattern@var1249 , count@expr1073745995 -@expr1073745997 1 , end@var1250 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1251 , const char pattern@var1252 [ ] , unsigned long pattern_len@var1253 , const Token * const end@var1254 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1255 , const char pattern@var1256 [ ] , const int varId@var1257 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1258 , const char pattern@var1259 [ ] , const Token * const end@var1260 , const int varId@var1261 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1262 , const char ( & pattern@var1263 ) [ count ] ) {
758: return findsimplematch (@expr1073745999 startTok@var1262 , pattern@var1263 , count@expr1073745998 -@expr1073746000 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1264 , const char pattern@var1265 [ ] , unsigned long pattern_len@var1266 ) {
761: return const_cast < Token *@expr4177 > (@expr1073746002 findsimplematch (@expr1073746003 const_cast < const Token *@expr4177 > (@expr1073746005 startTok@var1264 ) , pattern@var1265 , pattern_len@var1266 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1267 , const char ( & pattern@var1268 ) [ count ] , const Token * const end@var1269 ) {
765: return findsimplematch (@expr1073746007 startTok@var1267 , pattern@var1268 , count@expr1073746006 -@expr1073746008 1 , end@var1269 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1270 , const char pattern@var1271 [ ] , unsigned long pattern_len@var1272 , const Token * const end@var1273 ) {
768: return const_cast < Token *@expr4185 > (@expr1073746010 findsimplematch (@expr1073746011 const_cast < const Token *@expr4185 > (@expr1073746013 startTok@var1270 ) , pattern@var1271 , pattern_len@var1272 , end@var1273 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1274 , const char pattern@var1275 [ ] , const int varId@var1276 = 0 ) {
772: return const_cast < Token *@expr4190 > (@expr1073746015 findmatch (@expr1073746016 const_cast < const Token *@expr4190 > (@expr1073746018 startTok@var1274 ) , pattern@var1275 , varId@var1276 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1277 , const char pattern@var1278 [ ] , const Token * const end@var1279 , const int varId@var1280 = 0 ) {
775: return const_cast < Token *@expr4195 > (@expr1073746020 findmatch (@expr1073746021 const_cast < const Token *@expr4195 > (@expr1073746023 startTok@var1277 ) , pattern@var1278 , end@var1279 , varId@var1280 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1281 , const char * haystack@var1282 , int varid@var1283 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1389 .@expr1073746024 mFileIndex@var1425 ;
796: }
797: void fileIndex ( int indexOfFile@var1284 ) {
798: mImpl@var1389 .@expr1073746025 mFileIndex@var1425 =@expr1073746026 indexOfFile@var1284 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1389 .@expr1073746027 mLineNumber@var1426 ;
803: }
804: void linenr ( int lineNumber@var1285 ) {
805: mImpl@var1389 .@expr1073746028 mLineNumber@var1426 =@expr1073746029 lineNumber@var1285 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1389 .@expr1073746030 mColumn@var1427 ;
810: }
811: void column ( int c@var1286 ) {
812: mImpl@var1389 .@expr1073746031 mColumn@var1427 =@expr1073746032 c@var1286 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1384 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1287 , const Token * end@var1288 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1289 , const std :: string & originalNameStr@var1290 = emptyString@var1 , bool prepend@var1291 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1292 , const std :: string & originalNameStr@var1293 = emptyString@var1 )
840: {
841: return insertToken (@expr1073746033 tokenStr@var1292 , originalNameStr@var1293 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1385 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1389 .@expr1073746034 mVarId@var1420 ;
851: }
852: void varId ( int id@var1294 ) {
853: mImpl@var1389 .@expr1073746035 mVarId@var1420 =@expr1073746036 id@var1294 ;
854: if (@expr1073746037 id@var1294 !=@expr1073746038 0 ) {
855: tokType (@expr1073746039 eVariable ) ;
856: isStandardType (@expr1073746040 false ) ;
857: } else {
858: update_property_info (@expr1073746041 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073746042 mImpl@var1389 .@expr4219 mExprId@var1428 ) {
864: return mImpl@var1389 .@expr4219 mExprId@var1428 ; }
865: return mImpl@var1389 .@expr1073746045 mVarId@var1420 ;
866: }
867: void exprId ( int id@var1295 ) {
868: mImpl@var1389 .@expr1073746046 mExprId@var1428 =@expr1073746047 id@var1295 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1296 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1297 , const std :: vector < std :: string > & fileNames@var1298 ) const ;
888:
|
891:
892: void printLines ( int lines@var1299 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1300 , Token * start@var1301 , Token * end@var1302 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1303 ; varid@var1303 = false ;
905: bool exprid@var1304 ; exprid@var1304 = false ;
906: bool idtype@var1305 ; idtype@var1305 = false ;
907: bool attributes@var1306 ; attributes@var1306 = false ;
908: bool macro@var1307 ; macro@var1307 = false ;
909: bool linenumbers@var1308 ; linenumbers@var1308 = false ;
910: bool linebreaks@var1309 ; linebreaks@var1309 = false ;
911: bool files@var1310 ; files@var1310 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1311 ;
914: options@var1311 .@expr1073746048 attributes@var1312 =@expr1073746049 true ;
915: options@var1311 .@expr1073746050 macro@var1313 =@expr1073746051 true ;
916: options@var1311 .@expr1073746052 linenumbers@var1314 =@expr1073746053 true ;
917: options@var1311 .@expr1073746054 linebreaks@var1315 =@expr1073746055 true ;
918: options@var1311 .@expr1073746056 files@var1316 =@expr1073746057 true ;
919: return options@var1311 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1317 ; options@var1317 =@expr1073746058 forDebug (@expr1073746059 ) ;
923: options@var1317 .@expr1073746060 varid@var1318 =@expr1073746061 true ;
924: return options@var1317 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1319 ; options@var1319 =@expr1073746062 forDebug (@expr1073746063 ) ;
928: options@var1319 .@expr1073746064 exprid@var1320 =@expr1073746065 true ;
929: return options@var1319 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1321 ; options@var1321 =@expr1073746066 forDebug (@expr1073746067 ) ;
933: options@var1321 .@expr1073746068 exprid@var1322 =@expr1073746069 true ;
934: options@var1321 .@expr1073746070 varid@var1323 =@expr1073746071 true ;
935: options@var1321 .@expr1073746072 idtype@var1324 =@expr1073746073 true ;
936: return options@var1321 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1325 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1326 , bool attributes@var1327 , bool macro@var1328 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1329 , const std :: vector < std :: string > * fileNames@var1330 = nullptr , const Token * end@var1331 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1332 , bool attributes@var1333 = true ) const ;
952: std :: string stringifyList ( bool varid@var1334 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1335 , bool attributes@var1336 , bool linenumbers@var1337 , bool linebreaks@var1338 , bool files@var1339 , const std :: vector < std :: string > * fileNames@var1340 = nullptr , const Token * end@var1341 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1342 ) {
983: mLink@var1386 =@expr1073746074 linkToToken@var1342 ;
984: if (@expr1073746075 mStr@var1383 ==@expr1073746076 "<" ||@expr1073746077 mStr@var1383 ==@expr1073746078 ">" ) {
985: update_property_info (@expr1073746079 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1386 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1343 ) {
1006: mImpl@var1389 .@expr1073746080 mScope@var1429 =@expr1073746081 s@var1343 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1389 .@expr1073746082 mScope@var1429 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1344 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1387 ==@expr1073746083 eFunction ||@expr1073746084 mTokType@var1387 ==@expr1073746085 eLambda ?@expr1073746086 mImpl@var1389 .@expr1073746087 mFunction@var1430 :@expr1073746088 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1345 ) {
1034: mImpl@var1389 .@expr1073746089 mVariable@var1431 =@expr1073746090 v@var1345 ;
1035: if (@expr1073746091 v@var1345 ||@expr1073746092 mImpl@var1389 .@expr1073746093 mVarId@var1420 ) {
1036: tokType (@expr1073746094 eVariable ) ; }
1037: else { if (@expr1073746095 mTokType@var1387 ==@expr1073746096 eVariable ) {
1038: tokType (@expr1073746097 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1387 ==@expr1073746098 eVariable ?@expr1073746099 mImpl@var1389 .@expr1073746100 mVariable@var1431 :@expr1073746101 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1346 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1387 ==@expr1073746102 eType ?@expr1073746103 mImpl@var1389 .@expr1073746104 mType@var1432 :@expr1073746105 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1347 , const Token * * typeTok@var1348 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1349 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1350 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1387 ==@expr1073746106 eEnumerator ?@expr1073746107 mImpl@var1389 .@expr1073746108 mEnumerator@var1433 :@expr1073746109 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1351 ) {
1079: mImpl@var1389 .@expr1073746110 mEnumerator@var1433 =@expr1073746111 e@var1351 ;
1080: if (@expr1073746112 e@var1351 ) {
1081: tokType (@expr1073746113 eEnumerator ) ; }
1082: else { if (@expr1073746114 mTokType@var1387 ==@expr1073746115 eEnumerator ) {
1083: tokType (@expr1073746116 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1352 , Token * end@var1353 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1354 , Token * srcEnd@var1355 , Token * newLocation@var1356 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1389 .@expr1073746117 mProgressValue@var1434 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1357 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1389 .@expr4294 mOriginalName@var1435 ?@expr1073746119 *@expr1073746120 mImpl@var1389 .@expr4294 mOriginalName@var1435 :@expr1073746122 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1389 .@expr4299 mValues@var1408 ?@expr1073746124 *@expr1073746125 mImpl@var1389 .@expr4299 mValues@var1408 :@expr1073746127 TokenImpl ::@expr1073746128 mEmptyValueList@var1155 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1358 ) {
1164: if (@expr1073746129 !@expr1073746130 mImpl@var1389 .@expr4307 mOriginalName@var1435 ) {
1165: mImpl@var1389 .@expr4307 mOriginalName@var1435 =@expr1073746133 new std ::@expr1073746134 string (@expr1073746135 name@var1358 ) ; }
1166: else {
1167: *@expr1073746136 mImpl@var1389 .@expr4307 mOriginalName@var1435 =@expr1073746138 name@var1358 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1359 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1360 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1361 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1389 .@expr1073746140 mValues@var1408 .@expr1073746141 front (@expr1073746142 ) .@expr1073746143 intvalue@expr1073746139 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1362 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1363 , long long path@var1364 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1365 , const Settings * settings@var1366 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1367 , const Settings * settings@var1368 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1369 , int argnr@var1370 , const Settings * settings@var1371 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1372 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1373 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1374 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1375 ) {
1200: if (@expr1073746144 mImpl@var1389 .@expr4321 mValues@var1408 ) {
1201: mImpl@var1389 .@expr4321 mValues@var1408 .@expr1073746147 remove_if (@expr1073746148 pred@var1375 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1389 .@expr1073746149 mIndex@var1436 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1376 ) {
1213: mNext@var1384 =@expr1073746150 nextToken@var1376 ;
1214: }
1215: void previous ( Token * previousToken@var1377 ) {
1216: mPrevious@var1385 =@expr1073746151 previousToken@var1377 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1378 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1379 , const char * word@var1380 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1381 , char c@var1382 ) ;
1235:
1236: std :: string mStr@var1383 ;
1237:
1238: Token * mNext@var1384 ;
1239: Token * mPrevious@var1385 ;
1240: Token * mLink@var1386 ;
1241:
1242: enum Anonymous2 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1387 ;
1283:
1284: uint64_t mFlags@var1388 ;
1285:
1286: TokenImpl * mImpl@var1389 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1390 ) const {
1294: return (@expr4328 (@expr4328 mFlags@var1388 &@expr1073746154 flag_@var1390 ) !=@expr1073746155 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1391 , bool state_@var1392 ) {
1303: mFlags@var1388 =@expr1073746156 state_@var1392 ?@expr1073746157 mFlags@var1388 |@expr1073746158 flag_@var1391 :@expr1073746159 mFlags@var1388 &@expr1073746160 ~@expr1073746161 flag_@var1391 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1393 , const int indent1@var1394 = 0 , const int indent2@var1395 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1396 ) ;
1321: void astOperand2 ( Token * tok@var1397 ) ;
1322: void astParent ( Token * tok@var1398 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1389 .@expr1073746162 mAstOperand1@var1399 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1389 .@expr1073746163 mAstOperand1@var1399 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1389 .@expr1073746164 mAstOperand2@var1400 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1389 .@expr1073746165 mAstOperand2@var1400 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1389 .@expr1073746166 mAstParent@var1401 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1389 .@expr1073746167 mAstParent@var1401 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073746168 !@expr1073746169 astParent (@expr4346 ) ) {
1344: return nullptr ; }
1345: if (@expr1073746171 this@expr4348 ==@expr1073746173 astParent (@expr4346 ) .@expr4351 astOperand1 (@expr4352 ) ) {
1346: return astParent (@expr4346 ) .@expr4354 astOperand2 (@expr4355 ) ; }
1347: else { if (@expr1073746180 this@expr4348 ==@expr1073746181 astParent (@expr4346 ) .@expr4354 astOperand2 (@expr4355 ) ) {
1348: return astParent (@expr4346 ) .@expr4351 astOperand1 (@expr4352 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073746188 !@expr1073746189 astParent (@expr4366 ) ) {
1354: return nullptr ; }
1355: if (@expr1073746191 this@expr4368 ==@expr1073746193 astParent (@expr4366 ) .@expr4371 astOperand1 (@expr4372 ) ) {
1356: return astParent (@expr4366 ) .@expr4374 astOperand2 (@expr4375 ) ; }
1357: else { if (@expr1073746200 this@expr4368 ==@expr1073746201 astParent (@expr4366 ) .@expr4374 astOperand2 (@expr4375 ) ) {
1358: return astParent (@expr4366 ) .@expr4371 astOperand1 (@expr4372 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1402 ; ret@var1402 =@expr1073746208 this@expr1073746209 ;
1364: while (@expr1073746210 ret@var1402 .@expr4387 mImpl@var1403 .@expr4388 mAstParent@var1404 ) {
1365: ret@var1402 =@expr1073746213 ret@var1402 .@expr4387 mImpl@var1403 .@expr4388 mAstParent@var1404 ; }
1366: return ret@var1402 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1405 ; ret@var1405 =@expr1073746216 this@expr1073746217 ;
1371: while (@expr1073746218 ret@var1405 .@expr4395 mImpl@var1406 .@expr4396 mAstParent@var1407 ) {
1372: ret@var1405 =@expr1073746221 ret@var1405 .@expr4395 mImpl@var1406 .@expr4396 mAstParent@var1407 ; }
1373: return ret@var1405 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1389 .@expr1073746224 mAstOperand1@var1399 =@expr1073746225 mImpl@var1389 .@expr1073746226 mAstOperand2@var1400 =@expr1073746227 mImpl@var1389 .@expr1073746228 mAstParent@var1401 =@expr1073746229 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1389 .@expr4406 mValues@var1408 ;
1393: mImpl@var1389 .@expr4406 mValues@var1408 =@expr1073746232 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1409 = "" ) const {
1397: std ::@expr1073746233 string ret@var1410 ;
1398: if (@expr1073746234 mImpl@var1389 .@expr4411 mAstOperand1@var1399 ) {
1399: ret@var1410 =@expr1073746236 mImpl@var1389 .@expr4411 mAstOperand1@var1399 .@expr1073746238 astString (@expr1073746239 sep@var1409 ) ; }
1400: if (@expr1073746240 mImpl@var1389 .@expr4417 mAstOperand2@var1400 ) {
1401: ret@var1410 +=@expr1073746242 mImpl@var1389 .@expr4417 mAstOperand2@var1400 .@expr1073746244 astString (@expr1073746245 sep@var1409 ) ; }
1402: return ret@var1410 +@expr1073746246 sep@var1409 +@expr1073746247 mStr@var1383 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1411 , bool xml@var1412 , const std :: vector < std :: string > & fileNames@var1413 , std :: ostream & out@var1414 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1415 , std :: ostream & out@var1416 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1417 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1418 ) const {
1419: mImpl@var1389 .@expr1073746248 mCpp11init@var1419 =@expr1073746249 cpp11init@var1418 ?@expr1073746250 TokenImpl ::@expr4427 Cpp11init ::@expr1073746252 CPP11INIT :@expr1073746253 TokenImpl ::@expr4427 Cpp11init ::@expr1073746255 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1389 .@expr1073746256 mCpp11init@var1419 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1437 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1438 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1439 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1440 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1441 ( nullptr ) , num@var1442 ( 0 ) , known@var1443 ( true ) { }
62:
63: const Token * tok@var1441 ;
64: long long num@var1442 ;
65: bool known@var1443 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1444 ;
72: const Scope * classScope@var1445 ;
73: const Scope * enclosingScope@var1446 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1447 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1449 ( nullptr ) , nameTok@var1450 ( nullptr ) , access@var1451 ( AccessControl :: Public ) , isVirtual@var1452 ( false ) { }
82:
83: std :: string name@var1448 ;
84: const Type * type@var1449 ;
85: const Token * nameTok@var1450 ;
86: AccessControl access@var1451 ;
87: bool isVirtual@var1452 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1453 ) const {
90: return this@expr1073746257 .@expr1073746258 type@var1449 <@expr1073746259 rhs@var1453 .@expr1073746260 type@var1454 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1455 ( nullptr ) , nameEnd@var1456 ( nullptr ) , type@var1457 ( nullptr ) { }
97:
98: const Token * nameStart@var1455 ;
99: const Token * nameEnd@var1456 ;
100: const Type * type@var1457 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1458 ;
104: std :: vector < FriendInfo > friendList@var1459 ;
105:
106: const Token * typeStart@var1460 ;
107: const Token * typeEnd@var1461 ;
108: long long sizeOf@var1462 ;
109:
110: Type ( const Token * classDef_@var1463 = nullptr , const Scope * classScope_@var1464 = nullptr , const Scope * enclosingScope_@var1465 = nullptr ) :
111: classDef@var1444 ( classDef_@var1463 ) ,
112: classScope@var1445 ( classScope_@var1464 ) ,
113: enclosingScope@var1446 ( enclosingScope_@var1465 ) ,
114: needInitialization@var1447 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1460 ( nullptr ) ,
116: typeEnd@var1461 ( nullptr ) ,
117: sizeOf@var1462 ( 0 ) {
118: if (@expr1073746261 classDef_@var1463 &&@expr1073746262 classDef_@var1463 .@expr4439 str (@expr4440 ) ==@expr1073746265 "enum" ) {
119: needInitialization@var1447 =@expr1073746266 NeedInitialization ::@expr1073746267 True ; }
120: else { if (@expr1073746268 classDef_@var1463 &&@expr1073746269 classDef_@var1463 .@expr4439 str (@expr4440 ) ==@expr1073746272 "using" ) {
121: typeStart@var1460 =@expr1073746273 classDef@var1444 .@expr1073746274 tokAt (@expr1073746275 3 ) ;
122: typeEnd@var1461 =@expr1073746276 typeStart@var1460 ;
123: while (@expr1073746277 typeEnd@var1461 .@expr4454 next (@expr4455 ) &&@expr1073746280 typeEnd@var1461 .@expr4454 next (@expr4455 ) .@expr1073746283 str (@expr1073746284 ) !=@expr1073746285 ";" ) {
124: typeEnd@var1461 =@expr1073746286 typeEnd@var1461 .@expr4454 next (@expr4455 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1444 ?@expr1073746289 classDef@var1444 .@expr1073746290 str (@expr1073746291 ) :@expr1073746292 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1444 &&@expr1073746293 classDef@var1444 .@expr1073746294 str (@expr1073746295 ) ==@expr1073746296 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1466 , const Token * tok1@var1467 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1468 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1469 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1470 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1471 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1472 ) : scope@var1473 ( scope_@var1472 ) , name@var1474 ( nullptr ) , value@var1475 ( 0 ) , start@var1476 ( nullptr ) , end@var1477 ( nullptr ) , value_known@var1478 ( false ) { }
167: const Scope * scope@var1473 ;
168: const Token * name@var1474 ;
169: long long value@var1475 ;
170: const Token * start@var1476 ;
171: const Token * end@var1477 ;
172: bool value_known@var1478 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous3 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1479 ) const {
204: return (@expr4473 (@expr4473 mFlags@var1515 &@expr1073746299 flag_@var1479 ) !=@expr1073746300 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1480 , bool state_@var1481 ) {
213: mFlags@var1515 =@expr1073746301 state_@var1481 ?@expr1073746302 mFlags@var1515 |@expr1073746303 flag_@var1480 :@expr1073746304 mFlags@var1515 &@expr1073746305 ~@expr1073746306 flag_@var1480 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1482 , bool * isContainer@var1483 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1484 , const Token * start_@var1485 , const Token * end_@var1486 ,
226: int index_@var1487 , AccessControl access_@var1488 , const Type * type_@var1489 ,
227: const Scope * scope_@var1490 , const Settings * settings@var1491 )
228: : mNameToken@var1510 ( name_@var1484 ) ,
229: mTypeStartToken@var1511 ( start_@var1485 ) ,
230: mTypeEndToken@var1512 ( end_@var1486 ) ,
231: mIndex@var1513 ( index_@var1487 ) ,
232: mAccess@var1514 ( access_@var1488 ) ,
233: mFlags@var1515 ( 0 ) ,
234: mType@var1516 ( type_@var1489 ) ,
235: mScope@var1517 ( scope_@var1490 ) ,
236: mValueType@var1518 ( nullptr ) {
237: evaluate (@expr1073746307 settings@var1491 ) ;
238: }
239:
240: Variable ( const Token * name_@var1492 , const std :: string & clangType@var1493 , const Token * typeStart@var1494 ,
241: const Token * typeEnd@var1495 , int index_@var1496 , AccessControl access_@var1497 ,
242: const Type * type_@var1498 , const Scope * scope_@var1499 ) ;
243:
244: Variable ( const Variable & var@var1500 , const Scope * scope@var1501 ) ;
245:
246: Variable ( const Variable & var@var1502 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1503 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1510 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1511 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1512 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746308 mNameToken@var1510 ) {
300: return mNameToken@var1510 .@expr1073746309 str (@expr1073746310 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746311 mNameToken@var1510 ) {
312: return mNameToken@var1510 .@expr1073746312 varId (@expr1073746313 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1513 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1514 ==@expr1073746314 AccessControl ::@expr1073746315 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1514 ==@expr1073746316 AccessControl ::@expr1073746317 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1514 ==@expr1073746318 AccessControl ::@expr1073746319 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1514 ==@expr1073746320 AccessControl ::@expr1073746321 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1514 ==@expr1073746322 AccessControl ::@expr1073746323 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1514 ==@expr1073746324 AccessControl ::@expr1073746325 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746327 mAccess@var1514 ==@expr1073746328 AccessControl ::@expr1073746329 Local@expr1073746326 ) &&@expr1073746330 !@expr1073746331 isExtern (@expr1073746332 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746333 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746334 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746335 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746336 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746337 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1514 ==@expr1073746338 AccessControl ::@expr1073746339 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746340 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746341 fIsArray ) &&@expr1073746342 !@expr1073746343 getFlag (@expr1073746344 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746345 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746346 ) &&@expr1073746347 getFlag (@expr1073746348 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746349 fIsArray ) ||@expr1073746350 getFlag (@expr1073746351 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746352 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746353 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746354 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746355 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1516 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1516 ?@expr1073746356 mType@var1516 .@expr1073746357 classScope@var1521 :@expr1073746358 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1517 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1519 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1504 ) const {
550: return mDimensions@var1519 [@expr1073746359 index_@var1504 ] .@expr1073746360 num@var2935 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1505 ) const {
558: return mDimensions@var1519 [@expr1073746361 index_@var1505 ] .@expr1073746362 known@var2936 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746363 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746364 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746365 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1506 ) const {
602: return isStlType (@expr1073746366 ) &&@expr1073746367 stlType@var1506 ==@expr1073746368 mTypeStartToken@var1511 .@expr1073746369 strAt (@expr1073746370 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1507 ) const {
616: return isStlType (@expr1073746371 ) &&@expr1073746372 stlTypes@var1507 .@expr1073746373 find (@expr1073746374 mTypeStartToken@var1511 .@expr1073746375 strAt (@expr1073746376 2 ) ) !=@expr1073746377 stlTypes@var1507 .@expr1073746378 end (@expr1073746379 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746380 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4557 ) &&@expr1073746382 type (@expr4557 ) .@expr1073746384 isEnumType (@expr1073746385 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746386 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1518 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1508 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1514 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1509 ) {
660: mType@var1516 =@expr1073746387 t@var1509 ;
661: }
662:
663:
664: const Token * mNameToken@var1510 ;
665:
666:
667: const Token * mTypeStartToken@var1511 ;
668:
669:
670: const Token * mTypeEndToken@var1512 ;
671:
672:
673: int mIndex@var1513 ;
674:
675:
676: AccessControl mAccess@var1514 ;
677:
678:
679: unsigned int mFlags@var1515 ;
680:
681:
682: const Type * mType@var1516 ;
683:
684:
685: const Scope * mScope@var1517 ;
686:
687: ValueType * mValueType@var1518 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1519 ;
691:
692:
693: void evaluate ( const Settings * settings@var1520 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous4 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1522 ) const {
735: return (@expr4564 (@expr4564 mFlags@var1571 &@expr1073746390 flag@var1522 ) !=@expr1073746391 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1523 , bool state@var1524 ) {
744: mFlags@var1571 =@expr1073746392 state@var1524 ?@expr1073746393 mFlags@var1571 |@expr1073746394 flag@var1523 :@expr1073746395 mFlags@var1571 &@expr1073746396 ~@expr1073746397 flag@var1523 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1525 , const Token * tok@var1526 , const Scope * scope@var1527 , const Token * tokDef@var1528 , const Token * tokArgDef@var1529 ) ;
751: Function ( const Token * tokenDef@var1530 , const std :: string & clangType@var1531 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1541 .@expr1073746398 str (@expr1073746399 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1549 .@expr1073746400 size (@expr1073746401 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1549 .@expr1073746402 size (@expr1073746403 ) -@expr1073746404 initArgCount@var1550 ;
764: }
765: const Variable * getArgumentVar ( int num@var1532 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1550 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1533 , const Scope * scope@var1534 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1535 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1536 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1551 ==@expr1073746405 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1551 ==@expr1073746406 eConstructor ||@expr1073746407
785: type@var1551 ==@expr1073746408 eCopyConstructor ||@expr1073746409
786: type@var1551 ==@expr1073746410 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1551 ==@expr1073746411 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1541 .@expr1073746412 isAttributeConstructor (@expr1073746413 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1541 .@expr1073746414 isAttributeDestructor (@expr1073746415 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1541 .@expr1073746416 isAttributePure (@expr1073746417 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1541 .@expr1073746418 isAttributeConst (@expr1073746419 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1541 .@expr1073746420 isAttributeNoreturn (@expr1073746421 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1541 .@expr1073746422 isAttributeNothrow (@expr1073746423 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1541 .@expr1073746424 isAttributeNodiscard (@expr1073746425 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746426 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746427 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746428 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746429 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746430 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746431 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746432 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746433 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746434 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746435 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746436 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746437 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746438 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746439 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746440 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746441 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746442 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746443 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746444 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746445 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746446 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746447 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1537 ) {
881: setFlag (@expr1073746448 fHasBody , state@var1537 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746449 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746450 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1538 ) {
891: setFlag (@expr1073746451 fIsEscapeFunction , state@var1538 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746452 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1539 ) {
898: setFlag (@expr1073746453 fIsConstexpr , state@var1539 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1540 ) const ;
901:
902: const Token * tokenDef@var1541 ;
903: const Token * argDef@var1542 ;
904: const Token * token@var1543 ;
905: const Token * arg@var1544 ;
906: const Token * retDef@var1545 ;
907: const :: Type * retType@var1546 ;
908: const Scope * functionScope@var1547 ;
909: const Scope * nestedIn@var1548 ;
910: std :: list < Variable > argumentList@var1549 ;
911: int initArgCount@var1550 ;
912: Type type@var1551 ;
913: AccessControl access@var1552 ;
914: const Token * noexceptArg@var1553 ;
915: const Token * throwArg@var1554 ;
916: const Token * templateDef@var1555 ;
917: const Token * functionPointerUsage@var1556 ;
918:
919: bool argsMatch ( const Scope * scope@var1557 , const Token * first@var1558 , const Token * second@var1559 , const std :: string & path@var1560 , int path_length@var1561 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1562 , bool unknown@var1563 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1564 , bool unknown@var1565 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1566 , bool unknown@var1567 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1568 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746454 this@expr1073746455 .@expr1073746456 hasTrailingReturnType (@expr1073746457 ) ) {
931: return Token ::@expr1073746458 findmatch (@expr1073746459 retDef@var1545 , "{|;" ) ;
932: } else {
933: return tokenDef@var1541 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1569 , bool * foundAllBaseClasses@var1570 ) const ;
946:
947: unsigned int mFlags@var1571 ;
948:
949: void isInline ( bool state@var1572 ) {
950: setFlag (@expr1073746460 fIsInline , state@var1572 ) ;
951: }
952: void isConst ( bool state@var1573 ) {
953: setFlag (@expr1073746461 fIsConst , state@var1573 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1574 ) {
956: setFlag (@expr1073746462 fHasVirtualSpecifier , state@var1574 ) ;
957: }
958: void isPure ( bool state@var1575 ) {
959: setFlag (@expr1073746463 fIsPure , state@var1575 ) ;
960: }
961: void isStatic ( bool state@var1576 ) {
962: setFlag (@expr1073746464 fIsStatic , state@var1576 ) ;
963: }
964: void isStaticLocal ( bool state@var1577 ) {
965: setFlag (@expr1073746465 fIsStaticLocal , state@var1577 ) ;
966: }
967: void isExtern ( bool state@var1578 ) {
968: setFlag (@expr1073746466 fIsExtern , state@var1578 ) ;
969: }
970: void isFriend ( bool state@var1579 ) {
971: setFlag (@expr1073746467 fIsFriend , state@var1579 ) ;
972: }
973: void isExplicit ( bool state@var1580 ) {
974: setFlag (@expr1073746468 fIsExplicit , state@var1580 ) ;
975: }
976: void isDefault ( bool state@var1581 ) {
977: setFlag (@expr1073746469 fIsDefault , state@var1581 ) ;
978: }
979: void isDelete ( bool state@var1582 ) {
980: setFlag (@expr1073746470 fIsDelete , state@var1582 ) ;
981: }
982: void isNoExcept ( bool state@var1583 ) {
983: setFlag (@expr1073746471 fIsNoExcept , state@var1583 ) ;
984: }
985: void isThrow ( bool state@var1584 ) {
986: setFlag (@expr1073746472 fIsThrow , state@var1584 ) ;
987: }
988: void isOperator ( bool state@var1585 ) {
989: setFlag (@expr1073746473 fIsOperator , state@var1585 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1586 ) {
992: setFlag (@expr1073746474 fHasLvalRefQual , state@var1586 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1587 ) {
995: setFlag (@expr1073746475 fHasRvalRefQual , state@var1587 ) ;
996: }
997: void isVariadic ( bool state@var1588 ) {
998: setFlag (@expr1073746476 fIsVariadic , state@var1588 ) ;
999: }
1000: void isVolatile ( bool state@var1589 ) {
1001: setFlag (@expr1073746477 fIsVolatile , state@var1589 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1590 ) {
1004: return setFlag (@expr1073746478 fHasTrailingReturnType , state@var1590 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1591 ) {
1007: setFlag (@expr1073746479 fIsInlineKeyword , state@var1591 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1592 , const Scope * scope@var1593 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1594 ;
1019: const Scope * scope@var1595 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1596 , const Token * classDef_@var1597 , const Scope * nestedIn_@var1598 ) ;
1025: Scope ( const SymbolDatabase * check_@var1599 , const Token * classDef_@var1600 , const Scope * nestedIn_@var1601 , ScopeType type_@var1602 , const Token * start_@var1603 ) ;
1026:
1027: const SymbolDatabase * check@var1604 ;
1028: std :: string className@var1605 ;
1029: const Token * classDef@var1606 ;
1030: const Token * bodyStart@var1607 ;
1031: const Token * bodyEnd@var1608 ;
1032: std :: list < Function > functionList@var1609 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1610 ;
1034: std :: list < Variable > varlist@var1611 ;
1035: const Scope * nestedIn@var1612 ;
1036: std :: list < Scope * > nestedList@var1613 ;
1037: int numConstructors@var1614 ;
1038: int numCopyOrMoveConstructors@var1615 ;
1039: std :: list < UsingInfo > usingList@var1616 ;
1040: ScopeType type@var1617 ;
1041: Type * definedType@var1618 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1619 ;
1043: std :: vector < const Token * > bodyStartList@var1620 ;
1044:
1045:
1046: const Scope * functionOf@var1621 ;
1047: Function * function@var1622 ;
1048:
1049:
1050: const Token * enumType@var1623 ;
1051: bool enumClass@var1624 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1625 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1626 ) {
1056: bodyStart@var1607 =@expr1073746480 start@var1626 ;
1057: bodyEnd@var1608 =@expr1073746481 start@var1626 ?@expr1073746482 start@var1626 .@expr1073746483 link (@expr1073746484 ) :@expr1073746485 nullptr ;
1058: if (@expr1073746486 start@var1626 ) {
1059: bodyStartList@var1620 .@expr1073746487 push_back (@expr1073746488 start@var1626 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1605 .@expr1073746489 size (@expr1073746490 ) >@expr1073746491 9 &&@expr1073746492 className@var1605 .@expr1073746493 compare (@expr1073746494 0 , 9 , "Anonymous" ) ==@expr1073746495 0 &&@expr1073746496 std ::@expr1073746497 isdigit (@expr1073746498 className@var1605 [@expr1073746499 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1627 ) const {
1068: for (@expr1073746500 const Enumerator &@expr1073746501 i@var1628 :@expr1073746502 enumeratorList@var1625 ) {
1069: if (@expr1073746503 i@var1628 .@expr1073746504 name@var1629 .@expr1073746505 str (@expr1073746506 ) ==@expr1073746507 name@var1627 ) {
1070: return &@expr1073746508 i@var1628 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1630 ) const {
1076: if (@expr1073746509 !@expr1073746510 outer@var1630 ) {
1077: return false ; }
1078: if (@expr1073746511 outer@var1630 ==@expr1073746512 this@expr1073746513 ) {
1079: return true ; }
1080: const Scope * parent@var1631 ; parent@var1631 =@expr1073746514 nestedIn@var1612 ;
1081: while (@expr1073746515 outer@var1630 !=@expr1073746516 parent@var1631 &&@expr1073746517 parent@var1631 ) {
1082: parent@var1631 =@expr1073746518 parent@var1631 .@expr1073746519 nestedIn@var1632 ; }
1083: if (@expr1073746520 parent@var1631 &&@expr1073746521 parent@var1631 ==@expr1073746522 outer@var1630 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1633 ) {
1089: while (@expr1073746523 scope@var1633 ) {
1090: if (@expr1073746524 scope@var1633 .@expr1073746525 type@var1634 ==@expr1073746526 Scope ::@expr1073746527 eFunction ) {
1091: break ; }
1092: scope@var1633 =@expr1073746528 scope@var1633 .@expr1073746529 nestedIn@var1635 ;
1093: }
1094: if (@expr1073746530 !@expr1073746531 scope@var1633 ) {
1095: return nullptr ; }
1096: return scope@var1633 .@expr1073746532 function@var1636 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746533 type@var1617 ==@expr1073746534 eClass ||@expr1073746535 type@var1617 ==@expr1073746536 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746537 type@var1617 ==@expr1073746538 eClass ||@expr1073746539 type@var1617 ==@expr1073746540 eStruct ||@expr1073746541 type@var1617 ==@expr1073746542 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1617 !=@expr1073746543 eClass &&@expr1073746544 type@var1617 !=@expr1073746545 eStruct &&@expr1073746546 type@var1617 !=@expr1073746547 eUnion &&@expr1073746548 type@var1617 !=@expr1073746549 eGlobal &&@expr1073746550 type@var1617 !=@expr1073746551 eNamespace &&@expr1073746552 type@var1617 !=@expr1073746553 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1617 ==@expr1073746554 Scope ::@expr4731 ScopeType ::@expr1073746556 eFor ||@expr1073746557 type@var1617 ==@expr1073746558 Scope ::@expr4731 ScopeType ::@expr1073746560 eWhile ||@expr1073746561 type@var1617 ==@expr1073746562 Scope ::@expr4731 ScopeType ::@expr1073746564 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746565 type@var1617 ==@expr1073746566 eIf ||@expr1073746567 type@var1617 ==@expr1073746568 eElse ||@expr1073746569
1117: type@var1617 ==@expr1073746570 eFor ||@expr1073746571 type@var1617 ==@expr1073746572 eWhile ||@expr1073746573 type@var1617 ==@expr1073746574 eDo ||@expr1073746575
1118: type@var1617 ==@expr1073746576 eSwitch ||@expr1073746577 type@var1617 ==@expr1073746578 eUnconditional ||@expr1073746579
1119: type@var1617 ==@expr1073746580 eTry ||@expr1073746581 type@var1617 ==@expr1073746582 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1637 , bool requireConst@var1638 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1639 , bool isC@var1640 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1641 ) {
1135: return const_cast < Scope *@expr4759 > (@expr1073746584 const_cast < const Scope *@expr4759 > (@expr1073746586 this@expr1073746587 ) .@expr1073746588 findRecordInNestedList (@expr1073746589 name@var1641 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1642 ) const ;
1139: Type * findType ( const std :: string & name@var1643 ) {
1140: return const_cast < Type *@expr4766 > (@expr1073746591 const_cast < const Scope *@expr4766 > (@expr1073746593 this@expr1073746594 ) .@expr1073746595 findType (@expr1073746596 name@var1643 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1644 ) ;
1148:
1149: void addVariable ( const Token * token_@var1645 , const Token * start_@var1646 ,
1150: const Token * end_@var1647 , AccessControl access_@var1648 , const Type * type_@var1649 ,
1151: const Scope * scope_@var1650 , const Settings * settings@var1651 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1652 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1653 ) {
1159: functionList@var1609 .@expr1073746597 push_back (@expr1073746598 func@var1653 ) ;
1160:
1161: const Function * back@var1654 ; back@var1654 =@expr1073746599 &@expr1073746600 functionList@var1609 .@expr1073746601 back (@expr1073746602 ) ;
1162:
1163: functionMap@var1610 .@expr1073746603 insert (@expr1073746604 make_pair (@expr1073746605 back@var1654 .@expr1073746606 tokenDef@var1655 .@expr1073746607 str (@expr1073746608 ) , back@var1654 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1656 , AccessControl varaccess@var1657 , const Settings * settings@var1658 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1659 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1660 , bool isCpp@var1661 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1662 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1663 , const Token * & vartok@var1664 , const Token * & typetok@var1665 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1666 , int args@var1667 , std :: vector < const Function * > & matches@var1668 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1669 , const Token * start@var1670 , const Token * end@var1671 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1672 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1673 ;
1239: int bits@var1674 ;
1240: int pointer@var1675 ;
1241: int constness@var1676 ;
1242: Reference reference@var1677 ; reference@var1677 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1678 ;
1245: const :: Type * smartPointerType@var1679 ;
1246: const Token * smartPointerTypeToken@var1680 ;
1247: const Library :: SmartPointer * smartPointer@var1681 ;
1248: const Library :: Container * container@var1682 ;
1249:
1250: const Token * containerTypeToken@var1683 ;
1251:
1252: std :: string originalTypeName@var1684 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1672 ( UNKNOWN_SIGN ) ,
1257: type@var1673 ( UNKNOWN_TYPE ) ,
1258: bits@var1674 ( 0 ) ,
1259: pointer@var1675 ( 0U ) ,
1260: constness@var1676 ( 0U ) ,
1261: typeScope@var1678 ( nullptr ) ,
1262: smartPointerType@var1679 ( nullptr ) ,
1263: smartPointerTypeToken@var1680 ( nullptr ) ,
1264: smartPointer@var1681 ( nullptr ) ,
1265: container@var1682 ( nullptr ) ,
1266: containerTypeToken@var1683 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1685 , enum Type t@var1686 , int p@var1687 )
1269: : sign@var1672 ( s@var1685 ) ,
1270: type@var1673 ( t@var1686 ) ,
1271: bits@var1674 ( 0 ) ,
1272: pointer@var1675 ( p@var1687 ) ,
1273: constness@var1676 ( 0U ) ,
1274: typeScope@var1678 ( nullptr ) ,
1275: smartPointerType@var1679 ( nullptr ) ,
1276: smartPointerTypeToken@var1680 ( nullptr ) ,
1277: smartPointer@var1681 ( nullptr ) ,
1278: container@var1682 ( nullptr ) ,
1279: containerTypeToken@var1683 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1688 , enum Type t@var1689 , int p@var1690 , int c@var1691 )
1282: : sign@var1672 ( s@var1688 ) ,
1283: type@var1673 ( t@var1689 ) ,
1284: bits@var1674 ( 0 ) ,
1285: pointer@var1675 ( p@var1690 ) ,
1286: constness@var1676 ( c@var1691 ) ,
1287: typeScope@var1678 ( nullptr ) ,
1288: smartPointerType@var1679 ( nullptr ) ,
1289: smartPointerTypeToken@var1680 ( nullptr ) ,
1290: smartPointer@var1681 ( nullptr ) ,
1291: container@var1682 ( nullptr ) ,
1292: containerTypeToken@var1683 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1692 , enum Type t@var1693 , int p@var1694 , int c@var1695 , const std :: string & otn@var1696 )
1295: : sign@var1672 ( s@var1692 ) ,
1296: type@var1673 ( t@var1693 ) ,
1297: bits@var1674 ( 0 ) ,
1298: pointer@var1675 ( p@var1694 ) ,
1299: constness@var1676 ( c@var1695 ) ,
1300: typeScope@var1678 ( nullptr ) ,
1301: smartPointerType@var1679 ( nullptr ) ,
1302: smartPointerTypeToken@var1680 ( nullptr ) ,
1303: smartPointer@var1681 ( nullptr ) ,
1304: container@var1682 ( nullptr ) ,
1305: containerTypeToken@var1683 ( nullptr ) ,
1306: originalTypeName@var1684 ( otn@var1696 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1697 , const Settings * settings@var1698 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1699 , bool longType@var1700 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1701 , const ValueType * func@var1702 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1703 , const Variable * callVar@var1704 , const Variable * funcVar@var1705 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746609 type@var1673 >=@expr1073746610 ValueType ::@expr1073746611 Type ::@expr1073746612 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746613 type@var1673 >=@expr1073746614 ValueType ::@expr4791 Type ::@expr1073746616 BOOL &&@expr1073746617 type@var1673 <=@expr1073746618 ValueType ::@expr4791 Type ::@expr1073746620 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746621 type@var1673 >=@expr1073746622 ValueType ::@expr4799 Type ::@expr1073746624 FLOAT &&@expr1073746625 type@var1673 <=@expr1073746626 ValueType ::@expr4799 Type ::@expr1073746628 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1706 , const Settings * settings@var1707 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1678 &&@expr1073746629 typeScope@var1678 .@expr1073746630 type@var1708 ==@expr1073746631 Scope ::@expr1073746632 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1709 , bool p@var1710 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1711 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1712 , const Settings * settings@var1713 , ErrorLogger * errorLogger@var1714 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1715 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1716 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1717 ;
1359:
1360:
1361: std :: list < Type > typeList@var1718 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1719 , const Token * typeTok@var1720 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1721 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1722 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1723 , const Scope * startScope@var1724 , bool lookOutside@var1725 = false ) const ;
1382: Type * findType ( const Token * startTok@var1726 , Scope * startScope@var1727 , bool lookOutside@var1728 = false ) const {
1383: return const_cast < Type *@expr4809 > (@expr1073746634 this@expr1073746635 .@expr1073746636 findType (@expr1073746637 startTok@var1726 , const_cast < const Scope *@expr4809 > (@expr1073746639 startScope@var1727 ) , lookOutside@var1728 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1729 , const Scope * startScope@var1730 ) const ;
1387: Scope * findScope ( const Token * tok@var1731 , Scope * startScope@var1732 ) const {
1388: return const_cast < Scope *@expr4816 > (@expr1073746641 this@expr1073746642 .@expr1073746643 findScope (@expr1073746644 tok@var1731 , const_cast < const Scope *@expr4816 > (@expr1073746646 startScope@var1732 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1733 ) const {
1392: return varid@var1733 <@expr1073746647 mVariableList@var1790 .@expr1073746648 size (@expr1073746649 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1734 ) const {
1396: return mVariableList@var1790 .@expr1073746650 at (@expr1073746651 varId@var1734 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1790 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1735 , const std :: string & type@var1736 , const std :: string & msg@var1737 ) const ;
1407:
1408: void printOut ( const char * title@var1738 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1739 , const char * indent@var1740 ) const ;
1410: void printXml ( std :: ostream & out@var1741 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1742 , Token * tokens@var1743 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1744 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1745 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1746 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1747 , const Token * * tok@var1748 , const Token * argStart@var1749 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1750 , const Token * tok@var1751 , const Token * argStart@var1752 , const Token * funcStart@var1753 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1754 , const Token * & tok@var1755 , const Token * argStart@var1756 , const Token * funcStart@var1757 ) ;
1469: void addNewFunction ( Scope * * scope@var1758 , const Token * * tok@var1759 ) ;
1470: bool isFunction ( const Token * tok@var1760 , const Scope * outerScope@var1761 , const Token * * funcStart@var1762 , const Token * * argStart@var1763 , const Token * * declEnd@var1764 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1765 , const Scope * startScope@var1766 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1767 , const Scope * scope@var1768 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1769 , const Scope * ns@var1770 , const std :: string & path@var1771 , int path_length@var1772 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1773 , const Token * typeTok@var1774 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1775 , const Token * vartok@var1776 , Token * membertok@var1777 , const Variable * membervar@var1778 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1779 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1780 ) const ;
1485:
1486: void setValueType ( Token * tok@var1781 , const ValueType & valuetype@var1782 ) ;
1487: void setValueType ( Token * tok@var1783 , const Variable & var@var1784 ) ;
1488: void setValueType ( Token * tok@var1785 , const Enumerator & enumerator@var1786 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1787 ;
1491: const Settings * mSettings@var1788 ;
1492: ErrorLogger * mErrorLogger@var1789 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1790 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1791 ;
1499:
1500: bool mIsCpp@var1792 ;
1501: ValueType :: Sign mDefaultSignedness@var1793 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1794 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1795 , const TFunc & visitor@var1796 )
52: {
53: if (@expr1073746652 !@expr1073746653 ast@var1795 ) {
54: return ; }
55:
56: std ::@expr1073746654 stack < T *@expr4831 , std ::@expr1073746656 vector < T *@expr4831 > > tokens@var1797 ;
57: T * tok@var1798 ; tok@var1798 =@expr1073746658 ast@var1795 ;
58: do {
59: ChildrenToVisit c@var1799 ; c@var1799 =@expr1073746659 visitor@var1796 (@expr1073746660 tok@var1798 ) ;
60:
61: if (@expr1073746661 c@var1799 ==@expr1073746662 ChildrenToVisit ::@expr1073746663 done ) {
62: break ; }
63: if (@expr1073746664 c@var1799 ==@expr1073746665 ChildrenToVisit ::@expr1073746666 op2 ||@expr1073746667 c@var1799 ==@expr4844 ChildrenToVisit ::@expr4845 op1_and_op2 ) {
64: T * t2@var1800 ; t2@var1800 =@expr1073746670 tok@var1798 .@expr1073746671 astOperand2 (@expr1073746672 ) ;
65: if (@expr1073746673 t2@var1800 ) {
66: tokens@var1797 .@expr4850 push (@expr1073746675 t2@var1800 ) ; }
67: }
68: if (@expr1073746676 c@var1799 ==@expr1073746677 ChildrenToVisit ::@expr1073746678 op1 ||@expr1073746679 c@var1799 ==@expr4844 ChildrenToVisit ::@expr4845 op1_and_op2 ) {
69: T * t1@var1801 ; t1@var1801 =@expr1073746682 tok@var1798 .@expr1073746683 astOperand1 (@expr1073746684 ) ;
70: if (@expr1073746685 t1@var1801 ) {
71: tokens@var1797 .@expr4850 push (@expr1073746687 t1@var1801 ) ; }
72: }
73:
74: if (@expr1073746688 tokens@var1797 .@expr1073746689 empty (@expr1073746690 ) ) {
75: break ; }
76:
77: tok@var1798 =@expr1073746691 tokens@var1797 .@expr1073746692 top (@expr1073746693 ) ;
78: tokens@var1797 .@expr1073746694 pop (@expr1073746695 ) ;
79: } while (@expr1073746696 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1802 , const std :: function < bool ( const Token * ) > & pred@var1803 ) ;
83: const Token * findExpression ( const int exprid@var1804 ,
84: const Token * start@var1805 ,
85: const Token * end@var1806 ,
86: const std :: function < bool ( const Token * ) > & pred@var1807 ) ;
87: const Token * findExpression ( const Token * start@var1808 , const int exprid@var1809 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1810 , const char * op@var1811 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1812 , const char * op@var1813 ) ;
91:
92: int astCount ( const Token * tok@var1814 , const char * op@var1815 , int depth@var1816 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1817 , const Token * tok@var1818 ) ;
95:
96: bool astHasVar ( const Token * tok@var1819 , int varid@var1820 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1821 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1822 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1823 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1824 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1825 , bool unknown@var1826 ) ;
107: bool astIsUnsigned ( const Token * tok@var1827 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1828 , bool unknown@var1829 ) ;
110:
111: bool astIsBool ( const Token * tok@var1830 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1831 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1832 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1833 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1834 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1835 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1836 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1837 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1838 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1839 , const std :: string & comp@var1840 , const std :: string & rhs@var1841 , const Token * * vartok@var1842 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1843 ) ;
140:
141: bool isTemporary ( bool cpp@var1844 , const Token * tok@var1845 , const Library * library@var1846 , bool unknown@var1847 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1848 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1849 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1850 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1851 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1852 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1853 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1854 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1855 ) ;
155: const Token * getParentLifetime ( bool cpp@var1856 , const Token * tok@var1857 , const Library * library@var1858 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1859 ) ;
158: bool astIsRHS ( const Token * tok@var1860 ) ;
159:
160: Token * getCondTok ( Token * tok@var1861 ) ;
161: const Token * getCondTok ( const Token * tok@var1862 ) ;
162:
163: Token * getInitTok ( Token * tok@var1863 ) ;
164: const Token * getInitTok ( const Token * tok@var1864 ) ;
165:
166: Token * getStepTok ( Token * tok@var1865 ) ;
167: const Token * getStepTok ( const Token * tok@var1866 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1867 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1868 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1869 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1870 ,
180: int * const varid@var1871 ,
181: bool * const knownInitValue@var1872 ,
182: long long * const initValue@var1873 ,
183: bool * const partialCond@var1874 ,
184: long long * const stepValue@var1875 ,
185: long long * const lastValue@var1876 ) ;
186:
187: bool precedes ( const Token * tok1@var1877 , const Token * tok2@var1878 ) ;
188: bool succeeds ( const Token * tok1@var1879 , const Token * tok2@var1880 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1881 , bool onVar@var1882 = true , int depth@var1883 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1884 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1885 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1886 ,
198: bool temporary@var1887 = true ,
199: bool inconclusive@var1888 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1889 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1890 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1891 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1892 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1893 , bool macro@var1894 , const Token * tok1@var1895 , const Token * tok2@var1896 , const Library & library@var1897 , bool pure@var1898 , bool followVar@var1899 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1900 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1901 , const Token * const tok2@var1902 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1903 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1904 , bool cpp@var1905 , const Token * const cond1@var1906 , const Token * const cond2@var1907 , const Library & library@var1908 , bool pure@var1909 , bool followVar@var1910 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1911 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1912 , const Token * const tok1@var1913 , const Token * const tok2@var1914 , const Library & library@var1915 , bool pure@var1916 , bool followVar@var1917 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1918 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1919 , const Library & library@var1920 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1921 , const Library & library@var1922 , bool pure@var1923 , bool cpp@var1924 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1925 , const Token * tok@var1926 , bool checkArrayAccess@var1927 = false , bool checkReference@var1928 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1929 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1930 , const Library * library@var1931 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1932 ,
238: const Library * library@var1933 = nullptr ,
239: const Token * * unknownFunc@var1934 = nullptr ,
240: bool functionScope@var1935 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1936 ,
244: const Variable * var@var1937 ,
245: Scope :: ScopeType type@var1938 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1939 , int & argn@var1940 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1941 , int & argn@var1942 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1943 , int argnr@var1944 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1945 , int indirect@var1946 , int varid@var1947 , const Settings * settings@var1948 , bool * inconclusive@var1949 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1950 , int indirect@var1951 , const Settings * settings@var1952 , bool * inconclusive@var1953 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1954 , const Token * end@var1955 , const int exprid@var1956 , bool globalvar@var1957 , const Settings * settings@var1958 , bool cpp@var1959 , int depth@var1960 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1961 , const Token * end@var1962 , int indirect@var1963 , const int exprid@var1964 , bool globalvar@var1965 , const Settings * settings@var1966 , bool cpp@var1967 , int depth@var1968 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1969 , int indirect@var1970 , const Settings * settings@var1971 , bool cpp@var1972 , int depth@var1973 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1974 , const Settings * settings@var1975 , bool cpp@var1976 , int depth@var1977 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1978 ,
283: const Token * end@var1979 ,
284: int indirect@var1980 ,
285: std :: vector < const Variable * > vars@var1981 ,
286: const Settings * settings@var1982 ,
287: bool cpp@var1983 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1984 , int indirect@var1985 , const Settings * settings@var1986 , bool cpp@var1987 ) ;
290: bool isThisChanged ( const Token * start@var1988 , const Token * end@var1989 , int indirect@var1990 , const Settings * settings@var1991 , bool cpp@var1992 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1993 , const Token * end@var1994 , int indirect@var1995 , const int exprid@var1996 , bool globalvar@var1997 , const Settings * settings@var1998 , bool cpp@var1999 , int depth@var2000 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var2001 , const Token * end@var2002 , int indirect@var2003 , const int exprid@var2004 , bool globalvar@var2005 , const Settings * settings@var2006 , bool cpp@var2007 , int depth@var2008 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var2009 ,
296: const Token * start@var2010 ,
297: const Token * end@var2011 ,
298: const Settings * settings@var2012 ,
299: bool cpp@var2013 ,
300: int depth@var2014 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var2015 ,
303: const Token * tok@var2016 ,
304: int indirect@var2017 ,
305: bool globalvar@var2018 ,
306: const Settings * settings@var2019 ,
307: bool cpp@var2020 ,
308: int depth@var2021 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var2022 , int varid@var2023 , bool * inconclusive@var2024 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var2025 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var2026 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var2027 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var2028 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var2029 ) ;
330:
331: int getArgumentPos ( const Variable * var@var2030 , const Function * f@var2031 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var2032 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var2033 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var2034 ) ;
346: Token * findLambdaEndToken ( Token * first@var2035 ) ;
347:
348: bool isLikelyStream ( bool cpp@var2036 , const Token * stream@var2037 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var2038 , const Token * op@var2039 ) ;
356:
357: bool isCPPCast ( const Token * tok@var2040 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var2041 , const char * skipMatch@var2042 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var2043 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var2044 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var2045 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var2046 , const Library & library@var2047 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var2048 ) ;
371:
372: bool isNullOperand ( const Token * expr@var2049 ) ;
373:
374: bool isGlobalData ( const Token * expr@var2050 , bool cpp@var2051 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var2052 , const Library & library@var2053 ) : mCpp@var2086 ( cpp@var2052 ) , mLibrary@var2087 ( library@var2053 ) , mWhat@var2088 ( What :: Reassign ) , mValueFlowKnown@var2090 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var2054 , const Token * lhs@var2055 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var2056 , const Token * startToken@var2057 , const Token * endToken@var2058 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var2059 , const Token * startToken@var2060 , const Token * endToken@var2061 ) ;
404:
405: struct KnownAndToken {
406: bool known@var2062 ;
407: const Token * token@var2063 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var2064 , const Token * startToken@var2065 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var2066 , bool * localOut@var2067 = nullptr , bool * unknownVarIdOut@var2068 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var2069 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var2070 ;
420: explicit Result ( Type type@var2071 ) : type@var2070 ( type@var2071 ) , token@var2074 ( nullptr ) { }
421: Result ( Type type@var2072 , const Token * token@var2073 ) : type@var2070 ( type@var2072 ) , token@var2074 ( token@var2073 ) { }
422: const Token * token@var2074 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var2075 , const Token * startToken@var2076 , const Token * endToken@var2077 ) ;
426: struct Result checkRecursive ( const Token * expr@var2078 , const Token * startToken@var2079 , const Token * endToken@var2080 , const std :: set < int > & exprVarIds@var2081 , bool local@var2082 , bool inInnerClass@var2083 , int depth@var2084 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var2085 ) const ;
430:
431: const bool mCpp@var2086 ;
432: const Library & mLibrary@var2087 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var2088 ;
434: std :: vector < KnownAndToken > mValueFlow@var2089 ;
435: bool mValueFlowKnown@var2090 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var2091 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2092 ) {
44: if (@expr1073746697 bit@var2092 >=@expr1073746698 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746699 (@expr1073746700 1LL <<@expr1073746701 (@expr1073746702 bit@var2092 -@expr1073746703 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var2093 ) {
50: if (@expr1073746704 bit@var2093 >=@expr1073746705 64 ) {
51: return (@expr4882 ~@expr1073746707 0ULL ) >>@expr1073746708 1 ; }
52: return (@expr4882 1LL <<@expr1073746710 (@expr4882 bit@var2093 -@expr1073746712 1 ) ) -@expr1073746713 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var2094 ) const {
59: return value@var2094 >=@expr1073746714 min_value (@expr1073746715 int_bit@var2104 ) &&@expr1073746716 value@var2094 <=@expr1073746717 max_value (@expr1073746718 int_bit@var2104 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var2095 ) const {
63: unsigned long long intMax@var2096 ; intMax@var2096 =@expr1073746719 max_value (@expr1073746720 int_bit@var2104 ) ;
64: return value@var2095 <=@expr1073746721 intMax@var2096 ;
65: }
66:
67: bool isLongValue ( long long value@var2097 ) const {
68: return value@var2097 >=@expr1073746722 min_value (@expr1073746723 long_bit@var2105 ) &&@expr1073746724 value@var2097 <=@expr1073746725 max_value (@expr1073746726 long_bit@var2105 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var2098 ) const {
72: unsigned long long longMax@var2099 ; longMax@var2099 =@expr1073746727 max_value (@expr1073746728 long_bit@var2105 ) ;
73: return value@var2098 <=@expr1073746729 longMax@var2099 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var2100 ) const {
77: unsigned long long longLongMax@var2101 ; longLongMax@var2101 =@expr1073746730 max_value (@expr1073746731 long_long_bit@var2106 ) ;
78: return value@var2100 <=@expr1073746732 longLongMax@var2101 ;
79: }
80:
81: int char_bit@var2102 ;
82: int short_bit@var2103 ;
83: int int_bit@var2104 ;
84: int long_bit@var2105 ;
85: int long_long_bit@var2106 ;
86:
87:
88: int sizeof_bool@var2107 ;
89: int sizeof_short@var2108 ;
90: int sizeof_int@var2109 ;
91: int sizeof_long@var2110 ;
92: int sizeof_long_long@var2111 ;
93: int sizeof_float@var2112 ;
94: int sizeof_double@var2113 ;
95: int sizeof_long_double@var2114 ;
96: int sizeof_wchar_t@var2115 ;
97: int sizeof_size_t@var2116 ;
98: int sizeof_pointer@var2117 ;
99:
100: char defaultSign@var2118 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var2119 ;
115:
116:
117: bool platform ( PlatformType type@var2120 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var2121 [ ] , const std :: string & filename@var2122 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var2123 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var2119 ==@expr1073746733 Win32A ||@expr1073746734
136: platformType@var2119 ==@expr1073746735 Win32W ||@expr1073746736
137: platformType@var2119 ==@expr1073746737 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746738 platformType@var2119 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var2124 ) {
145: switch (@expr1073746739 pt@var2124 ) {
146: case Unspecified :@expr4916 ;
147: return "Unspecified" ;
148: case Native :@expr4916 ;
149: return "Native" ;
150: case Win32A :@expr4916 ;
151: return "win32A" ;
152: case Win32W :@expr4916 ;
153: return "win32W" ;
154: case Win64 :@expr4916 ;
155: return "win64" ;
156: case Unix32 :@expr4916 ;
157: return "unix32" ;
158: case Unix64 :@expr4916 ;
159: return "unix64" ;
160: case PlatformFile :@expr4916 ;
161: return "platformFile" ;
162: default :@expr4916 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746749 char_bit@var2102 +@expr1073746750 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746751 char_bit@var2102 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746752 char_bit@var2102 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var2125 , const std :: string & rhs@var2126 ) const {
41: return caseInsensitiveStringCompare (@expr1073746753 lhs@var2125 , rhs@var2126 ) <@expr1073746754 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var2134 ( cppcheck :: Platform :: Unspecified ) , msc@var2135 ( false ) , useMfc@var2136 ( false ) { }
67: std :: string cfg@var2127 ;
68: std :: string filename@var2128 ;
69: std :: string defines@var2129 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var2129 +@expr1073746755 (@expr1073746756 msc@var2135 ?@expr1073746757 ";_MSC_VER=1900" :@expr1073746758 "" ) +@expr1073746759 (@expr1073746760 useMfc@var2136 ?@expr1073746761 ";__AFXWIN_H__=1" :@expr1073746762 "" ) ;
72: }
73: std :: set < std :: string > undefs@var2130 ;
74: std :: list < std :: string > includePaths@var2131 ;
75: std :: list < std :: string > systemIncludePaths@var2132 ;
76: std :: string standard@var2133 ;
77: cppcheck :: Platform :: PlatformType platformType@var2134 ;
78: bool msc@var2135 ;
79: bool useMfc@var2136 ;
80:
81: void parseCommand ( std :: string command@var2137 ) ;
82: void setDefines ( std :: string defs@var2138 ) ;
83: void setIncludePaths ( const std :: string & basepath@var2139 , const std :: list < std :: string > & in@var2140 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2141 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var2142 ;
86: Type projectType@var2143 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var2144 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous5 {
96: std :: string analyzeAllVsConfigs@var2145 ;
97: std :: vector < std :: string > pathNames@var2146 ;
98: std :: list < std :: string > libraries@var2147 ;
99: std :: list < std :: string > excludedPaths@var2148 ;
100: std :: list < std :: string > checkVsConfigs@var2149 ;
101: std :: string projectFile@var2150 ;
102: std :: string platform@var2151 ;
103: } ; struct Anonymous5 guiProject@var2152 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var2153 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var2154 ) ;
107:
108: Type import ( const std :: string & filename@var2155 , Settings * settings@var2156 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var2157 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var2158 , Settings * settings@var2159 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var2160 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var2161 , const std :: string & path@var2162 , const std :: vector < std :: string > & fileFilters@var2163 ) ;
115: bool importVcxproj ( const std :: string & filename@var2164 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var2165 , const std :: string & additionalIncludeDirectories@var2166 , const std :: vector < std :: string > & fileFilters@var2167 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var2168 ) ;
117:
118: static void printError ( const std :: string & message@var2169 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var2170 ) ;
121:
122: std :: string mPath@var2171 ;
123: std :: set < std :: string > mAllVSConfigs@var2172 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var2173 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var2174 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var2175 [ 2 ] = "1" ;
131: const char BuildDirElementName@var2176 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var2177 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var2178 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var2179 [ 7 ] = "parser" ;
135: const char BugHunting@var2180 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var2181 [ 11 ] = "includedir" ;
137: const char DirElementName@var2182 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var2183 [ 5 ] = "name" ;
139: const char DefinesElementName@var2184 [ 8 ] = "defines" ;
140: const char DefineName@var2185 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var2186 [ 5 ] = "name" ;
142: const char UndefinesElementName@var2187 [ 10 ] = "undefines" ;
143: const char UndefineName@var2188 [ 9 ] = "undefine" ;
144: const char PathsElementName@var2189 [ 6 ] = "paths" ;
145: const char PathName@var2190 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var2191 [ 5 ] = "name" ;
147: const char RootPathName@var2192 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var2193 [ 5 ] = "name" ;
149: const char IgnoreElementName@var2194 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var2195 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var2196 [ 5 ] = "name" ;
152: const char ExcludeElementName@var2197 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var2198 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var2199 [ 5 ] = "name" ;
155: const char FunctionContracts@var2200 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var2201 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var2202 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var2203 [ 8 ] = "library" ;
159: const char PlatformElementName@var2204 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var2205 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var2206 [ 12 ] = "suppression" ;
162: const char AddonElementName@var2207 [ 6 ] = "addon" ;
163: const char AddonsElementName@var2208 [ 7 ] = "addons" ;
164: const char ToolElementName@var2209 [ 5 ] = "tool" ;
165: const char ToolsElementName@var2210 [ 6 ] = "tools" ;
166: const char TagsElementName@var2211 [ 5 ] = "tags" ;
167: const char TagElementName@var2212 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var2213 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var2214 [ 4 ] = "tag" ;
170: const char WarningElementName@var2215 [ 8 ] = "warning" ;
171: const char HashAttributeName@var2216 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var2217 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var2218 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var2219 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var2220 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var2221 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var2222 [ 11 ] = "clang-tidy" ;
178: const char Name@var2223 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var2224 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var2225 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2226 , std :: clock_t clocks@var2227 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2228 ;
45: long mNumberOfResults@var2229 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2228 ( 0 )
49: , mNumberOfResults@var2229 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2230 =@expr1073746764 (@expr1073746765 double ) (@expr1073746766 (@expr1073746767 unsigned long ) mClocks@var2228 ) /@expr1073746768 (@expr1073746769 double ) CLOCKS_PER_SEC@expr1073746763 ;
53: return ret@var2230 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2231 ) const ;
62: void addResults ( const std :: string & str@var2232 , std :: clock_t clocks@var2233 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2234 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2235 , SHOWTIME_MODES showtimeMode@var2236 , TimerResultsIntf * timerResults@var2237 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2238 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2239 ;
79: TimerResultsIntf * mTimerResults@var2240 ;
80: std :: clock_t mStart@var2241 ;
81: const SHOWTIME_MODES mShowTimeMode@var2242 ;
82: bool mStopped@var2243 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2244 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2245 ;
103:
104:
105: std :: string addonPython@var2246 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2247 ;
109:
110:
111: std :: string buildDir@var2248 ;
112:
113:
114: bool checkAllConfigurations@var2249 ;
115:
116:
117: bool checkConfiguration@var2250 ;
118:
|
121:
122: bool checkHeaders@var2251 ;
123:
124:
125: bool checkLibrary@var2252 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2253 ;
129:
130:
131: bool checkUnusedTemplates@var2254 ;
132:
133:
134: bool clang@var2255 ;
135:
136:
137: std :: string clangExecutable@var2256 ;
138:
139:
140: bool clangTidy@var2257 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2258 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2259 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2260 ;
150:
151:
152: bool daca@var2261 ;
153:
154:
155: bool debugnormal@var2262 ;
156:
157:
158: bool debugSimplified@var2263 ;
159:
160:
161: bool debugtemplate@var2264 ;
162:
163:
164: bool debugwarnings@var2265 ;
165:
166:
167: bool dump@var2266 ;
168: std :: string dumpFile@var2267 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2268 ;
176:
177:
178: bool exceptionHandling@var2269 ;
179:
180:
181: std :: string exename@var2270 ;
182:
183:
184:
185: int exitCode@var2271 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2272 ;
189:
190:
191: bool force@var2273 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2274 ;
196:
197:
198: bool inlineSuppressions@var2275 ;
199:
200:
201:
202: unsigned int jobs@var2276 ;
203:
|
206:
207: bool jointSuppressionReport@var2277 ;
208:
209:
210: std :: list < std :: string > libraries@var2278 ;
211:
212:
213: Library library@var2279 ;
214:
215:
216:
217: int loadAverage@var2280 ;
218:
|
221:
222: int maxConfigs@var2281 ;
223:
224:
225: int maxCtuDepth@var2282 ;
226:
227:
228: int maxTemplateRecursion@var2283 ;
229:
230:
231: Suppressions nofail@var2284 ;
232:
233:
234: Suppressions nomsg@var2285 ;
235:
236:
237: std :: string outputFile@var2286 ;
238:
239:
240: std :: string plistOutput@var2287 ;
241:
242:
243: bool preprocessOnly@var2288 ;
244:
245: ImportProject project@var2289 ;
246:
247:
248: bool quiet@var2290 ;
249:
250:
251: bool relativePaths@var2291 ;
252:
253:
254: bool reportProgress@var2292 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2293 ( "simple" )
261: , id@var2295 ( "rule" )
262: , severity@var2297 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2293 ;
266: std :: string pattern@var2294 ;
267: std :: string id@var2295 ;
268: std :: string summary@var2296 ;
269: Severity :: SeverityType severity@var2297 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2298 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2304 ( false ) , externalFunctions@var2305 ( false ) , internalFunctions@var2306 ( false ) , externalVariables@var2307 ( false ) { }
281:
282: static const char XmlRootName@var2299 [ ] ;
283: static const char XmlClasses@var2300 [ ] ;
284: static const char XmlExternalFunctions@var2301 [ ] ;
285: static const char XmlInternalFunctions@var2302 [ ] ;
286: static const char XmlExternalVariables@var2303 [ ] ;
287:
288: void clear ( ) {
289: classes@var2304 =@expr1073746770 externalFunctions@var2305 =@expr1073746771 internalFunctions@var2306 =@expr1073746772 externalVariables@var2307 =@expr1073746773 false ;
290: }
291:
|
297:
298: bool classes@var2304 ;
299:
|
304:
305: bool externalFunctions@var2305 ;
306:
|
310:
311: bool internalFunctions@var2306 ;
312:
|
316:
317: bool externalVariables@var2307 ;
318: } ;
319:
320: SafeChecks safeChecks@var2308 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2309 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2310 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2311 ;
325:
326:
327: SHOWTIME_MODES showtime@var2312 ;
328:
329:
330: Standards standards@var2313 ;
331:
332:
333:
334: std :: string templateFormat@var2314 ;
335:
336:
337:
338: std :: string templateLocation@var2315 ;
339:
340:
341: std :: string userDefines@var2316 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2317 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2318 ;
348:
349:
350: bool verbose@var2319 ;
351:
352:
353: bool xml@var2320 ;
354:
355:
356: int xml_version@var2321 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2322 ) const {
363: for (@expr1073746774 const std ::@expr1073746775 string &@expr1073746776 configExcludePath@var2323 :@expr1073746777 configExcludePaths@var2258 ) {
364: if (@expr1073746778 file@var2322 .@expr1073746779 length (@expr1073746780 ) >=@expr1073746781 configExcludePath@var2323 .@expr4958 length (@expr4959 ) &&@expr1073746784 file@var2322 .@expr1073746785 compare (@expr1073746786 0 , configExcludePath@var2323 .@expr4958 length (@expr4959 ) , configExcludePath@var2323 ) ==@expr1073746789 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2324 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2325 , bool inconclusiveCheck@var2326 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746790 find (@expr1073746791 libraries@var2278 .@expr1073746792 begin (@expr1073746793 ) , libraries@var2278 .@expr4970 end (@expr4971 ) , "posix" ) !=@expr1073746796 libraries@var2278 .@expr4970 end (@expr4971 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2327 = true ) {
392: Settings ::@expr1073746799 mTerminated@var2244 =@expr1073746800 t@var2327 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746801 mTerminated@var2244 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2328 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2329 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2330 ) {
47: mSettings@var2365 =@expr1073746802 settings@var2330 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2365 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2367 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2368 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2331 ) ;
72:
73: void addtoken ( const std :: string & str@var2332 , const int lineno@var2333 , const int column@var2334 , const int fileno@var2335 , bool split@var2336 = false ) ;
74: void addtoken ( const std :: string & str@var2337 , const Token * locationTok@var2338 ) ;
75:
76: void addtoken ( const Token * tok@var2339 , const int lineno@var2340 , const int column@var2341 , const int fileno@var2342 ) ;
77: void addtoken ( const Token * tok@var2343 , const Token * locationTok@var2344 ) ;
78: void addtoken ( const Token * tok@var2345 ) ;
79:
80: static void insertTokens ( Token * dest@var2346 , const Token * src@var2347 , int n@var2348 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2349 , const Token * first@var2350 , const Token * last@var2351 , bool one_line@var2352 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2353 , const std :: string & file0@var2354 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2355 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2356 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2362 .@expr1073746803 front@var2369 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2362 .@expr1073746804 front@var2369 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2362 .@expr1073746805 back@var2370 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2362 .@expr1073746806 back@var2370 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2363 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2357 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2358 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2359 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2360 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2361 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2362 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2363 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2364 ;
212:
213:
214: const Settings * mSettings@var2365 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2366 ;
217:
218:
219: bool mIsC@var2367 ;
220: bool mIsCpp@var2368 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2371 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2372 ;
67: mutable int mVarId@var2373 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2374 ) ;
73: bool hasVariable ( const std :: string & varname@var2375 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2376 ) const {
75: return mVariableId@var2371 .@expr1073746807 find (@expr1073746808 varname@var2376 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2371 .@expr1073746809 end (@expr1073746810 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2371 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746811 mVarId@var2373 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2377 , ErrorLogger * errorLogger@var2378 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2379 ) {
95: mTimerResults@var2499 =@expr1073746812 tr@var2379 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2477 .@expr1073746813 isC (@expr1073746814 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2477 .@expr1073746815 isCPP (@expr1073746816 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2380 , bool * unknown@var2381 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2382 , const std :: string & FileName@var2383 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2384 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2385 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2386 ,
142: const char FileName@var2387 [ ] ,
143: const std :: string & configuration@var2388 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2389 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2390 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2391 , const Token * end@var2392 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2393 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2394 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2395 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2396 , const Token * const tokEnd@var2397 , const bool only_k_r_fpar@var2398 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2399 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2400 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2401 , bool commandWithCondition@var2402 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2403 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2404 , Token * * _tok2@var2405 , Token * * _tok3@var2406 , std :: string & value@var2407 , int & valueVarId@var2408 , bool & valueIsPointer@var2409 , bool floatvar@var2410 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2411 , Token * tok3@var2412 , int varid@var2413 , const std :: string & structname@var2414 , std :: string & value@var2415 , int valueVarId@var2416 , bool valueIsPointer@var2417 , const Token * const valueToken@var2418 , int indentlevel@var2419 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2420 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2421 , const std :: string & endsWith@var2422 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2423 , const std :: string & endsWith@var2424 , bool cpp@var2425 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2426 ) {
585: mPreprocessor@var2500 =@expr1073746817 preprocessor@var2426 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2500 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2427 , const Token * end@var2428 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2429 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2430 , const std :: string & code@var2431 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2432 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2433 , const std :: string & what@var2434 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2435 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2436 , const std :: string & msg@var2437 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2438 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2439 , const std :: string & macroName@var2440 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2441 , const Token * end@var2442 , bool allowSemicolon@var2443 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2444 , const Severity :: SeverityType severity@var2445 , const std :: string & id@var2446 , const std :: string & msg@var2447 , bool inconclusive@var2448 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2449 , Severity :: SeverityType severity@var2450 , const std :: string & id@var2451 , const std :: string & msg@var2452 , bool inconclusive@var2453 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2454 , const Token * name@var2455 , const Token * typeDef@var2456 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2457 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2458 ,
821: const VariableMap & variableMap@var2459 ,
822: const int scopeStartVarId@var2460 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2461 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2462 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2463 ,
827: int * varId@var2464 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2465 ,
830: Token * const startToken@var2466 ,
831: const Token * const endToken@var2467 ,
832: const std :: map < std :: string , int > & varlist@var2468 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2469 ,
834: int * varId_@var2470 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2471 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2472 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2498 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2473 ) {
861: mSettings@var2484 =@expr1073746818 settings@var2473 ;
862: list@var2477 .@expr1073746819 setSettings (@expr1073746820 settings@var2473 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2486 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2474 ) const ;
877:
878: void dump ( std :: ostream & out@var2475 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2476 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2496 ;
888: }
889:
|
892:
893: TokenList list@var2477 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2477 .@expr1073746821 front (@expr1073746822 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2478 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2479 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2480 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2481 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2484 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2482 , bool inOperator@var2483 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746823 mVarId@var2496 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2484 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2485 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2486 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2487 ;
973:
974:
975:
976: std :: string mConfiguration@var2488 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2489 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2490 ;
983: std :: string filename@var2491 ;
984: int lineNumber@var2492 ;
985: int column@var2493 ;
986: bool used@var2494 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2495 ;
989:
990:
991: int mVarId@var2496 ;
992:
993:
994: int mUnnamedCount@var2497 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2498 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2499 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2500 ;
1013: } ;

##file cppcheck-2.8/lib/checknullpointer.h

1:
|
32:
33: class ErrorLogger ;
34: class Library ;
35: class Settings ;
36: class Token ;
37: class Tokenizer ;
38:
39: namespace tinyxml2 {
40: class XMLElement ;
41: }
42:
|
48:
49: class CheckNullPointer : public Check {
50: public:
51:
52: CheckNullPointer ( ) : Check ( myName ( ) ) { }
53:
54:
55: CheckNullPointer ( const Tokenizer * tokenizer@var2501 , const Settings * settings@var2502 , ErrorLogger * errorLogger@var2503 )
56: : Check ( myName ( ) , tokenizer@var2501 , settings@var2502 , errorLogger@var2503 ) { }
57:
58:
59: void runChecks ( const Tokenizer * tokenizer@var2504 , const Settings * settings@var2505 , ErrorLogger * errorLogger@var2506 ) override {
60: CheckNullPointer checkNullPointer@var2507 (@expr1073746824 tokenizer@var2504 , settings@var2505 , errorLogger@var2506 ) ;
61: checkNullPointer@var2507 .@expr1073746825 nullPointer (@expr1073746826 ) ;
62: checkNullPointer@var2507 .@expr1073746827 arithmetic (@expr1073746828 ) ;
63: checkNullPointer@var2507 .@expr1073746829 nullConstantDereference (@expr1073746830 ) ;
64: }
65:
|
71:
72: static void parseFunctionCall ( const Token & tok@var2508 ,
73: std :: list < const Token * > & var@var2509 ,
74: const Library * library@var2510 ) ;
75:
|
84:
85: bool isPointerDeRef ( const Token * tok@var2511 , bool & unknown@var2512 ) const ;
86:
87: static bool isPointerDeRef ( const Token * tok@var2513 , bool & unknown@var2514 , const Settings * settings@var2515 ) ;
88:
89:
90: void nullPointer ( ) ;
91:
92:
93: void nullConstantDereference ( ) ;
94:
95: void nullPointerError ( const Token * tok@var2516 ) {
96: ValueFlow ::@expr1073746831 Value v@var2517 (@expr1073746832 0 ) ;
97: v@var2517 .@expr1073746833 setKnown (@expr1073746834 ) ;
98: nullPointerError (@expr1073746835 tok@var2516 , "" , &@expr1073746836 v@var2517 , false ) ;
99: }
100: void nullPointerError ( const Token * tok@var2518 , const std :: string & varname@var2519 , const ValueFlow :: Value * value@var2520 , bool inconclusive@var2521 ) ;
101:
102:
103: class MyFileInfo : public Check :: FileInfo {
104: public:
105:
106: std :: list < CTU :: FileInfo :: UnsafeUsage > unsafeUsage@var2522 ;
107:
108:
109: std :: string toString ( ) const override ;
110: } ;
111:
112:
113: Check :: FileInfo * getFileInfo ( const Tokenizer * tokenizer@var2523 , const Settings * settings@var2524 ) const override ;
114:
115: Check :: FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2525 ) const override ;
116:
117:
118: bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var2526 , const std :: list < Check :: FileInfo * > & fileInfo@var2527 , const Settings & settings@var2528 , ErrorLogger & errorLogger@var2529 ) override ;
119:
120: private:
121:
122: void getErrorMessages ( ErrorLogger * errorLogger@var2530 , const Settings * settings@var2531 ) const override {
123: CheckNullPointer c@var2532 (@expr1073746837 nullptr , settings@var2531 , errorLogger@var2530 ) ;
124: c@var2532 .@expr1073746838 nullPointerError (@expr1073746839 nullptr , "pointer" , nullptr , false ) ;
125: c@var2532 .@expr1073746840 pointerArithmeticError (@expr1073746841 nullptr , nullptr , false ) ;
126: c@var2532 .@expr1073746842 redundantConditionWarning (@expr1073746843 nullptr , nullptr , nullptr , false ) ;
127: }
128:
129:
130: static std :: string myName ( ) {
131: return "Null pointer" ;
132: }
133:
134:
135: std :: string classInfo ( ) const override {
136: return "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
137:
138: ;
139: }
140:
|
144:
145: void nullPointerByDeRefAndChec ( ) ;
146:
147:
148: void arithmetic ( ) ;
149: void pointerArithmeticError ( const Token * tok@var2533 , const ValueFlow :: Value * value@var2534 , bool inconclusive@var2535 ) ;
150: void redundantConditionWarning ( const Token * tok@var2536 , const ValueFlow :: Value * value@var2537 , const Token * condition@var2538 , bool inconclusive@var2539 ) ;
151: } ;

##file cppcheck-2.8/lib/checkuninitvar.cpp

1:
|
45:
46: namespace tinyxml2 {
47: class XMLElement ;
48: }
49:
|
52:
53: namespace {
54: CheckUninitVar instance@var2540 ;
55: }
56:
|
59:
60: static const Token * getAstParentSkipPossibleCastAndAddressOf ( const Token * vartok@var2541 , bool * unknown@var2542 )
61: {
62: if (@expr5020 unknown@var2542 ) {
63: *@expr5021 unknown@var2542 =@expr1073746846 false ; }
64: if (@expr1073746847 !@expr1073746848 vartok@var2541 ) {
65: return nullptr ; }
66: const Token * parent@var2543 ; parent@var2543 =@expr1073746849 vartok@var2541 .@expr1073746850 astParent (@expr1073746851 ) ;
67: while (@expr1073746852 Token ::@expr5029 Match (@expr1073746854 parent@var2543 , ".|::" ) ) {
68: parent@var2543 =@expr1073746855 parent@var2543 .@expr5032 astParent (@expr5033 ) ; }
69: if (@expr1073746858 !@expr1073746859 parent@var2543 ) {
70: return nullptr ; }
71: if (@expr1073746860 parent@var2543 .@expr1073746861 isUnaryOp (@expr1073746862 "&" ) ) {
72: parent@var2543 =@expr1073746863 parent@var2543 .@expr5032 astParent (@expr5033 ) ; }
73: else { if (@expr1073746866 parent@var2543 .@expr1073746867 str (@expr1073746868 ) ==@expr1073746869 "&" &&@expr1073746870 vartok@var2541 ==@expr1073746871 parent@var2543 .@expr1073746872 astOperand2 (@expr1073746873 ) &&@expr1073746874 Token ::@expr5029 Match (@expr1073746876 parent@var2543 .@expr1073746877 astOperand1 (@expr1073746878 ) .@expr1073746879 previous (@expr1073746880 ) , "( %type% )" ) ) {
74: parent@var2543 =@expr1073746881 parent@var2543 .@expr5032 astParent (@expr5033 ) ;
75: if (@expr5020 unknown@var2542 ) {
76: *@expr5021 unknown@var2542 =@expr1073746886 true ; }
77: } }
78: while (@expr1073746887 parent@var2543 &&@expr1073746888 parent@var2543 .@expr1073746889 isCast (@expr1073746890 ) ) {
79: parent@var2543 =@expr1073746891 parent@var2543 .@expr5032 astParent (@expr5033 ) ; }
80: return parent@var2543 ;
81: }
82:
83: bool CheckUninitVar :: diag ( const Token * tok@var2544 )
84: {
85: if (@expr1073746894 !@expr1073746895 tok@var2544 ) {
86: return true ; }
87: while (@expr1073746896 Token ::@expr1073746897 Match (@expr1073746898 tok@var2544 .@expr5075 astParent (@expr5076 ) , "*|&|." ) ) {
88: tok@var2544 =@expr1073746901 tok@var2544 .@expr5075 astParent (@expr5076 ) ; }
89: return !@expr1073746904 mUninitDiags@var633 .@expr1073746905 insert (@expr1073746906 tok@var2544 ) .@expr1073746907 second@var2545 ;
90: }
91:
92: void CheckUninitVar :: check ( )
93: {
94: const SymbolDatabase * symbolDatabase@var2546 ; symbolDatabase@var2546 =@expr1073746908 mTokenizer@var28 .@expr1073746909 getSymbolDatabase (@expr1073746910 ) ;
95:
96: std ::@expr1073746911 set < std ::@expr1073746912 string > arrayTypeDefs@var2547 ;
97: for (@expr1073746913 const Token *@expr1073746914 tok@var2548 =@expr1073746915 mTokenizer@var28 .@expr1073746916 tokens (@expr1073746917 ) ; tok@var2548 ; tok@var2548 =@expr1073746918 tok@var2548 .@expr1073746919 next (@expr1073746920 ) ) {
98: if (@expr1073746921 Token ::@expr5098 Match (@expr1073746923 tok@var2548 , "%name% [" ) &&@expr1073746924 tok@var2548 .@expr5101 variable (@expr5102 ) &&@expr1073746927 Token ::@expr5098 Match (@expr1073746929 tok@var2548 .@expr5101 variable (@expr5102 ) .@expr5108 typeStartToken (@expr5109 ) , "%type% %var% ;" ) ) {
99: arrayTypeDefs@var2547 .@expr1073746934 insert (@expr1073746935 tok@var2548 .@expr5101 variable (@expr5102 ) .@expr5108 typeStartToken (@expr5109 ) .@expr1073746940 str (@expr1073746941 ) ) ; }
100: }
101:
102:
103: for (@expr1073746942 const Scope &@expr1073746943 scope@var2549 :@expr1073746944 symbolDatabase@var2546 .@expr1073746945 scopeList@var2550 ) {
104: if (@expr1073746946 scope@var2549 .@expr1073746947 isExecutable (@expr1073746948 ) ) {
105: checkScope (@expr1073746949 &@expr1073746950 scope@var2549 , arrayTypeDefs@var2547 ) ;
106: }
107: }
108: }
109:
110: void CheckUninitVar :: checkScope ( const Scope * scope@var2551 , const std :: set < std :: string > & arrayTypeDefs@var2552 )
111: {
112: for (@expr1073746951 const Variable &@expr5128 var@var2553 :@expr1073746953 scope@var2551 .@expr1073746954 varlist@var2554 ) {
113: if (@expr1073746955 (@expr1073746956 mTokenizer@var28 .@expr1073746957 isCPP (@expr1073746958 ) &&@expr1073746959 var@var2553 .@expr5136 type (@expr5137 ) &&@expr1073746962 !@expr1073746963 var@var2553 .@expr5140 isPointer (@expr5141 ) &&@expr1073746966 var@var2553 .@expr5136 type (@expr5137 ) .@expr1073746969 needInitialization@var2937 !=@expr1073746970 Type ::@expr1073746971 NeedInitialization ::@expr1073746972 True ) ||@expr1073746973
114: var@var2553 .@expr1073746974 isStatic (@expr1073746975 ) ||@expr1073746976 var@var2553 .@expr1073746977 isExtern (@expr1073746978 ) ||@expr1073746979 var@var2553 .@expr1073746980 isReference (@expr1073746981 ) ) {
115: continue ; }
116:
117:
118: if (@expr1073746982 var@var2553 .@expr1073746983 isThrow (@expr1073746984 ) ) {
119: continue ; }
120:
121: if (@expr1073746985 Token ::@expr5162 Match (@expr1073746987 var@var2553 .@expr5164 nameToken (@expr5165 ) .@expr5166 next (@expr5167 ) , "[({:]" ) ) {
122: continue ; }
123:
124: if (@expr1073746992 Token ::@expr5162 Match (@expr1073746994 var@var2553 .@expr5164 nameToken (@expr5165 ) , "%name% =" ) ) {
125: checkRhs (@expr1073746997 var@var2553 .@expr5164 nameToken (@expr5165 ) , var@var2553 , NO_ALLOC , 0U , emptyString@var1 ) ;
126: continue ;
127: }
128: if (@expr1073747000 Token ::@expr5162 Match (@expr1073747002 var@var2553 .@expr5164 nameToken (@expr5165 ) , "%name% ) (" ) &&@expr1073747005 Token ::@expr5182 simpleMatch (@expr1073747007 var@var2553 .@expr5164 nameToken (@expr5165 ) .@expr5186 linkAt (@expr5187 2 ) , ") =" ) ) {
129: checkRhs (@expr1073747012 var@var2553 .@expr5164 nameToken (@expr5165 ) .@expr5186 linkAt (@expr5187 2 ) .@expr1073747017 next (@expr1073747018 ) , var@var2553 , NO_ALLOC , 0U , emptyString@var1 ) ;
130: continue ;
131: }
132:
133: if (@expr1073747019 var@var2553 .@expr5196 isArray (@expr5197 ) ||@expr1073747022 var@var2553 .@expr5199 isPointerToArray (@expr5200 ) ) {
134: const Token * tok@var2555 ; tok@var2555 =@expr1073747025 var@var2553 .@expr5164 nameToken (@expr5165 ) .@expr5166 next (@expr5167 ) ;
135: if (@expr1073747030 var@var2553 .@expr5199 isPointerToArray (@expr5200 ) ) {
136: tok@var2555 =@expr1073747033 tok@var2555 .@expr1073747034 next (@expr1073747035 ) ; }
137: while (@expr1073747036 Token ::@expr5182 simpleMatch (@expr1073747038 tok@var2555 .@expr5215 link (@expr5216 ) , "] [" ) ) {
138: tok@var2555 =@expr1073747041 tok@var2555 .@expr5215 link (@expr5216 ) .@expr1073747044 next (@expr1073747045 ) ; }
139: if (@expr1073747046 Token ::@expr5162 Match (@expr1073747048 tok@var2555 .@expr5215 link (@expr5216 ) , "] =|{" ) ) {
140: continue ; }
141: }
142:
143: bool stdtype@var2556 ; stdtype@var2556 =@expr1073747051 mTokenizer@var28 .@expr1073747052 isC (@expr1073747053 ) &&@expr1073747054 arrayTypeDefs@var2552 .@expr1073747055 find (@expr1073747056 var@var2553 .@expr5233 typeStartToken (@expr5234 ) .@expr1073747059 str (@expr1073747060 ) ) ==@expr1073747061 arrayTypeDefs@var2552 .@expr1073747062 end (@expr1073747063 ) ;
144: const Token * tok@var2557 ; tok@var2557 =@expr1073747064 var@var2553 .@expr5233 typeStartToken (@expr5234 ) ;
145: for (@expr1073747067 ; tok@var2557 !=@expr1073747068 var@var2553 .@expr5164 nameToken (@expr5165 ) &&@expr1073747071 tok@var2557 .@expr5248 str (@expr5249 ) !=@expr1073747074 "<" ; tok@var2557 =@expr1073747075 tok@var2557 .@expr5252 next (@expr5253 ) ) {
146: if (@expr1073747078 tok@var2557 .@expr1073747079 isStandardType (@expr1073747080 ) ||@expr1073747081 tok@var2557 .@expr1073747082 isEnumType (@expr1073747083 ) ) {
147: stdtype@var2556 =@expr1073747084 true ; }
148: }
149: if (@expr1073747085 var@var2553 .@expr5196 isArray (@expr5197 ) &&@expr1073747088 !@expr1073747089 stdtype@var2556 ) {
150: if (@expr1073747090 !@expr1073747091 (@expr1073747092 var@var2553 .@expr1073747093 isStlType (@expr1073747094 ) &&@expr1073747095 Token ::@expr5182 simpleMatch (@expr1073747097 var@var2553 .@expr5233 typeStartToken (@expr5234 ) , "std :: array" ) &&@expr1073747100 var@var2553 .@expr5277 valueType (@expr5278 ) &&@expr1073747103
151: var@var2553 .@expr5277 valueType (@expr5278 ) .@expr5282 containerTypeToken@var2938 &&@expr1073747107 var@var2553 .@expr5277 valueType (@expr5278 ) .@expr5282 containerTypeToken@var2938 .@expr1073747111 isStandardType (@expr1073747112 ) ) ) {
152: continue ; }
153: }
154:
155: while (@expr1073747113 tok@var2557 &&@expr1073747114 tok@var2557 .@expr5248 str (@expr5249 ) !=@expr1073747117 ";" ) {
156: tok@var2557 =@expr1073747118 tok@var2557 .@expr5252 next (@expr5253 ) ; }
157: if (@expr1073747121 !@expr1073747122 tok@var2557 ) {
158: continue ; }
159:
160: if (@expr1073747123 tok@var2557 .@expr5300 astParent (@expr5301 ) &&@expr1073747126 Token ::@expr5182 simpleMatch (@expr1073747128 tok@var2557 .@expr5300 astParent (@expr5301 ) .@expr1073747131 previous (@expr1073747132 ) , "for (" ) &&@expr1073747133
161: checkLoopBody (@expr1073747134 tok@var2557 .@expr5300 astParent (@expr5301 ) .@expr1073747137 link (@expr1073747138 ) .@expr1073747139 next (@expr1073747140 ) , var@var2553 , var@var2553 .@expr5196 isArray (@expr5197 ) ?@expr1073747143 ARRAY :@expr1073747144 NO_ALLOC , emptyString@var1 , true ) ) {
162: continue ; }
163:
164: if (@expr1073747145 var@var2553 .@expr5196 isArray (@expr5197 ) ) {
165: Alloc alloc@var2558 ; alloc@var2558 =@expr1073747148 ARRAY ;
166: const std ::@expr1073747149 map < int , VariableValue > variableValue@var2559 ;
167: bool init@var2560 ; init@var2560 =@expr1073747150 false ;
168: for (@expr1073747151 const Token *@expr5328 parent@var2561 =@expr1073747153 var@var2553 .@expr5164 nameToken (@expr5165 ) ; parent@var2561 ; parent@var2561 =@expr1073747156 parent@var2561 .@expr1073747157 astParent (@expr1073747158 ) ) {
169: if (@expr1073747159 parent@var2561 .@expr1073747160 str (@expr1073747161 ) ==@expr1073747162 "=" ) {
170: init@var2560 =@expr1073747163 true ;
171: break ;
172: }
173: }
174: if (@expr1073747164 !@expr1073747165 init@var2560 ) {
175: checkScopeForVariable (@expr1073747166 tok@var2557 , var@var2553 , nullptr , nullptr , &@expr1073747167 alloc@var2558 , emptyString@var1 , variableValue@var2559 ) ; }
176: continue ;
177: }
178: if (@expr1073747168 stdtype@var2556 ||@expr1073747169 var@var2553 .@expr5140 isPointer (@expr5141 ) ) {
179: Alloc alloc@var2562 ; alloc@var2562 =@expr1073747172 NO_ALLOC ;
180: const std ::@expr1073747173 map < int , VariableValue > variableValue@var2563 ;
181: checkScopeForVariable (@expr1073747174 tok@var2557 , var@var2553 , nullptr , nullptr , &@expr1073747175 alloc@var2562 , emptyString@var1 , variableValue@var2563 ) ;
182: }
183: if (@expr1073747176 var@var2553 .@expr5136 type (@expr5137 ) ) {
184: checkStruct (@expr1073747179 tok@var2557 , var@var2553 ) ; }
185: }
186:
187: if (@expr1073747180 scope@var2551 .@expr5357 function@var2564 ) {
188: for (@expr1073747182 const Variable &@expr5128 arg@var2565 :@expr1073747184 scope@var2551 .@expr5357 function@var2564 .@expr1073747186 argumentList@var2566 ) {
189: if (@expr1073747187 arg@var2565 .@expr5364 declarationId (@expr5365 ) &&@expr1073747190 Token ::@expr5162 Match (@expr1073747192 arg@var2565 .@expr5369 typeStartToken (@expr5370 ) , "%type% * %name% [,)]" ) ) {
190:
191: for (@expr1073747195 const Token *@expr5328 tok@var2567 =@expr1073747197 scope@var2551 .@expr1073747198 bodyStart@var2568 ; tok@var2567 !=@expr1073747199 scope@var2551 .@expr1073747200 bodyEnd@var2569 ; tok@var2567 =@expr1073747201 tok@var2567 .@expr5378 next (@expr5379 ) ) {
192: if (@expr1073747204 !@expr1073747205 Token ::@expr5162 Match (@expr1073747207 tok@var2567 , "[;{}] %varid% =" , arg@var2565 .@expr5364 declarationId (@expr5365 ) ) ) {
193: continue ; }
194: const Token * allocFuncCallToken@var2570 ; allocFuncCallToken@var2570 =@expr1073747210 findAllocFuncCallToken (@expr1073747211 tok@var2567 .@expr1073747212 tokAt (@expr1073747213 2 ) .@expr1073747214 astOperand2 (@expr1073747215 ) , mSettings@var29 .@expr5392 library@var2925 ) ;
195: if (@expr1073747217 !@expr1073747218 allocFuncCallToken@var2570 ) {
196: continue ; }
197: const Library ::@expr1073747219 AllocFunc * allocFunc@var2571 ; allocFunc@var2571 =@expr1073747220 mSettings@var29 .@expr5392 library@var2925 .@expr1073747222 getAllocFuncInfo (@expr1073747223 allocFuncCallToken@var2570 ) ;
198: if (@expr1073747224 !@expr1073747225 allocFunc@var2571 ||@expr1073747226 allocFunc@var2571 .@expr1073747227 initData@var2572 ) {
199: continue ; }
200:
201: if (@expr1073747228 arg@var2565 .@expr5369 typeStartToken (@expr5370 ) .@expr1073747231 strAt (@expr1073747232 -1 ) ==@expr1073747233 "struct" ||@expr1073747234 (@expr1073747235 arg@var2565 .@expr5412 type (@expr5413 ) &&@expr1073747238 arg@var2565 .@expr5412 type (@expr5413 ) .@expr1073747241 isStructType (@expr1073747242 ) ) ) {
202: checkStruct (@expr1073747243 tok@var2567 , arg@var2565 ) ; }
203: else { if (@expr1073747244 arg@var2565 .@expr5369 typeStartToken (@expr5370 ) .@expr1073747247 isStandardType (@expr1073747248 ) ||@expr1073747249 arg@var2565 .@expr5369 typeStartToken (@expr5370 ) .@expr1073747252 isEnumType (@expr1073747253 ) ) {
204: Alloc alloc@var2573 ; alloc@var2573 =@expr1073747254 NO_ALLOC ;
205: const std ::@expr1073747255 map < int , VariableValue > variableValue@var2574 ;
206: checkScopeForVariable (@expr1073747256 tok@var2567 .@expr5378 next (@expr5379 ) , arg@var2565 , nullptr , nullptr , &@expr1073747259 alloc@var2573 , emptyString@var1 , variableValue@var2574 ) ;
207: } }
208: }
209: }
210: }
211: }
212: }
213:
214: void CheckUninitVar :: checkStruct ( const Token * tok@var2575 , const Variable & structvar@var2576 )
215: {
216: const Token * typeToken@var2577 ; typeToken@var2577 =@expr1073747260 structvar@var2576 .@expr1073747261 typeStartToken (@expr1073747262 ) ;
217: while (@expr1073747263 Token ::@expr1073747264 Match (@expr1073747265 typeToken@var2577 , "%name% ::" ) ) {
218: typeToken@var2577 =@expr1073747266 typeToken@var2577 .@expr1073747267 tokAt (@expr1073747268 2 ) ; }
219: const SymbolDatabase * symbolDatabase@var2578 ; symbolDatabase@var2578 =@expr1073747269 mTokenizer@var28 .@expr1073747270 getSymbolDatabase (@expr1073747271 ) ;
220: for (@expr1073747272 const Scope *@expr5449 scope2@var2579 :@expr1073747274 symbolDatabase@var2578 .@expr1073747275 classAndStructScopes@var2580 ) {
221: if (@expr1073747276 scope2@var2579 .@expr1073747277 className@var2581 ==@expr1073747278 typeToken@var2577 .@expr1073747279 str (@expr1073747280 ) &&@expr1073747281 scope2@var2579 .@expr1073747282 numConstructors@var2582 ==@expr1073747283 0U ) {
222: for (@expr1073747284 const Variable &@expr1073747285 var@var2583 :@expr1073747286 scope2@var2579 .@expr1073747287 varlist@var2584 ) {
223: if (@expr1073747288 var@var2583 .@expr1073747289 isStatic (@expr1073747290 ) ||@expr1073747291 var@var2583 .@expr1073747292 hasDefault (@expr1073747293 ) ||@expr1073747294 var@var2583 .@expr1073747295 isArray (@expr1073747296 ) ||@expr1073747297
224: (@expr1073747298 !@expr1073747299 mTokenizer@var28 .@expr1073747300 isC (@expr1073747301 ) &&@expr1073747302 var@var2583 .@expr1073747303 isClass (@expr1073747304 ) &&@expr1073747305 (@expr1073747306 !@expr1073747307 var@var2583 .@expr5484 type (@expr5485 ) ||@expr1073747310 var@var2583 .@expr5484 type (@expr5485 ) .@expr1073747313 needInitialization@var2937 !=@expr1073747314 Type ::@expr1073747315 NeedInitialization ::@expr1073747316 True ) ) ) {
225: continue ; }
226:
227:
228: bool innerunion@var2585 ; innerunion@var2585 =@expr1073747317 false ;
229: for (@expr1073747318 const Scope *@expr5449 innerScope@var2586 :@expr1073747320 scope2@var2579 .@expr1073747321 nestedList@var2587 ) {
230: if (@expr1073747322 innerScope@var2586 .@expr1073747323 type@var2588 ==@expr1073747324 Scope ::@expr1073747325 eUnion ) {
231: if (@expr1073747326 var@var2583 .@expr5503 typeStartToken (@expr5504 ) .@expr5505 linenr (@expr5506 ) >=@expr1073747331 innerScope@var2586 .@expr1073747332 bodyStart@var2589 .@expr1073747333 linenr (@expr1073747334 ) &&@expr1073747335
232: var@var2583 .@expr5503 typeStartToken (@expr5504 ) .@expr5505 linenr (@expr5506 ) <=@expr1073747340 innerScope@var2586 .@expr1073747341 bodyEnd@var2590 .@expr1073747342 linenr (@expr1073747343 ) ) {
233: innerunion@var2585 =@expr1073747344 true ;
234: break ;
235: }
236: }
237: }
238:
239: if (@expr1073747345 !@expr1073747346 innerunion@var2585 ) {
240: Alloc alloc@var2591 ; alloc@var2591 =@expr1073747347 NO_ALLOC ;
241: const Token * tok2@var2592 ; tok2@var2592 =@expr1073747348 tok@var2575 ;
242: if (@expr1073747349 tok@var2575 .@expr1073747350 str (@expr1073747351 ) ==@expr1073747352 "}" ) {
243: tok2@var2592 =@expr1073747353 tok2@var2592 .@expr1073747354 next (@expr1073747355 ) ; }
244: const std ::@expr1073747356 map < int , VariableValue > variableValue@var2593 ;
245: checkScopeForVariable (@expr1073747357 tok2@var2592 , structvar@var2576 , nullptr , nullptr , &@expr1073747358 alloc@var2591 , var@var2583 .@expr1073747359 name (@expr1073747360 ) , variableValue@var2593 ) ;
246: }
247: }
248: }
249: }
250: }
251:
252: static VariableValue operator! ( VariableValue v@var2594 )
253: {
254: v@var2594 .@expr5537 notEqual@var2595 =@expr1073747362 !@expr1073747363 v@var2594 .@expr5537 notEqual@var2595 ;
255: return v@var2594 ;
256: }
257: static bool operator== ( const VariableValue & v@var2596 , long long i@var2597 )
258: {
259: return v@var2596 .@expr1073747365 notEqual@var2598 ?@expr1073747366 (@expr1073747367 i@var2597 !=@expr1073747368 v@var2596 .@expr5545 value@var2599 ) :@expr1073747370 (@expr1073747371 i@var2597 ==@expr1073747372 v@var2596 .@expr5545 value@var2599 ) ;
260: }
261: static bool operator!= ( const VariableValue & v@var2600 , long long i@var2601 )
262: {
263: return v@var2600 .@expr1073747374 notEqual@var2602 ?@expr1073747375 (@expr1073747376 i@var2601 ==@expr1073747377 v@var2600 .@expr5554 value@var2603 ) :@expr1073747379 (@expr1073747380 i@var2601 !=@expr1073747381 v@var2600 .@expr5554 value@var2603 ) ;
264: }
265:
266: static void conditionAlwaysTrueOrFalse ( const Token * tok@var2604 , const std :: map < int , VariableValue > & variableValue@var2605 , bool * alwaysTrue@var2606 , bool * alwaysFalse@var2607 )
267: {
268: if (@expr1073747383 !@expr1073747384 tok@var2604 ) {
269: return ; }
270:
271: if (@expr1073747385 tok@var2604 .@expr1073747386 hasKnownIntValue (@expr1073747387 ) ) {
272: if (@expr1073747388 tok@var2604 .@expr1073747389 getKnownIntValue (@expr1073747390 ) ==@expr1073747391 0 ) {
273: *@expr5568 alwaysFalse@var2607 =@expr1073747393 true ; }
274: else {
275: *@expr5570 alwaysTrue@var2606 =@expr1073747395 true ; }
276: return ;
277: }
278:
279: if (@expr1073747396 tok@var2604 .@expr1073747397 isName (@expr1073747398 ) ||@expr1073747399 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr5578 "." ) {
280: while (@expr1073747403 tok@var2604 &&@expr1073747404 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr5578 "." ) {
281: tok@var2604 =@expr1073747408 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) ; }
282: const std ::@expr5587 map < int , VariableValue > ::@expr1073747412 const_iterator it@var2608 =@expr1073747413 variableValue@var2605 .@expr5590 find (@expr1073747415 tok@var2604 ?@expr1073747416 tok@var2604 .@expr1073747417 varId (@expr1073747418 ) :@expr1073747419 ~@expr5596 0U ) ;
283: if (@expr1073747421 it@var2608 !=@expr1073747422 variableValue@var2605 .@expr5599 end (@expr5600 ) ) {
284: *@expr5570 alwaysTrue@var2606 =@expr1073747426 it@var2608 .@expr5603 second@var2609 !=@expr1073747428 0LL ;
285: *@expr5568 alwaysFalse@var2607 =@expr1073747430 it@var2608 .@expr5603 second@var2609 ==@expr1073747432 0LL ;
286: }
287: }
288:
289: else { if (@expr1073747433 tok@var2604 .@expr1073747434 isComparisonOp (@expr1073747435 ) ) {
290: if (@expr1073747436 variableValue@var2605 .@expr1073747437 empty (@expr1073747438 ) ) {
291: return ;
292: }
293:
294: const Token * vartok@var2610 ; const Token * numtok@var2611 ;
295: if (@expr1073747439 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) &&@expr1073747442 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) .@expr1073747445 isNumber (@expr1073747446 ) ) {
296: vartok@var2610 =@expr1073747447 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) ;
297: numtok@var2611 =@expr1073747450 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) ;
298: } else { if (@expr1073747453 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) &&@expr1073747456 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) .@expr1073747459 isNumber (@expr1073747460 ) ) {
299: vartok@var2610 =@expr1073747461 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) ;
300: numtok@var2611 =@expr1073747464 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) ;
301: } else {
302: return ;
303: } }
304:
305: while (@expr1073747467 vartok@var2610 &&@expr1073747468 vartok@var2610 .@expr1073747469 str (@expr1073747470 ) ==@expr1073747471 "." ) {
306: vartok@var2610 =@expr1073747472 vartok@var2610 .@expr1073747473 astOperand2 (@expr1073747474 ) ; }
307:
308: const std ::@expr5587 map < int , VariableValue > ::@expr1073747476 const_iterator it@var2612 =@expr1073747477 variableValue@var2605 .@expr5590 find (@expr1073747479 vartok@var2610 ?@expr1073747480 vartok@var2610 .@expr1073747481 varId (@expr1073747482 ) :@expr1073747483 ~@expr5596 0U ) ;
309: if (@expr1073747485 it@var2612 ==@expr1073747486 variableValue@var2605 .@expr5599 end (@expr5600 ) ) {
310: return ; }
311:
312: if (@expr1073747489 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr1073747492 "==" ) {
313: *@expr5570 alwaysTrue@var2606 =@expr1073747494 it@var2612 .@expr5671 second@var2613 ==@expr1073747496 MathLib ::@expr5673 toLongNumber (@expr5674 numtok@var2611 .@expr5675 str (@expr5676 ) ) ; }
314: else { if (@expr1073747501 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr1073747504 "!=" ) {
315: *@expr5570 alwaysTrue@var2606 =@expr1073747506 it@var2612 .@expr5671 second@var2613 !=@expr1073747508 MathLib ::@expr5673 toLongNumber (@expr5674 numtok@var2611 .@expr5675 str (@expr5676 ) ) ; }
316: else {
317: return ; } }
318: *@expr5568 alwaysFalse@var2607 =@expr1073747514 !@expr1073747515 (@expr1073747516 *@expr5570 alwaysTrue@var2606 ) ;
319: }
320:
321: else { if (@expr1073747518 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr1073747521 "!" ) {
322: bool t@var2614 ; t@var2614 =@expr1073747522 false ; bool f@var2615 ; f@var2615 =@expr1073747523 false ;
323: conditionAlwaysTrueOrFalse (@expr1073747524 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) , variableValue@var2605 , &@expr1073747527 t@var2614 , &@expr1073747528 f@var2615 ) ;
324: if (@expr1073747529 t@var2614 ||@expr1073747530 f@var2615 ) {
325: *@expr5570 alwaysTrue@var2606 =@expr1073747532 !@expr1073747533 t@var2614 ;
326: *@expr5568 alwaysFalse@var2607 =@expr1073747535 !@expr1073747536 f@var2615 ;
327: }
328: }
329:
330: else { if (@expr1073747537 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr1073747540 "||" ) {
331: bool t1@var2616 ; t1@var2616 =@expr1073747541 false ; bool f1@var2617 ; f1@var2617 =@expr1073747542 false ;
332: conditionAlwaysTrueOrFalse (@expr1073747543 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) , variableValue@var2605 , &@expr1073747546 t1@var2616 , &@expr1073747547 f1@var2617 ) ;
333: bool t2@var2618 ; t2@var2618 =@expr1073747548 false ; bool f2@var2619 ; f2@var2619 =@expr1073747549 false ;
334: if (@expr1073747550 !@expr1073747551 t1@var2616 ) {
335: conditionAlwaysTrueOrFalse (@expr1073747552 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) , variableValue@var2605 , &@expr1073747555 t2@var2618 , &@expr1073747556 f2@var2619 ) ; }
336: *@expr5570 alwaysTrue@var2606 =@expr1073747558 t1@var2616 ||@expr1073747559 t2@var2618 ;
337: *@expr5568 alwaysFalse@var2607 =@expr1073747561 f1@var2617 &&@expr1073747562 f2@var2619 ;
338: }
339:
340: else { if (@expr1073747563 tok@var2604 .@expr5576 str (@expr5577 ) ==@expr1073747566 "&&" ) {
341: bool t1@var2620 ; t1@var2620 =@expr1073747567 false ; bool f1@var2621 ; f1@var2621 =@expr1073747568 false ;
342: conditionAlwaysTrueOrFalse (@expr1073747569 tok@var2604 .@expr5624 astOperand1 (@expr5625 ) , variableValue@var2605 , &@expr1073747572 t1@var2620 , &@expr1073747573 f1@var2621 ) ;
343: bool t2@var2622 ; t2@var2622 =@expr1073747574 false ; bool f2@var2623 ; f2@var2623 =@expr1073747575 false ;
344: if (@expr1073747576 !@expr1073747577 f1@var2621 ) {
345: conditionAlwaysTrueOrFalse (@expr1073747578 tok@var2604 .@expr5585 astOperand2 (@expr5586 ) , variableValue@var2605 , &@expr1073747581 t2@var2622 , &@expr1073747582 f2@var2623 ) ; }
346: *@expr5570 alwaysTrue@var2606 =@expr1073747584 t1@var2620 &&@expr1073747585 t2@var2622 ;
347: *@expr5568 alwaysFalse@var2607 =@expr1073747587 f1@var2621 ||@expr1073747588 f2@var2623 ;
348: } } } } }
349: }
350:
351: static bool isVariableUsed ( const Token * tok@var2624 , const Variable & var@var2625 )
352: {
353: if (@expr1073747589 !@expr1073747590 tok@var2624 ) {
354: return false ; }
355: if (@expr1073747591 tok@var2624 .@expr1073747592 str (@expr1073747593 ) ==@expr1073747594 "&" &&@expr1073747595 !@expr1073747596 tok@var2624 .@expr5773 astOperand2 (@expr5774 ) ) {
356: return false ; }
357: if (@expr1073747599 tok@var2624 .@expr1073747600 isConstOp (@expr1073747601 ) ) {
358: return isVariableUsed (@expr1073747602 tok@var2624 .@expr1073747603 astOperand1 (@expr1073747604 ) , var@var2625 ) ||@expr1073747605 isVariableUsed (@expr1073747606 tok@var2624 .@expr5773 astOperand2 (@expr5774 ) , var@var2625 ) ; }
359: if (@expr1073747609 tok@var2624 .@expr1073747610 varId (@expr1073747611 ) !=@expr1073747612 var@var2625 .@expr1073747613 declarationId (@expr1073747614 ) ) {
360: return false ; }
361: if (@expr1073747615 !@expr1073747616 var@var2625 .@expr1073747617 isArray (@expr1073747618 ) ) {
362: return true ; }
363:
364: const Token * parent@var2626 ; parent@var2626 =@expr1073747619 tok@var2624 .@expr1073747620 astParent (@expr1073747621 ) ;
365: while (@expr1073747622 Token ::@expr5799 Match (@expr1073747624 parent@var2626 , "[?:]" ) ) {
366: parent@var2626 =@expr1073747625 parent@var2626 .@expr5802 astParent (@expr5803 ) ; }
367:
368: if (@expr1073747628 !@expr1073747629 Token ::@expr5799 Match (@expr1073747631 parent@var2626 , "*|[" ) ) {
369: return false ; }
370: const Token * parent2@var2627 ; parent2@var2627 =@expr1073747632 parent@var2626 .@expr5802 astParent (@expr5803 ) ;
371:
372: return !@expr1073747635 parent2@var2627 ||@expr1073747636 parent2@var2627 .@expr1073747637 isConstOp (@expr1073747638 ) ||@expr1073747639 (@expr1073747640 parent2@var2627 .@expr1073747641 str (@expr1073747642 ) ==@expr1073747643 "=" &&@expr1073747644 parent2@var2627 .@expr1073747645 astOperand2 (@expr1073747646 ) ==@expr1073747647 parent@var2626 ) ;
373: }
374:
375: bool CheckUninitVar :: checkScopeForVariable ( const Token * tok@var2628 , const Variable & var@var2629 , bool * const possibleInit@var2630 , bool * const noreturn@var2631 , Alloc * const alloc@var2632 , const std :: string & membervar@var2633 , std :: map < int , VariableValue > variableValue@var2634 )
376: {
377: const bool suppressErrors@var2635 (@expr1073747648 possibleInit@var2630 &&@expr1073747649 *@expr5826 possibleInit@var2630 ) ;
378: const bool printDebug@var2636 =@expr1073747651 mSettings@var29 .@expr1073747652 debugwarnings@var2926 ;
379:
380: if (@expr5829 possibleInit@var2630 ) {
381: *@expr5826 possibleInit@var2630 =@expr1073747655 false ; }
382:
383: int number_of_if@var2637 ; number_of_if@var2637 =@expr1073747656 0 ;
384:
385: if (@expr1073747657 var@var2629 .@expr5834 declarationId (@expr5835 ) ==@expr1073747660 0U ) {
386: return true ; }
387:
388: for (@expr1073747661 ; tok@var2628 ; tok@var2628 =@expr1073747662 tok@var2628 .@expr5839 next (@expr5840 ) ) {
389:
390: if (@expr1073747665 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr1073747668 "}" ) {
391: if (@expr1073747669 number_of_if@var2637 &&@expr1073747670 possibleInit@var2630 ) {
392: *@expr5826 possibleInit@var2630 =@expr1073747672 true ; }
393:
394:
395: if (@expr1073747673 mTokenizer@var28 .@expr1073747674 isScopeNoReturn (@expr1073747675 tok@var2628 ) ) {
396: if (@expr5852 noreturn@var2631 ) {
397: *@expr5853 noreturn@var2631 =@expr1073747678 true ; }
398: return false ;
399: }
400:
401: break ;
402: }
403:
404:
405: if (@expr1073747679 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr5858 "{" &&@expr1073747683 Token ::@expr5860 Match (@expr1073747685 tok@var2628 .@expr5862 previous (@expr5863 ) , ",|;|{|}|]|try" ) ) {
406: bool possibleInitInner@var2638 ; possibleInitInner@var2638 =@expr1073747688 false ;
407: if (@expr1073747689 checkScopeForVariable (@expr1073747690 tok@var2628 .@expr5839 next (@expr5840 ) , var@var2629 , &@expr1073747693 possibleInitInner@var2638 , noreturn@var2631 , alloc@var2632 , membervar@var2633 , variableValue@var2634 ) ) {
408: return true ; }
409: tok@var2628 =@expr1073747694 tok@var2628 .@expr5871 link (@expr5872 ) ;
410: if (@expr1073747697 possibleInitInner@var2638 ) {
411: number_of_if@var2637 =@expr1073747698 1 ;
412: if (@expr5829 possibleInit@var2630 ) {
413: *@expr5826 possibleInit@var2630 =@expr1073747701 true ; }
414: }
415: continue ;
416: }
417:
418:
419: if (@expr1073747702 Token ::@expr5860 Match (@expr1073747704 tok@var2628 .@expr5862 previous (@expr5863 ) , "[;{}] %var% = - %name% ;" ) ) {
420: variableValue@var2634 [@expr1073747707 tok@var2628 .@expr5884 varId (@expr5885 ) ] =@expr1073747710 !@expr5887 VariableValue (@expr5888 0 ) ; }
421:
422:
423: else { if (@expr1073747713 Token ::@expr5890 simpleMatch (@expr5891 tok@var2628 , "if (" ) ) {
424: bool alwaysTrue@var2639 ; alwaysTrue@var2639 =@expr1073747716 false ;
425: bool alwaysFalse@var2640 ; alwaysFalse@var2640 =@expr1073747717 false ;
426:
427:
428: if (@expr5894 !@expr5895 membervar@var2633 .@expr5896 empty (@expr5897 ) ) {
429: for (@expr1073747722 const Token *@expr5899 cond@var2641 =@expr1073747724 tok@var2628 .@expr5901 linkAt (@expr5902 1 ) ; cond@var2641 !=@expr1073747727 tok@var2628 ; cond@var2641 =@expr1073747728 cond@var2641 .@expr1073747729 previous (@expr1073747730 ) ) {
430: if (@expr1073747731 cond@var2641 .@expr1073747732 varId (@expr1073747733 ) ==@expr1073747734 var@var2629 .@expr5834 declarationId (@expr5835 ) &&@expr1073747737 isMemberVariableAssignment (@expr1073747738 cond@var2641 , membervar@var2633 ) ) {
431: return true ; }
432: }
433: }
434:
435: conditionAlwaysTrueOrFalse (@expr1073747739 tok@var2628 .@expr5839 next (@expr5840 ) .@expr5918 astOperand2 (@expr5919 ) , variableValue@var2634 , &@expr1073747744 alwaysTrue@var2639 , &@expr1073747745 alwaysFalse@var2640 ) ;
436:
437:
438: if (@expr1073747746 !@expr5923 alwaysTrue@var2639 &&@expr1073747748 checkIfForWhileHead (@expr1073747749 tok@var2628 .@expr5839 next (@expr5840 ) , var@var2629 , suppressErrors@var2635 , bool (@expr5928 number_of_if@var2637 ==@expr5929 0 ) , *@expr5930 alloc@var2632 , membervar@var2633 ) ) {
439: return true ; }
440:
441:
442: int condVarId@var2642 ; condVarId@var2642 =@expr1073747755 0 ;
443: VariableValue condVarValue@var2643 (@expr1073747756 0 ) ;
444: const Token * condVarTok@var2644 ; condVarTok@var2644 =@expr1073747757 nullptr ;
445: if (@expr1073747758 alwaysFalse@var2640 ) {
446: ; }
447: else { if (@expr1073747759 Token ::@expr5890 simpleMatch (@expr5891 tok@var2628 , "if (" ) &&@expr1073747762
448: astIsVariableComparison (@expr1073747763 tok@var2628 .@expr5839 next (@expr5840 ) .@expr5918 astOperand2 (@expr5919 ) , "!=" , "0" , &@expr1073747768 condVarTok@var2644 ) ) {
449: const std ::@expr5945 map < int , VariableValue > ::@expr1073747770 const_iterator it@var2645 =@expr1073747771 variableValue@var2634 .@expr5948 find (@expr1073747773 condVarTok@var2644 .@expr5950 varId (@expr5951 ) ) ;
450: if (@expr1073747776 it@var2645 !=@expr1073747777 variableValue@var2634 .@expr5954 end (@expr5955 ) &&@expr1073747780 it@var2645 .@expr1073747781 second@var2646 !=@expr1073747782 0 ) {
451: return true ; }
452: else {
453: condVarId@var2642 =@expr1073747783 condVarTok@var2644 .@expr5950 varId (@expr5951 ) ;
454: condVarValue@var2643 =@expr1073747786 !@expr5887 VariableValue (@expr5888 0 ) ;
455: }
456: } else { if (@expr1073747789 Token ::@expr5890 simpleMatch (@expr5891 tok@var2628 , "if (" ) &&@expr1073747792 Token ::@expr5860 Match (@expr1073747794 tok@var2628 .@expr5839 next (@expr5840 ) .@expr5918 astOperand2 (@expr5919 ) , "==|!=" ) ) {
457: const Token * condition@var2647 ; condition@var2647 =@expr1073747799 tok@var2628 .@expr5839 next (@expr5840 ) .@expr5918 astOperand2 (@expr5919 ) ;
458: const Token * lhs@var2648 ; lhs@var2648 =@expr1073747804 condition@var2647 .@expr1073747805 astOperand1 (@expr1073747806 ) ;
459: const Token * rhs@var2649 ; rhs@var2649 =@expr1073747807 condition@var2647 .@expr1073747808 astOperand2 (@expr1073747809 ) ;
460: const Token * vartok@var2650 ; vartok@var2650 =@expr1073747810 (@expr1073747811 lhs@var2648 &&@expr1073747812 lhs@var2648 .@expr1073747813 hasKnownIntValue (@expr1073747814 ) ) ?@expr1073747815 rhs@var2649 :@expr5992 lhs@var2648 ;
461: const Token * numtok@var2651 ; numtok@var2651 =@expr1073747817 (@expr1073747818 lhs@var2648 ==@expr1073747819 vartok@var2650 ) ?@expr1073747820 rhs@var2649 :@expr5992 lhs@var2648 ;
462: while (@expr1073747822 Token ::@expr5890 simpleMatch (@expr1073747824 vartok@var2650 , "." ) ) {
463: vartok@var2650 =@expr1073747825 vartok@var2650 .@expr1073747826 astOperand2 (@expr1073747827 ) ; }
464: if (@expr1073747828 vartok@var2650 &&@expr1073747829 vartok@var2650 .@expr6006 varId (@expr6007 ) &&@expr1073747832 numtok@var2651 &&@expr1073747833 numtok@var2651 .@expr1073747834 hasKnownIntValue (@expr1073747835 ) ) {
465: const std ::@expr5945 map < int , VariableValue > ::@expr1073747837 const_iterator it@var2652 =@expr1073747838 variableValue@var2634 .@expr5948 find (@expr1073747840 vartok@var2650 .@expr6006 varId (@expr6007 ) ) ;
466: if (@expr1073747843 it@var2652 !=@expr1073747844 variableValue@var2634 .@expr5954 end (@expr5955 ) &&@expr1073747847 it@var2652 .@expr1073747848 second@var2653 !=@expr1073747849 numtok@var2651 .@expr6026 getKnownIntValue (@expr6027 ) ) {
467: return true ; }
468: condVarId@var2642 =@expr1073747852 vartok@var2650 .@expr6006 varId (@expr6007 ) ;
469: condVarValue@var2643 =@expr1073747855 VariableValue (@expr1073747856 numtok@var2651 .@expr6026 getKnownIntValue (@expr6027 ) ) ;
470: if (@expr1073747859 condition@var2647 .@expr1073747860 str (@expr1073747861 ) ==@expr1073747862 "!=" ) {
471: condVarValue@var2643 =@expr1073747863 !@expr6040 condVarValue@var2643 ; }
472: }
473: } } }
474:
475:
476: tok@var2628 =@expr1073747865 tok@var2628 .@expr5839 next (@expr5840 ) .@expr6044 link (@expr6045 ) .@expr6046 next (@expr6047 ) ;
477:
478: if (@expr6048 !@expr6049 tok@var2628 ) {
479: break ; }
480: if (@expr1073747874 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr5858 "{" ) {
481: bool possibleInitIf@var2654 (@expr1073747878 (@expr1073747879 !@expr5923 alwaysTrue@var2639 &&@expr1073747881 number_of_if@var2637 >@expr6058 0 ) ||@expr1073747883 suppressErrors@var2635 ) ;
482: bool noreturnIf@var2655 ; noreturnIf@var2655 =@expr1073747884 false ;
483: const bool initif@var2656 =@expr1073747885 !@expr6062 alwaysFalse@var2640 &&@expr1073747887 checkScopeForVariable (@expr1073747888 tok@var2628 .@expr5839 next (@expr5840 ) , var@var2629 , &@expr1073747891 possibleInitIf@var2654 , &@expr1073747892 noreturnIf@var2655 , alloc@var2632 , membervar@var2633 , variableValue@var2634 ) ;
484:
|
488:
489: if (@expr1073747893 !@expr5923 alwaysTrue@var2639 &&@expr1073747895 noreturnIf@var2655 &&@expr1073747896 number_of_if@var2637 >@expr6058 0 ) {
490: if (@expr6074 printDebug@var2636 ) {
491: std ::@expr1073747899 string condition@var2657 ;
492: for (@expr1073747900 const Token *@expr5899 tok2@var2658 =@expr1073747902 tok@var2628 .@expr5901 linkAt (@expr1073747904 -1 ) ; tok2@var2658 !=@expr1073747905 tok@var2628 ; tok2@var2658 =@expr1073747906 tok2@var2658 .@expr6083 next (@expr6084 ) ) {
493: condition@var2657 +=@expr1073747909 tok2@var2658 .@expr1073747910 str (@expr1073747911 ) ;
494: if (@expr1073747912 tok2@var2658 .@expr1073747913 isName (@expr1073747914 ) &&@expr1073747915 tok2@var2658 .@expr6083 next (@expr6084 ) .@expr1073747918 isName (@expr1073747919 ) ) {
495: condition@var2657 +=@expr1073747920 ' ' ; }
496: }
497: reportError (@expr1073747921 tok@var2628 , Severity ::@expr6098 debug , "bailoutUninitVar" , "bailout uninitialized variable checking for '" +@expr1073747923 var@var2629 .@expr1073747924 name (@expr1073747925 ) +@expr1073747926 "'. can't determine if this condition can be false when previous condition is false: " +@expr1073747927 condition@var2657 ) ;
498: }
499: return true ;
500: }
501:
502: if (@expr1073747928 alwaysTrue@var2639 &&@expr1073747929 (@expr1073747930 initif@var2656 ||@expr1073747931 noreturnIf@var2655 ) ) {
503: return true ; }
504:
505: std ::@expr1073747932 map < int , VariableValue > varValueIf@var2659 ;
506: if (@expr1073747933 !@expr6062 alwaysFalse@var2640 &&@expr1073747935 !@expr6112 initif@var2656 &&@expr1073747937 !@expr6114 noreturnIf@var2655 ) {
507: for (@expr1073747939 const Token *@expr5899 tok2@var2660 =@expr1073747941 tok@var2628 ; tok2@var2660 &&@expr1073747942 tok2@var2660 !=@expr1073747943 tok@var2628 .@expr5871 link (@expr5872 ) ; tok2@var2660 =@expr1073747946 tok2@var2660 .@expr6123 next (@expr6124 ) ) {
508: if (@expr1073747949 Token ::@expr5860 Match (@expr1073747951 tok2@var2660 , "[;{}.] %name% = - %name% ;" ) ) {
509: varValueIf@var2659 [@expr6128 tok2@var2660 .@expr6123 next (@expr6124 ) .@expr6131 varId (@expr6132 ) ] =@expr1073747957 !@expr5887 VariableValue (@expr5888 0 ) ; }
510: else { if (@expr1073747960 Token ::@expr5860 Match (@expr1073747962 tok2@var2660 , "[;{}.] %name% = %num% ;" ) ) {
511: varValueIf@var2659 [@expr6128 tok2@var2660 .@expr6123 next (@expr6124 ) .@expr6131 varId (@expr6132 ) ] =@expr1073747968 VariableValue (@expr1073747969 MathLib ::@expr6146 toLongNumber (@expr1073747971 tok2@var2660 .@expr1073747972 strAt (@expr1073747973 3 ) ) ) ; } }
512: }
513: }
514:
515: if (@expr1073747974 initif@var2656 &&@expr1073747975 condVarId@var2642 >@expr6152 0 ) {
516: variableValue@var2634 [@expr6153 condVarId@var2642 ] =@expr1073747978 !@expr6040 condVarValue@var2643 ; }
517:
518:
519: tok@var2628 =@expr1073747980 tok@var2628 .@expr5871 link (@expr5872 ) ;
520:
521: if (@expr1073747983 !@expr1073747984 Token ::@expr5890 simpleMatch (@expr1073747986 tok@var2628 , "} else {" ) ) {
522: if (@expr1073747987 initif@var2656 ||@expr1073747988 possibleInitIf@var2654 ) {
523: ++@expr1073747989 number_of_if@var2637 ;
524: if (@expr1073747990 number_of_if@var2637 >=@expr1073747991 2 ) {
525: return true ; }
526: }
527: } else {
528:
529: tok@var2628 =@expr1073747992 tok@var2628 .@expr6169 tokAt (@expr6170 2 ) ;
530:
531: bool possibleInitElse@var2661 (@expr1073747995 (@expr1073747996 !@expr6062 alwaysFalse@var2640 &&@expr1073747998 number_of_if@var2637 >@expr6058 0 ) ||@expr1073748000 suppressErrors@var2635 ) ;
532: bool noreturnElse@var2662 ; noreturnElse@var2662 =@expr1073748001 false ;
533: const bool initelse@var2663 =@expr1073748002 !@expr5923 alwaysTrue@var2639 &&@expr1073748004 checkScopeForVariable (@expr1073748005 tok@var2628 .@expr5839 next (@expr5840 ) , var@var2629 , &@expr1073748008 possibleInitElse@var2661 , &@expr1073748009 noreturnElse@var2662 , alloc@var2632 , membervar@var2633 , variableValue@var2634 ) ;
534:
535: std ::@expr1073748010 map < int , VariableValue > varValueElse@var2664 ;
536: if (@expr1073748011 !@expr5923 alwaysTrue@var2639 &&@expr1073748013 !@expr6190 initelse@var2663 &&@expr1073748015 !@expr6192 noreturnElse@var2662 ) {
537: for (@expr1073748017 const Token *@expr5899 tok2@var2665 =@expr1073748019 tok@var2628 ; tok2@var2665 &&@expr1073748020 tok2@var2665 !=@expr1073748021 tok@var2628 .@expr5871 link (@expr5872 ) ; tok2@var2665 =@expr1073748024 tok2@var2665 .@expr6201 next (@expr6202 ) ) {
538: if (@expr1073748027 Token ::@expr5860 Match (@expr1073748029 tok2@var2665 , "[;{}.] %var% = - %name% ;" ) ) {
539: varValueElse@var2664 [@expr6206 tok2@var2665 .@expr6201 next (@expr6202 ) .@expr6209 varId (@expr6210 ) ] =@expr1073748035 !@expr5887 VariableValue (@expr5888 0 ) ; }
540: else { if (@expr1073748038 Token ::@expr5860 Match (@expr1073748040 tok2@var2665 , "[;{}.] %var% = %num% ;" ) ) {
541: varValueElse@var2664 [@expr6206 tok2@var2665 .@expr6201 next (@expr6202 ) .@expr6209 varId (@expr6210 ) ] =@expr1073748046 VariableValue (@expr1073748047 MathLib ::@expr6146 toLongNumber (@expr1073748049 tok2@var2665 .@expr1073748050 strAt (@expr1073748051 3 ) ) ) ; } }
542: }
543: }
544:
545: if (@expr1073748052 initelse@var2663 &&@expr1073748053 condVarId@var2642 >@expr6152 0 &&@expr1073748055 !@expr6114 noreturnIf@var2655 &&@expr1073748057 !@expr6192 noreturnElse@var2662 ) {
546: variableValue@var2634 [@expr6153 condVarId@var2642 ] =@expr1073748060 condVarValue@var2643 ; }
547:
548:
549: tok@var2628 =@expr1073748061 tok@var2628 .@expr5871 link (@expr5872 ) ;
550:
551: if (@expr1073748064 (@expr1073748065 alwaysFalse@var2640 ||@expr1073748066 initif@var2656 ||@expr1073748067 noreturnIf@var2655 ) &&@expr1073748068
552: (@expr1073748069 alwaysTrue@var2639 ||@expr1073748070 initelse@var2663 ||@expr1073748071 noreturnElse@var2662 ) ) {
553: return true ; }
554:
555: if (@expr1073748072 initif@var2656 ||@expr1073748073 initelse@var2663 ||@expr1073748074 possibleInitElse@var2661 ) {
556: ++@expr1073748075 number_of_if@var2637 ; }
557: if (@expr1073748076 !@expr6112 initif@var2656 &&@expr1073748078 !@expr6114 noreturnIf@var2655 ) {
558: variableValue@var2634 .@expr6256 insert (@expr1073748081 varValueIf@var2659 .@expr1073748082 begin (@expr1073748083 ) , varValueIf@var2659 .@expr1073748084 end (@expr1073748085 ) ) ; }
559: if (@expr1073748086 !@expr6190 initelse@var2663 &&@expr1073748088 !@expr6192 noreturnElse@var2662 ) {
560: variableValue@var2634 .@expr6256 insert (@expr1073748091 varValueElse@var2664 .@expr1073748092 begin (@expr1073748093 ) , varValueElse@var2664 .@expr1073748094 end (@expr1073748095 ) ) ; }
561: }
562: }
563: }
564:
565:
566: else { if (@expr1073748096 Token ::@expr5890 simpleMatch (@expr1073748098 tok@var2628 , "= {" ) ) {
567:
568: const Token * end@var2666 ; end@var2666 =@expr1073748099 tok@var2628 .@expr5839 next (@expr5840 ) .@expr6044 link (@expr6045 ) ;
569:
570:
571: if (@expr1073748104 var@var2629 .@expr6281 isPointer (@expr6282 ) ||@expr1073748107 var@var2629 .@expr1073748108 isArray (@expr1073748109 ) ) {
572: if (@expr1073748110 Token ::@expr6287 findmatch (@expr1073748112 tok@var2628 .@expr6169 tokAt (@expr6170 2 ) , "%varid%" , end@var2666 , var@var2629 .@expr5834 declarationId (@expr5835 ) ) ) {
573: return true ; }
574: } else { if (@expr1073748117 Token ::@expr6287 findmatch (@expr1073748119 tok@var2628 .@expr6169 tokAt (@expr6170 2 ) , "& %varid%" , end@var2666 , var@var2629 .@expr5834 declarationId (@expr5835 ) ) ) {
575: return true ;
576: } }
577:
578: const Token * errorToken@var2667 ; errorToken@var2667 =@expr1073748124 nullptr ;
579: visitAstNodes (@expr1073748125 tok@var2628 .@expr5839 next (@expr5840 ) ,
580: [@expr1073748128 &@expr1073748129 ] (@expr1073748130 const Token *@expr5899 child@var2668 ) {
581: if (@expr1073748132 child@var2668 .@expr1073748133 isUnaryOp (@expr1073748134 "&" ) ) {
582: return ChildrenToVisit ::@expr6311 none ; }
583: if (@expr1073748136 child@var2668 .@expr6313 str (@expr6314 ) ==@expr1073748139 "," ||@expr1073748140 child@var2668 .@expr6313 str (@expr6314 ) ==@expr1073748143 "{" ||@expr1073748144 child@var2668 .@expr1073748145 isConstOp (@expr1073748146 ) ) {
584: return ChildrenToVisit ::@expr1073748147 op1_and_op2 ; }
585: if (@expr1073748148 child@var2668 .@expr6313 str (@expr6314 ) ==@expr1073748151 "." &&@expr1073748152 Token ::@expr5860 Match (@expr1073748154 child@var2668 .@expr1073748155 astOperand1 (@expr1073748156 ) , "%varid%" , var@var2629 .@expr5834 declarationId (@expr5835 ) ) &&@expr1073748159 child@var2668 .@expr6336 astOperand2 (@expr6337 ) &&@expr1073748162 child@var2668 .@expr6336 astOperand2 (@expr6337 ) .@expr1073748165 str (@expr1073748166 ) ==@expr1073748167 membervar@var2633 ) {
586: errorToken@var2667 =@expr1073748168 child@var2668 ;
587: return ChildrenToVisit ::@expr1073748169 done ;
588: }
589: return ChildrenToVisit ::@expr6311 none ;
590: } ) ;
591:
592: if (@expr1073748171 errorToken@var2667 ) {
593: uninitStructMemberError (@expr1073748172 errorToken@var2667 .@expr1073748173 astOperand2 (@expr1073748174 ) , errorToken@var2667 .@expr1073748175 astOperand1 (@expr1073748176 ) .@expr1073748177 str (@expr1073748178 ) +@expr1073748179 "." +@expr1073748180 membervar@var2633 ) ;
594: return true ;
595: }
596:
597:
598: tok@var2628 =@expr1073748181 end@var2666 ;
599: continue ;
600: } } }
601:
602:
603: if (@expr6358 isSizeOfEtc (@expr6359 tok@var2628 ) ) {
604: tok@var2628 =@expr1073748184 tok@var2628 .@expr5901 linkAt (@expr5902 1 ) ; }
605:
606:
607: else { if (@expr1073748187 Token ::@expr5860 Match (@expr6365 tok@var2628 , "for|while (" ) ||@expr1073748190 Token ::@expr5890 simpleMatch (@expr1073748192 tok@var2628 , "do {" ) ) {
608: const bool forwhile@var2669 =@expr1073748193 Token ::@expr5860 Match (@expr6365 tok@var2628 , "for|while (" ) ;
609:
610:
611: if (@expr1073748196 forwhile@var2669 &&@expr1073748197 checkIfForWhileHead (@expr1073748198 tok@var2628 .@expr5839 next (@expr5840 ) , var@var2629 , tok@var2628 .@expr5842 str (@expr5843 ) ==@expr1073748203 "for" , false , *@expr5930 alloc@var2632 , membervar@var2633 ) ) {
612: return true ; }
613:
614:
615: const Token * tok2@var2670 ; tok2@var2670 =@expr1073748205 forwhile@var2669 ?@expr1073748206 tok@var2628 .@expr5839 next (@expr5840 ) .@expr6044 link (@expr6045 ) .@expr6046 next (@expr6047 ) :@expr1073748213 tok@var2628 .@expr5839 next (@expr5840 ) ;
616:
617: if (@expr1073748216 tok2@var2670 &&@expr1073748217 tok2@var2670 .@expr1073748218 str (@expr1073748219 ) ==@expr1073748220 "{" ) {
618: const bool init@var2671 =@expr1073748221 checkLoopBody (@expr1073748222 tok2@var2670 , var@var2629 , *@expr5930 alloc@var2632 , membervar@var2633 , (@expr1073748224 number_of_if@var2637 >@expr6058 0 ) ||@expr1073748226 suppressErrors@var2635 ) ;
619:
620:
621: if (@expr1073748227 init@var2671 ) {
622: return true ; }
623:
624:
625: bool initcond@var2672 ; initcond@var2672 =@expr1073748228 false ;
626: if (@expr6405 !@expr6406 suppressErrors@var2635 ) {
627: const Token * startCond@var2673 ; startCond@var2673 =@expr1073748231 forwhile@var2669 ?@expr1073748232 tok@var2628 .@expr5839 next (@expr5840 ) :@expr1073748235 tok@var2628 .@expr5839 next (@expr5840 ) .@expr6044 link (@expr6045 ) .@expr1073748240 tokAt (@expr1073748241 2 ) ;
628: initcond@var2672 =@expr1073748242 checkIfForWhileHead (@expr1073748243 startCond@var2673 , var@var2629 , false , bool (@expr5928 number_of_if@var2637 ==@expr5929 0 ) , *@expr5930 alloc@var2632 , membervar@var2633 ) ;
629: }
630:
631:
632: tok@var2628 =@expr1073748247 tok2@var2670 .@expr1073748248 link (@expr1073748249 ) ;
633:
634:
635: if (@expr1073748250 !@expr1073748251 forwhile@var2669 ) {
636:
637: if (@expr1073748252 !@expr1073748253 Token ::@expr5890 simpleMatch (@expr1073748255 tok@var2628 , "} while (" ) ) {
638: if (@expr6074 printDebug@var2636 ) {
639: reportError (@expr1073748257 tok@var2628 , Severity ::@expr6098 debug , "" , "assertion failed '} while ('" ) ; }
640: break ;
641: }
642:
643:
644: tok@var2628 =@expr1073748259 tok@var2628 .@expr5901 linkAt (@expr1073748261 2 ) ;
645:
646: if (@expr6048 !@expr6049 tok@var2628 ) {
647:
648: break ; }
649:
650: if (@expr1073748264 initcond@var2672 ) {
651:
652: return true ; }
653: }
654: }
655: }
656:
657:
658: else { if (@expr1073748265 Token ::@expr5890 simpleMatch (@expr1073748267 tok@var2628 , ") {" ) ||@expr1073748268 (@expr1073748269 Token ::@expr5860 Match (@expr1073748271 tok@var2628 , "%name% {" ) &&@expr1073748272 tok@var2628 .@expr5842 str (@expr5843 ) !=@expr1073748275 "try" ) ) {
659: if (@expr1073748276 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr1073748279 "struct" ||@expr1073748280 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr1073748283 "union" ) {
660: tok@var2628 =@expr1073748284 tok@var2628 .@expr5901 linkAt (@expr5902 1 ) ;
661: continue ;
662: }
663: return true ;
664: } } }
665:
666:
667: if (@expr1073748287 Token ::@expr5890 simpleMatch (@expr1073748289 tok@var2628 , "( {" ) ) {
668: return true ;
669: }
670:
671:
672: if (@expr1073748290 Token ::@expr5860 Match (@expr1073748292 tok@var2628 , "asm|setjmp (" ) ) {
673: return true ;
674: }
675:
676:
677: if (@expr1073748293 Token ::@expr5860 Match (@expr1073748295 tok@var2628 , "[;{}] %name% :" ) ) {
678: return true ;
679: }
680:
681: if (@expr6472 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr6475 "?" ) {
682: if (@expr6476 !@expr6477 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) ) {
683: return true ; }
684: const bool used1@var2674 =@expr1073748304 isVariableUsed (@expr6481 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) .@expr6484 astOperand1 (@expr6485 ) , var@var2629 ) ;
685: const bool used0@var2675 =@expr1073748310 isVariableUsed (@expr6487 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) .@expr6490 astOperand2 (@expr6491 ) , var@var2629 ) ;
686: const bool err@var2676 =@expr1073748316 (@expr1073748317 number_of_if@var2637 ==@expr5929 0 ) ?@expr1073748319 (@expr1073748320 used1@var2674 ||@expr1073748321 used0@var2675 ) :@expr1073748322 (@expr1073748323 used1@var2674 &&@expr1073748324 used0@var2675 ) ;
687: if (@expr1073748325 err@var2676 ) {
688: uninitvarError (@expr6502 tok@var2628 , var@var2629 .@expr6503 nameToken (@expr6504 ) .@expr6505 str (@expr6506 ) , *@expr5930 alloc@var2632 ) ; }
689:
690:
691: return true ;
692: }
693:
694: if (@expr1073748332 Token ::@expr5860 Match (@expr1073748334 tok@var2628 , "return|break|continue|throw|goto" ) ) {
695: if (@expr5852 noreturn@var2631 ) {
696: *@expr5853 noreturn@var2631 =@expr1073748337 true ; }
697:
698: tok@var2628 =@expr1073748338 tok@var2628 .@expr5839 next (@expr5840 ) ;
699: while (@expr1073748341 tok@var2628 &&@expr1073748342 tok@var2628 .@expr5842 str (@expr5843 ) !=@expr1073748345 ";" ) {
700:
701: if (@expr6522 tok@var2628 .@expr5884 varId (@expr5885 ) ==@expr6525 var@var2629 .@expr5834 declarationId (@expr5835 ) ) {
702: if (@expr5894 !@expr5895 membervar@var2633 .@expr5896 empty (@expr5897 ) ) {
703: if (@expr1073748356 !@expr6406 suppressErrors@var2635 &&@expr1073748358 Token ::@expr5860 Match (@expr1073748360 tok@var2628 , "%name% . %name%" ) &&@expr1073748361 tok@var2628 .@expr6538 strAt (@expr6539 2 ) ==@expr6540 membervar@var2633 &&@expr1073748365 Token ::@expr5860 Match (@expr1073748367 tok@var2628 .@expr5839 next (@expr5840 ) .@expr1073748370 astParent (@expr1073748371 ) , "%cop%|return|throw|?" ) ) {
704: uninitStructMemberError (@expr6548 tok@var2628 , tok@var2628 .@expr5842 str (@expr5843 ) +@expr6551 "." +@expr6552 membervar@var2633 ) ; }
705: else { if (@expr1073748377 mTokenizer@var28 .@expr6554 isCPP (@expr6555 ) &&@expr1073748380 !@expr6406 suppressErrors@var2635 &&@expr1073748382 Token ::@expr5860 Match (@expr1073748384 tok@var2628 , "%name%" ) &&@expr1073748385 Token ::@expr5860 Match (@expr1073748387 tok@var2628 .@expr1073748388 astParent (@expr1073748389 ) , "return|throw|?" ) ) {
706: uninitStructMemberError (@expr6548 tok@var2628 , tok@var2628 .@expr5842 str (@expr5843 ) +@expr6551 "." +@expr6552 membervar@var2633 ) ; } }
707: }
708:
709:
710: else { if (@expr6571 !@expr6406 suppressErrors@var2635 &&@expr6573 isVariableUsage (@expr6574 tok@var2628 , var@var2629 .@expr6281 isPointer (@expr6282 ) , *@expr5930 alloc@var2632 ) ) {
711: uninitvarError (@expr6578 tok@var2628 , tok@var2628 .@expr5842 str (@expr5843 ) , *@expr5930 alloc@var2632 ) ; } }
712:
713: return true ;
714: }
715:
716: else { if (@expr6358 isSizeOfEtc (@expr6359 tok@var2628 ) ) {
717: tok@var2628 =@expr1073748408 tok@var2628 .@expr5901 linkAt (@expr5902 1 ) ; }
718:
719: else { if (@expr6472 tok@var2628 .@expr5842 str (@expr5843 ) ==@expr6475 "?" ) {
720: if (@expr6476 !@expr6477 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) ) {
721: return true ; }
722: const bool used1@var2677 =@expr1073748419 isVariableUsed (@expr6481 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) .@expr6484 astOperand1 (@expr6485 ) , var@var2629 ) ;
723: const bool used0@var2678 =@expr1073748425 isVariableUsed (@expr6487 tok@var2628 .@expr6478 astOperand2 (@expr6479 ) .@expr6490 astOperand2 (@expr6491 ) , var@var2629 ) ;
724: const bool err@var2679 =@expr1073748431 (@expr1073748432 number_of_if@var2637 ==@expr5929 0 ) ?@expr1073748434 (@expr1073748435 used1@var2677 ||@expr1073748436 used0@var2678 ) :@expr1073748437 (@expr1073748438 used1@var2677 &&@expr1073748439 used0@var2678 ) ;
725: if (@expr1073748440 err@var2679 ) {
726: uninitvarError (@expr6502 tok@var2628 , var@var2629 .@expr6503 nameToken (@expr6504 ) .@expr6505 str (@expr6506 ) , *@expr5930 alloc@var2632 ) ; }
727: return true ;
728: } } }
729:
730: tok@var2628 =@expr1073748447 tok@var2628 .@expr5839 next (@expr5840 ) ;
731: }
732:
733: return (@expr6626 noreturn@var2631 ==@expr1073748451 nullptr ) ;
734: }
735:
736:
737: if (@expr6522 tok@var2628 .@expr5884 varId (@expr5885 ) ==@expr6525 var@var2629 .@expr5834 declarationId (@expr5835 ) ) {
738:
739: if (@expr1073748458 var@var2629 .@expr6281 isPointer (@expr6282 ) &&@expr1073748461 Token ::@expr5890 simpleMatch (@expr1073748463 tok@var2628 .@expr5839 next (@expr5840 ) , "=" ) ) {
740: const Token * rhs@var2680 ; rhs@var2680 =@expr1073748466 tok@var2628 .@expr5839 next (@expr5840 ) .@expr5918 astOperand2 (@expr5919 ) ;
741: while (@expr1073748471 rhs@var2680 &&@expr1073748472 rhs@var2680 .@expr1073748473 isCast (@expr1073748474 ) ) {
742: rhs@var2680 =@expr1073748475 rhs@var2680 .@expr6652 astOperand2 (@expr6653 ) ?@expr1073748478 rhs@var2680 .@expr6652 astOperand2 (@expr6653 ) :@expr1073748481 rhs@var2680 .@expr6658 astOperand1 (@expr6659 ) ; }
743: if (@expr1073748484 rhs@var2680 &&@expr1073748485 Token ::@expr5860 Match (@expr1073748487 rhs@var2680 .@expr1073748488 previous (@expr1073748489 ) , "%name% (" ) ) {
744: const Library ::@expr1073748490 AllocFunc * allocFunc@var2681 ; allocFunc@var2681 =@expr1073748491 mSettings@var29 .@expr1073748492 library@var2925 .@expr1073748493 getAllocFuncInfo (@expr1073748494 rhs@var2680 .@expr6658 astOperand1 (@expr6659 ) ) ;
745: if (@expr1073748497 allocFunc@var2681 &&@expr1073748498 !@expr1073748499 allocFunc@var2681 .@expr1073748500 initData@var2682 ) {
746: *@expr5930 alloc@var2632 =@expr1073748502 NO_CTOR_CALL ;
747: continue ;
748: }
749: }
750: }
751: if (@expr1073748503 mTokenizer@var28 .@expr6554 isCPP (@expr6555 ) &&@expr1073748506 var@var2629 .@expr6281 isPointer (@expr6282 ) &&@expr1073748509 (@expr6626 var@var2629 .@expr6687 typeStartToken (@expr6688 ) .@expr6689 isStandardType (@expr6690 ) ||@expr6691 var@var2629 .@expr6687 typeStartToken (@expr6688 ) .@expr6694 isEnumType (@expr6695 ) ||@expr1073748520 (@expr6626 var@var2629 .@expr6698 type (@expr6699 ) &&@expr1073748524 var@var2629 .@expr6698 type (@expr6699 ) .@expr1073748527 needInitialization@var2937 ==@expr1073748528 Type ::@expr1073748529 NeedInitialization ::@expr1073748530 True ) ) &&@expr1073748531 Token ::@expr5890 simpleMatch (@expr1073748533 tok@var2628 .@expr5839 next (@expr5840 ) , "= new" ) ) {
752: *@expr5930 alloc@var2632 =@expr1073748537 CTOR_CALL ;
753:
754:
755: if (@expr1073748538 var@var2629 .@expr6715 typeScope (@expr6716 ) &&@expr1073748541 var@var2629 .@expr6715 typeScope (@expr6716 ) .@expr1073748544 numConstructors@var2939 >@expr1073748545 0 ) {
756: return true ; }
757:
758:
759: if (@expr1073748546 var@var2629 .@expr6687 typeStartToken (@expr6688 ) .@expr6689 isStandardType (@expr6690 ) ||@expr6691 var@var2629 .@expr6687 typeStartToken (@expr6688 ) .@expr6694 isEnumType (@expr6695 ) ) {
760:
761: if (@expr1073748556 Token ::@expr5860 Match (@expr1073748558 tok@var2628 .@expr5839 next (@expr5840 ) , "= new %type% (" ) ) {
762: return true ; }
763:
764:
765: if (@expr1073748561 Token ::@expr5860 Match (@expr1073748563 tok@var2628 .@expr5839 next (@expr5840 ) , "= new %type% [" ) &&@expr1073748566 Token ::@expr5890 simpleMatch (@expr1073748568 tok@var2628 .@expr5901 linkAt (@expr1073748570 4 ) , "] (" ) ) {
766: return true ; }
767: }
768:
769: continue ;
770: }
771:
772:
773: if (@expr5894 !@expr5895 membervar@var2633 .@expr5896 empty (@expr5897 ) ) {
774: if (@expr1073748575 isMemberVariableAssignment (@expr1073748576 tok@var2628 , membervar@var2633 ) ) {
775: checkRhs (@expr1073748577 tok@var2628 , var@var2629 , *@expr5930 alloc@var2632 , number_of_if@var2637 , membervar@var2633 ) ;
776: return true ;
777: }
778:
779: if (@expr1073748579 isMemberVariableUsage (@expr1073748580 tok@var2628 , var@var2629 .@expr6281 isPointer (@expr6282 ) , *@expr5930 alloc@var2632 , membervar@var2633 ) ) {
780: uninitStructMemberError (@expr6548 tok@var2628 , tok@var2628 .@expr5842 str (@expr5843 ) +@expr6551 "." +@expr6552 membervar@var2633 ) ;
781: return true ;
782: }
783:
784: if (@expr1073748589 Token ::@expr5860 Match (@expr1073748591 tok@var2628 .@expr5862 previous (@expr5863 ) , "[(,] %name% [,)]" ) ) {
785: return true ; }
786:
787: if (@expr1073748594 Token ::@expr5860 Match (@expr1073748596 tok@var2628 .@expr5862 previous (@expr5863 ) , "= %var% . %var% ;" ) &&@expr1073748599 membervar@var2633 ==@expr6540 tok@var2628 .@expr6538 strAt (@expr6539 2 ) ) {
788: return true ; }
789:
790: } else {
791:
792: if (@expr6571 !@expr6406 suppressErrors@var2635 &&@expr6573 isVariableUsage (@expr6574 tok@var2628 , var@var2629 .@expr6281 isPointer (@expr6282 ) , *@expr5930 alloc@var2632 ) ) {
793: uninitvarError (@expr6578 tok@var2628 , tok@var2628 .@expr5842 str (@expr5843 ) , *@expr5930 alloc@var2632 ) ;
794: return true ;
795: }
796:
797: else {
798: const Token * parent@var2683 ; parent@var2683 =@expr1073748614 tok@var2628 ;
799: while (@expr1073748615 parent@var2683 .@expr6792 astParent (@expr6793 ) &&@expr1073748618 (@expr6626 (@expr6626 astIsLHS (@expr6797 parent@var2683 ) &&@expr1073748622 parent@var2683 .@expr6792 astParent (@expr6793 ) .@expr1073748625 str (@expr1073748626 ) ==@expr1073748627 "[" ) ||@expr1073748628 parent@var2683 .@expr6792 astParent (@expr6793 ) .@expr1073748631 isUnaryOp (@expr1073748632 "*" ) ) ) {
800: parent@var2683 =@expr1073748633 parent@var2683 .@expr6792 astParent (@expr6793 ) ;
801: if (@expr1073748636 parent@var2683 .@expr1073748637 str (@expr1073748638 ) ==@expr1073748639 "[" ) {
802: if (@expr1073748640 const Token *@expr5899 errorToken@var2684 =@expr1073748642 checkExpr (@expr1073748643 parent@var2683 .@expr1073748644 astOperand2 (@expr1073748645 ) , var@var2629 , *@expr5930 alloc@var2632 , number_of_if@var2637 ==@expr5929 0 ) ) {
803: if (@expr6405 !@expr6406 suppressErrors@var2635 ) {
804: uninitvarError (@expr1073748650 errorToken@var2684 , errorToken@var2684 .@expr1073748651 expressionString (@expr1073748652 ) , *@expr5930 alloc@var2632 ) ; }
805: return true ;
806: }
807: }
808: }
809: if (@expr1073748654 Token ::@expr5890 simpleMatch (@expr1073748656 parent@var2683 .@expr6792 astParent (@expr6793 ) , "=" ) &&@expr1073748659 astIsLHS (@expr6797 parent@var2683 ) ) {
810: const Token * eq@var2685 ; eq@var2685 =@expr1073748661 parent@var2683 .@expr6792 astParent (@expr6793 ) ;
811: if (@expr1073748664 const Token *@expr5899 errorToken@var2686 =@expr1073748666 checkExpr (@expr1073748667 eq@var2685 .@expr1073748668 astOperand2 (@expr1073748669 ) , var@var2629 , *@expr5930 alloc@var2632 , number_of_if@var2637 ==@expr5929 0 ) ) {
812: if (@expr6405 !@expr6406 suppressErrors@var2635 ) {
813: uninitvarError (@expr1073748674 errorToken@var2686 , errorToken@var2686 .@expr1073748675 expressionString (@expr1073748676 ) , *@expr5930 alloc@var2632 ) ; }
814: return true ;
815: }
816: }
817:
818:
819: return true ;
820: }
821: }
822: }
823: }
824:
825: return false ;
826: }
827:
828: const Token * CheckUninitVar :: checkExpr ( const Token * tok@var2687 , const Variable & var@var2688 , const Alloc alloc@var2689 , bool known@var2690 , bool * bailout@var2691 )
829: {
830: if (@expr1073748678 !@expr1073748679 tok@var2687 ) {
831: return nullptr ; }
832: if (@expr1073748680 isSizeOfEtc (@expr1073748681 tok@var2687 .@expr1073748682 previous (@expr1073748683 ) ) ) {
833: return nullptr ; }
834:
835: if (@expr1073748684 tok@var2687 .@expr6861 astOperand1 (@expr6862 ) ) {
836: bool bailout1@var2692 ; bailout1@var2692 =@expr1073748687 false ;
837: const Token * errorToken@var2693 ; errorToken@var2693 =@expr1073748688 checkExpr (@expr1073748689 tok@var2687 .@expr6861 astOperand1 (@expr6862 ) , var@var2688 , alloc@var2689 , known@var2690 , &@expr1073748692 bailout1@var2692 ) ;
838: if (@expr1073748693 bailout@var2691 &&@expr1073748694 bailout1@var2692 ) {
839: *@expr6871 bailout@var2691 =@expr1073748696 true ; }
840: if (@expr1073748697 errorToken@var2693 ) {
841: return errorToken@var2693 ; }
842: if (@expr1073748698 (@expr1073748699 bailout1@var2692 ||@expr1073748700 !@expr1073748701 known@var2690 ) &&@expr1073748702 Token ::@expr1073748703 Match (@expr1073748704 tok@var2687 , "%oror%|&&|?" ) ) {
843: return nullptr ; }
844: }
845: if (@expr1073748705 tok@var2687 .@expr6882 astOperand2 (@expr6883 ) ) {
846: return checkExpr (@expr1073748708 tok@var2687 .@expr6882 astOperand2 (@expr6883 ) , var@var2688 , alloc@var2689 , known@var2690 , bailout@var2691 ) ; }
847: if (@expr1073748711 tok@var2687 .@expr1073748712 varId (@expr1073748713 ) ==@expr1073748714 var@var2688 .@expr1073748715 declarationId (@expr1073748716 ) ) {
848: const Token * errorToken@var2694 ; errorToken@var2694 =@expr1073748717 isVariableUsage (@expr1073748718 tok@var2687 , var@var2688 .@expr1073748719 isPointer (@expr1073748720 ) , alloc@var2689 ) ;
849: if (@expr1073748721 errorToken@var2694 ) {
850: return errorToken@var2694 ; }
851: else { if (@expr1073748722 bailout@var2691 ) {
852: *@expr6871 bailout@var2691 =@expr1073748724 true ; } }
853: }
854: return nullptr ;
855: }
856:
857: bool CheckUninitVar :: checkIfForWhileHead ( const Token * startparentheses@var2695 , const Variable & var@var2696 , bool suppressErrors@var2697 , bool isuninit@var2698 , Alloc alloc@var2699 , const std :: string & membervar@var2700 )
858: {
859: const Token * const endpar@var2701 ; endpar@var2701 =@expr1073748725 startparentheses@var2695 .@expr1073748726 link (@expr1073748727 ) ;
860: if (@expr1073748728 Token ::@expr6905 Match (@expr1073748730 startparentheses@var2695 , "( ! %name% %oror%" ) &&@expr1073748731 startparentheses@var2695 .@expr1073748732 tokAt (@expr1073748733 2 ) .@expr1073748734 getValue (@expr1073748735 0 ) ) {
861: suppressErrors@var2697 =@expr1073748736 true ; }
862: for (@expr1073748737 const Token *@expr6914 tok@var2702 =@expr1073748739 startparentheses@var2695 .@expr1073748740 next (@expr1073748741 ) ; tok@var2702 &&@expr1073748742 tok@var2702 !=@expr1073748743 endpar@var2701 ; tok@var2702 =@expr1073748744 tok@var2702 .@expr1073748745 next (@expr1073748746 ) ) {
863: if (@expr1073748747 tok@var2702 .@expr1073748748 varId (@expr1073748749 ) ==@expr1073748750 var@var2696 .@expr1073748751 declarationId (@expr1073748752 ) ) {
864: if (@expr1073748753 Token ::@expr6905 Match (@expr1073748755 tok@var2702 , "%name% . %name%" ) ) {
865: if (@expr1073748756 membervar@var2700 .@expr6933 empty (@expr6934 ) ) {
866: return true ; }
867: if (@expr1073748759 tok@var2702 .@expr1073748760 strAt (@expr1073748761 2 ) ==@expr1073748762 membervar@var2700 ) {
868: if (@expr1073748763 isMemberVariableAssignment (@expr1073748764 tok@var2702 , membervar@var2700 ) ) {
869: return true ; }
870:
871: if (@expr1073748765 !@expr1073748766 suppressErrors@var2697 &&@expr1073748767 isMemberVariableUsage (@expr1073748768 tok@var2702 , var@var2696 .@expr6945 isPointer (@expr6946 ) , alloc@var2699 , membervar@var2700 ) ) {
872: uninitStructMemberError (@expr1073748771 tok@var2702 , tok@var2702 .@expr6948 str (@expr6949 ) +@expr1073748774 "." +@expr1073748775 membervar@var2700 ) ; }
873: }
874: continue ;
875: }
876:
877: if (@expr1073748776 const Token *@expr6914 errorToken@var2703 =@expr1073748778 isVariableUsage (@expr1073748779 tok@var2702 , var@var2696 .@expr6945 isPointer (@expr6946 ) , alloc@var2699 ) ) {
878: if (@expr1073748782 suppressErrors@var2697 ) {
879: continue ; }
880: uninitvarError (@expr1073748783 errorToken@var2703 , errorToken@var2703 .@expr1073748784 expressionString (@expr1073748785 ) , alloc@var2699 ) ;
881: }
882: return true ;
883: }
884:
885: if (@expr1073748786 isSizeOfEtc (@expr1073748787 tok@var2702 ) ) {
886: tok@var2702 =@expr1073748788 tok@var2702 .@expr1073748789 linkAt (@expr1073748790 1 ) ; }
887: if (@expr1073748791 (@expr1073748792 !@expr1073748793 isuninit@var2698 ||@expr1073748794 !@expr1073748795 membervar@var2700 .@expr6933 empty (@expr6934 ) ) &&@expr1073748798 tok@var2702 .@expr6948 str (@expr6949 ) ==@expr1073748801 "&&" ) {
888: suppressErrors@var2697 =@expr1073748802 true ; }
889: }
890: return false ;
891: }
892:
893:
894: const Token * CheckUninitVar :: checkLoopBodyRecursive ( const Token * start@var2704 , const Variable & var@var2705 , const Alloc alloc@var2706 , const std :: string & membervar@var2707 , bool & bailout@var2708 ) const
895: {
896: assert (@expr1073748803 start@var2704 .@expr1073748804 str (@expr1073748805 ) ==@expr1073748806 "{" ) ;
897:
898: const Token * errorToken@var2709 ; errorToken@var2709 =@expr1073748807 nullptr ;
899:
900: const Token * const end@var2710 ; end@var2710 =@expr1073748808 start@var2704 .@expr1073748809 link (@expr1073748810 ) ;
901: for (@expr1073748811 const Token *@expr6988 tok@var2711 =@expr1073748813 start@var2704 .@expr1073748814 next (@expr1073748815 ) ; tok@var2711 !=@expr1073748816 end@var2710 ; tok@var2711 =@expr1073748817 tok@var2711 .@expr6994 next (@expr6995 ) ) {
902:
903: if (@expr1073748820 isSizeOfEtc (@expr1073748821 tok@var2711 ) ) {
904: tok@var2711 =@expr1073748822 tok@var2711 .@expr6999 linkAt (@expr7000 1 ) ;
905: continue ;
906: }
907:
908: if (@expr1073748825 Token ::@expr7002 Match (@expr1073748827 tok@var2711 , "asm ( %str% ) ;" ) ) {
909: bailout@var2708 =@expr1073748828 true ;
910: return nullptr ;
911: }
912:
913:
914: if (@expr1073748829 tok@var2711 .@expr7006 str (@expr7007 ) ==@expr1073748832 ";" &&@expr1073748833 Token ::@expr7010 simpleMatch (@expr1073748835 tok@var2711 .@expr7012 astParent (@expr7013 ) , ";" ) &&@expr1073748838 Token ::@expr7010 simpleMatch (@expr1073748840 tok@var2711 .@expr7012 astParent (@expr7013 ) .@expr7019 astParent (@expr7020 ) , "(" ) ) {
915: const Token * top@var2712 ; top@var2712 =@expr1073748845 tok@var2711 .@expr7012 astParent (@expr7013 ) .@expr7019 astParent (@expr7020 ) ;
916: if (@expr1073748850 !@expr1073748851 Token ::@expr7010 simpleMatch (@expr1073748853 top@var2712 .@expr1073748854 previous (@expr1073748855 ) , "for (" ) ||@expr1073748856 !@expr1073748857 Token ::@expr7010 simpleMatch (@expr1073748859 top@var2712 .@expr7036 link (@expr7037 ) , ") {" ) ) {
917: continue ; }
918: const Token * bodyStart@var2713 ; bodyStart@var2713 =@expr1073748862 top@var2712 .@expr7036 link (@expr7037 ) .@expr1073748865 next (@expr1073748866 ) ;
919: const Token * errorToken1@var2714 ; errorToken1@var2714 =@expr1073748867 checkLoopBodyRecursive (@expr1073748868 bodyStart@var2713 , var@var2705 , alloc@var2706 , membervar@var2707 , bailout@var2708 ) ;
920: if (@expr7045 !@expr7046 errorToken@var2709 ) {
921: errorToken@var2709 =@expr1073748871 errorToken1@var2714 ; }
922: if (@expr7048 bailout@var2708 ) {
923: return nullptr ; }
924: }
925:
926: if (@expr1073748873 Token ::@expr7010 simpleMatch (@expr1073748875 tok@var2711 , ") {" ) &&@expr1073748876
927: Token ::@expr7010 simpleMatch (@expr1073748878 tok@var2711 .@expr7055 link (@expr7056 ) .@expr1073748881 previous (@expr1073748882 ) , "for (" ) &&@expr1073748883
928: Token ::@expr7010 simpleMatch (@expr1073748885 tok@var2711 .@expr7055 link (@expr7056 ) .@expr7064 astOperand2 (@expr7065 ) , ";" ) &&@expr1073748890
929: Token ::@expr7010 simpleMatch (@expr1073748892 tok@var2711 .@expr7055 link (@expr7056 ) .@expr7064 astOperand2 (@expr7065 ) .@expr1073748897 astOperand2 (@expr1073748898 ) , ";" ) ) {
930: tok@var2711 =@expr1073748899 tok@var2711 .@expr6999 linkAt (@expr7000 1 ) ;
931: }
932:
933: if (@expr1073748902 tok@var2711 .@expr7006 str (@expr7007 ) ==@expr1073748905 "{" ) {
934:
935: if (@expr1073748906 tok@var2711 .@expr7083 scope (@expr7084 ) &&@expr1073748909 tok@var2711 .@expr7083 scope (@expr7084 ) .@expr1073748912 type@var2940 ==@expr1073748913 Scope ::@expr1073748914 ScopeType ::@expr1073748915 eSwitch ) {
936: bailout@var2708 =@expr1073748916 true ;
937: return nullptr ;
938: }
939:
940: const Token * errorToken1@var2715 ; errorToken1@var2715 =@expr1073748917 checkLoopBodyRecursive (@expr1073748918 tok@var2711 , var@var2705 , alloc@var2706 , membervar@var2707 , bailout@var2708 ) ;
941: tok@var2711 =@expr1073748919 tok@var2711 .@expr7055 link (@expr7056 ) ;
942: if (@expr1073748922 Token ::@expr7010 simpleMatch (@expr1073748924 tok@var2711 , "} else {" ) ) {
943: const Token * elseBody@var2716 ; elseBody@var2716 =@expr1073748925 tok@var2711 .@expr1073748926 tokAt (@expr1073748927 2 ) ;
944: const Token * errorToken2@var2717 ; errorToken2@var2717 =@expr1073748928 checkLoopBodyRecursive (@expr1073748929 elseBody@var2716 , var@var2705 , alloc@var2706 , membervar@var2707 , bailout@var2708 ) ;
945: tok@var2711 =@expr1073748930 elseBody@var2716 .@expr1073748931 link (@expr1073748932 ) ;
946: if (@expr1073748933 errorToken1@var2715 &&@expr1073748934 errorToken2@var2717 ) {
947: return errorToken1@var2715 ; }
948: if (@expr1073748935 errorToken2@var2717 ) {
949: errorToken@var2709 =@expr1073748936 errorToken2@var2717 ; }
950: }
951: if (@expr7048 bailout@var2708 ) {
952: return nullptr ; }
953: if (@expr7045 !@expr7046 errorToken@var2709 ) {
954: errorToken@var2709 =@expr1073748940 errorToken1@var2715 ; }
955: }
956:
957: if (@expr1073748941 tok@var2711 .@expr1073748942 varId (@expr1073748943 ) !=@expr1073748944 var@var2705 .@expr7121 declarationId (@expr7122 ) ) {
958: continue ; }
959:
960: bool conditionalUsage@var2718 ; conditionalUsage@var2718 =@expr1073748947 false ;
961: for (@expr1073748948 const Token *@expr6988 parent@var2719 =@expr1073748950 tok@var2711 ; parent@var2719 ; parent@var2719 =@expr1073748951 parent@var2719 .@expr7128 astParent (@expr7129 ) ) {
962: if (@expr1073748954 Token ::@expr7002 Match (@expr1073748956 parent@var2719 .@expr7128 astParent (@expr7129 ) , "%oror%|&&|?" ) &&@expr1073748959 astIsRHS (@expr1073748960 parent@var2719 ) ) {
963: conditionalUsage@var2718 =@expr1073748961 true ;
964: break ;
965: }
966: }
967:
968: if (@expr1073748962 !@expr1073748963 membervar@var2707 .@expr1073748964 empty (@expr1073748965 ) ) {
969: if (@expr1073748966 isMemberVariableAssignment (@expr1073748967 tok@var2711 , membervar@var2707 ) ) {
970: bool assign@var2720 ; assign@var2720 =@expr1073748968 true ;
971: bool rhs@var2721 ; rhs@var2721 =@expr1073748969 false ;
972:
973: const Token * rpar@var2722 ; rpar@var2722 =@expr1073748970 nullptr ;
974: for (@expr1073748971 const Token *@expr6988 tok2@var2723 =@expr1073748973 tok@var2711 .@expr6994 next (@expr6995 ) ; tok2@var2723 ; tok2@var2723 =@expr1073748976 tok2@var2723 .@expr1073748977 next (@expr1073748978 ) ) {
975: if (@expr1073748979 tok2@var2723 .@expr7156 str (@expr7157 ) ==@expr1073748982 "=" ) {
976: rhs@var2721 =@expr1073748983 true ; }
977:
978:
979: if (@expr1073748984 !@expr7161 rpar@var2722 &&@expr1073748986 tok2@var2723 .@expr7156 str (@expr7157 ) ==@expr1073748989 "(" ) {
980: rpar@var2722 =@expr1073748990 tok2@var2723 .@expr1073748991 link (@expr1073748992 ) ; }
981: else { if (@expr1073748993 tok2@var2723 .@expr7156 str (@expr7157 ) ==@expr1073748996 ")" ) {
982:
983: if (@expr1073748997 !@expr7161 rpar@var2722 ) {
984: break ; }
985: if (@expr1073748999 rpar@var2722 ==@expr1073749000 tok2@var2723 ) {
986: rpar@var2722 =@expr1073749001 nullptr ; }
987: } }
988:
989: if (@expr1073749002 tok2@var2723 .@expr7156 str (@expr7157 ) ==@expr1073749005 ";" ||@expr1073749006 (@expr1073749007 !@expr7161 rpar@var2722 &&@expr1073749009 tok2@var2723 .@expr7156 str (@expr7157 ) ==@expr1073749012 "," ) ) {
990: break ; }
991: if (@expr1073749013 rhs@var2721 &&@expr1073749014 tok2@var2723 .@expr1073749015 varId (@expr1073749016 ) ==@expr1073749017 var@var2705 .@expr7121 declarationId (@expr7122 ) &&@expr1073749020 isMemberVariableUsage (@expr1073749021 tok2@var2723 , var@var2705 .@expr7198 isPointer (@expr7199 ) , alloc@var2706 , membervar@var2707 ) ) {
992: assign@var2720 =@expr1073749024 false ;
993: break ;
994: }
995: }
996: if (@expr1073749025 assign@var2720 ) {
997: bailout@var2708 =@expr1073749026 true ;
998: return nullptr ;
999: }
1000: }
1001: if (@expr1073749027 isMemberVariableUsage (@expr1073749028 tok@var2711 , var@var2705 .@expr7198 isPointer (@expr7199 ) , alloc@var2706 , membervar@var2707 ) ) {
1002: if (@expr7207 !@expr7208 conditionalUsage@var2718 ) {
1003: return tok@var2711 ; }
1004: if (@expr7045 !@expr7046 errorToken@var2709 ) {
1005: errorToken@var2709 =@expr1073749035 tok@var2711 ; }
1006: } else { if (@expr1073749036 Token ::@expr7002 Match (@expr1073749038 tok@var2711 .@expr1073749039 previous (@expr1073749040 ) , "[(,] %name% [,)]" ) ) {
1007: bailout@var2708 =@expr1073749041 true ;
1008: return nullptr ;
1009: } }
1010: } else {
1011: if (@expr1073749042 const Token *@expr6988 errtok@var2724 =@expr1073749044 isVariableUsage (@expr1073749045 tok@var2711 , var@var2705 .@expr7198 isPointer (@expr7199 ) , alloc@var2706 ) ) {
1012: if (@expr7207 !@expr7208 conditionalUsage@var2718 ) {
1013: return errtok@var2724 ; }
1014: if (@expr7045 !@expr7046 errorToken@var2709 ) {
1015: errorToken@var2709 =@expr1073749052 errtok@var2724 ; }
1016: } else { if (@expr1073749053 tok@var2711 .@expr1073749054 strAt (@expr1073749055 1 ) ==@expr1073749056 "=" ) {
1017: bool varIsUsedInRhs@var2725 ; varIsUsedInRhs@var2725 =@expr1073749057 false ;
1018: visitAstNodes (@expr1073749058 tok@var2711 .@expr6994 next (@expr6995 ) .@expr1073749061 astOperand2 (@expr1073749062 ) , [@expr1073749063 &@expr1073749064 ] (@expr1073749065 const Token *@expr6988 t@var2726 ) {
1019: if (@expr1073749067 !@expr1073749068 t@var2726 ) {
1020: return ChildrenToVisit ::@expr7245 none ; }
1021: if (@expr1073749070 t@var2726 .@expr1073749071 varId (@expr1073749072 ) ==@expr1073749073 var@var2705 .@expr7121 declarationId (@expr7122 ) ) {
1022: varIsUsedInRhs@var2725 =@expr1073749076 true ;
1023: return ChildrenToVisit ::@expr1073749077 done ;
1024: }
1025: if (@expr1073749078 isSizeOfEtc (@expr1073749079 t@var2726 .@expr1073749080 previous (@expr1073749081 ) ) ) {
1026: return ChildrenToVisit ::@expr7245 none ; }
1027: return ChildrenToVisit ::@expr1073749083 op1_and_op2 ;
1028: } ) ;
1029: if (@expr1073749084 !@expr1073749085 varIsUsedInRhs@var2725 ) {
1030: bailout@var2708 =@expr1073749086 true ;
1031: return nullptr ;
1032: }
1033: } else {
1034: bailout@var2708 =@expr1073749087 true ;
1035: return nullptr ;
1036: } }
1037: }
1038: }
1039:
1040: return errorToken@var2709 ;
1041: }
1042:
1043: bool CheckUninitVar :: checkLoopBody ( const Token * tok@var2727 , const Variable & var@var2728 , const Alloc alloc@var2729 , const std :: string & membervar@var2730 , const bool suppressErrors@var2731 )
1044: {
1045: bool bailout@var2732 ; bailout@var2732 =@expr1073749088 false ;
1046: const Token * errorToken@var2733 ; errorToken@var2733 =@expr1073749089 checkLoopBodyRecursive (@expr1073749090 tok@var2727 , var@var2728 , alloc@var2729 , membervar@var2730 , bailout@var2732 ) ;
1047:
1048: if (@expr1073749091 !@expr1073749092 suppressErrors@var2731 &&@expr1073749093 !@expr1073749094 bailout@var2732 &&@expr1073749095 errorToken@var2733 ) {
1049: if (@expr1073749096 membervar@var2730 .@expr1073749097 empty (@expr1073749098 ) ) {
1050: uninitvarError (@expr1073749099 errorToken@var2733 , errorToken@var2733 .@expr7276 expressionString (@expr7277 ) , alloc@var2729 ) ; }
1051: else {
1052: uninitStructMemberError (@expr1073749102 errorToken@var2733 , errorToken@var2733 .@expr7276 expressionString (@expr7277 ) +@expr1073749105 "." +@expr1073749106 membervar@var2730 ) ; }
1053: return true ;
1054: }
1055:
1056: return bailout@var2732 ;
1057: }
1058:
1059: void CheckUninitVar :: checkRhs ( const Token * tok@var2734 , const Variable & var@var2735 , Alloc alloc@var2736 , int number_of_if@var2737 , const std :: string & membervar@var2738 )
1060: {
1061: bool rhs@var2739 ; rhs@var2739 =@expr1073749107 false ;
1062: int indent@var2740 ; indent@var2740 =@expr1073749108 0 ;
1063: while (@expr1073749109 nullptr !=@expr1073749110 (@expr1073749111 tok@var2734 =@expr1073749112 tok@var2734 .@expr1073749113 next (@expr1073749114 ) ) ) {
1064: if (@expr1073749115 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749118 "=" ) {
1065: rhs@var2739 =@expr1073749119 true ; }
1066: else { if (@expr1073749120 rhs@var2739 &&@expr1073749121 tok@var2734 .@expr1073749122 varId (@expr1073749123 ) ==@expr1073749124 var@var2735 .@expr1073749125 declarationId (@expr1073749126 ) ) {
1067: if (@expr1073749127 membervar@var2738 .@expr7304 empty (@expr7305 ) &&@expr1073749130 isVariableUsage (@expr1073749131 tok@var2734 , var@var2735 .@expr7308 isPointer (@expr7309 ) , alloc@var2736 ) ) {
1068: uninitvarError (@expr1073749134 tok@var2734 , tok@var2734 .@expr7292 str (@expr7293 ) , alloc@var2736 ) ; }
1069: else { if (@expr1073749137 !@expr1073749138 membervar@var2738 .@expr7304 empty (@expr7305 ) &&@expr1073749141 isMemberVariableUsage (@expr1073749142 tok@var2734 , var@var2735 .@expr7308 isPointer (@expr7309 ) , alloc@var2736 , membervar@var2738 ) ) {
1070: uninitStructMemberError (@expr1073749145 tok@var2734 , tok@var2734 .@expr7292 str (@expr7293 ) +@expr1073749148 "." +@expr1073749149 membervar@var2738 ) ; }
1071: else { if (@expr1073749150 Token ::@expr7327 Match (@expr1073749152 tok@var2734 , "%var% =" ) ) {
1072: break ; }
1073: else { if (@expr1073749153 Token ::@expr7327 Match (@expr1073749155 tok@var2734 .@expr1073749156 previous (@expr1073749157 ) , "[(,&]" ) ) {
1074: break ; } } } }
1075: } else { if (@expr1073749158 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749161 ";" ||@expr1073749162 (@expr1073749163 indent@var2740 ==@expr7340 0 &&@expr1073749165 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749168 "," ) ) {
1076: break ; }
1077: else { if (@expr1073749169 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749172 "(" ) {
1078: ++@expr1073749173 indent@var2740 ; }
1079: else { if (@expr1073749174 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749177 ")" ) {
1080: if (@expr1073749178 indent@var2740 ==@expr7340 0 ) {
1081: break ; }
1082: --@expr1073749180 indent@var2740 ;
1083: } else { if (@expr1073749181 tok@var2734 .@expr7292 str (@expr7293 ) ==@expr1073749184 "?" &&@expr1073749185 tok@var2734 .@expr7362 astOperand2 (@expr7363 ) ) {
1084: const bool used1@var2741 =@expr1073749188 isVariableUsed (@expr1073749189 tok@var2734 .@expr7362 astOperand2 (@expr7363 ) .@expr1073749192 astOperand1 (@expr1073749193 ) , var@var2735 ) ;
1085: const bool used0@var2742 =@expr1073749194 isVariableUsed (@expr1073749195 tok@var2734 .@expr7362 astOperand2 (@expr7363 ) .@expr1073749198 astOperand2 (@expr1073749199 ) , var@var2735 ) ;
1086: const bool err@var2743 =@expr1073749200 (@expr1073749201 number_of_if@var2737 ==@expr1073749202 0 ) ?@expr1073749203 (@expr1073749204 used1@var2741 ||@expr1073749205 used0@var2742 ) :@expr1073749206 (@expr1073749207 used1@var2741 &&@expr1073749208 used0@var2742 ) ;
1087: if (@expr1073749209 err@var2743 ) {
1088: uninitvarError (@expr1073749210 tok@var2734 , var@var2735 .@expr1073749211 nameToken (@expr1073749212 ) .@expr1073749213 str (@expr1073749214 ) , alloc@var2736 ) ; }
1089: break ;
1090: } else { if (@expr1073749215 isSizeOfEtc (@expr1073749216 tok@var2734 ) ) {
1091: tok@var2734 =@expr1073749217 tok@var2734 .@expr1073749218 linkAt (@expr1073749219 1 ) ; } } } } } } }
1092:
1093: }
1094: }
1095:
1096: static bool astIsLhs ( const Token * tok@var2744 )
1097: {
1098: return tok@var2744 &&@expr1073749220 tok@var2744 .@expr7397 astParent (@expr7398 ) &&@expr1073749223 tok@var2744 ==@expr1073749224 tok@var2744 .@expr7397 astParent (@expr7398 ) .@expr1073749227 astOperand1 (@expr1073749228 ) ;
1099: }
1100:
1101: static bool astIsRhs ( const Token * tok@var2745 )
1102: {
1103: return tok@var2745 &&@expr1073749229 tok@var2745 .@expr7406 astParent (@expr7407 ) &&@expr1073749232 tok@var2745 ==@expr1073749233 tok@var2745 .@expr7406 astParent (@expr7407 ) .@expr1073749236 astOperand2 (@expr1073749237 ) ;
1104: }
1105:
1106: static bool isVoidCast ( const Token * tok@var2746 )
1107: {
1108: return Token ::@expr1073749238 simpleMatch (@expr1073749239 tok@var2746 , "(" ) &&@expr1073749240 tok@var2746 .@expr1073749241 isCast (@expr1073749242 ) &&@expr1073749243 tok@var2746 .@expr7420 valueType (@expr7421 ) &&@expr1073749246 tok@var2746 .@expr7420 valueType (@expr7421 ) .@expr1073749249 type@var2941 ==@expr1073749250 ValueType ::@expr1073749251 Type ::@expr1073749252 VOID &&@expr1073749253 tok@var2746 .@expr7420 valueType (@expr7421 ) .@expr1073749256 pointer@var2942 ==@expr1073749257 0 ;
1109: }
1110:
1111: const Token * CheckUninitVar :: isVariableUsage ( bool cpp@var2747 , const Token * vartok@var2748 , const Library & library@var2749 , bool pointer@var2750 , Alloc alloc@var2751 , int indirect@var2752 )
1112: {
1113: const Token * valueExpr@var2753 ; valueExpr@var2753 =@expr1073749258 vartok@var2748 ;
1114: while (@expr1073749259 Token ::@expr7436 Match (@expr1073749261 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , ".|::" ) &&@expr1073749264 astIsRhs (@expr7441 valueExpr@var2753 ) ) {
1115: valueExpr@var2753 =@expr1073749266 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ; }
1116:
1117: while (@expr1073749269 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ) {
1118:
1119: if (@expr1073749272 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7451 isUnaryOp (@expr7452 "&" ) &&@expr1073749277 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7456 astParent (@expr7457 ) &&@expr1073749282 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7456 astParent (@expr7457 ) .@expr1073749287 isUnaryOp (@expr1073749288 "*" ) ) {
1120: valueExpr@var2753 =@expr1073749289 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7456 astParent (@expr7457 ) ; }
1121:
1122: else { if (@expr1073749294 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749297 isCast (@expr1073749298 ) &&@expr1073749299 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7451 isUnaryOp (@expr1073749303 "(" ) &&@expr1073749304 Token ::@expr7481 simpleMatch (@expr1073749306 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749309 link (@expr1073749310 ) .@expr1073749311 previous (@expr1073749312 ) , "& )" ) ) {
1123: valueExpr@var2753 =@expr1073749313 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ; }
1124: else {
1125: break ; } }
1126: }
1127: if (@expr1073749316 !@expr1073749317 pointer@var2750 ) {
1128: if (@expr1073749318 Token ::@expr7436 Match (@expr1073749320 vartok@var2748 , "%name% [.(]" ) &&@expr1073749321 vartok@var2748 .@expr7498 variable (@expr7499 ) &&@expr1073749324 !@expr1073749325 vartok@var2748 .@expr7498 variable (@expr7499 ) .@expr1073749328 isPointer (@expr1073749329 ) ) {
1129: return nullptr ; }
1130: while (@expr1073749330 Token ::@expr7481 simpleMatch (@expr7508 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "." ) &&@expr1073749335 astIsLhs (@expr7512 valueExpr@var2753 ) &&@expr1073749337 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7516 valueType (@expr7517 ) &&@expr1073749342 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7516 valueType (@expr7517 ) .@expr1073749347 pointer@var2943 ==@expr1073749348 0 ) {
1131: valueExpr@var2753 =@expr1073749349 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ; }
1132: }
1133: const Token * derefValue@var2754 ; derefValue@var2754 =@expr1073749352 nullptr ;
1134: if (@expr7529 alloc@var2751 !=@expr7530 NO_ALLOC ) {
1135: const int arrayDim@var2755 =@expr1073749355 (@expr1073749356 vartok@var2748 .@expr7498 variable (@expr7499 ) &&@expr1073749359 vartok@var2748 .@expr7498 variable (@expr7499 ) .@expr1073749362 isArray (@expr1073749363 ) ) ?@expr1073749364 vartok@var2748 .@expr7498 variable (@expr7499 ) .@expr1073749367 dimensions (@expr1073749368 ) .@expr1073749369 size (@expr1073749370 ) :@expr1073749371 1 ;
1136: int deref@var2756 ; deref@var2756 =@expr1073749372 0 ;
1137: derefValue@var2754 =@expr1073749373 valueExpr@var2753 ;
1138: while (@expr1073749374 Token ::@expr7436 Match (@expr1073749376 derefValue@var2754 .@expr7553 astParent (@expr7554 ) , "+|-|*|[|." ) ||@expr1073749379
1139: (@expr1073749380 derefValue@var2754 .@expr7553 astParent (@expr7554 ) &&@expr1073749383 derefValue@var2754 .@expr7553 astParent (@expr7554 ) .@expr1073749386 isCast (@expr1073749387 ) ) ||@expr1073749388
1140: (@expr1073749389 deref@var2756 <@expr7566 arrayDim@var2755 &&@expr1073749391 Token ::@expr7481 simpleMatch (@expr1073749393 derefValue@var2754 .@expr7553 astParent (@expr7554 ) , "&" ) &&@expr1073749396 derefValue@var2754 .@expr7553 astParent (@expr7554 ) .@expr1073749399 isBinaryOp (@expr1073749400 ) ) ) {
1141: const Token * const derefValueParent@var2757 ; derefValueParent@var2757 =@expr1073749401 derefValue@var2754 .@expr7553 astParent (@expr7554 ) ;
1142: if (@expr1073749404 derefValueParent@var2757 .@expr7581 str (@expr7582 ) ==@expr1073749407 "*" ) {
1143: if (@expr1073749408 derefValueParent@var2757 .@expr1073749409 isUnaryOp (@expr1073749410 "*" ) ) {
1144: ++@expr1073749411 deref@var2756 ; }
1145: else {
1146: break ; }
1147: } else { if (@expr1073749412 derefValueParent@var2757 .@expr7581 str (@expr7582 ) ==@expr1073749415 "[" ) {
1148: if (@expr1073749416 astIsLhs (@expr7593 derefValue@var2754 ) ) {
1149: ++@expr1073749418 deref@var2756 ; }
1150: else {
1151: break ; }
1152: } else { if (@expr1073749419 Token ::@expr7436 Match (@expr1073749421 derefValueParent@var2757 , "[+-]" ) ) {
1153: if (@expr1073749422 deref@var2756 >=@expr1073749423 arrayDim@var2755 ) {
1154: break ; }
1155: } else { if (@expr1073749424 derefValueParent@var2757 .@expr7581 str (@expr7582 ) ==@expr1073749427 "." ) {
1156: ++@expr1073749428 deref@var2756 ; } } } }
1157: derefValue@var2754 =@expr1073749429 derefValueParent@var2757 ;
1158: if (@expr7606 deref@var2756 <@expr7566 arrayDim@var2755 ) {
1159: valueExpr@var2753 =@expr1073749432 derefValue@var2754 ; }
1160: }
1161: if (@expr7606 deref@var2756 <@expr7566 arrayDim@var2755 ) {
1162:
1163: derefValue@var2754 =@expr1073749435 nullptr ;
1164: }
1165: } else { if (@expr1073749436 vartok@var2748 .@expr7613 astParent (@expr7614 ) &&@expr1073749439 vartok@var2748 .@expr7613 astParent (@expr7614 ) .@expr1073749442 isUnaryOp (@expr1073749443 "&" ) ) {
1166: const Token * child@var2758 ; child@var2758 =@expr1073749444 vartok@var2748 .@expr7613 astParent (@expr7614 ) ;
1167: const Token * parent@var2759 ; parent@var2759 =@expr1073749447 child@var2758 .@expr7624 astParent (@expr7625 ) ;
1168: while (@expr1073749450 parent@var2759 &&@expr1073749451 (@expr1073749452 parent@var2759 .@expr1073749453 isCast (@expr1073749454 ) ||@expr1073749455 parent@var2759 .@expr7632 str (@expr7633 ) ==@expr1073749458 "+" ) ) {
1169: child@var2758 =@expr1073749459 parent@var2759 ;
1170: parent@var2759 =@expr1073749460 child@var2758 .@expr7624 astParent (@expr7625 ) ;
1171: }
1172: if (@expr1073749463 parent@var2759 &&@expr1073749464 (@expr1073749465 parent@var2759 .@expr1073749466 isUnaryOp (@expr1073749467 "*" ) ||@expr1073749468 (@expr1073749469 parent@var2759 .@expr7632 str (@expr7633 ) ==@expr1073749472 "[" &&@expr1073749473 astIsLhs (@expr1073749474 child@var2758 ) ) ) ) {
1173: derefValue@var2754 =@expr1073749475 parent@var2759 ; }
1174: } }
1175:
1176: if (@expr1073749476 !@expr1073749477 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ) {
1177: return nullptr ; }
1178:
1179:
1180: if (@expr1073749480 derefValue@var2754 &&@expr1073749481 derefValue@var2754 .@expr7553 astParent (@expr7554 ) &&@expr1073749484 derefValue@var2754 .@expr7553 astParent (@expr7554 ) .@expr1073749487 isUnaryOp (@expr1073749488 "&" ) ) {
1181: return nullptr ; }
1182:
1183:
1184: if (@expr1073749489 Token ::@expr7481 simpleMatch (@expr7667 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "&" ) &&@expr1073749494 astIsRhs (@expr7441 valueExpr@var2753 ) &&@expr1073749496 Token ::@expr7436 Match (@expr1073749498 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749501 tokAt (@expr1073749502 -3 ) , "( %name% ) &" ) ) {
1185: return nullptr ; }
1186:
1187:
1188: if (@expr1073749503 isVoidCast (@expr1073749504 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ) ) {
1189: return nullptr ; }
1190: if (@expr1073749507 Token ::@expr7481 simpleMatch (@expr7508 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "." ) ) {
1191: const Token * parent@var2760 ; parent@var2760 =@expr1073749512 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ;
1192: while (@expr1073749515 Token ::@expr7481 simpleMatch (@expr1073749517 parent@var2760 , "." ) ) {
1193: parent@var2760 =@expr1073749518 parent@var2760 .@expr1073749519 astParent (@expr1073749520 ) ; }
1194: if (@expr1073749521 isVoidCast (@expr1073749522 parent@var2760 ) ) {
1195: return nullptr ; }
1196: }
1197: if (@expr7529 alloc@var2751 !=@expr7530 NO_ALLOC ) {
1198: if (@expr1073749525 Token ::@expr7436 Match (@expr1073749527 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "%comp%|%oror%|&&|?|!" ) ) {
1199: return nullptr ; }
1200: if (@expr1073749530 Token ::@expr7436 Match (@expr1073749532 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "%or%|&" ) &&@expr1073749535 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749538 isBinaryOp (@expr1073749539 ) ) {
1201: return nullptr ; }
1202: if (@expr1073749540 alloc@var2751 ==@expr7717 CTOR_CALL &&@expr1073749542 derefValue@var2754 &&@expr1073749543 Token ::@expr7481 simpleMatch (@expr1073749545 derefValue@var2754 .@expr7553 astParent (@expr7554 ) , "(" ) &&@expr1073749548 astIsLhs (@expr7593 derefValue@var2754 ) ) {
1203: return nullptr ; }
1204: if (@expr1073749550 Token ::@expr7481 simpleMatch (@expr1073749552 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "return" ) ) {
1205: return nullptr ; }
1206: }
1207:
1208:
1209: if (@expr1073749555 Token ::@expr7436 Match (@expr1073749557 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "[(,]" ) &&@expr1073749560 (@expr1073749561 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749564 str (@expr1073749565 ) ==@expr1073749566 "," ||@expr1073749567 astIsRhs (@expr7441 valueExpr@var2753 ) ) ) {
1210: const Token * parent@var2761 ; parent@var2761 =@expr1073749569 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ;
1211: while (@expr1073749572 Token ::@expr7481 simpleMatch (@expr1073749574 parent@var2761 , "," ) ) {
1212: parent@var2761 =@expr1073749575 parent@var2761 .@expr1073749576 astParent (@expr1073749577 ) ; }
1213: if (@expr1073749578 Token ::@expr7481 simpleMatch (@expr1073749580 parent@var2761 , "{" ) ) {
1214: return valueExpr@var2753 ; }
1215: const int use@var2762 =@expr1073749581 isFunctionParUsage (@expr7758 valueExpr@var2753 , library@var2749 , pointer@var2750 , alloc@var2751 , indirect@var2752 ) ;
1216: return (@expr7759 use@var2762 >@expr1073749584 0 ) ?@expr1073749585 valueExpr@var2753 :@expr7762 nullptr ;
1217: }
1218: if (@expr1073749587 derefValue@var2754 &&@expr1073749588 Token ::@expr7436 Match (@expr1073749590 derefValue@var2754 .@expr7553 astParent (@expr7554 ) , "[(,]" ) &&@expr1073749593 (@expr7759 derefValue@var2754 .@expr7553 astParent (@expr7554 ) .@expr1073749597 str (@expr1073749598 ) ==@expr1073749599 "," ||@expr1073749600 astIsRhs (@expr7777 derefValue@var2754 ) ) ) {
1219: const int use@var2763 =@expr1073749602 isFunctionParUsage (@expr1073749603 derefValue@var2754 , library@var2749 , false , NO_ALLOC , indirect@var2752 ) ;
1220: return (@expr7759 use@var2763 >@expr1073749605 0 ) ?@expr1073749606 derefValue@var2754 :@expr1073749607 nullptr ;
1221: }
1222: if (@expr1073749608 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7451 isUnaryOp (@expr7452 "&" ) ) {
1223: const Token * parent@var2764 ; parent@var2764 =@expr1073749613 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ;
1224: if (@expr1073749616 Token ::@expr7436 Match (@expr1073749618 parent@var2764 .@expr7795 astParent (@expr7796 ) , "[(,]" ) &&@expr1073749621 (@expr7759 parent@var2764 .@expr7795 astParent (@expr7796 ) .@expr1073749625 str (@expr1073749626 ) ==@expr1073749627 "," ||@expr1073749628 astIsRhs (@expr1073749629 parent@var2764 ) ) ) {
1225: const int use@var2765 =@expr1073749630 isFunctionParUsage (@expr7758 valueExpr@var2753 , library@var2749 , pointer@var2750 , alloc@var2751 , indirect@var2752 ) ;
1226: return (@expr7759 use@var2765 >@expr1073749633 0 ) ?@expr1073749634 valueExpr@var2753 :@expr7762 nullptr ;
1227: }
1228: return nullptr ;
1229: }
1230:
|
1233:
1234: {
1235: const Token * tok@var2766 ; tok@var2766 =@expr1073749636 derefValue@var2754 ?@expr7813 derefValue@var2754 :@expr7814 valueExpr@var2753 ;
1236: if (@expr1073749639 alloc@var2751 ==@expr1073749640 NO_ALLOC ) {
1237: while (@expr1073749641 tok@var2766 .@expr7818 valueType (@expr7819 ) &&@expr1073749644 tok@var2766 .@expr7818 valueType (@expr7819 ) .@expr1073749647 pointer@var2942 ==@expr1073749648 0 &&@expr1073749649 Token ::@expr7481 simpleMatch (@expr1073749651 tok@var2766 .@expr7828 astParent (@expr7829 ) , "." ) ) {
1238: tok@var2766 =@expr1073749654 tok@var2766 .@expr7828 astParent (@expr7829 ) ; }
1239: }
1240: if (@expr1073749657 Token ::@expr7481 simpleMatch (@expr1073749659 tok@var2766 .@expr7828 astParent (@expr7829 ) , "=" ) ) {
1241: if (@expr1073749662 astIsLhs (@expr1073749663 tok@var2766 ) ) {
1242: return nullptr ; }
1243: if (@expr1073749664 alloc@var2751 !=@expr7530 NO_ALLOC &&@expr1073749666 astIsRhs (@expr7441 valueExpr@var2753 ) ) {
1244: return nullptr ; }
1245: }
1246: }
1247:
1248:
1249: if (@expr1073749668 Token ::@expr7436 Match (@expr1073749670 (@expr7759 derefValue@var2754 ?@expr7848 derefValue@var2754 :@expr7849 vartok@var2748 ) .@expr1073749674 astParent (@expr1073749675 ) , "(|=" ) &&@expr1073749676 astIsRhs (@expr1073749677 derefValue@var2754 ?@expr7848 derefValue@var2754 :@expr7849 vartok@var2748 ) ) {
1250: const Token * rhstok@var2767 ; rhstok@var2767 =@expr1073749680 derefValue@var2754 ?@expr7848 derefValue@var2754 :@expr7849 vartok@var2748 ;
1251: const Token * lhstok@var2768 ; lhstok@var2768 =@expr1073749683 rhstok@var2767 .@expr1073749684 astParent (@expr1073749685 ) .@expr1073749686 astOperand1 (@expr1073749687 ) ;
1252: const Variable * lhsvar@var2769 ; lhsvar@var2769 =@expr1073749688 lhstok@var2768 .@expr1073749689 variable (@expr1073749690 ) ;
1253: if (@expr1073749691 lhsvar@var2769 &&@expr1073749692 lhsvar@var2769 .@expr1073749693 isReference (@expr1073749694 ) &&@expr1073749695 lhsvar@var2769 .@expr1073749696 nameToken (@expr1073749697 ) ==@expr1073749698 lhstok@var2768 ) {
1254: return nullptr ; }
1255: }
1256:
1257:
1258: if (@expr1073749699 Token ::@expr7481 simpleMatch (@expr1073749701 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , ":" ) &&@expr1073749704
1259: valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7456 astParent (@expr7457 ) &&@expr1073749709
1260: Token ::@expr7481 simpleMatch (@expr1073749711 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr7456 astParent (@expr7457 ) .@expr1073749716 previous (@expr1073749717 ) , "for (" ) ) {
1261: if (@expr1073749718 astIsLhs (@expr7512 valueExpr@var2753 ) ) {
1262: return nullptr ; }
1263:
1264: const Token * lhs@var2770 ; lhs@var2770 =@expr1073749720 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) .@expr1073749723 astOperand1 (@expr1073749724 ) ;
1265: if (@expr1073749725 lhs@var2770 &&@expr1073749726 lhs@var2770 .@expr7903 variable (@expr7904 ) &&@expr1073749729 lhs@var2770 .@expr7903 variable (@expr7904 ) .@expr1073749732 nameToken (@expr1073749733 ) ==@expr1073749734 lhs@var2770 &&@expr1073749735 lhs@var2770 .@expr7903 variable (@expr7904 ) .@expr1073749738 isReference (@expr1073749739 ) ) {
1266: return nullptr ; }
1267: }
1268:
1269:
1270:
1271: if (@expr1073749740 cpp@var2747 &&@expr1073749741 Token ::@expr7436 Match (@expr1073749743 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "<<|>>" ) ) {
1272: if (@expr1073749746 isLikelyStreamRead (@expr1073749747 cpp@var2747 , vartok@var2748 .@expr1073749748 previous (@expr1073749749 ) ) ) {
1273: return nullptr ; }
1274:
1275: if (@expr1073749750 const auto *@expr1073749751 vt@var2771 =@expr1073749752 valueExpr@var2753 .@expr1073749753 valueType (@expr1073749754 ) ) {
1276: if (@expr1073749755 vt@var2771 .@expr7932 type@var2772 ==@expr1073749757 ValueType ::@expr7934 Type ::@expr1073749759 VOID ) {
1277: return nullptr ; }
1278:
1279: if (@expr1073749760 (@expr7759 alloc@var2751 ==@expr7717 CTOR_CALL ||@expr1073749763 alloc@var2751 ==@expr1073749764 ARRAY ) &&@expr1073749765 vt@var2771 .@expr1073749766 pointer@var2773 &&@expr1073749767 vt@var2771 .@expr7932 type@var2772 !=@expr1073749769 ValueType ::@expr7934 Type ::@expr1073749771 CHAR &&@expr1073749772 vt@var2771 .@expr7932 type@var2772 !=@expr1073749774 ValueType ::@expr7934 Type ::@expr1073749776 WCHAR_T ) {
1280: return nullptr ; }
1281: }
1282: }
1283: if (@expr1073749777 astIsRhs (@expr7777 derefValue@var2754 ) &&@expr1073749779 isLikelyStreamRead (@expr1073749780 cpp@var2747 , derefValue@var2754 .@expr7553 astParent (@expr7554 ) ) ) {
1284: return nullptr ; }
1285:
1286:
1287: if (@expr1073749783 cpp@var2747 &&@expr1073749784 Token ::@expr7481 simpleMatch (@expr7667 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) , "&" ) &&@expr1073749789 astIsRhs (@expr7441 valueExpr@var2753 ) ) {
1288: const Token * parent@var2774 ; parent@var2774 =@expr1073749791 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ;
1289: while (@expr1073749794 Token ::@expr7481 simpleMatch (@expr1073749796 parent@var2774 , "&" ) &&@expr1073749797 parent@var2774 .@expr1073749798 isBinaryOp (@expr1073749799 ) ) {
1290: parent@var2774 =@expr1073749800 parent@var2774 .@expr1073749801 astParent (@expr1073749802 ) ; }
1291: if (@expr1073749803 !@expr1073749804 parent@var2774 ) {
1292: const Token * lhs@var2775 ; lhs@var2775 =@expr1073749805 valueExpr@var2753 .@expr7438 astParent (@expr7439 ) ;
1293: while (@expr1073749808 Token ::@expr7481 simpleMatch (@expr1073749810 lhs@var2775 , "&" ) &&@expr1073749811 lhs@var2775 .@expr1073749812 isBinaryOp (@expr1073749813 ) ) {
1294: lhs@var2775 =@expr1073749814 lhs@var2775 .@expr1073749815 astOperand1 (@expr1073749816 ) ; }
1295: if (@expr1073749817 lhs@var2775 &&@expr1073749818 lhs@var2775 .@expr1073749819 isName (@expr1073749820 ) &&@expr1073749821 (@expr7759 !@expr1073749823 lhs@var2775 .@expr8000 valueType (@expr8001 ) ||@expr1073749826 lhs@var2775 .@expr8000 valueType (@expr8001 ) .@expr1073749829 type@var2941 <=@expr1073749830 ValueType ::@expr7934 Type ::@expr1073749832 CONTAINER ) ) {
1296: return nullptr ; }
1297: }
1298: }
1299:
1300: return derefValue@var2754 ?@expr7813 derefValue@var2754 :@expr7814 valueExpr@var2753 ;
1301: }
1302:
1303: const Token * CheckUninitVar :: isVariableUsage ( const Token * vartok@var2776 , bool pointer@var2777 , Alloc alloc@var2778 , int indirect@var2779 ) const
1304: {
1305: return CheckUninitVar ::@expr1073749835 isVariableUsage (@expr1073749836 mTokenizer@var28 .@expr1073749837 isCPP (@expr1073749838 ) , vartok@var2776 , mSettings@var29 .@expr1073749839 library@var2925 , pointer@var2777 , alloc@var2778 , indirect@var2779 ) ;
1306: }
1307:
|
1313:
1314: int CheckUninitVar :: isFunctionParUsage ( const Token * vartok@var2780 , const Library & library@var2781 , bool pointer@var2782 , Alloc alloc@var2783 , int indirect@var2784 )
1315: {
1316: bool unknown@var2785 ; unknown@var2785 =@expr1073749840 false ;
1317: const Token * parent@var2786 ; parent@var2786 =@expr1073749841 getAstParentSkipPossibleCastAndAddressOf (@expr1073749842 vartok@var2780 , &@expr1073749843 unknown@var2785 ) ;
1318: if (@expr1073749844 unknown@var2785 ||@expr1073749845 !@expr1073749846 Token ::@expr8023 Match (@expr1073749848 parent@var2786 , "[(,]" ) ) {
1319: return -1 ; }
1320:
1321:
1322: int argumentNumber@var2787 ; argumentNumber@var2787 =@expr1073749849 0 ;
1323: const Token * start@var2788 ; start@var2788 =@expr1073749850 vartok@var2780 ;
1324: while (@expr1073749851 start@var2788 &&@expr1073749852 !@expr1073749853 Token ::@expr8023 Match (@expr1073749855 start@var2788 , "[;{}(]" ) ) {
1325: if (@expr1073749856 start@var2788 .@expr8033 str (@expr8034 ) ==@expr1073749859 ")" ) {
1326: start@var2788 =@expr1073749860 start@var2788 .@expr8037 link (@expr8038 ) ; }
1327: else { if (@expr1073749863 start@var2788 .@expr8033 str (@expr8034 ) ==@expr1073749866 "," ) {
1328: ++@expr1073749867 argumentNumber@var2787 ; } }
1329: start@var2788 =@expr1073749868 start@var2788 .@expr8045 previous (@expr8046 ) ;
1330: }
1331: if (@expr1073749871 !@expr1073749872 start@var2788 ) {
1332: return -1 ; }
1333:
1334: if (@expr1073749873 Token ::@expr1073749874 simpleMatch (@expr1073749875 start@var2788 .@expr8037 link (@expr8038 ) , ") {" ) &&@expr1073749878 Token ::@expr8023 Match (@expr1073749880 start@var2788 .@expr8045 previous (@expr8046 ) , "if|for|while|switch" ) ) {
1335: return (@expr8059 !@expr1073749884 pointer@var2782 ||@expr1073749885 alloc@var2783 ==@expr8062 NO_ALLOC ) ; }
1336:
1337:
1338: if (@expr1073749887 Token ::@expr8023 Match (@expr1073749889 start@var2788 .@expr8045 previous (@expr8046 ) , "%name% (" ) ) {
1339: const bool address@var2789 (@expr1073749892 vartok@var2780 .@expr1073749893 previous (@expr1073749894 ) .@expr1073749895 str (@expr1073749896 ) ==@expr1073749897 "&" ) ;
1340: const bool array@var2790 (@expr1073749898 vartok@var2780 .@expr8075 variable (@expr8076 ) &&@expr1073749901 vartok@var2780 .@expr8075 variable (@expr8076 ) .@expr1073749904 isArray (@expr1073749905 ) ) ;
1341:
1342: const Function * func@var2791 ; func@var2791 =@expr1073749906 start@var2788 .@expr8045 previous (@expr8046 ) .@expr1073749909 function (@expr1073749910 ) ;
1343: if (@expr1073749911 func@var2791 ) {
1344: const Variable * arg@var2792 ; arg@var2792 =@expr1073749912 func@var2791 .@expr1073749913 getArgumentVar (@expr1073749914 argumentNumber@var2787 ) ;
1345: if (@expr1073749915 arg@var2792 ) {
1346: const Token * argStart@var2793 ; argStart@var2793 =@expr1073749916 arg@var2792 .@expr1073749917 typeStartToken (@expr1073749918 ) ;
1347: if (@expr1073749919 !@expr8096 address@var2789 &&@expr1073749921 !@expr1073749922 array@var2790 &&@expr1073749923 Token ::@expr8023 Match (@expr1073749925 argStart@var2793 , "%type% %name%| [,)]" ) ) {
1348: return 1 ; }
1349: if (@expr1073749926 pointer@var2782 &&@expr1073749927 !@expr8096 address@var2789 &&@expr1073749929 alloc@var2783 ==@expr8062 NO_ALLOC &&@expr1073749931 Token ::@expr8023 Match (@expr1073749933 argStart@var2793 , "%type% * %name% [,)]" ) ) {
1350: return 1 ; }
1351: while (@expr1073749934 argStart@var2793 .@expr8111 previous (@expr8112 ) &&@expr1073749937 argStart@var2793 .@expr8111 previous (@expr8112 ) .@expr1073749940 isName (@expr1073749941 ) ) {
1352: argStart@var2793 =@expr1073749942 argStart@var2793 .@expr8111 previous (@expr8112 ) ; }
1353: if (@expr1073749945 Token ::@expr8023 Match (@expr1073749947 argStart@var2793 , "const %type% & %name% [,)]" ) ) {
1354:
1355: if (@expr1073749948 vartok@var2780 .@expr8075 variable (@expr8076 ) &&@expr1073749951 vartok@var2780 .@expr8075 variable (@expr8076 ) .@expr8130 valueType (@expr8131 ) &&@expr1073749956 vartok@var2780 .@expr8075 variable (@expr8076 ) .@expr8130 valueType (@expr8131 ) .@expr1073749961 type@var2944 ==@expr1073749962 ValueType ::@expr1073749963 Type ::@expr1073749964 RECORD ) {
1356: return -1 ; }
1357: return 1 ;
1358: }
1359: if (@expr1073749965 (@expr8059 pointer@var2782 ||@expr1073749967 address@var2789 ) &&@expr1073749968 Token ::@expr8023 Match (@expr1073749970 argStart@var2793 , "const %type% %name% [" ) &&@expr1073749971 Token ::@expr8023 Match (@expr1073749973 argStart@var2793 .@expr1073749974 linkAt (@expr1073749975 3 ) , "] [,)]" ) ) {
1360: return 1 ; }
1361: }
1362:
1363: } else { if (@expr1073749976 Token ::@expr8023 Match (@expr1073749978 start@var2788 .@expr8045 previous (@expr8046 ) , "if|while|for" ) ) {
1364:
1365: return alloc@var2783 ==@expr8062 NO_ALLOC ;
1366: } else {
1367: const bool isnullbad@var2794 =@expr1073749982 library@var2781 .@expr1073749983 isnullargbad (@expr1073749984 start@var2788 .@expr8045 previous (@expr8046 ) , argumentNumber@var2787 +@expr8163 1 ) ;
1368: if (@expr1073749988 indirect@var2784 ==@expr1073749989 0 &&@expr1073749990 pointer@var2782 &&@expr1073749991 !@expr8096 address@var2789 &&@expr1073749993 isnullbad@var2794 &&@expr1073749994 alloc@var2783 ==@expr8062 NO_ALLOC ) {
1369: return 1 ; }
1370: bool hasIndirect@var2795 ; hasIndirect@var2795 =@expr1073749996 false ;
1371: const bool isuninitbad@var2796 =@expr1073749997 library@var2781 .@expr1073749998 isuninitargbad (@expr1073749999 start@var2788 .@expr8045 previous (@expr8046 ) , argumentNumber@var2787 +@expr8163 1 , indirect@var2784 , &@expr1073750003 hasIndirect@var2795 ) ;
1372: if (@expr1073750004 alloc@var2783 !=@expr1073750005 NO_ALLOC ) {
1373: return (@expr8059 isnullbad@var2794 ||@expr1073750007 hasIndirect@var2795 ) &&@expr1073750008 isuninitbad@var2796 ; }
1374: return isuninitbad@var2796 &&@expr1073750009 (@expr8059 !@expr8096 address@var2789 ||@expr1073750012 isnullbad@var2794 ) ;
1375: } }
1376: }
1377:
1378:
1379: return -1 ;
1380: }
1381:
1382: int CheckUninitVar :: isFunctionParUsage ( const Token * vartok@var2797 , bool pointer@var2798 , Alloc alloc@var2799 , int indirect@var2800 ) const
1383: {
1384: return CheckUninitVar ::@expr1073750013 isFunctionParUsage (@expr1073750014 vartok@var2797 , mSettings@var29 .@expr1073750015 library@var2925 , pointer@var2798 , alloc@var2799 , indirect@var2800 ) ;
1385: }
1386:
1387: bool CheckUninitVar :: isMemberVariableAssignment ( const Token * tok@var2801 , const std :: string & membervar@var2802 ) const
1388: {
1389: if (@expr1073750016 Token ::@expr8193 Match (@expr1073750018 tok@var2801 , "%name% . %name%" ) &&@expr1073750019 tok@var2801 .@expr8196 strAt (@expr1073750021 2 ) ==@expr1073750022 membervar@var2802 ) {
1390: if (@expr1073750023 Token ::@expr8193 Match (@expr1073750025 tok@var2801 .@expr8202 tokAt (@expr8203 3 ) , "[=.[]" ) ) {
1391: return true ; }
1392: else { if (@expr1073750028 Token ::@expr8193 Match (@expr1073750030 tok@var2801 .@expr8202 tokAt (@expr8208 -2 ) , "[(,=] &" ) ) {
1393: return true ; }
1394: else { if (@expr1073750033 isLikelyStreamRead (@expr1073750034 mTokenizer@var28 .@expr1073750035 isCPP (@expr1073750036 ) , tok@var2801 .@expr8213 previous (@expr8214 ) ) ) {
1395: return true ; }
1396: else { if (@expr1073750039 (@expr1073750040 tok@var2801 .@expr8213 previous (@expr8214 ) &&@expr1073750043 tok@var2801 .@expr8213 previous (@expr8214 ) .@expr1073750046 isConstOp (@expr1073750047 ) ) ||@expr1073750048 Token ::@expr8193 Match (@expr1073750050 tok@var2801 .@expr8213 previous (@expr8214 ) , "[|=" ) ) {
1397: ; }
1398: else { if (@expr1073750053 tok@var2801 .@expr8202 tokAt (@expr8203 3 ) .@expr1073750056 isConstOp (@expr1073750057 ) ) {
1399: ; }
1400: else { if (@expr1073750058 Token ::@expr8193 Match (@expr1073750060 tok@var2801 .@expr8213 previous (@expr8214 ) , "[(,] %name% . %name% [,)]" ) &&@expr1073750063
1401: 1 ==@expr1073750064 isFunctionParUsage (@expr1073750065 tok@var2801 , false , NO_ALLOC ) ) {
1402: return false ;
1403: } else {
1404: return true ; } } } } } }
1405: } else { if (@expr1073750066 tok@var2801 .@expr8196 strAt (@expr1073750068 1 ) ==@expr1073750069 "=" ) {
1406: return true ; }
1407: else { if (@expr1073750070 Token ::@expr8193 Match (@expr1073750072 tok@var2801 , "%var% . %name% (" ) ) {
1408: const Token * ftok@var2803 ; ftok@var2803 =@expr1073750073 tok@var2801 .@expr8202 tokAt (@expr1073750075 2 ) ;
1409: if (@expr1073750076 !@expr1073750077 ftok@var2803 .@expr8254 function (@expr8255 ) ||@expr1073750080 !@expr1073750081 ftok@var2803 .@expr8254 function (@expr8255 ) .@expr1073750084 isConst (@expr1073750085 ) ) {
1410:
1411: return true ; }
1412: } else { if (@expr1073750086 tok@var2801 .@expr8196 strAt (@expr1073750088 -1 ) ==@expr1073750089 "&" ) {
1413: if (@expr1073750090 Token ::@expr8193 Match (@expr1073750092 tok@var2801 .@expr8202 tokAt (@expr8208 -2 ) , "[(,] & %name%" ) ) {
1414:
1415: int argumentNumber@var2804 ; argumentNumber@var2804 =@expr1073750095 0 ;
1416: const Token * ftok@var2805 ; ftok@var2805 =@expr1073750096 tok@var2801 ;
1417: while (@expr1073750097 ftok@var2805 &&@expr1073750098 !@expr1073750099 Token ::@expr8193 Match (@expr1073750101 ftok@var2805 , "[;{}(]" ) ) {
1418: if (@expr1073750102 ftok@var2805 .@expr8279 str (@expr8280 ) ==@expr1073750105 ")" ) {
1419: ftok@var2805 =@expr1073750106 ftok@var2805 .@expr1073750107 link (@expr1073750108 ) ; }
1420: else { if (@expr1073750109 ftok@var2805 .@expr8279 str (@expr8280 ) ==@expr1073750112 "," ) {
1421: ++@expr1073750113 argumentNumber@var2804 ; } }
1422: ftok@var2805 =@expr1073750114 ftok@var2805 .@expr8291 previous (@expr8292 ) ;
1423: }
1424:
1425:
1426: ftok@var2805 =@expr1073750117 ftok@var2805 ?@expr1073750118 ftok@var2805 .@expr8291 previous (@expr8292 ) :@expr1073750121 nullptr ;
1427: if (@expr1073750122 Token ::@expr8193 Match (@expr1073750124 ftok@var2805 , "%name% (" ) ) {
1428:
1429: const Function * function@var2806 ; function@var2806 =@expr1073750125 ftok@var2805 .@expr1073750126 function (@expr1073750127 ) ;
1430:
1431: if (@expr1073750128 !@expr1073750129 function@var2806 &&@expr1073750130 mSettings@var29 ) {
1432:
1433: const Library ::@expr8307 ArgumentChecks ::@expr8307 Direction argDirection@var2807 =@expr1073750133 mSettings@var29 .@expr1073750134 library@var2925 .@expr1073750135 getArgDirection (@expr1073750136 ftok@var2805 , 1 +@expr1073750137 argumentNumber@var2804 ) ;
1434: if (@expr1073750138 argDirection@var2807 ==@expr1073750139 Library ::@expr8316 ArgumentChecks ::@expr8317 Direction ::@expr1073750142 DIR_IN ) {
1435: return false ; }
1436: else { if (@expr1073750143 argDirection@var2807 ==@expr1073750144 Library ::@expr8316 ArgumentChecks ::@expr8317 Direction ::@expr1073750147 DIR_OUT ) {
1437: return true ; } }
1438: }
1439:
1440: const Variable * arg@var2808 ; arg@var2808 =@expr1073750148 function@var2806 ?@expr1073750149 function@var2806 .@expr1073750150 getArgumentVar (@expr1073750151 argumentNumber@var2804 ) :@expr1073750152 nullptr ;
1441: const Token * argStart@var2809 ; argStart@var2809 =@expr1073750153 arg@var2808 ?@expr1073750154 arg@var2808 .@expr1073750155 typeStartToken (@expr1073750156 ) :@expr1073750157 nullptr ;
1442: while (@expr1073750158 argStart@var2809 &&@expr1073750159 argStart@var2809 .@expr8336 previous (@expr8337 ) &&@expr1073750162 argStart@var2809 .@expr8336 previous (@expr8337 ) .@expr1073750165 isName (@expr1073750166 ) ) {
1443: argStart@var2809 =@expr1073750167 argStart@var2809 .@expr8336 previous (@expr8337 ) ; }
1444: if (@expr1073750170 Token ::@expr8193 Match (@expr1073750172 argStart@var2809 , "const struct| %type% * const| %name% [,)]" ) ) {
1445: return false ; }
1446: }
1447:
1448: else { if (@expr1073750173 ftok@var2805 &&@expr1073750174 Token ::@expr1073750175 simpleMatch (@expr1073750176 ftok@var2805 .@expr8291 previous (@expr8292 ) , "= * (" ) ) {
1449: return false ; } }
1450: }
1451: return true ;
1452: } } } }
1453: return false ;
1454: }
1455:
1456: bool CheckUninitVar :: isMemberVariableUsage ( const Token * tok@var2810 , bool isPointer@var2811 , Alloc alloc@var2812 , const std :: string & membervar@var2813 ) const
1457: {
1458: if (@expr1073750179 Token ::@expr8356 Match (@expr1073750181 tok@var2810 .@expr8358 previous (@expr8359 ) , "[(,] %name% . %name% [,)]" ) &&@expr1073750184
1459: tok@var2810 .@expr8361 strAt (@expr8362 2 ) ==@expr8363 membervar@var2813 ) {
1460: const int use@var2814 =@expr1073750188 isFunctionParUsage (@expr1073750189 tok@var2810 , isPointer@var2811 , alloc@var2812 ) ;
1461: if (@expr1073750190 use@var2814 ==@expr1073750191 1 ) {
1462: return true ; }
1463: }
1464:
1465: if (@expr1073750192 isMemberVariableAssignment (@expr1073750193 tok@var2810 , membervar@var2813 ) ) {
1466: return false ; }
1467:
1468: if (@expr1073750194 Token ::@expr8356 Match (@expr1073750196 tok@var2810 , "%name% . %name%" ) &&@expr1073750197 tok@var2810 .@expr8361 strAt (@expr8362 2 ) ==@expr8363 membervar@var2813 &&@expr1073750201 !@expr1073750202 (@expr1073750203 tok@var2810 .@expr8380 tokAt (@expr8381 -2 ) .@expr8382 variable (@expr8383 ) &&@expr1073750208 tok@var2810 .@expr8380 tokAt (@expr8381 -2 ) .@expr8382 variable (@expr8383 ) .@expr1073750213 isReference (@expr1073750214 ) ) ) {
1469: const Token * parent@var2815 ; parent@var2815 =@expr1073750215 tok@var2810 .@expr1073750216 next (@expr1073750217 ) .@expr1073750218 astParent (@expr1073750219 ) ;
1470: if (@expr1073750220 parent@var2815 &&@expr1073750221 parent@var2815 .@expr1073750222 isUnaryOp (@expr1073750223 "&" ) ) {
1471: return false ; }
1472: return true ;
1473: } else { if (@expr1073750224 !@expr8401 isPointer@var2811 &&@expr1073750226 !@expr1073750227 Token ::@expr8404 simpleMatch (@expr1073750229 tok@var2810 .@expr8406 astParent (@expr8407 ) , "." ) &&@expr1073750232 Token ::@expr8356 Match (@expr1073750234 tok@var2810 .@expr8358 previous (@expr8359 ) , "[(,] %name% [,)]" ) &&@expr1073750237 isVariableUsage (@expr8414 tok@var2810 , isPointer@var2811 , alloc@var2812 ) ) {
1474: return true ; }
1475:
1476: else { if (@expr1073750239 !@expr8401 isPointer@var2811 &&@expr1073750241 Token ::@expr8356 Match (@expr1073750243 tok@var2810 .@expr8358 previous (@expr8359 ) , "= %name% ;" ) ) {
1477: return true ; }
1478:
1479:
1480: else { if (@expr1073750246 !@expr8401 isPointer@var2811 &&@expr1073750248
1481: Token ::@expr8404 simpleMatch (@expr1073750250 tok@var2810 .@expr8406 astParent (@expr8407 ) , "&" ) &&@expr1073750253
1482: Token ::@expr8404 simpleMatch (@expr1073750255 tok@var2810 .@expr8406 astParent (@expr8407 ) .@expr8434 astParent (@expr8435 ) , "*" ) &&@expr1073750260
1483: Token ::@expr8356 Match (@expr1073750262 tok@var2810 .@expr8406 astParent (@expr8407 ) .@expr8434 astParent (@expr8435 ) .@expr8443 astParent (@expr8444 ) , "= * (| &" ) &&@expr1073750269
1484: tok@var2810 .@expr8406 astParent (@expr8407 ) .@expr8434 astParent (@expr8435 ) .@expr8443 astParent (@expr8444 ) .@expr1073750276 astOperand2 (@expr1073750277 ) ==@expr1073750278 tok@var2810 .@expr8406 astParent (@expr8407 ) .@expr8434 astParent (@expr8435 ) ) {
1485: return true ; }
1486:
1487: else { if (@expr1073750283 mSettings@var29 .@expr1073750284 certainty@var2927 .@expr1073750285 isEnabled (@expr1073750286 Certainty ::@expr1073750287 experimental ) &&@expr1073750288
1488: !@expr8401 isPointer@var2811 &&@expr1073750290
1489: Token ::@expr8356 Match (@expr1073750292 tok@var2810 .@expr8380 tokAt (@expr8381 -2 ) , "[(,] & %name% [,)]" ) &&@expr1073750295
1490: isVariableUsage (@expr8414 tok@var2810 , isPointer@var2811 , alloc@var2812 ) ) {
1491: return true ; } } } } }
1492:
1493: return false ;
1494: }
1495:
1496: void CheckUninitVar :: uninitstringError ( const Token * tok@var2816 , const std :: string & varname@var2817 , bool strncpy_@var2818 )
1497: {
1498: reportError (@expr1073750297 tok@var2816 , Severity ::@expr1073750298 error , "uninitstring" , "$symbol:" +@expr1073750299 varname@var2817 +@expr1073750300 "\nDangerous usage of '$symbol'" +@expr1073750301 (@expr1073750302 strncpy_@var2818 ?@expr1073750303 " (strncpy doesn't always null-terminate it)." :@expr1073750304 " (not null-terminated)." ) , CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var130 , Certainty ::@expr1073750305 normal ) ;
1499: }
1500:
1501: void CheckUninitVar :: uninitdataError ( const Token * tok@var2819 , const std :: string & varname@var2820 )
1502: {
1503: reportError (@expr1073750306 tok@var2819 , Severity ::@expr1073750307 error , "uninitdata" , "$symbol:" +@expr1073750308 varname@var2820 +@expr1073750309 "\nMemory is allocated but not initialized: $symbol" , CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 , Certainty ::@expr1073750310 normal ) ;
1504: }
1505:
1506: void CheckUninitVar :: uninitvarError ( const Token * tok@var2821 , const std :: string & varname@var2822 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var2823 )
1507: {
1508: if (@expr1073750311 diag (@expr1073750312 tok@var2821 ) ) {
1509: return ; }
1510: errorPath@var2823 .@expr1073750313 emplace_back (@expr1073750314 tok@var2821 , "" ) ;
1511: reportError (@expr1073750315 errorPath@var2823 ,
1512: Severity ::@expr1073750316 error ,
1513: "legacyUninitvar" ,
1514: "$symbol:" +@expr1073750317 varname@var2822 +@expr1073750318 "\nUninitialized variable: $symbol" ,
1515: CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 ,
1516: Certainty ::@expr1073750319 normal ) ;
1517: }
1518:
1519: void CheckUninitVar :: uninitvarError ( const Token * tok@var2824 , const ValueFlow :: Value & v@var2825 )
1520: {
1521: if (@expr1073750320 diag (@expr1073750321 tok@var2824 ) ) {
1522: return ; }
1523: const Token * ltok@var2826 ; ltok@var2826 =@expr1073750322 tok@var2824 ;
1524: if (@expr1073750323 tok@var2824 &&@expr1073750324 Token ::@expr1073750325 simpleMatch (@expr1073750326 tok@var2824 .@expr8503 astParent (@expr8504 ) , "." ) &&@expr1073750329 astIsRHS (@expr1073750330 tok@var2824 ) ) {
1525: ltok@var2826 =@expr1073750331 tok@var2824 .@expr8503 astParent (@expr8504 ) ; }
1526: const std ::@expr8510 string &@expr8511 varname@var2827 =@expr1073750336 ltok@var2826 ?@expr1073750337 ltok@var2826 .@expr1073750338 expressionString (@expr1073750339 ) :@expr1073750340 "x" ;
1527: std ::@expr1073750341 list < std ::@expr8510 pair < const Token *@expr1073750343 , std ::@expr8510 string > > errorPath@var2828 ; errorPath@var2828 =@expr1073750345 v@var2825 .@expr1073750346 errorPath@var2829 ;
1528: errorPath@var2828 .@expr1073750347 emplace_back (@expr1073750348 tok@var2824 , "" ) ;
1529: if (@expr1073750349 v@var2825 .@expr8526 subexpressions@var2830 .@expr1073750351 empty (@expr1073750352 ) ) {
1530: reportError (@expr1073750353 errorPath@var2828 ,
1531: Severity ::@expr8530 error ,
1532: "uninitvar" ,
1533: "$symbol:" +@expr8531 varname@var2827 +@expr1073750356 "\nUninitialized variable: $symbol" ,
1534: CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 ,
1535: Certainty ::@expr8533 normal ) ;
1536: return ;
1537: }
1538: std ::@expr1073750358 string vars@var2831 ; vars@var2831 =@expr1073750359 v@var2825 .@expr8526 subexpressions@var2830 .@expr1073750361 size (@expr1073750362 ) ==@expr1073750363 1 ?@expr1073750364 "variable: " :@expr1073750365 "variables: " ;
1539: std ::@expr1073750366 string prefix@var2832 ;
1540: for (@expr1073750367 const std ::@expr8510 string &@expr8511 var@var2833 :@expr1073750370 v@var2825 .@expr8526 subexpressions@var2830 ) {
1541: vars@var2831 +=@expr1073750372 prefix@var2832 +@expr1073750373 varname@var2827 +@expr1073750374 "." +@expr1073750375 var@var2833 ;
1542: prefix@var2832 =@expr1073750376 ", " ;
1543: }
1544: reportError (@expr1073750377 errorPath@var2828 ,
1545: Severity ::@expr8530 error ,
1546: "uninitvar" ,
1547: "$symbol:" +@expr8531 varname@var2827 +@expr1073750380 "\nUninitialized " +@expr1073750381 vars@var2831 ,
1548: CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 ,
1549: Certainty ::@expr8533 normal ) ;
1550: }
1551:
1552: void CheckUninitVar :: uninitStructMemberError ( const Token * tok@var2834 , const std :: string & membername@var2835 )
1553: {
1554: reportError (@expr1073750383 tok@var2834 ,
1555: Severity ::@expr1073750384 error ,
1556: "uninitStructMember" ,
1557: "$symbol:" +@expr1073750385 membername@var2835 +@expr1073750386 "\nUninitialized struct member: $symbol" , CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 , Certainty ::@expr1073750387 normal ) ;
1558: }
1559:
1560: enum class ExprUsage { None , NotUsed , PassedByReference , Used } ;
1561:
1562: static ExprUsage getFunctionUsage ( const Token * tok@var2836 , int indirect@var2837 , const Settings * settings@var2838 )
1563: {
1564: const bool addressOf@var2839 =@expr1073750388 tok@var2836 .@expr8565 astParent (@expr8566 ) &&@expr1073750391 tok@var2836 .@expr8565 astParent (@expr8566 ) .@expr1073750394 isUnaryOp (@expr1073750395 "&" ) ;
1565:
1566: int argnr@var2840 ;
1567: const Token * ftok@var2841 ; ftok@var2841 =@expr1073750396 getTokenArgumentFunction (@expr1073750397 tok@var2836 , argnr@var2840 ) ;
1568: if (@expr1073750398 !@expr1073750399 ftok@var2841 ) {
1569: return ExprUsage ::@expr8576 None ; }
1570: if (@expr1073750401 ftok@var2841 .@expr1073750402 function (@expr1073750403 ) ) {
1571: std ::@expr1073750404 vector < const Variable *@expr8581 > args@var2842 ; args@var2842 =@expr1073750406 getArgumentVars (@expr1073750407 ftok@var2841 , argnr@var2840 ) ;
1572: for (@expr1073750408 const Variable *@expr8581 arg@var2843 :@expr1073750410 args@var2842 ) {
1573: if (@expr1073750411 !@expr1073750412 arg@var2843 ) {
1574: continue ; }
1575: if (@expr1073750413 arg@var2843 .@expr1073750414 isReference (@expr1073750415 ) ) {
1576: return ExprUsage ::@expr1073750416 PassedByReference ; }
1577: }
1578: } else {
1579: const bool isnullbad@var2844 =@expr1073750417 settings@var2838 .@expr8594 library@var2845 .@expr1073750419 isnullargbad (@expr1073750420 ftok@var2841 , argnr@var2840 +@expr8597 1 ) ;
1580: if (@expr1073750422 indirect@var2837 ==@expr1073750423 0 &&@expr1073750424 astIsPointer (@expr1073750425 tok@var2836 ) &&@expr1073750426 !@expr8603 addressOf@var2839 &&@expr1073750428 isnullbad@var2844 ) {
1581: return ExprUsage ::@expr8605 Used ; }
1582: bool hasIndirect@var2846 ; hasIndirect@var2846 =@expr1073750430 false ;
1583: const bool isuninitbad@var2847 =@expr1073750431 settings@var2838 .@expr8594 library@var2845 .@expr1073750433 isuninitargbad (@expr1073750434 ftok@var2841 , argnr@var2840 +@expr8597 1 , indirect@var2837 , &@expr1073750436 hasIndirect@var2846 ) ;
1584: if (@expr1073750437 isuninitbad@var2847 &&@expr1073750438 (@expr1073750439 !@expr8603 addressOf@var2839 ||@expr1073750441 isnullbad@var2844 ) ) {
1585: return ExprUsage ::@expr8605 Used ; }
1586: }
1587: return ExprUsage ::@expr8576 None ;
1588: }
1589:
1590: static ExprUsage getExprUsage ( const Token * tok@var2848 , int indirect@var2849 , const Settings * settings@var2850 )
1591: {
1592: if (@expr1073750444 indirect@var2849 >@expr1073750445 0 &&@expr1073750446 tok@var2848 .@expr8623 astParent (@expr8624 ) ) {
1593: if (@expr1073750449 Token ::@expr8626 Match (@expr1073750451 tok@var2848 .@expr8623 astParent (@expr8624 ) , "%assign%" ) &&@expr1073750454 astIsRhs (@expr1073750455 tok@var2848 ) ) {
1594: return ExprUsage ::@expr8632 NotUsed ; }
1595: if (@expr1073750457 tok@var2848 .@expr8623 astParent (@expr8624 ) .@expr1073750460 isConstOp (@expr1073750461 ) ) {
1596: return ExprUsage ::@expr8632 NotUsed ; }
1597: if (@expr1073750463 tok@var2848 .@expr8623 astParent (@expr8624 ) .@expr1073750466 isCast (@expr1073750467 ) ) {
1598: return ExprUsage ::@expr8632 NotUsed ; }
1599: }
1600: if (@expr1073750469 indirect@var2849 ==@expr1073750470 0 &&@expr1073750471 Token ::@expr8626 Match (@expr1073750473 tok@var2848 .@expr8623 astParent (@expr8624 ) , "%cop%|%assign%|++|--" ) &&@expr1073750476 tok@var2848 .@expr8623 astParent (@expr8624 ) .@expr1073750479 str (@expr1073750480 ) !=@expr1073750481 "=" ) {
1601: return ExprUsage ::@expr1073750482 Used ; }
1602: return getFunctionUsage (@expr1073750483 tok@var2848 , indirect@var2849 , settings@var2850 ) ;
1603: }
1604:
1605: static bool isLeafDot ( const Token * tok@var2851 )
1606: {
1607: if (@expr1073750484 !@expr1073750485 tok@var2851 ) {
1608: return false ; }
1609: const Token * parent@var2852 ; parent@var2852 =@expr1073750486 tok@var2851 .@expr1073750487 astParent (@expr1073750488 ) ;
1610: if (@expr1073750489 !@expr1073750490 Token ::@expr1073750491 simpleMatch (@expr1073750492 parent@var2852 , "." ) ) {
1611: return false ; }
1612: if (@expr1073750493 parent@var2852 .@expr1073750494 astOperand2 (@expr1073750495 ) ==@expr1073750496 tok@var2851 ) {
1613: return true ; }
1614: return isLeafDot (@expr1073750497 parent@var2852 ) ;
1615: }
1616:
1617: void CheckUninitVar :: valueFlowUninit ( )
1618: {
1619: const SymbolDatabase * symbolDatabase@var2853 ; symbolDatabase@var2853 =@expr1073750498 mTokenizer@var28 .@expr1073750499 getSymbolDatabase (@expr1073750500 ) ;
1620:
1621: std ::@expr1073750501 unordered_set < int > ids@var2854 ;
1622: for (@expr1073750502 bool subfunction@var2855 :@expr1073750503 {@expr1073750504 false , true } ) {
1623:
1624: for (@expr1073750505 const Scope *@expr8682 scope@var2856 :@expr1073750507 symbolDatabase@var2853 .@expr1073750508 functionScopes@var2857 ) {
1625: for (@expr1073750509 const Token *@expr8682 tok@var2858 =@expr1073750511 scope@var2856 .@expr1073750512 bodyStart@var2859 ; tok@var2858 !=@expr1073750513 scope@var2856 .@expr1073750514 bodyEnd@var2860 ; tok@var2858 =@expr1073750515 tok@var2858 .@expr1073750516 next (@expr1073750517 ) ) {
1626: if (@expr1073750518 isSizeOfEtc (@expr1073750519 tok@var2858 ) ) {
1627: tok@var2858 =@expr1073750520 tok@var2858 .@expr1073750521 linkAt (@expr1073750522 1 ) ;
1628: continue ;
1629: }
1630: if (@expr1073750523 ids@var2854 .@expr8700 count (@expr1073750525 tok@var2858 .@expr8702 exprId (@expr8703 ) ) >@expr1073750528 0 ) {
1631: continue ; }
1632: if (@expr1073750529 !@expr8706 tok@var2858 .@expr8707 variable (@expr8708 ) &&@expr1073750533 !@expr1073750534 tok@var2858 .@expr8711 isUnaryOp (@expr1073750536 "*" ) &&@expr1073750537 !@expr1073750538 tok@var2858 .@expr8711 isUnaryOp (@expr1073750540 "&" ) ) {
1633: continue ; }
1634: if (@expr1073750541 Token ::@expr8718 Match (@expr1073750543 tok@var2858 , "%name% (" ) ) {
1635: continue ; }
1636: const Token * parent@var2861 ; parent@var2861 =@expr1073750544 tok@var2858 .@expr8721 astParent (@expr8722 ) ;
1637: while (@expr1073750547 Token ::@expr1073750548 simpleMatch (@expr1073750549 parent@var2861 , "." ) ) {
1638: parent@var2861 =@expr1073750550 parent@var2861 .@expr1073750551 astParent (@expr1073750552 ) ; }
1639: if (@expr1073750553 parent@var2861 &&@expr1073750554 parent@var2861 .@expr1073750555 isUnaryOp (@expr1073750556 "&" ) ) {
1640: continue ; }
1641: if (@expr1073750557 isVoidCast (@expr1073750558 parent@var2861 ) ) {
1642: continue ; }
1643: auto v@var2862 ; v@var2862 =@expr1073750559 std ::@expr1073750560 find_if (@expr1073750561
1644: tok@var2858 .@expr8738 values (@expr8739 ) .@expr1073750564 begin (@expr1073750565 ) , tok@var2858 .@expr8738 values (@expr8739 ) .@expr8744 end (@expr8745 ) , std ::@expr1073750570 mem_fn (@expr1073750571 &@expr1073750572 ValueFlow ::@expr1073750573 Value ::@expr1073750574 isUninitValue ) ) ;
1645: if (@expr1073750575 v@var2862 ==@expr1073750576 tok@var2858 .@expr8738 values (@expr8739 ) .@expr8744 end (@expr8745 ) ) {
1646: continue ; }
1647: if (@expr1073750581 v@var2862 .@expr8758 tokvalue@var2863 &&@expr1073750583 ids@var2854 .@expr8700 count (@expr1073750585 v@var2862 .@expr8758 tokvalue@var2863 .@expr8763 exprId (@expr8764 ) ) >@expr1073750589 0 ) {
1648: continue ; }
1649: if (@expr1073750590 subfunction@var2855 ==@expr1073750591 (@expr1073750592 v@var2862 .@expr1073750593 path@var2864 ==@expr1073750594 0 ) ) {
1650: continue ; }
1651: if (@expr1073750595 v@var2862 .@expr1073750596 isInconclusive (@expr1073750597 ) ) {
1652: continue ; }
1653: if (@expr1073750598 v@var2862 .@expr8775 indirect@var2865 >@expr1073750600 1 ||@expr1073750601 v@var2862 .@expr8775 indirect@var2865 <@expr1073750603 0 ) {
1654: continue ; }
1655: bool uninitderef@var2866 ; uninitderef@var2866 =@expr1073750604 false ;
1656: if (@expr1073750605 tok@var2858 .@expr8707 variable (@expr8708 ) ) {
1657: bool unknown@var2867 ;
1658: const bool isarray@var2868 =@expr1073750608 !@expr8706 tok@var2858 .@expr8707 variable (@expr8708 ) ||@expr1073750612 tok@var2858 .@expr8707 variable (@expr8708 ) .@expr1073750615 isArray (@expr1073750616 ) ;
1659: const bool ispointer@var2869 =@expr1073750617 astIsPointer (@expr1073750618 tok@var2858 ) &&@expr1073750619 !@expr1073750620 isarray@var2868 ;
1660: const bool deref@var2870 =@expr1073750621 CheckNullPointer ::@expr1073750622 isPointerDeRef (@expr1073750623 tok@var2858 , unknown@var2867 , mSettings@var29 ) ;
1661: if (@expr1073750624 ispointer@var2869 &&@expr1073750625 v@var2862 .@expr8775 indirect@var2865 ==@expr1073750627 1 &&@expr1073750628 !@expr8805 deref@var2870 ) {
1662: continue ; }
1663: if (@expr1073750630 isarray@var2868 &&@expr1073750631 !@expr8805 deref@var2870 ) {
1664: continue ; }
1665: uninitderef@var2866 =@expr1073750633 deref@var2870 &&@expr1073750634 v@var2862 .@expr8775 indirect@var2865 ==@expr1073750636 0 ;
1666: const bool isleaf@var2871 =@expr1073750637 isLeafDot (@expr1073750638 tok@var2858 ) ||@expr1073750639 uninitderef@var2866 ;
1667: if (@expr1073750640 Token ::@expr8718 Match (@expr1073750642 tok@var2858 .@expr8721 astParent (@expr8722 ) , ". %var%" ) &&@expr1073750645 !@expr1073750646 isleaf@var2871 ) {
1668: continue ; }
1669: }
1670: ExprUsage usage@var2872 ; usage@var2872 =@expr1073750647 getExprUsage (@expr1073750648 tok@var2858 , v@var2862 .@expr8775 indirect@var2865 , mSettings@var29 ) ;
1671: if (@expr1073750650 usage@var2872 ==@expr1073750651 ExprUsage ::@expr1073750652 NotUsed ) {
1672: continue ; }
1673: if (@expr1073750653 !@expr1073750654 v@var2862 .@expr1073750655 subexpressions@var2873 .@expr1073750656 empty (@expr1073750657 ) &&@expr1073750658 usage@var2872 ==@expr1073750659 ExprUsage ::@expr1073750660 PassedByReference ) {
1674: continue ; }
1675: if (@expr1073750661 usage@var2872 !=@expr1073750662 ExprUsage ::@expr1073750663 Used ) {
1676: if (@expr1073750664 !@expr1073750665 (@expr1073750666 Token ::@expr8718 Match (@expr1073750668 tok@var2858 .@expr8721 astParent (@expr8722 ) , ". %name% (" ) &&@expr1073750671 uninitderef@var2866 ) &&@expr1073750672
1677: isVariableChanged (@expr1073750673 tok@var2858 , v@var2862 .@expr8775 indirect@var2865 , mSettings@var29 , mTokenizer@var28 .@expr1073750675 isCPP (@expr1073750676 ) ) ) {
1678: continue ; }
1679: bool inconclusive@var2874 ; inconclusive@var2874 =@expr1073750677 false ;
1680: if (@expr1073750678 isVariableChangedByFunctionCall (@expr1073750679 tok@var2858 , v@var2862 .@expr8775 indirect@var2865 , mSettings@var29 , &@expr1073750681 inconclusive@var2874 ) ||@expr1073750682 inconclusive@var2874 ) {
1681: continue ; }
1682: }
1683: uninitvarError (@expr1073750683 tok@var2858 , *@expr1073750684 v@var2862 ) ;
1684: ids@var2854 .@expr8861 insert (@expr1073750686 tok@var2858 .@expr8702 exprId (@expr8703 ) ) ;
1685: if (@expr1073750689 v@var2862 .@expr8758 tokvalue@var2863 ) {
1686: ids@var2854 .@expr8861 insert (@expr1073750692 v@var2862 .@expr8758 tokvalue@var2863 .@expr8763 exprId (@expr8764 ) ) ; }
1687: }
1688: }
1689: }
1690: }
1691:
1692: std :: string CheckUninitVar :: MyFileInfo :: toString ( ) const
1693: {
1694: return CTU ::@expr1073750696 toString (@expr1073750697 unsafeUsage@var607 ) ;
1695: }
1696:
1697: Check :: FileInfo * CheckUninitVar :: getFileInfo ( const Tokenizer * tokenizer@var2875 , const Settings * settings@var2876 ) const
1698: {
1699: const CheckUninitVar checker@var2877 (@expr1073750698 tokenizer@var2875 , settings@var2876 , nullptr ) ;
1700: return checker@var2877 .@expr1073750699 getFileInfo (@expr1073750700 ) ;
1701: }
1702:
1703: static bool isVariableUsage ( const Check * check@var2878 , const Token * vartok@var2879 , long long * value@var2880 )
1704: {
1705: (@expr1073750701 void ) value@var2880 ;
1706: const CheckUninitVar * c@var2881 ; c@var2881 =@expr1073750702 dynamic_cast < const CheckUninitVar *@expr1073750703 > (@expr1073750704 check@var2878 ) ;
1707: return c@var2881 &&@expr1073750705 c@var2881 .@expr1073750706 isVariableUsage (@expr1073750707 vartok@var2879 , true , CheckUninitVar ::@expr1073750708 Alloc ::@expr1073750709 ARRAY ) ;
1708: }
1709:
1710: Check :: FileInfo * CheckUninitVar :: getFileInfo ( ) const
1711: {
1712: const std ::@expr1073750710 list < CTU ::@expr8887 FileInfo ::@expr8887 UnsafeUsage > & unsafeUsage@var2882 =@expr1073750713 CTU ::@expr1073750714 getUnsafeUsage (@expr1073750715 mTokenizer@var28 , mSettings@var29 , this@expr1073750716 , ::@expr1073750717 isVariableUsage ) ;
1713: if (@expr1073750718 unsafeUsage@var2882 .@expr1073750719 empty (@expr1073750720 ) ) {
1714: return nullptr ; }
1715:
1716: MyFileInfo * fileInfo@var2883 ; fileInfo@var2883 =@expr1073750721 new MyFileInfo ;
1717: fileInfo@var2883 .@expr1073750722 unsafeUsage@var2884 =@expr1073750723 unsafeUsage@var2882 ;
1718: return fileInfo@var2883 ;
1719: }
1720:
1721: Check :: FileInfo * CheckUninitVar :: loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var2885 ) const
1722: {
1723: const std ::@expr1073750724 list < CTU ::@expr8901 FileInfo ::@expr8901 UnsafeUsage > & unsafeUsage@var2886 =@expr1073750727 CTU ::@expr1073750728 loadUnsafeUsageListFromXml (@expr1073750729 xmlElement@var2885 ) ;
1724: if (@expr1073750730 unsafeUsage@var2886 .@expr1073750731 empty (@expr1073750732 ) ) {
1725: return nullptr ; }
1726:
1727: MyFileInfo * fileInfo@var2887 ; fileInfo@var2887 =@expr1073750733 new MyFileInfo ;
1728: fileInfo@var2887 .@expr1073750734 unsafeUsage@var2888 =@expr1073750735 unsafeUsage@var2886 ;
1729: return fileInfo@var2887 ;
1730: }
1731:
1732: bool CheckUninitVar :: analyseWholeProgram ( const CTU :: FileInfo * ctu@var2889 , const std :: list < Check :: FileInfo * > & fileInfo@var2890 , const Settings & settings@var2891 , ErrorLogger & errorLogger@var2892 )
1733: {
1734: if (@expr1073750736 !@expr1073750737 ctu@var2889 ) {
1735: return false ; }
1736: bool foundErrors@var2893 ; foundErrors@var2893 =@expr1073750738 false ;
1737: (@expr1073750739 void ) settings@var2891 ;
1738:
1739: const std ::@expr1073750740 map < std ::@expr8917 string , std ::@expr8917 list < const CTU ::@expr8917 FileInfo ::@expr8917 CallBase *@expr8921 > > callsMap@var2894 =@expr1073750746 ctu@var2889 .@expr1073750747 getCallsMap (@expr1073750748 ) ;
1740:
1741: for (@expr1073750749 Check ::@expr8917 FileInfo *@expr8921 fi1@var2895 :@expr1073750752 fileInfo@var2890 ) {
1742: const MyFileInfo * fi@var2896 ; fi@var2896 =@expr1073750753 dynamic_cast < MyFileInfo *@expr8921 > (@expr1073750755 fi1@var2895 ) ;
1743: if (@expr1073750756 !@expr1073750757 fi@var2896 ) {
1744: continue ; }
1745: for (@expr1073750758 const CTU ::@expr8917 FileInfo ::@expr8917 UnsafeUsage &@expr1073750761 unsafeUsage@var2897 :@expr1073750762 fi@var2896 .@expr1073750763 unsafeUsage@var2898 ) {
1746: const CTU ::@expr8940 FileInfo ::@expr1073750765 FunctionCall * functionCall@var2899 ; functionCall@var2899 =@expr1073750766 nullptr ;
1747:
1748: const std ::@expr1073750767 list < ErrorMessage ::@expr8917 FileLocation > & locationList@var2900 =@expr1073750769
1749: CTU ::@expr8940 FileInfo ::@expr1073750771 getErrorPath (@expr1073750772 CTU ::@expr8940 FileInfo ::@expr1073750774 InvalidValueType ::@expr1073750775 uninit ,
1750: unsafeUsage@var2897 ,
1751: callsMap@var2894 ,
1752: "Using argument ARG" ,
1753: &@expr1073750776 functionCall@var2899 ,
1754: false ) ;
1755: if (@expr1073750777 locationList@var2900 .@expr1073750778 empty (@expr1073750779 ) ) {
1756: continue ; }
1757:
1758: const ErrorMessage errmsg@var2901 (@expr1073750780 locationList@var2900 ,
1759: emptyString@var1 ,
1760: Severity ::@expr1073750781 error ,
1761: "Using argument " +@expr1073750782 unsafeUsage@var2897 .@expr1073750783 myArgumentName@var2902 +@expr1073750784 " that points at uninitialized variable " +@expr1073750785 functionCall@var2899 .@expr1073750786 callArgumentExpression@var2903 ,
1762: "ctuuninitvar" ,
1763: CWE_USE_OF_UNINITIALIZED_VARIABLE@var128 ,
1764: Certainty ::@expr1073750787 normal ) ;
1765: errorLogger@var2892 .@expr1073750788 reportErr (@expr1073750789 errmsg@var2901 ) ;
1766:
1767: foundErrors@var2893 =@expr1073750790 true ;
1768: }
1769: }
1770: return foundErrors@var2893 ;
1771: }

##file cppcheck-2.8/lib/settings.h

17:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2904 ; mFlags@var2904 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2904 ;
54: }
55: void clear ( ) {
56: mFlags@var2904 =@expr1073750791 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2904 =@expr1073750792 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2905 ) {
62: if (@expr1073750793 enabled@var2905 ) {
63: fill (@expr1073750794 ) ; }
64: else {
65: clear (@expr1073750795 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2906 ) const {
68: return (@expr8972 mFlags@var2904 &@expr1073750797 (@expr8972 1U <<@expr1073750799 (@expr1073750800 uint32_t ) flag@var2906 ) ) !=@expr1073750801 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2907 ) {
71: mFlags@var2904 |=@expr1073750802 (@expr1073750803 1U <<@expr1073750804 (@expr1073750805 uint32_t ) flag@var2907 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2908 ) {
74: mFlags@var2904 &=@expr1073750806 ~@expr1073750807 (@expr1073750808 1U <<@expr1073750809 (@expr1073750810 uint32_t ) flag@var2908 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2909 , bool enabled@var2910 ) {
77: if (@expr1073750811 enabled@var2910 ) {
78: enable (@expr1073750812 flag@var2909 ) ; }
79: else {
80: disable (@expr1073750813 flag@var2909 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2911 ; mFlags@var2911 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2911 ;
54: }
55: void clear ( ) {
56: mFlags@var2911 =@expr1073750814 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2911 =@expr1073750815 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2912 ) {
62: if (@expr1073750816 enabled@var2912 ) {
63: fill (@expr1073750817 ) ; }
64: else {
65: clear (@expr1073750818 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2913 ) const {
68: return (@expr8995 mFlags@var2911 &@expr1073750820 (@expr8995 1U <<@expr1073750822 (@expr1073750823 uint32_t ) flag@var2913 ) ) !=@expr1073750824 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2914 ) {
71: mFlags@var2911 |=@expr1073750825 (@expr1073750826 1U <<@expr1073750827 (@expr1073750828 uint32_t ) flag@var2914 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2915 ) {
74: mFlags@var2911 &=@expr1073750829 ~@expr1073750830 (@expr1073750831 1U <<@expr1073750832 (@expr1073750833 uint32_t ) flag@var2915 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2916 , bool enabled@var2917 ) {
77: if (@expr1073750834 enabled@var2917 ) {
78: enable (@expr1073750835 flag@var2916 ) ; }
79: else {
80: disable (@expr1073750836 flag@var2916 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2918 ; mFlags@var2918 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2918 ;
54: }
55: void clear ( ) {
56: mFlags@var2918 =@expr1073750837 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2918 =@expr1073750838 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2919 ) {
62: if (@expr1073750839 enabled@var2919 ) {
63: fill (@expr1073750840 ) ; }
64: else {
65: clear (@expr1073750841 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2920 ) const {
68: return (@expr9018 mFlags@var2918 &@expr1073750843 (@expr9018 1U <<@expr1073750845 (@expr1073750846 uint32_t ) flag@var2920 ) ) !=@expr1073750847 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2921 ) {
71: mFlags@var2918 |=@expr1073750848 (@expr1073750849 1U <<@expr1073750850 (@expr1073750851 uint32_t ) flag@var2921 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2922 ) {
74: mFlags@var2918 &=@expr1073750852 ~@expr1073750853 (@expr1073750854 1U <<@expr1073750855 (@expr1073750856 uint32_t ) flag@var2922 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2923 , bool enabled@var2924 ) {
77: if (@expr1073750857 enabled@var2924 ) {
78: enable (@expr1073750858 flag@var2923 ) ; }
79: else {
80: disable (@expr1073750859 flag@var2923 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  tok possible symbolic=(tok2->link())@53
  severity possible 7@246
  id possible {"bailoutUninitVar"@246,""@53}
  msg possible "assertion failed '} while ('"@53
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  severity possible 1@59
  id possible {"uninitStructMember"@59,"uninitdata"@65,"uninitstring"@66}
  certainty possible 0@59
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 54
  null always 0
  uninit always 1
  bufferOverflow always 2
Line 63
  { always 0
Line 64
  { always 0
Line 71
  { always 0
Line 74
  { always 0
Line 87
  { always 0
Line 92
  ( always {!<=-1,!>=2}
Line 101
  warning always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 122
  { always 0
Line 136
  warning always {!<=-1,!>=2}
Line 148
  ( always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
Line 51
  = always 0
  0 always 0
  notEqual always {!<=-1,!>=2}
  false always 0
Line 53
  notEqual always {!<=-1,!>=2}
Line 65
  ( always "Uninitialized variables"
Line 69
  ( always "Uninitialized variables"
Line 78
  ( always {!<=-1,!>=2}
Line 83
  NO_ALLOC always 0
  NO_CTOR_CALL always 1
  CTOR_CALL always 2
  ARRAY always 3
Line 84
  ( always {!<=-1,!>=2}
Line 85
  , always 0
  = always 0
  nullptr always 0
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 90
  , always 0
  = always 0
  0 always 0
Line 91
  , always 0
  = always 0
  0 always 0
Line 92
  , always 0
  = always 0
  0 always 0
Line 93
  , always 0
  = always 0
  0 always 0
Line 94
  ( always {!<=-1,!>=2}
Line 95
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 124
  errorPath always size=0
Line 127
  alloc possible 2
  == {!<=-1,!>=2,0}
  NO_CTOR_CALL always 1
  || always {!<=-1,!>=2}
  alloc always !1
  == always {!<=-1,!>=2}
  CTOR_CALL always 2
Line 137
  ( always {!<=-1,!>=2}
Line 141
  nullptr always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
  "varname" always "varname"
  true always 1
Line 148
  nullptr always 0
  "varname" always "varname"
Line 149
  nullptr always 0
  "a.b" always "a.b"
Line 153
  "Uninitialized variables" always "Uninitialized variables"
Line 157
  "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n" always "Uninitialized variables\n- using uninitialized local variables\n- using allocated data before it has been initialized\n"
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@57690,34@57946}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@225,34@226}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@225,""@226,""@227,"U"@228,"U"@229,"u"@230,"u"@231,"u8"@232,"u8"@233}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@87,34@88}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@84,34@86}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@59,128@60,64@61,32@62,16@63,8@64,4@65,2@66,1@67}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@68,128@69,64@70,32@71,16@72,8@73,4@74,2@75,1@76}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@68,4294967167@69,4294967231@70,4294967263@71,4294967279@72,4294967287@73,4294967291@74,4294967293@75,4294967294@76}
  flag {!<=-1,256@68,128@69,64@70,32@71,16@72,8@73,4@74,2@75,1@76}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible 2@49
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->astParent())@22,0@22,symbolic=(tok->astParent())@40,symbolic=(derefValue)@196,symbolic=(valueExpr->astParent())@230,symbolic=((lhs&&lhs->hasKnownIntValue())?rhs:lhs)@226,symbolic=(tok2->link())@52}
  pattern possible {"."@22,"."@40,"."@61,"."@76,"&"@81,"*"@83,"= * ("@120,") {"@128,"& )"@171,"."@179}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@214,4@215,0@216}
  t possible {10@214,4@215,0@216}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@214,4@215,0@216}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@214,0@216}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@214,0@216}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@214}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@214}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@214}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@214}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@214}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"*"@19,"&"@20,"&"@24,"&"@56,"&"@75,"&"@159,"*"@164,"("@170,"*"@202,"&"@208}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@222}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@224,17179869184@235,8589934592@237,34359738368@239,4294967296@241,2147483648@243,1073741824@245,536870912@247,268435456@249}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@55,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@56}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@223,17179869184@234,8589934592@236,34359738368@238,4294967296@240,2147483648@242,1073741824@244,536870912@246,268435456@248}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@223,17179869184@234,8589934592@236,34359738368@238,4294967296@240,2147483648@242,1073741824@244,536870912@246,268435456@248}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@157,4096@160,16384@163,2048@164,1024@165,65536@166,512@167,256@168,128@169}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@122,4194304@124,8388608@125,2097152@127,1048576@128,524288@129,262144@130,131072@131,65536@132}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@100,2097152@101,1048576@102,524288@103,262144@104,131072@105,65536@106,32768@107,16384@108}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@100,4292870143@101,4293918719@102,4294443007@103,4294705151@104,4294836223@105,4294901759@106,4294934527@107,4294950911@108}
  flag {!<=-1,8388608@100,2097152@101,1048576@102,524288@103,262144@104,131072@105,65536@106,32768@107,16384@108}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  visitor possible {lifetime[Lambda]=(var)@161,lifetime[Lambda]=(varIsUsedInRhs)@161,lifetime[Lambda]=(var)@20,lifetime[Lambda]=(errorToken)@20}
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 52
  ( always "Null pointer"
Line 56
  ( always "Null pointer"
Line 85
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 96
  0 always 0
Line 98
  "" always ""
  & {lifetime[Address]=(v),!0}
  false always 0
Line 100
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 123
  nullptr always 0
Line 124
  nullptr always 0
  "pointer" always "pointer"
  nullptr always 0
  false always 0
Line 125
  nullptr always 0
  nullptr always 0
  false always 0
Line 126
  nullptr always 0
  nullptr always 0
  nullptr always 0
  false always 0
Line 131
  "Null pointer" always "Null pointer"
Line 136
  "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n" always "Null pointers\n- null pointer dereferencing\n- undefined null pointer arithmetic\n"
Line 149
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 150
  , always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 62
  unknown possible lifetime[Address]=(unknown)@123
Line 63
  * always {!<=-1,!>=2}
  unknown {!0,lifetime[Address]=(unknown)@123}
  = always 0
  false always 0
Line 64
  ! always {!<=-1,!>=2}
Line 65
  nullptr always 0
Line 66
  vartok always !0
Line 67
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(vartok->astParent()),0}
  ".|::" always ".|::"
Line 69
  ! always {!<=-1,!>=2}
  parent possible symbolic=(vartok->astParent())
Line 70
  nullptr always 0
Line 71
  parent always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 72
  parent always !0
Line 73
  parent always !0
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  parent always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  "( %type% )" always "( %type% )"
Line 74
  parent always !0
Line 76
  * always {!<=-1,!>=2}
  unknown always !0
  = always 1
  true always 1
Line 78
  && always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
Line 79
  parent always !0
Line 80
  parent possible 0
Line 83
  ( always {!<=-1,!>=2}
Line 85
  ! {!<=-1,!>=2,1@60}
  tok possible 0@60
Line 86
  return always {!<=-1,!>=2}
  true always 1
Line 87
  ( always {!<=-1,!>=2}
  "*|&|." always "*|&|."
Line 89
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  mUninitDiags possible lifetime[Object]=(tok)
Line 98
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "%type% %var% ;" always "%type% %var% ;"
Line 99
  ( always !0
Line 103
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 104
  ( always {!<=-1,!>=2}
Line 105
  & {lifetime[Address]=(symbolDatabase->scopeList),!0}
Line 112
  scope possible lifetime[Address]=(symbolDatabase->scopeList)@67
Line 113
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 1
  True always 1
  || always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
  "[({:]" always "[({:]"
Line 124
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
Line 125
  NO_ALLOC always 0
  0U always 0
Line 128
  ( always {!<=-1,!>=2}
  "%name% ) (" always "%name% ) ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  ") =" always ") ="
Line 129
  2 always 2
  NO_ALLOC always 0
  0U always 0
Line 133
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  tok always symbolic=(var.nameToken()->next())
Line 137
  ( always {!<=-1,!>=2}
  tok possible symbolic=(var.nameToken()->next())
  "] [" always "] ["
Line 139
  ( always {!<=-1,!>=2}
  "] =|{" always "] =|{"
Line 143
  stdtype always {!<=-1,!>=2}
  stdtype always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(arrayTypeDefs)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(arrayTypeDefs),end=0}
Line 145
  tok possible symbolic=(var.typeStartToken())
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok {symbolic=(var.typeStartToken()),!symbolic=(var.nameToken())}
  != always {!<=-1,!>=2}
  "<" always "<"
Line 146
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 147
  stdtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 149
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  stdtype always {!<=-1,!>=2}
Line 150
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "std :: array" always "std :: array"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 151
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
  ( always {!<=-1,!>=2}
Line 155
  tok possible 0
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 156
  tok always !0
Line 157
  ! {!<=-1,!>=2,1}
  tok possible 0
Line 160
  tok always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  "for (" always "for ("
  && always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ( always {!<=-1,!>=2}
  ARRAY always 3
  : always 0
  NO_ALLOC always 0
  true always 1
Line 164
  ( always {!<=-1,!>=2}
Line 165
  = always 3
  ARRAY always 3
Line 167
  init always {!<=-1,!>=2}
  init always {!<=-1,!>=2}
  = always 0
  false always 0
Line 169
  == always {!<=-1,!>=2}
  "=" always "="
Line 170
  init always {!<=-1,!>=2}
  = always 1
  true always 1
Line 174
  ! {!<=-1,!>=2,1,0}
  init {!<=-1,!>=2,0,1}
Line 175
  ( always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  & {lifetime[Address]=(alloc),!0}
  variableValue always size=0
Line 178
  stdtype always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 179
  = always 0
  NO_ALLOC always 0
Line 181
  ( always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  & {lifetime[Address]=(alloc),!0}
  alloc always 0
  variableValue always size=0
Line 188
  . always !0
Line 189
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%type% * %name% [,)]" always "%type% * %name% [,)]"
Line 191
  != always {!<=-1,!>=2}
Line 192
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %varid% =" always "[;{}] %varid% ="
Line 194
  2 always 2
Line 195
  ! always {!<=-1,!>=2}
Line 197
  allocFuncCallToken always !0
Line 198
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  allocFunc always !0
  . always {!<=-1,!>=2}
  initData always {!<=-1,!>=2}
Line 201
  -1 always -1
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 203
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 204
  = always 0
  NO_ALLOC always 0
Line 206
  ( always {!<=-1,!>=2}
  nullptr always 0
  nullptr always 0
  & {lifetime[Address]=(alloc),!0}
  alloc always 0
  variableValue always size=0
Line 217
  ( always {!<=-1,!>=2}
  typeToken possible symbolic=(structvar.typeStartToken())
  "%name% ::" always "%name% ::"
Line 218
  2 always 2
Line 220
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 221
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0U always 0
Line 223
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 224
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  :: always 1
  True always 1
Line 228
  innerunion always {!<=-1,!>=2}
  innerunion always {!<=-1,!>=2}
  = always 0
  false always 0
Line 230
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 231
  ( possible {<=symbolic=(innerScope->bodyEnd->linenr()),>=symbolic=(innerScope->bodyEnd->linenr()+1),<=symbolic=(innerScope->bodyStart->linenr()-1)}
  >= {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 232
  ( {>=symbolic=(innerScope->bodyStart->linenr()),!<=symbolic=(innerScope->bodyStart->linenr()-1)}
  <= always {!<=-1,!>=2}
Line 233
  innerunion always {!<=-1,!>=2}
  = always 1
  true always 1
Line 239
  ! {!<=-1,!>=2,0}
  innerunion {!<=-1,!>=2,1}
Line 240
  = always 0
  NO_ALLOC always 0
Line 242
  tok always symbolic=(tok2)
  == always {!<=-1,!>=2}
  "}" always "}"
Line 243
  tok2 always symbolic=(tok)
Line 245
  ( always {!<=-1,!>=2}
  tok2 possible symbolic=(tok)
  nullptr always 0
  nullptr always 0
  & {lifetime[Address]=(alloc),!0}
  alloc always 0
  variableValue always size=0
Line 254
  . always {!<=-1,!>=2}
  notEqual always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  notEqual always {!<=-1,!>=2}
Line 257
  ( always {!<=-1,!>=2}
Line 259
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  notEqual always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 261
  ( always {!<=-1,!>=2}
Line 263
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  notEqual always {!<=-1,!>=2}
  ? always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 268
  ! always {!<=-1,!>=2}
Line 271
  tok always !0
  ( always {!<=-1,!>=2}
Line 272
  tok always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 273
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 275
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 279
  tok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 280
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 281
  tok always !0
Line 282
  :: possible {symbolic=(variableValue.end()),end=0}
  it possible {symbolic=(variableValue.end()),end=0}
  = possible lifetime[Iterator]=(variableValue)
  ( possible lifetime[Iterator]=(variableValue)
  tok possible 0
  ? possible 4294967295
  tok always !0
  : always 4294967295
  ~ always 4294967295
  0U always 0
Line 283
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variableValue),end=0}
Line 284
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  it always {!symbolic=(variableValue.end()),!end=0}
  != always {!<=-1,!>=2}
  0LL always 0
Line 285
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  it always {!symbolic=(variableValue.end()),!end=0}
  == always {!<=-1,!>=2}
  0LL always 0
Line 289
  tok always !0
  ( always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
Line 295
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 297
  = always !0
  ( always !0
Line 298
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 300
  = always !0
  ( always !0
Line 305
  vartok possible {symbolic=(tok->astOperand1()),symbolic=(tok->astOperand2())}
  && always {!<=-1,!>=2}
  vartok always !0
  == always {!<=-1,!>=2}
  "." always "."
Line 306
  vartok always !0
Line 308
  :: possible {symbolic=(variableValue.end()),end=0}
  it possible {symbolic=(variableValue.end()),end=0}
  = {lifetime[Iterator]=(variableValue),!size=0}
  variableValue always !size=0
  ( {lifetime[Iterator]=(variableValue),!size=0}
  vartok possible 0
  ? possible 4294967295
  vartok always !0
  : always 4294967295
  ~ always 4294967295
  0U always 0
Line 309
  == always {!<=-1,!>=2}
  variableValue always !size=0
  ( {lifetime[Iterator]=(variableValue),!size=0,end=0}
Line 312
  ( possible size=2
  == always {!<=-1,!>=2}
  "==" always "=="
Line 313
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  it always {!symbolic=(variableValue.end()),!end=0}
  == always {!<=-1,!>=2}
Line 314
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 315
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  it always {!symbolic=(variableValue.end()),!end=0}
  != always {!<=-1,!>=2}
Line 318
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  * {symbolic=(it->second==MathLib::toLongNumber(numtok->str())),symbolic=(it->second!=MathLib::toLongNumber(numtok->str())),!<=-1,!>=2}
Line 321
  tok always !0
  ( possible size=2
  == {!<=-1,!>=2,0}
  "!" always "!"
Line 322
  t always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
  = always 0
  false always 0
  f always {!<=-1,!>=2}
  f always {!<=-1,!>=2}
  = always 0
  false always 0
Line 323
  tok always !0
  & {lifetime[Address]=(t),!0}
  t always 0
  & {lifetime[Address]=(f),!0}
  f always 0
Line 324
  t always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  f always {!<=-1,!>=2}
Line 325
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 326
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  f always {!<=-1,!>=2}
Line 330
  tok always !0
  ( possible size=2
  == always {!<=-1,!>=2}
  "||" always "||"
Line 331
  t1 always {!<=-1,!>=2}
  t1 always {!<=-1,!>=2}
  = always 0
  false always 0
  f1 always {!<=-1,!>=2}
  f1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 332
  tok always !0
  & {lifetime[Address]=(t1),!0}
  t1 always 0
  & {lifetime[Address]=(f1),!0}
  f1 always 0
Line 333
  t2 always {!<=-1,!>=2}
  t2 always {!<=-1,!>=2}
  = always 0
  false always 0
  f2 always {!<=-1,!>=2}
  f2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 334
  ! always {!<=-1,!>=2}
  t1 always {!<=-1,!>=2}
Line 335
  tok always !0
  & {lifetime[Address]=(t2),!0}
  t2 always {!<=-1,!>=2}
  & {lifetime[Address]=(f2),!0}
  f2 always {!<=-1,!>=2}
Line 336
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  t1 {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  t2 always {!<=-1,!>=2}
Line 337
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  f1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  f2 always {!<=-1,!>=2}
Line 340
  tok always !0
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 341
  t1 always {!<=-1,!>=2}
  t1 always {!<=-1,!>=2}
  = always 0
  false always 0
  f1 always {!<=-1,!>=2}
  f1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 342
  tok always !0
  & {lifetime[Address]=(t1),!0}
  t1 always 0
  & {lifetime[Address]=(f1),!0}
  f1 always 0
Line 343
  t2 always {!<=-1,!>=2}
  t2 always {!<=-1,!>=2}
  = always 0
  false always 0
  f2 always {!<=-1,!>=2}
  f2 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 344
  ! always {!<=-1,!>=2}
  f1 always {!<=-1,!>=2}
Line 345
  tok always !0
  & {lifetime[Address]=(t2),!0}
  t2 always {!<=-1,!>=2}
  & {lifetime[Address]=(f2),!0}
  f2 always {!<=-1,!>=2}
Line 346
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  t1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  t2 always {!<=-1,!>=2}
Line 347
  * always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  f1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  f2 always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 353
  ! always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  false always 0
Line 355
  tok always !0
  == always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
Line 356
  return always {!<=-1,!>=2}
  false always 0
Line 357
  tok always !0
  ( always {!<=-1,!>=2}
Line 358
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 359
  != always {!<=-1,!>=2}
Line 360
  return always {!<=-1,!>=2}
  false always 0
Line 361
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  true always 1
Line 365
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  "[?:]" always "[?:]"
Line 368
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  "*|[" always "*|["
Line 369
  return always {!<=-1,!>=2}
  false always 0
Line 372
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  parent2 always symbolic=(parent->astParent())
  || always {!<=-1,!>=2}
  parent2 {symbolic=(parent->astParent()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  parent2 {symbolic=(parent->astParent()),!0}
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  parent2 {symbolic=(parent->astParent()),!0}
  == always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  suppressErrors always {!<=-1,!>=2}
  possibleInit possible {lifetime[Address]=(possibleInitInner)@197,lifetime[Address]=(possibleInitIf)@239,lifetime[Address]=(possibleInitElse)@2,0@229}
  && always {!<=-1,!>=2}
  * always {!<=-1,!>=2}
  possibleInit inconclusive {lifetime[Address]=(possibleInitInner)@197,lifetime[Address]=(possibleInitIf)@239,lifetime[Address]=(possibleInitElse)@2}
Line 378
  printDebug always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  debugwarnings always {!<=-1,!>=2}
Line 380
  possibleInit inconclusive {lifetime[Address]=(possibleInitInner)@197,lifetime[Address]=(possibleInitIf)@239,lifetime[Address]=(possibleInitElse)@2,0@229}
Line 381
  * always {!<=-1,!>=2}
  possibleInit inconclusive {lifetime[Address]=(possibleInitInner)@197,lifetime[Address]=(possibleInitIf)@239,lifetime[Address]=(possibleInitElse)@2}
  = always 0
  false always 0
Line 383
  = always 0
  0 always 0
Line 385
  == always {!<=-1,!>=2}
  0U always 0
Line 386
  return always {!<=-1,!>=2}
  true always 1
Line 390
  == always {!<=-1,!>=2}
  "}" always "}"
Line 391
  && always {!<=-1,!>=2}
Line 392
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 395
  ( always {!<=-1,!>=2}
Line 397
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 398
  return always {!<=-1,!>=2}
  false always 0
Line 405
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ",|;|{|}|]|try" always ",|;|{|}|]|try"
Line 406
  possibleInitInner always {!<=-1,!>=2}
  possibleInitInner always {!<=-1,!>=2}
  = always 0
  false always 0
Line 407
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(possibleInitInner),!0}
  possibleInitInner always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  true always 1
Line 410
  possibleInitInner always {!<=-1,!>=2}
Line 411
  = always 1
  1 always 1
Line 413
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 419
  ( always {!<=-1,!>=2}
  "[;{}] %var% = - %name% ;" always "[;{}] %var% = - %name% ;"
Line 420
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 423
  ( always {!<=-1,!>=2}
  "if (" always "if ("
Line 424
  alwaysTrue always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 425
  alwaysFalse always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
  = always 0
  false always 0
Line 428
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 429
  1 always 1
  != always {!<=-1,!>=2}
Line 430
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 431
  return always {!<=-1,!>=2}
  true always 1
Line 435
  & {lifetime[Address]=(alwaysTrue),!0}
  alwaysTrue always {!<=-1,!>=2}
  & {lifetime[Address]=(alwaysFalse),!0}
  alwaysFalse always {!<=-1,!>=2}
Line 438
  ! always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 439
  return always {!<=-1,!>=2}
  true always 1
Line 442
  = always 0
  0 always 0
Line 443
  0 always 0
Line 444
  = always 0
  nullptr always 0
Line 445
  alwaysFalse always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
  "if (" always "if ("
  && always {!<=-1,!>=2}
Line 448
  "!=" always "!="
  "0" always "0"
  & {lifetime[Address]=(condVarTok),!0}
Line 449
  = possible lifetime[Iterator]=(variableValue)
  ( possible lifetime[Iterator]=(variableValue)
Line 450
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variableValue),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  0 always 0
Line 451
  return always {!<=-1,!>=2}
  true always 1
Line 454
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 456
  ( always {!<=-1,!>=2}
  "if (" always "if ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "==|!=" always "==|!="
Line 458
  condition always symbolic=(tok->next()->astOperand2())
Line 459
  condition always symbolic=(tok->next()->astOperand2())
Line 460
  lhs always symbolic=(condition->astOperand1())
  && always {!<=-1,!>=2}
  lhs always symbolic=(condition->astOperand1())
  ( always {!<=-1,!>=2}
  rhs always symbolic=(condition->astOperand2())
  : always {symbolic=(condition->astOperand1()),symbolic=(condition->astOperand2())}
  lhs always symbolic=(condition->astOperand1())
Line 461
  lhs always symbolic=(condition->astOperand1())
  == always {!<=-1,!>=2}
  vartok always symbolic=((lhs&&lhs->hasKnownIntValue())?rhs:lhs)
  rhs always symbolic=(condition->astOperand2())
  : always {symbolic=(condition->astOperand1()),symbolic=(condition->astOperand2())}
  lhs always symbolic=(condition->astOperand1())
Line 462
  ( always {!<=-1,!>=2}
  vartok possible symbolic=((lhs&&lhs->hasKnownIntValue())?rhs:lhs)
  "." always "."
Line 464
  vartok possible symbolic=((lhs&&lhs->hasKnownIntValue())?rhs:lhs)
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 465
  = possible lifetime[Iterator]=(variableValue)
  ( possible lifetime[Iterator]=(variableValue)
Line 466
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variableValue),end=0}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  true always 1
Line 470
  condition always symbolic=(tok->next()->astOperand2())
  == always {!<=-1,!>=2}
  "!=" always "!="
Line 471
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 478
  ! always {!<=-1,!>=2}
Line 480
  == always {!<=-1,!>=2}
  "{" always "{"
Line 481
  possibleInitIf always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 482
  noreturnIf always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
  = always 0
  false always 0
Line 483
  initif always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(possibleInitIf),!0}
  possibleInitIf always {!<=-1,!>=2}
  & {lifetime[Address]=(noreturnIf),!0}
  noreturnIf always {!<=-1,!>=2}
Line 489
  ! always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 490
  printDebug always {!<=-1,!>=2}
Line 492
  -1 always -1
  != always {!<=-1,!>=2}
Line 494
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 495
  ' ' always 32
Line 497
  :: always 7
  debug always 7
  "bailoutUninitVar" always "bailoutUninitVar"
  "bailout uninitialized variable checking for '" always "bailout uninitialized variable checking for '"
  "'. can't determine if this condition can be false when previous condition is false: " always "'. can't determine if this condition can be false when previous condition is false: "
Line 499
  return always {!<=-1,!>=2}
  true always 1
Line 502
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  initif always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  true always 1
Line 506
  ! always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  initif always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
Line 507
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
  "[;{}.] %name% = - %name% ;" always "[;{}.] %name% = - %name% ;"
Line 509
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 510
  ( always {!<=-1,!>=2}
  "[;{}.] %name% = %num% ;" always "[;{}.] %name% = %num% ;"
Line 511
  3 always 3
Line 515
  initif always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 516
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 521
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 522
  initif always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  possibleInitIf always {!<=-1,!>=2}
Line 524
  >= always {!<=-1,!>=2}
  2 always 2
Line 525
  return always {!<=-1,!>=2}
  true always 1
Line 529
  2 always 2
Line 531
  possibleInitElse always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  alwaysFalse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 532
  noreturnElse always {!<=-1,!>=2}
  noreturnElse always {!<=-1,!>=2}
  = always 0
  false always 0
Line 533
  initelse always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(possibleInitElse),!0}
  possibleInitElse always {!<=-1,!>=2}
  & {lifetime[Address]=(noreturnElse),!0}
  noreturnElse always {!<=-1,!>=2}
Line 536
  ! always {!<=-1,!>=2}
  alwaysTrue always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  initelse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnElse always {!<=-1,!>=2}
Line 537
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
  "[;{}.] %var% = - %name% ;" always "[;{}.] %var% = - %name% ;"
Line 539
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  0 always 0
Line 540
  ( always {!<=-1,!>=2}
  "[;{}.] %var% = %num% ;" always "[;{}.] %var% = %num% ;"
Line 541
  3 always 3
Line 545
  initelse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnElse always {!<=-1,!>=2}
Line 551
  alwaysFalse always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  initif always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 552
  alwaysTrue always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  initelse always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  noreturnElse always {!<=-1,!>=2}
Line 553
  return always {!<=-1,!>=2}
  true always 1
Line 555
  initif always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  initelse always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  possibleInitElse always {!<=-1,!>=2}
Line 557
  ! always {!<=-1,!>=2}
  initif always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnIf always {!<=-1,!>=2}
Line 558
  ( {lifetime[Iterator]=(varValueIf),start=0}
  ( {lifetime[Iterator]=(varValueIf),end=0}
Line 559
  ! always {!<=-1,!>=2}
  initelse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  noreturnElse always {!<=-1,!>=2}
Line 560
  ( {lifetime[Iterator]=(varValueElse),start=0}
  ( {lifetime[Iterator]=(varValueElse),end=0}
Line 566
  ( always {!<=-1,!>=2}
  "= {" always "= {"
Line 571
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 572
  2 always 2
  "%varid%" always "%varid%"
  end always symbolic=(tok->next()->link())
Line 573
  return always {!<=-1,!>=2}
  true always 1
Line 574
  2 always 2
  "& %varid%" always "& %varid%"
  end always symbolic=(tok->next()->link())
Line 575
  return always {!<=-1,!>=2}
  true always 1
Line 578
  = always 0
  nullptr always 0
Line 580
  [ possible {lifetime[Lambda]=(var),lifetime[Lambda]=(errorToken)}
Line 581
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 582
  :: always 0
  none always 0
Line 583
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 584
  :: always 3
  op1_and_op2 always 3
Line 585
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid%" always "%varid%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 587
  :: always 4
  done always 4
Line 589
  :: always 0
  none always 0
Line 593
  "." always "."
Line 594
  return always {!<=-1,!>=2}
  true always 1
Line 598
  = always symbolic=(tok->next()->link())
  end always symbolic=(tok->next()->link())
Line 603
  ( always {!<=-1,!>=2}
Line 604
  1 always 1
Line 607
  ( always {!<=-1,!>=2}
  "for|while (" always "for|while ("
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 608
  forwhile always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "for|while (" always "for|while ("
Line 611
  forwhile always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "for" always "for"
  false always 0
Line 612
  return always {!<=-1,!>=2}
  true always 1
Line 615
  forwhile always {!<=-1,!>=2}
Line 617
  tok2 always symbolic=(forwhile?tok->next()->link()->next():tok->next())
  && always {!<=-1,!>=2}
  tok2 always symbolic=(forwhile?tok->next()->link()->next():tok->next())
  == always {!<=-1,!>=2}
  "{" always "{"
Line 618
  init always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(forwhile?tok->next()->link()->next():tok->next())
  > always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 621
  init always {!<=-1,!>=2}
Line 622
  return always {!<=-1,!>=2}
  true always 1
Line 625
  initcond always {!<=-1,!>=2}
  initcond always {!<=-1,!>=2}
  = always 0
  false always 0
Line 626
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 627
  forwhile always {!<=-1,!>=2}
  2 always 2
Line 628
  initcond always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
  ( always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 632
  tok2 always symbolic=(forwhile?tok->next()->link()->next():tok->next())
Line 635
  ! always {!<=-1,!>=2}
  forwhile always {!<=-1,!>=2}
Line 637
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok2->link())
  "} while (" always "} while ("
Line 638
  printDebug always {!<=-1,!>=2}
Line 639
  tok always symbolic=(tok2->link())
  :: always 7
  debug always 7
  "" always ""
  "assertion failed '} while ('" always "assertion failed '} while ('"
Line 644
  tok always symbolic=(tok2->link())
  2 always 2
Line 646
  ! always {!<=-1,!>=2}
Line 650
  initcond always {!<=-1,!>=2}
Line 652
  return always {!<=-1,!>=2}
  true always 1
Line 658
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% {" always "%name% {"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "try" always "try"
Line 659
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "union" always "union"
Line 660
  1 always 1
Line 663
  return always {!<=-1,!>=2}
  true always 1
Line 667
  ( always {!<=-1,!>=2}
  tok possible symbolic=(tok2->link())
  "( {" always "( {"
Line 668
  return always {!<=-1,!>=2}
  true always 1
Line 672
  ( always {!<=-1,!>=2}
  "asm|setjmp (" always "asm|setjmp ("
Line 673
  return always {!<=-1,!>=2}
  true always 1
Line 677
  ( always {!<=-1,!>=2}
  "[;{}] %name% :" always "[;{}] %name% :"
Line 678
  return always {!<=-1,!>=2}
  true always 1
Line 681
  == always {!<=-1,!>=2}
  "?" always "?"
Line 682
  ! always {!<=-1,!>=2}
Line 683
  return always {!<=-1,!>=2}
  true always 1
Line 684
  used1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 685
  used0 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 686
  err always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  ? always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
Line 687
  err {symbolic=((number_of_if==0)?(used1||used0):(used1&&used0)),!<=-1,!>=2}
Line 691
  return always {!<=-1,!>=2}
  true always 1
Line 694
  ( always {!<=-1,!>=2}
  "return|break|continue|throw|goto" always "return|break|continue|throw|goto"
Line 696
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 699
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 701
  == always {!<=-1,!>=2}
Line 702
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 703
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% . %name%" always "%name% . %name%"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%cop%|return|throw|?" always "%cop%|return|throw|?"
Line 704
  "." always "."
Line 705
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%" always "%name%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "return|throw|?" always "return|throw|?"
Line 706
  "." always "."
Line 710
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 713
  return always {!<=-1,!>=2}
  true always 1
Line 716
  ( always {!<=-1,!>=2}
Line 717
  1 always 1
Line 719
  == always {!<=-1,!>=2}
  "?" always "?"
Line 720
  ! always {!<=-1,!>=2}
Line 721
  return always {!<=-1,!>=2}
  true always 1
Line 722
  used1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 723
  used0 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 724
  err always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  ? always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
Line 725
  err {symbolic=((number_of_if==0)?(used1||used0):(used1&&used0)),!<=-1,!>=2}
Line 727
  return always {!<=-1,!>=2}
  true always 1
Line 733
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 737
  == always {!<=-1,!>=2}
Line 739
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
Line 741
  rhs possible symbolic=(tok->next()->astOperand2())
  && always {!<=-1,!>=2}
  rhs possible symbolic=(tok->next()->astOperand2())
  ( always {!<=-1,!>=2}
Line 743
  rhs possible symbolic=(tok->next()->astOperand2())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 745
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  initData always {!<=-1,!>=2}
Line 746
  = always 1
  NO_CTOR_CALL always 1
Line 751
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  True always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "= new" always "= new"
Line 752
  = always 2
  CTOR_CALL always 2
Line 755
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
Line 756
  return always {!<=-1,!>=2}
  true always 1
Line 759
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 761
  ( always {!<=-1,!>=2}
  "= new %type% (" always "= new %type% ("
Line 762
  return always {!<=-1,!>=2}
  true always 1
Line 765
  ( always {!<=-1,!>=2}
  "= new %type% [" always "= new %type% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  4 always 4
  "] (" always "] ("
Line 766
  return always {!<=-1,!>=2}
  true always 1
Line 773
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 774
  ( always {!<=-1,!>=2}
Line 776
  return always {!<=-1,!>=2}
  true always 1
Line 779
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 780
  "." always "."
Line 781
  return always {!<=-1,!>=2}
  true always 1
Line 784
  ( always {!<=-1,!>=2}
  "[(,] %name% [,)]" always "[(,] %name% [,)]"
Line 785
  return always {!<=-1,!>=2}
  true always 1
Line 787
  ( always {!<=-1,!>=2}
  "= %var% . %var% ;" always "= %var% . %var% ;"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 788
  return always {!<=-1,!>=2}
  true always 1
Line 792
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 794
  return always {!<=-1,!>=2}
  true always 1
Line 799
  parent possible symbolic=(tok)
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  && always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  == always {!<=-1,!>=2}
  "[" always "["
  || always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 801
  == always {!<=-1,!>=2}
  "[" always "["
Line 802
  == always {!<=-1,!>=2}
  0 always 0
Line 803
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  true always 1
Line 809
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok)
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 811
  eq always symbolic=(parent->astParent())
  == always {!<=-1,!>=2}
  0 always 0
Line 812
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 814
  return always {!<=-1,!>=2}
  true always 1
Line 819
  return always {!<=-1,!>=2}
  true always 1
Line 825
  return always {!<=-1,!>=2}
  false always 0
Line 828
  , always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 830
  ! always {!<=-1,!>=2}
Line 831
  nullptr always 0
Line 832
  ( always {!<=-1,!>=2}
  tok always !0
Line 833
  nullptr always 0
Line 835
  tok always !0
Line 836
  bailout1 always {!<=-1,!>=2}
  bailout1 always {!<=-1,!>=2}
  = always 0
  false always 0
Line 837
  tok always !0
  ( always !0
  known {!<=-1,!>=2,0}
  & {lifetime[Address]=(bailout1),!0}
  bailout1 always 0
Line 838
  && always {!<=-1,!>=2}
  bailout1 always {!<=-1,!>=2}
Line 839
  * always {!<=-1,!>=2}
  bailout always !0
  = always 1
  true always 1
Line 841
  errorToken always !0
Line 842
  bailout1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%oror%|&&|?" always "%oror%|&&|?"
Line 843
  nullptr always 0
Line 845
  tok always !0
Line 846
  tok always !0
  ( always !0
  known always {!<=-1,!>=2}
Line 847
  == always {!<=-1,!>=2}
Line 848
  ( always {!<=-1,!>=2}
Line 850
  errorToken always !0
Line 852
  * always {!<=-1,!>=2}
  bailout always !0
  = always 1
  true always 1
Line 854
  nullptr always 0
Line 857
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isuninit always {!<=-1,!>=2}
Line 860
  ( always {!<=-1,!>=2}
  "( ! %name% %oror%" always "( ! %name% %oror%"
  && always {!<=-1,!>=2}
  2 always 2
  0 always 0
Line 861
  suppressErrors always {!<=-1,!>=2}
  = always 1
  true always 1
Line 862
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
  endpar always symbolic=(startparentheses->link())
Line 863
  == always {!<=-1,!>=2}
Line 864
  ( always {!<=-1,!>=2}
  "%name% . %name%" always "%name% . %name%"
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  true always 1
Line 867
  2 always 2
  == always {!<=-1,!>=2}
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  true always 1
Line 871
  ! always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 872
  "." always "."
Line 877
  ( always {!<=-1,!>=2}
Line 878
  suppressErrors always {!<=-1,!>=2}
Line 880
  errorToken always !0
  errorToken always !0
Line 882
  return always {!<=-1,!>=2}
  true always 1
Line 885
  ( always {!<=-1,!>=2}
Line 886
  1 always 1
Line 887
  ! always {!<=-1,!>=2}
  isuninit always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 888
  suppressErrors always {!<=-1,!>=2}
  = always 1
  true always 1
Line 890
  return always {!<=-1,!>=2}
  false always 0
Line 894
  bailout always {!<=-1,!>=2}
Line 896
  start possible symbolic=(top->link()->next())@119
  == always {!<=-1,!>=2}
  "{" always "{"
Line 898
  = always 0
  nullptr always 0
Line 900
  start possible symbolic=(top->link()->next())@119
Line 901
  start possible symbolic=(top->link()->next())@119
  != always {!<=-1,!>=2}
  end always symbolic=(start->link())
  tok possible symbolic=(errorToken)
Line 903
  ( always {!<=-1,!>=2}
Line 904
  1 always 1
Line 908
  ( always {!<=-1,!>=2}
  "asm ( %str% ) ;" always "asm ( %str% ) ;"
Line 909
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 910
  nullptr always 0
Line 914
  == always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 916
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always symbolic=(tok->astParent()->astParent())
  "for (" always "for ("
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top always symbolic=(tok->astParent()->astParent())
  ") {" always ") {"
Line 918
  top always symbolic=(tok->astParent()->astParent())
Line 919
  bodyStart always symbolic=(top->link()->next())
  bailout always {!<=-1,!>=2}
Line 920
  ! always {!<=-1,!>=2}
Line 922
  bailout always {!<=-1,!>=2}
Line 923
  nullptr always 0
Line 926
  ( always {!<=-1,!>=2}
  ") {" always ") {"
  && always {!<=-1,!>=2}
Line 927
  ( always {!<=-1,!>=2}
  "for (" always "for ("
  && always {!<=-1,!>=2}
Line 928
  ( always {!<=-1,!>=2}
  ";" always ";"
  && always {!<=-1,!>=2}
Line 929
  ( always {!<=-1,!>=2}
  ";" always ";"
Line 930
  1 always 1
Line 933
  == always {!<=-1,!>=2}
  "{" always "{"
Line 935
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 936
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 937
  nullptr always 0
Line 940
  bailout always {!<=-1,!>=2}
Line 942
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 943
  2 always 2
Line 944
  bailout always {!<=-1,!>=2}
Line 946
  && always {!<=-1,!>=2}
Line 947
  errorToken1 always !0
Line 948
  errorToken2 possible 0
Line 949
  = always !0
  errorToken2 always !0
Line 951
  bailout always {!<=-1,!>=2}
Line 952
  nullptr always 0
Line 953
  ! always {!<=-1,!>=2}
Line 957
  != always {!<=-1,!>=2}
Line 960
  conditionalUsage always {!<=-1,!>=2}
  conditionalUsage always {!<=-1,!>=2}
  = always 0
  false always 0
Line 962
  ( always {!<=-1,!>=2}
  "%oror%|&&|?" always "%oror%|&&|?"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 963
  conditionalUsage always {!<=-1,!>=2}
  = always 1
  true always 1
Line 968
  ! {!<=-1,!>=2,0}
  membervar possible size=0
  ( {!<=-1,!>=2,1}
Line 969
  ( always {!<=-1,!>=2}
  membervar always !size=0
Line 970
  assign always {!<=-1,!>=2}
  assign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 971
  rhs always {!<=-1,!>=2}
  rhs always {!<=-1,!>=2}
  = always 0
  false always 0
Line 973
  = always 0
  nullptr always 0
Line 975
  tok2 possible symbolic=(rpar)
  ( possible size=1
  == always {!<=-1,!>=2}
  "=" always "="
Line 976
  rhs always {!<=-1,!>=2}
  = always 1
  true always 1
Line 979
  ! {!<=-1,!>=2,1}
  rpar possible {symbolic=(tok2),0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "(" always "("
Line 981
  tok2 possible symbolic=(rpar)
  == always {!<=-1,!>=2}
  ")" always ")"
Line 983
  ! always {!<=-1,!>=2}
  rpar possible symbolic=(tok2)
Line 985
  rpar always !0
  == always {!<=-1,!>=2}
Line 986
  = always 0
  nullptr always 0
Line 989
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
Line 991
  rhs always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 992
  assign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 996
  assign {!<=-1,!>=2,1,0}
Line 997
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 998
  nullptr always 0
Line 1001
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1002
  ! always {!<=-1,!>=2}
  conditionalUsage always {!<=-1,!>=2}
Line 1004
  ! always {!<=-1,!>=2}
Line 1006
  ( always {!<=-1,!>=2}
  "[(,] %name% [,)]" always "[(,] %name% [,)]"
Line 1007
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1008
  nullptr always 0
Line 1011
  ( always {!<=-1,!>=2}
Line 1012
  ! always {!<=-1,!>=2}
  conditionalUsage always {!<=-1,!>=2}
Line 1013
  errtok always !0
Line 1014
  ! always {!<=-1,!>=2}
Line 1015
  = always !0
  errtok always !0
Line 1016
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1017
  varIsUsedInRhs {!<=-1,!>=2,0}
  varIsUsedInRhs always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1018
  [ possible {lifetime[Lambda]=(var),lifetime[Lambda]=(varIsUsedInRhs)}
Line 1019
  ! always {!<=-1,!>=2}
Line 1020
  :: always 0
  none always 0
Line 1021
  t always !0
  == always {!<=-1,!>=2}
Line 1022
  varIsUsedInRhs always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1023
  :: always 4
  done always 4
Line 1025
  ( always {!<=-1,!>=2}
  t always !0
Line 1026
  :: always 0
  none always 0
Line 1027
  :: always 3
  op1_and_op2 always 3
Line 1029
  ! always {!<=-1,!>=2}
  varIsUsedInRhs always {!<=-1,!>=2}
Line 1030
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1031
  nullptr always 0
Line 1034
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1035
  nullptr always 0
Line 1040
  errorToken possible 0
Line 1043
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  suppressErrors always {!<=-1,!>=2}
Line 1045
  bailout always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1046
  tok possible symbolic=(forwhile?tok->next()->link()->next():tok->next())@45
  bailout always 0
Line 1048
  ! {!<=-1,!>=2,1@45,0@45}
  suppressErrors {!<=-1,!>=2,0@45,1@45}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1049
  ( always {!<=-1,!>=2}
Line 1050
  errorToken always !0
  errorToken always !0
Line 1052
  errorToken always !0
  errorToken always !0
  "." always "."
Line 1053
  return always {!<=-1,!>=2}
  true always 1
Line 1056
  return always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
Line 1061
  rhs always {!<=-1,!>=2}
  rhs always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1062
  = always 0
  0 always 0
Line 1063
  nullptr always 0
  != always {!<=-1,!>=2}
Line 1064
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1065
  rhs always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1066
  rhs always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
Line 1067
  membervar possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
Line 1068
  tok always !0
  tok always !0
Line 1069
  ! {!<=-1,!>=2,0}
  membervar possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always {!<=-1,!>=2}
  membervar always !size=0
Line 1070
  tok always !0
  tok always !0
  "." always "."
Line 1071
  ( always {!<=-1,!>=2}
  tok always !0
  "%var% =" always "%var% ="
Line 1073
  ( always {!<=-1,!>=2}
  tok always !0
  "[(,&]" always "[(,&]"
Line 1075
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 1077
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1079
  tok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1080
  == always {!<=-1,!>=2}
  0 always 0
Line 1082
  -- always !-1
  indent always !0
Line 1083
  tok always !0
  == always {!<=-1,!>=2}
  "?" always "?"
  && always {!<=-1,!>=2}
  tok always !0
Line 1084
  used1 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 1085
  used0 always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 1086
  err always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  ? always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  used1 always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  used0 always {!<=-1,!>=2}
Line 1087
  err {symbolic=((number_of_if==0)?(used1||used0):(used1&&used0)),!<=-1,!>=2}
Line 1088
  tok always !0
Line 1090
  ( always {!<=-1,!>=2}
  tok always !0
Line 1091
  tok always !0
  1 always 1
Line 1096
  ( always {!<=-1,!>=2}
Line 1098
  return always {!<=-1,!>=2}
  tok possible symbolic=(tok->astParent()->astOperand1())
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  == always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 1101
  ( always {!<=-1,!>=2}
Line 1103
  return always {!<=-1,!>=2}
  tok possible {symbolic=(tok->astParent()->astOperand2()),symbolic=(vartok)@155,symbolic=(valueExpr->astParent())@6,0@43}
  && always {!<=-1,!>=2}
  tok {!0,symbolic=(vartok)@155,symbolic=(valueExpr->astParent())@6}
  && always {!<=-1,!>=2}
  tok {!0,symbolic=(vartok)@155,symbolic=(valueExpr->astParent())@6}
  == always {!<=-1,!>=2}
  tok {!0,symbolic=(vartok)@155,symbolic=(valueExpr->astParent())@6}
  ( always !0
Line 1106
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {0@25,symbolic=(valueExpr->astParent())@232}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 7
  VOID always 7
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1111
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
Line 1114
  ( always {!<=-1,!>=2}
  valueExpr possible symbolic=(vartok)
  ".|::" always ".|::"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  valueExpr possible symbolic=(vartok)
Line 1117
  valueExpr possible symbolic=(vartok)
Line 1119
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 1120
  = always !0
  ( always !0
  ( always !0
Line 1122
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  "& )" always "& )"
Line 1123
  = always !0
  ( always !0
Line 1127
  ! {!<=-1,!>=2,0@3480}
  pointer {!<=-1,!>=2,1@3480}
Line 1128
  ( always {!<=-1,!>=2}
  "%name% [.(]" always "%name% [.(]"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1129
  nullptr always 0
Line 1130
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
Line 1133
  = always 0
  nullptr always 0
Line 1134
  alloc possible {0,2,3@3480}
  != {!<=-1,!>=2,0,1}
  NO_ALLOC always 0
Line 1135
  = always !<=-1
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  ? always !<=-1
  ( always !0
  ( always !<=-1
  : always 1
  1 always 1
Line 1136
  = always 0
  0 always 0
Line 1138
  ( always {!<=-1,!>=2}
  derefValue possible {symbolic=(valueExpr),symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  ( possible symbolic=(derefValue)
  "+|-|*|[|." always "+|-|*|[|."
  || always {!<=-1,!>=2}
Line 1139
  derefValue possible {symbolic=(valueExpr),symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  ( possible symbolic=(derefValue)
  && always {!<=-1,!>=2}
  derefValue possible {symbolic=(valueExpr),symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  ( {symbolic=(derefValue),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1140
  deref possible 0
  < always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  derefValue possible {symbolic=(valueExpr),symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  ( possible symbolic=(derefValue)
  "&" always "&"
  && always {!<=-1,!>=2}
  derefValue possible {symbolic=(valueExpr),symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  ( possible symbolic=(derefValue)
  ( always {!<=-1,!>=2}
Line 1142
  derefValueParent always symbolic=(derefValue->astParent())
  ( possible size=1
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1143
  derefValueParent always symbolic=(derefValue->astParent())
  ( always {!<=-1,!>=2}
  "*" always "*"
Line 1147
  derefValueParent always symbolic=(derefValue->astParent())
  ( possible size=1
  == always {!<=-1,!>=2}
  "[" always "["
Line 1148
  ( always {!<=-1,!>=2}
Line 1152
  ( always {!<=-1,!>=2}
  derefValueParent always symbolic=(derefValue->astParent())
  "[+-]" always "[+-]"
Line 1153
  >= always {!<=-1,!>=2}
Line 1155
  derefValueParent always symbolic=(derefValue->astParent())
  == always {!<=-1,!>=2}
  "." always "."
Line 1157
  = always symbolic=(derefValue->astParent())
  derefValueParent always symbolic=(derefValue->astParent())
Line 1158
  deref possible <=symbolic=(arrayDim-1)
  < {!<=-1,!>=2,1}
  arrayDim possible >=symbolic=(deref+1)
Line 1159
  = always {symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
  derefValue always {symbolic=(derefValueParent),symbolic=(derefValue->astParent())}
Line 1161
  < always {!<=-1,!>=2}
Line 1163
  = always 0
  nullptr always 0
Line 1165
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1166
  = always !0
  ( always !0
Line 1167
  child {symbolic=(vartok->astParent()),!0}
Line 1168
  parent possible {symbolic=(child->astParent()),0}
  && always {!<=-1,!>=2}
  parent {symbolic=(child->astParent()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  parent {symbolic=(child->astParent()),!0}
  == always {!<=-1,!>=2}
  "+" always "+"
Line 1169
  = always !0
  parent always !0
Line 1170
  child {symbolic=(parent),!0}
Line 1172
  parent possible {symbolic=(child->astParent()),0}
  && always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1173
  = always !0
  parent always !0
Line 1176
  ! always {!<=-1,!>=2}
Line 1177
  nullptr always 0
Line 1180
  derefValue possible 0
  && always {!<=-1,!>=2}
  derefValue always !0
  && always {!<=-1,!>=2}
  derefValue always !0
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1181
  nullptr always 0
Line 1184
  ( always {!<=-1,!>=2}
  ( always !0
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always !0
  -3 always -3
  "( %name% ) &" always "( %name% ) &"
Line 1185
  nullptr always 0
Line 1188
  ( always {!<=-1,!>=2}
Line 1189
  nullptr always 0
Line 1190
  ( always {!<=-1,!>=2}
  "." always "."
Line 1192
  ( always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
  "." always "."
Line 1194
  ( always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
Line 1195
  nullptr always 0
Line 1197
  alloc possible 2
  != {!<=-1,!>=2,1}
  NO_ALLOC always 0
Line 1198
  ( always {!<=-1,!>=2}
  "%comp%|%oror%|&&|?|!" always "%comp%|%oror%|&&|?|!"
Line 1199
  nullptr always 0
Line 1200
  ( always {!<=-1,!>=2}
  "%or%|&" always "%or%|&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1201
  nullptr always 0
Line 1202
  == always {!<=-1,!>=2}
  CTOR_CALL always 2
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  derefValue always !0
  "(" always "("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  derefValue always !0
Line 1203
  nullptr always 0
Line 1204
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 1205
  nullptr always 0
Line 1209
  ( always {!<=-1,!>=2}
  "[(,]" always "[(,]"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1211
  ( always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
  "," always ","
Line 1213
  ( always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
  "{" always "{"
Line 1215
  pointer always {!<=-1,!>=2}
Line 1216
  > always {!<=-1,!>=2}
  0 always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1218
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  derefValue always !0
  "[(,]" always "[(,]"
  && always {!<=-1,!>=2}
  derefValue always !0
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  derefValue always !0
Line 1219
  derefValue always !0
  false always 0
  NO_ALLOC always 0
Line 1220
  > always {!<=-1,!>=2}
  0 always 0
  ? possible 0
  derefValue always !0
  nullptr always 0
Line 1222
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1224
  ( always {!<=-1,!>=2}
  parent always symbolic=(valueExpr->astParent())
  "[(,]" always "[(,]"
  && always {!<=-1,!>=2}
  parent always symbolic=(valueExpr->astParent())
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(valueExpr->astParent())
Line 1225
  pointer always {!<=-1,!>=2}
Line 1226
  > always {!<=-1,!>=2}
  0 always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1228
  nullptr always 0
Line 1235
  = possible 1
  ? possible 1
  derefValue always !0
  : always 1
Line 1236
  alloc possible 0
  == {!<=-1,!>=2,1}
  NO_ALLOC always 0
Line 1237
  tok possible symbolic=(derefValue?derefValue:valueExpr)
  && always {!<=-1,!>=2}
  tok possible symbolic=(derefValue?derefValue:valueExpr)
  ( always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible symbolic=(derefValue?derefValue:valueExpr)
  "." always "."
Line 1240
  ( always {!<=-1,!>=2}
  tok possible symbolic=(derefValue?derefValue:valueExpr)
  "=" always "="
Line 1241
  ( always {!<=-1,!>=2}
Line 1242
  nullptr always 0
Line 1243
  != always {!<=-1,!>=2}
  NO_ALLOC always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1244
  nullptr always 0
Line 1249
  ( always {!<=-1,!>=2}
  derefValue possible 0
  "(|=" always "(|="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1250
  = possible 1
  ? possible 1
  derefValue always !0
  : always 1
Line 1251
  rhstok {symbolic=(derefValue?derefValue:vartok),1}
Line 1252
  lhstok always symbolic=(rhstok->astParent()->astOperand1())
Line 1253
  lhsvar always symbolic=(lhstok->variable())
  && always {!<=-1,!>=2}
  lhsvar {symbolic=(lhstok->variable()),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  lhsvar {symbolic=(lhstok->variable()),!0}
  == always {!<=-1,!>=2}
  lhstok always symbolic=(rhstok->astParent()->astOperand1())
Line 1254
  nullptr always 0
Line 1258
  ( always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
Line 1259
  && always {!<=-1,!>=2}
Line 1260
  ( always {!<=-1,!>=2}
  ( always !0
  "for (" always "for ("
Line 1261
  ( always {!<=-1,!>=2}
Line 1262
  nullptr always 0
Line 1265
  lhs {symbolic=(valueExpr->astParent()->astOperand1()),symbolic=(lhs->variable()->nameToken())}
  && always {!<=-1,!>=2}
  lhs {symbolic=(valueExpr->astParent()->astOperand1()),!0}
  && always {!<=-1,!>=2}
  lhs {symbolic=(valueExpr->astParent()->astOperand1()),!0}
  ( always !0
  == always {!<=-1,!>=2}
  lhs {symbolic=(valueExpr->astParent()->astOperand1()),!0}
  && always {!<=-1,!>=2}
  lhs always {symbolic=(valueExpr->astParent()->astOperand1()),symbolic=(lhs->variable()->nameToken())}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1266
  nullptr always 0
Line 1271
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "<<|>>" always "<<|>>"
Line 1272
  ( always {!<=-1,!>=2}
  cpp always 1
Line 1273
  nullptr always 0
Line 1276
  vt always !0
  . possible {9,11}
  == {!<=-1,!>=2,0}
  :: always 7
  VOID always 7
Line 1277
  nullptr always 0
Line 1279
  alloc possible 3
  == {!<=-1,!>=2,0}
  CTOR_CALL always 2
  || always {!<=-1,!>=2}
  alloc always !2
  == always {!<=-1,!>=2}
  ARRAY always 3
  && always {!<=-1,!>=2}
  vt always !0
  && always {!<=-1,!>=2}
  vt always !0
  . always !7
  != always {!<=-1,!>=2}
  :: always 9
  CHAR always 9
  && always {!<=-1,!>=2}
  vt always !0
  . always {!7,!9}
  != always {!<=-1,!>=2}
  :: always 11
  WCHAR_T always 11
Line 1280
  nullptr always 0
Line 1283
  ( always {!<=-1,!>=2}
  derefValue possible 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 1284
  nullptr always 0
Line 1287
  cpp always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1289
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(valueExpr->astParent()),0}
  "&" always "&"
  && always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
  ( always {!<=-1,!>=2}
Line 1291
  ! always {!<=-1,!>=2}
  parent possible symbolic=(valueExpr->astParent())
Line 1293
  ( always {!<=-1,!>=2}
  lhs possible {symbolic=(valueExpr->astParent()),0}
  "&" always "&"
  && always {!<=-1,!>=2}
  lhs possible symbolic=(valueExpr->astParent())
  ( always {!<=-1,!>=2}
Line 1295
  lhs possible symbolic=(valueExpr->astParent())
  && always {!<=-1,!>=2}
  lhs always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  lhs always !0
  || always {!<=-1,!>=2}
  lhs always !0
  ( always !0
  <= always {!<=-1,!>=2}
  :: always 5
  CONTAINER always 5
Line 1296
  nullptr always 0
Line 1300
  ? possible 1
  derefValue always !0
  : always 1
Line 1303
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
Line 1305
  ( always {!<=-1,!>=2}
  pointer {!<=-1,!>=2,1@13,0@96}
  alloc possible 3@13
Line 1314
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
Line 1316
  unknown always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1317
  & {lifetime[Address]=(unknown),!0}
  unknown always 0
Line 1318
  unknown always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,]" always "[(,]"
Line 1319
  -1 always -1
Line 1322
  = always 0
  0 always 0
Line 1324
  start possible {symbolic=(vartok),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start {symbolic=(vartok),!0}
  "[;{}(]" always "[;{}(]"
Line 1325
  start always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1326
  start always !0
Line 1327
  start always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 1331
  ! always {!<=-1,!>=2}
  start possible symbolic=(vartok)
Line 1332
  -1 always -1
Line 1334
  ( always {!<=-1,!>=2}
  start always !0
  ") {" always ") {"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !0
  "if|for|while|switch" always "if|for|while|switch"
Line 1335
  ! always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  NO_ALLOC always 0
Line 1338
  ( always {!<=-1,!>=2}
  start always !0
  "%name% (" always "%name% ("
Line 1339
  address {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1340
  array {!<=-1,!>=2,0}
  ( inconclusive 0
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1342
  start always !0
Line 1343
  func always symbolic=(start->previous()->function())
Line 1344
  func {symbolic=(start->previous()->function()),!0}
Line 1346
  arg always !0
Line 1347
  ! {!<=-1,!>=2,1}
  address {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  array always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argStart always symbolic=(arg->typeStartToken())
  "%type% %name%| [,)]" always "%type% %name%| [,)]"
Line 1348
  1 always 1
Line 1349
  pointer {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  NO_ALLOC always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  argStart always symbolic=(arg->typeStartToken())
  "%type% * %name% [,)]" always "%type% * %name% [,)]"
Line 1350
  1 always 1
Line 1351
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1352
  = always !0
  ( always !0
Line 1353
  ( always {!<=-1,!>=2}
  "const %type% & %name% [,)]" always "const %type% & %name% [,)]"
Line 1355
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 3
  RECORD always 3
Line 1356
  -1 always -1
Line 1357
  1 always 1
Line 1359
  pointer always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "const %type% %name% [" always "const %type% %name% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  3 always 3
  "] [,)]" always "] [,)]"
Line 1360
  1 always 1
Line 1363
  ( always {!<=-1,!>=2}
  start always !0
  "if|while|for" always "if|while|for"
Line 1365
  == always {!<=-1,!>=2}
  NO_ALLOC always 0
Line 1367
  isnullbad always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  start always !0
  1 always 1
Line 1368
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isnullbad always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  NO_ALLOC always 0
Line 1369
  1 always 1
Line 1370
  hasIndirect always {!<=-1,!>=2}
  hasIndirect always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1371
  isuninitbad always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
  & {lifetime[Address]=(hasIndirect),!0}
  hasIndirect always 0
Line 1372
  != always {!<=-1,!>=2}
  NO_ALLOC always 0
Line 1373
  isnullbad always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  hasIndirect always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isuninitbad always {!<=-1,!>=2}
Line 1374
  isuninitbad always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  address always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isnullbad always {!<=-1,!>=2}
Line 1379
  -1 always -1
Line 1382
  , always {!<=-1,!>=2}
  pointer always {!<=-1,!>=2}
Line 1384
  pointer {!<=-1,!>=2,0@105}
  alloc possible 0@105
Line 1387
  ( always {!<=-1,!>=2}
Line 1389
  ( always {!<=-1,!>=2}
  "%name% . %name%" always "%name% . %name%"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
Line 1390
  ( always {!<=-1,!>=2}
  3 always 3
  "[=.[]" always "[=.[]"
Line 1391
  return always {!<=-1,!>=2}
  true always 1
Line 1392
  ( always {!<=-1,!>=2}
  -2 always -2
  "[(,=] &" always "[(,=] &"
Line 1393
  return always {!<=-1,!>=2}
  true always 1
Line 1394
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( possible 0
Line 1395
  return always {!<=-1,!>=2}
  true always 1
Line 1396
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[|=" always "[|="
Line 1398
  3 always 3
  ( always {!<=-1,!>=2}
Line 1400
  ( always {!<=-1,!>=2}
  "[(,] %name% . %name% [,)]" always "[(,] %name% . %name% [,)]"
  && always {!<=-1,!>=2}
Line 1401
  1 always 1
  == always {!<=-1,!>=2}
  false always 0
  NO_ALLOC always 0
Line 1402
  return always {!<=-1,!>=2}
  false always 0
Line 1404
  return always {!<=-1,!>=2}
  true always 1
Line 1405
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1406
  return always {!<=-1,!>=2}
  true always 1
Line 1407
  ( always {!<=-1,!>=2}
  "%var% . %name% (" always "%var% . %name% ("
Line 1408
  2 always 2
Line 1409
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1411
  return always {!<=-1,!>=2}
  true always 1
Line 1412
  -1 always -1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 1413
  ( always {!<=-1,!>=2}
  -2 always -2
  "[(,] & %name%" always "[(,] & %name%"
Line 1415
  = always 0
  0 always 0
Line 1417
  ftok possible {symbolic=(tok),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok {symbolic=(tok),!0}
  "[;{}(]" always "[;{}(]"
Line 1418
  ftok always !0
  ( possible size=1
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1419
  ftok always !0
Line 1420
  ftok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 1426
  = possible 0
  ftok possible {symbolic=(tok),0}
  ? possible 0
  ftok always !0
  : always 0
  nullptr always 0
Line 1427
  ( always {!<=-1,!>=2}
  ftok possible 0
  "%name% (" always "%name% ("
Line 1431
  ! always {!<=-1,!>=2}
  function always symbolic=(ftok->function())
  && always {!<=-1,!>=2}
Line 1433
  mSettings always !0
  1 always 1
Line 1434
  argDirection possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  DIR_IN always 0
Line 1435
  return always {!<=-1,!>=2}
  false always 0
Line 1436
  argDirection always !0
  == always {!<=-1,!>=2}
  :: always 1
  DIR_OUT always 1
Line 1437
  return always {!<=-1,!>=2}
  true always 1
Line 1440
  = possible 0
  function {symbolic=(ftok->function()),0}
  ? possible 0
  function {symbolic=(ftok->function()),!0}
  : always 0
  nullptr always 0
Line 1441
  = possible 0
  arg possible 0
  ? possible 0
  arg always !0
  : always 0
  nullptr always 0
Line 1442
  argStart possible {symbolic=(arg?arg->typeStartToken():nullptr),0}
  && always {!<=-1,!>=2}
  argStart {symbolic=(arg?arg->typeStartToken():nullptr),!0}
  && always {!<=-1,!>=2}
  argStart {symbolic=(arg?arg->typeStartToken():nullptr),!0}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1443
  = always !0
  argStart always !0
  ( always !0
Line 1444
  ( always {!<=-1,!>=2}
  argStart possible {symbolic=(arg?arg->typeStartToken():nullptr),0}
  "const struct| %type% * const| %name% [,)]" always "const struct| %type% * const| %name% [,)]"
Line 1445
  return always {!<=-1,!>=2}
  false always 0
Line 1448
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  "= * (" always "= * ("
Line 1449
  return always {!<=-1,!>=2}
  false always 0
Line 1451
  return always {!<=-1,!>=2}
  true always 1
Line 1453
  return always {!<=-1,!>=2}
  false always 0
Line 1456
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  isPointer always {!<=-1,!>=2}
Line 1458
  ( always {!<=-1,!>=2}
  "[(,] %name% . %name% [,)]" always "[(,] %name% . %name% [,)]"
  && always {!<=-1,!>=2}
Line 1459
  2 always 2
  == always {!<=-1,!>=2}
Line 1460
  isPointer always {!<=-1,!>=2}
Line 1461
  == always {!<=-1,!>=2}
  1 always 1
Line 1462
  return always {!<=-1,!>=2}
  true always 1
Line 1465
  ( always {!<=-1,!>=2}
Line 1466
  return always {!<=-1,!>=2}
  false always 0
Line 1468
  ( always {!<=-1,!>=2}
  "%name% . %name%" always "%name% . %name%"
  && always {!<=-1,!>=2}
  2 always 2
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
  -2 always -2
  ( always {!<=-1,!>=2}
Line 1470
  parent always symbolic=(tok->next()->astParent())
  && always {!<=-1,!>=2}
  parent {symbolic=(tok->next()->astParent()),!0}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1471
  return always {!<=-1,!>=2}
  false always 0
Line 1472
  return always {!<=-1,!>=2}
  true always 1
Line 1473
  ! {!<=-1,!>=2,1}
  isPointer {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[(,] %name% [,)]" always "[(,] %name% [,)]"
  && always {!<=-1,!>=2}
  isPointer always {!<=-1,!>=2}
Line 1474
  return always {!<=-1,!>=2}
  true always 1
Line 1476
  ! {!<=-1,!>=2,1}
  isPointer {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "= %name% ;" always "= %name% ;"
Line 1477
  return always {!<=-1,!>=2}
  true always 1
Line 1480
  ! {!<=-1,!>=2,1}
  isPointer {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
Line 1481
  ( always {!<=-1,!>=2}
  "&" always "&"
  && always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
Line 1483
  ( always {!<=-1,!>=2}
  "= * (| &" always "= * (| &"
  && always {!<=-1,!>=2}
Line 1484
  == always {!<=-1,!>=2}
Line 1485
  return always {!<=-1,!>=2}
  true always 1
Line 1487
  ( always {!<=-1,!>=2}
  :: always 3
  experimental always 3
  && always {!<=-1,!>=2}
Line 1488
  ! always {!<=-1,!>=2}
  isPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1489
  ( always {!<=-1,!>=2}
  -2 always -2
  "[(,] & %name% [,)]" always "[(,] & %name% [,)]"
  && always {!<=-1,!>=2}
Line 1490
  isPointer always 0
Line 1491
  return always {!<=-1,!>=2}
  true always 1
Line 1493
  return always {!<=-1,!>=2}
  false always 0
Line 1496
  , always {!<=-1,!>=2}
  strncpy_ always {!<=-1,!>=2}
Line 1498
  tok possible 0@92
  :: always 1
  error always 1
  "uninitstring" always "uninitstring"
  "$symbol:" always "$symbol:"
  varname possible "varname"@92
  "\nDangerous usage of '$symbol'" always "\nDangerous usage of '$symbol'"
  strncpy_ {!<=-1,!>=2,1@92}
  ? possible {" (strncpy doesn't always null-terminate it)."," (not null-terminated)."}
  " (strncpy doesn't always null-terminate it)." always " (strncpy doesn't always null-terminate it)."
  : always " (not null-terminated)."
  " (not null-terminated)." always " (not null-terminated)."
  :: always 0
  normal always 0
Line 1503
  tok possible 0@93
  :: always 1
  error always 1
  "uninitdata" always "uninitdata"
  "$symbol:" always "$symbol:"
  varname possible "varname"@93
  "\nMemory is allocated but not initialized: $symbol" always "\nMemory is allocated but not initialized: $symbol"
  :: always 0
  normal always 0
Line 1508
  ( always {!<=-1,!>=2}
Line 1510
  errorPath possible size=0@97
  "" always ""
Line 1512
  :: always 1
  error always 1
Line 1513
  "legacyUninitvar" always "legacyUninitvar"
Line 1514
  "$symbol:" always "$symbol:"
  "\nUninitialized variable: $symbol" always "\nUninitialized variable: $symbol"
Line 1516
  :: always 0
  normal always 0
Line 1521
  ( always {!<=-1,!>=2}
  tok possible 0
Line 1523
  = possible 0
  tok possible 0
Line 1524
  tok {symbolic=(ltok),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(ltok),!0}
  "." always "."
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok {symbolic=(ltok),!0}
Line 1525
  tok {symbolic=(ltok),!0}
Line 1526
  = possible "x"
  ltok possible {symbolic=(tok),symbolic=(tok->astParent())}
  ? possible "x"
  ltok always !0
  : always "x"
  "x" always "x"
Line 1528
  errorPath always symbolic=(v.errorPath)
  "" always ""
Line 1529
  ( always {!<=-1,!>=2}
Line 1531
  :: always 1
  error always 1
Line 1532
  "uninitvar" always "uninitvar"
Line 1533
  "$symbol:" always "$symbol:"
  "\nUninitialized variable: $symbol" always "\nUninitialized variable: $symbol"
Line 1535
  :: always 0
  normal always 0
Line 1538
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  "variable: " always "variable: "
  : always "variables: "
  "variables: " always "variables: "
Line 1541
  prefix possible {size=0,", ",size=2}
  varname always symbolic=(ltok?ltok->expressionString():"x")
  "." always "."
Line 1542
  = always ", "
  ", " always ", "
Line 1545
  :: always 1
  error always 1
Line 1546
  "uninitvar" always "uninitvar"
Line 1547
  "$symbol:" always "$symbol:"
  "\nUninitialized " always "\nUninitialized "
Line 1549
  :: always 0
  normal always 0
Line 1554
  tok possible 0@94
Line 1555
  :: always 1
  error always 1
Line 1556
  "uninitStructMember" always "uninitStructMember"
Line 1557
  "$symbol:" always "$symbol:"
  membername possible "a.b"@94
  "\nUninitialized struct member: $symbol" always "\nUninitialized struct member: $symbol"
  :: always 0
  normal always 0
Line 1560
  None always 0
  NotUsed always 1
  PassedByReference always 2
  Used always 3
Line 1564
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1567
  argnr always Uninit
Line 1568
  ! always {!<=-1,!>=2}
Line 1569
  :: always 0
  None always 0
Line 1570
  ftok always !0
Line 1571
  ftok always !0
Line 1573
  ! always {!<=-1,!>=2}
Line 1575
  arg always !0
  ( always {!<=-1,!>=2}
Line 1576
  :: always 2
  PassedByReference always 2
Line 1579
  isnullbad always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  1 always 1
Line 1580
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  addressOf {symbolic=(tok->astParent()&&tok->astParent()->isUnaryOp("&")),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  isnullbad always {!<=-1,!>=2}
Line 1581
  :: always 3
  Used always 3
Line 1582
  hasIndirect always {!<=-1,!>=2}
  hasIndirect always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1583
  isuninitbad always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
  1 always 1
  & {lifetime[Address]=(hasIndirect),!0}
  hasIndirect always 0
Line 1584
  isuninitbad always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isnullbad always {!<=-1,!>=2}
Line 1585
  :: always 3
  Used always 3
Line 1587
  :: always 0
  None always 0
Line 1592
  indirect possible 0
  > {!<=-1,!>=2,0}
  0 always 0
  && always {!<=-1,!>=2}
Line 1593
  ( always {!<=-1,!>=2}
  ( always !0
  "%assign%" always "%assign%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1594
  :: always 1
  NotUsed always 1
Line 1595
  ( always !0
  ( always {!<=-1,!>=2}
Line 1596
  :: always 1
  NotUsed always 1
Line 1597
  ( always {!<=-1,!>=2}
Line 1598
  :: always 1
  NotUsed always 1
Line 1600
  indirect possible {>=1,<=0}
  == {!<=-1,!>=2,>=0,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%cop%|%assign%|++|--" always "%cop%|%assign%|++|--"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "=" always "="
Line 1601
  :: always 3
  Used always 3
Line 1602
  indirect possible >=1
Line 1605
  ( always {!<=-1,!>=2}
Line 1607
  ! always {!<=-1,!>=2}
Line 1608
  return always {!<=-1,!>=2}
  false always 0
Line 1609
  tok always !0
Line 1610
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always symbolic=(tok->astParent())
  "." always "."
Line 1611
  return always {!<=-1,!>=2}
  false always 0
Line 1612
  parent always symbolic=(tok->astParent())
  == always {!<=-1,!>=2}
  tok always !0
Line 1613
  return always {!<=-1,!>=2}
  true always 1
Line 1614
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1622
  subfunction always {!<=-1,!>=2}
  false always 0
  true always 1
Line 1624
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1625
  != always {!<=-1,!>=2}
Line 1626
  ( always {!<=-1,!>=2}
Line 1627
  1 always 1
Line 1630
  ( always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 1632
  ! {!<=-1,!>=2,1}
  ( possible 0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1634
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1637
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok->astParent()),0}
  "." always "."
Line 1639
  parent possible symbolic=(tok->astParent())
  && always {!<=-1,!>=2}
  parent always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
Line 1641
  ( always {!<=-1,!>=2}
  parent possible 0
Line 1643
  = possible lifetime[Iterator]=(tok->values())
  ( possible lifetime[Iterator]=(tok->values())
Line 1644
  ( {lifetime[Iterator]=(tok->values()),start=0}
  ( {lifetime[Iterator]=(tok->values()),end=0}
  & {lifetime[Address]=(isUninitValue),!0}
Line 1645
  v possible lifetime[Iterator]=(tok->values())
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(tok->values()),end=0}
Line 1647
  v {lifetime[Iterator]=(tok->values()),!symbolic=(tok->values().end()),!end=0}
  && always {!<=-1,!>=2}
  ( always !<=-1
  v {lifetime[Iterator]=(tok->values()),!symbolic=(tok->values().end()),!end=0}
  > always {!<=-1,!>=2}
  0 always 0
Line 1649
  subfunction always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  v always {!symbolic=(tok->values().end()),!end=0}
  == always {!<=-1,!>=2}
  0 always 0
Line 1653
  . possible {>=0,1}
  > {!<=-1,!>=2,>=0}
  1 always 1
  || {!<=-1,!>=2,>=0}
  . possible 1
  < {!<=-1,!>=2,0}
  0 always 0
Line 1655
  uninitderef always {!<=-1,!>=2}
  uninitderef always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1657
  unknown always {!<=-1,!>=2}
Line 1658
  isarray always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always 0
  ( always 1
  || always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1659
  ispointer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isarray {symbolic=(!tok->variable()||tok->variable()->isArray()),!<=-1,!>=2}
Line 1660
  deref always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  unknown {!<=-1,!>=2,Uninit}
Line 1661
  ispointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!>=2,!<=-1}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
Line 1663
  isarray {symbolic=(!tok->variable()||tok->variable()->isArray()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
Line 1665
  uninitderef always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  deref always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1666
  isleaf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  uninitderef {symbolic=(deref&&v->indirect==0),!<=-1,!>=2}
Line 1667
  ( always {!<=-1,!>=2}
  ". %var%" always ". %var%"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isleaf always {!<=-1,!>=2}
Line 1670
  . always {!>=2,!<=-1}
Line 1671
  usage possible {2,3}
  == {!<=-1,!>=2,0}
  :: always 1
  NotUsed always 1
Line 1673
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  usage always !1
  == always {!<=-1,!>=2}
  :: always 2
  PassedByReference always 2
Line 1675
  usage always !1
  != always {!<=-1,!>=2}
  :: always 3
  Used always 3
Line 1676
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ". %name% (" always ". %name% ("
  && always {!<=-1,!>=2}
  uninitderef always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1677
  ( always {!<=-1,!>=2}
Line 1679
  inconclusive always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1680
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(inconclusive),!0}
  inconclusive always 0
  || always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
Line 1686
  ids always !size=0
  . always !0
Line 1699
  nullptr always 0
Line 1703
  ( always {!<=-1,!>=2}
Line 1707
  return always {!<=-1,!>=2}
  c always symbolic=(dynamic_cast<const CheckUninitVar*>(check))
  && always {!<=-1,!>=2}
  c {symbolic=(dynamic_cast<const CheckUninitVar*>(check)),!0}
  true always 1
  :: always 3
  ARRAY always 3
Line 1712
  unsafeUsage possible size=0
  this always !0
Line 1713
  ( always {!<=-1,!>=2}
Line 1714
  nullptr always 0
Line 1717
  fileInfo always size=0
  = always !size=0
  unsafeUsage always !size=0
Line 1718
  fileInfo always size=0
Line 1723
  unsafeUsage possible size=0
Line 1724
  ( always {!<=-1,!>=2}
Line 1725
  nullptr always 0
Line 1728
  fileInfo always size=0
  = always !size=0
  unsafeUsage always !size=0
Line 1729
  fileInfo always size=0
Line 1732
  ( always {!<=-1,!>=2}
Line 1734
  ! always {!<=-1,!>=2}
Line 1735
  return always {!<=-1,!>=2}
  false always 0
Line 1736
  foundErrors always {!<=-1,!>=2}
  foundErrors always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1739
  ctu always !0
Line 1743
  ! always {!<=-1,!>=2}
  fi always symbolic=(dynamic_cast<MyFileInfo*>(fi1))
Line 1745
  fi {symbolic=(dynamic_cast<MyFileInfo*>(fi1)),!0}
Line 1746
  = always 0
  nullptr always 0
Line 1748
  locationList possible size=0
Line 1749
  :: always 1
  uninit always 1
Line 1752
  "Using argument ARG" always "Using argument ARG"
Line 1753
  & {lifetime[Address]=(functionCall),!0}
  functionCall always 0
Line 1754
  false always 0
Line 1755
  ( always {!<=-1,!>=2}
Line 1760
  :: always 1
  error always 1
Line 1761
  "Using argument " always "Using argument "
  " that points at uninitialized variable " always " that points at uninitialized variable "
Line 1762
  "ctuuninitvar" always "ctuuninitvar"
Line 1764
  :: always 0
  normal always 0
Line 1767
  foundErrors always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1770
  return always {!<=-1,!>=2}
  foundErrors always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,3@95}
  flag possible 3@95
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
