

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var13 ) ;
62:
63:
64: Check ( const std :: string & aname@var14 , const Tokenizer * tokenizer@var15 , const Settings * settings@var16 , ErrorLogger * errorLogger@var17 )
65: : mTokenizer@var28 ( tokenizer@var15 ) , mSettings@var29 ( settings@var16 ) , mErrorLogger@var30 ( errorLogger@var17 ) , mName@var63 ( aname@var14 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073744556 !@expr1073744557 mTokenizer@var28 ) {
69: instances (@expr1073744558 ) .@expr1073744559 remove (@expr1073744560 this@expr1073744561 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var18 , const Settings * settings@var19 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var63 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var20 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073744562 string (@expr1073744563 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var21 , const Settings * settings@var22 ) const {
107: (@expr1073744564 void ) tokenizer@var21 ;
108: (@expr1073744565 void ) settings@var22 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var23 ) const {
113: (@expr1073744566 void ) xmlElement@var23 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var24 , const std :: list < FileInfo * > & fileInfo@var25 , const Settings & , ErrorLogger & ) {
119: (@expr1073744567 void ) ctu@var24 ;
120: (@expr1073744568 void ) fileInfo@var25 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var26 , const char id@var27 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var28 ;
130: const Settings * const mSettings@var29 ;
131: ErrorLogger * const mErrorLogger@var30 ;
132:
133:
134: void reportError ( const Token * tok@var31 , const Severity :: SeverityType severity@var32 , const std :: string & id@var33 , const std :: string & msg@var34 ) {
135: reportError (@expr1073744569 tok@var31 , severity@var32 , id@var33 , msg@var34 , CWE (@expr1073744570 0U ) , Certainty ::@expr1073744571 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var35 , const Severity :: SeverityType severity@var36 , const std :: string & id@var37 , const std :: string & msg@var38 , const CWE & cwe@var39 , Certainty :: CertaintyLevel certainty@var40 ) {
140: const std ::@expr1073744572 list < const Token *@expr1073744573 > callstack@var41 (@expr1073744574 1 , tok@var35 ) ;
141: reportError (@expr1073744575 callstack@var41 , severity@var36 , id@var37 , msg@var38 , cwe@var39 , certainty@var40 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var42 , Severity :: SeverityType severity@var43 , const std :: string & id@var44 , const std :: string & msg@var45 ) {
146: reportError (@expr1073744576 callstack@var42 , severity@var43 , id@var44 , msg@var45 , CWE (@expr1073744577 0U ) , Certainty ::@expr1073744578 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var46 , Severity :: SeverityType severity@var47 , const std :: string & id@var48 , const std :: string & msg@var49 , const CWE & cwe@var50 , Certainty :: CertaintyLevel certainty@var51 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var52 , Severity :: SeverityType severity@var53 , const char id@var54 [ ] , const std :: string & msg@var55 , const CWE & cwe@var56 , Certainty :: CertaintyLevel certainty@var57 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var58 , const ValueFlow :: Value * value@var59 , const std :: string & bug@var60 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var61 , const char * str@var62 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var63 ;
167: } ;

##file cppcheck-2.8/lib/checkunusedvar.h

1:
|
30:
31: class ErrorLogger ;
32: class Scope ;
33: class Settings ;
34: class Token ;
35: class Tokenizer ;
36: class Type ;
37: class Variables ;
38: class Variable ;
39: class Function ;
40:
|
46:
47: class CheckUnusedVar : public Check {
48: public:
49:
50: CheckUnusedVar ( ) : Check ( myName ( ) ) { }
51:
52:
53: CheckUnusedVar ( const Tokenizer * tokenizer@var64 , const Settings * settings@var65 , ErrorLogger * errorLogger@var66 )
54: : Check ( myName ( ) , tokenizer@var64 , settings@var65 , errorLogger@var66 ) { }
55:
56:
57: void runChecks ( const Tokenizer * tokenizer@var67 , const Settings * settings@var68 , ErrorLogger * errorLogger@var69 ) override {
58: CheckUnusedVar checkUnusedVar@var70 (@expr1073744579 tokenizer@var67 , settings@var68 , errorLogger@var69 ) ;
59:
60:
61: checkUnusedVar@var70 .@expr1073744580 checkStructMemberUsage (@expr1073744581 ) ;
62: checkUnusedVar@var70 .@expr1073744582 checkFunctionVariableUsage (@expr1073744583 ) ;
63: }
64:
65:
66: void checkFunctionVariableUsage_iterateScopes ( const Scope * const scope@var71 , Variables & variables@var72 ) ;
67: void checkFunctionVariableUsage ( ) ;
68:
69:
70: void checkStructMemberUsage ( ) ;
71:
72: private:
73: bool isRecordTypeWithoutSideEffects ( const Type * type@var73 ) ;
74: bool isVariableWithoutSideEffects ( const Variable & var@var74 ) ;
75: bool isEmptyType ( const Type * type@var75 ) ;
76: bool isFunctionWithoutSideEffects ( const Function & func@var76 , const Token * functionUsageToken@var77 ,
77: std :: list < const Function * > checkedFuncs@var78 ) ;
78:
79:
80: void unusedStructMemberError ( const Token * tok@var79 , const std :: string & structname@var80 , const std :: string & varname@var81 , bool isUnion@var82 = false ) ;
81: void unusedVariableError ( const Token * tok@var83 , const std :: string & varname@var84 ) ;
82: void allocatedButUnusedVariableError ( const Token * tok@var85 , const std :: string & varname@var86 ) ;
83: void unreadVariableError ( const Token * tok@var87 , const std :: string & varname@var88 , bool modified@var89 ) ;
84: void unassignedVariableError ( const Token * tok@var90 , const std :: string & varname@var91 ) ;
85:
86: void getErrorMessages ( ErrorLogger * errorLogger@var92 , const Settings * settings@var93 ) const override {
87: CheckUnusedVar c@var94 (@expr1073744584 nullptr , settings@var93 , errorLogger@var92 ) ;
88:
89:
90: c@var94 .@expr1073744585 unusedVariableError (@expr1073744586 nullptr , "varname" ) ;
91: c@var94 .@expr1073744587 allocatedButUnusedVariableError (@expr1073744588 nullptr , "varname" ) ;
92: c@var94 .@expr1073744589 unreadVariableError (@expr1073744590 nullptr , "varname" , false ) ;
93: c@var94 .@expr1073744591 unassignedVariableError (@expr1073744592 nullptr , "varname" ) ;
94: c@var94 .@expr1073744593 unusedStructMemberError (@expr1073744594 nullptr , "structname" , "variable" ) ;
95: }
96:
97: static std :: string myName ( ) {
98: return "UnusedVar" ;
99: }
100:
101: std :: string classInfo ( ) const override {
102: return "UnusedVar checks\n- unused variable\n- allocated but unused variable\n- unread variable\n- unassigned variable\n- unused struct member\n"
103:
|
108:
109: ;
110: }
111:
112: std :: map < const Type * , bool > mIsRecordTypeWithoutSideEffectsMap@var95 ;
113:
114: std :: map < const Type * , bool > mIsEmptyTypeMap@var96 ;
115:
116: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var97 ;
42: double mDoubleValue@var98 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var99 ;
44: bool mIsUnsigned@var100 ;
45:
46: void promote ( const value & v@var101 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var102 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var99 !=@expr1073744595 Type ::@expr1073744596 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var99 ==@expr1073744597 Type ::@expr1073744598 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744599 ) ?@expr1073744600 mDoubleValue@var98 :@expr1073744601 (@expr1073744602 double ) mIntValue@var97 ;
60: }
61:
62: static value calc ( char op@var103 , const value & v1@var104 , const value & v2@var105 ) ;
63: int compare ( const value & v@var106 ) const ;
64: value add ( int v@var107 ) const ;
65: value shiftLeft ( const value & v@var108 ) const ;
66: value shiftRight ( const value & v@var109 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var110 ;
72:
73: static long long toLongNumber ( const std :: string & str@var111 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var112 ) ;
75:
76: template < class T > static std :: string toString ( T value@var113 ) {
77: std ::@expr1073744603 ostringstream result@var114 ;
78: result@var114 <<@expr1073744604 value@var113 ;
79: return result@var114 .@expr1073744605 str (@expr1073744606 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var115 ) ;
82:
83: static bool isInt ( const std :: string & str@var116 ) ;
84: static bool isFloat ( const std :: string & str@var117 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var118 ) ;
86: static bool isNegative ( const std :: string & str@var119 ) ;
87: static bool isPositive ( const std :: string & str@var120 ) ;
88: static bool isDec ( const std :: string & str@var121 ) ;
89: static bool isFloatHex ( const std :: string & str@var122 ) ;
90: static bool isIntHex ( const std :: string & str@var123 ) ;
91: static bool isOct ( const std :: string & str@var124 ) ;
92: static bool isBin ( const std :: string & str@var125 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var126 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var127 , bool supportMicrosoftExtensions@var128 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var129 , const std :: string & second@var130 ) ;
105: static std :: string subtract ( const std :: string & first@var131 , const std :: string & second@var132 ) ;
106: static std :: string multiply ( const std :: string & first@var133 , const std :: string & second@var134 ) ;
107: static std :: string divide ( const std :: string & first@var135 , const std :: string & second@var136 ) ;
108: static std :: string mod ( const std :: string & first@var137 , const std :: string & second@var138 ) ;
109: static std :: string incdec ( const std :: string & var@var139 , const std :: string & op@var140 ) ;
110: static std :: string calculate ( const std :: string & first@var141 , const std :: string & second@var142 , char action@var143 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var144 ) ;
113: static std :: string cos ( const std :: string & tok@var145 ) ;
114: static std :: string tan ( const std :: string & tok@var146 ) ;
115: static std :: string abs ( const std :: string & tok@var147 ) ;
116: static bool isEqual ( const std :: string & first@var148 , const std :: string & second@var149 ) ;
117: static bool isNotEqual ( const std :: string & first@var150 , const std :: string & second@var151 ) ;
118: static bool isGreater ( const std :: string & first@var152 , const std :: string & second@var153 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var154 , const std :: string & second@var155 ) ;
120: static bool isLess ( const std :: string & first@var156 , const std :: string & second@var157 ) ;
121: static bool isLessEqual ( const std :: string & first@var158 , const std :: string & second@var159 ) ;
122: static bool isNullValue ( const std :: string & str@var160 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var161 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var162 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var163 , std :: string :: size_type iPos@var164 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var165 , const MathLib :: value & v2@var166 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var167 , const MathLib :: value & v2@var168 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var169 , const MathLib :: value & v2@var170 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var171 , const MathLib :: value & v2@var172 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var173 , const MathLib :: value & v2@var174 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var175 , const MathLib :: value & v2@var176 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var177 , const MathLib :: value & v2@var178 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var179 , const MathLib :: value & v2@var180 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var181 , const MathLib :: value & v2@var182 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var183 , const MathLib :: value & v2@var184 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var185 ) ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var186 ) const {
35: return p@var186 .@expr1073744607 first@var187 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var188 ) const {
42: return p@var188 .@expr1073744608 second@var189 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var190 , const T & x@var191 )
48: {
49: return std ::@expr1073744609 find (@expr1073744610 r@var190 .@expr1073744611 begin (@expr1073744612 ) , r@var190 .@expr2789 end (@expr2790 ) , x@var191 ) !=@expr1073744615 r@var190 .@expr2789 end (@expr2790 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var192 , const T & x@var193 )
54: {
55: return std ::@expr1073744618 find (@expr1073744619 r@var192 .@expr1073744620 begin (@expr1073744621 ) , r@var192 .@expr2798 end (@expr2799 ) , x@var193 ) !=@expr1073744624 r@var192 .@expr2798 end (@expr2799 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var194 , const U & x@var195 )
60: {
61: return std ::@expr1073744627 find (@expr1073744628 r@var194 .@expr1073744629 begin (@expr1073744630 ) , r@var194 .@expr2807 end (@expr2808 ) , x@var195 ) !=@expr1073744633 r@var194 .@expr2807 end (@expr2808 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var196 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744636 t@var196 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var197 , char c@var198 )
74: {
75: return !@expr1073744637 str@var197 .@expr1073744638 empty (@expr1073744639 ) &&@expr1073744640 str@var197 .@expr1073744641 back (@expr1073744642 ) ==@expr1073744643 c@var198 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var199 , const char end@var200 [ ] , unsigned long endlen@var201 )
79: {
80: return (@expr2820 str@var199 .@expr2821 size (@expr2822 ) >=@expr1073744647 endlen@var201 ) &&@expr1073744648 (@expr2820 str@var199 .@expr1073744650 compare (@expr1073744651 str@var199 .@expr2821 size (@expr2822 ) -@expr1073744654 endlen@var201 , endlen@var201 , end@var200 ) ==@expr1073744655 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var202 , const char ( & end@var203 ) [ N ] )
85: {
86: return endsWith (@expr1073744657 str@var202 , end@var203 , N@expr1073744656 -@expr1073744658 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var204 , char q@var205 , const std :: string & p@var206 )
90: {
91: if (@expr1073744659 !@expr1073744660 endsWith (@expr1073744661 str@var204 , q@var205 ) ) {
92: return false ; }
93: if (@expr1073744662 (@expr1073744663 str@var204 .@expr1073744664 length (@expr1073744665 ) +@expr1073744666 1 ) >@expr1073744667 p@var206 .@expr1073744668 length (@expr1073744669 ) &&@expr1073744670 (@expr1073744671 str@var204 .@expr1073744672 compare (@expr1073744673 0 , p@var206 .@expr1073744674 size (@expr1073744675 ) +@expr1073744676 1 , p@var206 +@expr1073744677 q@var205 ) ==@expr1073744678 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var207 , char q@var208 )
99: {
100: static const std ::@expr2855 vector < std ::@expr2855 string > suffixes@var209 {@expr1073744681 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744682 const std ::@expr2855 string &@expr1073744684 p@var210 :@expr1073744685 suffixes@var209 ) {
102: if (@expr1073744686 isPrefixStringCharLiteral (@expr1073744687 str@var207 , q@var208 , p@var210 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var211 )
109: {
110: return isStringCharLiteral (@expr1073744688 str@var211 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var212 )
114: {
115: return isStringCharLiteral (@expr1073744689 str@var212 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var213 , char q@var214 )
119: {
120: const unsigned long quotePos@var215 =@expr1073744690 str@var213 .@expr1073744691 find (@expr1073744692 q@var214 ) ;
121: return str@var213 .@expr1073744693 substr (@expr1073744694 quotePos@var215 +@expr1073744695 1U , str@var213 .@expr1073744696 size (@expr1073744697 ) -@expr1073744698 quotePos@var215 -@expr1073744699 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var216 )
125: {
126: if (@expr1073744700 isStringLiteral (@expr1073744701 str@var216 ) ) {
127: return getStringCharLiteral (@expr1073744702 str@var216 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var217 )
132: {
133: if (@expr1073744703 isCharLiteral (@expr1073744704 str@var217 ) ) {
134: return getStringCharLiteral (@expr1073744705 str@var217 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var218 )
139: {
140: if (@expr1073744706 i@var218 ==@expr1073744707 1 ) {
141: return "st" ; }
142: if (@expr1073744708 i@var218 ==@expr1073744709 2 ) {
143: return "nd" ; }
144: if (@expr1073744710 i@var218 ==@expr1073744711 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var219 , const std :: string & rhs@var220 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var221 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var222 , const std :: string & name@var223 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var224 , const std :: string & name@var225 ) ;
156:
157: void strTolower ( std :: string & str@var226 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var227 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var228 ;
42:
43:
44: std :: string stdValue@var229 ;
45:
46:
47: Standards ( ) : c@var227 ( CLatest ) , cpp@var228 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var230 ) {
50: stdValue@var229 =@expr1073744712 str@var230 ;
51: if (@expr1073744713 str@var230 ==@expr1073744714 "c89" ||@expr1073744715 str@var230 ==@expr1073744716 "C89" ) {
52: c@var227 =@expr1073744717 C89 ;
53: return true ;
54: }
55: if (@expr1073744718 str@var230 ==@expr1073744719 "c99" ||@expr1073744720 str@var230 ==@expr1073744721 "C99" ) {
56: c@var227 =@expr1073744722 C99 ;
57: return true ;
58: }
59: if (@expr1073744723 str@var230 ==@expr1073744724 "c11" ||@expr1073744725 str@var230 ==@expr1073744726 "C11" ) {
60: c@var227 =@expr1073744727 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744728 c@var227 ) {
67: case C89 :@expr2905 ;
68: return "c89" ;
69: case C99 :@expr2905 ;
70: return "c99" ;
71: case C11 :@expr2905 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var231 ) {
77: if (@expr1073744732 std@var231 ==@expr1073744733 "c89" ) {
78: return Standards ::@expr1073744734 C89 ;
79: }
80: if (@expr1073744735 std@var231 ==@expr1073744736 "c99" ) {
81: return Standards ::@expr1073744737 C99 ;
82: }
83: if (@expr1073744738 std@var231 ==@expr1073744739 "c11" ) {
84: return Standards ::@expr1073744740 C11 ;
85: }
86: return Standards ::@expr1073744741 CLatest ;
87: }
88: bool setCPP ( std :: string str@var232 ) {
89: stdValue@var229 =@expr1073744742 str@var232 ;
90: strTolower (@expr1073744743 str@var232 ) ;
91: cpp@var228 =@expr1073744744 getCPP (@expr1073744745 str@var232 ) ;
92: return !@expr1073744746 stdValue@var229 .@expr1073744747 empty (@expr1073744748 ) &&@expr1073744749 str@var232 ==@expr1073744750 getCPP (@expr1073744751 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744752 cpp@var228 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var233 ) {
98: switch (@expr1073744753 std@var233 ) {
99: case CPP03 :@expr2930 ;
100: return "c++03" ;
101: case CPP11 :@expr2930 ;
102: return "c++11" ;
103: case CPP14 :@expr2930 ;
104: return "c++14" ;
105: case CPP17 :@expr2930 ;
106: return "c++17" ;
107: case CPP20 :@expr2930 ;
108: return "c++20" ;
109: case CPP23 :@expr2930 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var234 ) {
115: if (@expr1073744760 std@var234 ==@expr1073744761 "c++03" ) {
116: return Standards ::@expr1073744762 CPP03 ;
117: }
118: if (@expr1073744763 std@var234 ==@expr1073744764 "c++11" ) {
119: return Standards ::@expr1073744765 CPP11 ;
120: }
121: if (@expr1073744766 std@var234 ==@expr1073744767 "c++14" ) {
122: return Standards ::@expr1073744768 CPP14 ;
123: }
124: if (@expr1073744769 std@var234 ==@expr1073744770 "c++17" ) {
125: return Standards ::@expr1073744771 CPP17 ;
126: }
127: if (@expr1073744772 std@var234 ==@expr1073744773 "c++20" ) {
128: return Standards ::@expr1073744774 CPP20 ;
129: }
130: if (@expr1073744775 std@var234 ==@expr1073744776 "c++23" ) {
131: return Standards ::@expr1073744777 CPP23 ;
132: }
133: return Standards ::@expr1073744778 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var238 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var235 ) : errorcode@var238 ( e@var235 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var236 , T && r@var237 ) : errorcode@var238 ( e@var236 ) , reason@var239 ( r@var237 ) { }
66: ErrorCode errorcode@var238 ;
67: std :: string reason@var239 ;
68: } ;
69:
70: Error load ( const char exename@var240 [ ] , const char path@var241 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var242 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var243 [ ] , unsigned long len@var244 ) ;
75:
76: struct AllocFunc {
77: int groupId@var245 ;
78: int arg@var246 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var247 ;
81: int bufferSizeArg1@var248 ;
82: int bufferSizeArg2@var249 ;
83: int reallocArg@var250 ;
84: bool initData@var251 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var252 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var253 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var254 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var255 , int arg@var256 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var257 , int arg@var258 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var259 , int arg@var260 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var261 [ ] ) const {
107: return getAllocDealloc (@expr1073744779 mAlloc@var527 , name@var261 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var262 [ ] ) const {
112: return getAllocDealloc (@expr1073744780 mDealloc@var528 , name@var262 ) ;
113: }
114:
115:
116: int allocId ( const char name@var263 [ ] ) const {
117: const AllocFunc * af@var264 ; af@var264 =@expr1073744781 getAllocDealloc (@expr1073744782 mAlloc@var527 , name@var263 ) ;
118: return af@var264 ?@expr1073744783 af@var264 .@expr1073744784 groupId@var265 :@expr1073744785 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var266 [ ] ) const {
123: const AllocFunc * af@var267 ; af@var267 =@expr1073744786 getAllocDealloc (@expr1073744787 mDealloc@var528 , name@var266 ) ;
124: return af@var267 ?@expr1073744788 af@var267 .@expr1073744789 groupId@var268 :@expr1073744790 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var269 , int id@var270 , int arg@var271 ) {
129: mAlloc@var527 [@expr2967 functionname@var269 ] .@expr1073744792 groupId@var2736 =@expr1073744793 id@var270 ;
130: mAlloc@var527 [@expr2967 functionname@var269 ] .@expr1073744795 arg@var2737 =@expr1073744796 arg@var271 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var272 , int id@var273 , int arg@var274 ) {
134: mDealloc@var528 [@expr2973 functionname@var272 ] .@expr1073744798 groupId@var2738 =@expr1073744799 id@var273 ;
135: mDealloc@var528 [@expr2973 functionname@var272 ] .@expr1073744801 arg@var2739 =@expr1073744802 arg@var274 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var275 , int id@var276 , int arg@var277 , int reallocArg@var278 = 1 ) {
139: mRealloc@var529 [@expr2979 functionname@var275 ] .@expr1073744804 groupId@var2740 =@expr1073744805 id@var276 ;
140: mRealloc@var529 [@expr2979 functionname@var275 ] .@expr1073744807 arg@var2741 =@expr1073744808 arg@var277 ;
141: mRealloc@var529 [@expr2979 functionname@var275 ] .@expr1073744810 reallocArg@var2742 =@expr1073744811 reallocArg@var278 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var279 , bool noreturn@var280 ) {
146: mNoReturn@var530 [@expr1073744812 funcname@var279 ] =@expr1073744813 noreturn@var280 ?@expr1073744814 FalseTrueMaybe ::@expr1073744815 True :@expr1073744816 FalseTrueMaybe ::@expr1073744817 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var281 ) ;
150:
151:
152: static bool ismemory ( const int id@var282 ) {
153: return (@expr2994 (@expr2994 id@var282 >@expr1073744820 0 ) &&@expr1073744821 (@expr2994 (@expr2994 id@var282 &@expr1073744824 1 ) ==@expr1073744825 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var283 ) {
156: return (@expr3002 (@expr3002 func@var283 .@expr3004 groupId@var284 >@expr1073744829 0 ) &&@expr1073744830 (@expr3002 (@expr3002 func@var283 .@expr3004 groupId@var284 &@expr1073744834 1 ) ==@expr1073744835 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var285 ) {
161: return (@expr3012 (@expr3012 id@var285 >@expr1073744838 0 ) &&@expr1073744839 (@expr3012 (@expr3012 id@var285 &@expr1073744842 1 ) ==@expr1073744843 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var286 ) {
164: return (@expr3020 (@expr3020 func@var286 .@expr3022 groupId@var287 >@expr1073744847 0 ) &&@expr1073744848 (@expr3020 (@expr3020 func@var286 .@expr3022 groupId@var287 &@expr1073744852 1 ) ==@expr1073744853 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var288 ) const ;
168: int formatstr_argno ( const Token * ftok@var289 ) const ;
169: bool formatstr_scan ( const Token * ftok@var290 ) const ;
170: bool formatstr_secure ( const Token * ftok@var291 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var292 ;
174: int ptr2Arg@var293 ;
175: int sizeArg@var294 ;
176: int strlenArg@var295 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var296 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var297 ;
182: Standards standards@var298 ;
183: Severity :: SeverityType severity@var299 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var300 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var301 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var302 ) const ;
191: bool matchArguments ( const Token * ftok@var303 , const std :: string & functionName@var304 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var305 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var306 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var307 ) const ;
198: int returnValueContainer ( const Token * ftok@var308 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var309 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var310 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var311 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var312 , std :: string * unknownFunc@var313 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var323 ( -1 ) ,
210: size_templateArgNo@var325 ( -1 ) ,
211: arrayLike_indexOp@var326 ( false ) ,
212: stdStringLike@var327 ( false ) ,
213: stdAssociativeLike@var328 ( false ) ,
214: opLessAllowed@var329 ( true ) ,
215: hasInitializerListConstructor@var330 ( false ) ,
216: unstableErase@var331 ( false ) ,
217: unstableInsert@var332 ( false ) ,
218: view@var333 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var314 ;
248: Yield yield@var315 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var316 ;
252: int templateParameter@var317 ;
253: } ;
254: std :: string startPattern@var318 ; std :: string startPattern2@var319 ; std :: string endPattern@var320 ; std :: string itEndPattern@var321 ;
255: std :: map < std :: string , Function > functions@var322 ;
256: int type_templateArgNo@var323 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var324 ;
258: int size_templateArgNo@var325 ;
259: bool arrayLike_indexOp@var326 ;
260: bool stdStringLike@var327 ;
261: bool stdAssociativeLike@var328 ;
262: bool opLessAllowed@var329 ;
263: bool hasInitializerListConstructor@var330 ;
264: bool unstableErase@var331 ;
265: bool unstableInsert@var332 ;
266: bool view@var333 ;
267:
268: Action getAction ( const std :: string & function@var334 ) const {
269: const std ::@expr1073744854 map < std ::@expr1073744855 string , Function > ::@expr1073744856 const_iterator i@var335 =@expr1073744857 functions@var322 .@expr1073744858 find (@expr1073744859 function@var334 ) ;
270: if (@expr1073744860 i@var335 !=@expr1073744861 functions@var322 .@expr1073744862 end (@expr1073744863 ) ) {
271: return i@var335 .@expr1073744864 second@var336 .@expr1073744865 action@var337 ; }
272: return Action ::@expr1073744866 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var338 ) const {
276: const std ::@expr1073744867 map < std ::@expr1073744868 string , Function > ::@expr1073744869 const_iterator i@var339 =@expr1073744870 functions@var322 .@expr1073744871 find (@expr1073744872 function@var338 ) ;
277: if (@expr1073744873 i@var339 !=@expr1073744874 functions@var322 .@expr1073744875 end (@expr1073744876 ) ) {
278: return i@var339 .@expr1073744877 second@var340 .@expr1073744878 yield@var341 ; }
279: return Yield ::@expr1073744879 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var342 ) ;
283: static Action actionFrom ( const std :: string & actionName@var343 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var344 ;
286: const Container * detectContainer ( const Token * typeStart@var345 , bool iterator@var346 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var347 , bool * isIterator@var348 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var349 ( false ) ,
293: notnull@var350 ( false ) ,
294: notuninit@var351 ( -1 ) ,
295: formatstr@var352 ( false ) ,
296: strz@var353 ( false ) ,
297: optional@var354 ( false ) ,
298: variadic@var355 ( false ) ,
299: iteratorInfo@var361 ( ) ,
300: direction@var369 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var349 ;
303: bool notnull@var350 ;
304: int notuninit@var351 ;
305: bool formatstr@var352 ;
306: bool strz@var353 ;
307: bool optional@var354 ;
308: bool variadic@var355 ;
309: std :: string valid@var356 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var357 ( 0 ) , it@var358 ( false ) , first@var359 ( false ) , last@var360 ( false ) { }
314:
315: int container@var357 ;
316: bool it@var358 ;
317: bool first@var359 ;
318: bool last@var360 ;
319: } ;
320: IteratorInfo iteratorInfo@var361 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var362 , int a@var363 ) : type@var364 ( t@var362 ) , arg@var365 ( a@var363 ) , arg2@var366 ( 0 ) , value@var367 ( 0 ) { }
326: Type type@var364 ;
327: int arg@var365 ;
328: int arg2@var366 ;
329: long long value@var367 ;
330: } ;
331: std :: vector < MinSize > minsizes@var368 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var369 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var370 ;
344: bool use@var371 ;
345: bool leakignore@var372 ;
346: bool isconst@var373 ;
347: bool ispure@var374 ;
348: UseRetValType useretval@var375 ;
349: bool ignore@var376 ;
350: bool formatstr@var377 ;
351: bool formatstr_scan@var378 ;
352: bool formatstr_secure@var379 ;
353: Container :: Action containerAction@var380 ;
354: Container :: Yield containerYield@var381 ;
355: Function ( )
356: : use@var371 ( false ) ,
357: leakignore@var372 ( false ) ,
358: isconst@var373 ( false ) ,
359: ispure@var374 ( false ) ,
360: useretval@var375 ( UseRetValType :: NONE ) ,
361: ignore@var376 ( false ) ,
362: formatstr@var377 ( false ) ,
363: formatstr_scan@var378 ( false ) ,
364: formatstr_secure@var379 ( false ) ,
365: containerAction@var380 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var381 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var382 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var383 ;
372: bool isUse ( const std :: string & functionName@var384 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var385 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var386 , bool pure@var387 ) const ;
375: bool isFunctionConst ( const Token * ftok@var388 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var389 , int argnr@var390 ) const {
378: const ArgumentChecks * arg@var391 ; arg@var391 =@expr1073744880 getarg (@expr1073744881 ftok@var389 , argnr@var390 ) ;
379: return arg@var391 &&@expr1073744882 arg@var391 .@expr1073744883 notbool@var392 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var393 , int argnr@var394 ) const ;
383: bool isuninitargbad ( const Token * ftok@var395 , int argnr@var396 , int indirect@var397 = 0 , bool * hasIndirect@var398 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var399 , int argnr@var400 ) const {
386: const ArgumentChecks * arg@var401 ; arg@var401 =@expr1073744884 getarg (@expr1073744885 ftok@var399 , argnr@var400 ) ;
387: return arg@var401 &&@expr1073744886 arg@var401 .@expr1073744887 formatstr@var402 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var403 , int argnr@var404 ) const {
391: const ArgumentChecks * arg@var405 ; arg@var405 =@expr1073744888 getarg (@expr1073744889 ftok@var403 , argnr@var404 ) ;
392: return arg@var405 &&@expr1073744890 arg@var405 .@expr1073744891 strz@var406 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var407 , int argnr@var408 , const long long argvalue@var409 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var410 , int argnr@var411 , double argvalue@var412 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var413 , int argnr@var414 ) const {
399: const ArgumentChecks * arg@var415 ; arg@var415 =@expr1073744892 getarg (@expr1073744893 ftok@var413 , argnr@var414 ) ;
400: return arg@var415 ?@expr1073744894 arg@var415 .@expr1073744895 valid@var416 :@expr1073744896 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var417 ;
405: std :: string op1@var418 ;
406: std :: string op2@var419 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744897 isInt (@expr1073744898 op1@var418 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var420 , int argnr@var421 ) const {
413: const ArgumentChecks * arg@var422 ; arg@var422 =@expr1073744899 getarg (@expr1073744900 ftok@var420 , argnr@var421 ) ;
414: return arg@var422 &&@expr1073744901 arg@var422 .@expr3078 iteratorInfo@var423 .@expr1073744903 it@var424 ?@expr1073744904 &@expr1073744905 arg@var422 .@expr3078 iteratorInfo@var423 :@expr1073744907 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var425 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var426 , int argnr@var427 ) const {
420: const ArgumentChecks * arg@var428 ; arg@var428 =@expr1073744908 getarg (@expr1073744909 ftok@var426 , argnr@var427 ) ;
421: return arg@var428 ?@expr1073744910 &@expr1073744911 arg@var428 .@expr1073744912 minsizes@var429 :@expr1073744913 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var430 , int argnr@var431 ) const ;
425:
426: bool markupFile ( const std :: string & path@var432 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var433 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var537 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var434 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var435 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var436 , const std :: string & token@var437 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var438 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var439 ) const ;
443: const std :: string & blockend ( const std :: string & file@var440 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var441 , const std :: string & keyword@var442 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var443 ) const {
448: return mExporters@var540 .@expr1073744914 find (@expr1073744915 prefix@var443 ) !=@expr1073744916 mExporters@var540 .@expr1073744917 end (@expr1073744918 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var444 , const std :: string & token@var445 ) const {
452: const std ::@expr1073744919 map < std ::@expr1073744920 string , ExportedFunctions > ::@expr1073744921 const_iterator it@var446 =@expr1073744922 mExporters@var540 .@expr1073744923 find (@expr1073744924 prefix@var444 ) ;
453: return (@expr1073744925 it@var446 !=@expr1073744926 mExporters@var540 .@expr1073744927 end (@expr1073744928 ) &&@expr1073744929 it@var446 .@expr1073744930 second@var447 .@expr1073744931 isPrefix (@expr1073744932 token@var445 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var448 , const std :: string & token@var449 ) const {
457: const std ::@expr1073744933 map < std ::@expr1073744934 string , ExportedFunctions > ::@expr1073744935 const_iterator it@var450 =@expr1073744936 mExporters@var540 .@expr1073744937 find (@expr1073744938 prefix@var448 ) ;
458: return (@expr1073744939 it@var450 !=@expr1073744940 mExporters@var540 .@expr1073744941 end (@expr1073744942 ) &&@expr1073744943 it@var450 .@expr1073744944 second@var451 .@expr1073744945 isSuffix (@expr1073744946 token@var449 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var452 , const std :: string & importer@var453 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var454 , Container :: Yield yield@var455 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var456 , Container :: Action action@var457 ) const ;
465:
466: bool isreflection ( const std :: string & token@var458 ) const {
467: return mReflection@var542 .@expr1073744947 find (@expr1073744948 token@var458 ) !=@expr1073744949 mReflection@var542 .@expr1073744950 end (@expr1073744951 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var459 ) const {
471: const std ::@expr1073744952 map < std ::@expr1073744953 string , int > ::@expr1073744954 const_iterator it@var460 =@expr1073744955 mReflection@var542 .@expr1073744956 find (@expr1073744957 token@var459 ) ;
472: if (@expr1073744958 it@var460 !=@expr1073744959 mReflection@var542 .@expr1073744960 end (@expr1073744961 ) ) {
473: return it@var460 .@expr1073744962 second@var461 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var462 ;
478:
479: struct SmartPointer {
480: std :: string name@var463 ; name@var463 = "" ;
481: bool unique@var464 ; unique@var464 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var465 ;
485: bool isSmartPointer ( const Token * tok@var466 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var467 ) const ;
487:
488: struct PodType {
489: unsigned int size@var468 ;
490: char sign@var469 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var470 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var471 ) const {
494: const std ::@expr1073744963 unordered_map < std ::@expr1073744964 string , PodType > ::@expr1073744965 const_iterator it@var472 =@expr1073744966 mPodTypes@var543 .@expr1073744967 find (@expr1073744968 name@var471 ) ;
495: return (@expr3145 it@var472 !=@expr1073744970 mPodTypes@var543 .@expr1073744971 end (@expr1073744972 ) ) ?@expr1073744973 &@expr1073744974 (@expr3145 it@var472 .@expr1073744976 second@var473 ) :@expr1073744977 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var484 ( false )
501: , mUnsigned@var485 ( false )
502: , mLong@var486 ( false )
503: , mPointer@var487 ( false )
504: , mPtrPtr@var488 ( false )
505: , mConstPtr@var489 ( false ) { }
506: bool operator== ( const PlatformType & type@var474 ) const {
507: return (@expr1073744978 mSigned@var484 ==@expr1073744979 type@var474 .@expr1073744980 mSigned@var475 &&@expr1073744981
508: mUnsigned@var485 ==@expr1073744982 type@var474 .@expr1073744983 mUnsigned@var476 &&@expr1073744984
509: mLong@var486 ==@expr1073744985 type@var474 .@expr1073744986 mLong@var477 &&@expr1073744987
510: mPointer@var487 ==@expr1073744988 type@var474 .@expr1073744989 mPointer@var478 &&@expr1073744990
511: mPtrPtr@var488 ==@expr1073744991 type@var474 .@expr1073744992 mPtrPtr@var479 &&@expr1073744993
512: mConstPtr@var489 ==@expr1073744994 type@var474 .@expr1073744995 mConstPtr@var480 &&@expr1073744996
513: mType@var483 ==@expr1073744997 type@var474 .@expr1073744998 mType@var481 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var482 ) const {
516: return !@expr1073744999 (@expr1073745000 *@expr1073745001 this@expr1073745002 ==@expr1073745003 type@var482 ) ;
517: }
518: std :: string mType@var483 ;
519: bool mSigned@var484 ;
520: bool mUnsigned@var485 ;
521: bool mLong@var486 ;
522: bool mPointer@var487 ;
523: bool mPtrPtr@var488 ;
524: bool mConstPtr@var489 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var490 ) const {
529: const std ::@expr1073745004 map < std ::@expr1073745005 string , PlatformType > ::@expr1073745006 const_iterator it@var491 =@expr1073745007 mPlatformTypes@var493 .@expr1073745008 find (@expr1073745009 name@var490 ) ;
530: return (@expr3186 it@var491 !=@expr1073745011 mPlatformTypes@var493 .@expr1073745012 end (@expr1073745013 ) ) ?@expr1073745014 &@expr1073745015 (@expr3186 it@var491 .@expr1073745017 second@var492 ) :@expr1073745018 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var493 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var494 , const std :: string & platform@var495 ) const {
536: const std ::@expr1073745019 map < std ::@expr3196 string , Platform > ::@expr1073745021 const_iterator it@var496 =@expr1073745022 mPlatforms@var545 .@expr1073745023 find (@expr1073745024 platform@var495 ) ;
537: if (@expr1073745025 it@var496 !=@expr1073745026 mPlatforms@var545 .@expr1073745027 end (@expr1073745028 ) ) {
538: const PlatformType * const type@var497 ; type@var497 =@expr1073745029 it@var496 .@expr1073745030 second@var498 .@expr1073745031 platform_type (@expr1073745032 name@var494 ) ;
539: if (@expr1073745033 type@var497 ) {
540: return type@var497 ; }
541: }
542:
543: const std ::@expr1073745034 map < std ::@expr3196 string , PlatformType > ::@expr1073745036 const_iterator it2@var499 =@expr1073745037 mPlatformTypes@var544 .@expr1073745038 find (@expr1073745039 name@var494 ) ;
544: return (@expr3216 it2@var499 !=@expr1073745041 mPlatformTypes@var544 .@expr1073745042 end (@expr1073745043 ) ) ?@expr1073745044 &@expr1073745045 (@expr3216 it2@var499 .@expr1073745047 second@var500 ) :@expr1073745048 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var501 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var502 , Library :: Container :: Yield y@var503 , const std :: string & fallback@var504 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var505 , const std :: string & typeName@var506 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var507 , const std :: string & name@var508 , std :: set < std :: string > & unknown_elements@var509 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var510 ) {
565: mPrefixes@var514 .@expr1073745049 insert (@expr1073745050 prefix@var510 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var511 ) {
568: mSuffixes@var515 .@expr1073745051 insert (@expr1073745052 suffix@var511 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var512 ) const {
571: return (@expr1073745053 mPrefixes@var514 .@expr1073745054 find (@expr1073745055 prefix@var512 ) !=@expr1073745056 mPrefixes@var514 .@expr1073745057 end (@expr1073745058 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var513 ) const {
574: return (@expr1073745059 mSuffixes@var515 .@expr1073745060 find (@expr1073745061 suffix@var513 ) !=@expr1073745062 mSuffixes@var515 .@expr1073745063 end (@expr1073745064 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var514 ;
579: std :: set < std :: string > mSuffixes@var515 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var523 ( 0 ) { }
584:
585: void setStart ( const char * s@var516 ) {
586: mStart@var521 =@expr1073745065 s@var516 ;
587: }
588: void setEnd ( const char * e@var517 ) {
589: mEnd@var522 =@expr1073745066 e@var517 ;
590: }
591: void setOffset ( const int o@var518 ) {
592: mOffset@var523 =@expr1073745067 o@var518 ;
593: }
594: void addBlock ( const char * blockName@var519 ) {
595: mBlocks@var524 .@expr1073745068 insert (@expr1073745069 blockName@var519 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var521 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var522 ;
602: }
603: int offset ( ) const {
604: return mOffset@var523 ;
605: }
606: bool isBlock ( const std :: string & blockName@var520 ) const {
607: return mBlocks@var524 .@expr1073745070 find (@expr1073745071 blockName@var520 ) !=@expr1073745072 mBlocks@var524 .@expr1073745073 end (@expr1073745074 ) ;
608: }
609:
610: private:
611: std :: string mStart@var521 ;
612: std :: string mEnd@var522 ;
613: int mOffset@var523 ;
614: std :: set < std :: string > mBlocks@var524 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var525 ;
618: std :: set < std :: string > mFiles@var526 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var527 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var528 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var529 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var530 ;
623: std :: map < std :: string , std :: string > mReturnValue@var531 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var532 ;
625: std :: map < std :: string , int > mReturnValueContainer@var533 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var534 ;
627: std :: map < std :: string , bool > mReportErrors@var535 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var536 ;
629: std :: set < std :: string > mMarkupExtensions@var537 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var538 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var539 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var540 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var541 ;
634: std :: map < std :: string , int > mReflection@var542 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var543 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var544 ;
637: std :: map < std :: string , Platform > mPlatforms@var545 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var546 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var547 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var548 , int argnr@var549 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var550 , bool * error@var551 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var552 , const std :: string & name@var553 ) {
646: const std ::@expr1073745075 map < std ::@expr1073745076 string , AllocFunc > ::@expr1073745077 const_iterator it@var554 =@expr1073745078 data@var552 .@expr1073745079 find (@expr1073745080 name@var553 ) ;
647: return (@expr1073745081 it@var554 ==@expr1073745082 data@var552 .@expr1073745083 end (@expr1073745084 ) ) ?@expr1073745085 nullptr :@expr1073745086 &@expr1073745087 it@var554 .@expr1073745088 second@var555 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var556 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var557 ,
654: const Settings * settings@var558 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var559 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var560 ) const {
54: x@var560 ++@expr1073745089 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var561 ) const {
60: x@var561 --@expr1073745090 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var562 , const U & y@var563 ) const {
67: return x@var562 <@expr1073745091 y@var563 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var564 , const U & y@var565 ) const {
74: return std ::@expr1073745092 abs (@expr1073745093 x@var564 -@expr1073745094 y@var565 ) ==@expr1073745095 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var566 , T x@var567 , U y@var568 ) const {
81: result@var566 =@expr1073745096 !@expr1073745097 (@expr1073745098 x@var567 >@expr1073745099 y@var568 ||@expr1073745100 x@var567 <@expr1073745101 y@var568 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var569 = 0 , Bound b@var570 = Bound :: Point )
91: : valueType@var610 ( ValueType :: INT ) ,
92: bound@var611 ( b@var570 ) ,
93: intvalue@var612 ( val@var569 ) ,
94: tokvalue@var613 ( nullptr ) ,
95: floatValue@var614 ( 0.0 ) ,
96: moveKind@var615 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var616 ( val@var569 ) ,
98: condition@var617 ( nullptr ) ,
99: varId@var619 ( 0U ) ,
100: safe@var620 ( false ) ,
101: conditional@var621 ( false ) ,
102: macro@var622 ( false ) ,
103: defaultArg@var623 ( false ) ,
104: indirect@var624 ( 0 ) ,
105: path@var625 ( 0 ) ,
106: wideintvalue@var626 ( val@var569 ) ,
107: subexpressions@var627 ( ) ,
108: capturetok@var628 ( nullptr ) ,
109: lifetimeKind@var629 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var630 ( LifetimeScope :: Local ) ,
111: valueKind@var635 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var571 , long long val@var572 , Bound b@var573 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var574 ) const {
118: if (@expr1073745102 valueType@var610 !=@expr1073745103 rhs@var574 .@expr1073745104 valueType@var575 ) {
119: return false ; }
120: switch (@expr1073745105 valueType@var610 ) {
121: case ValueType ::@expr1073745106 INT :@expr3283
122: case ValueType ::@expr1073745108 CONTAINER_SIZE :@expr3283
123: case ValueType ::@expr1073745110 BUFFER_SIZE :@expr3283
124: case ValueType ::@expr1073745112 ITERATOR_START :@expr3283
125: case ValueType ::@expr1073745114 ITERATOR_END :@expr3283 ;
126: if (@expr3292 intvalue@var612 !=@expr3293 rhs@var574 .@expr3294 intvalue@var576 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073745119 TOK :@expr3283 ;
130: if (@expr3297 tokvalue@var613 !=@expr3298 rhs@var574 .@expr3299 tokvalue@var577 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073745124 FLOAT :@expr3283 ;
134:
135: if (@expr1073745126 floatValue@var614 >@expr1073745127 rhs@var574 .@expr3304 floatValue@var578 ||@expr1073745129 floatValue@var614 <@expr1073745130 rhs@var574 .@expr3304 floatValue@var578 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073745132 MOVED :@expr3283 ;
139: if (@expr1073745134 moveKind@var615 !=@expr1073745135 rhs@var574 .@expr1073745136 moveKind@var579 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073745137 UNINIT :@expr3283 ;
143: break ;
144: case ValueType ::@expr1073745139 LIFETIME :@expr3283 ;
145: if (@expr3297 tokvalue@var613 !=@expr3298 rhs@var574 .@expr3299 tokvalue@var577 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073745144 SYMBOLIC :@expr3283 ;
149: if (@expr1073745146 !@expr1073745147 sameToken (@expr1073745148 tokvalue@var613 , rhs@var574 .@expr3299 tokvalue@var577 ) ) {
150: return false ; }
151: if (@expr3292 intvalue@var612 !=@expr3293 rhs@var574 .@expr3294 intvalue@var576 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var580 , F f@var581 ) {
160: switch (@expr1073745153 self@var580 .@expr1073745154 valueType@var582 ) {
161: case ValueType ::@expr1073745155 INT :@expr3332
162: case ValueType ::@expr1073745157 SYMBOLIC :@expr3332
163: case ValueType ::@expr1073745159 BUFFER_SIZE :@expr3332
164: case ValueType ::@expr1073745161 CONTAINER_SIZE :@expr3332
165: case ValueType ::@expr1073745163 ITERATOR_START :@expr3332
166: case ValueType ::@expr1073745165 ITERATOR_END :@expr3332 ; {
167: f@var581 (@expr1073745167 self@var580 .@expr1073745168 intvalue@var583 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745169 FLOAT :@expr3332 ; {
171: f@var581 (@expr1073745171 self@var580 .@expr1073745172 floatValue@var584 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745173 UNINIT :@expr3332
175: case ValueType ::@expr1073745175 TOK :@expr3332
176: case ValueType ::@expr1073745177 LIFETIME :@expr3332
177: case ValueType ::@expr1073745179 MOVED :@expr3332 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var585 , Compare compare@var586 , T x@var587 , U y@var588 ) const {
186: result@var585 =@expr1073745181 compare@var586 (@expr1073745182 x@var587 , y@var588 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var589 , const Value & rhs@var590 , Compare compare@var591 , T x@var592 ) const {
191: visitValue (@expr1073745184 rhs@var590 ,
192: std ::@expr1073745185 bind (@expr1073745186 innerVisitor {@expr1073745187 } , std ::@expr1073745188 ref (@expr1073745189 result@var589 ) , std ::@expr1073745190 move (@expr1073745191 compare@var591 ) , x@var592 , std ::@expr1073745192 placeholders ::@expr1073745193 _1@expr1073745183 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var593 , Compare compare@var594 ) const {
198: assert (@expr1073745195 (@expr1073745196 !@expr1073745197 this@expr3374 .@expr1073745199 isSymbolicValue (@expr1073745200 ) &&@expr1073745201 !@expr1073745202 rhs@var593 .@expr1073745203 isSymbolicValue (@expr1073745204 ) ) ||@expr1073745205
199: (@expr1073745206 this@expr3374 .@expr1073745207 valueType@var610 ==@expr1073745208 rhs@var593 .@expr1073745209 valueType@var595 &&@expr1073745210 sameToken (@expr1073745211 this@expr3374 .@expr1073745212 tokvalue@var613 , rhs@var593 .@expr1073745213 tokvalue@var596 ) ) ) ;
200: bool result@var597 ; result@var597 =@expr1073745214 false ;
201: visitValue (@expr1073745215
202: *@expr1073745216 this@expr3374 ,
203: std ::@expr1073745217 bind (@expr1073745218 compareVisitor {@expr1073745219 } , std ::@expr3396 ref (@expr1073745221 result@var597 ) , std ::@expr3396 ref (@expr1073745223 rhs@var593 ) , std ::@expr1073745224 move (@expr1073745225 compare@var594 ) , std ::@expr1073745226 placeholders ::@expr1073745227 _1@expr1073745194 ) ) ;
204: return result@var597 ;
205: }
206:
207: bool operator== ( const Value & rhs@var598 ) const {
208: if (@expr1073745228 !@expr1073745229 equalValue (@expr1073745230 rhs@var598 ) ) {
209: return false ; }
210:
211: return varvalue@var616 ==@expr1073745231 rhs@var598 .@expr1073745232 varvalue@var599 &&@expr1073745233
212: condition@var617 ==@expr1073745234 rhs@var598 .@expr1073745235 condition@var600 &&@expr1073745236
213: varId@var619 ==@expr1073745237 rhs@var598 .@expr1073745238 varId@var601 &&@expr1073745239
214: conditional@var621 ==@expr1073745240 rhs@var598 .@expr1073745241 conditional@var602 &&@expr1073745242
215: defaultArg@var623 ==@expr1073745243 rhs@var598 .@expr1073745244 defaultArg@var603 &&@expr1073745245
216: indirect@var624 ==@expr1073745246 rhs@var598 .@expr1073745247 indirect@var604 &&@expr1073745248
217: valueKind@var635 ==@expr1073745249 rhs@var598 .@expr1073745250 valueKind@var605 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var606 ) const {
221: return !@expr1073745251 (@expr1073745252 *@expr1073745253 this@expr1073745254 ==@expr1073745255 rhs@var606 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var607 ) const {
226: bool result@var608 ; result@var608 =@expr1073745257 false ;
227: visitValue (@expr1073745258 *@expr1073745259 this@expr1073745260 , std ::@expr1073745261 bind (@expr1073745262 equalVisitor {@expr1073745263 } , std ::@expr1073745264 ref (@expr1073745265 result@var608 ) , x@var607 , std ::@expr1073745266 placeholders ::@expr1073745267 _1@expr1073745256 ) ) ;
228: return result@var608 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745268 bound@var611 ==@expr1073745269 Bound ::@expr1073745270 Lower ) {
233: visitValue (@expr1073745271 *@expr3448 this@expr3449 , increment {@expr1073745274 } ) ; }
234: else { if (@expr1073745275 bound@var611 ==@expr1073745276 Bound ::@expr1073745277 Upper ) {
235: visitValue (@expr1073745278 *@expr3448 this@expr3449 , decrement {@expr1073745280 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745281 bound@var611 ==@expr1073745282 Bound ::@expr3459 Lower ) {
240: bound@var611 =@expr1073745284 Bound ::@expr3461 Upper ; }
241: else { if (@expr1073745286 bound@var611 ==@expr1073745287 Bound ::@expr3461 Upper ) {
242: bound@var611 =@expr1073745289 Bound ::@expr3459 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745291 ) ;
247: decreaseRange (@expr1073745292 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var609 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var610 ;
267: bool isIntValue ( ) const {
268: return valueType@var610 ==@expr1073745293 ValueType ::@expr1073745294 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var610 ==@expr1073745295 ValueType ::@expr1073745296 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var610 ==@expr1073745297 ValueType ::@expr1073745298 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var610 ==@expr1073745299 ValueType ::@expr1073745300 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var610 ==@expr1073745301 ValueType ::@expr1073745302 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var610 ==@expr1073745303 ValueType ::@expr1073745304 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var610 ==@expr1073745305 ValueType ::@expr1073745306 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var610 ==@expr1073745307 ValueType ::@expr1073745308 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var610 ==@expr1073745309 ValueType ::@expr1073745310 ITERATOR_START ||@expr1073745311 valueType@var610 ==@expr1073745312 ValueType ::@expr1073745313 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var610 ==@expr1073745314 ValueType ::@expr1073745315 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var610 ==@expr1073745316 ValueType ::@expr1073745317 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var610 ==@expr1073745318 ValueType ::@expr1073745319 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var610 ==@expr1073745321 ValueType ::@expr1073745322 LIFETIME &&@expr1073745323 lifetimeScope@var630 ==@expr1073745324 LifetimeScope ::@expr1073745325 Local@expr1073745320 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var610 ==@expr1073745326 ValueType ::@expr1073745327 LIFETIME &&@expr1073745328 lifetimeScope@var630 ==@expr1073745329 LifetimeScope ::@expr1073745330 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var610 ==@expr1073745331 ValueType ::@expr1073745332 LIFETIME &&@expr1073745333 lifetimeScope@var630 ==@expr1073745334 LifetimeScope ::@expr1073745335 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745336 ) ||@expr1073745337 isUninitValue (@expr1073745338 ) ||@expr1073745339 isLifetimeValue (@expr1073745340 ) ;
318: }
319:
320:
321: Bound bound@var611 ;
322:
323:
324: long long intvalue@var612 ;
325:
326:
327: const Token * tokvalue@var613 ;
328:
329:
330: double floatValue@var614 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var615 ;
334:
335:
336: long long varvalue@var616 ;
337:
338:
339: const Token * condition@var617 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var618 ;
342:
343:
344: int varId@var619 ;
345:
346:
347: bool safe@var620 ;
348:
349:
350: bool conditional@var621 ;
351:
352:
353: bool macro@var622 ;
354:
355:
356: bool defaultArg@var623 ;
357:
358: int indirect@var624 ;
359:
360:
361: long long path@var625 ;
362:
363:
364: long long wideintvalue@var626 ;
365:
366: std :: vector < std :: string > subexpressions@var627 ;
367:
368:
369: const Token * capturetok@var628 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var629 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var630 ;
385:
386: static const char * toString ( MoveKind moveKind@var631 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var632 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var633 ) ;
389: static const char * toString ( Bound bound@var634 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var635 ;
402:
403: void setKnown ( ) {
404: valueKind@var635 =@expr1073745341 ValueKind ::@expr1073745342 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var635 ==@expr1073745343 ValueKind ::@expr1073745344 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var635 =@expr1073745346 ValueKind ::@expr1073745347 Possible@expr1073745345 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var635 ==@expr1073745349 ValueKind ::@expr1073745350 Possible@expr1073745348 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var635 ==@expr1073745351 ValueKind ::@expr1073745352 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var635 =@expr1073745353 ValueKind ::@expr1073745354 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var636 = true ) {
428: if (@expr1073745355 inconclusive@var636 ) {
429: valueKind@var635 =@expr1073745356 ValueKind ::@expr1073745357 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var635 ==@expr1073745358 ValueKind ::@expr1073745359 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745361 isKnown (@expr1073745362 ) ) {
438: valueKind@var635 =@expr1073745363 ValueKind ::@expr1073745364 Possible@expr1073745360 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745365 condition@var617 &&@expr1073745366 !@expr1073745367 defaultArg@var623 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var637 , const Token * tok2@var638 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var639 , const Settings * settings@var640 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var641 , SymbolDatabase * symboldatabase@var642 , ErrorLogger * errorLogger@var643 , const Settings * settings@var644 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var645 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var646 , const Settings * settings@var647 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var648 ,
459: const Settings * settings@var649 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var650 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var651 , const Token * indexTok@var652 , bool possible@var653 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var654 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var655 , const Settings * settings@var656 = nullptr , int depth@var657 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var658 ;
471: bool addressOf@var659 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var660 ;
473: bool inconclusive@var661 ;
474:
475: LifetimeToken ( ) : token@var658 ( nullptr ) , addressOf@var659 ( false ) , errorPath@var660 ( ) , inconclusive@var661 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var662 , ValueFlow :: Value :: ErrorPath errorPath@var663 )
478: : token@var658 ( token@var662 ) , addressOf@var659 ( false ) , errorPath@var660 ( std :: move ( errorPath@var663 ) ) , inconclusive@var661 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var664 , bool addressOf@var665 , ValueFlow :: Value :: ErrorPath errorPath@var666 )
482: : token@var658 ( token@var664 ) , addressOf@var659 ( addressOf@var665 ) , errorPath@var660 ( std :: move ( errorPath@var666 ) ) , inconclusive@var661 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var667 , bool b@var668 ) {
486: for (@expr1073745368 LifetimeToken &@expr1073745369 x@var669 :@expr1073745370 v@var667 ) {
487: x@var669 .@expr1073745371 addressOf@var670 =@expr1073745372 b@var668 ; }
488: return v@var667 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var671 , bool b@var672 ) {
492: for (@expr1073745373 LifetimeToken &@expr1073745374 x@var673 :@expr1073745375 v@var671 ) {
493: x@var673 .@expr1073745376 inconclusive@var674 =@expr1073745377 b@var672 ; }
494: return v@var671 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var675 , ValueFlow :: Value & true_value@var676 , ValueFlow :: Value & false_value@var677 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var678 ) ;
499: const Token * parseCompareInt ( const Token * tok@var679 , ValueFlow :: Value & true_value@var680 , ValueFlow :: Value & false_value@var681 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var682 , long long val@var683 , const Token * varTok@var684 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var685 , const Token * varTok@var686 , long long val@var687 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var688 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var689 ,
508: ValueFlow :: Value & value@var690 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var691 ,
511: bool escape@var692 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var693 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var694 , const Token * lifetime@var695 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var696 , ValueFlow :: Value :: ErrorPath & errorPath@var697 , bool * addressOf@var698 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var699 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var700 , const Settings * settings@var701 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var702 , const ValueFlow :: Value * val@var703 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var704 , const ValueFlow :: Value * val@var705 , ValueFlow :: Value :: ErrorPath & errorPath@var706 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var707 , bool inconclusive@var708 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var709 ,
529: bool inconclusive@var710 = false ,
530: long long path@var711 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var712 , const Scope * defaultScope@var713 = nullptr , bool smallest@var714 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var715 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var716 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var717 ;
69: std :: string mScope@var718 ;
70: std :: string mName@var719 ;
71: std :: string mFullName@var720 ;
72: const Token * mNameToken@var721 ;
73: const Token * mParamEnd@var722 ;
74: unsigned int mFlags@var723 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var724 ) {
90: setFlag (@expr1073745378 fIsClass , state@var724 ) ;
91: }
92: void isFunction ( bool state@var725 ) {
93: setFlag (@expr1073745379 fIsFunction , state@var725 ) ;
94: }
95: void isVariable ( bool state@var726 ) {
96: setFlag (@expr1073745380 fIsVariable , state@var726 ) ;
97: }
98: void isAlias ( bool state@var727 ) {
99: setFlag (@expr1073745381 fIsAlias , state@var727 ) ;
100: }
101: void isSpecialization ( bool state@var728 ) {
102: setFlag (@expr1073745382 fIsSpecialization , state@var728 ) ;
103: }
104: void isPartialSpecialization ( bool state@var729 ) {
105: setFlag (@expr1073745383 fIsPartialSpecialization , state@var729 ) ;
106: }
107: void isForwardDeclaration ( bool state@var730 ) {
108: setFlag (@expr1073745384 fIsForwardDeclaration , state@var730 ) ;
109: }
110: void isVariadic ( bool state@var731 ) {
111: setFlag (@expr1073745385 fIsVariadic , state@var731 ) ;
112: }
113: void isFriend ( bool state@var732 ) {
114: setFlag (@expr1073745386 fIsFriend , state@var732 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var733 ) const {
123: return (@expr3563 (@expr3563 mFlags@var723 &@expr1073745389 flag@var733 ) !=@expr1073745390 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var734 , bool state@var735 ) {
132: mFlags@var723 =@expr1073745391 state@var735 ?@expr1073745392 mFlags@var723 |@expr1073745393 flag@var734 :@expr1073745394 mFlags@var723 &@expr1073745395 ~@expr1073745396 flag@var734 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var736 , const std :: string & scope@var737 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var738 , const std :: string & scope@var739 , const Token * nameToken@var740 , const Token * paramEnd@var741 ) ;
150: TokenAndName ( const TokenAndName & other@var742 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var743 ) const {
154: return mToken@var717 ==@expr1073745397 rhs@var743 .@expr1073745398 mToken@var744 &&@expr1073745399 mScope@var718 ==@expr1073745400 rhs@var743 .@expr1073745401 mScope@var745 &&@expr1073745402 mName@var719 ==@expr1073745403 rhs@var743 .@expr1073745404 mName@var746 &&@expr1073745405 mFullName@var720 ==@expr1073745406 rhs@var743 .@expr1073745407 mFullName@var747 &&@expr1073745408
155: mNameToken@var721 ==@expr1073745409 rhs@var743 .@expr1073745410 mNameToken@var748 &&@expr1073745411 mParamEnd@var722 ==@expr1073745412 rhs@var743 .@expr1073745413 mParamEnd@var749 &&@expr1073745414 mFlags@var723 ==@expr1073745415 rhs@var743 .@expr1073745416 mFlags@var750 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var717 ;
160: }
161: void token ( Token * token@var751 ) {
162: mToken@var717 =@expr1073745417 token@var751 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var718 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var719 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var720 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var721 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var722 ;
178: }
179: void paramEnd ( const Token * end@var752 ) {
180: mParamEnd@var722 =@expr1073745418 end@var752 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745419 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745420 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745421 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745422 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745423 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745424 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745425 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745426 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745427 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var753 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var754 ) const {
243:
244:
245: return (@expr3604 (@expr3604 mFlags@var723 &@expr1073745430 fFamilyMask ) &@expr1073745431 (@expr3604 decl@var754 .@expr1073745433 mFlags@var755 &@expr1073745434 fFamilyMask ) ) !=@expr1073745435 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var756 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var757 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var758 , const unsigned long numberOfArguments@var759 , bool variadic@var760 , const char patternAfter@var761 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var762 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var763 , int & namepos@var764 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var765 , int & namepos@var766 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var767 , int & namepos@var768 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var769 ,
306: bool & codeWithTemplates@var770 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var771 , bool isTemplate@var772 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var773 = nullptr , Token * backToken@var774 = nullptr , bool isTemplate@var775 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var776 , Token * end@var777 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var778 , const std :: string & scope@var779 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var780 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var781 ,
393: const std :: list < const Token * > & specializations@var782 ,
394: const std :: time_t maxtime@var783 ,
395: std :: set < std :: string > & expandedtemplates@var784 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var785 , const Token * tok@var786 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var787 , const Token * tok@var788 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var789 ,
422: const TokenAndName & templateInstantiation@var790 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var791 ,
424: const std :: string & newName@var792 ,
425: bool copy@var793 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var794 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var795 ,
435: const std :: string & newName@var796 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var797 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var798 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var799 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var800 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var801 ,
458: const Token * templateInstantiationNameToken@var802 ,
459: const std :: list < const Token * > & specializations@var803 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var804 , const Token * end@var805 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var806 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var807 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var808 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var809 ,
487: const std :: string & indent@var810 = "    " ) const ;
488: void printOut ( const std :: string & text@var811 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var812 ;
491: TokenList & mTokenList@var813 ;
492: const Settings * mSettings@var814 ;
493: ErrorLogger * mErrorLogger@var815 ;
494: bool mChanged@var816 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var817 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var818 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var819 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var820 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var821 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var822 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var823 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var824 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var825 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var826 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var827 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var828 ;
57: Token * back@var829 ;
58: const TokenList * list@var830 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var831 , const Token * bodyEnd_@var832 , const std :: set < std :: string > & usingNamespaces_@var833 = std :: set < std :: string > ( ) ) : name@var834 ( name_@var831 ) , bodyEnd@var835 ( bodyEnd_@var832 ) , usingNamespaces@var836 ( usingNamespaces_@var833 ) { }
63: std :: string name@var834 ;
64: const Token * const bodyEnd@var835 ;
65: std :: set < std :: string > usingNamespaces@var836 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var837 ;
70: int mFileIndex@var838 ;
71: int mLineNumber@var839 ;
72: int mColumn@var840 ;
73: int mExprId@var841 ;
74:
75:
76: Token * mAstOperand1@var842 ;
77: Token * mAstOperand2@var843 ;
78: Token * mAstParent@var844 ;
79:
80:
81: const Scope * mScope@var845 ;
82: union {
83: const Function * mFunction@var846 ;
84: const Variable * mVariable@var847 ;
85: const :: Type * mType@var848 ;
86: const Enumerator * mEnumerator@var849 ;
87: } ;
88:
|
92:
93: int mProgressValue@var850 ;
94:
|
97:
98: int mIndex@var851 ;
99:
100:
101: std :: string * mOriginalName@var852 ;
102:
103:
104: ValueType * mValueType@var853 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var854 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var855 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var856 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var857 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var858 ;
119: long long value@var859 ;
120: struct CppcheckAttributes * next@var860 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var861 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var862 ;
126:
127:
128: unsigned char mBits@var863 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var864 , long long value@var865 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var866 , long long * value@var867 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var837 ( 0 )
135: , mFileIndex@var838 ( 0 )
136: , mLineNumber@var839 ( 0 )
137: , mColumn@var840 ( 0 )
138: , mExprId@var841 ( 0 )
139: , mAstOperand1@var842 ( nullptr )
140: , mAstOperand2@var843 ( nullptr )
141: , mAstParent@var844 ( nullptr )
142: , mScope@var845 ( nullptr )
143: , mFunction@var846 ( nullptr )
144: , mProgressValue@var850 ( 0 )
145: , mIndex@var851 ( 0 )
146: , mOriginalName@var852 ( nullptr )
147: , mValueType@var853 ( nullptr )
148: , mValues@var854 ( nullptr )
149: , mTemplateSimplifierPointers@var856 ( nullptr )
150: , mScopeInfo@var857 ( nullptr )
151: , mCppcheckAttributes@var861 ( nullptr )
152: , mCpp11init@var862 ( Cpp11init :: UNKNOWN )
153: , mBits@var863 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var868 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var869 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var870 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var871 ) {
199: mStr@var1083 =@expr1073745436 s@var871 ;
200: mImpl@var1089 .@expr1073745437 mVarId@var1120 =@expr1073745438 0 ;
201:
202: update_property_info (@expr1073745439 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var872 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1083 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var873 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var874 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var875 ) const ;
236: Token * tokAt ( int index@var876 ) {
237: return const_cast < Token *@expr3616 > (@expr1073745441 const_cast < const Token *@expr3616 > (@expr1073745443 this@expr1073745444 ) .@expr1073745445 tokAt (@expr1073745446 index@var876 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var877 ) const ;
245: Token * linkAt ( int index@var878 ) {
246: return const_cast < Token *@expr3623 > (@expr1073745448 const_cast < const Token *@expr3623 > (@expr1073745450 this@expr1073745451 ) .@expr1073745452 linkAt (@expr1073745453 index@var878 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var879 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var880 , const char ( & pattern@var881 ) [ count ] ) {
276: return simpleMatch (@expr1073745455 tok@var880 , pattern@var881 , count@expr1073745454 -@expr1073745456 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var882 , const char pattern@var883 [ ] , unsigned long pattern_len@var884 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var885 , const char pattern@var886 [ ] , int varid@var887 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var888 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var889 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var890 , const Settings * const settings@var891 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var892 , long long index@var893 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1089 .@expr1073745457 mValueType@var1121 ;
366: }
367: void setValueType ( ValueType * vt@var894 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var895 ; top@var895 =@expr1073745458 this@expr1073745459 ;
371: while (@expr1073745460 top@var895 &&@expr1073745461 !@expr1073745462 Token ::@expr1073745463 Match (@expr1073745464 top@var895 .@expr3641 astParent (@expr3642 ) , ",|(" ) ) {
372: top@var895 =@expr1073745467 top@var895 .@expr3641 astParent (@expr3642 ) ; }
373: return top@var895 ?@expr1073745470 top@var895 .@expr1073745471 mImpl@var896 .@expr1073745472 mValueType@var897 :@expr1073745473 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1087 ;
378: }
379: void tokType ( Token :: Type t@var898 ) {
380: mTokType@var1087 =@expr1073745474 t@var898 ;
381:
382: const bool memoizedIsName@var899 =@expr1073745475 mTokType@var1087 ==@expr1073745476 eName ||@expr1073745477 mTokType@var1087 ==@expr1073745478 eType ||@expr1073745479 mTokType@var1087 ==@expr1073745480 eVariable ||@expr1073745481
383: mTokType@var1087 ==@expr1073745482 eFunction ||@expr1073745483 mTokType@var1087 ==@expr1073745484 eKeyword ||@expr1073745485 mTokType@var1087 ==@expr3662 eBoolean ||@expr1073745487
384: mTokType@var1087 ==@expr3664 eEnumerator ;
385: setFlag (@expr1073745489 fIsName , memoizedIsName@var899 ) ;
386:
387: const bool memoizedIsLiteral@var900 =@expr1073745490 mTokType@var1087 ==@expr1073745491 eNumber ||@expr1073745492 mTokType@var1087 ==@expr1073745493 eString ||@expr1073745494 mTokType@var1087 ==@expr1073745495 eChar ||@expr1073745496
388: mTokType@var1087 ==@expr3662 eBoolean ||@expr1073745498 mTokType@var1087 ==@expr1073745499 eLiteral ||@expr1073745500 mTokType@var1087 ==@expr3664 eEnumerator ;
389: setFlag (@expr1073745502 fIsLiteral , memoizedIsLiteral@var900 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1087 ==@expr1073745503 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745504 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1088 ==@expr1073745505 fIsName &&@expr1073745506 mTokType@var1087 ==@expr1073745507 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745508 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1087 ==@expr1073745509 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1087 ==@expr1073745510 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745511 isConstOp (@expr1073745512 ) ||@expr1073745513
412: isAssignmentOp (@expr1073745514 ) ||@expr1073745515
413: mTokType@var1087 ==@expr1073745516 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745517 isArithmeticalOp (@expr1073745518 ) ||@expr1073745519
417: mTokType@var1087 ==@expr1073745520 eLogicalOp ||@expr1073745521
418: mTokType@var1087 ==@expr1073745522 eComparisonOp ||@expr1073745523
419: mTokType@var1087 ==@expr1073745524 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745525 ) ||@expr1073745526
423: mTokType@var1087 ==@expr1073745527 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1087 ==@expr1073745528 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1087 ==@expr1073745529 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1087 ==@expr1073745530 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1087 ==@expr1073745531 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1087 ==@expr1073745532 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745533 ) !=@expr1073745534 nullptr &&@expr1073745535 astOperand2 (@expr1073745536 ) !=@expr1073745537 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var901 ) const {
444: return s@var901 ==@expr1073745538 mStr@var1083 &&@expr1073745539 astOperand1 (@expr1073745540 ) !=@expr1073745541 nullptr &&@expr1073745542 astOperand2 (@expr1073745543 ) ==@expr1073745544 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1088 ;
450: }
451: void flags ( const unsigned int flags_@var902 ) {
452: mFlags@var1088 =@expr1073745545 flags_@var902 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745546 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var903 ) {
458: setFlag (@expr1073745547 fIsUnsigned , sign@var903 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745548 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var904 ) {
464: setFlag (@expr1073745549 fIsSigned , sign@var904 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745550 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var905 ) {
470: setFlag (@expr1073745551 fIsPointerCompare , b@var905 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745552 fIsLong ) ;
474: }
475: void isLong ( bool size@var906 ) {
476: setFlag (@expr1073745553 fIsLong , size@var906 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745554 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var907 ) {
482: setFlag (@expr1073745555 fIsStandardType , b@var907 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745556 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var908 ) {
488: setFlag (@expr1073745557 fIsExpandedMacro , m@var908 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745558 fIsCast ) ;
492: }
493: void isCast ( bool c@var909 ) {
494: setFlag (@expr1073745559 fIsCast , c@var909 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745560 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var910 ) {
500: setFlag (@expr1073745561 fIsAttributeConstructor , ac@var910 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745562 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var911 ) {
506: setFlag (@expr1073745563 fIsAttributeDestructor , value@var911 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745564 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var912 ) {
512: setFlag (@expr1073745565 fIsAttributeUnused , unused@var912 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745566 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var913 ) {
518: setFlag (@expr1073745567 fIsAttributeUsed , unused@var913 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745568 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var914 ) {
524: setFlag (@expr1073745569 fIsAttributePure , value@var914 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745570 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var915 ) {
530: setFlag (@expr1073745571 fIsAttributeConst , value@var915 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745572 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var916 ) {
536: setFlag (@expr1073745573 fIsAttributeNoreturn , value@var916 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745574 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var917 ) {
542: setFlag (@expr1073745575 fIsAttributeNothrow , value@var917 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745576 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var918 ) {
548: setFlag (@expr1073745577 fIsAttributePacked , value@var918 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745578 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var919 ) {
554: setFlag (@expr1073745579 fIsAttributeNodiscard , value@var919 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745580 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var920 ) {
560: setFlag (@expr1073745581 fIsAttributeMaybeUnused , value@var920 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var921 , long long value@var922 ) {
563: mImpl@var1089 .@expr1073745582 setCppcheckAttribute (@expr1073745583 type@var921 , value@var922 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var923 , long long * value@var924 ) const {
566: return mImpl@var1089 .@expr1073745584 getCppcheckAttribute (@expr1073745585 type@var923 , value@var924 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745586 mImpl@var1089 .@expr1073745587 mCppcheckAttributes@var1122 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745588 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745589 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var925 ) {
578: setFlag (@expr1073745590 fIsOperatorKeyword , value@var925 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745591 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var926 ) {
584: setFlag (@expr1073745592 fIsComplex , value@var926 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745593 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var927 ) {
590: setFlag (@expr1073745594 fIsEnumType , value@var927 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745595 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var928 ) {
596: setFlag (@expr1073745596 fAtAddress , b@var928 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745597 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var929 ) {
602: setFlag (@expr1073745598 fIncompleteVar , b@var929 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745599 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var930 ) {
609: setFlag (@expr1073745600 fIsIncompleteConstant , b@var930 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745601 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var931 ) {
616: setFlag (@expr1073745602 fConstexpr , b@var931 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745603 fExternC ) ;
621: }
622: void isExternC ( bool b@var932 ) {
623: setFlag (@expr1073745604 fExternC , b@var932 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745605 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var933 ) {
630: setFlag (@expr1073745606 fIsSplitVarDeclComma , b@var933 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745607 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var934 ) {
637: setFlag (@expr1073745608 fIsSplitVarDeclEq , b@var934 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745609 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var935 ) {
644: setFlag (@expr1073745610 fIsImplicitInt , b@var935 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745611 fIsInline ) ;
649: }
650: void isInline ( bool b@var936 ) {
651: setFlag (@expr1073745612 fIsInline , b@var936 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745613 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var937 ) {
658: setFlag (@expr1073745614 fIsRemovedVoidParameter , b@var937 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745615 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var938 ) {
665: setFlag (@expr1073745616 fIsTemplate , b@var938 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745617 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var939 ) {
672: setFlag (@expr1073745618 fIsSimplifedScope , b@var939 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1089 .@expr1073745619 mBits@var1123 >@expr1073745620 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1089 .@expr1073745621 mBits@var1123 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1089 .@expr1073745622 mTemplateSimplifierPointers@var1124 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var940 ) {
685: if (@expr1073745623 !@expr1073745624 mImpl@var1089 .@expr3801 mTemplateSimplifierPointers@var1124 ) {
686: mImpl@var1089 .@expr3801 mTemplateSimplifierPointers@var1124 =@expr1073745627 new std ::@expr1073745628 set < TemplateSimplifier ::@expr1073745629 TokenAndName *@expr1073745630 > ; }
687: mImpl@var1089 .@expr3801 mTemplateSimplifierPointers@var1124 .@expr1073745632 insert (@expr1073745633 tokenAndName@var940 ) ;
688: }
689: void setBits ( const unsigned char b@var941 ) {
690: mImpl@var1089 .@expr1073745634 mBits@var1123 =@expr1073745635 b@var941 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3812 (@expr3812 (@expr3812 mTokType@var1087 ==@expr1073745639 eString ) &&@expr1073745640 isPrefixStringCharLiteral (@expr1073745641 mStr@var1083 , '"' , "u8" ) ) ||@expr1073745642
695: (@expr3812 (@expr3812 mTokType@var1087 ==@expr1073745645 eChar ) &&@expr1073745646 isPrefixStringCharLiteral (@expr1073745647 mStr@var1083 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3824 (@expr3824 (@expr3824 mTokType@var1087 ==@expr1073745651 eString ) &&@expr1073745652 isPrefixStringCharLiteral (@expr1073745653 mStr@var1083 , '"' , "u" ) ) ||@expr1073745654
700: (@expr3824 (@expr3824 mTokType@var1087 ==@expr1073745657 eChar ) &&@expr1073745658 isPrefixStringCharLiteral (@expr1073745659 mStr@var1083 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3836 (@expr3836 (@expr3836 mTokType@var1087 ==@expr1073745663 eString ) &&@expr1073745664 isPrefixStringCharLiteral (@expr1073745665 mStr@var1083 , '"' , "U" ) ) ||@expr1073745666
705: (@expr3836 (@expr3836 mTokType@var1087 ==@expr1073745669 eChar ) &&@expr1073745670 isPrefixStringCharLiteral (@expr1073745671 mStr@var1083 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3848 (@expr3848 (@expr3848 mTokType@var1087 ==@expr1073745675 eString ) &&@expr1073745676 isPrefixStringCharLiteral (@expr1073745677 mStr@var1083 , '"' , "" ) ) ||@expr1073745678
710: (@expr3848 (@expr3848 mTokType@var1087 ==@expr1073745681 eChar ) &&@expr1073745682 isPrefixStringCharLiteral (@expr1073745683 mStr@var1083 , '\'' , "" ) &&@expr1073745684 mStr@var1083 .@expr1073745685 length (@expr1073745686 ) ==@expr1073745687 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3864 (@expr3864 (@expr3864 mTokType@var1087 ==@expr1073745691 eChar ) &&@expr1073745692 isPrefixStringCharLiteral (@expr1073745693 mStr@var1083 , '\'' , "" ) ) &&@expr1073745694
715: (@expr3864 mStr@var1083 .@expr1073745696 length (@expr1073745697 ) >@expr1073745698 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745699 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var942 ) {
738: setFlag (@expr1073745700 fIsTemplateArg , value@var942 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var943 , const char ( & pattern@var944 ) [ count ] ) {
743: return findsimplematch (@expr1073745702 startTok@var943 , pattern@var944 , count@expr1073745701 -@expr1073745703 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var945 , const char pattern@var946 [ ] , unsigned long pattern_len@var947 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var948 , const char ( & pattern@var949 ) [ count ] , const Token * const end@var950 ) {
749: return findsimplematch (@expr1073745705 startTok@var948 , pattern@var949 , count@expr1073745704 -@expr1073745706 1 , end@var950 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var951 , const char pattern@var952 [ ] , unsigned long pattern_len@var953 , const Token * const end@var954 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var955 , const char pattern@var956 [ ] , const int varId@var957 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var958 , const char pattern@var959 [ ] , const Token * const end@var960 , const int varId@var961 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var962 , const char ( & pattern@var963 ) [ count ] ) {
758: return findsimplematch (@expr1073745708 startTok@var962 , pattern@var963 , count@expr1073745707 -@expr1073745709 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var964 , const char pattern@var965 [ ] , unsigned long pattern_len@var966 ) {
761: return const_cast < Token *@expr3886 > (@expr1073745711 findsimplematch (@expr1073745712 const_cast < const Token *@expr3886 > (@expr1073745714 startTok@var964 ) , pattern@var965 , pattern_len@var966 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var967 , const char ( & pattern@var968 ) [ count ] , const Token * const end@var969 ) {
765: return findsimplematch (@expr1073745716 startTok@var967 , pattern@var968 , count@expr1073745715 -@expr1073745717 1 , end@var969 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var970 , const char pattern@var971 [ ] , unsigned long pattern_len@var972 , const Token * const end@var973 ) {
768: return const_cast < Token *@expr3894 > (@expr1073745719 findsimplematch (@expr1073745720 const_cast < const Token *@expr3894 > (@expr1073745722 startTok@var970 ) , pattern@var971 , pattern_len@var972 , end@var973 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var974 , const char pattern@var975 [ ] , const int varId@var976 = 0 ) {
772: return const_cast < Token *@expr3899 > (@expr1073745724 findmatch (@expr1073745725 const_cast < const Token *@expr3899 > (@expr1073745727 startTok@var974 ) , pattern@var975 , varId@var976 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var977 , const char pattern@var978 [ ] , const Token * const end@var979 , const int varId@var980 = 0 ) {
775: return const_cast < Token *@expr3904 > (@expr1073745729 findmatch (@expr1073745730 const_cast < const Token *@expr3904 > (@expr1073745732 startTok@var977 ) , pattern@var978 , end@var979 , varId@var980 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var981 , const char * haystack@var982 , int varid@var983 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1089 .@expr1073745733 mFileIndex@var1125 ;
796: }
797: void fileIndex ( int indexOfFile@var984 ) {
798: mImpl@var1089 .@expr1073745734 mFileIndex@var1125 =@expr1073745735 indexOfFile@var984 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1089 .@expr1073745736 mLineNumber@var1126 ;
803: }
804: void linenr ( int lineNumber@var985 ) {
805: mImpl@var1089 .@expr1073745737 mLineNumber@var1126 =@expr1073745738 lineNumber@var985 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1089 .@expr1073745739 mColumn@var1127 ;
810: }
811: void column ( int c@var986 ) {
812: mImpl@var1089 .@expr1073745740 mColumn@var1127 =@expr1073745741 c@var986 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1084 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var987 , const Token * end@var988 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var989 , const std :: string & originalNameStr@var990 = emptyString@var1 , bool prepend@var991 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var992 , const std :: string & originalNameStr@var993 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745742 tokenStr@var992 , originalNameStr@var993 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1085 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1089 .@expr1073745743 mVarId@var1120 ;
851: }
852: void varId ( int id@var994 ) {
853: mImpl@var1089 .@expr1073745744 mVarId@var1120 =@expr1073745745 id@var994 ;
854: if (@expr1073745746 id@var994 !=@expr1073745747 0 ) {
855: tokType (@expr1073745748 eVariable ) ;
856: isStandardType (@expr1073745749 false ) ;
857: } else {
858: update_property_info (@expr1073745750 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745751 mImpl@var1089 .@expr3928 mExprId@var1128 ) {
864: return mImpl@var1089 .@expr3928 mExprId@var1128 ; }
865: return mImpl@var1089 .@expr1073745754 mVarId@var1120 ;
866: }
867: void exprId ( int id@var995 ) {
868: mImpl@var1089 .@expr1073745755 mExprId@var1128 =@expr1073745756 id@var995 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var996 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var997 , const std :: vector < std :: string > & fileNames@var998 ) const ;
888:
|
891:
892: void printLines ( int lines@var999 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1000 , Token * start@var1001 , Token * end@var1002 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1003 ; varid@var1003 = false ;
905: bool exprid@var1004 ; exprid@var1004 = false ;
906: bool idtype@var1005 ; idtype@var1005 = false ;
907: bool attributes@var1006 ; attributes@var1006 = false ;
908: bool macro@var1007 ; macro@var1007 = false ;
909: bool linenumbers@var1008 ; linenumbers@var1008 = false ;
910: bool linebreaks@var1009 ; linebreaks@var1009 = false ;
911: bool files@var1010 ; files@var1010 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1011 ;
914: options@var1011 .@expr1073745757 attributes@var1012 =@expr1073745758 true ;
915: options@var1011 .@expr1073745759 macro@var1013 =@expr1073745760 true ;
916: options@var1011 .@expr1073745761 linenumbers@var1014 =@expr1073745762 true ;
917: options@var1011 .@expr1073745763 linebreaks@var1015 =@expr1073745764 true ;
918: options@var1011 .@expr1073745765 files@var1016 =@expr1073745766 true ;
919: return options@var1011 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1017 ; options@var1017 =@expr1073745767 forDebug (@expr1073745768 ) ;
923: options@var1017 .@expr1073745769 varid@var1018 =@expr1073745770 true ;
924: return options@var1017 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1019 ; options@var1019 =@expr1073745771 forDebug (@expr1073745772 ) ;
928: options@var1019 .@expr1073745773 exprid@var1020 =@expr1073745774 true ;
929: return options@var1019 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1021 ; options@var1021 =@expr1073745775 forDebug (@expr1073745776 ) ;
933: options@var1021 .@expr1073745777 exprid@var1022 =@expr1073745778 true ;
934: options@var1021 .@expr1073745779 varid@var1023 =@expr1073745780 true ;
935: options@var1021 .@expr1073745781 idtype@var1024 =@expr1073745782 true ;
936: return options@var1021 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1025 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1026 , bool attributes@var1027 , bool macro@var1028 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1029 , const std :: vector < std :: string > * fileNames@var1030 = nullptr , const Token * end@var1031 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1032 , bool attributes@var1033 = true ) const ;
952: std :: string stringifyList ( bool varid@var1034 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1035 , bool attributes@var1036 , bool linenumbers@var1037 , bool linebreaks@var1038 , bool files@var1039 , const std :: vector < std :: string > * fileNames@var1040 = nullptr , const Token * end@var1041 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1042 ) {
983: mLink@var1086 =@expr1073745783 linkToToken@var1042 ;
984: if (@expr1073745784 mStr@var1083 ==@expr1073745785 "<" ||@expr1073745786 mStr@var1083 ==@expr1073745787 ">" ) {
985: update_property_info (@expr1073745788 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1086 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1043 ) {
1006: mImpl@var1089 .@expr1073745789 mScope@var1129 =@expr1073745790 s@var1043 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1089 .@expr1073745791 mScope@var1129 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1044 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1087 ==@expr1073745792 eFunction ||@expr1073745793 mTokType@var1087 ==@expr1073745794 eLambda ?@expr1073745795 mImpl@var1089 .@expr1073745796 mFunction@var1130 :@expr1073745797 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1045 ) {
1034: mImpl@var1089 .@expr1073745798 mVariable@var1131 =@expr1073745799 v@var1045 ;
1035: if (@expr1073745800 v@var1045 ||@expr1073745801 mImpl@var1089 .@expr1073745802 mVarId@var1120 ) {
1036: tokType (@expr1073745803 eVariable ) ; }
1037: else { if (@expr1073745804 mTokType@var1087 ==@expr1073745805 eVariable ) {
1038: tokType (@expr1073745806 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1087 ==@expr1073745807 eVariable ?@expr1073745808 mImpl@var1089 .@expr1073745809 mVariable@var1131 :@expr1073745810 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1046 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1087 ==@expr1073745811 eType ?@expr1073745812 mImpl@var1089 .@expr1073745813 mType@var1132 :@expr1073745814 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1047 , const Token * * typeTok@var1048 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1049 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1050 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1087 ==@expr1073745815 eEnumerator ?@expr1073745816 mImpl@var1089 .@expr1073745817 mEnumerator@var1133 :@expr1073745818 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1051 ) {
1079: mImpl@var1089 .@expr1073745819 mEnumerator@var1133 =@expr1073745820 e@var1051 ;
1080: if (@expr1073745821 e@var1051 ) {
1081: tokType (@expr1073745822 eEnumerator ) ; }
1082: else { if (@expr1073745823 mTokType@var1087 ==@expr1073745824 eEnumerator ) {
1083: tokType (@expr1073745825 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1052 , Token * end@var1053 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1054 , Token * srcEnd@var1055 , Token * newLocation@var1056 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1089 .@expr1073745826 mProgressValue@var1134 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1057 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1089 .@expr4003 mOriginalName@var1135 ?@expr1073745828 *@expr1073745829 mImpl@var1089 .@expr4003 mOriginalName@var1135 :@expr1073745831 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1089 .@expr4008 mValues@var1108 ?@expr1073745833 *@expr1073745834 mImpl@var1089 .@expr4008 mValues@var1108 :@expr1073745836 TokenImpl ::@expr1073745837 mEmptyValueList@var855 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1058 ) {
1164: if (@expr1073745838 !@expr1073745839 mImpl@var1089 .@expr4016 mOriginalName@var1135 ) {
1165: mImpl@var1089 .@expr4016 mOriginalName@var1135 =@expr1073745842 new std ::@expr1073745843 string (@expr1073745844 name@var1058 ) ; }
1166: else {
1167: *@expr1073745845 mImpl@var1089 .@expr4016 mOriginalName@var1135 =@expr1073745847 name@var1058 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1059 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1060 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1061 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1089 .@expr1073745849 mValues@var1108 .@expr1073745850 front (@expr1073745851 ) .@expr1073745852 intvalue@expr1073745848 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1062 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1063 , long long path@var1064 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1065 , const Settings * settings@var1066 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1067 , const Settings * settings@var1068 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1069 , int argnr@var1070 , const Settings * settings@var1071 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1072 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1073 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1074 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1075 ) {
1200: if (@expr1073745853 mImpl@var1089 .@expr4030 mValues@var1108 ) {
1201: mImpl@var1089 .@expr4030 mValues@var1108 .@expr1073745856 remove_if (@expr1073745857 pred@var1075 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1089 .@expr1073745858 mIndex@var1136 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1076 ) {
1213: mNext@var1084 =@expr1073745859 nextToken@var1076 ;
1214: }
1215: void previous ( Token * previousToken@var1077 ) {
1216: mPrevious@var1085 =@expr1073745860 previousToken@var1077 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1078 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1079 , const char * word@var1080 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1081 , char c@var1082 ) ;
1235:
1236: std :: string mStr@var1083 ;
1237:
1238: Token * mNext@var1084 ;
1239: Token * mPrevious@var1085 ;
1240: Token * mLink@var1086 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1087 ;
1283:
1284: uint64_t mFlags@var1088 ;
1285:
1286: TokenImpl * mImpl@var1089 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1090 ) const {
1294: return (@expr4037 (@expr4037 mFlags@var1088 &@expr1073745863 flag_@var1090 ) !=@expr1073745864 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1091 , bool state_@var1092 ) {
1303: mFlags@var1088 =@expr1073745865 state_@var1092 ?@expr1073745866 mFlags@var1088 |@expr1073745867 flag_@var1091 :@expr1073745868 mFlags@var1088 &@expr1073745869 ~@expr1073745870 flag_@var1091 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1093 , const int indent1@var1094 = 0 , const int indent2@var1095 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1096 ) ;
1321: void astOperand2 ( Token * tok@var1097 ) ;
1322: void astParent ( Token * tok@var1098 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1089 .@expr1073745871 mAstOperand1@var1099 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1089 .@expr1073745872 mAstOperand1@var1099 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1089 .@expr1073745873 mAstOperand2@var1100 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1089 .@expr1073745874 mAstOperand2@var1100 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1089 .@expr1073745875 mAstParent@var1101 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1089 .@expr1073745876 mAstParent@var1101 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745877 !@expr1073745878 astParent (@expr4055 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745880 this@expr4057 ==@expr1073745882 astParent (@expr4055 ) .@expr4060 astOperand1 (@expr4061 ) ) {
1346: return astParent (@expr4055 ) .@expr4063 astOperand2 (@expr4064 ) ; }
1347: else { if (@expr1073745889 this@expr4057 ==@expr1073745890 astParent (@expr4055 ) .@expr4063 astOperand2 (@expr4064 ) ) {
1348: return astParent (@expr4055 ) .@expr4060 astOperand1 (@expr4061 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745897 !@expr1073745898 astParent (@expr4075 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745900 this@expr4077 ==@expr1073745902 astParent (@expr4075 ) .@expr4080 astOperand1 (@expr4081 ) ) {
1356: return astParent (@expr4075 ) .@expr4083 astOperand2 (@expr4084 ) ; }
1357: else { if (@expr1073745909 this@expr4077 ==@expr1073745910 astParent (@expr4075 ) .@expr4083 astOperand2 (@expr4084 ) ) {
1358: return astParent (@expr4075 ) .@expr4080 astOperand1 (@expr4081 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1102 ; ret@var1102 =@expr1073745917 this@expr1073745918 ;
1364: while (@expr1073745919 ret@var1102 .@expr4096 mImpl@var1103 .@expr4097 mAstParent@var1104 ) {
1365: ret@var1102 =@expr1073745922 ret@var1102 .@expr4096 mImpl@var1103 .@expr4097 mAstParent@var1104 ; }
1366: return ret@var1102 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1105 ; ret@var1105 =@expr1073745925 this@expr1073745926 ;
1371: while (@expr1073745927 ret@var1105 .@expr4104 mImpl@var1106 .@expr4105 mAstParent@var1107 ) {
1372: ret@var1105 =@expr1073745930 ret@var1105 .@expr4104 mImpl@var1106 .@expr4105 mAstParent@var1107 ; }
1373: return ret@var1105 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1089 .@expr1073745933 mAstOperand1@var1099 =@expr1073745934 mImpl@var1089 .@expr1073745935 mAstOperand2@var1100 =@expr1073745936 mImpl@var1089 .@expr1073745937 mAstParent@var1101 =@expr1073745938 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1089 .@expr4115 mValues@var1108 ;
1393: mImpl@var1089 .@expr4115 mValues@var1108 =@expr1073745941 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1109 = "" ) const {
1397: std ::@expr1073745942 string ret@var1110 ;
1398: if (@expr1073745943 mImpl@var1089 .@expr4120 mAstOperand1@var1099 ) {
1399: ret@var1110 =@expr1073745945 mImpl@var1089 .@expr4120 mAstOperand1@var1099 .@expr1073745947 astString (@expr1073745948 sep@var1109 ) ; }
1400: if (@expr1073745949 mImpl@var1089 .@expr4126 mAstOperand2@var1100 ) {
1401: ret@var1110 +=@expr1073745951 mImpl@var1089 .@expr4126 mAstOperand2@var1100 .@expr1073745953 astString (@expr1073745954 sep@var1109 ) ; }
1402: return ret@var1110 +@expr1073745955 sep@var1109 +@expr1073745956 mStr@var1083 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1111 , bool xml@var1112 , const std :: vector < std :: string > & fileNames@var1113 , std :: ostream & out@var1114 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1115 , std :: ostream & out@var1116 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1117 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1118 ) const {
1419: mImpl@var1089 .@expr1073745957 mCpp11init@var1119 =@expr1073745958 cpp11init@var1118 ?@expr1073745959 TokenImpl ::@expr4136 Cpp11init ::@expr1073745961 CPP11INIT :@expr1073745962 TokenImpl ::@expr4136 Cpp11init ::@expr1073745964 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1089 .@expr1073745965 mCpp11init@var1119 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1137 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1138 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1139 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1140 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1141 ( nullptr ) , num@var1142 ( 0 ) , known@var1143 ( true ) { }
62:
63: const Token * tok@var1141 ;
64: long long num@var1142 ;
65: bool known@var1143 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1144 ;
72: const Scope * classScope@var1145 ;
73: const Scope * enclosingScope@var1146 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1147 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1149 ( nullptr ) , nameTok@var1150 ( nullptr ) , access@var1151 ( AccessControl :: Public ) , isVirtual@var1152 ( false ) { }
82:
83: std :: string name@var1148 ;
84: const Type * type@var1149 ;
85: const Token * nameTok@var1150 ;
86: AccessControl access@var1151 ;
87: bool isVirtual@var1152 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1153 ) const {
90: return this@expr1073745966 .@expr1073745967 type@var1149 <@expr1073745968 rhs@var1153 .@expr1073745969 type@var1154 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1155 ( nullptr ) , nameEnd@var1156 ( nullptr ) , type@var1157 ( nullptr ) { }
97:
98: const Token * nameStart@var1155 ;
99: const Token * nameEnd@var1156 ;
100: const Type * type@var1157 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1158 ;
104: std :: vector < FriendInfo > friendList@var1159 ;
105:
106: const Token * typeStart@var1160 ;
107: const Token * typeEnd@var1161 ;
108: long long sizeOf@var1162 ;
109:
110: Type ( const Token * classDef_@var1163 = nullptr , const Scope * classScope_@var1164 = nullptr , const Scope * enclosingScope_@var1165 = nullptr ) :
111: classDef@var1144 ( classDef_@var1163 ) ,
112: classScope@var1145 ( classScope_@var1164 ) ,
113: enclosingScope@var1146 ( enclosingScope_@var1165 ) ,
114: needInitialization@var1147 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1160 ( nullptr ) ,
116: typeEnd@var1161 ( nullptr ) ,
117: sizeOf@var1162 ( 0 ) {
118: if (@expr1073745970 classDef_@var1163 &&@expr1073745971 classDef_@var1163 .@expr4148 str (@expr4149 ) ==@expr1073745974 "enum" ) {
119: needInitialization@var1147 =@expr1073745975 NeedInitialization ::@expr1073745976 True ; }
120: else { if (@expr1073745977 classDef_@var1163 &&@expr1073745978 classDef_@var1163 .@expr4148 str (@expr4149 ) ==@expr1073745981 "using" ) {
121: typeStart@var1160 =@expr1073745982 classDef@var1144 .@expr1073745983 tokAt (@expr1073745984 3 ) ;
122: typeEnd@var1161 =@expr1073745985 typeStart@var1160 ;
123: while (@expr1073745986 typeEnd@var1161 .@expr4163 next (@expr4164 ) &&@expr1073745989 typeEnd@var1161 .@expr4163 next (@expr4164 ) .@expr1073745992 str (@expr1073745993 ) !=@expr1073745994 ";" ) {
124: typeEnd@var1161 =@expr1073745995 typeEnd@var1161 .@expr4163 next (@expr4164 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1144 ?@expr1073745998 classDef@var1144 .@expr1073745999 str (@expr1073746000 ) :@expr1073746001 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1144 &&@expr1073746002 classDef@var1144 .@expr1073746003 str (@expr1073746004 ) ==@expr1073746005 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1166 , const Token * tok1@var1167 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1168 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1169 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1170 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1171 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1172 ) : scope@var1173 ( scope_@var1172 ) , name@var1174 ( nullptr ) , value@var1175 ( 0 ) , start@var1176 ( nullptr ) , end@var1177 ( nullptr ) , value_known@var1178 ( false ) { }
167: const Scope * scope@var1173 ;
168: const Token * name@var1174 ;
169: long long value@var1175 ;
170: const Token * start@var1176 ;
171: const Token * end@var1177 ;
172: bool value_known@var1178 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1179 ) const {
204: return (@expr4182 (@expr4182 mFlags@var1215 &@expr1073746008 flag_@var1179 ) !=@expr1073746009 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1180 , bool state_@var1181 ) {
213: mFlags@var1215 =@expr1073746010 state_@var1181 ?@expr1073746011 mFlags@var1215 |@expr1073746012 flag_@var1180 :@expr1073746013 mFlags@var1215 &@expr1073746014 ~@expr1073746015 flag_@var1180 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1182 , bool * isContainer@var1183 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1184 , const Token * start_@var1185 , const Token * end_@var1186 ,
226: int index_@var1187 , AccessControl access_@var1188 , const Type * type_@var1189 ,
227: const Scope * scope_@var1190 , const Settings * settings@var1191 )
228: : mNameToken@var1210 ( name_@var1184 ) ,
229: mTypeStartToken@var1211 ( start_@var1185 ) ,
230: mTypeEndToken@var1212 ( end_@var1186 ) ,
231: mIndex@var1213 ( index_@var1187 ) ,
232: mAccess@var1214 ( access_@var1188 ) ,
233: mFlags@var1215 ( 0 ) ,
234: mType@var1216 ( type_@var1189 ) ,
235: mScope@var1217 ( scope_@var1190 ) ,
236: mValueType@var1218 ( nullptr ) {
237: evaluate (@expr1073746016 settings@var1191 ) ;
238: }
239:
240: Variable ( const Token * name_@var1192 , const std :: string & clangType@var1193 , const Token * typeStart@var1194 ,
241: const Token * typeEnd@var1195 , int index_@var1196 , AccessControl access_@var1197 ,
242: const Type * type_@var1198 , const Scope * scope_@var1199 ) ;
243:
244: Variable ( const Variable & var@var1200 , const Scope * scope@var1201 ) ;
245:
246: Variable ( const Variable & var@var1202 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1203 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1210 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1211 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1212 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073746017 mNameToken@var1210 ) {
300: return mNameToken@var1210 .@expr1073746018 str (@expr1073746019 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073746020 mNameToken@var1210 ) {
312: return mNameToken@var1210 .@expr1073746021 varId (@expr1073746022 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1213 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1214 ==@expr1073746023 AccessControl ::@expr1073746024 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1214 ==@expr1073746025 AccessControl ::@expr1073746026 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1214 ==@expr1073746027 AccessControl ::@expr1073746028 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1214 ==@expr1073746029 AccessControl ::@expr1073746030 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1214 ==@expr1073746031 AccessControl ::@expr1073746032 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1214 ==@expr1073746033 AccessControl ::@expr1073746034 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073746036 mAccess@var1214 ==@expr1073746037 AccessControl ::@expr1073746038 Local@expr1073746035 ) &&@expr1073746039 !@expr1073746040 isExtern (@expr1073746041 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073746042 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073746043 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073746044 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073746045 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073746046 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1214 ==@expr1073746047 AccessControl ::@expr1073746048 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073746049 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073746050 fIsArray ) &&@expr1073746051 !@expr1073746052 getFlag (@expr1073746053 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073746054 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073746055 ) &&@expr1073746056 getFlag (@expr1073746057 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073746058 fIsArray ) ||@expr1073746059 getFlag (@expr1073746060 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073746061 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073746062 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073746063 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073746064 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1216 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1216 ?@expr1073746065 mType@var1216 .@expr1073746066 classScope@var1221 :@expr1073746067 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1217 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1219 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1204 ) const {
550: return mDimensions@var1219 [@expr1073746068 index_@var1204 ] .@expr1073746069 num@var2743 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1205 ) const {
558: return mDimensions@var1219 [@expr1073746070 index_@var1205 ] .@expr1073746071 known@var2744 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073746072 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073746073 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073746074 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1206 ) const {
602: return isStlType (@expr1073746075 ) &&@expr1073746076 stlType@var1206 ==@expr1073746077 mTypeStartToken@var1211 .@expr1073746078 strAt (@expr1073746079 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1207 ) const {
616: return isStlType (@expr1073746080 ) &&@expr1073746081 stlTypes@var1207 .@expr1073746082 find (@expr1073746083 mTypeStartToken@var1211 .@expr1073746084 strAt (@expr1073746085 2 ) ) !=@expr1073746086 stlTypes@var1207 .@expr1073746087 end (@expr1073746088 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073746089 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4266 ) &&@expr1073746091 type (@expr4266 ) .@expr1073746093 isEnumType (@expr1073746094 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073746095 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1218 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1208 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1214 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1209 ) {
660: mType@var1216 =@expr1073746096 t@var1209 ;
661: }
662:
663:
664: const Token * mNameToken@var1210 ;
665:
666:
667: const Token * mTypeStartToken@var1211 ;
668:
669:
670: const Token * mTypeEndToken@var1212 ;
671:
672:
673: int mIndex@var1213 ;
674:
675:
676: AccessControl mAccess@var1214 ;
677:
678:
679: unsigned int mFlags@var1215 ;
680:
681:
682: const Type * mType@var1216 ;
683:
684:
685: const Scope * mScope@var1217 ;
686:
687: ValueType * mValueType@var1218 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1219 ;
691:
692:
693: void evaluate ( const Settings * settings@var1220 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1222 ) const {
735: return (@expr4273 (@expr4273 mFlags@var1271 &@expr1073746099 flag@var1222 ) !=@expr1073746100 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1223 , bool state@var1224 ) {
744: mFlags@var1271 =@expr1073746101 state@var1224 ?@expr1073746102 mFlags@var1271 |@expr1073746103 flag@var1223 :@expr1073746104 mFlags@var1271 &@expr1073746105 ~@expr1073746106 flag@var1223 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1225 , const Token * tok@var1226 , const Scope * scope@var1227 , const Token * tokDef@var1228 , const Token * tokArgDef@var1229 ) ;
751: Function ( const Token * tokenDef@var1230 , const std :: string & clangType@var1231 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1241 .@expr1073746107 str (@expr1073746108 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1249 .@expr1073746109 size (@expr1073746110 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1249 .@expr1073746111 size (@expr1073746112 ) -@expr1073746113 initArgCount@var1250 ;
764: }
765: const Variable * getArgumentVar ( int num@var1232 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1250 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1233 , const Scope * scope@var1234 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1235 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1236 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1251 ==@expr1073746114 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1251 ==@expr1073746115 eConstructor ||@expr1073746116
785: type@var1251 ==@expr1073746117 eCopyConstructor ||@expr1073746118
786: type@var1251 ==@expr1073746119 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1251 ==@expr1073746120 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1241 .@expr1073746121 isAttributeConstructor (@expr1073746122 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1241 .@expr1073746123 isAttributeDestructor (@expr1073746124 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1241 .@expr1073746125 isAttributePure (@expr1073746126 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1241 .@expr1073746127 isAttributeConst (@expr1073746128 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1241 .@expr1073746129 isAttributeNoreturn (@expr1073746130 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1241 .@expr1073746131 isAttributeNothrow (@expr1073746132 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1241 .@expr1073746133 isAttributeNodiscard (@expr1073746134 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073746135 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073746136 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073746137 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073746138 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073746139 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073746140 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073746141 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073746142 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073746143 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073746144 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073746145 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073746146 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073746147 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073746148 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073746149 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073746150 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073746151 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073746152 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073746153 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073746154 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073746155 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073746156 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1237 ) {
881: setFlag (@expr1073746157 fHasBody , state@var1237 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073746158 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746159 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1238 ) {
891: setFlag (@expr1073746160 fIsEscapeFunction , state@var1238 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746161 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1239 ) {
898: setFlag (@expr1073746162 fIsConstexpr , state@var1239 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1240 ) const ;
901:
902: const Token * tokenDef@var1241 ;
903: const Token * argDef@var1242 ;
904: const Token * token@var1243 ;
905: const Token * arg@var1244 ;
906: const Token * retDef@var1245 ;
907: const :: Type * retType@var1246 ;
908: const Scope * functionScope@var1247 ;
909: const Scope * nestedIn@var1248 ;
910: std :: list < Variable > argumentList@var1249 ;
911: int initArgCount@var1250 ;
912: Type type@var1251 ;
913: AccessControl access@var1252 ;
914: const Token * noexceptArg@var1253 ;
915: const Token * throwArg@var1254 ;
916: const Token * templateDef@var1255 ;
917: const Token * functionPointerUsage@var1256 ;
918:
919: bool argsMatch ( const Scope * scope@var1257 , const Token * first@var1258 , const Token * second@var1259 , const std :: string & path@var1260 , int path_length@var1261 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1262 , bool unknown@var1263 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1264 , bool unknown@var1265 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1266 , bool unknown@var1267 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1268 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746163 this@expr1073746164 .@expr1073746165 hasTrailingReturnType (@expr1073746166 ) ) {
931: return Token ::@expr1073746167 findmatch (@expr1073746168 retDef@var1245 , "{|;" ) ;
932: } else {
933: return tokenDef@var1241 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1269 , bool * foundAllBaseClasses@var1270 ) const ;
946:
947: unsigned int mFlags@var1271 ;
948:
949: void isInline ( bool state@var1272 ) {
950: setFlag (@expr1073746169 fIsInline , state@var1272 ) ;
951: }
952: void isConst ( bool state@var1273 ) {
953: setFlag (@expr1073746170 fIsConst , state@var1273 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1274 ) {
956: setFlag (@expr1073746171 fHasVirtualSpecifier , state@var1274 ) ;
957: }
958: void isPure ( bool state@var1275 ) {
959: setFlag (@expr1073746172 fIsPure , state@var1275 ) ;
960: }
961: void isStatic ( bool state@var1276 ) {
962: setFlag (@expr1073746173 fIsStatic , state@var1276 ) ;
963: }
964: void isStaticLocal ( bool state@var1277 ) {
965: setFlag (@expr1073746174 fIsStaticLocal , state@var1277 ) ;
966: }
967: void isExtern ( bool state@var1278 ) {
968: setFlag (@expr1073746175 fIsExtern , state@var1278 ) ;
969: }
970: void isFriend ( bool state@var1279 ) {
971: setFlag (@expr1073746176 fIsFriend , state@var1279 ) ;
972: }
973: void isExplicit ( bool state@var1280 ) {
974: setFlag (@expr1073746177 fIsExplicit , state@var1280 ) ;
975: }
976: void isDefault ( bool state@var1281 ) {
977: setFlag (@expr1073746178 fIsDefault , state@var1281 ) ;
978: }
979: void isDelete ( bool state@var1282 ) {
980: setFlag (@expr1073746179 fIsDelete , state@var1282 ) ;
981: }
982: void isNoExcept ( bool state@var1283 ) {
983: setFlag (@expr1073746180 fIsNoExcept , state@var1283 ) ;
984: }
985: void isThrow ( bool state@var1284 ) {
986: setFlag (@expr1073746181 fIsThrow , state@var1284 ) ;
987: }
988: void isOperator ( bool state@var1285 ) {
989: setFlag (@expr1073746182 fIsOperator , state@var1285 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1286 ) {
992: setFlag (@expr1073746183 fHasLvalRefQual , state@var1286 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1287 ) {
995: setFlag (@expr1073746184 fHasRvalRefQual , state@var1287 ) ;
996: }
997: void isVariadic ( bool state@var1288 ) {
998: setFlag (@expr1073746185 fIsVariadic , state@var1288 ) ;
999: }
1000: void isVolatile ( bool state@var1289 ) {
1001: setFlag (@expr1073746186 fIsVolatile , state@var1289 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1290 ) {
1004: return setFlag (@expr1073746187 fHasTrailingReturnType , state@var1290 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1291 ) {
1007: setFlag (@expr1073746188 fIsInlineKeyword , state@var1291 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1292 , const Scope * scope@var1293 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1294 ;
1019: const Scope * scope@var1295 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1296 , const Token * classDef_@var1297 , const Scope * nestedIn_@var1298 ) ;
1025: Scope ( const SymbolDatabase * check_@var1299 , const Token * classDef_@var1300 , const Scope * nestedIn_@var1301 , ScopeType type_@var1302 , const Token * start_@var1303 ) ;
1026:
1027: const SymbolDatabase * check@var1304 ;
1028: std :: string className@var1305 ;
1029: const Token * classDef@var1306 ;
1030: const Token * bodyStart@var1307 ;
1031: const Token * bodyEnd@var1308 ;
1032: std :: list < Function > functionList@var1309 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1310 ;
1034: std :: list < Variable > varlist@var1311 ;
1035: const Scope * nestedIn@var1312 ;
1036: std :: list < Scope * > nestedList@var1313 ;
1037: int numConstructors@var1314 ;
1038: int numCopyOrMoveConstructors@var1315 ;
1039: std :: list < UsingInfo > usingList@var1316 ;
1040: ScopeType type@var1317 ;
1041: Type * definedType@var1318 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1319 ;
1043: std :: vector < const Token * > bodyStartList@var1320 ;
1044:
1045:
1046: const Scope * functionOf@var1321 ;
1047: Function * function@var1322 ;
1048:
1049:
1050: const Token * enumType@var1323 ;
1051: bool enumClass@var1324 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1325 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1326 ) {
1056: bodyStart@var1307 =@expr1073746189 start@var1326 ;
1057: bodyEnd@var1308 =@expr1073746190 start@var1326 ?@expr1073746191 start@var1326 .@expr1073746192 link (@expr1073746193 ) :@expr1073746194 nullptr ;
1058: if (@expr1073746195 start@var1326 ) {
1059: bodyStartList@var1320 .@expr1073746196 push_back (@expr1073746197 start@var1326 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1305 .@expr1073746198 size (@expr1073746199 ) >@expr1073746200 9 &&@expr1073746201 className@var1305 .@expr1073746202 compare (@expr1073746203 0 , 9 , "Anonymous" ) ==@expr1073746204 0 &&@expr1073746205 std ::@expr1073746206 isdigit (@expr1073746207 className@var1305 [@expr1073746208 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1327 ) const {
1068: for (@expr1073746209 const Enumerator &@expr1073746210 i@var1328 :@expr1073746211 enumeratorList@var1325 ) {
1069: if (@expr1073746212 i@var1328 .@expr1073746213 name@var1329 .@expr1073746214 str (@expr1073746215 ) ==@expr1073746216 name@var1327 ) {
1070: return &@expr1073746217 i@var1328 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1330 ) const {
1076: if (@expr1073746218 !@expr1073746219 outer@var1330 ) {
1077: return false ; }
1078: if (@expr1073746220 outer@var1330 ==@expr1073746221 this@expr1073746222 ) {
1079: return true ; }
1080: const Scope * parent@var1331 ; parent@var1331 =@expr1073746223 nestedIn@var1312 ;
1081: while (@expr1073746224 outer@var1330 !=@expr1073746225 parent@var1331 &&@expr1073746226 parent@var1331 ) {
1082: parent@var1331 =@expr1073746227 parent@var1331 .@expr1073746228 nestedIn@var1332 ; }
1083: if (@expr1073746229 parent@var1331 &&@expr1073746230 parent@var1331 ==@expr1073746231 outer@var1330 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1333 ) {
1089: while (@expr1073746232 scope@var1333 ) {
1090: if (@expr1073746233 scope@var1333 .@expr1073746234 type@var1334 ==@expr1073746235 Scope ::@expr1073746236 eFunction ) {
1091: break ; }
1092: scope@var1333 =@expr1073746237 scope@var1333 .@expr1073746238 nestedIn@var1335 ;
1093: }
1094: if (@expr1073746239 !@expr1073746240 scope@var1333 ) {
1095: return nullptr ; }
1096: return scope@var1333 .@expr1073746241 function@var1336 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746242 type@var1317 ==@expr1073746243 eClass ||@expr1073746244 type@var1317 ==@expr1073746245 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746246 type@var1317 ==@expr1073746247 eClass ||@expr1073746248 type@var1317 ==@expr1073746249 eStruct ||@expr1073746250 type@var1317 ==@expr1073746251 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1317 !=@expr1073746252 eClass &&@expr1073746253 type@var1317 !=@expr1073746254 eStruct &&@expr1073746255 type@var1317 !=@expr1073746256 eUnion &&@expr1073746257 type@var1317 !=@expr1073746258 eGlobal &&@expr1073746259 type@var1317 !=@expr1073746260 eNamespace &&@expr1073746261 type@var1317 !=@expr1073746262 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1317 ==@expr1073746263 Scope ::@expr4440 ScopeType ::@expr1073746265 eFor ||@expr1073746266 type@var1317 ==@expr1073746267 Scope ::@expr4440 ScopeType ::@expr1073746269 eWhile ||@expr1073746270 type@var1317 ==@expr1073746271 Scope ::@expr4440 ScopeType ::@expr1073746273 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746274 type@var1317 ==@expr1073746275 eIf ||@expr1073746276 type@var1317 ==@expr1073746277 eElse ||@expr1073746278
1117: type@var1317 ==@expr1073746279 eFor ||@expr1073746280 type@var1317 ==@expr1073746281 eWhile ||@expr1073746282 type@var1317 ==@expr1073746283 eDo ||@expr1073746284
1118: type@var1317 ==@expr1073746285 eSwitch ||@expr1073746286 type@var1317 ==@expr1073746287 eUnconditional ||@expr1073746288
1119: type@var1317 ==@expr1073746289 eTry ||@expr1073746290 type@var1317 ==@expr1073746291 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1337 , bool requireConst@var1338 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1339 , bool isC@var1340 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1341 ) {
1135: return const_cast < Scope *@expr4468 > (@expr1073746293 const_cast < const Scope *@expr4468 > (@expr1073746295 this@expr1073746296 ) .@expr1073746297 findRecordInNestedList (@expr1073746298 name@var1341 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1342 ) const ;
1139: Type * findType ( const std :: string & name@var1343 ) {
1140: return const_cast < Type *@expr4475 > (@expr1073746300 const_cast < const Scope *@expr4475 > (@expr1073746302 this@expr1073746303 ) .@expr1073746304 findType (@expr1073746305 name@var1343 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1344 ) ;
1148:
1149: void addVariable ( const Token * token_@var1345 , const Token * start_@var1346 ,
1150: const Token * end_@var1347 , AccessControl access_@var1348 , const Type * type_@var1349 ,
1151: const Scope * scope_@var1350 , const Settings * settings@var1351 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1352 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1353 ) {
1159: functionList@var1309 .@expr1073746306 push_back (@expr1073746307 func@var1353 ) ;
1160:
1161: const Function * back@var1354 ; back@var1354 =@expr1073746308 &@expr1073746309 functionList@var1309 .@expr1073746310 back (@expr1073746311 ) ;
1162:
1163: functionMap@var1310 .@expr1073746312 insert (@expr1073746313 make_pair (@expr1073746314 back@var1354 .@expr1073746315 tokenDef@var1355 .@expr1073746316 str (@expr1073746317 ) , back@var1354 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1356 , AccessControl varaccess@var1357 , const Settings * settings@var1358 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1359 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1360 , bool isCpp@var1361 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1362 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1363 , const Token * & vartok@var1364 , const Token * & typetok@var1365 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1366 , int args@var1367 , std :: vector < const Function * > & matches@var1368 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1369 , const Token * start@var1370 , const Token * end@var1371 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1372 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1373 ;
1239: int bits@var1374 ;
1240: int pointer@var1375 ;
1241: int constness@var1376 ;
1242: Reference reference@var1377 ; reference@var1377 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1378 ;
1245: const :: Type * smartPointerType@var1379 ;
1246: const Token * smartPointerTypeToken@var1380 ;
1247: const Library :: SmartPointer * smartPointer@var1381 ;
1248: const Library :: Container * container@var1382 ;
1249:
1250: const Token * containerTypeToken@var1383 ;
1251:
1252: std :: string originalTypeName@var1384 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1372 ( UNKNOWN_SIGN ) ,
1257: type@var1373 ( UNKNOWN_TYPE ) ,
1258: bits@var1374 ( 0 ) ,
1259: pointer@var1375 ( 0U ) ,
1260: constness@var1376 ( 0U ) ,
1261: typeScope@var1378 ( nullptr ) ,
1262: smartPointerType@var1379 ( nullptr ) ,
1263: smartPointerTypeToken@var1380 ( nullptr ) ,
1264: smartPointer@var1381 ( nullptr ) ,
1265: container@var1382 ( nullptr ) ,
1266: containerTypeToken@var1383 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1385 , enum Type t@var1386 , int p@var1387 )
1269: : sign@var1372 ( s@var1385 ) ,
1270: type@var1373 ( t@var1386 ) ,
1271: bits@var1374 ( 0 ) ,
1272: pointer@var1375 ( p@var1387 ) ,
1273: constness@var1376 ( 0U ) ,
1274: typeScope@var1378 ( nullptr ) ,
1275: smartPointerType@var1379 ( nullptr ) ,
1276: smartPointerTypeToken@var1380 ( nullptr ) ,
1277: smartPointer@var1381 ( nullptr ) ,
1278: container@var1382 ( nullptr ) ,
1279: containerTypeToken@var1383 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1388 , enum Type t@var1389 , int p@var1390 , int c@var1391 )
1282: : sign@var1372 ( s@var1388 ) ,
1283: type@var1373 ( t@var1389 ) ,
1284: bits@var1374 ( 0 ) ,
1285: pointer@var1375 ( p@var1390 ) ,
1286: constness@var1376 ( c@var1391 ) ,
1287: typeScope@var1378 ( nullptr ) ,
1288: smartPointerType@var1379 ( nullptr ) ,
1289: smartPointerTypeToken@var1380 ( nullptr ) ,
1290: smartPointer@var1381 ( nullptr ) ,
1291: container@var1382 ( nullptr ) ,
1292: containerTypeToken@var1383 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1392 , enum Type t@var1393 , int p@var1394 , int c@var1395 , const std :: string & otn@var1396 )
1295: : sign@var1372 ( s@var1392 ) ,
1296: type@var1373 ( t@var1393 ) ,
1297: bits@var1374 ( 0 ) ,
1298: pointer@var1375 ( p@var1394 ) ,
1299: constness@var1376 ( c@var1395 ) ,
1300: typeScope@var1378 ( nullptr ) ,
1301: smartPointerType@var1379 ( nullptr ) ,
1302: smartPointerTypeToken@var1380 ( nullptr ) ,
1303: smartPointer@var1381 ( nullptr ) ,
1304: container@var1382 ( nullptr ) ,
1305: containerTypeToken@var1383 ( nullptr ) ,
1306: originalTypeName@var1384 ( otn@var1396 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1397 , const Settings * settings@var1398 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1399 , bool longType@var1400 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1401 , const ValueType * func@var1402 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1403 , const Variable * callVar@var1404 , const Variable * funcVar@var1405 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746318 type@var1373 >=@expr1073746319 ValueType ::@expr1073746320 Type ::@expr1073746321 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746322 type@var1373 >=@expr1073746323 ValueType ::@expr4500 Type ::@expr1073746325 BOOL &&@expr1073746326 type@var1373 <=@expr1073746327 ValueType ::@expr4500 Type ::@expr1073746329 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746330 type@var1373 >=@expr1073746331 ValueType ::@expr4508 Type ::@expr1073746333 FLOAT &&@expr1073746334 type@var1373 <=@expr1073746335 ValueType ::@expr4508 Type ::@expr1073746337 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1406 , const Settings * settings@var1407 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1378 &&@expr1073746338 typeScope@var1378 .@expr1073746339 type@var1408 ==@expr1073746340 Scope ::@expr1073746341 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1409 , bool p@var1410 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1411 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1412 , const Settings * settings@var1413 , ErrorLogger * errorLogger@var1414 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1415 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1416 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1417 ;
1359:
1360:
1361: std :: list < Type > typeList@var1418 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1419 , const Token * typeTok@var1420 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1421 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1422 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1423 , const Scope * startScope@var1424 , bool lookOutside@var1425 = false ) const ;
1382: Type * findType ( const Token * startTok@var1426 , Scope * startScope@var1427 , bool lookOutside@var1428 = false ) const {
1383: return const_cast < Type *@expr4518 > (@expr1073746343 this@expr1073746344 .@expr1073746345 findType (@expr1073746346 startTok@var1426 , const_cast < const Scope *@expr4518 > (@expr1073746348 startScope@var1427 ) , lookOutside@var1428 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1429 , const Scope * startScope@var1430 ) const ;
1387: Scope * findScope ( const Token * tok@var1431 , Scope * startScope@var1432 ) const {
1388: return const_cast < Scope *@expr4525 > (@expr1073746350 this@expr1073746351 .@expr1073746352 findScope (@expr1073746353 tok@var1431 , const_cast < const Scope *@expr4525 > (@expr1073746355 startScope@var1432 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1433 ) const {
1392: return varid@var1433 <@expr1073746356 mVariableList@var1490 .@expr1073746357 size (@expr1073746358 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1434 ) const {
1396: return mVariableList@var1490 .@expr1073746359 at (@expr1073746360 varId@var1434 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1490 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1435 , const std :: string & type@var1436 , const std :: string & msg@var1437 ) const ;
1407:
1408: void printOut ( const char * title@var1438 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1439 , const char * indent@var1440 ) const ;
1410: void printXml ( std :: ostream & out@var1441 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1442 , Token * tokens@var1443 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1444 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1445 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1446 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1447 , const Token * * tok@var1448 , const Token * argStart@var1449 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1450 , const Token * tok@var1451 , const Token * argStart@var1452 , const Token * funcStart@var1453 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1454 , const Token * & tok@var1455 , const Token * argStart@var1456 , const Token * funcStart@var1457 ) ;
1469: void addNewFunction ( Scope * * scope@var1458 , const Token * * tok@var1459 ) ;
1470: bool isFunction ( const Token * tok@var1460 , const Scope * outerScope@var1461 , const Token * * funcStart@var1462 , const Token * * argStart@var1463 , const Token * * declEnd@var1464 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1465 , const Scope * startScope@var1466 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1467 , const Scope * scope@var1468 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1469 , const Scope * ns@var1470 , const std :: string & path@var1471 , int path_length@var1472 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1473 , const Token * typeTok@var1474 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1475 , const Token * vartok@var1476 , Token * membertok@var1477 , const Variable * membervar@var1478 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1479 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1480 ) const ;
1485:
1486: void setValueType ( Token * tok@var1481 , const ValueType & valuetype@var1482 ) ;
1487: void setValueType ( Token * tok@var1483 , const Variable & var@var1484 ) ;
1488: void setValueType ( Token * tok@var1485 , const Enumerator & enumerator@var1486 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1487 ;
1491: const Settings * mSettings@var1488 ;
1492: ErrorLogger * mErrorLogger@var1489 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1490 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1491 ;
1499:
1500: bool mIsCpp@var1492 ;
1501: ValueType :: Sign mDefaultSignedness@var1493 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1494 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1495 , const TFunc & visitor@var1496 )
52: {
53: if (@expr1073746361 !@expr1073746362 ast@var1495 ) {
54: return ; }
55:
56: std ::@expr1073746363 stack < T *@expr4540 , std ::@expr1073746365 vector < T *@expr4540 > > tokens@var1497 ;
57: T * tok@var1498 ; tok@var1498 =@expr1073746367 ast@var1495 ;
58: do {
59: ChildrenToVisit c@var1499 ; c@var1499 =@expr1073746368 visitor@var1496 (@expr1073746369 tok@var1498 ) ;
60:
61: if (@expr1073746370 c@var1499 ==@expr1073746371 ChildrenToVisit ::@expr1073746372 done ) {
62: break ; }
63: if (@expr1073746373 c@var1499 ==@expr1073746374 ChildrenToVisit ::@expr1073746375 op2 ||@expr1073746376 c@var1499 ==@expr4553 ChildrenToVisit ::@expr4554 op1_and_op2 ) {
64: T * t2@var1500 ; t2@var1500 =@expr1073746379 tok@var1498 .@expr1073746380 astOperand2 (@expr1073746381 ) ;
65: if (@expr1073746382 t2@var1500 ) {
66: tokens@var1497 .@expr4559 push (@expr1073746384 t2@var1500 ) ; }
67: }
68: if (@expr1073746385 c@var1499 ==@expr1073746386 ChildrenToVisit ::@expr1073746387 op1 ||@expr1073746388 c@var1499 ==@expr4553 ChildrenToVisit ::@expr4554 op1_and_op2 ) {
69: T * t1@var1501 ; t1@var1501 =@expr1073746391 tok@var1498 .@expr1073746392 astOperand1 (@expr1073746393 ) ;
70: if (@expr1073746394 t1@var1501 ) {
71: tokens@var1497 .@expr4559 push (@expr1073746396 t1@var1501 ) ; }
72: }
73:
74: if (@expr1073746397 tokens@var1497 .@expr1073746398 empty (@expr1073746399 ) ) {
75: break ; }
76:
77: tok@var1498 =@expr1073746400 tokens@var1497 .@expr1073746401 top (@expr1073746402 ) ;
78: tokens@var1497 .@expr1073746403 pop (@expr1073746404 ) ;
79: } while (@expr1073746405 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1502 , const std :: function < bool ( const Token * ) > & pred@var1503 ) ;
83: const Token * findExpression ( const int exprid@var1504 ,
84: const Token * start@var1505 ,
85: const Token * end@var1506 ,
86: const std :: function < bool ( const Token * ) > & pred@var1507 ) ;
87: const Token * findExpression ( const Token * start@var1508 , const int exprid@var1509 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1510 , const char * op@var1511 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1512 , const char * op@var1513 ) ;
91:
92: int astCount ( const Token * tok@var1514 , const char * op@var1515 , int depth@var1516 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1517 , const Token * tok@var1518 ) ;
95:
96: bool astHasVar ( const Token * tok@var1519 , int varid@var1520 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1521 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1522 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1523 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1524 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1525 , bool unknown@var1526 ) ;
107: bool astIsUnsigned ( const Token * tok@var1527 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1528 , bool unknown@var1529 ) ;
110:
111: bool astIsBool ( const Token * tok@var1530 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1531 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1532 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1533 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1534 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1535 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1536 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1537 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1538 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1539 , const std :: string & comp@var1540 , const std :: string & rhs@var1541 , const Token * * vartok@var1542 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1543 ) ;
140:
141: bool isTemporary ( bool cpp@var1544 , const Token * tok@var1545 , const Library * library@var1546 , bool unknown@var1547 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1548 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1549 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1550 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1551 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1552 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1553 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1554 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1555 ) ;
155: const Token * getParentLifetime ( bool cpp@var1556 , const Token * tok@var1557 , const Library * library@var1558 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1559 ) ;
158: bool astIsRHS ( const Token * tok@var1560 ) ;
159:
160: Token * getCondTok ( Token * tok@var1561 ) ;
161: const Token * getCondTok ( const Token * tok@var1562 ) ;
162:
163: Token * getInitTok ( Token * tok@var1563 ) ;
164: const Token * getInitTok ( const Token * tok@var1564 ) ;
165:
166: Token * getStepTok ( Token * tok@var1565 ) ;
167: const Token * getStepTok ( const Token * tok@var1566 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1567 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1568 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1569 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1570 ,
180: int * const varid@var1571 ,
181: bool * const knownInitValue@var1572 ,
182: long long * const initValue@var1573 ,
183: bool * const partialCond@var1574 ,
184: long long * const stepValue@var1575 ,
185: long long * const lastValue@var1576 ) ;
186:
187: bool precedes ( const Token * tok1@var1577 , const Token * tok2@var1578 ) ;
188: bool succeeds ( const Token * tok1@var1579 , const Token * tok2@var1580 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1581 , bool onVar@var1582 = true , int depth@var1583 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1584 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1585 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1586 ,
198: bool temporary@var1587 = true ,
199: bool inconclusive@var1588 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1589 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1590 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1591 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1592 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1593 , bool macro@var1594 , const Token * tok1@var1595 , const Token * tok2@var1596 , const Library & library@var1597 , bool pure@var1598 , bool followVar@var1599 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1600 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1601 , const Token * const tok2@var1602 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1603 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1604 , bool cpp@var1605 , const Token * const cond1@var1606 , const Token * const cond2@var1607 , const Library & library@var1608 , bool pure@var1609 , bool followVar@var1610 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1611 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1612 , const Token * const tok1@var1613 , const Token * const tok2@var1614 , const Library & library@var1615 , bool pure@var1616 , bool followVar@var1617 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1618 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1619 , const Library & library@var1620 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1621 , const Library & library@var1622 , bool pure@var1623 , bool cpp@var1624 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1625 , const Token * tok@var1626 , bool checkArrayAccess@var1627 = false , bool checkReference@var1628 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1629 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1630 , const Library * library@var1631 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1632 ,
238: const Library * library@var1633 = nullptr ,
239: const Token * * unknownFunc@var1634 = nullptr ,
240: bool functionScope@var1635 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1636 ,
244: const Variable * var@var1637 ,
245: Scope :: ScopeType type@var1638 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1639 , int & argn@var1640 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1641 , int & argn@var1642 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1643 , int argnr@var1644 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1645 , int indirect@var1646 , int varid@var1647 , const Settings * settings@var1648 , bool * inconclusive@var1649 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1650 , int indirect@var1651 , const Settings * settings@var1652 , bool * inconclusive@var1653 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1654 , const Token * end@var1655 , const int exprid@var1656 , bool globalvar@var1657 , const Settings * settings@var1658 , bool cpp@var1659 , int depth@var1660 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1661 , const Token * end@var1662 , int indirect@var1663 , const int exprid@var1664 , bool globalvar@var1665 , const Settings * settings@var1666 , bool cpp@var1667 , int depth@var1668 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1669 , int indirect@var1670 , const Settings * settings@var1671 , bool cpp@var1672 , int depth@var1673 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1674 , const Settings * settings@var1675 , bool cpp@var1676 , int depth@var1677 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1678 ,
283: const Token * end@var1679 ,
284: int indirect@var1680 ,
285: std :: vector < const Variable * > vars@var1681 ,
286: const Settings * settings@var1682 ,
287: bool cpp@var1683 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1684 , int indirect@var1685 , const Settings * settings@var1686 , bool cpp@var1687 ) ;
290: bool isThisChanged ( const Token * start@var1688 , const Token * end@var1689 , int indirect@var1690 , const Settings * settings@var1691 , bool cpp@var1692 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1693 , const Token * end@var1694 , int indirect@var1695 , const int exprid@var1696 , bool globalvar@var1697 , const Settings * settings@var1698 , bool cpp@var1699 , int depth@var1700 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1701 , const Token * end@var1702 , int indirect@var1703 , const int exprid@var1704 , bool globalvar@var1705 , const Settings * settings@var1706 , bool cpp@var1707 , int depth@var1708 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1709 ,
296: const Token * start@var1710 ,
297: const Token * end@var1711 ,
298: const Settings * settings@var1712 ,
299: bool cpp@var1713 ,
300: int depth@var1714 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1715 ,
303: const Token * tok@var1716 ,
304: int indirect@var1717 ,
305: bool globalvar@var1718 ,
306: const Settings * settings@var1719 ,
307: bool cpp@var1720 ,
308: int depth@var1721 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1722 , int varid@var1723 , bool * inconclusive@var1724 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1725 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1726 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1727 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1728 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1729 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1730 , const Function * f@var1731 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1732 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1733 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1734 ) ;
346: Token * findLambdaEndToken ( Token * first@var1735 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1736 , const Token * stream@var1737 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1738 , const Token * op@var1739 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1740 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1741 , const char * skipMatch@var1742 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1743 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1744 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1745 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1746 , const Library & library@var1747 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1748 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1749 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1750 , bool cpp@var1751 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1752 , const Library & library@var1753 ) : mCpp@var1786 ( cpp@var1752 ) , mLibrary@var1787 ( library@var1753 ) , mWhat@var1788 ( What :: Reassign ) , mValueFlowKnown@var1790 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1754 , const Token * lhs@var1755 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1756 , const Token * startToken@var1757 , const Token * endToken@var1758 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1759 , const Token * startToken@var1760 , const Token * endToken@var1761 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1762 ;
407: const Token * token@var1763 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1764 , const Token * startToken@var1765 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1766 , bool * localOut@var1767 = nullptr , bool * unknownVarIdOut@var1768 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1769 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1770 ;
420: explicit Result ( Type type@var1771 ) : type@var1770 ( type@var1771 ) , token@var1774 ( nullptr ) { }
421: Result ( Type type@var1772 , const Token * token@var1773 ) : type@var1770 ( type@var1772 ) , token@var1774 ( token@var1773 ) { }
422: const Token * token@var1774 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1775 , const Token * startToken@var1776 , const Token * endToken@var1777 ) ;
426: struct Result checkRecursive ( const Token * expr@var1778 , const Token * startToken@var1779 , const Token * endToken@var1780 , const std :: set < int > & exprVarIds@var1781 , bool local@var1782 , bool inInnerClass@var1783 , int depth@var1784 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1785 ) const ;
430:
431: const bool mCpp@var1786 ;
432: const Library & mLibrary@var1787 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1788 ;
434: std :: vector < KnownAndToken > mValueFlow@var1789 ;
435: bool mValueFlowKnown@var1790 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1791 ) ;

##file cppcheck-2.8/lib/preprocessor.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37:
|
46:
47: class Directive {
48: public:
49:
50: std :: string file@var1792 ;
51:
52:
53: unsigned int linenr@var1793 ;
54:
55:
56: std :: string str@var1794 ;
57:
58:
59: Directive ( const std :: string & _file@var1795 , const int _linenr@var1796 , const std :: string & _str@var1797 ) ;
60: } ;
61:
|
69:
70: class Preprocessor {
71: public:
72:
|
75:
76: enum HeaderTypes {
77: NoHeader = 0 ,
78: UserHeader ,
79: SystemHeader
80: } ;
81:
82:
83: static char macroChar@var1798 ;
84:
85: explicit Preprocessor ( Settings & settings@var1799 , ErrorLogger * errorLogger@var1800 = nullptr ) ;
86: virtual ~ Preprocessor ( ) ;
87:
88: static std :: atomic < bool > missingIncludeFlag@var1801 ;
89: static std :: atomic < bool > missingSystemIncludeFlag@var1802 ;
90:
91: void inlineSuppressions ( const simplecpp :: TokenList & tokens@var1803 ) ;
92:
93: void setDirectives ( const simplecpp :: TokenList & tokens@var1804 ) ;
94: void setDirectives ( const std :: list < Directive > & directives@var1805 ) {
95: mDirectives@var1857 =@expr1073746406 directives@var1805 ;
96: }
97:
98:
99: const std :: list < Directive > & getDirectives ( ) const {
100: return mDirectives@var1857 ;
101: }
102:
103: std :: set < std :: string > getConfigs ( const simplecpp :: TokenList & tokens@var1806 ) const ;
104:
105: void handleErrors ( const simplecpp :: OutputList & outputList@var1807 , bool throwError@var1808 ) ;
106:
107: bool loadFiles ( const simplecpp :: TokenList & rawtokens@var1809 , std :: vector < std :: string > & files@var1810 ) ;
108:
109: void removeComments ( ) ;
110:
111: void setPlatformInfo ( simplecpp :: TokenList * tokens@var1811 ) const ;
112:
|
123:
124: void preprocess ( std :: istream & istr@var1812 , std :: map < std :: string , std :: string > & result@var1813 , const std :: string & filename@var1814 , const std :: list < std :: string > & includePaths@var1815 = std :: list < std :: string > ( ) ) ;
125:
|
142:
143: void preprocess ( std :: istream & srcCodeStream@var1816 , std :: string & processedFile@var1817 , std :: list < std :: string > & resultConfigurations@var1818 , const std :: string & filename@var1819 , const std :: list < std :: string > & includePaths@var1820 ) ;
144:
145: simplecpp :: TokenList preprocess ( const simplecpp :: TokenList & tokens1@var1821 , const std :: string & cfg@var1822 , std :: vector < std :: string > & files@var1823 , bool throwError@var1824 = false ) ;
146:
147: std :: string getcode ( const simplecpp :: TokenList & tokens1@var1825 , const std :: string & cfg@var1826 , std :: vector < std :: string > & files@var1827 , const bool writeLocations@var1828 ) ;
148:
|
154:
155: std :: string getcode ( const std :: string & filedata@var1829 , const std :: string & cfg@var1830 , const std :: string & filename@var1831 ) ;
156:
|
162:
163: bool validateCfg ( const std :: string & cfg@var1832 , const std :: list < simplecpp :: MacroUsage > & macroUsageList@var1833 ) ;
164: void validateCfgError ( const std :: string & file@var1834 , const unsigned int line@var1835 , const std :: string & cfg@var1836 , const std :: string & macro@var1837 ) ;
165:
|
172:
173: unsigned int calculateChecksum ( const simplecpp :: TokenList & tokens1@var1838 , const std :: string & toolinfo@var1839 ) const ;
174:
175: void simplifyPragmaAsm ( simplecpp :: TokenList * tokenList@var1840 ) ;
176:
177: private:
178:
179: static void simplifyPragmaAsmPrivate ( simplecpp :: TokenList * tokenList@var1841 ) ;
180:
181: public:
182:
183:
184: static void getErrorMessages ( ErrorLogger * errorLogger@var1842 , const Settings * settings@var1843 ) ;
185:
186: void setFile0 ( const std :: string & f@var1844 ) {
187: mFile0@var1859 =@expr1073746407 f@var1844 ;
188: }
189:
|
192:
193: void dump ( std :: ostream & out@var1845 ) const ;
194:
195: void reportOutput ( const simplecpp :: OutputList & outputList@var1846 , bool showerror@var1847 ) ;
196:
197: private:
198: void missingInclude ( const std :: string & filename@var1848 , unsigned int linenr@var1849 , const std :: string & header@var1850 , HeaderTypes headerType@var1851 ) ;
199: void error ( const std :: string & filename@var1852 , unsigned int linenr@var1853 , const std :: string & msg@var1854 ) ;
200:
201: Settings & mSettings@var1855 ;
202: ErrorLogger * mErrorLogger@var1856 ;
203:
204:
205: std :: list < Directive > mDirectives@var1857 ;
206:
207: std :: map < std :: string , simplecpp :: TokenList * > mTokenLists@var1858 ;
208:
209:
210: std :: string mFile0@var1859 ;
211:
212:
213: std :: list < simplecpp :: MacroUsage > mMacroUsage@var1860 ;
214: std :: list < simplecpp :: IfCond > mIfCond@var1861 ;
215: } ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1862 ) {
44: if (@expr1073746408 bit@var1862 >=@expr1073746409 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746410 (@expr1073746411 1LL <<@expr1073746412 (@expr1073746413 bit@var1862 -@expr1073746414 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1863 ) {
50: if (@expr1073746415 bit@var1863 >=@expr1073746416 64 ) {
51: return (@expr4593 ~@expr1073746418 0ULL ) >>@expr1073746419 1 ; }
52: return (@expr4593 1LL <<@expr1073746421 (@expr4593 bit@var1863 -@expr1073746423 1 ) ) -@expr1073746424 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1864 ) const {
59: return value@var1864 >=@expr1073746425 min_value (@expr1073746426 int_bit@var1874 ) &&@expr1073746427 value@var1864 <=@expr1073746428 max_value (@expr1073746429 int_bit@var1874 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1865 ) const {
63: unsigned long long intMax@var1866 ; intMax@var1866 =@expr1073746430 max_value (@expr1073746431 int_bit@var1874 ) ;
64: return value@var1865 <=@expr1073746432 intMax@var1866 ;
65: }
66:
67: bool isLongValue ( long long value@var1867 ) const {
68: return value@var1867 >=@expr1073746433 min_value (@expr1073746434 long_bit@var1875 ) &&@expr1073746435 value@var1867 <=@expr1073746436 max_value (@expr1073746437 long_bit@var1875 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1868 ) const {
72: unsigned long long longMax@var1869 ; longMax@var1869 =@expr1073746438 max_value (@expr1073746439 long_bit@var1875 ) ;
73: return value@var1868 <=@expr1073746440 longMax@var1869 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1870 ) const {
77: unsigned long long longLongMax@var1871 ; longLongMax@var1871 =@expr1073746441 max_value (@expr1073746442 long_long_bit@var1876 ) ;
78: return value@var1870 <=@expr1073746443 longLongMax@var1871 ;
79: }
80:
81: int char_bit@var1872 ;
82: int short_bit@var1873 ;
83: int int_bit@var1874 ;
84: int long_bit@var1875 ;
85: int long_long_bit@var1876 ;
86:
87:
88: int sizeof_bool@var1877 ;
89: int sizeof_short@var1878 ;
90: int sizeof_int@var1879 ;
91: int sizeof_long@var1880 ;
92: int sizeof_long_long@var1881 ;
93: int sizeof_float@var1882 ;
94: int sizeof_double@var1883 ;
95: int sizeof_long_double@var1884 ;
96: int sizeof_wchar_t@var1885 ;
97: int sizeof_size_t@var1886 ;
98: int sizeof_pointer@var1887 ;
99:
100: char defaultSign@var1888 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1889 ;
115:
116:
117: bool platform ( PlatformType type@var1890 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1891 [ ] , const std :: string & filename@var1892 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1893 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1889 ==@expr1073746444 Win32A ||@expr1073746445
136: platformType@var1889 ==@expr1073746446 Win32W ||@expr1073746447
137: platformType@var1889 ==@expr1073746448 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746449 platformType@var1889 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1894 ) {
145: switch (@expr1073746450 pt@var1894 ) {
146: case Unspecified :@expr4627 ;
147: return "Unspecified" ;
148: case Native :@expr4627 ;
149: return "Native" ;
150: case Win32A :@expr4627 ;
151: return "win32A" ;
152: case Win32W :@expr4627 ;
153: return "win32W" ;
154: case Win64 :@expr4627 ;
155: return "win64" ;
156: case Unix32 :@expr4627 ;
157: return "unix32" ;
158: case Unix64 :@expr4627 ;
159: return "unix64" ;
160: case PlatformFile :@expr4627 ;
161: return "platformFile" ;
162: default :@expr4627 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746460 char_bit@var1872 +@expr1073746461 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746462 char_bit@var1872 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746463 char_bit@var1872 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1895 , const std :: string & rhs@var1896 ) const {
41: return caseInsensitiveStringCompare (@expr1073746464 lhs@var1895 , rhs@var1896 ) <@expr1073746465 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1904 ( cppcheck :: Platform :: Unspecified ) , msc@var1905 ( false ) , useMfc@var1906 ( false ) { }
67: std :: string cfg@var1897 ;
68: std :: string filename@var1898 ;
69: std :: string defines@var1899 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1899 +@expr1073746466 (@expr1073746467 msc@var1905 ?@expr1073746468 ";_MSC_VER=1900" :@expr1073746469 "" ) +@expr1073746470 (@expr1073746471 useMfc@var1906 ?@expr1073746472 ";__AFXWIN_H__=1" :@expr1073746473 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1900 ;
74: std :: list < std :: string > includePaths@var1901 ;
75: std :: list < std :: string > systemIncludePaths@var1902 ;
76: std :: string standard@var1903 ;
77: cppcheck :: Platform :: PlatformType platformType@var1904 ;
78: bool msc@var1905 ;
79: bool useMfc@var1906 ;
80:
81: void parseCommand ( std :: string command@var1907 ) ;
82: void setDefines ( std :: string defs@var1908 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1909 , const std :: list < std :: string > & in@var1910 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1911 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1912 ;
86: Type projectType@var1913 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1914 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous4 {
96: std :: string analyzeAllVsConfigs@var1915 ;
97: std :: vector < std :: string > pathNames@var1916 ;
98: std :: list < std :: string > libraries@var1917 ;
99: std :: list < std :: string > excludedPaths@var1918 ;
100: std :: list < std :: string > checkVsConfigs@var1919 ;
101: std :: string projectFile@var1920 ;
102: std :: string platform@var1921 ;
103: } ; struct Anonymous4 guiProject@var1922 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1923 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1924 ) ;
107:
108: Type import ( const std :: string & filename@var1925 , Settings * settings@var1926 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1927 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1928 , Settings * settings@var1929 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1930 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1931 , const std :: string & path@var1932 , const std :: vector < std :: string > & fileFilters@var1933 ) ;
115: bool importVcxproj ( const std :: string & filename@var1934 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1935 , const std :: string & additionalIncludeDirectories@var1936 , const std :: vector < std :: string > & fileFilters@var1937 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1938 ) ;
117:
118: static void printError ( const std :: string & message@var1939 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1940 ) ;
121:
122: std :: string mPath@var1941 ;
123: std :: set < std :: string > mAllVSConfigs@var1942 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1943 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1944 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1945 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1946 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1947 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1948 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1949 [ 7 ] = "parser" ;
135: const char BugHunting@var1950 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1951 [ 11 ] = "includedir" ;
137: const char DirElementName@var1952 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1953 [ 5 ] = "name" ;
139: const char DefinesElementName@var1954 [ 8 ] = "defines" ;
140: const char DefineName@var1955 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1956 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1957 [ 10 ] = "undefines" ;
143: const char UndefineName@var1958 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1959 [ 6 ] = "paths" ;
145: const char PathName@var1960 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1961 [ 5 ] = "name" ;
147: const char RootPathName@var1962 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1963 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1964 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1965 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1966 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1967 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1968 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1969 [ 5 ] = "name" ;
155: const char FunctionContracts@var1970 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1971 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1972 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1973 [ 8 ] = "library" ;
159: const char PlatformElementName@var1974 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1975 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1976 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1977 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1978 [ 7 ] = "addons" ;
164: const char ToolElementName@var1979 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1980 [ 6 ] = "tools" ;
166: const char TagsElementName@var1981 [ 5 ] = "tags" ;
167: const char TagElementName@var1982 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1983 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1984 [ 4 ] = "tag" ;
170: const char WarningElementName@var1985 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1986 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1987 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1988 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1989 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1990 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1991 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1992 [ 11 ] = "clang-tidy" ;
178: const char Name@var1993 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1994 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1995 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1996 ;
43: std :: string errorId@var1997 ;
44: void setFileName ( const std :: string & s@var1998 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var2002 ;
47: }
48: int lineNumber@var1999 ;
49: Certainty :: CertaintyLevel certainty@var2000 ;
50: std :: string symbolNames@var2001 ;
51: private:
52: std :: string mFileName@var2002 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var2036 ( NO_LINE ) , hash@var2038 ( 0 ) , thisAndNextLine@var2039 ( false ) , matched@var2040 ( false ) , checked@var2041 ( false ) { }
57: Suppression ( const Suppression & other@var2003 ) {
58: *@expr1073746474 this@expr1073746475 =@expr1073746476 other@var2003 ;
59: }
60: Suppression ( const std :: string & id@var2004 , const std :: string & file@var2005 , int line@var2006 = NO_LINE ) : errorId@var2034 ( id@var2004 ) , fileName@var2035 ( file@var2005 ) , lineNumber@var2036 ( line@var2006 ) , hash@var2038 ( 0 ) , thisAndNextLine@var2039 ( false ) , matched@var2040 ( false ) , checked@var2041 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var2007 ) {
63: errorId@var2034 =@expr1073746477 other@var2007 .@expr1073746478 errorId@var2008 ;
64: fileName@var2035 =@expr1073746479 other@var2007 .@expr1073746480 fileName@var2009 ;
65: lineNumber@var2036 =@expr1073746481 other@var2007 .@expr1073746482 lineNumber@var2010 ;
66: symbolName@var2037 =@expr1073746483 other@var2007 .@expr1073746484 symbolName@var2011 ;
67: hash@var2038 =@expr1073746485 other@var2007 .@expr1073746486 hash@var2012 ;
68: thisAndNextLine@var2039 =@expr1073746487 other@var2007 .@expr1073746488 thisAndNextLine@var2013 ;
69: matched@var2040 =@expr1073746489 other@var2007 .@expr1073746490 matched@var2014 ;
70: checked@var2041 =@expr1073746491 other@var2007 .@expr1073746492 checked@var2015 ;
71: return *@expr1073746493 this@expr1073746494 ;
72: }
73:
74: bool operator< ( const Suppression & other@var2016 ) const {
75: if (@expr1073746495 errorId@var2034 !=@expr1073746496 other@var2016 .@expr4673 errorId@var2017 ) {
76: return errorId@var2034 <@expr1073746498 other@var2016 .@expr4673 errorId@var2017 ; }
77: if (@expr1073746500 lineNumber@var2036 <@expr1073746501 other@var2016 .@expr1073746502 lineNumber@var2018 ) {
78: return true ; }
79: if (@expr1073746503 fileName@var2035 !=@expr1073746504 other@var2016 .@expr4681 fileName@var2019 ) {
80: return fileName@var2035 <@expr1073746506 other@var2016 .@expr4681 fileName@var2019 ; }
81: if (@expr1073746508 symbolName@var2037 !=@expr1073746509 other@var2016 .@expr4686 symbolName@var2020 ) {
82: return symbolName@var2037 <@expr1073746511 other@var2016 .@expr4686 symbolName@var2020 ; }
83: if (@expr1073746513 hash@var2038 !=@expr1073746514 other@var2016 .@expr4691 hash@var2021 ) {
84: return hash@var2038 <@expr1073746516 other@var2016 .@expr4691 hash@var2021 ; }
85: if (@expr1073746518 thisAndNextLine@var2039 !=@expr1073746519 other@var2016 .@expr1073746520 thisAndNextLine@var2022 ) {
86: return thisAndNextLine@var2039 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var2023 , std :: string * errorMessage@var2024 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var2025 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var2026 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746522 fileName@var2035 .@expr1073746523 empty (@expr1073746524 ) &&@expr1073746525 fileName@var2035 .@expr1073746526 find_first_of (@expr1073746527 "?*" ) ==@expr1073746528 std ::@expr1073746529 string ::@expr1073746530 npos@expr1073746521 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var2027 ) const {
109: return errorId@var2034 ==@expr1073746531 other@var2027 .@expr1073746532 errorId@var2028 &&@expr1073746533
110: fileName@var2035 ==@expr1073746534 other@var2027 .@expr1073746535 fileName@var2029 &&@expr1073746536
111: lineNumber@var2036 ==@expr1073746537 other@var2027 .@expr1073746538 lineNumber@var2030 &&@expr1073746539
112: symbolName@var2037 ==@expr1073746540 other@var2027 .@expr1073746541 symbolName@var2031 &&@expr1073746542
113: hash@var2038 ==@expr1073746543 other@var2027 .@expr1073746544 hash@var2032 &&@expr1073746545
114: thisAndNextLine@var2039 ==@expr1073746546 other@var2027 .@expr1073746547 thisAndNextLine@var2033 ;
115: }
116:
117: std :: string errorId@var2034 ;
118: std :: string fileName@var2035 ;
119: int lineNumber@var2036 ;
120: std :: string symbolName@var2037 ;
121: unsigned long hash@var2038 ;
122: bool thisAndNextLine@var2039 ;
123: bool matched@var2040 ;
124: bool checked@var2041 ;
125:
126: enum Anonymous5 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var2042 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var2043 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var2044 , std :: string * errorMessage@var2045 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var2046 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var2047 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var2048 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var2049 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var2050 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var2051 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var2052 , const bool unusedFunctionChecking@var2053 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var2054 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var2055 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var2056 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var2057 , std :: clock_t clocks@var2058 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var2059 ;
45: long mNumberOfResults@var2060 ;
46:
47: TimerResultsData ( )
48: : mClocks@var2059 ( 0 )
49: , mNumberOfResults@var2060 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var2061 =@expr1073746549 (@expr1073746550 double ) (@expr1073746551 (@expr1073746552 unsigned long ) mClocks@var2059 ) /@expr1073746553 (@expr1073746554 double ) CLOCKS_PER_SEC@expr1073746548 ;
53: return ret@var2061 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var2062 ) const ;
62: void addResults ( const std :: string & str@var2063 , std :: clock_t clocks@var2064 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var2065 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var2066 , SHOWTIME_MODES showtimeMode@var2067 , TimerResultsIntf * timerResults@var2068 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var2069 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var2070 ;
79: TimerResultsIntf * mTimerResults@var2071 ;
80: std :: clock_t mStart@var2072 ;
81: const SHOWTIME_MODES mShowTimeMode@var2073 ;
82: bool mStopped@var2074 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var2075 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var2076 ;
103:
104:
105: std :: string addonPython@var2077 ;
106:
107:
108: std :: vector < std :: string > basePaths@var2078 ;
109:
110:
111: std :: string buildDir@var2079 ;
112:
113:
114: bool checkAllConfigurations@var2080 ;
115:
116:
117: bool checkConfiguration@var2081 ;
118:
|
121:
122: bool checkHeaders@var2082 ;
123:
124:
125: bool checkLibrary@var2083 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var2084 ;
129:
130:
131: bool checkUnusedTemplates@var2085 ;
132:
133:
134: bool clang@var2086 ;
135:
136:
137: std :: string clangExecutable@var2087 ;
138:
139:
140: bool clangTidy@var2088 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var2089 ;
144:
145:
146: std :: string cppcheckCfgProductName@var2090 ;
147:
148:
149: std :: string cppcheckCfgAbout@var2091 ;
150:
151:
152: bool daca@var2092 ;
153:
154:
155: bool debugnormal@var2093 ;
156:
157:
158: bool debugSimplified@var2094 ;
159:
160:
161: bool debugtemplate@var2095 ;
162:
163:
164: bool debugwarnings@var2096 ;
165:
166:
167: bool dump@var2097 ;
168: std :: string dumpFile@var2098 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var2099 ;
176:
177:
178: bool exceptionHandling@var2100 ;
179:
180:
181: std :: string exename@var2101 ;
182:
183:
184:
185: int exitCode@var2102 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var2103 ;
189:
190:
191: bool force@var2104 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2105 ;
196:
197:
198: bool inlineSuppressions@var2106 ;
199:
200:
201:
202: unsigned int jobs@var2107 ;
203:
|
206:
207: bool jointSuppressionReport@var2108 ;
208:
209:
210: std :: list < std :: string > libraries@var2109 ;
211:
212:
213: Library library@var2110 ;
214:
215:
216:
217: int loadAverage@var2111 ;
218:
|
221:
222: int maxConfigs@var2112 ;
223:
224:
225: int maxCtuDepth@var2113 ;
226:
227:
228: int maxTemplateRecursion@var2114 ;
229:
230:
231: Suppressions nofail@var2115 ;
232:
233:
234: Suppressions nomsg@var2116 ;
235:
236:
237: std :: string outputFile@var2117 ;
238:
239:
240: std :: string plistOutput@var2118 ;
241:
242:
243: bool preprocessOnly@var2119 ;
244:
245: ImportProject project@var2120 ;
246:
247:
248: bool quiet@var2121 ;
249:
250:
251: bool relativePaths@var2122 ;
252:
253:
254: bool reportProgress@var2123 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2124 ( "simple" )
261: , id@var2126 ( "rule" )
262: , severity@var2128 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2124 ;
266: std :: string pattern@var2125 ;
267: std :: string id@var2126 ;
268: std :: string summary@var2127 ;
269: Severity :: SeverityType severity@var2128 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2129 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2135 ( false ) , externalFunctions@var2136 ( false ) , internalFunctions@var2137 ( false ) , externalVariables@var2138 ( false ) { }
281:
282: static const char XmlRootName@var2130 [ ] ;
283: static const char XmlClasses@var2131 [ ] ;
284: static const char XmlExternalFunctions@var2132 [ ] ;
285: static const char XmlInternalFunctions@var2133 [ ] ;
286: static const char XmlExternalVariables@var2134 [ ] ;
287:
288: void clear ( ) {
289: classes@var2135 =@expr1073746555 externalFunctions@var2136 =@expr1073746556 internalFunctions@var2137 =@expr1073746557 externalVariables@var2138 =@expr1073746558 false ;
290: }
291:
|
297:
298: bool classes@var2135 ;
299:
|
304:
305: bool externalFunctions@var2136 ;
306:
|
310:
311: bool internalFunctions@var2137 ;
312:
|
316:
317: bool externalVariables@var2138 ;
318: } ;
319:
320: SafeChecks safeChecks@var2139 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2140 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2141 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2142 ;
325:
326:
327: SHOWTIME_MODES showtime@var2143 ;
328:
329:
330: Standards standards@var2144 ;
331:
332:
333:
334: std :: string templateFormat@var2145 ;
335:
336:
337:
338: std :: string templateLocation@var2146 ;
339:
340:
341: std :: string userDefines@var2147 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2148 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2149 ;
348:
349:
350: bool verbose@var2150 ;
351:
352:
353: bool xml@var2151 ;
354:
355:
356: int xml_version@var2152 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2153 ) const {
363: for (@expr1073746559 const std ::@expr1073746560 string &@expr1073746561 configExcludePath@var2154 :@expr1073746562 configExcludePaths@var2089 ) {
364: if (@expr1073746563 file@var2153 .@expr1073746564 length (@expr1073746565 ) >=@expr1073746566 configExcludePath@var2154 .@expr4743 length (@expr4744 ) &&@expr1073746569 file@var2153 .@expr1073746570 compare (@expr1073746571 0 , configExcludePath@var2154 .@expr4743 length (@expr4744 ) , configExcludePath@var2154 ) ==@expr1073746574 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2155 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2156 , bool inconclusiveCheck@var2157 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746575 find (@expr1073746576 libraries@var2109 .@expr1073746577 begin (@expr1073746578 ) , libraries@var2109 .@expr4755 end (@expr4756 ) , "posix" ) !=@expr1073746581 libraries@var2109 .@expr4755 end (@expr4756 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2158 = true ) {
392: Settings ::@expr1073746584 mTerminated@var2075 =@expr1073746585 t@var2158 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746586 mTerminated@var2075 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2159 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var2160 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var2161 ) {
47: mSettings@var2196 =@expr1073746587 settings@var2161 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var2196 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var2198 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var2199 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var2162 ) ;
72:
73: void addtoken ( const std :: string & str@var2163 , const int lineno@var2164 , const int column@var2165 , const int fileno@var2166 , bool split@var2167 = false ) ;
74: void addtoken ( const std :: string & str@var2168 , const Token * locationTok@var2169 ) ;
75:
76: void addtoken ( const Token * tok@var2170 , const int lineno@var2171 , const int column@var2172 , const int fileno@var2173 ) ;
77: void addtoken ( const Token * tok@var2174 , const Token * locationTok@var2175 ) ;
78: void addtoken ( const Token * tok@var2176 ) ;
79:
80: static void insertTokens ( Token * dest@var2177 , const Token * src@var2178 , int n@var2179 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var2180 , const Token * first@var2181 , const Token * last@var2182 , bool one_line@var2183 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var2184 , const std :: string & file0@var2185 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var2186 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var2187 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var2193 .@expr1073746588 front@var2200 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var2193 .@expr1073746589 front@var2200 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var2193 .@expr1073746590 back@var2201 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var2193 .@expr1073746591 back@var2201 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var2194 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var2188 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var2189 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var2190 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var2191 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var2192 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var2193 ;
206:
207:
208: std :: vector < std :: string > mFiles@var2194 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var2195 ;
212:
213:
214: const Settings * mSettings@var2196 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var2197 ;
217:
218:
219: bool mIsC@var2198 ;
220: bool mIsCpp@var2199 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var2202 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var2203 ;
67: mutable int mVarId@var2204 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var2205 ) ;
73: bool hasVariable ( const std :: string & varname@var2206 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var2207 ) const {
75: return mVariableId@var2202 .@expr1073746592 find (@expr1073746593 varname@var2207 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var2202 .@expr1073746594 end (@expr1073746595 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var2202 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746596 mVarId@var2204 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var2208 , ErrorLogger * errorLogger@var2209 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var2210 ) {
95: mTimerResults@var2330 =@expr1073746597 tr@var2210 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var2308 .@expr1073746598 isC (@expr1073746599 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var2308 .@expr1073746600 isCPP (@expr1073746601 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var2211 , bool * unknown@var2212 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var2213 , const std :: string & FileName@var2214 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var2215 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var2216 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var2217 ,
142: const char FileName@var2218 [ ] ,
143: const std :: string & configuration@var2219 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var2220 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var2221 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var2222 , const Token * end@var2223 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var2224 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var2225 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var2226 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var2227 , const Token * const tokEnd@var2228 , const bool only_k_r_fpar@var2229 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var2230 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var2231 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var2232 , bool commandWithCondition@var2233 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var2234 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var2235 , Token * * _tok2@var2236 , Token * * _tok3@var2237 , std :: string & value@var2238 , int & valueVarId@var2239 , bool & valueIsPointer@var2240 , bool floatvar@var2241 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var2242 , Token * tok3@var2243 , int varid@var2244 , const std :: string & structname@var2245 , std :: string & value@var2246 , int valueVarId@var2247 , bool valueIsPointer@var2248 , const Token * const valueToken@var2249 , int indentlevel@var2250 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var2251 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var2252 , const std :: string & endsWith@var2253 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var2254 , const std :: string & endsWith@var2255 , bool cpp@var2256 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var2257 ) {
585: mPreprocessor@var2331 =@expr1073746602 preprocessor@var2257 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var2331 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var2258 , const Token * end@var2259 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var2260 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var2261 , const std :: string & code@var2262 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var2263 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var2264 , const std :: string & what@var2265 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var2266 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var2267 , const std :: string & msg@var2268 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var2269 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var2270 , const std :: string & macroName@var2271 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var2272 , const Token * end@var2273 , bool allowSemicolon@var2274 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var2275 , const Severity :: SeverityType severity@var2276 , const std :: string & id@var2277 , const std :: string & msg@var2278 , bool inconclusive@var2279 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var2280 , Severity :: SeverityType severity@var2281 , const std :: string & id@var2282 , const std :: string & msg@var2283 , bool inconclusive@var2284 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var2285 , const Token * name@var2286 , const Token * typeDef@var2287 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var2288 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var2289 ,
821: const VariableMap & variableMap@var2290 ,
822: const int scopeStartVarId@var2291 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var2292 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var2293 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var2294 ,
827: int * varId@var2295 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var2296 ,
830: Token * const startToken@var2297 ,
831: const Token * const endToken@var2298 ,
832: const std :: map < std :: string , int > & varlist@var2299 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var2300 ,
834: int * varId_@var2301 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var2302 ) ;
849:
850: bool operatorEnd ( const Token * tok@var2303 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var2329 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var2304 ) {
861: mSettings@var2315 =@expr1073746603 settings@var2304 ;
862: list@var2308 .@expr1073746604 setSettings (@expr1073746605 settings@var2304 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var2317 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var2305 ) const ;
877:
878: void dump ( std :: ostream & out@var2306 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var2307 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var2327 ;
888: }
889:
|
892:
893: TokenList list@var2308 ;
894:
895: const Token * tokens ( ) const {
896: return list@var2308 .@expr1073746606 front (@expr1073746607 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var2309 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var2310 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var2311 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var2312 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var2315 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var2313 , bool inOperator@var2314 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746608 mVarId@var2327 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var2315 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var2316 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var2317 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var2318 ;
973:
974:
975:
976: std :: string mConfiguration@var2319 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var2320 ;
980:
981: struct TypedefInfo {
982: std :: string name@var2321 ;
983: std :: string filename@var2322 ;
984: int lineNumber@var2323 ;
985: int column@var2324 ;
986: bool used@var2325 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var2326 ;
989:
990:
991: int mVarId@var2327 ;
992:
993:
994: int mUnnamedCount@var2328 ;
995:
|
999:
1000: bool mCodeWithTemplates@var2329 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var2330 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var2331 ;
1013: } ;

##file cppcheck-2.8/lib/checkunusedvar.cpp

1:
|
41:
42: namespace {
43: CheckUnusedVar instance@var2332 ;
44: }
45:
46: static const struct CWE CWE563@var2333 ( 563U ) ;
47: static const struct CWE CWE665@var2334 ( 665U ) ;
48:
49:
50: static bool isRaiiClassScope ( const Scope * classScope@var2335 )
51: {
52: return classScope@var2335 &&@expr1073746609 classScope@var2335 .@expr1073746610 getDestructor (@expr1073746611 ) !=@expr1073746612 nullptr ;
53: }
54:
55:
56: static bool isRaiiClass ( const ValueType * valueType@var2336 , bool cpp@var2337 , bool defaultReturn@var2338 = true )
57: {
58: if (@expr1073746613 !@expr1073746614 cpp@var2337 ) {
59: return false ; }
60:
61: if (@expr1073746615 !@expr1073746616 valueType@var2336 ) {
62: return defaultReturn@var2338 ; }
63:
64: if (@expr1073746617 valueType@var2336 .@expr4794 smartPointerType@var2339 &&@expr1073746619 isRaiiClassScope (@expr1073746620 valueType@var2336 .@expr4794 smartPointerType@var2339 .@expr1073746622 classScope@var2340 ) ) {
65: return true ; }
66:
67: switch (@expr1073746623 valueType@var2336 .@expr1073746624 type@var2341 ) {
68: case ValueType ::@expr4801 Type ::@expr1073746626 UNKNOWN_TYPE :@expr4803
69: case ValueType ::@expr4801 Type ::@expr1073746629 NONSTD :@expr4803 ;
70: return defaultReturn@var2338 ;
71:
72: case ValueType ::@expr4801 Type ::@expr1073746632 RECORD :@expr4803 ;
73: if (@expr1073746634 isRaiiClassScope (@expr1073746635 valueType@var2336 .@expr1073746636 typeScope@var2342 ) ) {
74: return true ; }
75: return defaultReturn@var2338 ;
76:
77: case ValueType ::@expr4801 Type ::@expr1073746638 POD :@expr4803
78: case ValueType ::@expr4801 Type ::@expr1073746641 SMART_POINTER :@expr4803
79: case ValueType ::@expr4801 Type ::@expr1073746644 CONTAINER :@expr4803
80: case ValueType ::@expr4801 Type ::@expr1073746647 ITERATOR :@expr4803
81: case ValueType ::@expr4801 Type ::@expr1073746650 VOID :@expr4803
82: case ValueType ::@expr4801 Type ::@expr1073746653 BOOL :@expr4803
83: case ValueType ::@expr4801 Type ::@expr1073746656 CHAR :@expr4803
84: case ValueType ::@expr4801 Type ::@expr1073746659 SHORT :@expr4803
85: case ValueType ::@expr4801 Type ::@expr1073746662 WCHAR_T :@expr4803
86: case ValueType ::@expr4801 Type ::@expr1073746665 INT :@expr4803
87: case ValueType ::@expr4801 Type ::@expr1073746668 LONG :@expr4803
88: case ValueType ::@expr4801 Type ::@expr1073746671 LONGLONG :@expr4803
89: case ValueType ::@expr4801 Type ::@expr1073746674 UNKNOWN_INT :@expr4803
90: case ValueType ::@expr4801 Type ::@expr1073746677 FLOAT :@expr4803
91: case ValueType ::@expr4801 Type ::@expr1073746680 DOUBLE :@expr4803
92: case ValueType ::@expr4801 Type ::@expr1073746683 LONGDOUBLE :@expr4803 ;
93: return false ;
94: }
95:
96: return defaultReturn@var2338 ;
97: }
98:
|
101:
102: class Variables {
103: public:
104: enum VariableType { standard , array , pointer , reference , pointerArray , referenceArray , pointerPointer , none } ;
105:
106:
107: class VariableUsage {
108: public:
109: explicit VariableUsage ( const Variable * var@var2343 = nullptr ,
110: VariableType type@var2344 = standard ,
111: bool read@var2345 = false ,
112: bool write@var2346 = false ,
113: bool modified@var2347 = false ,
114: bool allocateMemory@var2348 = false ) :
115: _var@var2351 ( var@var2343 ) ,
116: _lastAccess@var2352 ( var@var2343 ? var@var2343 . nameToken ( ) : nullptr ) ,
117: mType@var2353 ( type@var2344 ) ,
118: _read@var2354 ( read@var2345 ) ,
119: _write@var2355 ( write@var2346 ) ,
120: _modified@var2356 ( modified@var2347 ) ,
121: _allocateMemory@var2357 ( allocateMemory@var2348 ) { }
122:
123:
124: void use ( ) {
125: _read@var2354 =@expr1073746685 true ;
126: _write@var2355 =@expr1073746686 true ;
127: }
128:
129:
130: bool unused ( ) const {
131: return (@expr1073746687 !@expr1073746688 _read@var2354 &&@expr1073746689 !@expr1073746690 _write@var2355 ) ;
132: }
133:
134: std :: set < int > _aliases@var2349 ;
135: std :: set < const Scope * > _assignments@var2350 ;
136:
137: const Variable * _var@var2351 ;
138: const Token * _lastAccess@var2352 ;
139: VariableType mType@var2353 ;
140: bool _read@var2354 ;
141: bool _write@var2355 ;
142: bool _modified@var2356 ;
143: bool _allocateMemory@var2357 ;
144: } ;
145:
146: void clear ( ) {
147: mVarUsage@var2387 .@expr1073746691 clear (@expr1073746692 ) ;
148: }
149: const std :: map < int , VariableUsage > & varUsage ( ) const {
150: return mVarUsage@var2387 ;
151: }
152: void addVar ( const Variable * var@var2358 , VariableType type@var2359 , bool write_@var2360 ) ;
153: void allocateMemory ( int varid@var2361 , const Token * tok@var2362 ) ;
154: void read ( int varid@var2363 , const Token * tok@var2364 ) ;
155: void readAliases ( int varid@var2365 , const Token * tok@var2366 ) ;
156: void readAll ( int varid@var2367 , const Token * tok@var2368 ) ;
157: void write ( int varid@var2369 , const Token * tok@var2370 ) ;
158: void writeAliases ( int varid@var2371 , const Token * tok@var2372 ) ;
159: void writeAll ( int varid@var2373 , const Token * tok@var2374 ) ;
160: void use ( int varid@var2375 , const Token * tok@var2376 ) ;
161: void modified ( int varid@var2377 , const Token * tok@var2378 ) ;
162: VariableUsage * find ( int varid@var2379 ) ;
163: void alias ( int varid1@var2380 , int varid2@var2381 , bool replace@var2382 ) ;
164: void erase ( int varid@var2383 ) {
165: mVarUsage@var2387 .@expr1073746693 erase (@expr1073746694 varid@var2383 ) ;
166: }
167: void eraseAliases ( int varid@var2384 ) ;
168: void eraseAll ( int varid@var2385 ) ;
169: void clearAliases ( int varid@var2386 ) ;
170:
171: private:
172:
173: std :: map < int , VariableUsage > mVarUsage@var2387 ;
174: } ;
175:
|
183:
184: void Variables :: alias ( int varid1@var2388 , int varid2@var2389 , bool replace@var2390 )
185: {
186: VariableUsage * var1@var2391 ; var1@var2391 =@expr1073746695 find (@expr1073746696 varid1@var2388 ) ;
187: VariableUsage * var2@var2392 ; var2@var2392 =@expr1073746697 find (@expr1073746698 varid2@var2389 ) ;
188:
189: if (@expr1073746699 !@expr1073746700 var1@var2391 ||@expr1073746701 !@expr1073746702 var2@var2392 ) {
190: return ; }
191:
192:
193: if (@expr1073746703 varid1@var2388 ==@expr1073746704 varid2@var2389 ) {
194: var1@var2391 .@expr1073746705 use (@expr1073746706 ) ;
195: return ;
196: }
197:
198: if (@expr1073746707 replace@var2390 ) {
199:
200: for (@expr1073746708 std ::@expr4885 set < int > ::@expr4885 const_iterator i@var2393 =@expr1073746711 var1@var2391 .@expr4888 _aliases@var2394 .@expr1073746713 begin (@expr1073746714 ) ; i@var2393 !=@expr1073746715 var1@var2391 .@expr4888 _aliases@var2394 .@expr1073746717 end (@expr1073746718 ) ; ++@expr1073746719 i@var2393 ) {
201: VariableUsage * temp@var2395 ; temp@var2395 =@expr1073746720 find (@expr1073746721 *@expr1073746722 i@var2393 ) ;
202:
203: if (@expr1073746723 temp@var2395 ) {
204: temp@var2395 .@expr1073746724 _aliases@var2396 .@expr1073746725 erase (@expr1073746726 var1@var2391 .@expr1073746727 _var@var2397 .@expr1073746728 declarationId (@expr1073746729 ) ) ; }
205: }
206:
207:
208: var1@var2391 .@expr4888 _aliases@var2394 .@expr1073746731 clear (@expr1073746732 ) ;
209: }
210:
211:
212: for (@expr1073746733 std ::@expr4885 set < int > ::@expr4885 const_iterator i@var2398 =@expr1073746736 var2@var2392 .@expr4913 _aliases@var2399 .@expr1073746738 begin (@expr1073746739 ) ; i@var2398 !=@expr1073746740 var2@var2392 .@expr4913 _aliases@var2399 .@expr1073746742 end (@expr1073746743 ) ; ++@expr1073746744 i@var2398 ) {
213: if (@expr1073746745 *@expr4922 i@var2398 !=@expr1073746747 varid1@var2388 ) {
214: var1@var2391 .@expr4888 _aliases@var2394 .@expr4925 insert (@expr1073746750 *@expr4922 i@var2398 ) ; }
215: }
216:
217:
218: var2@var2392 .@expr4913 _aliases@var2399 .@expr1073746753 insert (@expr1073746754 varid1@var2388 ) ;
219: var1@var2391 .@expr4888 _aliases@var2394 .@expr4925 insert (@expr1073746757 varid2@var2389 ) ;
220:
221: if (@expr1073746758 var2@var2392 .@expr1073746759 mType@var2400 ==@expr1073746760 Variables ::@expr1073746761 pointer ) {
222: var2@var2392 .@expr1073746762 _read@var2401 =@expr1073746763 true ;
223: }
224: }
225:
226: void Variables :: clearAliases ( int varid@var2402 )
227: {
228: VariableUsage * usage@var2403 ; usage@var2403 =@expr1073746764 find (@expr1073746765 varid@var2402 ) ;
229:
230: if (@expr1073746766 usage@var2403 ) {
231:
232: std ::@expr1073746767 set < int > ::@expr1073746768 const_iterator i@var2404 ;
233:
234: for (@expr1073746769 i@var2404 =@expr1073746770 usage@var2403 .@expr4947 _aliases@var2405 .@expr1073746772 begin (@expr1073746773 ) ; i@var2404 !=@expr1073746774 usage@var2403 .@expr4947 _aliases@var2405 .@expr1073746776 end (@expr1073746777 ) ; ++@expr1073746778 i@var2404 ) {
235: VariableUsage * temp@var2406 ; temp@var2406 =@expr1073746779 find (@expr1073746780 *@expr1073746781 i@var2404 ) ;
236:
237: if (@expr1073746782 temp@var2406 ) {
238: temp@var2406 .@expr1073746783 _aliases@var2407 .@expr1073746784 erase (@expr1073746785 usage@var2403 .@expr1073746786 _var@var2408 .@expr1073746787 declarationId (@expr1073746788 ) ) ; }
239: }
240:
241:
242: usage@var2403 .@expr4947 _aliases@var2405 .@expr1073746790 clear (@expr1073746791 ) ;
243: }
244: }
245:
246: void Variables :: eraseAliases ( int varid@var2409 )
247: {
248: VariableUsage * usage@var2410 ; usage@var2410 =@expr1073746792 find (@expr1073746793 varid@var2409 ) ;
249:
250: if (@expr1073746794 usage@var2410 ) {
251: for (@expr1073746795 std ::@expr4972 set < int > ::@expr4972 const_iterator aliases@var2411 =@expr1073746798 usage@var2410 .@expr4975 _aliases@var2412 .@expr1073746800 begin (@expr1073746801 ) ; aliases@var2411 !=@expr1073746802 usage@var2410 .@expr4975 _aliases@var2412 .@expr1073746804 end (@expr1073746805 ) ; ++@expr1073746806 aliases@var2411 ) {
252: erase (@expr1073746807 *@expr1073746808 aliases@var2411 ) ; }
253: }
254: }
255:
256: void Variables :: eraseAll ( int varid@var2413 )
257: {
258: eraseAliases (@expr1073746809 varid@var2413 ) ;
259: erase (@expr1073746810 varid@var2413 ) ;
260: }
261:
262: void Variables :: addVar ( const Variable * var@var2414 ,
263: VariableType type@var2415 ,
264: bool write_@var2416 )
265: {
266: if (@expr1073746811 var@var2414 .@expr4988 declarationId (@expr4989 ) >@expr1073746814 0 ) {
267: mVarUsage@var2387 .@expr1073746815 insert (@expr1073746816 std ::@expr1073746817 make_pair (@expr1073746818 var@var2414 .@expr4988 declarationId (@expr4989 ) , VariableUsage (@expr1073746821 var@var2414 , type@var2415 , false , write_@var2416 , false ) ) ) ;
268: }
269: }
270:
271: void Variables :: allocateMemory ( int varid@var2417 , const Token * tok@var2418 )
272: {
273: VariableUsage * usage@var2419 ; usage@var2419 =@expr1073746822 find (@expr1073746823 varid@var2417 ) ;
274:
275: if (@expr1073746824 usage@var2419 ) {
276: usage@var2419 .@expr1073746825 _allocateMemory@var2420 =@expr1073746826 true ;
277: usage@var2419 .@expr1073746827 _lastAccess@var2421 =@expr1073746828 tok@var2418 ;
278: }
279: }
280:
281: void Variables :: read ( int varid@var2422 , const Token * tok@var2423 )
282: {
283: VariableUsage * usage@var2424 ; usage@var2424 =@expr1073746829 find (@expr1073746830 varid@var2422 ) ;
284:
285: if (@expr1073746831 usage@var2424 ) {
286: usage@var2424 .@expr1073746832 _read@var2425 =@expr1073746833 true ;
287: if (@expr1073746834 tok@var2423 ) {
288: usage@var2424 .@expr1073746835 _lastAccess@var2426 =@expr1073746836 tok@var2423 ; }
289: }
290: }
291:
292: void Variables :: readAliases ( int varid@var2427 , const Token * tok@var2428 )
293: {
294: VariableUsage * usage@var2429 ; usage@var2429 =@expr1073746837 find (@expr1073746838 varid@var2427 ) ;
295:
296: if (@expr1073746839 usage@var2429 ) {
297: for (@expr1073746840 int aliases@var2430 :@expr1073746841 usage@var2429 .@expr1073746842 _aliases@var2431 ) {
298: VariableUsage * aliased@var2432 ; aliased@var2432 =@expr1073746843 find (@expr1073746844 aliases@var2430 ) ;
299:
300: if (@expr1073746845 aliased@var2432 ) {
301: aliased@var2432 .@expr1073746846 _read@var2433 =@expr1073746847 true ;
302: aliased@var2432 .@expr1073746848 _lastAccess@var2434 =@expr1073746849 tok@var2428 ;
303: }
304: }
305: }
306: }
307:
308: void Variables :: readAll ( int varid@var2435 , const Token * tok@var2436 )
309: {
310: read (@expr1073746850 varid@var2435 , tok@var2436 ) ;
311: readAliases (@expr1073746851 varid@var2435 , tok@var2436 ) ;
312: }
313:
314: void Variables :: write ( int varid@var2437 , const Token * tok@var2438 )
315: {
316: VariableUsage * usage@var2439 ; usage@var2439 =@expr1073746852 find (@expr1073746853 varid@var2437 ) ;
317:
318: if (@expr1073746854 usage@var2439 ) {
319: usage@var2439 .@expr1073746855 _write@var2440 =@expr1073746856 true ;
320: if (@expr1073746857 !@expr1073746858 usage@var2439 .@expr1073746859 _var@var2441 .@expr1073746860 isStatic (@expr1073746861 ) &&@expr1073746862 !@expr1073746863 Token ::@expr1073746864 simpleMatch (@expr1073746865 tok@var2438 .@expr1073746866 next (@expr1073746867 ) , "= 0 ;" ) ) {
321: usage@var2439 .@expr1073746868 _read@var2442 =@expr1073746869 false ; }
322: usage@var2439 .@expr1073746870 _lastAccess@var2443 =@expr1073746871 tok@var2438 ;
323: }
324: }
325:
326: void Variables :: writeAliases ( int varid@var2444 , const Token * tok@var2445 )
327: {
328: VariableUsage * usage@var2446 ; usage@var2446 =@expr1073746872 find (@expr1073746873 varid@var2444 ) ;
329:
330: if (@expr1073746874 usage@var2446 ) {
331: for (@expr1073746875 std ::@expr5052 set < int > ::@expr5052 const_iterator aliases@var2447 =@expr1073746878 usage@var2446 .@expr5055 _aliases@var2448 .@expr1073746880 begin (@expr1073746881 ) ; aliases@var2447 !=@expr1073746882 usage@var2446 .@expr5055 _aliases@var2448 .@expr1073746884 end (@expr1073746885 ) ; ++@expr1073746886 aliases@var2447 ) {
332: VariableUsage * aliased@var2449 ; aliased@var2449 =@expr1073746887 find (@expr1073746888 *@expr1073746889 aliases@var2447 ) ;
333:
334: if (@expr1073746890 aliased@var2449 ) {
335: aliased@var2449 .@expr1073746891 _write@var2450 =@expr1073746892 true ;
336: aliased@var2449 .@expr1073746893 _lastAccess@var2451 =@expr1073746894 tok@var2445 ;
337: }
338: }
339: }
340: }
341:
342: void Variables :: writeAll ( int varid@var2452 , const Token * tok@var2453 )
343: {
344: write (@expr1073746895 varid@var2452 , tok@var2453 ) ;
345: writeAliases (@expr1073746896 varid@var2452 , tok@var2453 ) ;
346: }
347:
348: void Variables :: use ( int varid@var2454 , const Token * tok@var2455 )
349: {
350: VariableUsage * usage@var2456 ; usage@var2456 =@expr1073746897 find (@expr1073746898 varid@var2454 ) ;
351:
352: if (@expr1073746899 usage@var2456 ) {
353: usage@var2456 .@expr1073746900 use (@expr1073746901 ) ;
354: usage@var2456 .@expr1073746902 _lastAccess@var2457 =@expr1073746903 tok@var2455 ;
355:
356: for (@expr1073746904 std ::@expr5081 set < int > ::@expr5081 const_iterator aliases@var2458 =@expr1073746907 usage@var2456 .@expr5084 _aliases@var2459 .@expr1073746909 begin (@expr1073746910 ) ; aliases@var2458 !=@expr1073746911 usage@var2456 .@expr5084 _aliases@var2459 .@expr1073746913 end (@expr1073746914 ) ; ++@expr1073746915 aliases@var2458 ) {
357: VariableUsage * aliased@var2460 ; aliased@var2460 =@expr1073746916 find (@expr1073746917 *@expr1073746918 aliases@var2458 ) ;
358:
359: if (@expr1073746919 aliased@var2460 ) {
360: aliased@var2460 .@expr1073746920 use (@expr1073746921 ) ;
361: aliased@var2460 .@expr1073746922 _lastAccess@var2461 =@expr1073746923 tok@var2455 ;
362: }
363: }
364: }
365: }
366:
367: void Variables :: modified ( int varid@var2462 , const Token * tok@var2463 )
368: {
369: VariableUsage * usage@var2464 ; usage@var2464 =@expr1073746924 find (@expr1073746925 varid@var2462 ) ;
370:
371: if (@expr1073746926 usage@var2464 ) {
372: if (@expr1073746927 !@expr1073746928 usage@var2464 .@expr1073746929 _var@var2465 .@expr1073746930 isStatic (@expr1073746931 ) ) {
373: usage@var2464 .@expr1073746932 _read@var2466 =@expr1073746933 false ; }
374: usage@var2464 .@expr1073746934 _modified@var2467 =@expr1073746935 true ;
375: usage@var2464 .@expr1073746936 _lastAccess@var2468 =@expr1073746937 tok@var2463 ;
376:
377: for (@expr1073746938 std ::@expr5115 set < int > ::@expr5115 const_iterator aliases@var2469 =@expr1073746941 usage@var2464 .@expr5118 _aliases@var2470 .@expr1073746943 begin (@expr1073746944 ) ; aliases@var2469 !=@expr1073746945 usage@var2464 .@expr5118 _aliases@var2470 .@expr1073746947 end (@expr1073746948 ) ; ++@expr1073746949 aliases@var2469 ) {
378: VariableUsage * aliased@var2471 ; aliased@var2471 =@expr1073746950 find (@expr1073746951 *@expr1073746952 aliases@var2469 ) ;
379:
380: if (@expr1073746953 aliased@var2471 ) {
381: aliased@var2471 .@expr1073746954 _modified@var2472 =@expr1073746955 true ;
382: aliased@var2471 .@expr1073746956 _lastAccess@var2473 =@expr1073746957 tok@var2463 ;
383: }
384: }
385: }
386: }
387:
388: Variables :: VariableUsage * Variables :: find ( int varid@var2474 )
389: {
390: if (@expr1073746958 varid@var2474 ) {
391: std ::@expr1073746959 map < int , VariableUsage > ::@expr1073746960 iterator i@var2475 ; i@var2475 =@expr1073746961 mVarUsage@var2387 .@expr1073746962 find (@expr1073746963 varid@var2474 ) ;
392: if (@expr1073746964 i@var2475 !=@expr1073746965 mVarUsage@var2387 .@expr1073746966 end (@expr1073746967 ) ) {
393: return &@expr1073746968 i@var2475 .@expr1073746969 second@var2476 ; }
394: }
395: return nullptr ;
396: }
397:
398: static const Token * doAssignment ( Variables & variables@var2477 , const Token * tok@var2478 , bool dereference@var2479 , const Scope * scope@var2480 )
399: {
400:
401: if (@expr1073746970 Token ::@expr5147 Match (@expr1073746972 tok@var2478 , "%var% = %var% !!;" ) ) {
402: const Token * rhsVarTok@var2481 ; rhsVarTok@var2481 =@expr1073746973 tok@var2478 .@expr5150 tokAt (@expr5151 2 ) ;
403: if (@expr1073746976 tok@var2478 .@expr5153 varId (@expr5154 ) ==@expr1073746979 rhsVarTok@var2481 .@expr1073746980 varId (@expr1073746981 ) ) {
404: return rhsVarTok@var2481 ;
405: }
406: }
407:
408: if (@expr1073746982 Token ::@expr5147 Match (@expr1073746984 tok@var2478 , "%var% %assign%" ) &&@expr1073746985 tok@var2478 .@expr5162 strAt (@expr5163 1 ) !=@expr1073746988 "=" ) {
409: return tok@var2478 .@expr5165 next (@expr5166 ) ; }
410:
411: const Token * const tokOld@var2482 ; tokOld@var2482 =@expr1073746991 tok@var2478 ;
412:
413:
414: const int varid1@var2483 =@expr1073746992 tok@var2478 .@expr5153 varId (@expr5154 ) ;
415: Variables ::@expr5171 VariableUsage * var1@var2484 ; var1@var2484 =@expr1073746996 variables@var2477 .@expr5173 find (@expr1073746998 varid1@var2483 ) ;
416:
417: if (@expr1073746999 var1@var2484 ) {
418:
419: tok@var2478 =@expr1073747000 tok@var2478 .@expr5165 next (@expr5166 ) ;
420: while (@expr1073747003 !@expr1073747004 tok@var2478 .@expr1073747005 isAssignmentOp (@expr1073747006 ) ) {
421: if (@expr1073747007 tok@var2478 .@expr5153 varId (@expr5154 ) ) {
422: variables@var2477 .@expr5186 read (@expr1073747011 tok@var2478 .@expr5153 varId (@expr5154 ) , tok@var2478 ) ; }
423: tok@var2478 =@expr1073747014 tok@var2478 .@expr5165 next (@expr5166 ) ;
424: }
425: tok@var2478 =@expr1073747017 tok@var2478 .@expr5165 next (@expr5166 ) ;
426:
427: if (@expr1073747020 Token ::@expr5147 Match (@expr1073747022 tok@var2478 , "( const| struct|union| %type% * ) ( (" ) ) {
428: tok@var2478 =@expr1073747023 tok@var2478 .@expr1073747024 link (@expr1073747025 ) .@expr1073747026 next (@expr1073747027 ) ; }
429:
430: if (@expr1073747028 Token ::@expr5147 Match (@expr1073747030 tok@var2478 , "( [(<] const| struct|union| %type% *| [>)]" ) ) {
431: tok@var2478 =@expr1073747031 tok@var2478 .@expr5165 next (@expr5166 ) ; }
432:
433: if (@expr1073747034 Token ::@expr5147 Match (@expr1073747036 tok@var2478 , "(| &| %name%" ) ||@expr1073747037
434: (@expr1073747038 Token ::@expr5147 Match (@expr1073747040 tok@var2478 .@expr5165 next (@expr5166 ) , "< const| struct|union| %type% *| > ( &| %name%" ) ) ) {
435: bool addressOf@var2485 ; addressOf@var2485 =@expr1073747043 false ;
436:
437: if (@expr1073747044 Token ::@expr5147 Match (@expr1073747046 tok@var2478 , "%var% ." ) ) {
438: variables@var2477 .@expr5223 use (@expr1073747048 tok@var2478 .@expr5153 varId (@expr5154 ) , tok@var2478 ) ; }
439:
440:
441: if (@expr5227 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5230 "(" ) {
442: tok@var2478 =@expr1073747055 tok@var2478 .@expr5165 next (@expr5166 ) ;
443: if (@expr5234 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5237 "const" ) {
444: tok@var2478 =@expr1073747062 tok@var2478 .@expr5165 next (@expr5166 ) ; }
445:
446: if (@expr5241 Token ::@expr5147 Match (@expr5243 tok@var2478 , "struct|union" ) ) {
447: tok@var2478 =@expr1073747068 tok@var2478 .@expr5165 next (@expr5166 ) ; }
448:
449: while (@expr1073747071 (@expr1073747072 tok@var2478 .@expr1073747073 isName (@expr1073747074 ) &&@expr1073747075 tok@var2478 .@expr5153 varId (@expr5154 ) ==@expr1073747078 0 ) ||@expr1073747079 (@expr1073747080 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5259 "*" ) ||@expr1073747084 (@expr1073747085 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr1073747088 ")" ) ) {
450: tok@var2478 =@expr1073747089 tok@var2478 .@expr5165 next (@expr5166 ) ; }
451:
452: if (@expr5268 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5271 "&" ) {
453: addressOf@var2485 =@expr1073747096 true ;
454: tok@var2478 =@expr1073747097 tok@var2478 .@expr5165 next (@expr5166 ) ;
455: } else { if (@expr5227 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5230 "(" ) {
456: tok@var2478 =@expr1073747104 tok@var2478 .@expr5165 next (@expr5166 ) ;
457: if (@expr5268 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5271 "&" ) {
458: addressOf@var2485 =@expr1073747111 true ;
459: tok@var2478 =@expr1073747112 tok@var2478 .@expr5165 next (@expr5166 ) ;
460: }
461: } else { if (@expr1073747115 Token ::@expr5147 Match (@expr1073747117 tok@var2478 , "%cop% %var%" ) ) {
462: variables@var2477 .@expr5186 read (@expr1073747119 tok@var2478 .@expr5165 next (@expr5166 ) .@expr1073747122 varId (@expr1073747123 ) , tok@var2478 ) ;
463: } } }
464: }
465:
466:
467: else { if (@expr1073747124 tok@var2478 .@expr5228 str (@expr5229 ) .@expr1073747127 find (@expr1073747128 "cast" ) !=@expr1073747129 std ::@expr1073747130 string ::@expr1073747131 npos &&@expr1073747132
468: tok@var2478 .@expr5162 strAt (@expr5163 1 ) ==@expr1073747135 "<" ) {
469: tok@var2478 =@expr1073747136 tok@var2478 .@expr5150 tokAt (@expr5151 2 ) ;
470: if (@expr5234 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5237 "const" ) {
471: tok@var2478 =@expr1073747143 tok@var2478 .@expr5165 next (@expr5166 ) ; }
472:
473: if (@expr5241 Token ::@expr5147 Match (@expr5243 tok@var2478 , "struct|union" ) ) {
474: tok@var2478 =@expr1073747149 tok@var2478 .@expr5165 next (@expr5166 ) ; }
475:
476: tok@var2478 =@expr1073747152 tok@var2478 .@expr5165 next (@expr5166 ) ;
477: if (@expr1073747155 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5259 "*" ) {
478: tok@var2478 =@expr1073747159 tok@var2478 .@expr5165 next (@expr5166 ) ; }
479:
480: tok@var2478 =@expr1073747162 tok@var2478 .@expr5150 tokAt (@expr5151 2 ) ;
481: if (@expr1073747165 !@expr1073747166 tok@var2478 ) {
482: return tokOld@var2482 ; }
483: if (@expr5268 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5271 "&" ) {
484: addressOf@var2485 =@expr1073747171 true ;
485: tok@var2478 =@expr1073747172 tok@var2478 .@expr5165 next (@expr5166 ) ;
486: }
487: }
488:
489:
490: else { if (@expr1073747175 !@expr1073747176 Token ::@expr5147 Match (@expr1073747178 tok@var2478 , "%name% ?" ) ) {
491: if (@expr5268 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr5271 "&" ) {
492: addressOf@var2485 =@expr1073747183 true ;
493: tok@var2478 =@expr1073747184 tok@var2478 .@expr5165 next (@expr5166 ) ;
494: } else { if (@expr1073747187 tok@var2478 .@expr5228 str (@expr5229 ) ==@expr1073747190 "new" ) {
495: return tokOld@var2482 ; } }
496: } } }
497:
498:
499: const int varid2@var2486 =@expr1073747191 tok@var2478 .@expr5153 varId (@expr5154 ) ;
500: const Variables ::@expr5171 VariableUsage * var2@var2487 ; var2@var2487 =@expr1073747195 variables@var2477 .@expr5173 find (@expr1073747197 varid2@var2486 ) ;
501:
502: if (@expr1073747198 var2@var2487 ) {
503: if (@expr1073747199 var1@var2484 .@expr5376 mType@var2488 ==@expr5377 Variables ::@expr5378 pointer ||@expr1073747203 var1@var2484 .@expr5376 mType@var2488 ==@expr5381 Variables ::@expr5382 pointerArray ) {
504: if (@expr1073747207 dereference@var2479 ) {
505: variables@var2477 .@expr5186 read (@expr5385 varid2@var2486 , tok@var2478 ) ; }
506: else {
507: if (@expr1073747210 addressOf@var2485 ||@expr1073747211
508: var2@var2487 .@expr5388 mType@var2489 ==@expr1073747213 Variables ::@expr5390 array ||@expr1073747215
509: var2@var2487 .@expr5388 mType@var2489 ==@expr5393 Variables ::@expr5378 pointer ) {
510: bool replace@var2490 ; replace@var2490 =@expr1073747219 true ;
511:
512:
513: if (@expr1073747220 var1@var2484 .@expr5376 mType@var2488 ==@expr5381 Variables ::@expr5382 pointerArray ) {
514: replace@var2490 =@expr1073747224 false ; }
515:
516:
517: else { if (@expr5401 scope@var2480 ==@expr5402 var1@var2484 .@expr5403 _var@var2491 .@expr5404 scope (@expr5405 ) ) {
518: replace@var2490 =@expr1073747230 true ; }
519:
520:
521: else {
522:
523: if (@expr1073747231 var1@var2484 .@expr5408 _assignments@var2492 .@expr5409 find (@expr5410 scope@var2480 ) ==@expr5411 var1@var2484 .@expr5408 _assignments@var2492 .@expr5413 end (@expr5414 ) ||@expr1073747239
524: scope@var2480 .@expr1073747240 type@var2493 ==@expr1073747241 Scope ::@expr1073747242 eSwitch ) {
525:
526:
527: if (@expr1073747243 var1@var2484 .@expr5408 _assignments@var2492 .@expr1073747245 empty (@expr1073747246 ) ) {
528: replace@var2490 =@expr1073747247 false ; }
529:
530:
531: else {
532:
533: replace@var2490 =@expr1073747248 false ;
534: }
535: }
536:
537:
538: else {
539:
540: replace@var2490 =@expr1073747249 var1@var2484 .@expr5408 _assignments@var2492 .@expr1073747251 size (@expr1073747252 ) ==@expr1073747253 1 ;
541: }
542: } }
543:
544: variables@var2477 .@expr5430 alias (@expr1073747255 varid1@var2483 , varid2@var2486 , replace@var2490 ) ;
545: } else { if (@expr1073747256 tok@var2478 .@expr5162 strAt (@expr5163 1 ) ==@expr1073747259 "?" ) {
546: if (@expr1073747260 var2@var2487 .@expr5388 mType@var2489 ==@expr1073747262 Variables ::@expr5439 reference ) {
547: variables@var2477 .@expr5440 readAliases (@expr5441 varid2@var2486 , tok@var2478 ) ; }
548: else {
549: variables@var2477 .@expr5186 read (@expr5385 varid2@var2486 , tok@var2478 ) ; }
550: } else {
551: variables@var2477 .@expr1073747268 readAll (@expr1073747269 varid2@var2486 , tok@var2478 ) ;
552: } }
553: }
554: } else { if (@expr1073747270 var1@var2484 .@expr5376 mType@var2488 ==@expr1073747272 Variables ::@expr5439 reference ) {
555: variables@var2477 .@expr5430 alias (@expr5451 varid1@var2483 , varid2@var2486 , true ) ;
556: } else { if (@expr1073747276 var1@var2484 .@expr5376 mType@var2488 ==@expr1073747278 Variables ::@expr1073747279 standard &&@expr1073747280 addressOf@var2485 ) {
557: variables@var2477 .@expr5430 alias (@expr5451 varid1@var2483 , varid2@var2486 , true ) ;
558: } else {
559: if (@expr1073747283 (@expr1073747284 var2@var2487 .@expr5388 mType@var2489 ==@expr5393 Variables ::@expr5378 pointer ||@expr1073747288 var2@var2487 .@expr5388 mType@var2489 ==@expr1073747290 Variables ::@expr5382 pointerArray ) &&@expr1073747292 tok@var2478 .@expr5162 strAt (@expr5163 1 ) ==@expr1073747295 "[" ) {
560: variables@var2477 .@expr5440 readAliases (@expr5441 varid2@var2486 , tok@var2478 ) ; }
561:
562: variables@var2477 .@expr5186 read (@expr5385 varid2@var2486 , tok@var2478 ) ;
563: } } }
564: } else {
565: if (@expr1073747300 var1@var2484 .@expr5376 mType@var2488 ==@expr5377 Variables ::@expr5378 pointer &&@expr1073747304 !@expr1073747305 dereference@var2479 ) {
566:
567: if (@expr5401 var1@var2484 .@expr5403 _var@var2491 .@expr5404 scope (@expr5405 ) ==@expr5402 scope@var2480 ) {
568:
569: for (@expr1073747311 const Token *@expr1073747312 rhs@var2494 =@expr1073747313 tok@var2478 ; rhs@var2494 &&@expr1073747314 rhs@var2494 .@expr1073747315 str (@expr1073747316 ) !=@expr1073747317 ";" ; rhs@var2494 =@expr1073747318 rhs@var2494 .@expr1073747319 next (@expr1073747320 ) ) {
570: if (@expr1073747321 rhs@var2494 .@expr1073747322 varId (@expr1073747323 ) ==@expr1073747324 varid1@var2483 ) {
571: variables@var2477 .@expr5223 use (@expr1073747326 varid1@var2483 , tok@var2478 ) ;
572: break ;
573: }
574: }
575: variables@var2477 .@expr5503 clearAliases (@expr5504 varid1@var2483 ) ;
576: } else {
577:
578: if (@expr1073747329 var1@var2484 .@expr5408 _assignments@var2492 .@expr5409 find (@expr5410 scope@var2480 ) ==@expr5411 var1@var2484 .@expr5408 _assignments@var2492 .@expr5413 end (@expr5414 ) ) {
579:
580:
581:
582: }
583:
584:
585: else {
586:
587:
588: variables@var2477 .@expr5503 clearAliases (@expr5504 varid1@var2483 ) ;
589: }
590: }
591: }
592: }
593: } else {
594: tok@var2478 =@expr1073747339 tokOld@var2482 ; }
595:
596: var1@var2484 .@expr5408 _assignments@var2492 .@expr1073747341 insert (@expr1073747342 scope@var2480 ) ;
597: }
598:
599:
600:
601: else { if (@expr1073747343 Token ::@expr5147 Match (@expr1073747345 tok@var2478 .@expr5150 tokAt (@expr1073747347 -2 ) , "%name% ." ) ) {
602: const Token * rhsVarTok@var2495 ; rhsVarTok@var2495 =@expr1073747348 tok@var2478 .@expr5150 tokAt (@expr5151 2 ) ;
603: if (@expr1073747351 rhsVarTok@var2495 &&@expr1073747352 rhsVarTok@var2495 .@expr5529 varId (@expr5530 ) ) {
604: const int varid2@var2496 =@expr1073747355 rhsVarTok@var2495 .@expr5529 varId (@expr5530 ) ;
605: const Variables ::@expr5171 VariableUsage * var2@var2497 ; var2@var2497 =@expr1073747359 variables@var2477 .@expr5173 find (@expr1073747361 varid2@var2496 ) ;
606:
607:
608: if (@expr1073747362 var2@var2497 &&@expr1073747363 (@expr1073747364 var2@var2497 .@expr5541 mType@var2498 ==@expr1073747366 Variables ::@expr5390 array ||@expr1073747368
609: var2@var2497 .@expr5541 mType@var2498 ==@expr1073747370 Variables ::@expr5378 pointer ) ) {
610:
611:
612: variables@var2477 .@expr1073747372 eraseAll (@expr1073747373 varid2@var2496 ) ;
613: }
614: }
615: }
616:
617:
618: else { if (@expr1073747374 Token ::@expr5147 Match (@expr1073747376 tok@var2478 , "%name% = %name% ;" ) ) {
619: const int varid2@var2499 =@expr1073747377 tok@var2478 .@expr5150 tokAt (@expr5151 2 ) .@expr1073747380 varId (@expr1073747381 ) ;
620: const Variables ::@expr5171 VariableUsage * var2@var2500 ; var2@var2500 =@expr1073747383 variables@var2477 .@expr5173 find (@expr1073747385 varid2@var2499 ) ;
621: if (@expr1073747386 var2@var2500 &&@expr1073747387 (@expr1073747388 var2@var2500 .@expr5565 mType@var2501 ==@expr1073747390 Variables ::@expr5390 array ||@expr1073747392
622: var2@var2500 .@expr5565 mType@var2501 ==@expr1073747394 Variables ::@expr5378 pointer ) ) {
623: variables@var2477 .@expr5223 use (@expr1073747397 varid2@var2499 , tok@var2478 ) ;
624: }
625: } } }
626:
627: return tok@var2478 ;
628: }
629:
630: static bool isPartOfClassStructUnion ( const Token * tok@var2502 )
631: {
632: for (@expr1073747398 ; tok@var2502 ; tok@var2502 =@expr1073747399 tok@var2502 .@expr1073747400 previous (@expr1073747401 ) ) {
633: if (@expr1073747402 tok@var2502 .@expr5579 str (@expr5580 ) ==@expr1073747405 "}" ||@expr1073747406 tok@var2502 .@expr5579 str (@expr5580 ) ==@expr1073747409 ")" ) {
634: tok@var2502 =@expr1073747410 tok@var2502 .@expr1073747411 link (@expr1073747412 ) ; }
635: else { if (@expr1073747413 tok@var2502 .@expr5579 str (@expr5580 ) ==@expr1073747416 "(" ) {
636: return (@expr5593 false ) ; }
637: else { if (@expr1073747418 tok@var2502 .@expr5579 str (@expr5580 ) ==@expr1073747421 "{" ) {
638: return (@expr5593 tok@var2502 .@expr5599 strAt (@expr5600 -1 ) ==@expr1073747425 "struct" ||@expr1073747426 tok@var2502 .@expr5599 strAt (@expr5604 -2 ) ==@expr1073747429 "struct" ||@expr1073747430 tok@var2502 .@expr5599 strAt (@expr5600 -1 ) ==@expr1073747433 "class" ||@expr1073747434 tok@var2502 .@expr5599 strAt (@expr5604 -2 ) ==@expr1073747437 "class" ||@expr1073747438 tok@var2502 .@expr5599 strAt (@expr5600 -1 ) ==@expr1073747441 "union" ||@expr1073747442 tok@var2502 .@expr5599 strAt (@expr5604 -2 ) ==@expr1073747445 "union" ) ;
639: } } }
640: }
641: return false ;
642: }
643:
644: static bool isVarDecl ( const Token * tok@var2503 )
645: {
646: return tok@var2503 &&@expr1073747446 tok@var2503 .@expr5623 variable (@expr5624 ) &&@expr1073747449 tok@var2503 .@expr5623 variable (@expr5624 ) .@expr1073747452 nameToken (@expr1073747453 ) ==@expr1073747454 tok@var2503 ;
647: }
648:
649:
650: static const Token * skipBrackets ( const Token * tok@var2504 )
651: {
652: while (@expr1073747455 tok@var2504 &&@expr1073747456 tok@var2504 .@expr1073747457 str (@expr1073747458 ) ==@expr1073747459 "[" ) {
653: tok@var2504 =@expr1073747460 tok@var2504 .@expr1073747461 link (@expr1073747462 ) .@expr1073747463 next (@expr1073747464 ) ; }
654: return tok@var2504 ;
655: }
656:
657:
658:
659: static const Token * skipBracketsAndMembers ( const Token * tok@var2505 )
660: {
661: while (@expr1073747465 tok@var2505 ) {
662: if (@expr1073747466 tok@var2505 .@expr1073747467 str (@expr1073747468 ) ==@expr1073747469 "[" ) {
663: tok@var2505 =@expr1073747470 tok@var2505 .@expr1073747471 link (@expr1073747472 ) .@expr1073747473 next (@expr1073747474 ) ; }
664: else { if (@expr1073747475 Token ::@expr1073747476 Match (@expr1073747477 tok@var2505 , ". %name%" ) ) {
665: tok@var2505 =@expr1073747478 tok@var2505 .@expr1073747479 tokAt (@expr1073747480 2 ) ; }
666: else {
667: break ; } }
668: }
669: return tok@var2505 ;
670: }
671:
672: static void useFunctionArgs ( const Token * tok@var2506 , Variables & variables@var2507 )
673: {
674:
675: if (@expr1073747481 !@expr1073747482 tok@var2506 ) {
676: return ; }
677: if (@expr1073747483 tok@var2506 .@expr1073747484 str (@expr1073747485 ) ==@expr1073747486 "," ) {
678: useFunctionArgs (@expr5663 tok@var2506 .@expr5664 astOperand1 (@expr5665 ) , variables@var2507 ) ;
679: useFunctionArgs (@expr5666 tok@var2506 .@expr5667 astOperand2 (@expr5668 ) , variables@var2507 ) ;
680: } else { if (@expr1073747493 Token ::@expr1073747494 Match (@expr1073747495 tok@var2506 , "[+:]" ) &&@expr1073747496 (@expr1073747497 !@expr1073747498 tok@var2506 .@expr5675 valueType (@expr5676 ) ||@expr1073747501 tok@var2506 .@expr5675 valueType (@expr5676 ) .@expr1073747504 pointer@var2745 ) ) {
681: useFunctionArgs (@expr5663 tok@var2506 .@expr5664 astOperand1 (@expr5665 ) , variables@var2507 ) ;
682: useFunctionArgs (@expr5666 tok@var2506 .@expr5667 astOperand2 (@expr5668 ) , variables@var2507 ) ;
683: } else { if (@expr1073747511 tok@var2506 .@expr5688 variable (@expr5689 ) &&@expr1073747514 tok@var2506 .@expr5688 variable (@expr5689 ) .@expr1073747517 isArray (@expr1073747518 ) ) {
684: variables@var2507 .@expr1073747519 use (@expr1073747520 tok@var2506 .@expr1073747521 varId (@expr1073747522 ) , tok@var2506 ) ;
685: } } }
686: }
687:
|
690:
691: void CheckUnusedVar :: checkFunctionVariableUsage_iterateScopes ( const Scope * const scope@var2508 , Variables & variables@var2509 )
692: {
693:
694: if (@expr1073747523 scope@var2508 .@expr1073747524 isExecutable (@expr1073747525 ) ) {
695:
696: for (@expr1073747526 std ::@expr5703 list < Variable > ::@expr5703 const_iterator i@var2510 =@expr1073747529 scope@var2508 .@expr5706 varlist@var2511 .@expr1073747531 begin (@expr1073747532 ) ; i@var2510 !=@expr1073747533 scope@var2508 .@expr5706 varlist@var2511 .@expr1073747535 end (@expr1073747536 ) ; ++@expr1073747537 i@var2510 ) {
697: if (@expr1073747538 i@var2510 .@expr1073747539 isThrow (@expr1073747540 ) ||@expr1073747541 i@var2510 .@expr1073747542 isExtern (@expr1073747543 ) ) {
698: continue ; }
699: Variables ::@expr1073747544 VariableType type@var2512 ; type@var2512 =@expr1073747545 Variables ::@expr5722 none ;
700: if (@expr1073747547 i@var2510 .@expr5724 isArray (@expr5725 ) &&@expr1073747550 (@expr1073747551 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5730 previous (@expr5731 ) .@expr5732 str (@expr5733 ) ==@expr5734 "*" ||@expr1073747559 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5738 strAt (@expr5739 -2 ) ==@expr5740 "*" ) ) {
701: type@var2512 =@expr1073747565 Variables ::@expr5742 pointerArray ; }
702: else { if (@expr1073747567 i@var2510 .@expr5724 isArray (@expr5725 ) &&@expr1073747570 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5730 previous (@expr5731 ) .@expr5732 str (@expr5733 ) ==@expr1073747577 "&" ) {
703: type@var2512 =@expr1073747578 Variables ::@expr1073747579 referenceArray ; }
704: else { if (@expr1073747580 i@var2510 .@expr5724 isArray (@expr5725 ) ) {
705: type@var2512 =@expr1073747583 (@expr1073747584 i@var2510 .@expr1073747585 dimensions (@expr1073747586 ) .@expr1073747587 size (@expr1073747588 ) ==@expr1073747589 1U ) ?@expr1073747590 Variables ::@expr5767 array :@expr1073747592 Variables ::@expr5742 pointerArray ; }
706: else { if (@expr1073747594 i@var2510 .@expr1073747595 isReference (@expr1073747596 ) &&@expr1073747597 !@expr1073747598 (@expr1073747599 i@var2510 .@expr5776 valueType (@expr5777 ) &&@expr1073747602 i@var2510 .@expr5776 valueType (@expr5777 ) .@expr1073747605 type@var2747 ==@expr1073747606 ValueType ::@expr1073747607 UNKNOWN_TYPE &&@expr1073747608 Token ::@expr5785 simpleMatch (@expr1073747610 i@var2510 .@expr5787 typeStartToken (@expr5788 ) , "auto" ) ) ) {
707: type@var2512 =@expr1073747613 Variables ::@expr5790 reference ; }
708: else { if (@expr1073747615 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5730 previous (@expr5731 ) .@expr5732 str (@expr5733 ) ==@expr5734 "*" &&@expr1073747623 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5738 strAt (@expr5739 -2 ) ==@expr5740 "*" ) {
709: type@var2512 =@expr1073747629 Variables ::@expr5806 pointerPointer ; }
710: else { if (@expr1073747631 i@var2510 .@expr1073747632 isPointerToArray (@expr1073747633 ) ) {
711: type@var2512 =@expr1073747634 Variables ::@expr5806 pointerPointer ; }
712: else { if (@expr1073747636 i@var2510 .@expr1073747637 isPointer (@expr1073747638 ) ) {
713: type@var2512 =@expr1073747639 Variables ::@expr5816 pointer ; }
714: else { if (@expr1073747641 mTokenizer@var28 .@expr1073747642 isC (@expr1073747643 ) ||@expr1073747644
715: i@var2510 .@expr1073747645 typeEndToken (@expr1073747646 ) .@expr1073747647 isStandardType (@expr1073747648 ) ||@expr1073747649
716: isRecordTypeWithoutSideEffects (@expr1073747650 i@var2510 .@expr1073747651 type (@expr1073747652 ) ) ||@expr1073747653
717: mSettings@var29 .@expr5830 library@var2732 .@expr1073747655 detectContainer (@expr1073747656 i@var2510 .@expr5787 typeStartToken (@expr5788 ) , false ) ||@expr1073747659
718: i@var2510 .@expr5836 isStlType (@expr5837 ) ) {
719: type@var2512 =@expr1073747662 Variables ::@expr5839 standard ; } } } } } } } }
720: if (@expr1073747664 type@var2512 ==@expr1073747665 Variables ::@expr5722 none ||@expr1073747667 isPartOfClassStructUnion (@expr1073747668 i@var2510 .@expr5787 typeStartToken (@expr5788 ) ) ) {
721: continue ; }
722: const Token * defValTok@var2513 ; defValTok@var2513 =@expr1073747671 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr1073747674 next (@expr1073747675 ) ;
723: if (@expr1073747676 Token ::@expr5853 Match (@expr1073747678 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr5730 previous (@expr5731 ) , "* %var% ) (" ) ) {
724: defValTok@var2513 =@expr1073747683 defValTok@var2513 .@expr1073747684 linkAt (@expr1073747685 1 ) .@expr1073747686 next (@expr1073747687 ) ; }
725: for (@expr1073747688 ; defValTok@var2513 ; defValTok@var2513 =@expr1073747689 defValTok@var2513 .@expr5866 next (@expr5867 ) ) {
726: if (@expr1073747692 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747695 "[" ) {
727: defValTok@var2513 =@expr1073747696 defValTok@var2513 .@expr1073747697 link (@expr1073747698 ) ; }
728: else { if (@expr1073747699 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747702 "(" ||@expr1073747703 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr5882 "{" ||@expr1073747707 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr5886 "=" ||@expr1073747711 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747714 ":" ) {
729: variables@var2509 .@expr5891 addVar (@expr1073747716 &@expr5893 *@expr5894 i@var2510 , type@var2512 , true ) ;
730: break ;
731: } else { if (@expr1073747719 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747722 ";" ||@expr1073747723 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747726 "," ||@expr1073747727 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr1073747730 ")" ) {
732: variables@var2509 .@expr5891 addVar (@expr1073747732 &@expr5893 *@expr5894 i@var2510 , type@var2512 , i@var2510 .@expr1073747735 isStatic (@expr1073747736 ) &&@expr1073747737 i@var2510 .@expr1073747738 scope (@expr1073747739 ) .@expr1073747740 type@var2748 !=@expr1073747741 Scope ::@expr5918 eFunction ) ;
733: break ;
734: } } }
735: }
736: if (@expr1073747743 i@var2510 .@expr5724 isArray (@expr5725 ) &&@expr1073747746 i@var2510 .@expr1073747747 isClass (@expr1073747748 ) &&@expr1073747749
737: !@expr1073747750 (@expr1073747751 i@var2510 .@expr5836 isStlType (@expr5837 ) &&@expr1073747754 i@var2510 .@expr5776 valueType (@expr5777 ) &&@expr1073747757 i@var2510 .@expr5776 valueType (@expr5777 ) .@expr5936 containerTypeToken@var2749 &&@expr1073747761 i@var2510 .@expr5776 valueType (@expr5777 ) .@expr5936 containerTypeToken@var2749 .@expr1073747765 isStandardType (@expr1073747766 ) ) ) {
738: variables@var2509 .@expr5943 write (@expr1073747768 i@var2510 .@expr1073747769 declarationId (@expr1073747770 ) , i@var2510 .@expr5728 nameToken (@expr5729 ) ) ; }
739: if (@expr1073747773 i@var2510 .@expr5724 isArray (@expr5725 ) &&@expr1073747776 Token ::@expr5853 Match (@expr1073747778 i@var2510 .@expr5728 nameToken (@expr5729 ) , "%name% [ %var% ]" ) ) {
740: variables@var2509 .@expr5957 read (@expr1073747782 i@var2510 .@expr5728 nameToken (@expr5729 ) .@expr1073747785 tokAt (@expr1073747786 2 ) .@expr1073747787 varId (@expr1073747788 ) , i@var2510 .@expr5728 nameToken (@expr5729 ) ) ; }
741:
742: if (@expr1073747791 defValTok@var2513 &&@expr1073747792 defValTok@var2513 .@expr5866 next (@expr5867 ) ) {
743:
744: if (@expr1073747795 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr5886 "=" &&@expr1073747799 defValTok@var2513 .@expr5866 next (@expr5867 ) .@expr1073747802 str (@expr1073747803 ) !=@expr1073747804 "{" ) {
745: doAssignment (@expr1073747805 variables@var2509 , i@var2510 .@expr5728 nameToken (@expr5729 ) , false , scope@var2508 ) ;
746: } else {
747:
748: const Token * tokBraceStart@var2514 ; tokBraceStart@var2514 =@expr1073747808 nullptr ;
749: if (@expr1073747809 Token ::@expr5785 simpleMatch (@expr1073747811 defValTok@var2513 , "= {" ) ) {
750:
751: tokBraceStart@var2514 =@expr1073747812 defValTok@var2513 .@expr5866 next (@expr5867 ) ;
752: } else { if (@expr1073747815 defValTok@var2513 .@expr5869 str (@expr5870 ) ==@expr5882 "{" ) {
753:
754: tokBraceStart@var2514 =@expr1073747819 defValTok@var2513 ;
755: } }
756: if (@expr1073747820 tokBraceStart@var2514 ) {
757: for (@expr1073747821 const Token *@expr5998 tok@var2515 =@expr1073747823 tokBraceStart@var2514 .@expr1073747824 next (@expr1073747825 ) ; tok@var2515 &&@expr1073747826 tok@var2515 !=@expr1073747827 tokBraceStart@var2514 .@expr1073747828 link (@expr1073747829 ) ; tok@var2515 =@expr1073747830 tok@var2515 .@expr1073747831 next (@expr1073747832 ) ) {
758: if (@expr1073747833 tok@var2515 .@expr6010 varId (@expr6011 ) ) {
759:
760: variables@var2509 .@expr5957 read (@expr1073747837 tok@var2515 .@expr6010 varId (@expr6011 ) , i@var2510 .@expr5728 nameToken (@expr5729 ) ) ;
761: }
762: }
763: }
764: }
765: }
766: }
767: }
768:
769:
770: const Token * tok@var2516 ;
771: if (@expr1073747842 scope@var2508 .@expr1073747843 type@var2517 ==@expr1073747844 Scope ::@expr5918 eFunction ) {
772: tok@var2516 =@expr1073747846 scope@var2508 .@expr6023 bodyStart@var2518 .@expr1073747848 next (@expr1073747849 ) ; }
773: else {
774: tok@var2516 =@expr1073747850 scope@var2508 .@expr1073747851 classDef@var2519 .@expr1073747852 next (@expr1073747853 ) ; }
775: for (@expr1073747854 ; tok@var2516 &&@expr1073747855 tok@var2516 !=@expr1073747856 scope@var2508 .@expr1073747857 bodyEnd@var2520 ; tok@var2516 =@expr1073747858 tok@var2516 .@expr6035 next (@expr6036 ) ) {
776: if (@expr1073747861 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr1073747864 "{" &&@expr1073747865 tok@var2516 !=@expr1073747866 scope@var2508 .@expr6023 bodyStart@var2518 &&@expr1073747868 !@expr1073747869 tok@var2516 .@expr6046 previous (@expr6047 ) .@expr1073747872 varId (@expr1073747873 ) ) {
777: for (@expr1073747874 const Scope *@expr5998 i@var2521 :@expr1073747876 scope@var2508 .@expr1073747877 nestedList@var2522 ) {
778: if (@expr1073747878 i@var2521 .@expr1073747879 bodyStart@var2523 ==@expr1073747880 tok@var2516 ) {
779: checkFunctionVariableUsage_iterateScopes (@expr1073747881 tok@var2516 .@expr1073747882 scope (@expr1073747883 ) , variables@var2509 ) ;
780: tok@var2516 =@expr1073747884 tok@var2516 .@expr6061 link (@expr6062 ) ;
781: break ;
782: }
783: }
784: if (@expr1073747887 !@expr1073747888 tok@var2516 ) {
785: break ; }
786: }
787:
788: if (@expr1073747889 Token ::@expr5853 Match (@expr1073747891 tok@var2516 , "asm ( %str% )" ) ) {
789: variables@var2509 .@expr6068 clear (@expr6069 ) ;
790: break ;
791: }
792:
793:
794: if (@expr1073747894 tok@var2516 .@expr1073747895 isName (@expr1073747896 ) &&@expr1073747897 endsWith (@expr1073747898 tok@var2516 .@expr6038 str (@expr6039 ) , '>' ) ) {
795:
796:
797:
798: variables@var2509 .@expr6068 clear (@expr6069 ) ;
799: }
800:
801: else { if (@expr1073747903 Token ::@expr5853 Match (@expr1073747905 tok@var2516 .@expr6046 previous (@expr6047 ) , "[;{}]" ) ) {
802: for (@expr1073747908 const Token *@expr5998 tok2@var2524 =@expr1073747910 tok@var2516 .@expr6035 next (@expr6036 ) ; tok2@var2524 ; tok2@var2524 =@expr1073747913 tok2@var2524 .@expr6090 next (@expr6091 ) ) {
803: if (@expr1073747916 tok2@var2524 .@expr1073747917 varId (@expr1073747918 ) ) {
804:
805: const Variable * var@var2525 ; var@var2525 =@expr1073747919 tok2@var2524 .@expr1073747920 variable (@expr1073747921 ) ;
806: if (@expr1073747922 !@expr1073747923 var@var2525 ||@expr1073747924 var@var2525 .@expr1073747925 nameToken (@expr1073747926 ) !=@expr1073747927 tok2@var2524 ) {
807: continue ; }
808:
809:
810: if (@expr1073747928 tok2@var2524 .@expr1073747929 strAt (@expr1073747930 -1 ) ==@expr1073747931 ">" ) {
811: for (@expr1073747932 const Token *@expr5998 tok3@var2526 =@expr1073747934 tok@var2516 ; tok3@var2526 !=@expr1073747935 tok2@var2524 ; tok3@var2526 =@expr1073747936 tok3@var2526 .@expr1073747937 next (@expr1073747938 ) ) {
812: if (@expr1073747939 tok3@var2526 .@expr6116 varId (@expr6117 ) ) {
813: variables@var2509 .@expr6118 use (@expr1073747943 tok3@var2526 .@expr6116 varId (@expr6117 ) , tok3@var2526 ) ; }
814: }
815: }
816:
817:
818: tok@var2516 =@expr1073747946 tok2@var2524 .@expr6090 next (@expr6091 ) ;
819: if (@expr1073747949 Token ::@expr5853 Match (@expr1073747951 tok@var2516 , "( %name% )" ) ) {
820: tok@var2516 =@expr1073747952 tok@var2516 .@expr6035 next (@expr6036 ) ; }
821: else { if (@expr1073747955 Token ::@expr5853 Match (@expr1073747957 tok@var2516 , "= %var% ;" ) ) {
822: tok@var2516 =@expr1073747958 tok@var2516 .@expr6035 next (@expr6036 ) ;
823: if (@expr1073747961 !@expr1073747962 var@var2525 .@expr1073747963 isReference (@expr1073747964 ) ) {
824: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ; }
825: } else { if (@expr1073747969 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr1073747972 "[" &&@expr1073747973 Token ::@expr5785 simpleMatch (@expr1073747975 skipBrackets (@expr6152 tok@var2516 ) , "= {" ) ) {
826: const Token * const rhs1@var2527 ; rhs1@var2527 =@expr1073747977 skipBrackets (@expr6152 tok@var2516 ) .@expr1073747979 next (@expr1073747980 ) ;
827: for (@expr1073747981 const Token *@expr5998 rhs@var2528 =@expr1073747983 rhs1@var2527 .@expr1073747984 link (@expr1073747985 ) ; rhs@var2528 !=@expr1073747986 rhs1@var2527 ; rhs@var2528 =@expr1073747987 rhs@var2528 .@expr1073747988 previous (@expr1073747989 ) ) {
828: if (@expr1073747990 rhs@var2528 .@expr6167 varId (@expr6168 ) ) {
829: variables@var2509 .@expr6169 readAll (@expr1073747994 rhs@var2528 .@expr6167 varId (@expr6168 ) , rhs@var2528 ) ; }
830: }
831: } else { if (@expr1073747997 var@var2525 .@expr1073747998 typeEndToken (@expr1073747999 ) .@expr1073748000 str (@expr1073748001 ) ==@expr1073748002 ">" ) {
832: tok@var2516 =@expr1073748003 tok@var2516 .@expr6046 previous (@expr6047 ) ; } } } }
833: break ;
834: } else { if (@expr1073748006 Token ::@expr5853 Match (@expr1073748008 tok2@var2524 , "[;({=]" ) ) {
835: break ; } }
836: }
837: } }
838:
839: if (@expr1073748009 Token ::@expr5853 Match (@expr1073748011 tok@var2516 , "free|g_free|kfree|vfree ( %var% )" ) ||@expr1073748012
840: (@expr1073748013 mTokenizer@var28 .@expr6190 isCPP (@expr6191 ) &&@expr1073748016 (@expr1073748017 Token ::@expr5853 Match (@expr1073748019 tok@var2516 , "delete %var% ;" ) ||@expr1073748020 Token ::@expr5853 Match (@expr1073748022 tok@var2516 , "delete [ ] %var% ;" ) ) ) ) {
841: int varid@var2529 ; varid@var2529 =@expr1073748023 0 ;
842: if (@expr1073748024 tok@var2516 .@expr6038 str (@expr6039 ) !=@expr1073748027 "delete" ) {
843: const Token * varTok@var2530 ; varTok@var2530 =@expr1073748028 tok@var2516 .@expr6205 tokAt (@expr6206 2 ) ;
844: varid@var2529 =@expr1073748031 varTok@var2530 .@expr1073748032 varId (@expr1073748033 ) ;
845: tok@var2516 =@expr1073748034 varTok@var2530 .@expr1073748035 next (@expr1073748036 ) ;
846: } else { if (@expr1073748037 tok@var2516 .@expr6214 strAt (@expr1073748039 1 ) ==@expr1073748040 "[" ) {
847: const Token * varTok@var2531 ; varTok@var2531 =@expr1073748041 tok@var2516 .@expr6205 tokAt (@expr1073748043 3 ) ;
848: varid@var2529 =@expr1073748044 varTok@var2531 .@expr1073748045 varId (@expr1073748046 ) ;
849: tok@var2516 =@expr1073748047 varTok@var2531 ;
850: } else {
851: varid@var2529 =@expr1073748048 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) ;
852: tok@var2516 =@expr1073748053 tok@var2516 .@expr6035 next (@expr6036 ) ;
853: } }
854:
855: const Variables ::@expr6232 VariableUsage * const var@var2532 ; var@var2532 =@expr1073748057 variables@var2509 .@expr6234 find (@expr1073748059 varid@var2529 ) ;
856: if (@expr1073748060 var@var2532 ) {
857: if (@expr1073748061 !@expr1073748062 var@var2532 .@expr1073748063 _aliases@var2533 .@expr1073748064 empty (@expr1073748065 ) ) {
858: variables@var2509 .@expr6118 use (@expr1073748067 varid@var2529 , tok@var2516 ) ; }
859: else { if (@expr1073748068 !@expr1073748069 var@var2532 .@expr1073748070 _allocateMemory@var2534 ) {
860: variables@var2509 .@expr6169 readAll (@expr1073748072 varid@var2529 , tok@var2516 ) ; } }
861: }
862: }
863:
864: else { if (@expr1073748073 Token ::@expr5853 Match (@expr1073748075 tok@var2516 , "return|throw" ) ) {
865: for (@expr1073748076 const Token *@expr5998 tok2@var2535 =@expr1073748078 tok@var2516 .@expr6035 next (@expr6036 ) ; tok2@var2535 ; tok2@var2535 =@expr1073748081 tok2@var2535 .@expr1073748082 next (@expr1073748083 ) ) {
866: if (@expr1073748084 tok2@var2535 .@expr6261 varId (@expr6262 ) ) {
867: variables@var2509 .@expr6169 readAll (@expr1073748088 tok2@var2535 .@expr6261 varId (@expr6262 ) , tok@var2516 ) ; }
868: else { if (@expr1073748091 tok2@var2535 .@expr1073748092 str (@expr1073748093 ) ==@expr1073748094 ";" ) {
869: break ; } }
870: }
871: }
872:
873:
874: else { if (@expr1073748095 Token ::@expr5853 Match (@expr1073748097 tok@var2516 , "*| ++|--| %name% ++|--| %assign%" ) ||@expr1073748098
875: Token ::@expr5853 Match (@expr1073748100 tok@var2516 , "*| ( const| %type% *| ) %name% %assign%" ) ) {
876: bool dereference@var2536 ; dereference@var2536 =@expr1073748101 false ;
877: bool pre@var2537 ; pre@var2537 =@expr1073748102 false ;
878: bool post@var2538 ; post@var2538 =@expr1073748103 false ;
879:
880: if (@expr6280 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr6283 "*" ) {
881: dereference@var2536 =@expr1073748108 true ;
882: tok@var2516 =@expr1073748109 tok@var2516 .@expr6035 next (@expr6036 ) ;
883: }
884:
885: if (@expr1073748112 Token ::@expr5853 Match (@expr1073748114 tok@var2516 , "( const| %type% *| ) %name% %assign%" ) ) {
886: tok@var2516 =@expr1073748115 tok@var2516 .@expr6061 link (@expr6062 ) .@expr6294 next (@expr6295 ) ; }
887:
888: else { if (@expr6296 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr6299 "(" ) {
889: tok@var2516 =@expr1073748124 tok@var2516 .@expr6035 next (@expr6036 ) ; } }
890:
891: if (@expr1073748127 tok@var2516 .@expr1073748128 tokType (@expr1073748129 ) ==@expr1073748130 Token ::@expr6307 eIncDecOp ) {
892: pre@var2537 =@expr1073748132 true ;
893: tok@var2516 =@expr1073748133 tok@var2516 .@expr6035 next (@expr6036 ) ;
894: }
895:
896: if (@expr1073748136 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6315 tokType (@expr6316 ) ==@expr6317 Token ::@expr6307 eIncDecOp ) {
897: post@var2538 =@expr1073748143 true ; }
898:
899: const int varid1@var2539 =@expr1073748144 tok@var2516 .@expr6143 varId (@expr6144 ) ;
900: const Token * const start@var2540 ; start@var2540 =@expr1073748147 tok@var2516 ;
901:
902:
903: bool inwhile@var2541 ; inwhile@var2541 =@expr1073748148 false ;
904: {
905: const Token * parent@var2542 ; parent@var2542 =@expr1073748149 tok@var2516 .@expr1073748150 astParent (@expr1073748151 ) ;
906: while (@expr1073748152 parent@var2542 ) {
907: if (@expr1073748153 Token ::@expr5785 simpleMatch (@expr1073748155 parent@var2542 .@expr1073748156 previous (@expr1073748157 ) , "while (" ) ) {
908: inwhile@var2541 =@expr1073748158 true ;
909: break ;
910: }
911: parent@var2542 =@expr1073748159 parent@var2542 .@expr1073748160 astParent (@expr1073748161 ) ;
912: }
913: }
914:
915: tok@var2516 =@expr1073748162 doAssignment (@expr1073748163 variables@var2509 , tok@var2516 , dereference@var2536 , scope@var2508 ) ;
916:
917: if (@expr1073748164 tok@var2516 &&@expr1073748165 tok@var2516 .@expr6342 isAssignmentOp (@expr6343 ) &&@expr1073748168 tok@var2516 .@expr6038 str (@expr6039 ) !=@expr1073748171 "=" ) {
918: variables@var2509 .@expr6118 use (@expr6349 varid1@var2539 , tok@var2516 ) ;
919: if (@expr1073748174 Token ::@expr5853 Match (@expr1073748176 tok@var2516 , "%assign% %name%" ) ) {
920: tok@var2516 =@expr1073748177 tok@var2516 .@expr6035 next (@expr6036 ) ;
921: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
922: }
923: }
924:
925: if (@expr1073748184 pre@var2537 ||@expr1073748185 post@var2538 ) {
926: variables@var2509 .@expr6118 use (@expr6349 varid1@var2539 , tok@var2516 ) ; }
927:
928: if (@expr1073748188 dereference@var2536 ) {
929: const Variables ::@expr6232 VariableUsage * const var@var2543 ; var@var2543 =@expr1073748190 variables@var2509 .@expr6234 find (@expr6368 varid1@var2539 ) ;
930: if (@expr1073748193 var@var2543 &&@expr1073748194 var@var2543 .@expr1073748195 mType@var2544 ==@expr1073748196 Variables ::@expr5767 array ) {
931: variables@var2509 .@expr5943 write (@expr6375 varid1@var2539 , tok@var2516 ) ; }
932: variables@var2509 .@expr6376 writeAliases (@expr6377 varid1@var2539 , tok@var2516 ) ;
933: variables@var2509 .@expr5957 read (@expr6379 varid1@var2539 , tok@var2516 ) ;
934: } else {
935: const Variables ::@expr6232 VariableUsage * const var@var2545 ; var@var2545 =@expr1073748205 variables@var2509 .@expr6234 find (@expr6368 varid1@var2539 ) ;
936: if (@expr1073748208 var@var2545 &&@expr1073748209 (@expr1073748210 inwhile@var2541 ||@expr1073748211 start@var2540 .@expr1073748212 strAt (@expr1073748213 -1 ) ==@expr1073748214 "," ) ) {
937: variables@var2509 .@expr6118 use (@expr6349 varid1@var2539 , tok@var2516 ) ;
938: } else { if (@expr1073748217 var@var2545 &&@expr1073748218 var@var2545 .@expr6395 mType@var2546 ==@expr1073748220 Variables ::@expr5790 reference ) {
939: variables@var2509 .@expr6376 writeAliases (@expr6377 varid1@var2539 , tok@var2516 ) ;
940: variables@var2509 .@expr5957 read (@expr6379 varid1@var2539 , tok@var2516 ) ;
941: }
942:
943: else { if (@expr1073748226 var@var2545 &&@expr1073748227 var@var2545 .@expr6395 mType@var2546 ==@expr1073748229 Variables ::@expr5816 pointer &&@expr1073748231
944: Token ::@expr5853 Match (@expr1073748233 start@var2540 , "%name% =" ) &&@expr1073748234
945: findAllocFuncCallToken (@expr6411 start@var2540 .@expr6412 next (@expr6413 ) .@expr6414 astOperand2 (@expr6415 ) , mSettings@var29 .@expr5830 library@var2732 ) ) {
946:
947: const Token * allocFuncCallToken@var2547 ; allocFuncCallToken@var2547 =@expr1073748241 findAllocFuncCallToken (@expr6411 start@var2540 .@expr6412 next (@expr6413 ) .@expr6414 astOperand2 (@expr6415 ) , mSettings@var29 .@expr5830 library@var2732 ) ;
948: const Library ::@expr1073748248 AllocFunc * allocFunc@var2548 ; allocFunc@var2548 =@expr1073748249 mSettings@var29 .@expr5830 library@var2732 .@expr1073748251 getAllocFuncInfo (@expr1073748252 allocFuncCallToken@var2547 ) ;
949:
950: bool allocateMemory@var2549 ; allocateMemory@var2549 =@expr1073748253 !@expr1073748254 allocFunc@var2548 ||@expr1073748255 Library ::@expr1073748256 ismemory (@expr1073748257 allocFunc@var2548 .@expr1073748258 groupId@var2550 ) ;
951:
952: if (@expr1073748259 allocFuncCallToken@var2547 .@expr1073748260 str (@expr1073748261 ) ==@expr1073748262 "new" ) {
953: const Token * type@var2551 ; type@var2551 =@expr1073748263 allocFuncCallToken@var2547 .@expr1073748264 next (@expr1073748265 ) ;
954:
955:
956: if (@expr1073748266 mTokenizer@var28 .@expr6190 isCPP (@expr6191 ) &&@expr1073748269 (@expr1073748270 Token ::@expr5785 simpleMatch (@expr1073748272 type@var2551 , "( nothrow )" ) ||@expr1073748273
957: Token ::@expr5785 simpleMatch (@expr1073748275 type@var2551 , "( std :: nothrow )" ) ) ) {
958: type@var2551 =@expr1073748276 type@var2551 .@expr1073748277 link (@expr1073748278 ) .@expr1073748279 next (@expr1073748280 ) ; }
959:
960:
961: if (@expr1073748281 !@expr1073748282 type@var2551 .@expr1073748283 isStandardType (@expr1073748284 ) ) {
962: const Variable * variable@var2552 ; variable@var2552 =@expr1073748285 start@var2540 .@expr1073748286 variable (@expr1073748287 ) ;
963: if (@expr1073748288 !@expr1073748289 variable@var2552 ||@expr1073748290 !@expr1073748291 isRecordTypeWithoutSideEffects (@expr1073748292 variable@var2552 .@expr1073748293 type (@expr1073748294 ) ) ) {
964: allocateMemory@var2549 =@expr1073748295 false ; }
965: }
966: }
967:
968: if (@expr1073748296 allocateMemory@var2549 ) {
969: variables@var2509 .@expr6473 allocateMemory (@expr1073748298 varid1@var2539 , tok@var2516 ) ; }
970: else {
971: variables@var2509 .@expr5943 write (@expr6375 varid1@var2539 , tok@var2516 ) ; }
972: } else { if (@expr1073748301 varid1@var2539 &&@expr1073748302 Token ::@expr5853 Match (@expr1073748304 tok@var2516 , "%varid% ." , varid1@var2539 ) ) {
973: variables@var2509 .@expr5957 read (@expr6379 varid1@var2539 , tok@var2516 ) ;
974: variables@var2509 .@expr5943 write (@expr1073748308 varid1@var2539 , start@var2540 ) ;
975: } else {
976: variables@var2509 .@expr5943 write (@expr6375 varid1@var2539 , tok@var2516 ) ;
977: } } } }
978: }
979:
980: const Variables ::@expr6232 VariableUsage * const var2@var2553 ; var2@var2553 =@expr1073748312 variables@var2509 .@expr6234 find (@expr1073748314 tok@var2516 .@expr6143 varId (@expr6144 ) ) ;
981: if (@expr1073748317 var2@var2553 ) {
982: if (@expr1073748318 var2@var2553 .@expr6495 mType@var2554 ==@expr1073748320 Variables ::@expr5790 reference ) {
983: variables@var2509 .@expr6376 writeAliases (@expr1073748323 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
984: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
985: } else { if (@expr1073748330 tok@var2516 .@expr6143 varId (@expr6144 ) !=@expr6509 varid1@var2539 &&@expr1073748334 Token ::@expr5853 Match (@expr1073748336 tok@var2516 , "%name% .|[" ) ) {
986: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ; }
987: else { if (@expr1073748341 tok@var2516 .@expr6143 varId (@expr6144 ) !=@expr6509 varid1@var2539 &&@expr1073748345
988: var2@var2553 .@expr6495 mType@var2554 ==@expr1073748347 Variables ::@expr5839 standard &&@expr1073748349
989: tok@var2516 .@expr6214 strAt (@expr1073748351 -1 ) !=@expr1073748352 "&" ) {
990: variables@var2509 .@expr6118 use (@expr6530 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ; } } }
991: }
992:
993: const Token * const equal@var2555 ; equal@var2555 =@expr1073748357 skipBracketsAndMembers (@expr6534 tok@var2516 .@expr6035 next (@expr6036 ) ) ;
994:
995:
996: if (@expr1073748361 tok@var2516 !=@expr1073748362 start@var2540 &&@expr1073748363 equal@var2555 &&@expr1073748364 equal@var2555 .@expr1073748365 str (@expr1073748366 ) ==@expr1073748367 "=" ) {
997: const int varId@var2556 =@expr1073748368 tok@var2516 .@expr6143 varId (@expr6144 ) ;
998: const Variables ::@expr6232 VariableUsage * const var@var2557 ; var@var2557 =@expr1073748372 variables@var2509 .@expr6234 find (@expr1073748374 varId@var2556 ) ;
999:
1000: if (@expr1073748375 var@var2557 &&@expr1073748376 var@var2557 .@expr1073748377 mType@var2558 !=@expr1073748378 Variables ::@expr5790 reference ) {
1001: variables@var2509 .@expr5957 read (@expr1073748381 varId@var2556 , tok@var2516 ) ;
1002: }
1003:
1004: tok@var2516 =@expr1073748382 tok@var2516 .@expr6046 previous (@expr6047 ) ;
1005: }
1006: }
1007:
1008:
1009: else { if (@expr1073748385 (@expr1073748386 Token ::@expr5853 Match (@expr1073748388 tok@var2516 , "%name% [" ) &&@expr1073748389 Token ::@expr5785 simpleMatch (@expr1073748391 skipBracketsAndMembers (@expr6534 tok@var2516 .@expr6035 next (@expr6036 ) ) , "=" ) ) ||@expr1073748395
1010: (@expr1073748396 Token ::@expr5785 simpleMatch (@expr1073748398 tok@var2516 , "* (" ) &&@expr1073748399 Token ::@expr5785 simpleMatch (@expr1073748401 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6580 link (@expr6581 ) , ") =" ) ) ) {
1011: const Token * eq@var2559 ; eq@var2559 =@expr1073748406 tok@var2516 ;
1012: while (@expr1073748407 eq@var2559 &&@expr1073748408 !@expr1073748409 eq@var2559 .@expr1073748410 isAssignmentOp (@expr1073748411 ) ) {
1013: eq@var2559 =@expr1073748412 eq@var2559 .@expr1073748413 astParent (@expr1073748414 ) ; }
1014:
1015: const bool deref@var2560 =@expr1073748415 eq@var2559 &&@expr1073748416 eq@var2559 .@expr6593 astOperand1 (@expr6594 ) &&@expr1073748419 eq@var2559 .@expr6593 astOperand1 (@expr6594 ) .@expr6598 valueType (@expr6599 ) &&@expr1073748424 eq@var2559 .@expr6593 astOperand1 (@expr6594 ) .@expr6598 valueType (@expr6599 ) .@expr1073748429 pointer@var2750 ==@expr1073748430 0U ;
1016:
1017: if (@expr6280 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr6283 "*" ) {
1018: tok@var2516 =@expr1073748435 tok@var2516 .@expr6205 tokAt (@expr6206 2 ) ;
1019: if (@expr6296 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr6299 "(" ) {
1020: tok@var2516 =@expr1073748442 tok@var2516 .@expr6061 link (@expr6062 ) .@expr6294 next (@expr6295 ) ; }
1021: }
1022:
1023: const int varid@var2561 =@expr1073748447 tok@var2516 .@expr6143 varId (@expr6144 ) ;
1024: const Variables ::@expr6232 VariableUsage * var@var2562 ; var@var2562 =@expr1073748451 variables@var2509 .@expr6234 find (@expr1073748453 varid@var2561 ) ;
1025:
1026: if (@expr1073748454 var@var2562 ) {
1027:
1028: if (@expr1073748455 var@var2562 .@expr6632 mType@var2563 ==@expr6633 Variables ::@expr5816 pointer &&@expr1073748459
1029: Token ::@expr5853 Match (@expr1073748461 skipBrackets (@expr1073748462 tok@var2516 .@expr6035 next (@expr6036 ) ) , "= new|malloc|calloc|kmalloc|kzalloc|kcalloc|strdup|strndup|vmalloc|g_new0|g_try_new|g_new|g_malloc|g_malloc0|g_try_malloc|g_try_malloc0|g_strdup|g_strndup|g_strdup_printf" ) ) {
1030: variables@var2509 .@expr6473 allocateMemory (@expr1073748466 varid@var2561 , tok@var2516 ) ;
1031: } else { if (@expr1073748467 var@var2562 .@expr6632 mType@var2563 ==@expr6633 Variables ::@expr5816 pointer ||@expr1073748471 var@var2562 .@expr6632 mType@var2563 ==@expr1073748473 Variables ::@expr5790 reference ) {
1032: variables@var2509 .@expr5957 read (@expr1073748476 varid@var2561 , tok@var2516 ) ;
1033: variables@var2509 .@expr6376 writeAliases (@expr1073748478 varid@var2561 , tok@var2516 ) ;
1034: } else { if (@expr1073748479 var@var2562 .@expr6632 mType@var2563 ==@expr1073748481 Variables ::@expr5742 pointerArray ) {
1035: tok@var2516 =@expr1073748483 doAssignment (@expr1073748484 variables@var2509 , tok@var2516 , deref@var2560 , scope@var2508 ) ;
1036: } else {
1037: variables@var2509 .@expr1073748485 writeAll (@expr1073748486 varid@var2561 , tok@var2516 ) ; } } }
1038: }
1039: }
1040:
1041: else { if (@expr1073748487 mTokenizer@var28 .@expr6190 isCPP (@expr6191 ) &&@expr1073748490 Token ::@expr5853 Match (@expr1073748492 tok@var2516 , "[;{}] %var% <<" ) ) {
1042: variables@var2509 .@expr1073748493 erase (@expr1073748494 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) ) ;
1043: }
1044:
1045: else { if (@expr1073748499 Token ::@expr5853 Match (@expr1073748501 tok@var2516 , "& %var%" ) ) {
1046: if (@expr6678 tok@var2516 .@expr6679 astOperand2 (@expr6680 ) ) {
1047: variables@var2509 .@expr5957 read (@expr6682 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ;
1048: } else {
1049: variables@var2509 .@expr6118 use (@expr6688 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ; }
1050: } else { if (@expr1073748517 Token ::@expr5853 Match (@expr1073748519 tok@var2516 , ">>|>>= %name%" ) ) {
1051: if (@expr1073748520 isLikelyStreamRead (@expr1073748521 mTokenizer@var28 .@expr6190 isCPP (@expr6191 ) , tok@var2516 ) ) {
1052: variables@var2509 .@expr6118 use (@expr6688 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ; }
1053: else {
1054: variables@var2509 .@expr5957 read (@expr6682 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ; }
1055: } else { if (@expr1073748536 Token ::@expr5853 Match (@expr1073748538 tok@var2516 , "%var% >>|&" ) &&@expr1073748539 Token ::@expr5853 Match (@expr1073748541 tok@var2516 .@expr6046 previous (@expr6047 ) , "[{};:]" ) ) {
1056: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1057: } else { if (@expr1073748548 isLikelyStreamRead (@expr1073748549 mTokenizer@var28 .@expr6190 isCPP (@expr6191 ) , tok@var2516 .@expr6046 previous (@expr6047 ) ) ) {
1058: variables@var2509 .@expr6118 use (@expr6530 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1059: }
1060:
1061:
1062: else { if (@expr1073748558 Token ::@expr5853 Match (@expr1073748560 tok@var2516 , "[(,] %var% [" ) ) {
1063: variables@var2509 .@expr6118 use (@expr6688 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ;
1064: } else { if (@expr1073748567 Token ::@expr5853 Match (@expr1073748569 tok@var2516 , "[(,] %var% [,)]" ) &&@expr1073748570 tok@var2516 .@expr6046 previous (@expr6047 ) .@expr1073748573 str (@expr1073748574 ) !=@expr1073748575 "*" ) {
1065: variables@var2509 .@expr6118 use (@expr6688 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ;
1066: } else { if (@expr1073748582 Token ::@expr5853 Match (@expr1073748584 tok@var2516 , "[(,] & %var% [,)]" ) ) {
1067: variables@var2509 .@expr6761 eraseAll (@expr1073748586 tok@var2516 .@expr6205 tokAt (@expr6206 2 ) .@expr1073748589 varId (@expr1073748590 ) ) ;
1068: } else { if (@expr1073748591 Token ::@expr5853 Match (@expr1073748593 tok@var2516 , "[(,] (" ) &&@expr1073748594
1069: Token ::@expr5853 Match (@expr1073748596 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6580 link (@expr6581 ) , ") %var% [,)]" ) ) {
1070: variables@var2509 .@expr6118 use (@expr1073748602 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6580 link (@expr6581 ) .@expr1073748607 next (@expr1073748608 ) .@expr1073748609 varId (@expr1073748610 ) , tok@var2516 ) ;
1071: } else { if (@expr1073748611 Token ::@expr5853 Match (@expr1073748613 tok@var2516 , "[(,] *| %var% =" ) ) {
1072: tok@var2516 =@expr1073748614 tok@var2516 .@expr6035 next (@expr6036 ) ;
1073: if (@expr6280 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr6283 "*" ) {
1074: tok@var2516 =@expr1073748621 tok@var2516 .@expr6035 next (@expr6036 ) ; }
1075: variables@var2509 .@expr6118 use (@expr6530 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1076: }
1077:
1078:
1079: else { if (@expr1073748628 Token ::@expr5853 Match (@expr1073748630 tok@var2516 , "%name% (" ) ) {
1080: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1081: useFunctionArgs (@expr1073748635 tok@var2516 .@expr6035 next (@expr6036 ) .@expr1073748638 astOperand2 (@expr1073748639 ) , variables@var2509 ) ;
1082: } else { if (@expr1073748640 Token ::@expr5853 Match (@expr1073748642 tok@var2516 , "std :: ref ( %var% )" ) ) {
1083: variables@var2509 .@expr6761 eraseAll (@expr1073748644 tok@var2516 .@expr6205 tokAt (@expr1073748646 4 ) .@expr1073748647 varId (@expr1073748648 ) ) ;
1084: }
1085:
1086: else { if (@expr1073748649 Token ::@expr5853 Match (@expr1073748651 tok@var2516 .@expr6046 previous (@expr6047 ) , "[{,] %var% [,}]" ) ) {
1087: variables@var2509 .@expr5957 read (@expr6142 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1088: }
1089:
1090: else { if (@expr1073748658 tok@var2516 .@expr6143 varId (@expr6144 ) &&@expr1073748661 Token ::@expr5853 Match (@expr1073748663 tok@var2516 , "%var% ." ) ) {
1091: variables@var2509 .@expr6118 use (@expr6530 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1092: }
1093:
1094: else { if (@expr1073748668 tok@var2516 .@expr6038 str (@expr6039 ) ==@expr1073748671 ":" &&@expr1073748672 (@expr1073748673 !@expr1073748674 tok@var2516 .@expr6851 valueType (@expr6852 ) ||@expr1073748677 tok@var2516 .@expr6851 valueType (@expr6852 ) .@expr1073748680 pointer@var2745 ) ) {
1095: if (@expr1073748681 tok@var2516 .@expr6858 astOperand1 (@expr6859 ) ) {
1096: variables@var2509 .@expr6118 use (@expr1073748685 tok@var2516 .@expr6858 astOperand1 (@expr6859 ) .@expr1073748688 varId (@expr1073748689 ) , tok@var2516 .@expr6858 astOperand1 (@expr6859 ) ) ; }
1097: if (@expr6678 tok@var2516 .@expr6679 astOperand2 (@expr6680 ) ) {
1098: variables@var2509 .@expr6118 use (@expr1073748696 tok@var2516 .@expr6679 astOperand2 (@expr6680 ) .@expr1073748699 varId (@expr1073748700 ) , tok@var2516 .@expr6679 astOperand2 (@expr6680 ) ) ; }
1099: }
1100:
1101: else { if (@expr1073748703 tok@var2516 .@expr1073748704 isExtendedOp (@expr1073748705 ) &&@expr1073748706 tok@var2516 .@expr6035 next (@expr6036 ) &&@expr1073748709 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) &&@expr1073748714 tok@var2516 .@expr6214 strAt (@expr1073748716 2 ) !=@expr1073748717 "=" &&@expr1073748718 !@expr1073748719 isVarDecl (@expr1073748720 tok@var2516 .@expr6035 next (@expr6036 ) ) ) {
1102: variables@var2509 .@expr6169 readAll (@expr1073748724 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6227 varId (@expr6228 ) , tok@var2516 ) ;
1103: }
1104:
1105: else { if (@expr1073748729 tok@var2516 .@expr6143 varId (@expr6144 ) &&@expr1073748732 !@expr1073748733 isVarDecl (@expr1073748734 tok@var2516 ) &&@expr1073748735 tok@var2516 .@expr6035 next (@expr6036 ) &&@expr1073748738 (@expr1073748739 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6918 str (@expr6919 ) ==@expr1073748744 ")" ||@expr1073748745 tok@var2516 .@expr6035 next (@expr6036 ) .@expr1073748748 isExtendedOp (@expr1073748749 ) ) ) {
1106: if (@expr1073748750 Token ::@expr5853 Match (@expr1073748752 tok@var2516 .@expr6205 tokAt (@expr6930 -2 ) , "%name% ( %var% [,)]" ) &&@expr1073748755
1107: !@expr1073748756 (@expr1073748757 tok@var2516 .@expr6205 tokAt (@expr6930 -2 ) .@expr6936 variable (@expr6937 ) &&@expr1073748762 tok@var2516 .@expr6205 tokAt (@expr6930 -2 ) .@expr6936 variable (@expr6937 ) .@expr1073748767 isReference (@expr1073748768 ) ) ) {
1108: variables@var2509 .@expr6118 use (@expr6530 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ; }
1109: else {
1110: variables@var2509 .@expr6169 readAll (@expr6950 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ; }
1111: }
1112:
1113: else { if (@expr1073748777 Token ::@expr5853 Match (@expr1073748779 tok@var2516 , "%var% ;" ) &&@expr1073748780 Token ::@expr5853 Match (@expr1073748782 tok@var2516 .@expr6046 previous (@expr6047 ) , "[;{}:]" ) ) {
1114: variables@var2509 .@expr6169 readAll (@expr6950 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1115: }
1116:
1117:
1118: else { if (@expr1073748789 tok@var2516 .@expr6035 next (@expr6036 ) &&@expr1073748792 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6315 tokType (@expr6316 ) ==@expr6317 Token ::@expr6307 eIncDecOp &&@expr1073748799 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6978 astOperand1 (@expr6979 ) &&@expr1073748804 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6978 astOperand1 (@expr6979 ) .@expr6985 varId (@expr6986 ) ) {
1119: if (@expr1073748811 tok@var2516 .@expr6035 next (@expr6036 ) .@expr1073748814 astParent (@expr1073748815 ) ) {
1120: variables@var2509 .@expr6118 use (@expr1073748817 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6978 astOperand1 (@expr6979 ) .@expr6985 varId (@expr6986 ) , tok@var2516 ) ; }
1121: else {
1122: variables@var2509 .@expr1073748824 modified (@expr1073748825 tok@var2516 .@expr6035 next (@expr6036 ) .@expr6978 astOperand1 (@expr6979 ) .@expr6985 varId (@expr6986 ) , tok@var2516 ) ; }
1123: }
1124:
1125: else { if (@expr1073748832 tok@var2516 .@expr6342 isAssignmentOp (@expr6343 ) ) {
1126: for (@expr1073748835 const Token *@expr5998 tok2@var2564 =@expr1073748837 tok@var2516 .@expr6035 next (@expr6036 ) ; tok2@var2564 &&@expr1073748840 tok2@var2564 .@expr1073748841 str (@expr1073748842 ) !=@expr1073748843 ";" ; tok2@var2564 =@expr1073748844 tok2@var2564 .@expr7021 next (@expr7022 ) ) {
1127: if (@expr1073748847 tok2@var2564 .@expr7024 varId (@expr7025 ) ) {
1128: if (@expr1073748850 tok2@var2564 .@expr1073748851 strAt (@expr1073748852 1 ) ==@expr1073748853 "=" ) {
1129: variables@var2509 .@expr5943 write (@expr1073748855 tok2@var2564 .@expr7024 varId (@expr7025 ) , tok@var2516 ) ; }
1130: else { if (@expr1073748858 tok2@var2564 .@expr7021 next (@expr7022 ) &&@expr1073748861 tok2@var2564 .@expr7021 next (@expr7022 ) .@expr1073748864 isAssignmentOp (@expr1073748865 ) ) {
1131: variables@var2509 .@expr6118 use (@expr1073748867 tok2@var2564 .@expr7024 varId (@expr7025 ) , tok@var2516 ) ; }
1132: else {
1133: variables@var2509 .@expr5957 read (@expr1073748871 tok2@var2564 .@expr7024 varId (@expr7025 ) , tok@var2516 ) ; } }
1134: }
1135: }
1136: } else { if (@expr1073748874 tok@var2516 .@expr7051 variable (@expr7052 ) &&@expr1073748877 tok@var2516 .@expr7051 variable (@expr7052 ) .@expr1073748880 isClass (@expr1073748881 ) &&@expr1073748882 tok@var2516 .@expr7051 variable (@expr7052 ) .@expr7061 type (@expr7062 ) &&@expr1073748887
1137: (@expr1073748888 tok@var2516 .@expr7051 variable (@expr7052 ) .@expr7061 type (@expr7062 ) .@expr1073748893 needInitialization@var2751 ==@expr1073748894 Type ::@expr1073748895 NeedInitialization ::@expr1073748896 False ) &&@expr1073748897
1138: tok@var2516 .@expr6035 next (@expr6036 ) .@expr6918 str (@expr6919 ) ==@expr1073748902 ";" ) {
1139: variables@var2509 .@expr5943 write (@expr1073748904 tok@var2516 .@expr6143 varId (@expr6144 ) , tok@var2516 ) ;
1140: } } } } } } } } } } } } } } } } } } } } } } } } }
1141: }
1142: }
1143:
1144: void CheckUnusedVar :: checkFunctionVariableUsage ( )
1145: {
1146: if (@expr1073748908 !@expr1073748909 mSettings@var29 .@expr7086 severity@var2733 .@expr7087 isEnabled (@expr1073748912 Severity ::@expr1073748913 style ) ) {
1147: return ; }
1148:
1149:
1150: const SymbolDatabase * symbolDatabase@var2565 ; symbolDatabase@var2565 =@expr1073748914 mTokenizer@var28 .@expr1073748915 getSymbolDatabase (@expr1073748916 ) ;
1151:
1152: auto reportLibraryCfgError@var2566 ; reportLibraryCfgError@var2566 =@expr1073748917 [@expr1073748918 this@expr1073748919 ] (@expr1073748920 const Token *@expr7097 tok@var2567 , const std ::@expr7098 string &@expr7099 typeName@var2568 ) {
1153: if (@expr1073748924 mSettings@var29 .@expr1073748925 checkLibrary@var2734 &&@expr1073748926 mSettings@var29 .@expr7086 severity@var2733 .@expr7087 isEnabled (@expr1073748929 Severity ::@expr7106 information ) ) {
1154: reportError (@expr1073748931 tok@var2567 ,
1155: Severity ::@expr7106 information ,
1156: "checkLibraryCheckType" ,
1157: "--check-library: Provide <type-checks><unusedvar> configuration for " +@expr1073748933 typeName@var2568 ) ;
1158: }
1159: } ;
1160:
1161:
1162: for (@expr1073748934 const Scope *@expr7097 scope@var2569 :@expr1073748936 symbolDatabase@var2565 .@expr1073748937 functionScopes@var2570 ) {
1163:
1164:
1165: if (@expr1073748938 scope@var2569 .@expr1073748939 hasInlineOrLambdaFunction (@expr1073748940 ) ) {
1166: continue ; }
1167:
1168: for (@expr1073748941 const Token *@expr7097 tok@var2571 =@expr1073748943 scope@var2569 .@expr1073748944 bodyStart@var2572 ; tok@var2571 !=@expr1073748945 scope@var2569 .@expr1073748946 bodyEnd@var2573 ; tok@var2571 =@expr1073748947 tok@var2571 .@expr7124 next (@expr7125 ) ) {
1169: if (@expr1073748950 findLambdaEndToken (@expr1073748951 tok@var2571 ) ) {
1170:
1171: break ; }
1172: if (@expr1073748952 Token ::@expr7129 simpleMatch (@expr1073748954 tok@var2571 , "try {" ) ) {
1173:
1174: tok@var2571 =@expr1073748955 tok@var2571 .@expr1073748956 linkAt (@expr1073748957 1 ) ; }
1175: const Token * varDecl@var2574 ; varDecl@var2574 =@expr1073748958 nullptr ;
1176: if (@expr1073748959 tok@var2571 .@expr7136 variable (@expr7137 ) &&@expr1073748962 tok@var2571 .@expr7136 variable (@expr7137 ) .@expr7141 nameToken (@expr7142 ) ==@expr7143 tok@var2571 ) {
1177: const Token * eq@var2575 ; eq@var2575 =@expr1073748968 tok@var2571 .@expr7124 next (@expr7125 ) ;
1178: while (@expr1073748971 Token ::@expr7129 simpleMatch (@expr1073748973 eq@var2575 , "[" ) ) {
1179: eq@var2575 =@expr1073748974 eq@var2575 .@expr1073748975 link (@expr1073748976 ) .@expr1073748977 next (@expr1073748978 ) ; }
1180: if (@expr1073748979 Token ::@expr7129 simpleMatch (@expr1073748981 eq@var2575 , "=" ) ) {
1181: varDecl@var2574 =@expr1073748982 tok@var2571 ;
1182: tok@var2571 =@expr1073748983 eq@var2575 ;
1183: }
1184: }
1185:
1186: const bool isAssignment@var2576 =@expr1073748984 tok@var2571 .@expr1073748985 isAssignmentOp (@expr1073748986 ) &&@expr1073748987 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ;
1187: const bool isInitialization@var2577 =@expr1073748990 Token ::@expr7167 Match (@expr1073748992 tok@var2571 , "%var% (|{" ) &&@expr1073748993 tok@var2571 .@expr7136 variable (@expr7137 ) &&@expr1073748996 tok@var2571 .@expr7136 variable (@expr7137 ) .@expr7141 nameToken (@expr7142 ) ==@expr7143 tok@var2571 ;
1188: const bool isIncrementOrDecrement@var2578 =@expr1073749002 tok@var2571 .@expr1073749003 tokType (@expr1073749004 ) ==@expr1073749005 Token ::@expr1073749006 Type ::@expr1073749007 eIncDecOp ;
1189: if (@expr1073749008 !@expr1073749009 isAssignment@var2576 &&@expr1073749010 !@expr1073749011 isInitialization@var2577 &&@expr1073749012 !@expr1073749013 isIncrementOrDecrement@var2578 ) {
1190: continue ; }
1191:
1192: if (@expr1073749014 isInitialization@var2577 &&@expr1073749015 Token ::@expr7167 Match (@expr1073749017 tok@var2571 , "%var% { }" ) ) {
1193: continue ; }
1194:
1195: if (@expr1073749018 isIncrementOrDecrement@var2578 &&@expr1073749019 tok@var2571 .@expr7196 astParent (@expr7197 ) &&@expr1073749022 precedes (@expr1073749023 tok@var2571 , tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ) ) {
1196: continue ; }
1197:
1198: if (@expr1073749026 tok@var2571 .@expr7203 str (@expr7204 ) ==@expr1073749029 "=" &&@expr1073749030 isRaiiClass (@expr7207 tok@var2571 .@expr7208 valueType (@expr7209 ) , mTokenizer@var28 .@expr7210 isCPP (@expr7211 ) , false ) ) {
1199: continue ; }
1200:
1201: const bool isPointer@var2579 =@expr1073749036 tok@var2571 .@expr7208 valueType (@expr7209 ) &&@expr1073749039 tok@var2571 .@expr7208 valueType (@expr7209 ) .@expr1073749042 pointer@var2745 ;
1202:
1203: if (@expr1073749043 tok@var2571 .@expr1073749044 isName (@expr1073749045 ) ) {
1204: if (@expr1073749046 isRaiiClass (@expr7207 tok@var2571 .@expr7208 valueType (@expr7209 ) , mTokenizer@var28 .@expr7210 isCPP (@expr7211 ) , false ) ) {
1205: continue ; }
1206: tok@var2571 =@expr1073749052 tok@var2571 .@expr7124 next (@expr7125 ) ;
1207: }
1208: if (@expr1073749055 tok@var2571 .@expr7196 astParent (@expr7197 ) &&@expr1073749058 !@expr1073749059 tok@var2571 .@expr7196 astParent (@expr7197 ) .@expr1073749062 isAssignmentOp (@expr1073749063 ) &&@expr1073749064 tok@var2571 .@expr7203 str (@expr7204 ) !=@expr1073749067 "(" ) {
1209: const Token * parent@var2580 ; parent@var2580 =@expr1073749068 tok@var2571 .@expr7196 astParent (@expr7197 ) ;
1210: while (@expr1073749071 Token ::@expr7167 Match (@expr1073749073 parent@var2580 , "%oror%|%comp%|!|&&" ) ) {
1211: parent@var2580 =@expr1073749074 parent@var2580 .@expr1073749075 astParent (@expr1073749076 ) ; }
1212: if (@expr1073749077 !@expr1073749078 parent@var2580 ) {
1213: continue ; }
1214: if (@expr1073749079 !@expr1073749080 Token ::@expr7129 simpleMatch (@expr1073749082 parent@var2580 .@expr1073749083 previous (@expr1073749084 ) , "if (" ) ) {
1215: continue ; }
1216: }
1217:
1218: if (@expr1073749085 isPointer@var2579 &&@expr1073749086 isNullOperand (@expr1073749087 tok@var2571 .@expr1073749088 astOperand2 (@expr1073749089 ) ) ) {
1219: continue ; }
1220:
1221: if (@expr1073749090 !@expr1073749091 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ) {
1222: continue ; }
1223:
1224: const Token * iteratorToken@var2581 ; iteratorToken@var2581 =@expr1073749094 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ;
1225: while (@expr1073749097 Token ::@expr7167 Match (@expr1073749099 iteratorToken@var2581 , "[.*]" ) ) {
1226: iteratorToken@var2581 =@expr1073749100 iteratorToken@var2581 .@expr1073749101 astOperand1 (@expr1073749102 ) ; }
1227: if (@expr1073749103 iteratorToken@var2581 &&@expr1073749104 iteratorToken@var2581 .@expr7281 variable (@expr7282 ) &&@expr1073749107 iteratorToken@var2581 .@expr7281 variable (@expr7282 ) .@expr1073749110 typeEndToken (@expr1073749111 ) .@expr1073749112 str (@expr1073749113 ) .@expr1073749114 find (@expr1073749115 "iterator" ) !=@expr1073749116 std ::@expr1073749117 string ::@expr1073749118 npos@expr1073748907 ) {
1228: continue ; }
1229:
1230: const Token * op1tok@var2582 ; op1tok@var2582 =@expr1073749119 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ;
1231: while (@expr1073749122 Token ::@expr7167 Match (@expr1073749124 op1tok@var2582 , ".|[|*" ) ) {
1232: op1tok@var2582 =@expr1073749125 op1tok@var2582 .@expr1073749126 astOperand1 (@expr1073749127 ) ; }
1233:
1234: const Variable * op1Var@var2583 ; op1Var@var2583 =@expr1073749128 op1tok@var2582 ?@expr1073749129 op1tok@var2582 .@expr1073749130 variable (@expr1073749131 ) :@expr1073749132 nullptr ;
1235: if (@expr1073749133 !@expr1073749134 op1Var@var2583 &&@expr1073749135 Token ::@expr7167 Match (@expr1073749137 tok@var2571 , "(|{" ) &&@expr1073749138 tok@var2571 .@expr7315 previous (@expr7316 ) &&@expr1073749141 tok@var2571 .@expr7315 previous (@expr7316 ) .@expr7320 variable (@expr7321 ) ) {
1236: op1Var@var2583 =@expr1073749146 tok@var2571 .@expr7315 previous (@expr7316 ) .@expr7320 variable (@expr7321 ) ; }
1237: std ::@expr1073749151 string bailoutTypeName@var2584 ;
1238: if (@expr1073749152 op1Var@var2583 ) {
1239: if (@expr1073749153 op1Var@var2583 .@expr1073749154 isReference (@expr1073749155 ) &&@expr1073749156 op1Var@var2583 .@expr7333 nameToken (@expr7334 ) !=@expr1073749159 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ) {
1240:
1241: continue ; }
1242:
1243: if (@expr1073749162 op1Var@var2583 .@expr1073749163 isStatic (@expr1073749164 ) ) {
1244:
1245: continue ; }
1246:
1247: if (@expr1073749165 op1Var@var2583 .@expr7333 nameToken (@expr7334 ) .@expr1073749168 isAttributeUnused (@expr1073749169 ) ) {
1248: continue ; }
1249:
1250:
1251: if (@expr1073749170 op1Var@var2583 .@expr7347 type (@expr7348 ) &&@expr1073749173 op1Var@var2583 .@expr7347 type (@expr7348 ) .@expr1073749176 isUnionType (@expr1073749177 ) ) {
1252: continue ; }
1253:
1254:
1255: if (@expr1073749178 mTokenizer@var28 .@expr7210 isCPP (@expr7211 ) &&@expr1073749181
1256: op1Var@var2583 .@expr1073749182 isClass (@expr1073749183 ) &&@expr1073749184
1257: (@expr1073749185 !@expr1073749186 op1Var@var2583 .@expr7363 valueType (@expr7364 ) ||@expr1073749189 op1Var@var2583 .@expr7363 valueType (@expr7364 ) .@expr1073749192 type@var2746 ==@expr1073749193 ValueType ::@expr7370 Type ::@expr7371 UNKNOWN_TYPE ) ) {
1258:
1259: const std ::@expr7098 string typeName@var2585 =@expr1073749197 op1Var@var2583 .@expr1073749198 getTypeName (@expr1073749199 ) ;
1260: switch (@expr1073749200 mSettings@var29 .@expr7377 library@var2732 .@expr7378 getTypeCheck (@expr1073749203 "unusedvar" , typeName@var2585 ) ) {
1261: case Library ::@expr7380 TypeCheck ::@expr7381 def :@expr7382 ;
1262: bailoutTypeName@var2584 =@expr1073749207 typeName@var2585 ;
1263: break ;
1264: case Library ::@expr7380 TypeCheck ::@expr7385 check :@expr7382 ;
1265: break ;
1266: case Library ::@expr7380 TypeCheck ::@expr7388 suppress :@expr7382 ;
1267: continue ;
1268: }
1269: }
1270: }
1271:
1272:
1273: const Token * start@var2586 ; start@var2586 =@expr1073749214 tok@var2571 .@expr1073749215 findExpressionStartEndTokens (@expr1073749216 ) .@expr1073749217 second .@expr1073749218 next (@expr1073749219 ) ;
1274:
1275: const Token * expr@var2587 ; expr@var2587 =@expr1073749220 varDecl@var2574 ?@expr1073749221 varDecl@var2574 :@expr1073749222 tok@var2571 .@expr7164 astOperand1 (@expr7165 ) ;
1276:
1277: if (@expr1073749225 isInitialization@var2577 ) {
1278: expr@var2587 =@expr1073749226 tok@var2571 .@expr7315 previous (@expr7316 ) ; }
1279:
1280:
1281: if (@expr1073749229 tok@var2571 .@expr7315 previous (@expr7316 ) &&@expr1073749232 tok@var2571 .@expr7315 previous (@expr7316 ) .@expr7320 variable (@expr7321 ) &&@expr1073749237 tok@var2571 .@expr7315 previous (@expr7316 ) .@expr7320 variable (@expr7321 ) .@expr1073749242 nameToken (@expr1073749243 ) .@expr1073749244 scope (@expr1073749245 ) .@expr1073749246 type@var2748 ==@expr1073749247 Scope ::@expr1073749248 eUnion ) {
1282: continue ; }
1283:
1284: FwdAnalysis fwdAnalysis@var2588 (@expr1073749249 mTokenizer@var28 .@expr7210 isCPP (@expr7211 ) , mSettings@var29 .@expr7377 library@var2732 ) ;
1285: const Token * scopeEnd@var2589 ; scopeEnd@var2589 =@expr1073749253 getEndOfExprScope (@expr1073749254 expr@var2587 , scope@var2569 , false ) ;
1286: if (@expr1073749255 fwdAnalysis@var2588 .@expr1073749256 unusedValue (@expr1073749257 expr@var2587 , start@var2586 , scopeEnd@var2589 ) ) {
1287: if (@expr1073749258 !@expr1073749259 bailoutTypeName@var2584 .@expr1073749260 empty (@expr1073749261 ) ) {
1288: if (@expr1073749262 bailoutTypeName@var2584 !=@expr1073749263 "auto" ) {
1289: reportLibraryCfgError@var2566 (@expr1073749264 tok@var2571 , bailoutTypeName@var2584 ) ; }
1290: continue ;
1291: }
1292:
1293:
1294: if (@expr1073749265 !@expr1073749266 expr@var2587 .@expr7443 variable (@expr7444 ) ||@expr1073749269 !@expr1073749270 expr@var2587 .@expr7443 variable (@expr7444 ) .@expr1073749273 isMaybeUnused (@expr1073749274 ) ) {
1295: unreadVariableError (@expr1073749275 tok@var2571 , expr@var2587 .@expr1073749276 expressionString (@expr1073749277 ) , false ) ; }
1296: }
1297: }
1298:
1299:
1300: Variables variables@var2590 ;
1301:
1302: checkFunctionVariableUsage_iterateScopes (@expr1073749278 scope@var2569 , variables@var2590 ) ;
1303:
1304:
1305:
1306: for (@expr1073749279 std ::@expr7098 map < int , Variables ::@expr7098 VariableUsage > ::@expr7098 const_iterator it@var2591 =@expr1073749283 variables@var2590 .@expr7460 varUsage (@expr7461 ) .@expr1073749286 begin (@expr1073749287 ) ;
1307: it@var2591 !=@expr1073749288 variables@var2590 .@expr7460 varUsage (@expr7461 ) .@expr1073749291 end (@expr1073749292 ) ;
1308: ++@expr1073749293 it@var2591 ) {
1309: const Variables ::@expr7098 VariableUsage &@expr7099 usage@var2592 =@expr1073749296 it@var2591 .@expr1073749297 second@var2593 ;
1310:
1311:
1312: if (@expr1073749298 usage@var2592 .@expr7475 _var@var2594 .@expr7476 nameToken (@expr7477 ) .@expr1073749302 isAttributeUnused (@expr1073749303 ) ||@expr1073749304 usage@var2592 .@expr7475 _var@var2594 .@expr7476 nameToken (@expr7477 ) .@expr1073749308 isAttributeUsed (@expr1073749309 ) ) {
1313: continue ; }
1314:
1315:
1316: if (@expr1073749310 usage@var2592 .@expr7487 mType@var2595 ==@expr1073749312 Variables ::@expr1073749313 pointerPointer ||@expr1073749314
1317: usage@var2592 .@expr7487 mType@var2595 ==@expr1073749316 Variables ::@expr1073749317 pointerArray ||@expr1073749318
1318: usage@var2592 .@expr7487 mType@var2595 ==@expr1073749320 Variables ::@expr1073749321 referenceArray ) {
1319: continue ; }
1320:
1321: const std ::@expr7098 string &@expr7099 varname@var2596 =@expr1073749324 usage@var2592 .@expr7475 _var@var2594 .@expr1073749326 name (@expr1073749327 ) ;
1322: const Variable * var@var2597 ; var@var2597 =@expr1073749328 symbolDatabase@var2565 .@expr1073749329 getVariableFromVarId (@expr1073749330 it@var2591 .@expr1073749331 first@var2598 ) ;
1323:
1324:
1325:
1326: if (@expr1073749332 usage@var2592 .@expr7509 unused (@expr7510 ) &&@expr7511 !@expr7512 usage@var2592 .@expr7513 _modified@var2599 &&@expr1073749338 usage@var2592 .@expr7515 _allocateMemory@var2600 ) {
1327: allocatedButUnusedVariableError (@expr1073749340 usage@var2592 .@expr7517 _lastAccess@var2601 , varname@var2596 ) ; }
1328:
1329:
1330: else { if (@expr1073749342 usage@var2592 .@expr7509 unused (@expr7510 ) &&@expr7511 !@expr7512 usage@var2592 .@expr7513 _modified@var2599 ) {
1331: if (@expr1073749348 !@expr7525 usage@var2592 .@expr7475 _var@var2594 .@expr7527 isMaybeUnused (@expr7528 ) ) {
1332: unusedVariableError (@expr1073749353 usage@var2592 .@expr7475 _var@var2594 .@expr7476 nameToken (@expr7477 ) , varname@var2596 ) ;
1333: }
1334: }
1335:
1336: else { if (@expr1073749357 usage@var2592 .@expr7513 _modified@var2599 &&@expr1073749359 !@expr7536 usage@var2592 .@expr7537 _write@var2602 &&@expr1073749362 !@expr7539 usage@var2592 .@expr7515 _allocateMemory@var2600 &&@expr1073749365 var@var2597 &&@expr1073749366 !@expr7543 var@var2597 .@expr7544 isStlType (@expr7545 ) ) {
1337: unassignedVariableError (@expr7546 usage@var2592 .@expr7475 _var@var2594 .@expr7476 nameToken (@expr7477 ) , varname@var2596 ) ; }
1338:
1339:
1340: else { if (@expr1073749374 !@expr7536 usage@var2592 .@expr7537 _write@var2602 &&@expr1073749377 !@expr7539 usage@var2592 .@expr7515 _allocateMemory@var2600 &&@expr1073749380 var@var2597 &&@expr1073749381 !@expr7543 var@var2597 .@expr7544 isStlType (@expr7545 ) &&@expr1073749385 !@expr1073749386 isEmptyType (@expr1073749387 var@var2597 .@expr1073749388 type (@expr1073749389 ) ) ) {
1341: unassignedVariableError (@expr7546 usage@var2592 .@expr7475 _var@var2594 .@expr7476 nameToken (@expr7477 ) , varname@var2596 ) ; }
1342: else { if (@expr1073749394 !@expr7525 usage@var2592 .@expr7475 _var@var2594 .@expr7527 isMaybeUnused (@expr7528 ) &&@expr1073749399 !@expr7512 usage@var2592 .@expr7513 _modified@var2599 &&@expr1073749402 !@expr1073749403 usage@var2592 .@expr1073749404 _read@var2603 &&@expr1073749405 var@var2597 ) {
1343: const Token * vnt@var2604 ; vnt@var2604 =@expr1073749406 var@var2597 .@expr1073749407 nameToken (@expr1073749408 ) ;
1344: bool error@var2605 ; error@var2605 =@expr1073749409 false ;
1345: if (@expr1073749410 vnt@var2604 .@expr1073749411 next (@expr1073749412 ) .@expr1073749413 isSplittedVarDeclEq (@expr1073749414 ) ) {
1346: const Token * nextStmt@var2606 ; nextStmt@var2606 =@expr1073749415 vnt@var2604 .@expr1073749416 tokAt (@expr1073749417 2 ) ;
1347: while (@expr1073749418 nextStmt@var2606 &&@expr1073749419 nextStmt@var2606 .@expr1073749420 str (@expr1073749421 ) !=@expr1073749422 ";" ) {
1348: nextStmt@var2606 =@expr1073749423 nextStmt@var2606 .@expr1073749424 next (@expr1073749425 ) ; }
1349: error@var2605 =@expr1073749426 precedes (@expr1073749427 usage@var2592 .@expr7517 _lastAccess@var2601 , nextStmt@var2606 ) ;
1350: }
1351: if (@expr7605 error@var2605 ) {
1352: if (@expr1073749430 mTokenizer@var28 .@expr7210 isCPP (@expr7211 ) &&@expr1073749433 var@var2597 .@expr1073749434 isClass (@expr1073749435 ) &&@expr1073749436
1353: (@expr1073749437 !@expr1073749438 var@var2597 .@expr7615 valueType (@expr7616 ) ||@expr1073749441 var@var2597 .@expr7615 valueType (@expr7616 ) .@expr1073749444 type@var2746 ==@expr1073749445 ValueType ::@expr7370 Type ::@expr7371 UNKNOWN_TYPE ) ) {
1354: const std ::@expr7098 string typeName@var2607 =@expr1073749449 var@var2597 .@expr1073749450 getTypeName (@expr1073749451 ) ;
1355: switch (@expr1073749452 mSettings@var29 .@expr7377 library@var2732 .@expr7378 getTypeCheck (@expr1073749455 "unusedvar" , typeName@var2607 ) ) {
1356: case Library ::@expr7380 TypeCheck ::@expr7381 def :@expr7382 ;
1357: reportLibraryCfgError@var2566 (@expr1073749459 vnt@var2604 , typeName@var2607 ) ;
1358: break ;
1359: case Library ::@expr7380 TypeCheck ::@expr7385 check :@expr7382 ;
1360: break ;
1361: case Library ::@expr7380 TypeCheck ::@expr7388 suppress :@expr7382 ;
1362: error@var2605 =@expr1073749466 false ;
1363: }
1364: }
1365: if (@expr7605 error@var2605 ) {
1366: unreadVariableError (@expr1073749468 vnt@var2604 , varname@var2596 , false ) ; }
1367: }
1368: } } } } }
1369: }
1370: }
1371: }
1372:
1373: void CheckUnusedVar :: unusedVariableError ( const Token * tok@var2608 , const std :: string & varname@var2609 )
1374: {
1375: reportError (@expr1073749469 tok@var2608 , Severity ::@expr1073749470 style , "unusedVariable" , "$symbol:" +@expr1073749471 varname@var2609 +@expr1073749472 "\nUnused variable: $symbol" , CWE563@var2333 , Certainty ::@expr1073749473 normal ) ;
1376: }
1377:
1378: void CheckUnusedVar :: allocatedButUnusedVariableError ( const Token * tok@var2610 , const std :: string & varname@var2611 )
1379: {
1380: reportError (@expr1073749474 tok@var2610 , Severity ::@expr1073749475 style , "unusedAllocatedMemory" , "$symbol:" +@expr1073749476 varname@var2611 +@expr1073749477 "\nVariable '$symbol' is allocated memory that is never used." , CWE563@var2333 , Certainty ::@expr1073749478 normal ) ;
1381: }
1382:
1383: void CheckUnusedVar :: unreadVariableError ( const Token * tok@var2612 , const std :: string & varname@var2613 , bool modified@var2614 )
1384: {
1385: if (@expr1073749479 modified@var2614 ) {
1386: reportError (@expr1073749480 tok@var2612 , Severity ::@expr7657 style , "unreadVariable" , "$symbol:" +@expr7658 varname@var2613 +@expr1073749483 "\nVariable '$symbol' is modified but its new value is never used." , CWE563@var2333 , Certainty ::@expr7660 normal ) ; }
1387: else {
1388: reportError (@expr1073749485 tok@var2612 , Severity ::@expr7657 style , "unreadVariable" , "$symbol:" +@expr7658 varname@var2613 +@expr1073749488 "\nVariable '$symbol' is assigned a value that is never used." , CWE563@var2333 , Certainty ::@expr7660 normal ) ; }
1389: }
1390:
1391: void CheckUnusedVar :: unassignedVariableError ( const Token * tok@var2615 , const std :: string & varname@var2616 )
1392: {
1393: reportError (@expr1073749490 tok@var2615 , Severity ::@expr1073749491 style , "unassignedVariable" , "$symbol:" +@expr1073749492 varname@var2616 +@expr1073749493 "\nVariable '$symbol' is not assigned a value." , CWE665@var2334 , Certainty ::@expr1073749494 normal ) ;
1394: }
1395:
|
1398:
1399: void CheckUnusedVar :: checkStructMemberUsage ( )
1400: {
1401: if (@expr1073749496 !@expr1073749497 mSettings@var29 .@expr1073749498 severity@var2733 .@expr1073749499 isEnabled (@expr1073749500 Severity ::@expr1073749501 style ) ) {
1402: return ; }
1403:
1404: const SymbolDatabase * symbolDatabase@var2617 ; symbolDatabase@var2617 =@expr1073749502 mTokenizer@var28 .@expr1073749503 getSymbolDatabase (@expr1073749504 ) ;
1405:
1406: for (@expr1073749505 const Scope &@expr7682 scope@var2618 :@expr1073749507 symbolDatabase@var2617 .@expr7684 scopeList@var2619 ) {
1407: if (@expr1073749509 scope@var2618 .@expr7686 type@var2620 !=@expr1073749511 Scope ::@expr1073749512 eStruct &&@expr1073749513 scope@var2618 .@expr7686 type@var2620 !=@expr1073749515 Scope ::@expr7692 eUnion ) {
1408: continue ; }
1409:
1410: if (@expr1073749517 scope@var2618 .@expr7694 bodyStart@var2621 .@expr1073749519 fileIndex (@expr1073749520 ) !=@expr1073749521 0 ||@expr1073749522 scope@var2618 .@expr7699 className@var2622 .@expr1073749524 empty (@expr1073749525 ) ) {
1411: continue ; }
1412:
1413:
1414: if (@expr1073749526 scope@var2618 .@expr7703 bodyEnd@var2623 .@expr1073749528 isAttributePacked (@expr1073749529 ) ) {
1415: continue ; }
1416: if (@expr1073749530 const Preprocessor *@expr7707 preprocessor@var2624 =@expr1073749532 mTokenizer@var28 .@expr1073749533 getPreprocessor (@expr1073749534 ) ) {
1417: bool isPacked@var2625 ; isPacked@var2625 =@expr1073749535 false ;
1418: for (@expr1073749536 const Directive &@expr7682 d@var2626 :@expr1073749538 preprocessor@var2624 .@expr1073749539 getDirectives (@expr1073749540 ) ) {
1419: if (@expr1073749541 d@var2626 .@expr1073749542 str@var2627 ==@expr1073749543 "#pragma pack(1)" &&@expr1073749544 d@var2626 .@expr1073749545 file@var2628 ==@expr1073749546 mTokenizer@var28 .@expr1073749547 list@var2735 .@expr1073749548 getFiles (@expr1073749549 ) .@expr1073749550 front (@expr1073749551 ) &&@expr1073749552 d@var2626 .@expr1073749553 linenr@var2629 <@expr1073749554 scope@var2618 .@expr7694 bodyStart@var2621 .@expr1073749556 linenr (@expr1073749557 ) ) {
1420: isPacked@var2625 =@expr1073749558 true ;
1421: break ;
1422: }
1423: }
1424: if (@expr1073749559 isPacked@var2625 ) {
1425: continue ; }
1426: }
1427:
1428:
1429: if (@expr1073749560 !@expr1073749561 scope@var2618 .@expr1073749562 functionList@var2630 .@expr1073749563 empty (@expr1073749564 ) ) {
1430: continue ; }
1431:
1432:
1433: if (@expr1073749565 scope@var2618 .@expr7699 className@var2622 .@expr1073749567 find (@expr1073749568 "<" ) !=@expr1073749569 std ::@expr1073749570 string ::@expr1073749571 npos@expr1073749495 ) {
1434: continue ; }
1435:
1436:
1437: bool bailout@var2631 ; bailout@var2631 =@expr1073749572 false ;
1438: for (@expr1073749573 const Scope &@expr7682 derivedScope@var2632 :@expr1073749575 symbolDatabase@var2617 .@expr7684 scopeList@var2619 ) {
1439: if (@expr1073749577 derivedScope@var2632 .@expr7754 definedType@var2633 ) {
1440: for (@expr1073749579 const Type ::@expr1073749580 BaseInfo &@expr7682 derivedFrom@var2634 :@expr1073749582 derivedScope@var2632 .@expr7754 definedType@var2633 .@expr1073749584 derivedFrom@var2635 ) {
1441: if (@expr1073749585 derivedFrom@var2634 .@expr1073749586 type@var2636 ==@expr1073749587 scope@var2618 .@expr1073749588 definedType@var2637 ) {
1442: bailout@var2631 =@expr1073749589 true ;
1443: break ;
1444: }
1445: }
1446: }
1447: }
1448: if (@expr7766 bailout@var2631 ) {
1449: continue ; }
1450:
1451:
1452: for (@expr1073749591 const Variable *@expr7707 var@var2638 :@expr1073749593 symbolDatabase@var2617 .@expr1073749594 variableList (@expr1073749595 ) ) {
1453: if (@expr1073749596 var@var2638 &&@expr1073749597 (@expr1073749598 var@var2638 .@expr1073749599 isExtern (@expr1073749600 ) ||@expr1073749601 (@expr1073749602 var@var2638 .@expr1073749603 isGlobal (@expr1073749604 ) &&@expr1073749605 !@expr1073749606 var@var2638 .@expr1073749607 isStatic (@expr1073749608 ) ) ) &&@expr1073749609 var@var2638 .@expr7786 typeEndToken (@expr7787 ) .@expr7788 str (@expr7789 ) ==@expr7790 scope@var2618 .@expr7699 className@var2622 ) {
1454: bailout@var2631 =@expr1073749616 true ;
1455: break ;
1456: }
1457: if (@expr1073749617 var@var2638 &&@expr1073749618 (@expr1073749619 var@var2638 .@expr1073749620 typeStartToken (@expr1073749621 ) .@expr1073749622 str (@expr1073749623 ) ==@expr1073749624 scope@var2618 .@expr7699 className@var2622 ||@expr1073749626 var@var2638 .@expr7786 typeEndToken (@expr7787 ) .@expr7788 str (@expr7789 ) ==@expr7790 scope@var2618 .@expr7699 className@var2622 ) ) {
1458: const std ::@expr1073749633 string addressPattern@var2639 (@expr1073749634 "!!" +@expr1073749635 scope@var2618 .@expr7699 className@var2622 +@expr1073749637 " & " +@expr1073749638 var@var2638 .@expr1073749639 name (@expr1073749640 ) ) ;
1459: const Token * addrTok@var2640 ; addrTok@var2640 =@expr1073749641 scope@var2618 .@expr7703 bodyEnd@var2623 ;
1460: do {
1461: addrTok@var2640 =@expr1073749643 Token ::@expr7820 findmatch (@expr1073749645 addrTok@var2640 , addressPattern@var2639 .@expr1073749646 c_str (@expr1073749647 ) ) ;
1462: if (@expr1073749648 (@expr1073749649 addrTok@var2640 &&@expr1073749650 addrTok@var2640 .@expr1073749651 str (@expr1073749652 ) ==@expr1073749653 ")" &&@expr1073749654 addrTok@var2640 .@expr1073749655 link (@expr1073749656 ) .@expr1073749657 isCast (@expr1073749658 ) ) ||@expr1073749659 isCPPCast (@expr1073749660 addrTok@var2640 ) ) {
1463: bailout@var2631 =@expr1073749661 true ;
1464: break ;
1465: }
1466: if (@expr1073749662 addrTok@var2640 ) {
1467: addrTok@var2640 =@expr1073749663 addrTok@var2640 .@expr1073749664 next (@expr1073749665 ) ; }
1468: } while (@expr1073749666 addrTok@var2640 ) ;
1469: }
1470: }
1471: if (@expr7766 bailout@var2631 ) {
1472: continue ; }
1473:
1474:
1475: const std ::@expr1073749668 string castPattern@var2641 (@expr1073749669 "( struct| " +@expr7846 scope@var2618 .@expr7699 className@var2622 +@expr1073749672 " * ) &| %name%" ) ;
1476: if (@expr1073749673 Token ::@expr7820 findmatch (@expr1073749675 scope@var2618 .@expr7703 bodyEnd@var2623 , castPattern@var2641 .@expr1073749677 c_str (@expr1073749678 ) ) ) {
1477: continue ; }
1478:
1479:
1480: const std ::@expr1073749679 string initPattern@var2642 (@expr1073749680 "( struct| " +@expr7846 scope@var2618 .@expr7699 className@var2622 +@expr1073749683 " ) {" ) ;
1481: if (@expr1073749684 Token ::@expr7820 findmatch (@expr1073749686 scope@var2618 .@expr7703 bodyEnd@var2623 , initPattern@var2642 .@expr1073749688 c_str (@expr1073749689 ) ) ) {
1482: continue ; }
1483:
1484:
1485: for (@expr1073749690 const Token *@expr7707 tok@var2643 =@expr1073749692 scope@var2618 .@expr7703 bodyEnd@var2623 ; nullptr !=@expr1073749694 (@expr1073749695 tok@var2643 =@expr1073749696 Token ::@expr1073749697 findsimplematch (@expr1073749698 tok@var2643 , "sizeof (" ) ) ; ) {
1486: tok@var2643 =@expr1073749699 tok@var2643 .@expr1073749700 tokAt (@expr1073749701 2 ) ;
1487: if (@expr1073749702 Token ::@expr1073749703 Match (@expr1073749704 tok@var2643 , (@expr1073749705 "struct| " +@expr1073749706 scope@var2618 .@expr7699 className@var2622 ) .@expr1073749708 c_str (@expr1073749709 ) ) ) {
1488: bailout@var2631 =@expr1073749710 true ;
1489: break ;
1490: }
1491: }
1492: if (@expr7766 bailout@var2631 ) {
1493: continue ; }
1494:
1495: for (@expr1073749712 const Variable &@expr7682 var@var2644 :@expr1073749714 scope@var2618 .@expr1073749715 varlist@var2645 ) {
1496:
1497: if (@expr1073749716 !@expr1073749717 var@var2644 .@expr1073749718 typeStartToken (@expr1073749719 ) .@expr1073749720 isStandardType (@expr1073749721 ) &&@expr1073749722 !@expr1073749723 var@var2644 .@expr1073749724 isPointer (@expr1073749725 ) &&@expr1073749726 !@expr1073749727 astIsContainer (@expr1073749728 var@var2644 .@expr7905 nameToken (@expr7906 ) ) &&@expr1073749731 !@expr1073749732 isRecordTypeWithoutSideEffects (@expr1073749733 var@var2644 .@expr1073749734 type (@expr1073749735 ) ) ) {
1498: continue ; }
1499:
1500:
1501: bool use@var2646 ; use@var2646 =@expr1073749736 false ;
1502: for (@expr1073749737 const Token *@expr7707 tok@var2647 =@expr1073749739 mTokenizer@var28 .@expr1073749740 tokens (@expr1073749741 ) ; tok@var2647 ; tok@var2647 =@expr1073749742 tok@var2647 .@expr1073749743 next (@expr1073749744 ) ) {
1503: if (@expr1073749745 tok@var2647 .@expr1073749746 variable (@expr1073749747 ) !=@expr1073749748 &@expr1073749749 var@var2644 ) {
1504: continue ; }
1505: if (@expr1073749750 tok@var2647 !=@expr1073749751 var@var2644 .@expr7905 nameToken (@expr7906 ) ) {
1506: use@var2646 =@expr1073749754 true ;
1507: break ;
1508: }
1509: }
1510: if (@expr1073749755 !@expr1073749756 use@var2646 ) {
1511: unusedStructMemberError (@expr1073749757 var@var2644 .@expr7905 nameToken (@expr7906 ) , scope@var2618 .@expr7699 className@var2622 , var@var2644 .@expr1073749761 name (@expr1073749762 ) , scope@var2618 .@expr7686 type@var2620 ==@expr1073749764 Scope ::@expr7692 eUnion ) ; }
1512: }
1513: }
1514: }
1515:
1516: void CheckUnusedVar :: unusedStructMemberError ( const Token * tok@var2648 , const std :: string & structname@var2649 , const std :: string & varname@var2650 , bool isUnion@var2651 )
1517: {
1518: const std ::@expr1073749766 string prefix@var2652 =@expr1073749767 isUnion@var2651 ?@expr1073749768 "union member " :@expr1073749769 "struct member " ;
1519: reportError (@expr1073749770 tok@var2648 , Severity ::@expr1073749771 style , "unusedStructMember" , "$symbol:" +@expr1073749772 structname@var2649 +@expr1073749773 "::" +@expr1073749774 varname@var2650 +@expr1073749775 '\n' +@expr1073749776 prefix@var2652 +@expr1073749777 "'$symbol' is never used." , CWE563@var2333 , Certainty ::@expr1073749778 normal ) ;
1520: }
1521:
1522: bool CheckUnusedVar :: isRecordTypeWithoutSideEffects ( const Type * type@var2653 )
1523: {
1524:
1525:
1526: const std ::@expr1073749779 pair < std ::@expr7956 map < const Type *@expr7957 , bool > ::@expr7956 iterator , bool > found@var2654 =@expr1073749783 mIsRecordTypeWithoutSideEffectsMap@var95 .@expr1073749784 insert (@expr1073749785
1527: std ::@expr1073749786 pair < const Type *@expr7957 , bool > (@expr1073749788 type@var2653 , false ) ) ;
1528: bool &@expr7965 withoutSideEffects@var2655 =@expr1073749790 found@var2654 .@expr1073749791 first@var2656 .@expr1073749792 second@var2657 ;
1529: if (@expr1073749793 !@expr1073749794 found@var2654 .@expr1073749795 second@var2658 ) {
1530: return withoutSideEffects@var2655 ; }
1531:
1532:
1533: if (@expr1073749796 !@expr1073749797 type@var2653 ||@expr1073749798 !@expr1073749799 type@var2653 .@expr7976 classScope@var2659 ) {
1534: return (@expr7977 withoutSideEffects@var2655 =@expr1073749802 false ) ; }
1535:
1536:
1537: for (@expr1073749803 const Function &@expr7965 f@var2660 :@expr1073749805 type@var2653 .@expr7976 classScope@var2659 .@expr1073749807 functionList@var2661 ) {
1538: if (@expr1073749808 !@expr1073749809 f@var2660 .@expr1073749810 isConstructor (@expr1073749811 ) ) {
1539: continue ; }
1540: if (@expr1073749812 f@var2660 .@expr7989 argDef@var2662 &&@expr1073749814 Token ::@expr7991 simpleMatch (@expr1073749816 f@var2660 .@expr7989 argDef@var2662 .@expr7994 link (@expr7995 ) , ") =" ) ) {
1541: continue ; }
1542: const bool emptyBody@var2663 =@expr1073749820 f@var2660 .@expr7997 functionScope@var2664 &&@expr1073749822 Token ::@expr7991 simpleMatch (@expr1073749824 f@var2660 .@expr7997 functionScope@var2664 .@expr1073749826 bodyStart@var2665 , "{ }" ) ;
1543:
1544: Token * nextToken@var2666 ; nextToken@var2666 =@expr1073749827 f@var2660 .@expr7989 argDef@var2662 .@expr7994 link (@expr7995 ) ;
1545: if (@expr1073749831 Token ::@expr7991 simpleMatch (@expr1073749833 nextToken@var2666 , ") :" ) ) {
1546:
1547: nextToken@var2666 =@expr1073749834 nextToken@var2666 .@expr1073749835 next (@expr1073749836 ) ;
1548:
1549: for (@expr1073749837 const Token *@expr7957 initListToken@var2667 =@expr1073749839 nextToken@var2666 ; Token ::@expr1073749840 Match (@expr1073749841 initListToken@var2667 , "[:,] %var% [({]" ) ; initListToken@var2667 =@expr1073749842 initListToken@var2667 .@expr8019 linkAt (@expr8020 2 ) .@expr1073749845 next (@expr1073749846 ) ) {
1550: const Token * varToken@var2668 ; varToken@var2668 =@expr1073749847 initListToken@var2667 .@expr1073749848 next (@expr1073749849 ) ;
1551: const Variable * variable@var2669 ; variable@var2669 =@expr1073749850 varToken@var2668 .@expr1073749851 variable (@expr1073749852 ) ;
1552: if (@expr1073749853 variable@var2669 &&@expr1073749854 !@expr1073749855 isVariableWithoutSideEffects (@expr1073749856 *@expr1073749857 variable@var2669 ) ) {
1553: return withoutSideEffects@var2655 =@expr1073749858 false ;
1554: }
1555:
1556: const Token * valueEnd@var2670 ; valueEnd@var2670 =@expr1073749859 initListToken@var2667 .@expr8019 linkAt (@expr8020 2 ) ;
1557: for (@expr1073749862 const Token *@expr7957 valueToken@var2671 =@expr1073749864 initListToken@var2667 .@expr1073749865 tokAt (@expr1073749866 3 ) ; valueToken@var2671 !=@expr1073749867 valueEnd@var2670 ; valueToken@var2671 =@expr1073749868 valueToken@var2671 .@expr1073749869 next (@expr1073749870 ) ) {
1558: const Variable * initValueVar@var2672 ; initValueVar@var2672 =@expr1073749871 valueToken@var2671 .@expr1073749872 variable (@expr1073749873 ) ;
1559: if (@expr1073749874 initValueVar@var2672 &&@expr1073749875 !@expr1073749876 isVariableWithoutSideEffects (@expr1073749877 *@expr1073749878 initValueVar@var2672 ) ) {
1560: return withoutSideEffects@var2655 =@expr1073749879 false ;
1561: }
1562: if (@expr1073749880 (@expr7977 valueToken@var2671 .@expr8058 tokType (@expr8059 ) ==@expr1073749884 Token ::@expr8061 Type ::@expr1073749886 eName ) ||@expr1073749887
1563: (@expr7977 valueToken@var2671 .@expr8058 tokType (@expr8059 ) ==@expr1073749891 Token ::@expr8061 Type ::@expr1073749893 eLambda ) ||@expr1073749894
1564: (@expr7977 valueToken@var2671 .@expr8058 tokType (@expr8059 ) ==@expr1073749898 Token ::@expr8061 Type ::@expr1073749900 eOther ) ) {
1565: return withoutSideEffects@var2655 =@expr1073749901 false ;
1566: }
1567: const Function * initValueFunc@var2673 ; initValueFunc@var2673 =@expr1073749902 valueToken@var2671 .@expr1073749903 function (@expr1073749904 ) ;
1568: if (@expr1073749905 initValueFunc@var2673 &&@expr1073749906 !@expr1073749907 isFunctionWithoutSideEffects (@expr1073749908 *@expr1073749909 initValueFunc@var2673 , valueToken@var2671 ,
1569: std ::@expr1073749910 list < const Function *@expr7957 > {@expr1073749912 } ) ) {
1570: return withoutSideEffects@var2655 =@expr1073749913 false ;
1571: }
1572: }
1573: }
1574: }
1575:
1576: if (@expr1073749914 !@expr1073749915 emptyBody@var2663 ) {
1577: return (@expr7977 withoutSideEffects@var2655 =@expr1073749917 false ) ; }
1578: }
1579:
1580:
1581: for (@expr1073749918 const Type ::@expr7956 BaseInfo &@expr7965 derivedFrom@var2674 :@expr1073749921 type@var2653 .@expr1073749922 derivedFrom@var2675 ) {
1582: if (@expr1073749923 !@expr1073749924 isRecordTypeWithoutSideEffects (@expr1073749925 derivedFrom@var2674 .@expr1073749926 type@var2676 ) ) {
1583: return (@expr7977 withoutSideEffects@var2655 =@expr1073749928 false ) ; }
1584: }
1585:
1586:
1587: for (@expr1073749929 const Variable &@expr7965 var@var2677 :@expr1073749931 type@var2653 .@expr7976 classScope@var2659 .@expr1073749933 varlist@var2678 ) {
1588: withoutSideEffects@var2655 =@expr1073749934 isVariableWithoutSideEffects (@expr1073749935 var@var2677 ) ;
1589: if (@expr1073749936 !@expr1073749937 withoutSideEffects@var2655 ) {
1590: return withoutSideEffects@var2655 ;
1591: }
1592: }
1593:
1594:
1595: return (@expr7977 withoutSideEffects@var2655 =@expr1073749939 true ) ;
1596: }
1597:
1598: bool CheckUnusedVar :: isVariableWithoutSideEffects ( const Variable & var@var2679 )
1599: {
1600: if (@expr1073749940 var@var2679 .@expr1073749941 isPointer (@expr1073749942 ) ) {
1601: return true ; }
1602:
1603: const Type * variableType@var2680 ; variableType@var2680 =@expr1073749943 var@var2679 .@expr1073749944 type (@expr1073749945 ) ;
1604: if (@expr1073749946 variableType@var2680 ) {
1605: if (@expr1073749947 !@expr1073749948 isRecordTypeWithoutSideEffects (@expr1073749949 variableType@var2680 ) ) {
1606: return false ; }
1607: } else {
1608: if (@expr1073749950 $(@expr1073749951 !@expr1073749952 var@var2679 .@expr8129 valueType (@expr8130 ) $) $&&@expr1073749955 $wrongData $(@expr1073749956 var@var2679 .@expr1073749957 typeStartToken (@expr1073749958 ) $, "!var.valueType()" $) ) {
1609: return false ; }
1610: ValueType ::@expr1073749959 Type valueType@var2681 ; valueType@var2681 =@expr1073749960 var@var2679 .@expr8129 valueType (@expr8130 ) .@expr1073749963 type@var2746 ;
1611: if (@expr1073749964 (@expr1073749965 valueType@var2681 ==@expr1073749966 ValueType ::@expr8143 Type ::@expr1073749968 UNKNOWN_TYPE ) ||@expr1073749969 (@expr1073749970 valueType@var2681 ==@expr1073749971 ValueType ::@expr8143 Type ::@expr1073749973 NONSTD ) ) {
1612: return false ; }
1613: }
1614:
1615: return true ;
1616: }
1617:
1618: bool CheckUnusedVar :: isEmptyType ( const Type * type@var2682 )
1619: {
1620:
1621:
1622: const std ::@expr1073749974 pair < std ::@expr8151 map < const Type *@expr8152 , bool > ::@expr8151 iterator , bool > found@var2683 =@expr1073749978 mIsEmptyTypeMap@var96 .@expr1073749979 insert (@expr1073749980
1623: std ::@expr1073749981 pair < const Type *@expr8152 , bool > (@expr1073749983 type@var2682 , false ) ) ;
1624: bool &@expr1073749984 emptyType@var2684 =@expr1073749985 found@var2683 .@expr1073749986 first@var2685 .@expr1073749987 second@var2686 ;
1625: if (@expr1073749988 !@expr1073749989 found@var2683 .@expr1073749990 second@var2687 ) {
1626: return emptyType@var2684 ; }
1627:
1628: if (@expr1073749991 type@var2682 &&@expr1073749992 type@var2682 .@expr8169 classScope@var2688 &&@expr1073749994 type@var2682 .@expr8169 classScope@var2688 .@expr1073749996 numConstructors@var2689 ==@expr1073749997 0 &&@expr1073749998
1629: (@expr1073749999 type@var2682 .@expr8169 classScope@var2688 .@expr1073750001 varlist@var2690 .@expr1073750002 empty (@expr1073750003 ) ) ) {
1630: for (@expr1073750004 std ::@expr8151 vector < Type ::@expr8151 BaseInfo > ::@expr8151 const_iterator i@var2691 =@expr1073750008 type@var2682 .@expr8185 derivedFrom@var2692 .@expr1073750010 begin (@expr1073750011 ) ; i@var2691 !=@expr1073750012 type@var2682 .@expr8185 derivedFrom@var2692 .@expr1073750014 end (@expr1073750015 ) ; ++@expr1073750016 i@var2691 ) {
1631: if (@expr1073750017 !@expr1073750018 isEmptyType (@expr1073750019 i@var2691 .@expr1073750020 type@var2693 ) ) {
1632: emptyType@var2684 =@expr1073750021 false ;
1633: return emptyType@var2684 ;
1634: }
1635: }
1636: emptyType@var2684 =@expr1073750022 true ;
1637: return emptyType@var2684 ;
1638: }
1639:
1640: emptyType@var2684 =@expr1073750023 false ;
1641: return emptyType@var2684 ;
1642: }
1643:
1644: bool CheckUnusedVar :: isFunctionWithoutSideEffects ( const Function & func@var2694 , const Token * functionUsageToken@var2695 ,
1645: std :: list < const Function * > checkedFuncs@var2696 )
1646: {
1647:
1648: if (@expr1073750024 !@expr1073750025 func@var2694 .@expr1073750026 hasBody (@expr1073750027 ) ) {
1649: return false ;
1650: }
1651:
1652: for (@expr1073750028 const Token *@expr8205 argsToken@var2697 =@expr1073750030 functionUsageToken@var2695 .@expr1073750031 next (@expr1073750032 ) ; !@expr1073750033 Token ::@expr8210 simpleMatch (@expr1073750035 argsToken@var2697 , ")" ) ; argsToken@var2697 =@expr1073750036 argsToken@var2697 .@expr1073750037 next (@expr1073750038 ) ) {
1653: const Variable * argVar@var2698 ; argVar@var2698 =@expr1073750039 argsToken@var2697 .@expr1073750040 variable (@expr1073750041 ) ;
1654: if (@expr1073750042 argVar@var2698 &&@expr1073750043 argVar@var2698 .@expr1073750044 isGlobal (@expr1073750045 ) ) {
1655: return false ;
1656: }
1657: }
1658:
1659: bool sideEffectReturnFound@var2699 ; sideEffectReturnFound@var2699 =@expr1073750046 false ;
1660: std ::@expr1073750047 set < const Variable *@expr8205 > pointersToGlobals@var2700 ;
1661: for (@expr1073750049 Token *@expr8205 bodyToken@var2701 =@expr1073750051 func@var2694 .@expr8228 functionScope@var2702 .@expr1073750053 bodyStart@var2703 .@expr1073750054 next (@expr1073750055 ) ; bodyToken@var2701 !=@expr1073750056 func@var2694 .@expr8228 functionScope@var2702 .@expr1073750058 bodyEnd@var2704 ;
1662: bodyToken@var2701 =@expr1073750059 bodyToken@var2701 .@expr8236 next (@expr8237 ) ) {
1663:
1664: const Variable * bodyVariable@var2705 ; bodyVariable@var2705 =@expr1073750062 bodyToken@var2701 .@expr1073750063 variable (@expr1073750064 ) ;
1665: if (@expr1073750065 bodyVariable@var2705 ) {
1666: if (@expr1073750066 !@expr1073750067 isVariableWithoutSideEffects (@expr1073750068 *@expr1073750069 bodyVariable@var2705 ) ) {
1667: return false ;
1668: }
1669:
1670: if (@expr1073750070 bodyVariable@var2705 .@expr1073750071 isGlobal (@expr1073750072 ) ||@expr1073750073 (@expr1073750074 pointersToGlobals@var2700 .@expr1073750075 find (@expr1073750076 bodyVariable@var2705 ) !=@expr1073750077 pointersToGlobals@var2700 .@expr1073750078 end (@expr1073750079 ) ) ) {
1671: const int depth@var2706 =@expr1073750080 20 ;
1672: if (@expr1073750081 isVariableChanged (@expr1073750082 bodyToken@var2701 , depth@var2706 , mSettings@var29 , mTokenizer@var28 .@expr1073750083 isCPP (@expr1073750084 ) ) ) {
1673: return false ;
1674: }
1675:
1676: if (@expr1073750085 Token ::@expr8210 simpleMatch (@expr1073750087 bodyToken@var2701 .@expr8264 tokAt (@expr1073750089 -1 ) , "&" ) &&@expr1073750090 Token ::@expr8210 simpleMatch (@expr1073750092 bodyToken@var2701 .@expr8264 tokAt (@expr1073750094 -2 ) , "=" ) ) {
1677: const Token * assigned_var_token@var2707 ; assigned_var_token@var2707 =@expr1073750095 bodyToken@var2701 .@expr8264 tokAt (@expr1073750097 -3 ) ;
1678: if (@expr1073750098 assigned_var_token@var2707 &&@expr1073750099 assigned_var_token@var2707 .@expr8276 variable (@expr8277 ) ) {
1679: pointersToGlobals@var2700 .@expr1073750102 insert (@expr1073750103 assigned_var_token@var2707 .@expr8276 variable (@expr8277 ) ) ;
1680: }
1681: }
1682: }
1683: }
1684:
1685:
1686: const Function * bodyFunction@var2708 ; bodyFunction@var2708 =@expr1073750106 bodyToken@var2701 .@expr1073750107 function (@expr1073750108 ) ;
1687: if (@expr1073750109 bodyFunction@var2708 ) {
1688: if (@expr1073750110 std ::@expr1073750111 find (@expr1073750112 checkedFuncs@var2696 .@expr1073750113 begin (@expr1073750114 ) , checkedFuncs@var2696 .@expr8291 end (@expr8292 ) , bodyFunction@var2708 ) !=@expr1073750117 checkedFuncs@var2696 .@expr8291 end (@expr8292 ) ) {
1689: continue ;
1690: }
1691: checkedFuncs@var2696 .@expr1073750120 push_back (@expr1073750121 bodyFunction@var2708 ) ;
1692: if (@expr1073750122 !@expr1073750123 isFunctionWithoutSideEffects (@expr1073750124 *@expr1073750125 bodyFunction@var2708 , bodyToken@var2701 , checkedFuncs@var2696 ) ) {
1693: return false ;
1694: }
1695: }
1696:
1697:
1698: if (@expr1073750126 Token ::@expr8210 simpleMatch (@expr1073750128 bodyToken@var2701 , "return" ) ) {
1699: const Token * returnValueToken@var2709 ; returnValueToken@var2709 =@expr1073750129 bodyToken@var2701 .@expr8236 next (@expr8237 ) ;
1700:
1701: if (@expr1073750132 !@expr1073750133 Token ::@expr8210 simpleMatch (@expr1073750135 returnValueToken@var2709 .@expr1073750136 next (@expr1073750137 ) , ";" ) ) {
1702: sideEffectReturnFound@var2699 =@expr1073750138 true ;
1703: continue ;
1704: }
1705:
1706: const Variable * returnVariable@var2710 ; returnVariable@var2710 =@expr1073750139 returnValueToken@var2709 .@expr1073750140 variable (@expr1073750141 ) ;
1707: if (@expr1073750142 returnValueToken@var2709 .@expr1073750143 isLiteral (@expr1073750144 ) ||@expr1073750145
1708: (@expr1073750146 returnVariable@var2710 &&@expr1073750147 isVariableWithoutSideEffects (@expr1073750148 *@expr1073750149 returnVariable@var2710 ) ) ) {
1709: continue ;
1710: }
1711: sideEffectReturnFound@var2699 =@expr1073750150 true ;
1712: }
1713:
1714:
1715: if (@expr1073750151 bodyToken@var2701 .@expr1073750152 isNameOnly (@expr1073750153 ) ) {
1716: return false ;
1717: }
1718: }
1719:
1720: return !@expr1073750154 sideEffectReturnFound@var2699 ;
1721: }

##file cppcheck-2.8/lib/settings.h

11:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2711 ; mFlags@var2711 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2711 ;
54: }
55: void clear ( ) {
56: mFlags@var2711 =@expr1073750155 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2711 =@expr1073750156 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2712 ) {
62: if (@expr1073750157 enabled@var2712 ) {
63: fill (@expr1073750158 ) ; }
64: else {
65: clear (@expr1073750159 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2713 ) const {
68: return (@expr8336 mFlags@var2711 &@expr1073750161 (@expr8336 1U <<@expr1073750163 (@expr1073750164 uint32_t ) flag@var2713 ) ) !=@expr1073750165 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2714 ) {
71: mFlags@var2711 |=@expr1073750166 (@expr1073750167 1U <<@expr1073750168 (@expr1073750169 uint32_t ) flag@var2714 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2715 ) {
74: mFlags@var2711 &=@expr1073750170 ~@expr1073750171 (@expr1073750172 1U <<@expr1073750173 (@expr1073750174 uint32_t ) flag@var2715 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2716 , bool enabled@var2717 ) {
77: if (@expr1073750175 enabled@var2717 ) {
78: enable (@expr1073750176 flag@var2716 ) ; }
79: else {
80: disable (@expr1073750177 flag@var2716 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2718 ; mFlags@var2718 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2718 ;
54: }
55: void clear ( ) {
56: mFlags@var2718 =@expr1073750178 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2718 =@expr1073750179 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2719 ) {
62: if (@expr1073750180 enabled@var2719 ) {
63: fill (@expr1073750181 ) ; }
64: else {
65: clear (@expr1073750182 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2720 ) const {
68: return (@expr8359 mFlags@var2718 &@expr1073750184 (@expr8359 1U <<@expr1073750186 (@expr1073750187 uint32_t ) flag@var2720 ) ) !=@expr1073750188 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2721 ) {
71: mFlags@var2718 |=@expr1073750189 (@expr1073750190 1U <<@expr1073750191 (@expr1073750192 uint32_t ) flag@var2721 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2722 ) {
74: mFlags@var2718 &=@expr1073750193 ~@expr1073750194 (@expr1073750195 1U <<@expr1073750196 (@expr1073750197 uint32_t ) flag@var2722 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2723 , bool enabled@var2724 ) {
77: if (@expr1073750198 enabled@var2724 ) {
78: enable (@expr1073750199 flag@var2723 ) ; }
79: else {
80: disable (@expr1073750200 flag@var2723 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2725 ; mFlags@var2725 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2725 ;
54: }
55: void clear ( ) {
56: mFlags@var2725 =@expr1073750201 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2725 =@expr1073750202 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2726 ) {
62: if (@expr1073750203 enabled@var2726 ) {
63: fill (@expr1073750204 ) ; }
64: else {
65: clear (@expr1073750205 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2727 ) const {
68: return (@expr8382 mFlags@var2725 &@expr1073750207 (@expr8382 1U <<@expr1073750209 (@expr1073750210 uint32_t ) flag@var2727 ) ) !=@expr1073750211 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2728 ) {
71: mFlags@var2725 |=@expr1073750212 (@expr1073750213 1U <<@expr1073750214 (@expr1073750215 uint32_t ) flag@var2728 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2729 ) {
74: mFlags@var2725 &=@expr1073750216 ~@expr1073750217 (@expr1073750218 1U <<@expr1073750219 (@expr1073750220 uint32_t ) flag@var2729 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2730 , bool enabled@var2731 ) {
77: if (@expr1073750221 enabled@var2731 ) {
78: enable (@expr1073750222 flag@var2730 ) ; }
79: else {
80: disable (@expr1073750223 flag@var2730 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  severity possible 6@116
  id possible "checkLibraryCheckType"@116
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  severity possible 3@70
  id possible {"unusedStructMember"@70,"unassignedVariable"@108,"unreadVariable"@109,"unreadVariable"@110,"unusedAllocatedMemory"@111,"unusedVariable"@112}
  certainty possible 0@70
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 50
  ( always "UnusedVar"
Line 54
  ( always "UnusedVar"
Line 73
  ( always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
Line 75
  ( always {!<=-1,!>=2}
Line 76
  ( always {!<=-1,!>=2}
Line 80
  , always 0
  = always 0
  false always 0
Line 87
  nullptr always 0
Line 90
  nullptr always 0
  "varname" always "varname"
Line 91
  nullptr always 0
  "varname" always "varname"
Line 92
  nullptr always 0
  "varname" always "varname"
  false always 0
Line 93
  nullptr always 0
  "varname" always "varname"
Line 94
  nullptr always 0
  "structname" always "structname"
  "variable" always "variable"
Line 98
  "UnusedVar" always "UnusedVar"
Line 102
  "UnusedVar checks\n- unused variable\n- allocated but unused variable\n- unread variable\n- unassigned variable\n- unused struct member\n" always "UnusedVar checks\n- unused variable\n- allocated but unused variable\n- unread variable\n- unassigned variable\n- unused struct member\n"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {62@70,39@34317,34@34573}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@134,34@135}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@134,""@135,""@136,"U"@137,"U"@138,"u"@139,"u"@140,"u8"@141,"u8"@142}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@10,34@11}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@7,34@9}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@224,128@225,64@226,32@227,16@228,8@229,4@230,2@231,1@232}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@233,128@234,64@235,32@236,16@237,8@238,4@239,2@240,1@241}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@233,4294967167@234,4294967231@235,4294967263@236,4294967279@237,4294967287@238,4294967291@239,4294967293@240,4294967294@241}
  flag {!<=-1,256@233,128@234,64@235,32@236,16@237,8@238,4@239,2@240,1@241}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {-1@26,-2@28,-3@29}
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(f.argDef->link())@54,symbolic=(tok->next())@123,symbolic=(allocFuncCallToken->next())@158}
  pattern possible {")"@15,"&"@25,"="@27,"return"@34,";"@36,") ="@50,"{ }"@52,") :"@54,"try {"@118,"["@123}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@123,4@124,0@125}
  t possible {10@123,4@124,0@125}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@123,4@124,0@125}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@123,0@125}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@123,0@125}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@123}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@123}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@123}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@123}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@123}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@131}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  pattern possible "sizeof ("@94
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@133,17179869184@144,8589934592@146,34359738368@148,4294967296@150,2147483648@152,1073741824@154,536870912@156,268435456@158}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@220,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@221}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@132,17179869184@143,8589934592@145,34359738368@147,4294967296@149,2147483648@151,1073741824@153,536870912@155,268435456@157}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@132,17179869184@143,8589934592@145,34359738368@147,4294967296@149,2147483648@151,1073741824@153,536870912@155,268435456@157}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@66,4096@69,16384@72,2048@73,1024@74,65536@75,512@76,256@77,128@78}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@31,4194304@33,8388608@34,2097152@36,1048576@37,524288@38,262144@39,131072@40,65536@41}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@9,2097152@10,1048576@11,524288@12,262144@13,131072@14,65536@15,32768@16,16384@17}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@9,4292870143@10,4293918719@11,4294443007@12,4294705151@13,4294836223@14,4294901759@15,4294934527@16,4294950911@17}
  flag {!<=-1,8388608@9,2097152@10,1048576@11,524288@12,262144@13,131072@14,65536@15,32768@16,16384@17}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 53
  linenr always !<=-1
Line 77
  NoHeader always 0
  = always 0
  0 always 0
  , always 1
Line 78
  UserHeader always 1
  , always 2
Line 79
  SystemHeader always 2
Line 85
  , always 0
  = always 0
  nullptr always 0
Line 105
  , always {!<=-1,!>=2}
  throwError always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 145
  , always 0
  throwError always {!<=-1,!>=2}
  = always 0
  false always 0
Line 147
  , always {!<=-1,!>=2}
  writeLocations always {!<=-1,!>=2}
Line 163
  ( always {!<=-1,!>=2}
Line 164
  , always !<=-1
  line always !<=-1
Line 173
  ( always !<=-1
Line 195
  , always {!<=-1,!>=2}
  showerror always {!<=-1,!>=2}
Line 198
  , always !<=-1
  linenr always !<=-1
Line 199
  , always !<=-1
  linenr always !<=-1
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 46
  563U always 563
Line 47
  665U always 665
Line 50
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classScope always !0
  != always {!<=-1,!>=2}
  nullptr always 0
Line 56
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 1
  defaultReturn always {!<=-1,!>=2}
  = always 1
  true always 1
Line 58
  ! always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  false always 0
Line 61
  ! always {!<=-1,!>=2}
Line 62
  return always {!<=-1,!>=2}
  defaultReturn always {!<=-1,!>=2}
Line 64
  valueType always !0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  valueType always !0
  . always !0
Line 65
  return always {!<=-1,!>=2}
  true always 1
Line 67
  valueType always !0
Line 68
  :: always 0
  UNKNOWN_TYPE always 0
Line 69
  :: always 2
  NONSTD always 2
Line 70
  return always {!<=-1,!>=2}
  defaultReturn always {!<=-1,!>=2}
Line 72
  :: always 3
  RECORD always 3
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  true always 1
Line 75
  return always {!<=-1,!>=2}
  defaultReturn always {!<=-1,!>=2}
Line 77
  :: always 1
  POD always 1
Line 78
  :: always 4
  SMART_POINTER always 4
Line 79
  :: always 5
  CONTAINER always 5
Line 80
  :: always 6
  ITERATOR always 6
Line 81
  :: always 7
  VOID always 7
Line 82
  :: always 8
  BOOL always 8
Line 83
  :: always 9
  CHAR always 9
Line 84
  :: always 10
  SHORT always 10
Line 85
  :: always 11
  WCHAR_T always 11
Line 86
  :: always 12
  INT always 12
Line 87
  :: always 13
  LONG always 13
Line 88
  :: always 14
  LONGLONG always 14
Line 89
  :: always 15
  UNKNOWN_INT always 15
Line 90
  :: always 16
  FLOAT always 16
Line 91
  :: always 17
  DOUBLE always 17
Line 92
  :: always 18
  LONGDOUBLE always 18
Line 93
  return always {!<=-1,!>=2}
  false always 0
Line 96
  return always {!<=-1,!>=2}
  defaultReturn always {!<=-1,!>=2}
Line 104
  standard always 0
  array always 1
  pointer always 2
  reference always 3
  pointerArray always 4
  referenceArray always 5
  pointerPointer always 6
  none always 7
Line 109
  = always 0
  nullptr always 0
Line 110
  = always 0
  standard always 0
Line 111
  read always {!<=-1,!>=2}
  = always 0
  false always 0
Line 112
  write always {!<=-1,!>=2}
  = always 0
  false always 0
Line 113
  modified always {!<=-1,!>=2}
  = always 0
  false always 0
Line 114
  allocateMemory always {!<=-1,!>=2}
  = always 0
  false always 0
Line 115
  ( inconclusive lifetime[SubObject]=(var)
Line 116
  ? possible 0
  : always 0
  nullptr always 0
Line 118
  _read always {!<=-1,!>=2}
  read always {!<=-1,!>=2}
Line 119
  _write always {!<=-1,!>=2}
  write always {!<=-1,!>=2}
Line 120
  _modified always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
Line 121
  _allocateMemory always {!<=-1,!>=2}
  allocateMemory always {!<=-1,!>=2}
Line 125
  _read always {!<=-1,!>=2}
  = always 1
  true always 1
Line 126
  _write always {!<=-1,!>=2}
  = always 1
  true always 1
Line 130
  ( always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  _write always {!<=-1,!>=2}
Line 140
  _read always {!<=-1,!>=2}
Line 141
  _write always {!<=-1,!>=2}
Line 142
  _modified always {!<=-1,!>=2}
Line 143
  _allocateMemory always {!<=-1,!>=2}
Line 165
  varid possible symbolic=(rhsVarTok->varId())@52714
Line 184
  replace always {!<=-1,!>=2}
Line 186
  varid1 possible symbolic=(varid2)
Line 187
  varid2 possible {symbolic=(varid1),symbolic=(tok->varId())@187}
Line 189
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 193
  == always {!<=-1,!>=2}
  varid2 possible symbolic=(tok->varId())@191
Line 194
  var1 always !0
Line 198
  replace always {!<=-1,!>=2}
Line 200
  = {lifetime[Iterator]=(var1->_aliases),start=0}
  var1 always !0
  ( {lifetime[Iterator]=(var1->_aliases),start=0}
  i possible {lifetime[Iterator]=(var1->_aliases),start=0}
  != always {!<=-1,!>=2}
  var1 always !0
  ( {lifetime[Iterator]=(var1->_aliases),end=0}
  i possible lifetime[Iterator]=(var1->_aliases)
Line 201
  i {lifetime[Iterator]=(var1->_aliases),!symbolic=(var1->_aliases.end()),!end=0}
Line 204
  temp always !0
  var1 always !0
Line 208
  var1 always !0
Line 212
  = {lifetime[Iterator]=(var2->_aliases),start=0}
  ( {lifetime[Iterator]=(var2->_aliases),start=0}
  i possible {lifetime[Iterator]=(var2->_aliases),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(var2->_aliases),end=0}
Line 213
  i possible lifetime[Iterator]=(var2->_aliases)
  != always {!<=-1,!>=2}
Line 214
  * always !symbolic=(varid1)
  i possible lifetime[Iterator]=(var2->_aliases)
Line 218
  . possible lifetime[Object]=(varid1)
Line 219
  . possible lifetime[Object]=(varid2)
Line 221
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
Line 222
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  = always 1
  true always 1
Line 234
  = {lifetime[Iterator]=(usage->_aliases),start=0}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),start=0}
  i possible {lifetime[Iterator]=(usage->_aliases),start=0}
  != always {!<=-1,!>=2}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),end=0}
  i possible lifetime[Iterator]=(usage->_aliases)
Line 235
  i {lifetime[Iterator]=(usage->_aliases),!symbolic=(usage->_aliases.end()),!end=0}
Line 238
  temp always !0
  usage always !0
Line 242
  usage always !0
Line 248
  varid possible symbolic=(rhsVarTok->varId())@52713
Line 251
  = {lifetime[Iterator]=(usage->_aliases),start=0}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),start=0}
  aliases possible {lifetime[Iterator]=(usage->_aliases),start=0}
  != always {!<=-1,!>=2}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),end=0}
  aliases possible lifetime[Iterator]=(usage->_aliases)
Line 252
  aliases {lifetime[Iterator]=(usage->_aliases),!symbolic=(usage->_aliases.end()),!end=0}
Line 258
  varid possible symbolic=(rhsVarTok->varId())@205
Line 259
  varid possible symbolic=(rhsVarTok->varId())@205
Line 263
  , always {!<=-1,!>=2}
Line 264
  write_ always {!<=-1,!>=2}
Line 266
  var possible {lifetime[Address]=(*i)@20,lifetime[Address]=(*i)@24}
  > always {!<=-1,!>=2}
  0 always 0
Line 267
  mVarUsage possible lifetime[Object]=(var)
  ( possible lifetime[Object]=(var)
  ( {>=1,!<=0}
  ( possible lifetime[SubObject]=(var)
  false always 0
  write_ always {!<=-1,!>=2}
  false always 0
Line 273
  varid possible symbolic=(tok->varId())@212
Line 276
  usage always !0
  . always {!<=-1,!>=2}
  _allocateMemory always {!<=-1,!>=2}
  = always 1
  true always 1
Line 277
  usage always !0
Line 283
  varid possible {symbolic=(tok->varId())@188,symbolic=(tok->varId())@185}
Line 286
  usage always !0
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  = always 1
  true always 1
Line 288
  usage always !0
  = always !0
  tok always !0
Line 294
  varid possible symbolic=(tok->varId())@188
Line 297
  usage always !0
Line 301
  aliased always !0
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  = always 1
  true always 1
Line 302
  aliased always !0
Line 310
  varid possible symbolic=(tok->varId())@190
Line 311
  varid possible symbolic=(tok->varId())@190
Line 316
  varid possible symbolic=(tok->varId())@55512
Line 319
  usage always !0
  . always {!<=-1,!>=2}
  _write always {!<=-1,!>=2}
  = always 1
  true always 1
Line 320
  ! always {!<=-1,!>=2}
  usage always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "= 0 ;" always "= 0 ;"
Line 321
  usage always !0
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  = always 0
  false always 0
Line 322
  usage always !0
Line 328
  varid possible symbolic=(tok->varId())@214
Line 331
  = {lifetime[Iterator]=(usage->_aliases),start=0}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),start=0}
  aliases possible {lifetime[Iterator]=(usage->_aliases),start=0}
  != always {!<=-1,!>=2}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),end=0}
  aliases possible lifetime[Iterator]=(usage->_aliases)
Line 332
  aliases {lifetime[Iterator]=(usage->_aliases),!symbolic=(usage->_aliases.end()),!end=0}
Line 335
  aliased always !0
  . always {!<=-1,!>=2}
  _write always {!<=-1,!>=2}
  = always 1
  true always 1
Line 336
  aliased always !0
Line 344
  varid possible symbolic=(tok->varId())@216
Line 345
  varid possible symbolic=(tok->varId())@216
Line 350
  varid possible symbolic=(rhs->varId())@199
Line 353
  usage always !0
Line 354
  usage always !0
Line 356
  = {lifetime[Iterator]=(usage->_aliases),start=0}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),start=0}
  aliases possible {lifetime[Iterator]=(usage->_aliases),start=0}
  != always {!<=-1,!>=2}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),end=0}
  aliases possible lifetime[Iterator]=(usage->_aliases)
Line 357
  aliases {lifetime[Iterator]=(usage->_aliases),!symbolic=(usage->_aliases.end()),!end=0}
Line 360
  aliased always !0
Line 361
  aliased always !0
Line 372
  ! always {!<=-1,!>=2}
  usage always !0
  ( always {!<=-1,!>=2}
Line 373
  usage always !0
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  = always 0
  false always 0
Line 374
  usage always !0
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
  = always 1
  true always 1
Line 375
  usage always !0
Line 377
  = {lifetime[Iterator]=(usage->_aliases),start=0}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),start=0}
  aliases possible {lifetime[Iterator]=(usage->_aliases),start=0}
  != always {!<=-1,!>=2}
  usage always !0
  ( {lifetime[Iterator]=(usage->_aliases),end=0}
  aliases possible lifetime[Iterator]=(usage->_aliases)
Line 378
  aliases {lifetime[Iterator]=(usage->_aliases),!symbolic=(usage->_aliases.end()),!end=0}
Line 381
  aliased always !0
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
  = always 1
  true always 1
Line 382
  aliased always !0
Line 390
  varid possible {symbolic=(varTok->varId())@110,symbolic=(varTok->varId())@110,symbolic=(tok->varId())@187,symbolic=(tok->varId())@138,symbolic=(rhs->varId())@138,symbolic=(rhsVarTok->varId())@204,symbolic=(varid2)@240,symbolic=(varid1)@241}
Line 391
  = possible lifetime[Iterator]=(mVarUsage)
  ( possible lifetime[Iterator]=(mVarUsage)
  varid {!0,symbolic=(tok->varId())@187,symbolic=(tok->varId())@138,symbolic=(rhsVarTok->varId())@204}
Line 392
  i {lifetime[Iterator]=(mVarUsage),symbolic=(mVarUsage.find(varid))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mVarUsage),end=0}
Line 393
  & {lifetime[Object]=(mVarUsage),!0}
  i {lifetime[Iterator]=(mVarUsage),symbolic=(mVarUsage.find(varid)),!symbolic=(mVarUsage.end()),!end=0}
Line 395
  nullptr always 0
Line 398
  , always {!<=-1,!>=2}
  dereference always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
  tok possible symbolic=(start)@134
  "%var% = %var% !!;" always "%var% = %var% !!;"
Line 402
  2 always 2
Line 403
  == always {!<=-1,!>=2}
Line 408
  ( always {!<=-1,!>=2}
  "%var% %assign%" always "%var% %assign%"
  && always {!<=-1,!>=2}
  1 always 1
  != always {!<=-1,!>=2}
  "=" always "="
Line 414
  tok always symbolic=(tokOld)
Line 415
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varid1 {symbolic=(tok->varId()),symbolic=(rhs->varId())}
Line 417
  var1 inconclusive lifetime[Object]=(variables)
Line 419
  tok always symbolic=(tokOld)
Line 420
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 422
  ( always !0
Line 427
  ( always {!<=-1,!>=2}
  "( const| struct|union| %type% * ) ( (" always "( const| struct|union| %type% * ) ( ("
Line 430
  ( always {!<=-1,!>=2}
  "( [(<] const| struct|union| %type% *| [>)]" always "( [(<] const| struct|union| %type% *| [>)]"
Line 433
  ( always {!<=-1,!>=2}
  "(| &| %name%" always "(| &| %name%"
  || always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
  "< const| struct|union| %type% *| > ( &| %name%" always "< const| struct|union| %type% *| > ( &| %name%"
Line 435
  addressOf {!<=-1,!>=2,0}
  addressOf always {!<=-1,!>=2}
  = always 0
  false always 0
Line 437
  ( always {!<=-1,!>=2}
  "%var% ." always "%var% ."
Line 441
  ( possible {size=1,size=3}
  == {!<=-1,!>=2,0}
  "(" always "("
Line 443
  == always {!<=-1,!>=2}
  "const" always "const"
Line 446
  ( always {!<=-1,!>=2}
  "struct|union" always "struct|union"
Line 449
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 452
  ( possible size=1
  == always {!<=-1,!>=2}
  "&" always "&"
Line 453
  addressOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 455
  == always {!<=-1,!>=2}
  "(" always "("
Line 457
  == always {!<=-1,!>=2}
  "&" always "&"
Line 458
  addressOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 461
  ( always {!<=-1,!>=2}
  "%cop% %var%" always "%cop% %var%"
Line 467
  ( possible {size=1,size=3}
  ( always !<=-1
  "cast" always "cast"
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 468
  1 always 1
  == always {!<=-1,!>=2}
  "<" always "<"
Line 469
  2 always 2
Line 470
  == always {!<=-1,!>=2}
  "const" always "const"
Line 473
  ( always {!<=-1,!>=2}
  "struct|union" always "struct|union"
Line 477
  == always {!<=-1,!>=2}
  "*" always "*"
Line 480
  2 always 2
Line 481
  ! always {!<=-1,!>=2}
Line 483
  tok always !0
  == always {!<=-1,!>=2}
  "&" always "&"
Line 484
  addressOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 485
  tok always !0
Line 490
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% ?" always "%name% ?"
Line 491
  ( possible size=3
  == {!<=-1,!>=2,0}
  "&" always "&"
Line 492
  addressOf always {!<=-1,!>=2}
  = always 1
  true always 1
Line 494
  == always {!<=-1,!>=2}
  "new" always "new"
Line 500
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varid2 always symbolic=(tok->varId())
Line 502
  var2 inconclusive lifetime[Object]=(variables)
Line 503
  var1 {lifetime[Object]=(variables),!0}
  . possible {4,3,0}
  == {!<=-1,!>=2,0}
  :: always 2
  pointer always 2
  || {!<=-1,!>=2,1,0}
  var1 {lifetime[Object]=(variables),!0}
  . {4,3,0,!2}
  == {!<=-1,!>=2,1,0}
  :: always 4
  pointerArray always 4
Line 504
  dereference always {!<=-1,!>=2}
Line 505
  varid2 always symbolic=(tok->varId())
Line 507
  addressOf always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 508
  var2 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 1
  array always 1
  || always {!<=-1,!>=2}
Line 509
  var2 {lifetime[Object]=(variables),!0}
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
Line 510
  replace always {!<=-1,!>=2}
  replace always {!<=-1,!>=2}
  = always 1
  true always 1
Line 513
  var1 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 4
  pointerArray always 4
Line 514
  replace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 517
  == always {!<=-1,!>=2}
  var1 {lifetime[Object]=(variables),!0}
Line 518
  replace always {!<=-1,!>=2}
  = always 1
  true always 1
Line 523
  var1 {lifetime[Object]=(variables),!0}
  ( possible {lifetime[Iterator]=(var1->_assignments),lifetime[Object]=(variables)}
  scope always !symbolic=(var1->_var->scope())
  == always {!<=-1,!>=2}
  var1 {lifetime[Object]=(variables),!0}
  ( {lifetime[Iterator]=(var1->_assignments),lifetime[Object]=(variables),end=0}
  || always {!<=-1,!>=2}
Line 524
  == always {!<=-1,!>=2}
  :: always 11
  eSwitch always 11
Line 527
  var1 {lifetime[Object]=(variables),!0}
  ( always {!<=-1,!>=2}
Line 528
  replace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 533
  replace always {!<=-1,!>=2}
  = always 0
  false always 0
Line 540
  replace always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  var1 {lifetime[Object]=(variables),!0}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 544
  varid2 always symbolic=(tok->varId())
  replace {!<=-1,!>=2,0,1}
Line 545
  1 always 1
  == always {!<=-1,!>=2}
  "?" always "?"
Line 546
  var2 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 3
  reference always 3
Line 547
  varid2 always symbolic=(tok->varId())
Line 549
  varid2 always symbolic=(tok->varId())
Line 551
  varid2 always symbolic=(tok->varId())
Line 554
  var1 {lifetime[Object]=(variables),!0}
  . {0,!2,!4}
  == {!<=-1,!>=2,0}
  :: always 3
  reference always 3
Line 555
  varid2 always symbolic=(tok->varId())
  true always 1
Line 556
  var1 {lifetime[Object]=(variables),!0}
  . always {!2,!4,!3}
  == always {!<=-1,!>=2}
  :: always 0
  standard always 0
  && always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
Line 557
  varid2 always symbolic=(tok->varId())
  true always 1
Line 559
  var2 {lifetime[Object]=(variables),!0}
  . possible 4
  == {!<=-1,!>=2,0}
  :: always 2
  pointer always 2
  || always {!<=-1,!>=2}
  var2 {lifetime[Object]=(variables),!0}
  . always !2
  == always {!<=-1,!>=2}
  :: always 4
  pointerArray always 4
  && always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 560
  varid2 always symbolic=(tok->varId())
Line 562
  varid2 always symbolic=(tok->varId())
Line 565
  var1 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  dereference always {!<=-1,!>=2}
Line 567
  var1 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
Line 569
  && always {!<=-1,!>=2}
  rhs always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 570
  == always {!<=-1,!>=2}
Line 571
  varid1 always symbolic=(rhs->varId())
Line 578
  var1 {lifetime[Object]=(variables),!0}
  ( possible {lifetime[Iterator]=(var1->_assignments),lifetime[Object]=(variables)}
  scope always !symbolic=(var1->_var->scope())
  == always {!<=-1,!>=2}
  var1 {lifetime[Object]=(variables),!0}
  ( {lifetime[Iterator]=(var1->_assignments),lifetime[Object]=(variables),end=0}
Line 596
  var1 {lifetime[Object]=(variables),!0}
  . possible lifetime[Object]=(scope)
Line 601
  ( always {!<=-1,!>=2}
  tok always symbolic=(tokOld)
  -2 always -2
  "%name% ." always "%name% ."
Line 602
  tok always symbolic=(tokOld)
  2 always 2
Line 603
  && always {!<=-1,!>=2}
  rhsVarTok always !0
Line 604
  = always !0
  rhsVarTok always !0
  ( always !0
Line 605
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varid2 {symbolic=(rhsVarTok->varId()),!0}
Line 608
  var2 inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var2 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 1
  array always 1
  || always {!<=-1,!>=2}
Line 609
  var2 {lifetime[Object]=(variables),!0}
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
Line 612
  varid2 {symbolic=(rhsVarTok->varId()),!0}
Line 618
  ( always {!<=-1,!>=2}
  tok always symbolic=(tokOld)
  "%name% = %name% ;" always "%name% = %name% ;"
Line 619
  tok always symbolic=(tokOld)
  2 always 2
Line 620
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
Line 621
  var2 inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var2 {lifetime[Object]=(variables),!0}
  == always {!<=-1,!>=2}
  :: always 1
  array always 1
  || always {!<=-1,!>=2}
Line 622
  var2 {lifetime[Object]=(variables),!0}
  . always !1
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
Line 623
  tok always symbolic=(tokOld)
Line 627
  tok possible symbolic=(tokOld)
Line 630
  ( always {!<=-1,!>=2}
Line 633
  ( possible size=1
  == always {!<=-1,!>=2}
  "}" always "}"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 635
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 636
  return always {!<=-1,!>=2}
  false always 0
Line 637
  == always {!<=-1,!>=2}
  "{" always "{"
Line 638
  return always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "struct" always "struct"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "class" always "class"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "class" always "class"
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "union" always "union"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "union" always "union"
Line 641
  return always {!<=-1,!>=2}
  false always 0
Line 644
  ( always {!<=-1,!>=2}
Line 646
  return always {!<=-1,!>=2}
  tok possible symbolic=(tok->variable()->nameToken())
  && always {!<=-1,!>=2}
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  == always {!<=-1,!>=2}
  tok always !0
Line 652
  tok possible symbolic=(tok2->next())@91
  && always {!<=-1,!>=2}
  tok {!0,symbolic=(tok2->next())@91}
  == always {!<=-1,!>=2}
  "[" always "["
Line 653
  tok always !0
Line 654
  tok possible {0,symbolic=(tok2->next())@91}
Line 662
  tok always !0
  == always {!<=-1,!>=2}
  "[" always "["
Line 663
  tok always !0
Line 664
  ( always {!<=-1,!>=2}
  tok always !0
  ". %name%" always ". %name%"
Line 665
  tok always !0
  2 always 2
Line 669
  tok possible 0
Line 675
  ! always {!<=-1,!>=2}
Line 677
  tok always !0
  == always {!<=-1,!>=2}
  "," always ","
Line 678
  tok always !0
Line 679
  tok always !0
Line 680
  ( always {!<=-1,!>=2}
  tok always !0
  "[+:]" always "[+:]"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
  || always {!<=-1,!>=2}
  tok always !0
  ( always !0
Line 681
  tok always !0
Line 682
  tok always !0
Line 683
  tok always !0
  && always {!<=-1,!>=2}
  tok always !0
  ( always !0
  ( always {!<=-1,!>=2}
Line 684
  tok always !0
  tok always !0
Line 694
  ( always {!<=-1,!>=2}
Line 696
  = {lifetime[Iterator]=(scope->varlist),start=0}
  ( {lifetime[Iterator]=(scope->varlist),start=0}
  i possible lifetime[Iterator]=(scope->varlist)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(scope->varlist),end=0}
Line 697
  i possible lifetime[Iterator]=(scope->varlist)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  i possible lifetime[Iterator]=(scope->varlist)
  ( always {!<=-1,!>=2}
Line 699
  = always 7
  :: always 7
  none always 7
Line 700
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "*" always "*"
Line 701
  = always 4
  :: always 4
  pointerArray always 4
Line 702
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&" always "&"
Line 703
  = always 5
  :: always 5
  referenceArray always 5
Line 704
  ( always {!<=-1,!>=2}
Line 705
  ( always !<=-1
  == always {!<=-1,!>=2}
  1U always 1
  :: always 1
  array always 1
  : always 4
  :: always 4
  pointerArray always 4
Line 706
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "auto" always "auto"
Line 707
  = always 3
  :: always 3
  reference always 3
Line 708
  == always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  -2 always -2
  == always {!<=-1,!>=2}
  "*" always "*"
Line 709
  = always 6
  :: always 6
  pointerPointer always 6
Line 710
  ( always {!<=-1,!>=2}
Line 711
  = always 6
  :: always 6
  pointerPointer always 6
Line 712
  ( always {!<=-1,!>=2}
Line 713
  = always 2
  :: always 2
  pointer always 2
Line 714
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 715
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 716
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 717
  false always 0
  || always {!<=-1,!>=2}
Line 718
  ( always {!<=-1,!>=2}
Line 719
  = always 0
  :: always 0
  standard always 0
Line 720
  type possible symbolic=((i->dimensions().size()==1U)?Variables::array:Variables::pointerArray)
  == always {!<=-1,!>=2}
  :: always 7
  none always 7
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 723
  ( always {!<=-1,!>=2}
  "* %var% ) (" always "* %var% ) ("
Line 724
  defValTok always symbolic=(i->nameToken()->next())
  1 always 1
Line 725
  defValTok possible symbolic=(i->nameToken()->next())
Line 726
  == always {!<=-1,!>=2}
  "[" always "["
Line 728
  == always {!<=-1,!>=2}
  "(" always "("
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "{" always "{"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "=" always "="
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ":" always ":"
Line 729
  & {lifetime[Address]=(*i),!0}
  true always 1
Line 731
  == always {!<=-1,!>=2}
  ";" always ";"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "," always ","
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
Line 732
  & {lifetime[Address]=(*i),!0}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 736
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 737
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 739
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% [ %var% ]" always "%name% [ %var% ]"
Line 740
  2 always 2
Line 742
  && always {!<=-1,!>=2}
Line 744
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "{" always "{"
Line 745
  false always 0
Line 748
  = always 0
  nullptr always 0
Line 749
  ( always {!<=-1,!>=2}
  "= {" always "= {"
Line 752
  == always {!<=-1,!>=2}
  "{" always "{"
Line 756
  tokBraceStart possible {symbolic=(defValTok->next()),symbolic=(defValTok)}
Line 757
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 771
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 775
  tok possible {symbolic=(scope->bodyStart->next()),symbolic=(scope->classDef->next())}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 776
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 778
  == always {!<=-1,!>=2}
Line 784
  ! always {!<=-1,!>=2}
Line 788
  ( always {!<=-1,!>=2}
  "asm ( %str% )" always "asm ( %str% )"
Line 789
  variables always NonMovedVariable
Line 794
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '>' always 62
Line 798
  variables always NonMovedVariable
Line 801
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 806
  ! always {!<=-1,!>=2}
  var always symbolic=(tok2->variable())
  || always {!<=-1,!>=2}
  var always symbolic=(tok2->variable())
  != always {!<=-1,!>=2}
Line 810
  -1 always -1
  == always {!<=-1,!>=2}
  ">" always ">"
Line 811
  != always {!<=-1,!>=2}
Line 819
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok2->next())
  "( %name% )" always "( %name% )"
Line 820
  tok always symbolic=(tok2->next())
Line 821
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok2->next())
  "= %var% ;" always "= %var% ;"
Line 822
  tok always symbolic=(tok2->next())
Line 823
  ! always {!<=-1,!>=2}
  var always symbolic=(tok2->variable())
  ( always {!<=-1,!>=2}
Line 825
  tok always symbolic=(tok2->next())
  == always {!<=-1,!>=2}
  "[" always "["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always symbolic=(tok2->next())
  "= {" always "= {"
Line 826
  tok always symbolic=(tok2->next())
Line 827
  != always {!<=-1,!>=2}
Line 831
  var always symbolic=(tok2->variable())
  == always {!<=-1,!>=2}
  ">" always ">"
Line 832
  tok always symbolic=(tok2->next())
Line 834
  ( always {!<=-1,!>=2}
  "[;({=]" always "[;({=]"
Line 839
  ( always {!<=-1,!>=2}
  "free|g_free|kfree|vfree ( %var% )" always "free|g_free|kfree|vfree ( %var% )"
  || always {!<=-1,!>=2}
Line 840
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete %var% ;" always "delete %var% ;"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "delete [ ] %var% ;" always "delete [ ] %var% ;"
Line 841
  = always 0
  0 always 0
Line 842
  != always {!<=-1,!>=2}
  "delete" always "delete"
Line 843
  2 always 2
Line 846
  1 always 1
  == always {!<=-1,!>=2}
  "[" always "["
Line 847
  3 always 3
Line 855
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varid possible {symbolic=(varTok->varId()),symbolic=(varTok->varId())}
Line 856
  var inconclusive lifetime[Object]=(variables)
Line 857
  ! always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  ( always {!<=-1,!>=2}
Line 859
  ! always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  . always {!<=-1,!>=2}
  _allocateMemory always {!<=-1,!>=2}
Line 864
  ( always {!<=-1,!>=2}
  "return|throw" always "return|throw"
Line 868
  == always {!<=-1,!>=2}
  ";" always ";"
Line 874
  ( always {!<=-1,!>=2}
  "*| ++|--| %name% ++|--| %assign%" always "*| ++|--| %name% ++|--| %assign%"
  || always {!<=-1,!>=2}
Line 875
  ( always {!<=-1,!>=2}
  "*| ( const| %type% *| ) %name% %assign%" always "*| ( const| %type% *| ) %name% %assign%"
Line 876
  dereference always {!<=-1,!>=2}
  dereference always {!<=-1,!>=2}
  = always 0
  false always 0
Line 877
  pre always {!<=-1,!>=2}
  pre always {!<=-1,!>=2}
  = always 0
  false always 0
Line 878
  post always {!<=-1,!>=2}
  post always {!<=-1,!>=2}
  = always 0
  false always 0
Line 880
  == always {!<=-1,!>=2}
  "*" always "*"
Line 881
  dereference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 885
  ( always {!<=-1,!>=2}
  "( const| %type% *| ) %name% %assign%" always "( const| %type% *| ) %name% %assign%"
Line 888
  == always {!<=-1,!>=2}
  "(" always "("
Line 891
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 892
  pre always {!<=-1,!>=2}
  = always 1
  true always 1
Line 896
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 897
  post always {!<=-1,!>=2}
  = always 1
  true always 1
Line 903
  inwhile always {!<=-1,!>=2}
  inwhile always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  tok always symbolic=(start)
Line 906
  parent possible symbolic=(tok->astParent())
Line 907
  ( always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
  "while (" always "while ("
Line 908
  inwhile always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  tok always symbolic=(start)
  dereference always {!<=-1,!>=2}
Line 917
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "=" always "="
Line 919
  ( always {!<=-1,!>=2}
  "%assign% %name%" always "%assign% %name%"
Line 925
  pre always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  post always {!<=-1,!>=2}
Line 928
  dereference always {!<=-1,!>=2}
Line 929
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
Line 930
  var inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 1
  array always 1
Line 935
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
Line 936
  var inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  inwhile always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  -1 always -1
  == always {!<=-1,!>=2}
  "," always ","
Line 938
  var inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 3
  reference always 3
Line 943
  var inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
  && always {!<=-1,!>=2}
Line 944
  ( always {!<=-1,!>=2}
  "%name% =" always "%name% ="
  && always {!<=-1,!>=2}
Line 950
  allocateMemory always {!<=-1,!>=2}
  allocateMemory always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 952
  == always {!<=-1,!>=2}
  "new" always "new"
Line 956
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  type always symbolic=(allocFuncCallToken->next())
  "( nothrow )" always "( nothrow )"
  || always {!<=-1,!>=2}
Line 957
  ( always {!<=-1,!>=2}
  type always symbolic=(allocFuncCallToken->next())
  "( std :: nothrow )" always "( std :: nothrow )"
Line 958
  type always symbolic=(allocFuncCallToken->next())
Line 961
  ! always {!<=-1,!>=2}
  type possible symbolic=(allocFuncCallToken->next())
  ( always {!<=-1,!>=2}
Line 963
  ! always {!<=-1,!>=2}
  variable always symbolic=(start->variable())
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  variable always symbolic=(start->variable())
Line 964
  allocateMemory always {!<=-1,!>=2}
  = always 0
  false always 0
Line 968
  allocateMemory always {!<=-1,!>=2}
Line 972
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%varid% ." always "%varid% ."
Line 980
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
Line 981
  var2 inconclusive lifetime[Object]=(variables)
Line 982
  var2 inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 3
  reference always 3
Line 985
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% .|[" always "%name% .|["
Line 987
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 988
  var2 inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 0
  standard always 0
  && always {!<=-1,!>=2}
Line 989
  -1 always -1
  != always {!<=-1,!>=2}
  "&" always "&"
Line 996
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "=" always "="
Line 998
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varId always symbolic=(tok->varId())
Line 1000
  var inconclusive lifetime[Object]=(variables)
  && always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  != always {!<=-1,!>=2}
  :: always 3
  reference always 3
Line 1001
  varId always symbolic=(tok->varId())
Line 1009
  ( always {!<=-1,!>=2}
  "%name% [" always "%name% ["
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "=" always "="
  || always {!<=-1,!>=2}
Line 1010
  ( always {!<=-1,!>=2}
  "* (" always "* ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") =" always ") ="
Line 1012
  eq possible symbolic=(tok)
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  eq possible symbolic=(tok)
  ( always {!<=-1,!>=2}
Line 1015
  deref always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  eq possible symbolic=(tok)
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0U always 0
Line 1017
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1018
  2 always 2
Line 1019
  == always {!<=-1,!>=2}
  "(" always "("
Line 1024
  = inconclusive lifetime[Object]=(variables)
  ( inconclusive lifetime[Object]=(variables)
  varid always symbolic=(tok->varId())
Line 1026
  var inconclusive lifetime[Object]=(variables)
Line 1028
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
  && always {!<=-1,!>=2}
Line 1029
  ( always {!<=-1,!>=2}
  "= new|malloc|calloc|kmalloc|kzalloc|kcalloc|strdup|strndup|vmalloc|g_new0|g_try_new|g_new|g_malloc|g_malloc0|g_try_malloc|g_try_malloc0|g_strdup|g_strndup|g_strdup_printf" always "= new|malloc|calloc|kmalloc|kzalloc|kcalloc|strdup|strndup|vmalloc|g_new0|g_try_new|g_new|g_malloc|g_malloc0|g_try_malloc|g_try_malloc0|g_strdup|g_strndup|g_strdup_printf"
Line 1030
  varid always symbolic=(tok->varId())
Line 1031
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 2
  pointer always 2
  || always {!<=-1,!>=2}
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 3
  reference always 3
Line 1032
  varid always symbolic=(tok->varId())
Line 1033
  varid always symbolic=(tok->varId())
Line 1034
  var inconclusive lifetime[Object]=(variables)
  == always {!<=-1,!>=2}
  :: always 4
  pointerArray always 4
Line 1035
  deref {symbolic=(eq&&eq->astOperand1()&&eq->astOperand1()->valueType()&&eq->astOperand1()->valueType()->pointer==0U),!<=-1,!>=2}
Line 1037
  varid always symbolic=(tok->varId())
Line 1041
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}] %var% <<" always "[;{}] %var% <<"
Line 1045
  ( always {!<=-1,!>=2}
  "& %var%" always "& %var%"
Line 1050
  ( always {!<=-1,!>=2}
  ">>|>>= %name%" always ">>|>>= %name%"
Line 1051
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1055
  ( always {!<=-1,!>=2}
  "%var% >>|&" always "%var% >>|&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[{};:]" always "[{};:]"
Line 1057
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1062
  ( always {!<=-1,!>=2}
  "[(,] %var% [" always "[(,] %var% ["
Line 1064
  ( always {!<=-1,!>=2}
  "[(,] %var% [,)]" always "[(,] %var% [,)]"
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "*" always "*"
Line 1066
  ( always {!<=-1,!>=2}
  "[(,] & %var% [,)]" always "[(,] & %var% [,)]"
Line 1067
  2 always 2
Line 1068
  ( always {!<=-1,!>=2}
  "[(,] (" always "[(,] ("
  && always {!<=-1,!>=2}
Line 1069
  ( always {!<=-1,!>=2}
  ") %var% [,)]" always ") %var% [,)]"
Line 1071
  ( always {!<=-1,!>=2}
  "[(,] *| %var% =" always "[(,] *| %var% ="
Line 1073
  == always {!<=-1,!>=2}
  "*" always "*"
Line 1079
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1082
  ( always {!<=-1,!>=2}
  "std :: ref ( %var% )" always "std :: ref ( %var% )"
Line 1083
  4 always 4
Line 1086
  ( always {!<=-1,!>=2}
  "[{,] %var% [,}]" always "[{,] %var% [,}]"
Line 1090
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% ." always "%var% ."
Line 1094
  == always {!<=-1,!>=2}
  ":" always ":"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1101
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  2 always 2
  != always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1105
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ")" always ")"
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1106
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ( %var% [,)]" always "%name% ( %var% [,)]"
  && always {!<=-1,!>=2}
Line 1107
  ! always {!<=-1,!>=2}
  -2 always -2
  && always {!<=-1,!>=2}
  -2 always -2
  ( always {!<=-1,!>=2}
Line 1113
  ( always {!<=-1,!>=2}
  "%var% ;" always "%var% ;"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}:]" always "[;{}:]"
Line 1118
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1125
  ( always {!<=-1,!>=2}
Line 1126
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1128
  1 always 1
  == always {!<=-1,!>=2}
  "=" always "="
Line 1130
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1136
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1137
  == always {!<=-1,!>=2}
  :: always 2
  False always 2
  && always {!<=-1,!>=2}
Line 1138
  == always {!<=-1,!>=2}
  ";" always ";"
Line 1146
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1152
  = possible lifetime[Lambda]=(this)
  [ possible lifetime[Lambda]=(this)
  this always !0
Line 1153
  . always {!<=-1,!>=2}
  checkLibrary always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 6
  information always 6
Line 1155
  :: always 6
  information always 6
Line 1156
  "checkLibraryCheckType" always "checkLibraryCheckType"
Line 1157
  "--check-library: Provide <type-checks><unusedvar> configuration for " always "--check-library: Provide <type-checks><unusedvar> configuration for "
Line 1165
  ( always {!<=-1,!>=2}
Line 1168
  != always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 1174
  1 always 1
Line 1175
  = always 0
  nullptr always 0
Line 1176
  tok possible symbolic=(tok->variable()->nameToken())
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 1177
  tok always symbolic=(tok->variable()->nameToken())
Line 1178
  ( always {!<=-1,!>=2}
  eq possible symbolic=(tok->next())
  "[" always "["
Line 1180
  ( always {!<=-1,!>=2}
  eq possible symbolic=(tok->next())
  "=" always "="
Line 1181
  = always symbolic=(tok->variable()->nameToken())
  tok always symbolic=(tok->variable()->nameToken())
Line 1186
  isAssignment always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  tok possible symbolic=(eq)
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1187
  isInitialization always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% (|{" always "%var% (|{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
Line 1188
  isIncrementOrDecrement always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 16
  eIncDecOp always 16
Line 1189
  ! always {!<=-1,!>=2}
  isAssignment {symbolic=(tok->isAssignmentOp()&&tok->astOperand1()),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isInitialization always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isIncrementOrDecrement {symbolic=(tok->tokType()==Token::Type::eIncDecOp),!<=-1,!>=2}
Line 1192
  isInitialization {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%var% { }" always "%var% { }"
Line 1195
  isIncrementOrDecrement always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1198
  == always {!<=-1,!>=2}
  "=" always "="
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 1201
  isPointer always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 1203
  ( always {!<=-1,!>=2}
Line 1204
  ( always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  false always 0
Line 1208
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  "(" always "("
Line 1209
  = always !0
  ( always !0
Line 1210
  ( always {!<=-1,!>=2}
  parent possible {symbolic=(tok->astParent()),0}
  "%oror%|%comp%|!|&&" always "%oror%|%comp%|!|&&"
Line 1212
  ! always {!<=-1,!>=2}
  parent possible symbolic=(tok->astParent())
Line 1214
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent always !0
  "if (" always "if ("
Line 1218
  isPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1221
  ! always {!<=-1,!>=2}
Line 1224
  = always !0
  ( always !0
Line 1225
  ( always {!<=-1,!>=2}
  iteratorToken possible {symbolic=(tok->astOperand1()),0}
  "[.*]" always "[.*]"
Line 1227
  iteratorToken possible symbolic=(tok->astOperand1())
  && always {!<=-1,!>=2}
  iteratorToken always !0
  && always {!<=-1,!>=2}
  iteratorToken always !0
  ( always !0
  ( always !<=-1
  "iterator" always "iterator"
  != always {!<=-1,!>=2}
Line 1230
  = always !0
  ( always !0
Line 1231
  ( always {!<=-1,!>=2}
  op1tok possible symbolic=(tok->astOperand1())
  ".|[|*" always ".|[|*"
Line 1234
  = possible 0
  op1tok possible symbolic=(tok->astOperand1())
  ? possible 0
  op1tok always !0
  : always 0
  nullptr always 0
Line 1235
  ! {!<=-1,!>=2,1}
  op1Var {symbolic=(op1tok?op1tok->variable():nullptr),0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(|{" always "(|{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
Line 1236
  = always !0
  ( always !0
  ( always !0
Line 1238
  op1Var possible {symbolic=(op1tok?op1tok->variable():nullptr),symbolic=(tok->previous()->variable())}
Line 1239
  op1Var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  op1Var always !0
  != always {!<=-1,!>=2}
  ( always !0
Line 1243
  op1Var always !0
  ( always {!<=-1,!>=2}
Line 1247
  ( always {!<=-1,!>=2}
Line 1251
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1255
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1256
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1257
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 1260
  "unusedvar" always "unusedvar"
  typeName always symbolic=(op1Var->getTypeName())
Line 1261
  :: always 0
  def always 0
Line 1264
  :: always 1
  check always 1
Line 1266
  :: always 2
  suppress always 2
Line 1275
  = possible 1
  ? possible 1
  varDecl always !0
  : always 1
  ( always !0
Line 1277
  isInitialization always {!<=-1,!>=2}
Line 1281
  ( possible symbolic=(expr)
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 1284
  ( always {!<=-1,!>=2}
Line 1285
  false always 0
Line 1286
  ( always {!<=-1,!>=2}
Line 1287
  ! {!<=-1,!>=2,0,1}
  bailoutTypeName possible {size=0,size=4}
  ( {!<=-1,!>=2,1,0}
Line 1288
  bailoutTypeName always !size=0
  != always {!<=-1,!>=2}
  "auto" always "auto"
Line 1289
  bailoutTypeName always !size=0
Line 1294
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1295
  false always 0
Line 1306
  = {lifetime[Iterator]=(variables.varUsage()),lifetime[Object]=(variables),start=0}
  ( {lifetime[Iterator]=(variables.varUsage()),lifetime[Object]=(variables),start=0}
Line 1307
  it possible {lifetime[Iterator]=(variables.varUsage()),lifetime[Object]=(variables),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variables.varUsage()),lifetime[Object]=(variables),end=0}
Line 1309
  it {lifetime[Iterator]=(variables.varUsage()),lifetime[Object]=(variables),!symbolic=(variables.varUsage().end()),!end=0}
Line 1312
  usage always symbolic=(it->second)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  usage always symbolic=(it->second)
  ( always {!<=-1,!>=2}
Line 1316
  usage always symbolic=(it->second)
  . possible {4,5}
  == {!<=-1,!>=2,0}
  :: always 6
  pointerPointer always 6
  || {!<=-1,!>=2,0}
Line 1317
  usage always symbolic=(it->second)
  . {5,!6}
  == {!<=-1,!>=2,0}
  :: always 4
  pointerArray always 4
  || always {!<=-1,!>=2}
Line 1318
  usage always symbolic=(it->second)
  . always {!6,!4}
  == always {!<=-1,!>=2}
  :: always 5
  referenceArray always 5
Line 1326
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _allocateMemory always {!<=-1,!>=2}
Line 1330
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
Line 1331
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1336
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _write always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _allocateMemory always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
Line 1340
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _write always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _allocateMemory always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  var always !0
Line 1342
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _modified always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  _read always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1343
  var always !0
Line 1344
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1345
  vnt always symbolic=(var->nameToken())
  ( always {!<=-1,!>=2}
Line 1346
  vnt always symbolic=(var->nameToken())
  2 always 2
Line 1347
  && always {!<=-1,!>=2}
  nextStmt always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 1348
  nextStmt always !0
Line 1349
  error always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  nextStmt possible 0
Line 1351
  error {!<=-1,!>=2,0}
Line 1352
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 1353
  ! always {!<=-1,!>=2}
  var always !0
  || always {!<=-1,!>=2}
  var always !0
  ( always !0
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 1354
  var always !0
Line 1355
  "unusedvar" always "unusedvar"
  typeName always symbolic=(var->getTypeName())
Line 1356
  :: always 0
  def always 0
Line 1359
  :: always 1
  check always 1
Line 1361
  :: always 2
  suppress always 2
Line 1362
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1365
  error {!<=-1,!>=2,0}
Line 1366
  false always 0
Line 1375
  tok possible 0@16
  :: always 3
  style always 3
  "unusedVariable" always "unusedVariable"
  "$symbol:" always "$symbol:"
  varname possible "varname"@16
  "\nUnused variable: $symbol" always "\nUnused variable: $symbol"
  :: always 0
  normal always 0
Line 1380
  tok possible 0@17
  :: always 3
  style always 3
  "unusedAllocatedMemory" always "unusedAllocatedMemory"
  "$symbol:" always "$symbol:"
  varname possible "varname"@17
  "\nVariable '$symbol' is allocated memory that is never used." always "\nVariable '$symbol' is allocated memory that is never used."
  :: always 0
  normal always 0
Line 1383
  , always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
Line 1385
  modified {!<=-1,!>=2,0@195}
Line 1386
  :: always 3
  style always 3
  "unreadVariable" always "unreadVariable"
  "$symbol:" always "$symbol:"
  "\nVariable '$symbol' is modified but its new value is never used." always "\nVariable '$symbol' is modified but its new value is never used."
  :: always 0
  normal always 0
Line 1388
  tok possible 0@18
  :: always 3
  style always 3
  "unreadVariable" always "unreadVariable"
  "$symbol:" always "$symbol:"
  varname possible "varname"@18
  "\nVariable '$symbol' is assigned a value that is never used." always "\nVariable '$symbol' is assigned a value that is never used."
  :: always 0
  normal always 0
Line 1393
  tok possible 0@19
  :: always 3
  style always 3
  "unassignedVariable" always "unassignedVariable"
  "$symbol:" always "$symbol:"
  varname possible "varname"@19
  "\nVariable '$symbol' is not assigned a value." always "\nVariable '$symbol' is not assigned a value."
  :: always 0
  normal always 0
Line 1401
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  :: always 3
  style always 3
Line 1406
  symbolDatabase always symbolic=(mTokenizer->getSymbolDatabase())
Line 1407
  . possible 3
  != {!<=-1,!>=2,1}
  :: always 2
  eStruct always 2
  && always {!<=-1,!>=2}
  . always !2
  != always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 1410
  != always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1414
  ( always {!<=-1,!>=2}
Line 1417
  isPacked always {!<=-1,!>=2}
  isPacked always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1418
  preprocessor always !0
Line 1419
  == always {!<=-1,!>=2}
  "#pragma pack(1)" always "#pragma pack(1)"
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always !<=-1
  linenr always !<=-1
  < always {!<=-1,!>=2}
Line 1420
  isPacked always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1424
  isPacked {!<=-1,!>=2,1}
Line 1429
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1433
  ( always !<=-1
  "<" always "<"
  != always {!<=-1,!>=2}
Line 1437
  bailout always {!<=-1,!>=2}
  bailout always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1440
  . always !0
Line 1441
  == always {!<=-1,!>=2}
Line 1442
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1448
  bailout always {!<=-1,!>=2}
Line 1453
  var possible 0
  && always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  var always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
Line 1454
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1457
  var possible 0
  && always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  var always !0
  == always {!<=-1,!>=2}
  . always !symbolic=(var->typeStartToken()->str())
Line 1458
  "!!" always "!!"
  " & " always " & "
  var always !0
Line 1461
  addrTok possible symbolic=(scope.bodyEnd)
  ( {lifetime[Object]=(addressPattern),!0}
Line 1462
  addrTok possible 0
  && always {!<=-1,!>=2}
  addrTok always !0
  == always {!<=-1,!>=2}
  ")" always ")"
  && always {!<=-1,!>=2}
  addrTok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  addrTok possible 0
Line 1463
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1467
  addrTok always !0
Line 1471
  bailout {!<=-1,!>=2,1}
Line 1475
  "( struct| " always "( struct| "
  " * ) &| %name%" always " * ) &| %name%"
Line 1476
  ( {lifetime[Object]=(castPattern),!0}
Line 1480
  "( struct| " always "( struct| "
  " ) {" always " ) {"
Line 1481
  ( {lifetime[Object]=(initPattern),!0}
Line 1485
  nullptr always 0
  != always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 1486
  2 always 2
Line 1487
  ( always {!<=-1,!>=2}
  "struct| " always "struct| "
  ( {lifetime[Object]=("struct| "+scope.className),!0}
Line 1488
  bailout always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1492
  bailout {!<=-1,!>=2,1}
Line 1497
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1501
  use always {!<=-1,!>=2}
  use always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1502
  tok possible symbolic=(var.nameToken())
  tok possible symbolic=(var.nameToken())
Line 1503
  tok possible symbolic=(var.nameToken())
  != always {!<=-1,!>=2}
  & {lifetime[Address]=(varlist),!0}
Line 1505
  != always {!<=-1,!>=2}
Line 1506
  use always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1510
  ! {!<=-1,!>=2,1,0}
  use {!<=-1,!>=2,0,1}
Line 1511
  == always {!<=-1,!>=2}
  :: always 3
  eUnion always 3
Line 1516
  , always {!<=-1,!>=2}
  isUnion always {!<=-1,!>=2}
Line 1518
  = possible {"union member ","struct member "}
  isUnion {!<=-1,!>=2,0@105,1@105}
  ? possible {"union member ","struct member "}
  "union member " always "union member "
  : always "struct member "
  "struct member " always "struct member "
Line 1519
  tok possible 0@20
  :: always 3
  style always 3
  "unusedStructMember" always "unusedStructMember"
  "$symbol:" always "$symbol:"
  structname possible "structname"@20
  "::" always "::"
  varname possible "variable"@20
  '\n' always 10
  "'$symbol' is never used." always "'$symbol' is never used."
  :: always 0
  normal always 0
Line 1522
  ( always {!<=-1,!>=2}
Line 1527
  type {0,symbolic=(var.type())@45}
  false always 0
Line 1528
  withoutSideEffects always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 1529
  ! always {!<=-1,!>=2}
Line 1530
  return always {!<=-1,!>=2}
  withoutSideEffects {symbolic=(found.first->second),symbolic=(withoutSideEffects),!<=-1,!>=2}
Line 1533
  ! always {!<=-1,!>=2}
  type inconclusive symbolic=(var.type())@45
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  type always !0
Line 1534
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1537
  type always !0
  . always !0
Line 1538
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1540
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
  ") =" always ") ="
Line 1542
  emptyBody always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always !0
  "{ }" always "{ }"
Line 1545
  ( always {!<=-1,!>=2}
  nextToken always symbolic=(f.argDef->link())
  ") :" always ") :"
Line 1549
  ( always {!<=-1,!>=2}
  "[:,] %var% [({]" always "[:,] %var% [({]"
  2 always 2
Line 1551
  varToken always symbolic=(initListToken->next())
Line 1552
  variable always symbolic=(varToken->variable())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  variable {symbolic=(varToken->variable()),!0}
Line 1553
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1556
  2 always 2
Line 1557
  3 always 3
  != always {!<=-1,!>=2}
Line 1559
  initValueVar always symbolic=(valueToken->variable())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  initValueVar {symbolic=(valueToken->variable()),!0}
Line 1560
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1562
  == always {!<=-1,!>=2}
  :: always 4
  eName always 4
  || always {!<=-1,!>=2}
Line 1563
  ( always !4
  == always {!<=-1,!>=2}
  :: always 19
  eLambda always 19
  || always {!<=-1,!>=2}
Line 1564
  ( always {!4,!19}
  == always {!<=-1,!>=2}
  :: always 21
  eOther always 21
Line 1565
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1568
  initValueFunc always symbolic=(valueToken->function())
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  initValueFunc {symbolic=(valueToken->function()),!0}
Line 1569
  { always {size=0,{}
Line 1570
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1576
  ! always {!<=-1,!>=2}
  emptyBody always {!<=-1,!>=2}
Line 1577
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1582
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1583
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1588
  withoutSideEffects always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1589
  ! always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
Line 1590
  return always {!<=-1,!>=2}
  withoutSideEffects always 0
Line 1595
  return always {!<=-1,!>=2}
  withoutSideEffects always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1598
  ( always {!<=-1,!>=2}
Line 1600
  ( always {!<=-1,!>=2}
Line 1601
  return always {!<=-1,!>=2}
  true always 1
Line 1604
  variableType always symbolic=(var.type())
Line 1605
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  variableType {symbolic=(var.type()),!0}
Line 1606
  return always {!<=-1,!>=2}
  false always 0
Line 1608
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "!var.valueType()" always "!var.valueType()"
Line 1609
  return always {!<=-1,!>=2}
  false always 0
Line 1611
  valueType always symbolic=(var.valueType()->type)
  == always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
  || always {!<=-1,!>=2}
  valueType {symbolic=(var.valueType()->type),!0}
  == always {!<=-1,!>=2}
  :: always 2
  NONSTD always 2
Line 1612
  return always {!<=-1,!>=2}
  false always 0
Line 1615
  return always {!<=-1,!>=2}
  true always 1
Line 1618
  ( always {!<=-1,!>=2}
Line 1623
  type inconclusive 0
  false always 0
Line 1624
  emptyType always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 1625
  ! always {!<=-1,!>=2}
Line 1626
  return always {!<=-1,!>=2}
  emptyType {symbolic=(found.first->second),symbolic=(emptyType),!<=-1,!>=2}
Line 1628
  && always {!<=-1,!>=2}
  type always !0
  && always {!<=-1,!>=2}
  type always !0
  . always !0
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
Line 1629
  . always !0
  ( always {!<=-1,!>=2}
Line 1630
  = {lifetime[Iterator]=(type->derivedFrom),start=0}
  type always !0
  ( {lifetime[Iterator]=(type->derivedFrom),start=0}
  i possible {lifetime[Iterator]=(type->derivedFrom),start=0}
  != always {!<=-1,!>=2}
  type always !0
  ( {lifetime[Iterator]=(type->derivedFrom),end=0}
Line 1631
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i possible lifetime[Iterator]=(type->derivedFrom)
Line 1632
  emptyType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1633
  return always {!<=-1,!>=2}
  emptyType always 0
Line 1636
  emptyType always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1637
  return always {!<=-1,!>=2}
  emptyType always 1
Line 1640
  emptyType always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1641
  return always {!<=-1,!>=2}
  emptyType always 0
Line 1644
  ( always {!<=-1,!>=2}
Line 1648
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1649
  return always {!<=-1,!>=2}
  false always 0
Line 1652
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ")" always ")"
Line 1654
  argVar always symbolic=(argsToken->variable())
  && always {!<=-1,!>=2}
  argVar {symbolic=(argsToken->variable()),!0}
  ( always {!<=-1,!>=2}
Line 1655
  return always {!<=-1,!>=2}
  false always 0
Line 1659
  sideEffectReturnFound always {!<=-1,!>=2}
  sideEffectReturnFound always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1661
  != always {!<=-1,!>=2}
Line 1665
  bodyVariable always symbolic=(bodyToken->variable())
Line 1666
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bodyVariable {symbolic=(bodyToken->variable()),!0}
Line 1667
  return always {!<=-1,!>=2}
  false always 0
Line 1670
  bodyVariable {symbolic=(bodyToken->variable()),!0}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(pointersToGlobals)
  bodyVariable {symbolic=(bodyToken->variable()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(pointersToGlobals),end=0}
Line 1671
  depth always 20
  = always 20
  20 always 20
Line 1672
  depth always 20
  ( always {!<=-1,!>=2}
Line 1673
  return always {!<=-1,!>=2}
  false always 0
Line 1676
  ( always {!<=-1,!>=2}
  -1 always -1
  "&" always "&"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "=" always "="
Line 1677
  -3 always -3
Line 1678
  && always {!<=-1,!>=2}
  assigned_var_token always !0
Line 1679
  assigned_var_token always !0
  ( always !0
Line 1687
  bodyFunction always symbolic=(bodyToken->function())
Line 1688
  ( possible lifetime[Iterator]=(checkedFuncs)
  ( {lifetime[Iterator]=(checkedFuncs),start=0}
  ( {lifetime[Iterator]=(checkedFuncs),end=0}
  bodyFunction {symbolic=(bodyToken->function()),!0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(checkedFuncs),end=0}
Line 1691
  bodyFunction inconclusive symbolic=(bodyToken->function())
Line 1692
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  bodyFunction inconclusive symbolic=(bodyToken->function())
  checkedFuncs always !size=0
Line 1693
  return always {!<=-1,!>=2}
  false always 0
Line 1698
  ( always {!<=-1,!>=2}
  "return" always "return"
Line 1701
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  returnValueToken always symbolic=(bodyToken->next())
  ";" always ";"
Line 1702
  sideEffectReturnFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1706
  returnValueToken always symbolic=(bodyToken->next())
Line 1707
  returnValueToken always symbolic=(bodyToken->next())
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1708
  returnVariable always symbolic=(returnValueToken->variable())
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  returnVariable {symbolic=(returnValueToken->variable()),!0}
Line 1711
  sideEffectReturnFound always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1715
  ( always {!<=-1,!>=2}
Line 1716
  return always {!<=-1,!>=2}
  false always 0
Line 1720
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  sideEffectReturnFound {!<=-1,!>=2,0}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( {!<=-1,3@71,6@115}
  flag possible {3@71,6@115}
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
