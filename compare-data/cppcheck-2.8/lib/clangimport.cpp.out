

##file cppcheck-2.8/lib/clangimport.h

1:
|
26:
27: class Tokenizer ;
28:
29: namespace clangimport {
30: void parseClangAstDump ( Tokenizer * tokenizer@var1 , std :: istream & f@var2 ) ;
31: }

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var3 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var4 , const std :: string & errorMsg@var5 , Type type@var6 = INTERNAL ) ;
38: const Token * token@var7 ;
39: std :: string errorMessage@var8 ;
40: Type type@var9 ;
41: std :: string id@var10 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var11 ) ;
117: static SeverityType fromString ( const std :: string & severity@var12 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var13 ) : id@var14 ( cweId@var13 ) { }
122: unsigned short id@var14 ;
123: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var15 ;
42: double mDoubleValue@var16 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var17 ;
44: bool mIsUnsigned@var18 ;
45:
46: void promote ( const value & v@var19 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var20 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var17 !=@expr1073744257 Type ::@expr1073744258 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var17 ==@expr1073744259 Type ::@expr1073744260 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744261 ) ?@expr1073744262 mDoubleValue@var16 :@expr1073744263 (@expr1073744264 double ) mIntValue@var15 ;
60: }
61:
62: static value calc ( char op@var21 , const value & v1@var22 , const value & v2@var23 ) ;
63: int compare ( const value & v@var24 ) const ;
64: value add ( int v@var25 ) const ;
65: value shiftLeft ( const value & v@var26 ) const ;
66: value shiftRight ( const value & v@var27 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var28 ;
72:
73: static long long toLongNumber ( const std :: string & str@var29 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var30 ) ;
75:
76: template < class T > static std :: string toString ( T value@var31 ) {
77: std ::@expr1073744265 ostringstream result@var32 ;
78: result@var32 <<@expr1073744266 value@var31 ;
79: return result@var32 .@expr1073744267 str (@expr1073744268 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var33 ) ;
82:
83: static bool isInt ( const std :: string & str@var34 ) ;
84: static bool isFloat ( const std :: string & str@var35 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var36 ) ;
86: static bool isNegative ( const std :: string & str@var37 ) ;
87: static bool isPositive ( const std :: string & str@var38 ) ;
88: static bool isDec ( const std :: string & str@var39 ) ;
89: static bool isFloatHex ( const std :: string & str@var40 ) ;
90: static bool isIntHex ( const std :: string & str@var41 ) ;
91: static bool isOct ( const std :: string & str@var42 ) ;
92: static bool isBin ( const std :: string & str@var43 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var44 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var45 , bool supportMicrosoftExtensions@var46 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var47 , const std :: string & second@var48 ) ;
105: static std :: string subtract ( const std :: string & first@var49 , const std :: string & second@var50 ) ;
106: static std :: string multiply ( const std :: string & first@var51 , const std :: string & second@var52 ) ;
107: static std :: string divide ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
108: static std :: string mod ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
109: static std :: string incdec ( const std :: string & var@var57 , const std :: string & op@var58 ) ;
110: static std :: string calculate ( const std :: string & first@var59 , const std :: string & second@var60 , char action@var61 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var62 ) ;
113: static std :: string cos ( const std :: string & tok@var63 ) ;
114: static std :: string tan ( const std :: string & tok@var64 ) ;
115: static std :: string abs ( const std :: string & tok@var65 ) ;
116: static bool isEqual ( const std :: string & first@var66 , const std :: string & second@var67 ) ;
117: static bool isNotEqual ( const std :: string & first@var68 , const std :: string & second@var69 ) ;
118: static bool isGreater ( const std :: string & first@var70 , const std :: string & second@var71 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var72 , const std :: string & second@var73 ) ;
120: static bool isLess ( const std :: string & first@var74 , const std :: string & second@var75 ) ;
121: static bool isLessEqual ( const std :: string & first@var76 , const std :: string & second@var77 ) ;
122: static bool isNullValue ( const std :: string & str@var78 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var79 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var80 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var81 , std :: string :: size_type iPos@var82 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var83 , const MathLib :: value & v2@var84 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var85 , const MathLib :: value & v2@var86 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var87 , const MathLib :: value & v2@var88 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var89 , const MathLib :: value & v2@var90 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var91 , const MathLib :: value & v2@var92 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var93 , const MathLib :: value & v2@var94 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var95 , const MathLib :: value & v2@var96 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var97 , const MathLib :: value & v2@var98 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var99 , const MathLib :: value & v2@var100 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var101 , const MathLib :: value & v2@var102 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var103 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var104 ) {
44: if (@expr1073744269 bit@var104 >=@expr1073744270 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073744271 (@expr1073744272 1LL <<@expr1073744273 (@expr1073744274 bit@var104 -@expr1073744275 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var105 ) {
50: if (@expr1073744276 bit@var105 >=@expr1073744277 64 ) {
51: return (@expr2454 ~@expr1073744279 0ULL ) >>@expr1073744280 1 ; }
52: return (@expr2454 1LL <<@expr1073744282 (@expr2454 bit@var105 -@expr1073744284 1 ) ) -@expr1073744285 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var106 ) const {
59: return value@var106 >=@expr1073744286 min_value (@expr1073744287 int_bit@var116 ) &&@expr1073744288 value@var106 <=@expr1073744289 max_value (@expr1073744290 int_bit@var116 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var107 ) const {
63: unsigned long long intMax@var108 ; intMax@var108 =@expr1073744291 max_value (@expr1073744292 int_bit@var116 ) ;
64: return value@var107 <=@expr1073744293 intMax@var108 ;
65: }
66:
67: bool isLongValue ( long long value@var109 ) const {
68: return value@var109 >=@expr1073744294 min_value (@expr1073744295 long_bit@var117 ) &&@expr1073744296 value@var109 <=@expr1073744297 max_value (@expr1073744298 long_bit@var117 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var110 ) const {
72: unsigned long long longMax@var111 ; longMax@var111 =@expr1073744299 max_value (@expr1073744300 long_bit@var117 ) ;
73: return value@var110 <=@expr1073744301 longMax@var111 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var112 ) const {
77: unsigned long long longLongMax@var113 ; longLongMax@var113 =@expr1073744302 max_value (@expr1073744303 long_long_bit@var118 ) ;
78: return value@var112 <=@expr1073744304 longLongMax@var113 ;
79: }
80:
81: int char_bit@var114 ;
82: int short_bit@var115 ;
83: int int_bit@var116 ;
84: int long_bit@var117 ;
85: int long_long_bit@var118 ;
86:
87:
88: int sizeof_bool@var119 ;
89: int sizeof_short@var120 ;
90: int sizeof_int@var121 ;
91: int sizeof_long@var122 ;
92: int sizeof_long_long@var123 ;
93: int sizeof_float@var124 ;
94: int sizeof_double@var125 ;
95: int sizeof_long_double@var126 ;
96: int sizeof_wchar_t@var127 ;
97: int sizeof_size_t@var128 ;
98: int sizeof_pointer@var129 ;
99:
100: char defaultSign@var130 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var131 ;
115:
116:
117: bool platform ( PlatformType type@var132 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var133 [ ] , const std :: string & filename@var134 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var135 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var131 ==@expr1073744305 Win32A ||@expr1073744306
136: platformType@var131 ==@expr1073744307 Win32W ||@expr1073744308
137: platformType@var131 ==@expr1073744309 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073744310 platformType@var131 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var136 ) {
145: switch (@expr1073744311 pt@var136 ) {
146: case Unspecified :@expr2488 ;
147: return "Unspecified" ;
148: case Native :@expr2488 ;
149: return "Native" ;
150: case Win32A :@expr2488 ;
151: return "win32A" ;
152: case Win32W :@expr2488 ;
153: return "win32W" ;
154: case Win64 :@expr2488 ;
155: return "win64" ;
156: case Unix32 :@expr2488 ;
157: return "unix32" ;
158: case Unix64 :@expr2488 ;
159: return "unix64" ;
160: case PlatformFile :@expr2488 ;
161: return "platformFile" ;
162: default :@expr2488 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073744321 char_bit@var114 +@expr1073744322 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073744323 char_bit@var114 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073744324 char_bit@var114 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var137 ) const {
35: return p@var137 .@expr1073744325 first@var138 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var139 ) const {
42: return p@var139 .@expr1073744326 second@var140 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var141 , const T & x@var142 )
48: {
49: return std ::@expr1073744327 find (@expr1073744328 r@var141 .@expr1073744329 begin (@expr1073744330 ) , r@var141 .@expr2507 end (@expr2508 ) , x@var142 ) !=@expr1073744333 r@var141 .@expr2507 end (@expr2508 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var143 , const T & x@var144 )
54: {
55: return std ::@expr1073744336 find (@expr1073744337 r@var143 .@expr1073744338 begin (@expr1073744339 ) , r@var143 .@expr2516 end (@expr2517 ) , x@var144 ) !=@expr1073744342 r@var143 .@expr2516 end (@expr2517 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var145 , const U & x@var146 )
60: {
61: return std ::@expr1073744345 find (@expr1073744346 r@var145 .@expr1073744347 begin (@expr1073744348 ) , r@var145 .@expr2525 end (@expr2526 ) , x@var146 ) !=@expr1073744351 r@var145 .@expr2525 end (@expr2526 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var147 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744354 t@var147 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var148 , char c@var149 )
74: {
75: return !@expr1073744355 str@var148 .@expr1073744356 empty (@expr1073744357 ) &&@expr1073744358 str@var148 .@expr1073744359 back (@expr1073744360 ) ==@expr1073744361 c@var149 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var150 , const char end@var151 [ ] , unsigned long endlen@var152 )
79: {
80: return (@expr2538 str@var150 .@expr2539 size (@expr2540 ) >=@expr1073744365 endlen@var152 ) &&@expr1073744366 (@expr2538 str@var150 .@expr1073744368 compare (@expr1073744369 str@var150 .@expr2539 size (@expr2540 ) -@expr1073744372 endlen@var152 , endlen@var152 , end@var151 ) ==@expr1073744373 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var153 , const char ( & end@var154 ) [ N ] )
85: {
86: return endsWith (@expr1073744375 str@var153 , end@var154 , N@expr1073744374 -@expr1073744376 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var155 , char q@var156 , const std :: string & p@var157 )
90: {
91: if (@expr1073744377 !@expr1073744378 endsWith (@expr1073744379 str@var155 , q@var156 ) ) {
92: return false ; }
93: if (@expr1073744380 (@expr1073744381 str@var155 .@expr1073744382 length (@expr1073744383 ) +@expr1073744384 1 ) >@expr1073744385 p@var157 .@expr1073744386 length (@expr1073744387 ) &&@expr1073744388 (@expr1073744389 str@var155 .@expr1073744390 compare (@expr1073744391 0 , p@var157 .@expr1073744392 size (@expr1073744393 ) +@expr1073744394 1 , p@var157 +@expr1073744395 q@var156 ) ==@expr1073744396 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var158 , char q@var159 )
99: {
100: static const std ::@expr2573 vector < std ::@expr2573 string > suffixes@var160 {@expr1073744399 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744400 const std ::@expr2573 string &@expr1073744402 p@var161 :@expr1073744403 suffixes@var160 ) {
102: if (@expr1073744404 isPrefixStringCharLiteral (@expr1073744405 str@var158 , q@var159 , p@var161 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var162 )
109: {
110: return isStringCharLiteral (@expr1073744406 str@var162 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var163 )
114: {
115: return isStringCharLiteral (@expr1073744407 str@var163 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var164 , char q@var165 )
119: {
120: const unsigned long quotePos@var166 =@expr1073744408 str@var164 .@expr1073744409 find (@expr1073744410 q@var165 ) ;
121: return str@var164 .@expr1073744411 substr (@expr1073744412 quotePos@var166 +@expr1073744413 1U , str@var164 .@expr1073744414 size (@expr1073744415 ) -@expr1073744416 quotePos@var166 -@expr1073744417 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var167 )
125: {
126: if (@expr1073744418 isStringLiteral (@expr1073744419 str@var167 ) ) {
127: return getStringCharLiteral (@expr1073744420 str@var167 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var168 )
132: {
133: if (@expr1073744421 isCharLiteral (@expr1073744422 str@var168 ) ) {
134: return getStringCharLiteral (@expr1073744423 str@var168 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var169 )
139: {
140: if (@expr1073744424 i@var169 ==@expr1073744425 1 ) {
141: return "st" ; }
142: if (@expr1073744426 i@var169 ==@expr1073744427 2 ) {
143: return "nd" ; }
144: if (@expr1073744428 i@var169 ==@expr1073744429 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var170 , const std :: string & rhs@var171 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var172 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var173 , const std :: string & name@var174 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var175 , const std :: string & name@var176 ) ;
156:
157: void strTolower ( std :: string & str@var177 ) ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var178 , const std :: string & rhs@var179 ) const {
41: return caseInsensitiveStringCompare (@expr1073744430 lhs@var178 , rhs@var179 ) <@expr1073744431 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var187 ( cppcheck :: Platform :: Unspecified ) , msc@var188 ( false ) , useMfc@var189 ( false ) { }
67: std :: string cfg@var180 ;
68: std :: string filename@var181 ;
69: std :: string defines@var182 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var182 +@expr1073744432 (@expr1073744433 msc@var188 ?@expr1073744434 ";_MSC_VER=1900" :@expr1073744435 "" ) +@expr1073744436 (@expr1073744437 useMfc@var189 ?@expr1073744438 ";__AFXWIN_H__=1" :@expr1073744439 "" ) ;
72: }
73: std :: set < std :: string > undefs@var183 ;
74: std :: list < std :: string > includePaths@var184 ;
75: std :: list < std :: string > systemIncludePaths@var185 ;
76: std :: string standard@var186 ;
77: cppcheck :: Platform :: PlatformType platformType@var187 ;
78: bool msc@var188 ;
79: bool useMfc@var189 ;
80:
81: void parseCommand ( std :: string command@var190 ) ;
82: void setDefines ( std :: string defs@var191 ) ;
83: void setIncludePaths ( const std :: string & basepath@var192 , const std :: list < std :: string > & in@var193 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var194 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var195 ;
86: Type projectType@var196 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var197 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous0 {
96: std :: string analyzeAllVsConfigs@var198 ;
97: std :: vector < std :: string > pathNames@var199 ;
98: std :: list < std :: string > libraries@var200 ;
99: std :: list < std :: string > excludedPaths@var201 ;
100: std :: list < std :: string > checkVsConfigs@var202 ;
101: std :: string projectFile@var203 ;
102: std :: string platform@var204 ;
103: } ; struct Anonymous0 guiProject@var205 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var206 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var207 ) ;
107:
108: Type import ( const std :: string & filename@var208 , Settings * settings@var209 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var210 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var211 , Settings * settings@var212 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var213 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var214 , const std :: string & path@var215 , const std :: vector < std :: string > & fileFilters@var216 ) ;
115: bool importVcxproj ( const std :: string & filename@var217 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var218 , const std :: string & additionalIncludeDirectories@var219 , const std :: vector < std :: string > & fileFilters@var220 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var221 ) ;
117:
118: static void printError ( const std :: string & message@var222 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var223 ) ;
121:
122: std :: string mPath@var224 ;
123: std :: set < std :: string > mAllVSConfigs@var225 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var226 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var227 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var228 [ 2 ] = "1" ;
131: const char BuildDirElementName@var229 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var230 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var231 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var232 [ 7 ] = "parser" ;
135: const char BugHunting@var233 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var234 [ 11 ] = "includedir" ;
137: const char DirElementName@var235 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var236 [ 5 ] = "name" ;
139: const char DefinesElementName@var237 [ 8 ] = "defines" ;
140: const char DefineName@var238 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var239 [ 5 ] = "name" ;
142: const char UndefinesElementName@var240 [ 10 ] = "undefines" ;
143: const char UndefineName@var241 [ 9 ] = "undefine" ;
144: const char PathsElementName@var242 [ 6 ] = "paths" ;
145: const char PathName@var243 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var244 [ 5 ] = "name" ;
147: const char RootPathName@var245 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var246 [ 5 ] = "name" ;
149: const char IgnoreElementName@var247 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var248 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var249 [ 5 ] = "name" ;
152: const char ExcludeElementName@var250 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var251 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var252 [ 5 ] = "name" ;
155: const char FunctionContracts@var253 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var254 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var255 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var256 [ 8 ] = "library" ;
159: const char PlatformElementName@var257 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var258 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var259 [ 12 ] = "suppression" ;
162: const char AddonElementName@var260 [ 6 ] = "addon" ;
163: const char AddonsElementName@var261 [ 7 ] = "addons" ;
164: const char ToolElementName@var262 [ 5 ] = "tool" ;
165: const char ToolsElementName@var263 [ 6 ] = "tools" ;
166: const char TagsElementName@var264 [ 5 ] = "tags" ;
167: const char TagElementName@var265 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var266 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var267 [ 4 ] = "tag" ;
170: const char WarningElementName@var268 [ 8 ] = "warning" ;
171: const char HashAttributeName@var269 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var270 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var271 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var272 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var273 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var274 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var275 [ 11 ] = "clang-tidy" ;
178: const char Name@var276 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var277 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var278 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var279 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var280 ;
42:
43:
44: std :: string stdValue@var281 ;
45:
46:
47: Standards ( ) : c@var279 ( CLatest ) , cpp@var280 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var282 ) {
50: stdValue@var281 =@expr1073744440 str@var282 ;
51: if (@expr1073744441 str@var282 ==@expr1073744442 "c89" ||@expr1073744443 str@var282 ==@expr1073744444 "C89" ) {
52: c@var279 =@expr1073744445 C89 ;
53: return true ;
54: }
55: if (@expr1073744446 str@var282 ==@expr1073744447 "c99" ||@expr1073744448 str@var282 ==@expr1073744449 "C99" ) {
56: c@var279 =@expr1073744450 C99 ;
57: return true ;
58: }
59: if (@expr1073744451 str@var282 ==@expr1073744452 "c11" ||@expr1073744453 str@var282 ==@expr1073744454 "C11" ) {
60: c@var279 =@expr1073744455 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744456 c@var279 ) {
67: case C89 :@expr2633 ;
68: return "c89" ;
69: case C99 :@expr2633 ;
70: return "c99" ;
71: case C11 :@expr2633 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var283 ) {
77: if (@expr1073744460 std@var283 ==@expr1073744461 "c89" ) {
78: return Standards ::@expr1073744462 C89 ;
79: }
80: if (@expr1073744463 std@var283 ==@expr1073744464 "c99" ) {
81: return Standards ::@expr1073744465 C99 ;
82: }
83: if (@expr1073744466 std@var283 ==@expr1073744467 "c11" ) {
84: return Standards ::@expr1073744468 C11 ;
85: }
86: return Standards ::@expr1073744469 CLatest ;
87: }
88: bool setCPP ( std :: string str@var284 ) {
89: stdValue@var281 =@expr1073744470 str@var284 ;
90: strTolower (@expr1073744471 str@var284 ) ;
91: cpp@var280 =@expr1073744472 getCPP (@expr1073744473 str@var284 ) ;
92: return !@expr1073744474 stdValue@var281 .@expr1073744475 empty (@expr1073744476 ) &&@expr1073744477 str@var284 ==@expr1073744478 getCPP (@expr1073744479 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744480 cpp@var280 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var285 ) {
98: switch (@expr1073744481 std@var285 ) {
99: case CPP03 :@expr2658 ;
100: return "c++03" ;
101: case CPP11 :@expr2658 ;
102: return "c++11" ;
103: case CPP14 :@expr2658 ;
104: return "c++14" ;
105: case CPP17 :@expr2658 ;
106: return "c++17" ;
107: case CPP20 :@expr2658 ;
108: return "c++20" ;
109: case CPP23 :@expr2658 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var286 ) {
115: if (@expr1073744488 std@var286 ==@expr1073744489 "c++03" ) {
116: return Standards ::@expr1073744490 CPP03 ;
117: }
118: if (@expr1073744491 std@var286 ==@expr1073744492 "c++11" ) {
119: return Standards ::@expr1073744493 CPP11 ;
120: }
121: if (@expr1073744494 std@var286 ==@expr1073744495 "c++14" ) {
122: return Standards ::@expr1073744496 CPP14 ;
123: }
124: if (@expr1073744497 std@var286 ==@expr1073744498 "c++17" ) {
125: return Standards ::@expr1073744499 CPP17 ;
126: }
127: if (@expr1073744500 std@var286 ==@expr1073744501 "c++20" ) {
128: return Standards ::@expr1073744502 CPP20 ;
129: }
130: if (@expr1073744503 std@var286 ==@expr1073744504 "c++23" ) {
131: return Standards ::@expr1073744505 CPP23 ;
132: }
133: return Standards ::@expr1073744506 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var290 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var287 ) : errorcode@var290 ( e@var287 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var288 , T && r@var289 ) : errorcode@var290 ( e@var288 ) , reason@var291 ( r@var289 ) { }
66: ErrorCode errorcode@var290 ;
67: std :: string reason@var291 ;
68: } ;
69:
70: Error load ( const char exename@var292 [ ] , const char path@var293 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var294 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var295 [ ] , unsigned long len@var296 ) ;
75:
76: struct AllocFunc {
77: int groupId@var297 ;
78: int arg@var298 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var299 ;
81: int bufferSizeArg1@var300 ;
82: int bufferSizeArg2@var301 ;
83: int reallocArg@var302 ;
84: bool initData@var303 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var304 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var305 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var306 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var307 , int arg@var308 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var309 , int arg@var310 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var311 , int arg@var312 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var313 [ ] ) const {
107: return getAllocDealloc (@expr1073744507 mAlloc@var579 , name@var313 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var314 [ ] ) const {
112: return getAllocDealloc (@expr1073744508 mDealloc@var580 , name@var314 ) ;
113: }
114:
115:
116: int allocId ( const char name@var315 [ ] ) const {
117: const AllocFunc * af@var316 ; af@var316 =@expr1073744509 getAllocDealloc (@expr1073744510 mAlloc@var579 , name@var315 ) ;
118: return af@var316 ?@expr1073744511 af@var316 .@expr1073744512 groupId@var317 :@expr1073744513 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var318 [ ] ) const {
123: const AllocFunc * af@var319 ; af@var319 =@expr1073744514 getAllocDealloc (@expr1073744515 mDealloc@var580 , name@var318 ) ;
124: return af@var319 ?@expr1073744516 af@var319 .@expr1073744517 groupId@var320 :@expr1073744518 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var321 , int id@var322 , int arg@var323 ) {
129: mAlloc@var579 [@expr2695 functionname@var321 ] .@expr1073744520 groupId@var2440 =@expr1073744521 id@var322 ;
130: mAlloc@var579 [@expr2695 functionname@var321 ] .@expr1073744523 arg@var2441 =@expr1073744524 arg@var323 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var324 , int id@var325 , int arg@var326 ) {
134: mDealloc@var580 [@expr2701 functionname@var324 ] .@expr1073744526 groupId@var2442 =@expr1073744527 id@var325 ;
135: mDealloc@var580 [@expr2701 functionname@var324 ] .@expr1073744529 arg@var2443 =@expr1073744530 arg@var326 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var327 , int id@var328 , int arg@var329 , int reallocArg@var330 = 1 ) {
139: mRealloc@var581 [@expr2707 functionname@var327 ] .@expr1073744532 groupId@var2444 =@expr1073744533 id@var328 ;
140: mRealloc@var581 [@expr2707 functionname@var327 ] .@expr1073744535 arg@var2445 =@expr1073744536 arg@var329 ;
141: mRealloc@var581 [@expr2707 functionname@var327 ] .@expr1073744538 reallocArg@var2446 =@expr1073744539 reallocArg@var330 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var331 , bool noreturn@var332 ) {
146: mNoReturn@var582 [@expr1073744540 funcname@var331 ] =@expr1073744541 noreturn@var332 ?@expr1073744542 FalseTrueMaybe ::@expr1073744543 True :@expr1073744544 FalseTrueMaybe ::@expr1073744545 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var333 ) ;
150:
151:
152: static bool ismemory ( const int id@var334 ) {
153: return (@expr2722 (@expr2722 id@var334 >@expr1073744548 0 ) &&@expr1073744549 (@expr2722 (@expr2722 id@var334 &@expr1073744552 1 ) ==@expr1073744553 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var335 ) {
156: return (@expr2730 (@expr2730 func@var335 .@expr2732 groupId@var336 >@expr1073744557 0 ) &&@expr1073744558 (@expr2730 (@expr2730 func@var335 .@expr2732 groupId@var336 &@expr1073744562 1 ) ==@expr1073744563 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var337 ) {
161: return (@expr2740 (@expr2740 id@var337 >@expr1073744566 0 ) &&@expr1073744567 (@expr2740 (@expr2740 id@var337 &@expr1073744570 1 ) ==@expr1073744571 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var338 ) {
164: return (@expr2748 (@expr2748 func@var338 .@expr2750 groupId@var339 >@expr1073744575 0 ) &&@expr1073744576 (@expr2748 (@expr2748 func@var338 .@expr2750 groupId@var339 &@expr1073744580 1 ) ==@expr1073744581 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var340 ) const ;
168: int formatstr_argno ( const Token * ftok@var341 ) const ;
169: bool formatstr_scan ( const Token * ftok@var342 ) const ;
170: bool formatstr_secure ( const Token * ftok@var343 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var344 ;
174: int ptr2Arg@var345 ;
175: int sizeArg@var346 ;
176: int strlenArg@var347 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var348 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var349 ;
182: Standards standards@var350 ;
183: Severity :: SeverityType severity@var351 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var352 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var353 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var354 ) const ;
191: bool matchArguments ( const Token * ftok@var355 , const std :: string & functionName@var356 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var357 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var358 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var359 ) const ;
198: int returnValueContainer ( const Token * ftok@var360 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var361 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var362 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var363 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var364 , std :: string * unknownFunc@var365 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var375 ( -1 ) ,
210: size_templateArgNo@var377 ( -1 ) ,
211: arrayLike_indexOp@var378 ( false ) ,
212: stdStringLike@var379 ( false ) ,
213: stdAssociativeLike@var380 ( false ) ,
214: opLessAllowed@var381 ( true ) ,
215: hasInitializerListConstructor@var382 ( false ) ,
216: unstableErase@var383 ( false ) ,
217: unstableInsert@var384 ( false ) ,
218: view@var385 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var366 ;
248: Yield yield@var367 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var368 ;
252: int templateParameter@var369 ;
253: } ;
254: std :: string startPattern@var370 ; std :: string startPattern2@var371 ; std :: string endPattern@var372 ; std :: string itEndPattern@var373 ;
255: std :: map < std :: string , Function > functions@var374 ;
256: int type_templateArgNo@var375 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var376 ;
258: int size_templateArgNo@var377 ;
259: bool arrayLike_indexOp@var378 ;
260: bool stdStringLike@var379 ;
261: bool stdAssociativeLike@var380 ;
262: bool opLessAllowed@var381 ;
263: bool hasInitializerListConstructor@var382 ;
264: bool unstableErase@var383 ;
265: bool unstableInsert@var384 ;
266: bool view@var385 ;
267:
268: Action getAction ( const std :: string & function@var386 ) const {
269: const std ::@expr1073744582 map < std ::@expr1073744583 string , Function > ::@expr1073744584 const_iterator i@var387 =@expr1073744585 functions@var374 .@expr1073744586 find (@expr1073744587 function@var386 ) ;
270: if (@expr1073744588 i@var387 !=@expr1073744589 functions@var374 .@expr1073744590 end (@expr1073744591 ) ) {
271: return i@var387 .@expr1073744592 second@var388 .@expr1073744593 action@var389 ; }
272: return Action ::@expr1073744594 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var390 ) const {
276: const std ::@expr1073744595 map < std ::@expr1073744596 string , Function > ::@expr1073744597 const_iterator i@var391 =@expr1073744598 functions@var374 .@expr1073744599 find (@expr1073744600 function@var390 ) ;
277: if (@expr1073744601 i@var391 !=@expr1073744602 functions@var374 .@expr1073744603 end (@expr1073744604 ) ) {
278: return i@var391 .@expr1073744605 second@var392 .@expr1073744606 yield@var393 ; }
279: return Yield ::@expr1073744607 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var394 ) ;
283: static Action actionFrom ( const std :: string & actionName@var395 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var396 ;
286: const Container * detectContainer ( const Token * typeStart@var397 , bool iterator@var398 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var399 , bool * isIterator@var400 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var401 ( false ) ,
293: notnull@var402 ( false ) ,
294: notuninit@var403 ( -1 ) ,
295: formatstr@var404 ( false ) ,
296: strz@var405 ( false ) ,
297: optional@var406 ( false ) ,
298: variadic@var407 ( false ) ,
299: iteratorInfo@var413 ( ) ,
300: direction@var421 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var401 ;
303: bool notnull@var402 ;
304: int notuninit@var403 ;
305: bool formatstr@var404 ;
306: bool strz@var405 ;
307: bool optional@var406 ;
308: bool variadic@var407 ;
309: std :: string valid@var408 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var409 ( 0 ) , it@var410 ( false ) , first@var411 ( false ) , last@var412 ( false ) { }
314:
315: int container@var409 ;
316: bool it@var410 ;
317: bool first@var411 ;
318: bool last@var412 ;
319: } ;
320: IteratorInfo iteratorInfo@var413 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var414 , int a@var415 ) : type@var416 ( t@var414 ) , arg@var417 ( a@var415 ) , arg2@var418 ( 0 ) , value@var419 ( 0 ) { }
326: Type type@var416 ;
327: int arg@var417 ;
328: int arg2@var418 ;
329: long long value@var419 ;
330: } ;
331: std :: vector < MinSize > minsizes@var420 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var421 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var422 ;
344: bool use@var423 ;
345: bool leakignore@var424 ;
346: bool isconst@var425 ;
347: bool ispure@var426 ;
348: UseRetValType useretval@var427 ;
349: bool ignore@var428 ;
350: bool formatstr@var429 ;
351: bool formatstr_scan@var430 ;
352: bool formatstr_secure@var431 ;
353: Container :: Action containerAction@var432 ;
354: Container :: Yield containerYield@var433 ;
355: Function ( )
356: : use@var423 ( false ) ,
357: leakignore@var424 ( false ) ,
358: isconst@var425 ( false ) ,
359: ispure@var426 ( false ) ,
360: useretval@var427 ( UseRetValType :: NONE ) ,
361: ignore@var428 ( false ) ,
362: formatstr@var429 ( false ) ,
363: formatstr_scan@var430 ( false ) ,
364: formatstr_secure@var431 ( false ) ,
365: containerAction@var432 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var433 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var434 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var435 ;
372: bool isUse ( const std :: string & functionName@var436 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var437 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var438 , bool pure@var439 ) const ;
375: bool isFunctionConst ( const Token * ftok@var440 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var441 , int argnr@var442 ) const {
378: const ArgumentChecks * arg@var443 ; arg@var443 =@expr1073744608 getarg (@expr1073744609 ftok@var441 , argnr@var442 ) ;
379: return arg@var443 &&@expr1073744610 arg@var443 .@expr1073744611 notbool@var444 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var445 , int argnr@var446 ) const ;
383: bool isuninitargbad ( const Token * ftok@var447 , int argnr@var448 , int indirect@var449 = 0 , bool * hasIndirect@var450 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var451 , int argnr@var452 ) const {
386: const ArgumentChecks * arg@var453 ; arg@var453 =@expr1073744612 getarg (@expr1073744613 ftok@var451 , argnr@var452 ) ;
387: return arg@var453 &&@expr1073744614 arg@var453 .@expr1073744615 formatstr@var454 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var455 , int argnr@var456 ) const {
391: const ArgumentChecks * arg@var457 ; arg@var457 =@expr1073744616 getarg (@expr1073744617 ftok@var455 , argnr@var456 ) ;
392: return arg@var457 &&@expr1073744618 arg@var457 .@expr1073744619 strz@var458 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var459 , int argnr@var460 , const long long argvalue@var461 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var462 , int argnr@var463 , double argvalue@var464 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var465 , int argnr@var466 ) const {
399: const ArgumentChecks * arg@var467 ; arg@var467 =@expr1073744620 getarg (@expr1073744621 ftok@var465 , argnr@var466 ) ;
400: return arg@var467 ?@expr1073744622 arg@var467 .@expr1073744623 valid@var468 :@expr1073744624 emptyString@var3 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var469 ;
405: std :: string op1@var470 ;
406: std :: string op2@var471 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744625 isInt (@expr1073744626 op1@var470 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var472 , int argnr@var473 ) const {
413: const ArgumentChecks * arg@var474 ; arg@var474 =@expr1073744627 getarg (@expr1073744628 ftok@var472 , argnr@var473 ) ;
414: return arg@var474 &&@expr1073744629 arg@var474 .@expr2806 iteratorInfo@var475 .@expr1073744631 it@var476 ?@expr1073744632 &@expr1073744633 arg@var474 .@expr2806 iteratorInfo@var475 :@expr1073744635 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var477 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var478 , int argnr@var479 ) const {
420: const ArgumentChecks * arg@var480 ; arg@var480 =@expr1073744636 getarg (@expr1073744637 ftok@var478 , argnr@var479 ) ;
421: return arg@var480 ?@expr1073744638 &@expr1073744639 arg@var480 .@expr1073744640 minsizes@var481 :@expr1073744641 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var482 , int argnr@var483 ) const ;
425:
426: bool markupFile ( const std :: string & path@var484 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var485 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var589 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var486 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var487 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var488 , const std :: string & token@var489 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var490 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var491 ) const ;
443: const std :: string & blockend ( const std :: string & file@var492 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var493 , const std :: string & keyword@var494 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var495 ) const {
448: return mExporters@var592 .@expr1073744642 find (@expr1073744643 prefix@var495 ) !=@expr1073744644 mExporters@var592 .@expr1073744645 end (@expr1073744646 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var496 , const std :: string & token@var497 ) const {
452: const std ::@expr1073744647 map < std ::@expr1073744648 string , ExportedFunctions > ::@expr1073744649 const_iterator it@var498 =@expr1073744650 mExporters@var592 .@expr1073744651 find (@expr1073744652 prefix@var496 ) ;
453: return (@expr1073744653 it@var498 !=@expr1073744654 mExporters@var592 .@expr1073744655 end (@expr1073744656 ) &&@expr1073744657 it@var498 .@expr1073744658 second@var499 .@expr1073744659 isPrefix (@expr1073744660 token@var497 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var500 , const std :: string & token@var501 ) const {
457: const std ::@expr1073744661 map < std ::@expr1073744662 string , ExportedFunctions > ::@expr1073744663 const_iterator it@var502 =@expr1073744664 mExporters@var592 .@expr1073744665 find (@expr1073744666 prefix@var500 ) ;
458: return (@expr1073744667 it@var502 !=@expr1073744668 mExporters@var592 .@expr1073744669 end (@expr1073744670 ) &&@expr1073744671 it@var502 .@expr1073744672 second@var503 .@expr1073744673 isSuffix (@expr1073744674 token@var501 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var504 , const std :: string & importer@var505 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var506 , Container :: Yield yield@var507 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var508 , Container :: Action action@var509 ) const ;
465:
466: bool isreflection ( const std :: string & token@var510 ) const {
467: return mReflection@var594 .@expr1073744675 find (@expr1073744676 token@var510 ) !=@expr1073744677 mReflection@var594 .@expr1073744678 end (@expr1073744679 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var511 ) const {
471: const std ::@expr1073744680 map < std ::@expr1073744681 string , int > ::@expr1073744682 const_iterator it@var512 =@expr1073744683 mReflection@var594 .@expr1073744684 find (@expr1073744685 token@var511 ) ;
472: if (@expr1073744686 it@var512 !=@expr1073744687 mReflection@var594 .@expr1073744688 end (@expr1073744689 ) ) {
473: return it@var512 .@expr1073744690 second@var513 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var514 ;
478:
479: struct SmartPointer {
480: std :: string name@var515 ; name@var515 = "" ;
481: bool unique@var516 ; unique@var516 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var517 ;
485: bool isSmartPointer ( const Token * tok@var518 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var519 ) const ;
487:
488: struct PodType {
489: unsigned int size@var520 ;
490: char sign@var521 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var522 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var523 ) const {
494: const std ::@expr1073744691 unordered_map < std ::@expr1073744692 string , PodType > ::@expr1073744693 const_iterator it@var524 =@expr1073744694 mPodTypes@var595 .@expr1073744695 find (@expr1073744696 name@var523 ) ;
495: return (@expr2873 it@var524 !=@expr1073744698 mPodTypes@var595 .@expr1073744699 end (@expr1073744700 ) ) ?@expr1073744701 &@expr1073744702 (@expr2873 it@var524 .@expr1073744704 second@var525 ) :@expr1073744705 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var536 ( false )
501: , mUnsigned@var537 ( false )
502: , mLong@var538 ( false )
503: , mPointer@var539 ( false )
504: , mPtrPtr@var540 ( false )
505: , mConstPtr@var541 ( false ) { }
506: bool operator== ( const PlatformType & type@var526 ) const {
507: return (@expr1073744706 mSigned@var536 ==@expr1073744707 type@var526 .@expr1073744708 mSigned@var527 &&@expr1073744709
508: mUnsigned@var537 ==@expr1073744710 type@var526 .@expr1073744711 mUnsigned@var528 &&@expr1073744712
509: mLong@var538 ==@expr1073744713 type@var526 .@expr1073744714 mLong@var529 &&@expr1073744715
510: mPointer@var539 ==@expr1073744716 type@var526 .@expr1073744717 mPointer@var530 &&@expr1073744718
511: mPtrPtr@var540 ==@expr1073744719 type@var526 .@expr1073744720 mPtrPtr@var531 &&@expr1073744721
512: mConstPtr@var541 ==@expr1073744722 type@var526 .@expr1073744723 mConstPtr@var532 &&@expr1073744724
513: mType@var535 ==@expr1073744725 type@var526 .@expr1073744726 mType@var533 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var534 ) const {
516: return !@expr1073744727 (@expr1073744728 *@expr1073744729 this@expr1073744730 ==@expr1073744731 type@var534 ) ;
517: }
518: std :: string mType@var535 ;
519: bool mSigned@var536 ;
520: bool mUnsigned@var537 ;
521: bool mLong@var538 ;
522: bool mPointer@var539 ;
523: bool mPtrPtr@var540 ;
524: bool mConstPtr@var541 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var542 ) const {
529: const std ::@expr1073744732 map < std ::@expr1073744733 string , PlatformType > ::@expr1073744734 const_iterator it@var543 =@expr1073744735 mPlatformTypes@var545 .@expr1073744736 find (@expr1073744737 name@var542 ) ;
530: return (@expr2914 it@var543 !=@expr1073744739 mPlatformTypes@var545 .@expr1073744740 end (@expr1073744741 ) ) ?@expr1073744742 &@expr1073744743 (@expr2914 it@var543 .@expr1073744745 second@var544 ) :@expr1073744746 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var545 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var546 , const std :: string & platform@var547 ) const {
536: const std ::@expr1073744747 map < std ::@expr2924 string , Platform > ::@expr1073744749 const_iterator it@var548 =@expr1073744750 mPlatforms@var597 .@expr1073744751 find (@expr1073744752 platform@var547 ) ;
537: if (@expr1073744753 it@var548 !=@expr1073744754 mPlatforms@var597 .@expr1073744755 end (@expr1073744756 ) ) {
538: const PlatformType * const type@var549 ; type@var549 =@expr1073744757 it@var548 .@expr1073744758 second@var550 .@expr1073744759 platform_type (@expr1073744760 name@var546 ) ;
539: if (@expr1073744761 type@var549 ) {
540: return type@var549 ; }
541: }
542:
543: const std ::@expr1073744762 map < std ::@expr2924 string , PlatformType > ::@expr1073744764 const_iterator it2@var551 =@expr1073744765 mPlatformTypes@var596 .@expr1073744766 find (@expr1073744767 name@var546 ) ;
544: return (@expr2944 it2@var551 !=@expr1073744769 mPlatformTypes@var596 .@expr1073744770 end (@expr1073744771 ) ) ?@expr1073744772 &@expr1073744773 (@expr2944 it2@var551 .@expr1073744775 second@var552 ) :@expr1073744776 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var553 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var554 , Library :: Container :: Yield y@var555 , const std :: string & fallback@var556 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var557 , const std :: string & typeName@var558 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var559 , const std :: string & name@var560 , std :: set < std :: string > & unknown_elements@var561 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var562 ) {
565: mPrefixes@var566 .@expr1073744777 insert (@expr1073744778 prefix@var562 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var563 ) {
568: mSuffixes@var567 .@expr1073744779 insert (@expr1073744780 suffix@var563 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var564 ) const {
571: return (@expr1073744781 mPrefixes@var566 .@expr1073744782 find (@expr1073744783 prefix@var564 ) !=@expr1073744784 mPrefixes@var566 .@expr1073744785 end (@expr1073744786 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var565 ) const {
574: return (@expr1073744787 mSuffixes@var567 .@expr1073744788 find (@expr1073744789 suffix@var565 ) !=@expr1073744790 mSuffixes@var567 .@expr1073744791 end (@expr1073744792 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var566 ;
579: std :: set < std :: string > mSuffixes@var567 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var575 ( 0 ) { }
584:
585: void setStart ( const char * s@var568 ) {
586: mStart@var573 =@expr1073744793 s@var568 ;
587: }
588: void setEnd ( const char * e@var569 ) {
589: mEnd@var574 =@expr1073744794 e@var569 ;
590: }
591: void setOffset ( const int o@var570 ) {
592: mOffset@var575 =@expr1073744795 o@var570 ;
593: }
594: void addBlock ( const char * blockName@var571 ) {
595: mBlocks@var576 .@expr1073744796 insert (@expr1073744797 blockName@var571 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var573 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var574 ;
602: }
603: int offset ( ) const {
604: return mOffset@var575 ;
605: }
606: bool isBlock ( const std :: string & blockName@var572 ) const {
607: return mBlocks@var576 .@expr1073744798 find (@expr1073744799 blockName@var572 ) !=@expr1073744800 mBlocks@var576 .@expr1073744801 end (@expr1073744802 ) ;
608: }
609:
610: private:
611: std :: string mStart@var573 ;
612: std :: string mEnd@var574 ;
613: int mOffset@var575 ;
614: std :: set < std :: string > mBlocks@var576 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var577 ;
618: std :: set < std :: string > mFiles@var578 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var579 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var580 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var581 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var582 ;
623: std :: map < std :: string , std :: string > mReturnValue@var583 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var584 ;
625: std :: map < std :: string , int > mReturnValueContainer@var585 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var586 ;
627: std :: map < std :: string , bool > mReportErrors@var587 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var588 ;
629: std :: set < std :: string > mMarkupExtensions@var589 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var590 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var591 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var592 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var593 ;
634: std :: map < std :: string , int > mReflection@var594 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var595 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var596 ;
637: std :: map < std :: string , Platform > mPlatforms@var597 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var598 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var599 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var600 , int argnr@var601 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var602 , bool * error@var603 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var604 , const std :: string & name@var605 ) {
646: const std ::@expr1073744803 map < std ::@expr1073744804 string , AllocFunc > ::@expr1073744805 const_iterator it@var606 =@expr1073744806 data@var604 .@expr1073744807 find (@expr1073744808 name@var605 ) ;
647: return (@expr1073744809 it@var606 ==@expr1073744810 data@var604 .@expr1073744811 end (@expr1073744812 ) ) ?@expr1073744813 nullptr :@expr1073744814 &@expr1073744815 it@var606 .@expr1073744816 second@var607 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var608 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var609 ,
654: const Settings * settings@var610 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var611 = nullptr ) ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var612 ;
43: std :: string errorId@var613 ;
44: void setFileName ( const std :: string & s@var614 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var618 ;
47: }
48: int lineNumber@var615 ;
49: Certainty :: CertaintyLevel certainty@var616 ;
50: std :: string symbolNames@var617 ;
51: private:
52: std :: string mFileName@var618 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var652 ( NO_LINE ) , hash@var654 ( 0 ) , thisAndNextLine@var655 ( false ) , matched@var656 ( false ) , checked@var657 ( false ) { }
57: Suppression ( const Suppression & other@var619 ) {
58: *@expr1073744817 this@expr1073744818 =@expr1073744819 other@var619 ;
59: }
60: Suppression ( const std :: string & id@var620 , const std :: string & file@var621 , int line@var622 = NO_LINE ) : errorId@var650 ( id@var620 ) , fileName@var651 ( file@var621 ) , lineNumber@var652 ( line@var622 ) , hash@var654 ( 0 ) , thisAndNextLine@var655 ( false ) , matched@var656 ( false ) , checked@var657 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var623 ) {
63: errorId@var650 =@expr1073744820 other@var623 .@expr1073744821 errorId@var624 ;
64: fileName@var651 =@expr1073744822 other@var623 .@expr1073744823 fileName@var625 ;
65: lineNumber@var652 =@expr1073744824 other@var623 .@expr1073744825 lineNumber@var626 ;
66: symbolName@var653 =@expr1073744826 other@var623 .@expr1073744827 symbolName@var627 ;
67: hash@var654 =@expr1073744828 other@var623 .@expr1073744829 hash@var628 ;
68: thisAndNextLine@var655 =@expr1073744830 other@var623 .@expr1073744831 thisAndNextLine@var629 ;
69: matched@var656 =@expr1073744832 other@var623 .@expr1073744833 matched@var630 ;
70: checked@var657 =@expr1073744834 other@var623 .@expr1073744835 checked@var631 ;
71: return *@expr1073744836 this@expr1073744837 ;
72: }
73:
74: bool operator< ( const Suppression & other@var632 ) const {
75: if (@expr1073744838 errorId@var650 !=@expr1073744839 other@var632 .@expr3016 errorId@var633 ) {
76: return errorId@var650 <@expr1073744841 other@var632 .@expr3016 errorId@var633 ; }
77: if (@expr1073744843 lineNumber@var652 <@expr1073744844 other@var632 .@expr1073744845 lineNumber@var634 ) {
78: return true ; }
79: if (@expr1073744846 fileName@var651 !=@expr1073744847 other@var632 .@expr3024 fileName@var635 ) {
80: return fileName@var651 <@expr1073744849 other@var632 .@expr3024 fileName@var635 ; }
81: if (@expr1073744851 symbolName@var653 !=@expr1073744852 other@var632 .@expr3029 symbolName@var636 ) {
82: return symbolName@var653 <@expr1073744854 other@var632 .@expr3029 symbolName@var636 ; }
83: if (@expr1073744856 hash@var654 !=@expr1073744857 other@var632 .@expr3034 hash@var637 ) {
84: return hash@var654 <@expr1073744859 other@var632 .@expr3034 hash@var637 ; }
85: if (@expr1073744861 thisAndNextLine@var655 !=@expr1073744862 other@var632 .@expr1073744863 thisAndNextLine@var638 ) {
86: return thisAndNextLine@var655 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var639 , std :: string * errorMessage@var640 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var641 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var642 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073744865 fileName@var651 .@expr1073744866 empty (@expr1073744867 ) &&@expr1073744868 fileName@var651 .@expr1073744869 find_first_of (@expr1073744870 "?*" ) ==@expr1073744871 std ::@expr1073744872 string ::@expr1073744873 npos@expr1073744864 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var643 ) const {
109: return errorId@var650 ==@expr1073744874 other@var643 .@expr1073744875 errorId@var644 &&@expr1073744876
110: fileName@var651 ==@expr1073744877 other@var643 .@expr1073744878 fileName@var645 &&@expr1073744879
111: lineNumber@var652 ==@expr1073744880 other@var643 .@expr1073744881 lineNumber@var646 &&@expr1073744882
112: symbolName@var653 ==@expr1073744883 other@var643 .@expr1073744884 symbolName@var647 &&@expr1073744885
113: hash@var654 ==@expr1073744886 other@var643 .@expr1073744887 hash@var648 &&@expr1073744888
114: thisAndNextLine@var655 ==@expr1073744889 other@var643 .@expr1073744890 thisAndNextLine@var649 ;
115: }
116:
117: std :: string errorId@var650 ;
118: std :: string fileName@var651 ;
119: int lineNumber@var652 ;
120: std :: string symbolName@var653 ;
121: unsigned long hash@var654 ;
122: bool thisAndNextLine@var655 ;
123: bool matched@var656 ;
124: bool checked@var657 ;
125:
126: enum Anonymous1 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var658 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var659 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var660 , std :: string * errorMessage@var661 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var662 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var663 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var664 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var665 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var666 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var667 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var668 , const bool unusedFunctionChecking@var669 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var670 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var671 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var672 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var673 , std :: clock_t clocks@var674 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var675 ;
45: long mNumberOfResults@var676 ;
46:
47: TimerResultsData ( )
48: : mClocks@var675 ( 0 )
49: , mNumberOfResults@var676 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var677 =@expr1073744892 (@expr1073744893 double ) (@expr1073744894 (@expr1073744895 unsigned long ) mClocks@var675 ) /@expr1073744896 (@expr1073744897 double ) CLOCKS_PER_SEC@expr1073744891 ;
53: return ret@var677 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var678 ) const ;
62: void addResults ( const std :: string & str@var679 , std :: clock_t clocks@var680 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var681 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var682 , SHOWTIME_MODES showtimeMode@var683 , TimerResultsIntf * timerResults@var684 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var685 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var686 ;
79: TimerResultsIntf * mTimerResults@var687 ;
80: std :: clock_t mStart@var688 ;
81: const SHOWTIME_MODES mShowTimeMode@var689 ;
82: bool mStopped@var690 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var691 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var692 ;
103:
104:
105: std :: string addonPython@var693 ;
106:
107:
108: std :: vector < std :: string > basePaths@var694 ;
109:
110:
111: std :: string buildDir@var695 ;
112:
113:
114: bool checkAllConfigurations@var696 ;
115:
116:
117: bool checkConfiguration@var697 ;
118:
|
121:
122: bool checkHeaders@var698 ;
123:
124:
125: bool checkLibrary@var699 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var700 ;
129:
130:
131: bool checkUnusedTemplates@var701 ;
132:
133:
134: bool clang@var702 ;
135:
136:
137: std :: string clangExecutable@var703 ;
138:
139:
140: bool clangTidy@var704 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var705 ;
144:
145:
146: std :: string cppcheckCfgProductName@var706 ;
147:
148:
149: std :: string cppcheckCfgAbout@var707 ;
150:
151:
152: bool daca@var708 ;
153:
154:
155: bool debugnormal@var709 ;
156:
157:
158: bool debugSimplified@var710 ;
159:
160:
161: bool debugtemplate@var711 ;
162:
163:
164: bool debugwarnings@var712 ;
165:
166:
167: bool dump@var713 ;
168: std :: string dumpFile@var714 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var715 ;
176:
177:
178: bool exceptionHandling@var716 ;
179:
180:
181: std :: string exename@var717 ;
182:
183:
184:
185: int exitCode@var718 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var719 ;
189:
190:
191: bool force@var720 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var721 ;
196:
197:
198: bool inlineSuppressions@var722 ;
199:
200:
201:
202: unsigned int jobs@var723 ;
203:
|
206:
207: bool jointSuppressionReport@var724 ;
208:
209:
210: std :: list < std :: string > libraries@var725 ;
211:
212:
213: Library library@var726 ;
214:
215:
216:
217: int loadAverage@var727 ;
218:
|
221:
222: int maxConfigs@var728 ;
223:
224:
225: int maxCtuDepth@var729 ;
226:
227:
228: int maxTemplateRecursion@var730 ;
229:
230:
231: Suppressions nofail@var731 ;
232:
233:
234: Suppressions nomsg@var732 ;
235:
236:
237: std :: string outputFile@var733 ;
238:
239:
240: std :: string plistOutput@var734 ;
241:
242:
243: bool preprocessOnly@var735 ;
244:
245: ImportProject project@var736 ;
246:
247:
248: bool quiet@var737 ;
249:
250:
251: bool relativePaths@var738 ;
252:
253:
254: bool reportProgress@var739 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var740 ( "simple" )
261: , id@var742 ( "rule" )
262: , severity@var744 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var740 ;
266: std :: string pattern@var741 ;
267: std :: string id@var742 ;
268: std :: string summary@var743 ;
269: Severity :: SeverityType severity@var744 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var745 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var751 ( false ) , externalFunctions@var752 ( false ) , internalFunctions@var753 ( false ) , externalVariables@var754 ( false ) { }
281:
282: static const char XmlRootName@var746 [ ] ;
283: static const char XmlClasses@var747 [ ] ;
284: static const char XmlExternalFunctions@var748 [ ] ;
285: static const char XmlInternalFunctions@var749 [ ] ;
286: static const char XmlExternalVariables@var750 [ ] ;
287:
288: void clear ( ) {
289: classes@var751 =@expr1073744898 externalFunctions@var752 =@expr1073744899 internalFunctions@var753 =@expr1073744900 externalVariables@var754 =@expr1073744901 false ;
290: }
291:
|
297:
298: bool classes@var751 ;
299:
|
304:
305: bool externalFunctions@var752 ;
306:
|
310:
311: bool internalFunctions@var753 ;
312:
|
316:
317: bool externalVariables@var754 ;
318: } ;
319:
320: SafeChecks safeChecks@var755 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var756 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var757 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var758 ;
325:
326:
327: SHOWTIME_MODES showtime@var759 ;
328:
329:
330: Standards standards@var760 ;
331:
332:
333:
334: std :: string templateFormat@var761 ;
335:
336:
337:
338: std :: string templateLocation@var762 ;
339:
340:
341: std :: string userDefines@var763 ;
342:
343:
344: std :: set < std :: string > userUndefs@var764 ;
345:
346:
347: std :: list < std :: string > userIncludes@var765 ;
348:
349:
350: bool verbose@var766 ;
351:
352:
353: bool xml@var767 ;
354:
355:
356: int xml_version@var768 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var769 ) const {
363: for (@expr1073744902 const std ::@expr1073744903 string &@expr1073744904 configExcludePath@var770 :@expr1073744905 configExcludePaths@var705 ) {
364: if (@expr1073744906 file@var769 .@expr1073744907 length (@expr1073744908 ) >=@expr1073744909 configExcludePath@var770 .@expr3086 length (@expr3087 ) &&@expr1073744912 file@var769 .@expr1073744913 compare (@expr1073744914 0 , configExcludePath@var770 .@expr3086 length (@expr3087 ) , configExcludePath@var770 ) ==@expr1073744917 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var771 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var772 , bool inconclusiveCheck@var773 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073744918 find (@expr1073744919 libraries@var725 .@expr1073744920 begin (@expr1073744921 ) , libraries@var725 .@expr3098 end (@expr3099 ) , "posix" ) !=@expr1073744924 libraries@var725 .@expr3098 end (@expr3099 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var774 = true ) {
392: Settings ::@expr1073744927 mTerminated@var691 =@expr1073744928 t@var774 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073744929 mTerminated@var691 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var775 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var776 ) const {
54: x@var776 ++@expr1073744930 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var777 ) const {
60: x@var777 --@expr1073744931 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var778 , const U & y@var779 ) const {
67: return x@var778 <@expr1073744932 y@var779 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var780 , const U & y@var781 ) const {
74: return std ::@expr1073744933 abs (@expr1073744934 x@var780 -@expr1073744935 y@var781 ) ==@expr1073744936 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var782 , T x@var783 , U y@var784 ) const {
81: result@var782 =@expr1073744937 !@expr1073744938 (@expr1073744939 x@var783 >@expr1073744940 y@var784 ||@expr1073744941 x@var783 <@expr1073744942 y@var784 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var785 = 0 , Bound b@var786 = Bound :: Point )
91: : valueType@var826 ( ValueType :: INT ) ,
92: bound@var827 ( b@var786 ) ,
93: intvalue@var828 ( val@var785 ) ,
94: tokvalue@var829 ( nullptr ) ,
95: floatValue@var830 ( 0.0 ) ,
96: moveKind@var831 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var832 ( val@var785 ) ,
98: condition@var833 ( nullptr ) ,
99: varId@var835 ( 0U ) ,
100: safe@var836 ( false ) ,
101: conditional@var837 ( false ) ,
102: macro@var838 ( false ) ,
103: defaultArg@var839 ( false ) ,
104: indirect@var840 ( 0 ) ,
105: path@var841 ( 0 ) ,
106: wideintvalue@var842 ( val@var785 ) ,
107: subexpressions@var843 ( ) ,
108: capturetok@var844 ( nullptr ) ,
109: lifetimeKind@var845 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var846 ( LifetimeScope :: Local ) ,
111: valueKind@var851 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var787 , long long val@var788 , Bound b@var789 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var790 ) const {
118: if (@expr1073744943 valueType@var826 !=@expr1073744944 rhs@var790 .@expr1073744945 valueType@var791 ) {
119: return false ; }
120: switch (@expr1073744946 valueType@var826 ) {
121: case ValueType ::@expr1073744947 INT :@expr3124
122: case ValueType ::@expr1073744949 CONTAINER_SIZE :@expr3124
123: case ValueType ::@expr1073744951 BUFFER_SIZE :@expr3124
124: case ValueType ::@expr1073744953 ITERATOR_START :@expr3124
125: case ValueType ::@expr1073744955 ITERATOR_END :@expr3124 ;
126: if (@expr3133 intvalue@var828 !=@expr3134 rhs@var790 .@expr3135 intvalue@var792 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744960 TOK :@expr3124 ;
130: if (@expr3138 tokvalue@var829 !=@expr3139 rhs@var790 .@expr3140 tokvalue@var793 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744965 FLOAT :@expr3124 ;
134:
135: if (@expr1073744967 floatValue@var830 >@expr1073744968 rhs@var790 .@expr3145 floatValue@var794 ||@expr1073744970 floatValue@var830 <@expr1073744971 rhs@var790 .@expr3145 floatValue@var794 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744973 MOVED :@expr3124 ;
139: if (@expr1073744975 moveKind@var831 !=@expr1073744976 rhs@var790 .@expr1073744977 moveKind@var795 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744978 UNINIT :@expr3124 ;
143: break ;
144: case ValueType ::@expr1073744980 LIFETIME :@expr3124 ;
145: if (@expr3138 tokvalue@var829 !=@expr3139 rhs@var790 .@expr3140 tokvalue@var793 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744985 SYMBOLIC :@expr3124 ;
149: if (@expr1073744987 !@expr1073744988 sameToken (@expr1073744989 tokvalue@var829 , rhs@var790 .@expr3140 tokvalue@var793 ) ) {
150: return false ; }
151: if (@expr3133 intvalue@var828 !=@expr3134 rhs@var790 .@expr3135 intvalue@var792 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var796 , F f@var797 ) {
160: switch (@expr1073744994 self@var796 .@expr1073744995 valueType@var798 ) {
161: case ValueType ::@expr1073744996 INT :@expr3173
162: case ValueType ::@expr1073744998 SYMBOLIC :@expr3173
163: case ValueType ::@expr1073745000 BUFFER_SIZE :@expr3173
164: case ValueType ::@expr1073745002 CONTAINER_SIZE :@expr3173
165: case ValueType ::@expr1073745004 ITERATOR_START :@expr3173
166: case ValueType ::@expr1073745006 ITERATOR_END :@expr3173 ; {
167: f@var797 (@expr1073745008 self@var796 .@expr1073745009 intvalue@var799 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073745010 FLOAT :@expr3173 ; {
171: f@var797 (@expr1073745012 self@var796 .@expr1073745013 floatValue@var800 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073745014 UNINIT :@expr3173
175: case ValueType ::@expr1073745016 TOK :@expr3173
176: case ValueType ::@expr1073745018 LIFETIME :@expr3173
177: case ValueType ::@expr1073745020 MOVED :@expr3173 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var801 , Compare compare@var802 , T x@var803 , U y@var804 ) const {
186: result@var801 =@expr1073745022 compare@var802 (@expr1073745023 x@var803 , y@var804 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var805 , const Value & rhs@var806 , Compare compare@var807 , T x@var808 ) const {
191: visitValue (@expr1073745025 rhs@var806 ,
192: std ::@expr1073745026 bind (@expr1073745027 innerVisitor {@expr1073745028 } , std ::@expr1073745029 ref (@expr1073745030 result@var805 ) , std ::@expr1073745031 move (@expr1073745032 compare@var807 ) , x@var808 , std ::@expr1073745033 placeholders ::@expr1073745034 _1@expr1073745024 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var809 , Compare compare@var810 ) const {
198: assert (@expr1073745036 (@expr1073745037 !@expr1073745038 this@expr3215 .@expr1073745040 isSymbolicValue (@expr1073745041 ) &&@expr1073745042 !@expr1073745043 rhs@var809 .@expr1073745044 isSymbolicValue (@expr1073745045 ) ) ||@expr1073745046
199: (@expr1073745047 this@expr3215 .@expr1073745048 valueType@var826 ==@expr1073745049 rhs@var809 .@expr1073745050 valueType@var811 &&@expr1073745051 sameToken (@expr1073745052 this@expr3215 .@expr1073745053 tokvalue@var829 , rhs@var809 .@expr1073745054 tokvalue@var812 ) ) ) ;
200: bool result@var813 ; result@var813 =@expr1073745055 false ;
201: visitValue (@expr1073745056
202: *@expr1073745057 this@expr3215 ,
203: std ::@expr1073745058 bind (@expr1073745059 compareVisitor {@expr1073745060 } , std ::@expr3237 ref (@expr1073745062 result@var813 ) , std ::@expr3237 ref (@expr1073745064 rhs@var809 ) , std ::@expr1073745065 move (@expr1073745066 compare@var810 ) , std ::@expr1073745067 placeholders ::@expr1073745068 _1@expr1073745035 ) ) ;
204: return result@var813 ;
205: }
206:
207: bool operator== ( const Value & rhs@var814 ) const {
208: if (@expr1073745069 !@expr1073745070 equalValue (@expr1073745071 rhs@var814 ) ) {
209: return false ; }
210:
211: return varvalue@var832 ==@expr1073745072 rhs@var814 .@expr1073745073 varvalue@var815 &&@expr1073745074
212: condition@var833 ==@expr1073745075 rhs@var814 .@expr1073745076 condition@var816 &&@expr1073745077
213: varId@var835 ==@expr1073745078 rhs@var814 .@expr1073745079 varId@var817 &&@expr1073745080
214: conditional@var837 ==@expr1073745081 rhs@var814 .@expr1073745082 conditional@var818 &&@expr1073745083
215: defaultArg@var839 ==@expr1073745084 rhs@var814 .@expr1073745085 defaultArg@var819 &&@expr1073745086
216: indirect@var840 ==@expr1073745087 rhs@var814 .@expr1073745088 indirect@var820 &&@expr1073745089
217: valueKind@var851 ==@expr1073745090 rhs@var814 .@expr1073745091 valueKind@var821 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var822 ) const {
221: return !@expr1073745092 (@expr1073745093 *@expr1073745094 this@expr1073745095 ==@expr1073745096 rhs@var822 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var823 ) const {
226: bool result@var824 ; result@var824 =@expr1073745098 false ;
227: visitValue (@expr1073745099 *@expr1073745100 this@expr1073745101 , std ::@expr1073745102 bind (@expr1073745103 equalVisitor {@expr1073745104 } , std ::@expr1073745105 ref (@expr1073745106 result@var824 ) , x@var823 , std ::@expr1073745107 placeholders ::@expr1073745108 _1@expr1073745097 ) ) ;
228: return result@var824 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073745109 bound@var827 ==@expr1073745110 Bound ::@expr1073745111 Lower ) {
233: visitValue (@expr1073745112 *@expr3289 this@expr3290 , increment {@expr1073745115 } ) ; }
234: else { if (@expr1073745116 bound@var827 ==@expr1073745117 Bound ::@expr1073745118 Upper ) {
235: visitValue (@expr1073745119 *@expr3289 this@expr3290 , decrement {@expr1073745121 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073745122 bound@var827 ==@expr1073745123 Bound ::@expr3300 Lower ) {
240: bound@var827 =@expr1073745125 Bound ::@expr3302 Upper ; }
241: else { if (@expr1073745127 bound@var827 ==@expr1073745128 Bound ::@expr3302 Upper ) {
242: bound@var827 =@expr1073745130 Bound ::@expr3300 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073745132 ) ;
247: decreaseRange (@expr1073745133 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var825 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var826 ;
267: bool isIntValue ( ) const {
268: return valueType@var826 ==@expr1073745134 ValueType ::@expr1073745135 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var826 ==@expr1073745136 ValueType ::@expr1073745137 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var826 ==@expr1073745138 ValueType ::@expr1073745139 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var826 ==@expr1073745140 ValueType ::@expr1073745141 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var826 ==@expr1073745142 ValueType ::@expr1073745143 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var826 ==@expr1073745144 ValueType ::@expr1073745145 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var826 ==@expr1073745146 ValueType ::@expr1073745147 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var826 ==@expr1073745148 ValueType ::@expr1073745149 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var826 ==@expr1073745150 ValueType ::@expr1073745151 ITERATOR_START ||@expr1073745152 valueType@var826 ==@expr1073745153 ValueType ::@expr1073745154 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var826 ==@expr1073745155 ValueType ::@expr1073745156 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var826 ==@expr1073745157 ValueType ::@expr1073745158 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var826 ==@expr1073745159 ValueType ::@expr1073745160 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var826 ==@expr1073745162 ValueType ::@expr1073745163 LIFETIME &&@expr1073745164 lifetimeScope@var846 ==@expr1073745165 LifetimeScope ::@expr1073745166 Local@expr1073745161 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var826 ==@expr1073745167 ValueType ::@expr1073745168 LIFETIME &&@expr1073745169 lifetimeScope@var846 ==@expr1073745170 LifetimeScope ::@expr1073745171 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var826 ==@expr1073745172 ValueType ::@expr1073745173 LIFETIME &&@expr1073745174 lifetimeScope@var846 ==@expr1073745175 LifetimeScope ::@expr1073745176 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073745177 ) ||@expr1073745178 isUninitValue (@expr1073745179 ) ||@expr1073745180 isLifetimeValue (@expr1073745181 ) ;
318: }
319:
320:
321: Bound bound@var827 ;
322:
323:
324: long long intvalue@var828 ;
325:
326:
327: const Token * tokvalue@var829 ;
328:
329:
330: double floatValue@var830 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var831 ;
334:
335:
336: long long varvalue@var832 ;
337:
338:
339: const Token * condition@var833 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var834 ;
342:
343:
344: int varId@var835 ;
345:
346:
347: bool safe@var836 ;
348:
349:
350: bool conditional@var837 ;
351:
352:
353: bool macro@var838 ;
354:
355:
356: bool defaultArg@var839 ;
357:
358: int indirect@var840 ;
359:
360:
361: long long path@var841 ;
362:
363:
364: long long wideintvalue@var842 ;
365:
366: std :: vector < std :: string > subexpressions@var843 ;
367:
368:
369: const Token * capturetok@var844 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var845 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var846 ;
385:
386: static const char * toString ( MoveKind moveKind@var847 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var848 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var849 ) ;
389: static const char * toString ( Bound bound@var850 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var851 ;
402:
403: void setKnown ( ) {
404: valueKind@var851 =@expr1073745182 ValueKind ::@expr1073745183 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var851 ==@expr1073745184 ValueKind ::@expr1073745185 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var851 =@expr1073745187 ValueKind ::@expr1073745188 Possible@expr1073745186 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var851 ==@expr1073745190 ValueKind ::@expr1073745191 Possible@expr1073745189 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var851 ==@expr1073745192 ValueKind ::@expr1073745193 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var851 =@expr1073745194 ValueKind ::@expr1073745195 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var852 = true ) {
428: if (@expr1073745196 inconclusive@var852 ) {
429: valueKind@var851 =@expr1073745197 ValueKind ::@expr1073745198 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var851 ==@expr1073745199 ValueKind ::@expr1073745200 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073745202 isKnown (@expr1073745203 ) ) {
438: valueKind@var851 =@expr1073745204 ValueKind ::@expr1073745205 Possible@expr1073745201 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073745206 condition@var833 &&@expr1073745207 !@expr1073745208 defaultArg@var839 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var853 , const Token * tok2@var854 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var855 , const Settings * settings@var856 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var857 , SymbolDatabase * symboldatabase@var858 , ErrorLogger * errorLogger@var859 , const Settings * settings@var860 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var861 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var862 , const Settings * settings@var863 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var864 ,
459: const Settings * settings@var865 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var866 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var867 , const Token * indexTok@var868 , bool possible@var869 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var870 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var871 , const Settings * settings@var872 = nullptr , int depth@var873 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var874 ;
471: bool addressOf@var875 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var876 ;
473: bool inconclusive@var877 ;
474:
475: LifetimeToken ( ) : token@var874 ( nullptr ) , addressOf@var875 ( false ) , errorPath@var876 ( ) , inconclusive@var877 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var878 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var879 )
478: : token@var874 ( token@var878 ) , addressOf@var875 ( false ) , errorPath@var876 ( std :: move ( errorPath@var879 ) ) , inconclusive@var877 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var880 , bool addressOf@var881 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var882 )
482: : token@var874 ( token@var880 ) , addressOf@var875 ( addressOf@var881 ) , errorPath@var876 ( std :: move ( errorPath@var882 ) ) , inconclusive@var877 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var883 , bool b@var884 ) {
486: for (@expr1073745209 LifetimeToken &@expr1073745210 x@var885 :@expr1073745211 v@var883 ) {
487: x@var885 .@expr1073745212 addressOf@var886 =@expr1073745213 b@var884 ; }
488: return v@var883 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var887 , bool b@var888 ) {
492: for (@expr1073745214 LifetimeToken &@expr1073745215 x@var889 :@expr1073745216 v@var887 ) {
493: x@var889 .@expr1073745217 inconclusive@var890 =@expr1073745218 b@var888 ; }
494: return v@var887 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var891 , ValueFlow :: Value & true_value@var892 , ValueFlow :: Value & false_value@var893 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var894 ) ;
499: const Token * parseCompareInt ( const Token * tok@var895 , ValueFlow :: Value & true_value@var896 , ValueFlow :: Value & false_value@var897 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var898 , long long val@var899 , const Token * varTok@var900 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var901 , const Token * varTok@var902 , long long val@var903 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var904 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var905 ,
508: ValueFlow :: Value & value@var906 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var907 ,
511: bool escape@var908 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var909 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var910 , const Token * lifetime@var911 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var912 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var913 , bool * addressOf@var914 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var915 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var916 , const Settings * settings@var917 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var918 , const ValueFlow :: Value * val@var919 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var920 , const ValueFlow :: Value * val@var921 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var922 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var923 , bool inconclusive@var924 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var925 ,
529: bool inconclusive@var926 = false ,
530: long long path@var927 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var928 , const Scope * defaultScope@var929 = nullptr , bool smallest@var930 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var931 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var932 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var933 ;
69: std :: string mScope@var934 ;
70: std :: string mName@var935 ;
71: std :: string mFullName@var936 ;
72: const Token * mNameToken@var937 ;
73: const Token * mParamEnd@var938 ;
74: unsigned int mFlags@var939 ;
75:
76: enum Anonymous2 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var940 ) {
90: setFlag (@expr1073745219 fIsClass , state@var940 ) ;
91: }
92: void isFunction ( bool state@var941 ) {
93: setFlag (@expr1073745220 fIsFunction , state@var941 ) ;
94: }
95: void isVariable ( bool state@var942 ) {
96: setFlag (@expr1073745221 fIsVariable , state@var942 ) ;
97: }
98: void isAlias ( bool state@var943 ) {
99: setFlag (@expr1073745222 fIsAlias , state@var943 ) ;
100: }
101: void isSpecialization ( bool state@var944 ) {
102: setFlag (@expr1073745223 fIsSpecialization , state@var944 ) ;
103: }
104: void isPartialSpecialization ( bool state@var945 ) {
105: setFlag (@expr1073745224 fIsPartialSpecialization , state@var945 ) ;
106: }
107: void isForwardDeclaration ( bool state@var946 ) {
108: setFlag (@expr1073745225 fIsForwardDeclaration , state@var946 ) ;
109: }
110: void isVariadic ( bool state@var947 ) {
111: setFlag (@expr1073745226 fIsVariadic , state@var947 ) ;
112: }
113: void isFriend ( bool state@var948 ) {
114: setFlag (@expr1073745227 fIsFriend , state@var948 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var949 ) const {
123: return (@expr3404 (@expr3404 mFlags@var939 &@expr1073745230 flag@var949 ) !=@expr1073745231 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var950 , bool state@var951 ) {
132: mFlags@var939 =@expr1073745232 state@var951 ?@expr1073745233 mFlags@var939 |@expr1073745234 flag@var950 :@expr1073745235 mFlags@var939 &@expr1073745236 ~@expr1073745237 flag@var950 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var952 , const std :: string & scope@var953 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var954 , const std :: string & scope@var955 , const Token * nameToken@var956 , const Token * paramEnd@var957 ) ;
150: TokenAndName ( const TokenAndName & other@var958 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var959 ) const {
154: return mToken@var933 ==@expr1073745238 rhs@var959 .@expr1073745239 mToken@var960 &&@expr1073745240 mScope@var934 ==@expr1073745241 rhs@var959 .@expr1073745242 mScope@var961 &&@expr1073745243 mName@var935 ==@expr1073745244 rhs@var959 .@expr1073745245 mName@var962 &&@expr1073745246 mFullName@var936 ==@expr1073745247 rhs@var959 .@expr1073745248 mFullName@var963 &&@expr1073745249
155: mNameToken@var937 ==@expr1073745250 rhs@var959 .@expr1073745251 mNameToken@var964 &&@expr1073745252 mParamEnd@var938 ==@expr1073745253 rhs@var959 .@expr1073745254 mParamEnd@var965 &&@expr1073745255 mFlags@var939 ==@expr1073745256 rhs@var959 .@expr1073745257 mFlags@var966 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var933 ;
160: }
161: void token ( Token * token@var967 ) {
162: mToken@var933 =@expr1073745258 token@var967 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var934 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var935 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var936 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var937 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var938 ;
178: }
179: void paramEnd ( const Token * end@var968 ) {
180: mParamEnd@var938 =@expr1073745259 end@var968 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745260 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745261 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745262 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745263 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745264 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745265 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745266 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745267 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745268 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var969 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var970 ) const {
243:
244:
245: return (@expr3445 (@expr3445 mFlags@var939 &@expr1073745271 fFamilyMask ) &@expr1073745272 (@expr3445 decl@var970 .@expr1073745274 mFlags@var971 &@expr1073745275 fFamilyMask ) ) !=@expr1073745276 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var972 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var973 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var974 , const unsigned long numberOfArguments@var975 , bool variadic@var976 , const char patternAfter@var977 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var978 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var979 , int & namepos@var980 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var981 , int & namepos@var982 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var983 , int & namepos@var984 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var985 ,
306: bool & codeWithTemplates@var986 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var987 , bool isTemplate@var988 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var989 = nullptr , Token * backToken@var990 = nullptr , bool isTemplate@var991 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var992 , Token * end@var993 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var994 , const std :: string & scope@var995 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var996 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var997 ,
393: const std :: list < const Token * > & specializations@var998 ,
394: const std :: time_t maxtime@var999 ,
395: std :: set < std :: string > & expandedtemplates@var1000 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var1001 , const Token * tok@var1002 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1003 , const Token * tok@var1004 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var1005 ,
422: const TokenAndName & templateInstantiation@var1006 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var1007 ,
424: const std :: string & newName@var1008 ,
425: bool copy@var1009 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var1010 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1011 ,
435: const std :: string & newName@var1012 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var1013 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var1014 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var1015 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var1016 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var1017 ,
458: const Token * templateInstantiationNameToken@var1018 ,
459: const std :: list < const Token * > & specializations@var1019 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var1020 , const Token * end@var1021 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var1022 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var1023 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1024 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var1025 ,
487: const std :: string & indent@var1026 = "    " ) const ;
488: void printOut ( const std :: string & text@var1027 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var1028 ;
491: TokenList & mTokenList@var1029 ;
492: const Settings * mSettings@var1030 ;
493: ErrorLogger * mErrorLogger@var1031 ;
494: bool mChanged@var1032 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var1033 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var1034 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var1035 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var1036 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var1037 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var1038 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var1039 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var1040 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var1041 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var1042 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var1043 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1044 ;
57: Token * back@var1045 ;
58: const TokenList * list@var1046 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1047 , const Token * bodyEnd_@var1048 , const std :: set < std :: string > & usingNamespaces_@var1049 = std :: set < std :: string > ( ) ) : name@var1050 ( name_@var1047 ) , bodyEnd@var1051 ( bodyEnd_@var1048 ) , usingNamespaces@var1052 ( usingNamespaces_@var1049 ) { }
63: std :: string name@var1050 ;
64: const Token * const bodyEnd@var1051 ;
65: std :: set < std :: string > usingNamespaces@var1052 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1053 ;
70: int mFileIndex@var1054 ;
71: int mLineNumber@var1055 ;
72: int mColumn@var1056 ;
73: int mExprId@var1057 ;
74:
75:
76: Token * mAstOperand1@var1058 ;
77: Token * mAstOperand2@var1059 ;
78: Token * mAstParent@var1060 ;
79:
80:
81: const Scope * mScope@var1061 ;
82: union {
83: const Function * mFunction@var1062 ;
84: const Variable * mVariable@var1063 ;
85: const :: Type * mType@var1064 ;
86: const Enumerator * mEnumerator@var1065 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1066 ;
94:
|
97:
98: int mIndex@var1067 ;
99:
100:
101: std :: string * mOriginalName@var1068 ;
102:
103:
104: ValueType * mValueType@var1069 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1070 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1071 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1072 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1073 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1074 ;
119: long long value@var1075 ;
120: struct CppcheckAttributes * next@var1076 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1077 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1078 ;
126:
127:
128: unsigned char mBits@var1079 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1080 , long long value@var1081 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1082 , long long * value@var1083 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1053 ( 0 )
135: , mFileIndex@var1054 ( 0 )
136: , mLineNumber@var1055 ( 0 )
137: , mColumn@var1056 ( 0 )
138: , mExprId@var1057 ( 0 )
139: , mAstOperand1@var1058 ( nullptr )
140: , mAstOperand2@var1059 ( nullptr )
141: , mAstParent@var1060 ( nullptr )
142: , mScope@var1061 ( nullptr )
143: , mFunction@var1062 ( nullptr )
144: , mProgressValue@var1066 ( 0 )
145: , mIndex@var1067 ( 0 )
146: , mOriginalName@var1068 ( nullptr )
147: , mValueType@var1069 ( nullptr )
148: , mValues@var1070 ( nullptr )
149: , mTemplateSimplifierPointers@var1072 ( nullptr )
150: , mScopeInfo@var1073 ( nullptr )
151: , mCppcheckAttributes@var1077 ( nullptr )
152: , mCpp11init@var1078 ( Cpp11init :: UNKNOWN )
153: , mBits@var1079 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1084 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1085 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1086 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1087 ) {
199: mStr@var1299 =@expr1073745277 s@var1087 ;
200: mImpl@var1305 .@expr1073745278 mVarId@var1336 =@expr1073745279 0 ;
201:
202: update_property_info (@expr1073745280 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1088 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1299 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1089 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1090 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1091 ) const ;
236: Token * tokAt ( int index@var1092 ) {
237: return const_cast < Token *@expr3457 > (@expr1073745282 const_cast < const Token *@expr3457 > (@expr1073745284 this@expr1073745285 ) .@expr1073745286 tokAt (@expr1073745287 index@var1092 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1093 ) const ;
245: Token * linkAt ( int index@var1094 ) {
246: return const_cast < Token *@expr3464 > (@expr1073745289 const_cast < const Token *@expr3464 > (@expr1073745291 this@expr1073745292 ) .@expr1073745293 linkAt (@expr1073745294 index@var1094 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1095 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1096 , const char ( & pattern@var1097 ) [ count ] ) {
276: return simpleMatch (@expr1073745296 tok@var1096 , pattern@var1097 , count@expr1073745295 -@expr1073745297 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1098 , const char pattern@var1099 [ ] , unsigned long pattern_len@var1100 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1101 , const char pattern@var1102 [ ] , int varid@var1103 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1104 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1105 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1106 , const Settings * const settings@var1107 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1108 , long long index@var1109 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1305 .@expr1073745298 mValueType@var1337 ;
366: }
367: void setValueType ( ValueType * vt@var1110 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1111 ; top@var1111 =@expr1073745299 this@expr1073745300 ;
371: while (@expr1073745301 top@var1111 &&@expr1073745302 !@expr1073745303 Token ::@expr1073745304 Match (@expr1073745305 top@var1111 .@expr3482 astParent (@expr3483 ) , ",|(" ) ) {
372: top@var1111 =@expr1073745308 top@var1111 .@expr3482 astParent (@expr3483 ) ; }
373: return top@var1111 ?@expr1073745311 top@var1111 .@expr1073745312 mImpl@var1112 .@expr1073745313 mValueType@var1113 :@expr1073745314 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1303 ;
378: }
379: void tokType ( Token :: Type t@var1114 ) {
380: mTokType@var1303 =@expr1073745315 t@var1114 ;
381:
382: const bool memoizedIsName@var1115 =@expr1073745316 mTokType@var1303 ==@expr1073745317 eName ||@expr1073745318 mTokType@var1303 ==@expr1073745319 eType ||@expr1073745320 mTokType@var1303 ==@expr1073745321 eVariable ||@expr1073745322
383: mTokType@var1303 ==@expr1073745323 eFunction ||@expr1073745324 mTokType@var1303 ==@expr1073745325 eKeyword ||@expr1073745326 mTokType@var1303 ==@expr3503 eBoolean ||@expr1073745328
384: mTokType@var1303 ==@expr3505 eEnumerator ;
385: setFlag (@expr1073745330 fIsName , memoizedIsName@var1115 ) ;
386:
387: const bool memoizedIsLiteral@var1116 =@expr1073745331 mTokType@var1303 ==@expr1073745332 eNumber ||@expr1073745333 mTokType@var1303 ==@expr1073745334 eString ||@expr1073745335 mTokType@var1303 ==@expr1073745336 eChar ||@expr1073745337
388: mTokType@var1303 ==@expr3503 eBoolean ||@expr1073745339 mTokType@var1303 ==@expr1073745340 eLiteral ||@expr1073745341 mTokType@var1303 ==@expr3505 eEnumerator ;
389: setFlag (@expr1073745343 fIsLiteral , memoizedIsLiteral@var1116 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1303 ==@expr1073745344 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745345 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1304 ==@expr1073745346 fIsName &&@expr1073745347 mTokType@var1303 ==@expr1073745348 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745349 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1303 ==@expr1073745350 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1303 ==@expr1073745351 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745352 isConstOp (@expr1073745353 ) ||@expr1073745354
412: isAssignmentOp (@expr1073745355 ) ||@expr1073745356
413: mTokType@var1303 ==@expr1073745357 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745358 isArithmeticalOp (@expr1073745359 ) ||@expr1073745360
417: mTokType@var1303 ==@expr1073745361 eLogicalOp ||@expr1073745362
418: mTokType@var1303 ==@expr1073745363 eComparisonOp ||@expr1073745364
419: mTokType@var1303 ==@expr1073745365 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745366 ) ||@expr1073745367
423: mTokType@var1303 ==@expr1073745368 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1303 ==@expr1073745369 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1303 ==@expr1073745370 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1303 ==@expr1073745371 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1303 ==@expr1073745372 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1303 ==@expr1073745373 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745374 ) !=@expr1073745375 nullptr &&@expr1073745376 astOperand2 (@expr1073745377 ) !=@expr1073745378 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1117 ) const {
444: return s@var1117 ==@expr1073745379 mStr@var1299 &&@expr1073745380 astOperand1 (@expr1073745381 ) !=@expr1073745382 nullptr &&@expr1073745383 astOperand2 (@expr1073745384 ) ==@expr1073745385 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1304 ;
450: }
451: void flags ( const unsigned int flags_@var1118 ) {
452: mFlags@var1304 =@expr1073745386 flags_@var1118 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745387 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1119 ) {
458: setFlag (@expr1073745388 fIsUnsigned , sign@var1119 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745389 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1120 ) {
464: setFlag (@expr1073745390 fIsSigned , sign@var1120 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745391 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1121 ) {
470: setFlag (@expr1073745392 fIsPointerCompare , b@var1121 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745393 fIsLong ) ;
474: }
475: void isLong ( bool size@var1122 ) {
476: setFlag (@expr1073745394 fIsLong , size@var1122 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745395 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1123 ) {
482: setFlag (@expr1073745396 fIsStandardType , b@var1123 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745397 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1124 ) {
488: setFlag (@expr1073745398 fIsExpandedMacro , m@var1124 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745399 fIsCast ) ;
492: }
493: void isCast ( bool c@var1125 ) {
494: setFlag (@expr1073745400 fIsCast , c@var1125 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745401 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1126 ) {
500: setFlag (@expr1073745402 fIsAttributeConstructor , ac@var1126 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745403 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1127 ) {
506: setFlag (@expr1073745404 fIsAttributeDestructor , value@var1127 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745405 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1128 ) {
512: setFlag (@expr1073745406 fIsAttributeUnused , unused@var1128 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745407 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1129 ) {
518: setFlag (@expr1073745408 fIsAttributeUsed , unused@var1129 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745409 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1130 ) {
524: setFlag (@expr1073745410 fIsAttributePure , value@var1130 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745411 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1131 ) {
530: setFlag (@expr1073745412 fIsAttributeConst , value@var1131 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745413 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1132 ) {
536: setFlag (@expr1073745414 fIsAttributeNoreturn , value@var1132 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745415 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1133 ) {
542: setFlag (@expr1073745416 fIsAttributeNothrow , value@var1133 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745417 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1134 ) {
548: setFlag (@expr1073745418 fIsAttributePacked , value@var1134 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745419 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1135 ) {
554: setFlag (@expr1073745420 fIsAttributeNodiscard , value@var1135 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745421 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1136 ) {
560: setFlag (@expr1073745422 fIsAttributeMaybeUnused , value@var1136 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1137 , long long value@var1138 ) {
563: mImpl@var1305 .@expr1073745423 setCppcheckAttribute (@expr1073745424 type@var1137 , value@var1138 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1139 , long long * value@var1140 ) const {
566: return mImpl@var1305 .@expr1073745425 getCppcheckAttribute (@expr1073745426 type@var1139 , value@var1140 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745427 mImpl@var1305 .@expr1073745428 mCppcheckAttributes@var1338 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745429 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745430 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1141 ) {
578: setFlag (@expr1073745431 fIsOperatorKeyword , value@var1141 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745432 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1142 ) {
584: setFlag (@expr1073745433 fIsComplex , value@var1142 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745434 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1143 ) {
590: setFlag (@expr1073745435 fIsEnumType , value@var1143 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745436 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1144 ) {
596: setFlag (@expr1073745437 fAtAddress , b@var1144 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745438 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1145 ) {
602: setFlag (@expr1073745439 fIncompleteVar , b@var1145 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745440 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1146 ) {
609: setFlag (@expr1073745441 fIsIncompleteConstant , b@var1146 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745442 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1147 ) {
616: setFlag (@expr1073745443 fConstexpr , b@var1147 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745444 fExternC ) ;
621: }
622: void isExternC ( bool b@var1148 ) {
623: setFlag (@expr1073745445 fExternC , b@var1148 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745446 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1149 ) {
630: setFlag (@expr1073745447 fIsSplitVarDeclComma , b@var1149 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745448 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1150 ) {
637: setFlag (@expr1073745449 fIsSplitVarDeclEq , b@var1150 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745450 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1151 ) {
644: setFlag (@expr1073745451 fIsImplicitInt , b@var1151 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745452 fIsInline ) ;
649: }
650: void isInline ( bool b@var1152 ) {
651: setFlag (@expr1073745453 fIsInline , b@var1152 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745454 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1153 ) {
658: setFlag (@expr1073745455 fIsRemovedVoidParameter , b@var1153 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745456 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1154 ) {
665: setFlag (@expr1073745457 fIsTemplate , b@var1154 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745458 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1155 ) {
672: setFlag (@expr1073745459 fIsSimplifedScope , b@var1155 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1305 .@expr1073745460 mBits@var1339 >@expr1073745461 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1305 .@expr1073745462 mBits@var1339 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1305 .@expr1073745463 mTemplateSimplifierPointers@var1340 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1156 ) {
685: if (@expr1073745464 !@expr1073745465 mImpl@var1305 .@expr3642 mTemplateSimplifierPointers@var1340 ) {
686: mImpl@var1305 .@expr3642 mTemplateSimplifierPointers@var1340 =@expr1073745468 new std ::@expr1073745469 set < TemplateSimplifier ::@expr1073745470 TokenAndName *@expr1073745471 > ; }
687: mImpl@var1305 .@expr3642 mTemplateSimplifierPointers@var1340 .@expr1073745473 insert (@expr1073745474 tokenAndName@var1156 ) ;
688: }
689: void setBits ( const unsigned char b@var1157 ) {
690: mImpl@var1305 .@expr1073745475 mBits@var1339 =@expr1073745476 b@var1157 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3653 (@expr3653 (@expr3653 mTokType@var1303 ==@expr1073745480 eString ) &&@expr1073745481 isPrefixStringCharLiteral (@expr1073745482 mStr@var1299 , '"' , "u8" ) ) ||@expr1073745483
695: (@expr3653 (@expr3653 mTokType@var1303 ==@expr1073745486 eChar ) &&@expr1073745487 isPrefixStringCharLiteral (@expr1073745488 mStr@var1299 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3665 (@expr3665 (@expr3665 mTokType@var1303 ==@expr1073745492 eString ) &&@expr1073745493 isPrefixStringCharLiteral (@expr1073745494 mStr@var1299 , '"' , "u" ) ) ||@expr1073745495
700: (@expr3665 (@expr3665 mTokType@var1303 ==@expr1073745498 eChar ) &&@expr1073745499 isPrefixStringCharLiteral (@expr1073745500 mStr@var1299 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3677 (@expr3677 (@expr3677 mTokType@var1303 ==@expr1073745504 eString ) &&@expr1073745505 isPrefixStringCharLiteral (@expr1073745506 mStr@var1299 , '"' , "U" ) ) ||@expr1073745507
705: (@expr3677 (@expr3677 mTokType@var1303 ==@expr1073745510 eChar ) &&@expr1073745511 isPrefixStringCharLiteral (@expr1073745512 mStr@var1299 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3689 (@expr3689 (@expr3689 mTokType@var1303 ==@expr1073745516 eString ) &&@expr1073745517 isPrefixStringCharLiteral (@expr1073745518 mStr@var1299 , '"' , "" ) ) ||@expr1073745519
710: (@expr3689 (@expr3689 mTokType@var1303 ==@expr1073745522 eChar ) &&@expr1073745523 isPrefixStringCharLiteral (@expr1073745524 mStr@var1299 , '\'' , "" ) &&@expr1073745525 mStr@var1299 .@expr1073745526 length (@expr1073745527 ) ==@expr1073745528 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3705 (@expr3705 (@expr3705 mTokType@var1303 ==@expr1073745532 eChar ) &&@expr1073745533 isPrefixStringCharLiteral (@expr1073745534 mStr@var1299 , '\'' , "" ) ) &&@expr1073745535
715: (@expr3705 mStr@var1299 .@expr1073745537 length (@expr1073745538 ) >@expr1073745539 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745540 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1158 ) {
738: setFlag (@expr1073745541 fIsTemplateArg , value@var1158 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1159 , const char ( & pattern@var1160 ) [ count ] ) {
743: return findsimplematch (@expr1073745543 startTok@var1159 , pattern@var1160 , count@expr1073745542 -@expr1073745544 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1161 , const char pattern@var1162 [ ] , unsigned long pattern_len@var1163 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1164 , const char ( & pattern@var1165 ) [ count ] , const Token * const end@var1166 ) {
749: return findsimplematch (@expr1073745546 startTok@var1164 , pattern@var1165 , count@expr1073745545 -@expr1073745547 1 , end@var1166 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1167 , const char pattern@var1168 [ ] , unsigned long pattern_len@var1169 , const Token * const end@var1170 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1171 , const char pattern@var1172 [ ] , const int varId@var1173 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1174 , const char pattern@var1175 [ ] , const Token * const end@var1176 , const int varId@var1177 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1178 , const char ( & pattern@var1179 ) [ count ] ) {
758: return findsimplematch (@expr1073745549 startTok@var1178 , pattern@var1179 , count@expr1073745548 -@expr1073745550 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1180 , const char pattern@var1181 [ ] , unsigned long pattern_len@var1182 ) {
761: return const_cast < Token *@expr3727 > (@expr1073745552 findsimplematch (@expr1073745553 const_cast < const Token *@expr3727 > (@expr1073745555 startTok@var1180 ) , pattern@var1181 , pattern_len@var1182 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1183 , const char ( & pattern@var1184 ) [ count ] , const Token * const end@var1185 ) {
765: return findsimplematch (@expr1073745557 startTok@var1183 , pattern@var1184 , count@expr1073745556 -@expr1073745558 1 , end@var1185 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1186 , const char pattern@var1187 [ ] , unsigned long pattern_len@var1188 , const Token * const end@var1189 ) {
768: return const_cast < Token *@expr3735 > (@expr1073745560 findsimplematch (@expr1073745561 const_cast < const Token *@expr3735 > (@expr1073745563 startTok@var1186 ) , pattern@var1187 , pattern_len@var1188 , end@var1189 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1190 , const char pattern@var1191 [ ] , const int varId@var1192 = 0 ) {
772: return const_cast < Token *@expr3740 > (@expr1073745565 findmatch (@expr1073745566 const_cast < const Token *@expr3740 > (@expr1073745568 startTok@var1190 ) , pattern@var1191 , varId@var1192 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1193 , const char pattern@var1194 [ ] , const Token * const end@var1195 , const int varId@var1196 = 0 ) {
775: return const_cast < Token *@expr3745 > (@expr1073745570 findmatch (@expr1073745571 const_cast < const Token *@expr3745 > (@expr1073745573 startTok@var1193 ) , pattern@var1194 , end@var1195 , varId@var1196 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1197 , const char * haystack@var1198 , int varid@var1199 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1305 .@expr1073745574 mFileIndex@var1341 ;
796: }
797: void fileIndex ( int indexOfFile@var1200 ) {
798: mImpl@var1305 .@expr1073745575 mFileIndex@var1341 =@expr1073745576 indexOfFile@var1200 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1305 .@expr1073745577 mLineNumber@var1342 ;
803: }
804: void linenr ( int lineNumber@var1201 ) {
805: mImpl@var1305 .@expr1073745578 mLineNumber@var1342 =@expr1073745579 lineNumber@var1201 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1305 .@expr1073745580 mColumn@var1343 ;
810: }
811: void column ( int c@var1202 ) {
812: mImpl@var1305 .@expr1073745581 mColumn@var1343 =@expr1073745582 c@var1202 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1300 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1203 , const Token * end@var1204 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1205 , const std :: string & originalNameStr@var1206 = emptyString@var3 , bool prepend@var1207 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1208 , const std :: string & originalNameStr@var1209 = emptyString@var3 )
840: {
841: return insertToken (@expr1073745583 tokenStr@var1208 , originalNameStr@var1209 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1301 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1305 .@expr1073745584 mVarId@var1336 ;
851: }
852: void varId ( int id@var1210 ) {
853: mImpl@var1305 .@expr1073745585 mVarId@var1336 =@expr1073745586 id@var1210 ;
854: if (@expr1073745587 id@var1210 !=@expr1073745588 0 ) {
855: tokType (@expr1073745589 eVariable ) ;
856: isStandardType (@expr1073745590 false ) ;
857: } else {
858: update_property_info (@expr1073745591 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745592 mImpl@var1305 .@expr3769 mExprId@var1344 ) {
864: return mImpl@var1305 .@expr3769 mExprId@var1344 ; }
865: return mImpl@var1305 .@expr1073745595 mVarId@var1336 ;
866: }
867: void exprId ( int id@var1211 ) {
868: mImpl@var1305 .@expr1073745596 mExprId@var1344 =@expr1073745597 id@var1211 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1212 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1213 , const std :: vector < std :: string > & fileNames@var1214 ) const ;
888:
|
891:
892: void printLines ( int lines@var1215 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1216 , Token * start@var1217 , Token * end@var1218 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1219 ; varid@var1219 = false ;
905: bool exprid@var1220 ; exprid@var1220 = false ;
906: bool idtype@var1221 ; idtype@var1221 = false ;
907: bool attributes@var1222 ; attributes@var1222 = false ;
908: bool macro@var1223 ; macro@var1223 = false ;
909: bool linenumbers@var1224 ; linenumbers@var1224 = false ;
910: bool linebreaks@var1225 ; linebreaks@var1225 = false ;
911: bool files@var1226 ; files@var1226 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1227 ;
914: options@var1227 .@expr1073745598 attributes@var1228 =@expr1073745599 true ;
915: options@var1227 .@expr1073745600 macro@var1229 =@expr1073745601 true ;
916: options@var1227 .@expr1073745602 linenumbers@var1230 =@expr1073745603 true ;
917: options@var1227 .@expr1073745604 linebreaks@var1231 =@expr1073745605 true ;
918: options@var1227 .@expr1073745606 files@var1232 =@expr1073745607 true ;
919: return options@var1227 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1233 ; options@var1233 =@expr1073745608 forDebug (@expr1073745609 ) ;
923: options@var1233 .@expr1073745610 varid@var1234 =@expr1073745611 true ;
924: return options@var1233 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1235 ; options@var1235 =@expr1073745612 forDebug (@expr1073745613 ) ;
928: options@var1235 .@expr1073745614 exprid@var1236 =@expr1073745615 true ;
929: return options@var1235 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1237 ; options@var1237 =@expr1073745616 forDebug (@expr1073745617 ) ;
933: options@var1237 .@expr1073745618 exprid@var1238 =@expr1073745619 true ;
934: options@var1237 .@expr1073745620 varid@var1239 =@expr1073745621 true ;
935: options@var1237 .@expr1073745622 idtype@var1240 =@expr1073745623 true ;
936: return options@var1237 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1241 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1242 , bool attributes@var1243 , bool macro@var1244 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1245 , const std :: vector < std :: string > * fileNames@var1246 = nullptr , const Token * end@var1247 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1248 , bool attributes@var1249 = true ) const ;
952: std :: string stringifyList ( bool varid@var1250 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1251 , bool attributes@var1252 , bool linenumbers@var1253 , bool linebreaks@var1254 , bool files@var1255 , const std :: vector < std :: string > * fileNames@var1256 = nullptr , const Token * end@var1257 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1258 ) {
983: mLink@var1302 =@expr1073745624 linkToToken@var1258 ;
984: if (@expr1073745625 mStr@var1299 ==@expr1073745626 "<" ||@expr1073745627 mStr@var1299 ==@expr1073745628 ">" ) {
985: update_property_info (@expr1073745629 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1302 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1259 ) {
1006: mImpl@var1305 .@expr1073745630 mScope@var1345 =@expr1073745631 s@var1259 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1305 .@expr1073745632 mScope@var1345 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1260 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1303 ==@expr1073745633 eFunction ||@expr1073745634 mTokType@var1303 ==@expr1073745635 eLambda ?@expr1073745636 mImpl@var1305 .@expr1073745637 mFunction@var1346 :@expr1073745638 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1261 ) {
1034: mImpl@var1305 .@expr1073745639 mVariable@var1347 =@expr1073745640 v@var1261 ;
1035: if (@expr1073745641 v@var1261 ||@expr1073745642 mImpl@var1305 .@expr1073745643 mVarId@var1336 ) {
1036: tokType (@expr1073745644 eVariable ) ; }
1037: else { if (@expr1073745645 mTokType@var1303 ==@expr1073745646 eVariable ) {
1038: tokType (@expr1073745647 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1303 ==@expr1073745648 eVariable ?@expr1073745649 mImpl@var1305 .@expr1073745650 mVariable@var1347 :@expr1073745651 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1262 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1303 ==@expr1073745652 eType ?@expr1073745653 mImpl@var1305 .@expr1073745654 mType@var1348 :@expr1073745655 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1263 , const Token * * typeTok@var1264 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1265 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1266 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1303 ==@expr1073745656 eEnumerator ?@expr1073745657 mImpl@var1305 .@expr1073745658 mEnumerator@var1349 :@expr1073745659 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1267 ) {
1079: mImpl@var1305 .@expr1073745660 mEnumerator@var1349 =@expr1073745661 e@var1267 ;
1080: if (@expr1073745662 e@var1267 ) {
1081: tokType (@expr1073745663 eEnumerator ) ; }
1082: else { if (@expr1073745664 mTokType@var1303 ==@expr1073745665 eEnumerator ) {
1083: tokType (@expr1073745666 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1268 , Token * end@var1269 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1270 , Token * srcEnd@var1271 , Token * newLocation@var1272 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1305 .@expr1073745667 mProgressValue@var1350 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1273 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1305 .@expr3844 mOriginalName@var1351 ?@expr1073745669 *@expr1073745670 mImpl@var1305 .@expr3844 mOriginalName@var1351 :@expr1073745672 emptyString@var3 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1305 .@expr3849 mValues@var1324 ?@expr1073745674 *@expr1073745675 mImpl@var1305 .@expr3849 mValues@var1324 :@expr1073745677 TokenImpl ::@expr1073745678 mEmptyValueList@var1071 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1274 ) {
1164: if (@expr1073745679 !@expr1073745680 mImpl@var1305 .@expr3857 mOriginalName@var1351 ) {
1165: mImpl@var1305 .@expr3857 mOriginalName@var1351 =@expr1073745683 new std ::@expr1073745684 string (@expr1073745685 name@var1274 ) ; }
1166: else {
1167: *@expr1073745686 mImpl@var1305 .@expr3857 mOriginalName@var1351 =@expr1073745688 name@var1274 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1275 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1276 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1277 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1305 .@expr1073745690 mValues@var1324 .@expr1073745691 front (@expr1073745692 ) .@expr1073745693 intvalue@expr1073745689 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1278 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1279 , long long path@var1280 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1281 , const Settings * settings@var1282 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1283 , const Settings * settings@var1284 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1285 , int argnr@var1286 , const Settings * settings@var1287 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1288 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1289 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1290 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1291 ) {
1200: if (@expr1073745694 mImpl@var1305 .@expr3871 mValues@var1324 ) {
1201: mImpl@var1305 .@expr3871 mValues@var1324 .@expr1073745697 remove_if (@expr1073745698 pred@var1291 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1305 .@expr1073745699 mIndex@var1352 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1292 ) {
1213: mNext@var1300 =@expr1073745700 nextToken@var1292 ;
1214: }
1215: void previous ( Token * previousToken@var1293 ) {
1216: mPrevious@var1301 =@expr1073745701 previousToken@var1293 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1294 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1295 , const char * word@var1296 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1297 , char c@var1298 ) ;
1235:
1236: std :: string mStr@var1299 ;
1237:
1238: Token * mNext@var1300 ;
1239: Token * mPrevious@var1301 ;
1240: Token * mLink@var1302 ;
1241:
1242: enum Anonymous3 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1303 ;
1283:
1284: uint64_t mFlags@var1304 ;
1285:
1286: TokenImpl * mImpl@var1305 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1306 ) const {
1294: return (@expr3878 (@expr3878 mFlags@var1304 &@expr1073745704 flag_@var1306 ) !=@expr1073745705 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1307 , bool state_@var1308 ) {
1303: mFlags@var1304 =@expr1073745706 state_@var1308 ?@expr1073745707 mFlags@var1304 |@expr1073745708 flag_@var1307 :@expr1073745709 mFlags@var1304 &@expr1073745710 ~@expr1073745711 flag_@var1307 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1309 , const int indent1@var1310 = 0 , const int indent2@var1311 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1312 ) ;
1321: void astOperand2 ( Token * tok@var1313 ) ;
1322: void astParent ( Token * tok@var1314 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1305 .@expr1073745712 mAstOperand1@var1315 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1305 .@expr1073745713 mAstOperand1@var1315 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1305 .@expr1073745714 mAstOperand2@var1316 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1305 .@expr1073745715 mAstOperand2@var1316 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1305 .@expr1073745716 mAstParent@var1317 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1305 .@expr1073745717 mAstParent@var1317 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745718 !@expr1073745719 astParent (@expr3896 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745721 this@expr3898 ==@expr1073745723 astParent (@expr3896 ) .@expr3901 astOperand1 (@expr3902 ) ) {
1346: return astParent (@expr3896 ) .@expr3904 astOperand2 (@expr3905 ) ; }
1347: else { if (@expr1073745730 this@expr3898 ==@expr1073745731 astParent (@expr3896 ) .@expr3904 astOperand2 (@expr3905 ) ) {
1348: return astParent (@expr3896 ) .@expr3901 astOperand1 (@expr3902 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745738 !@expr1073745739 astParent (@expr3916 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745741 this@expr3918 ==@expr1073745743 astParent (@expr3916 ) .@expr3921 astOperand1 (@expr3922 ) ) {
1356: return astParent (@expr3916 ) .@expr3924 astOperand2 (@expr3925 ) ; }
1357: else { if (@expr1073745750 this@expr3918 ==@expr1073745751 astParent (@expr3916 ) .@expr3924 astOperand2 (@expr3925 ) ) {
1358: return astParent (@expr3916 ) .@expr3921 astOperand1 (@expr3922 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1318 ; ret@var1318 =@expr1073745758 this@expr1073745759 ;
1364: while (@expr1073745760 ret@var1318 .@expr3937 mImpl@var1319 .@expr3938 mAstParent@var1320 ) {
1365: ret@var1318 =@expr1073745763 ret@var1318 .@expr3937 mImpl@var1319 .@expr3938 mAstParent@var1320 ; }
1366: return ret@var1318 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1321 ; ret@var1321 =@expr1073745766 this@expr1073745767 ;
1371: while (@expr1073745768 ret@var1321 .@expr3945 mImpl@var1322 .@expr3946 mAstParent@var1323 ) {
1372: ret@var1321 =@expr1073745771 ret@var1321 .@expr3945 mImpl@var1322 .@expr3946 mAstParent@var1323 ; }
1373: return ret@var1321 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1305 .@expr1073745774 mAstOperand1@var1315 =@expr1073745775 mImpl@var1305 .@expr1073745776 mAstOperand2@var1316 =@expr1073745777 mImpl@var1305 .@expr1073745778 mAstParent@var1317 =@expr1073745779 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1305 .@expr3956 mValues@var1324 ;
1393: mImpl@var1305 .@expr3956 mValues@var1324 =@expr1073745782 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1325 = "" ) const {
1397: std ::@expr1073745783 string ret@var1326 ;
1398: if (@expr1073745784 mImpl@var1305 .@expr3961 mAstOperand1@var1315 ) {
1399: ret@var1326 =@expr1073745786 mImpl@var1305 .@expr3961 mAstOperand1@var1315 .@expr1073745788 astString (@expr1073745789 sep@var1325 ) ; }
1400: if (@expr1073745790 mImpl@var1305 .@expr3967 mAstOperand2@var1316 ) {
1401: ret@var1326 +=@expr1073745792 mImpl@var1305 .@expr3967 mAstOperand2@var1316 .@expr1073745794 astString (@expr1073745795 sep@var1325 ) ; }
1402: return ret@var1326 +@expr1073745796 sep@var1325 +@expr1073745797 mStr@var1299 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1327 , bool xml@var1328 , const std :: vector < std :: string > & fileNames@var1329 , std :: ostream & out@var1330 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1331 , std :: ostream & out@var1332 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1333 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1334 ) const {
1419: mImpl@var1305 .@expr1073745798 mCpp11init@var1335 =@expr1073745799 cpp11init@var1334 ?@expr1073745800 TokenImpl ::@expr3977 Cpp11init ::@expr1073745802 CPP11INIT :@expr1073745803 TokenImpl ::@expr3977 Cpp11init ::@expr1073745805 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1305 .@expr1073745806 mCpp11init@var1335 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1353 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1354 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1355 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1356 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1357 ( nullptr ) , num@var1358 ( 0 ) , known@var1359 ( true ) { }
62:
63: const Token * tok@var1357 ;
64: long long num@var1358 ;
65: bool known@var1359 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1360 ;
72: const Scope * classScope@var1361 ;
73: const Scope * enclosingScope@var1362 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1363 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1365 ( nullptr ) , nameTok@var1366 ( nullptr ) , access@var1367 ( AccessControl :: Public ) , isVirtual@var1368 ( false ) { }
82:
83: std :: string name@var1364 ;
84: const Type * type@var1365 ;
85: const Token * nameTok@var1366 ;
86: AccessControl access@var1367 ;
87: bool isVirtual@var1368 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1369 ) const {
90: return this@expr1073745807 .@expr1073745808 type@var1365 <@expr1073745809 rhs@var1369 .@expr1073745810 type@var1370 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1371 ( nullptr ) , nameEnd@var1372 ( nullptr ) , type@var1373 ( nullptr ) { }
97:
98: const Token * nameStart@var1371 ;
99: const Token * nameEnd@var1372 ;
100: const Type * type@var1373 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1374 ;
104: std :: vector < FriendInfo > friendList@var1375 ;
105:
106: const Token * typeStart@var1376 ;
107: const Token * typeEnd@var1377 ;
108: long long sizeOf@var1378 ;
109:
110: Type ( const Token * classDef_@var1379 = nullptr , const Scope * classScope_@var1380 = nullptr , const Scope * enclosingScope_@var1381 = nullptr ) :
111: classDef@var1360 ( classDef_@var1379 ) ,
112: classScope@var1361 ( classScope_@var1380 ) ,
113: enclosingScope@var1362 ( enclosingScope_@var1381 ) ,
114: needInitialization@var1363 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1376 ( nullptr ) ,
116: typeEnd@var1377 ( nullptr ) ,
117: sizeOf@var1378 ( 0 ) {
118: if (@expr1073745811 classDef_@var1379 &&@expr1073745812 classDef_@var1379 .@expr3989 str (@expr3990 ) ==@expr1073745815 "enum" ) {
119: needInitialization@var1363 =@expr1073745816 NeedInitialization ::@expr1073745817 True ; }
120: else { if (@expr1073745818 classDef_@var1379 &&@expr1073745819 classDef_@var1379 .@expr3989 str (@expr3990 ) ==@expr1073745822 "using" ) {
121: typeStart@var1376 =@expr1073745823 classDef@var1360 .@expr1073745824 tokAt (@expr1073745825 3 ) ;
122: typeEnd@var1377 =@expr1073745826 typeStart@var1376 ;
123: while (@expr1073745827 typeEnd@var1377 .@expr4004 next (@expr4005 ) &&@expr1073745830 typeEnd@var1377 .@expr4004 next (@expr4005 ) .@expr1073745833 str (@expr1073745834 ) !=@expr1073745835 ";" ) {
124: typeEnd@var1377 =@expr1073745836 typeEnd@var1377 .@expr4004 next (@expr4005 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1360 ?@expr1073745839 classDef@var1360 .@expr1073745840 str (@expr1073745841 ) :@expr1073745842 emptyString@var3 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1360 &&@expr1073745843 classDef@var1360 .@expr1073745844 str (@expr1073745845 ) ==@expr1073745846 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1382 , const Token * tok1@var1383 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1384 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1385 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1386 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1387 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1388 ) : scope@var1389 ( scope_@var1388 ) , name@var1390 ( nullptr ) , value@var1391 ( 0 ) , start@var1392 ( nullptr ) , end@var1393 ( nullptr ) , value_known@var1394 ( false ) { }
167: const Scope * scope@var1389 ;
168: const Token * name@var1390 ;
169: long long value@var1391 ;
170: const Token * start@var1392 ;
171: const Token * end@var1393 ;
172: bool value_known@var1394 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous4 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1395 ) const {
204: return (@expr4023 (@expr4023 mFlags@var1431 &@expr1073745849 flag_@var1395 ) !=@expr1073745850 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1396 , bool state_@var1397 ) {
213: mFlags@var1431 =@expr1073745851 state_@var1397 ?@expr1073745852 mFlags@var1431 |@expr1073745853 flag_@var1396 :@expr1073745854 mFlags@var1431 &@expr1073745855 ~@expr1073745856 flag_@var1396 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1398 , bool * isContainer@var1399 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1400 , const Token * start_@var1401 , const Token * end_@var1402 ,
226: int index_@var1403 , AccessControl access_@var1404 , const Type * type_@var1405 ,
227: const Scope * scope_@var1406 , const Settings * settings@var1407 )
228: : mNameToken@var1426 ( name_@var1400 ) ,
229: mTypeStartToken@var1427 ( start_@var1401 ) ,
230: mTypeEndToken@var1428 ( end_@var1402 ) ,
231: mIndex@var1429 ( index_@var1403 ) ,
232: mAccess@var1430 ( access_@var1404 ) ,
233: mFlags@var1431 ( 0 ) ,
234: mType@var1432 ( type_@var1405 ) ,
235: mScope@var1433 ( scope_@var1406 ) ,
236: mValueType@var1434 ( nullptr ) {
237: evaluate (@expr1073745857 settings@var1407 ) ;
238: }
239:
240: Variable ( const Token * name_@var1408 , const std :: string & clangType@var1409 , const Token * typeStart@var1410 ,
241: const Token * typeEnd@var1411 , int index_@var1412 , AccessControl access_@var1413 ,
242: const Type * type_@var1414 , const Scope * scope_@var1415 ) ;
243:
244: Variable ( const Variable & var@var1416 , const Scope * scope@var1417 ) ;
245:
246: Variable ( const Variable & var@var1418 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1419 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1426 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1427 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1428 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745858 mNameToken@var1426 ) {
300: return mNameToken@var1426 .@expr1073745859 str (@expr1073745860 ) ; }
301:
302: return emptyString@var3 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745861 mNameToken@var1426 ) {
312: return mNameToken@var1426 .@expr1073745862 varId (@expr1073745863 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1429 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1430 ==@expr1073745864 AccessControl ::@expr1073745865 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1430 ==@expr1073745866 AccessControl ::@expr1073745867 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1430 ==@expr1073745868 AccessControl ::@expr1073745869 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1430 ==@expr1073745870 AccessControl ::@expr1073745871 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1430 ==@expr1073745872 AccessControl ::@expr1073745873 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1430 ==@expr1073745874 AccessControl ::@expr1073745875 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745877 mAccess@var1430 ==@expr1073745878 AccessControl ::@expr1073745879 Local@expr1073745876 ) &&@expr1073745880 !@expr1073745881 isExtern (@expr1073745882 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745883 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745884 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745885 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745886 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745887 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1430 ==@expr1073745888 AccessControl ::@expr1073745889 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745890 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745891 fIsArray ) &&@expr1073745892 !@expr1073745893 getFlag (@expr1073745894 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745895 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745896 ) &&@expr1073745897 getFlag (@expr1073745898 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745899 fIsArray ) ||@expr1073745900 getFlag (@expr1073745901 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745902 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745903 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745904 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745905 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1432 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1432 ?@expr1073745906 mType@var1432 .@expr1073745907 classScope@var1437 :@expr1073745908 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1433 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1435 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1420 ) const {
550: return mDimensions@var1435 [@expr1073745909 index_@var1420 ] .@expr1073745910 num@var2447 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1421 ) const {
558: return mDimensions@var1435 [@expr1073745911 index_@var1421 ] .@expr1073745912 known@var2448 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745913 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745914 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745915 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1422 ) const {
602: return isStlType (@expr1073745916 ) &&@expr1073745917 stlType@var1422 ==@expr1073745918 mTypeStartToken@var1427 .@expr1073745919 strAt (@expr1073745920 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1423 ) const {
616: return isStlType (@expr1073745921 ) &&@expr1073745922 stlTypes@var1423 .@expr1073745923 find (@expr1073745924 mTypeStartToken@var1427 .@expr1073745925 strAt (@expr1073745926 2 ) ) !=@expr1073745927 stlTypes@var1423 .@expr1073745928 end (@expr1073745929 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745930 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr4107 ) &&@expr1073745932 type (@expr4107 ) .@expr1073745934 isEnumType (@expr1073745935 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745936 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1434 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1424 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1430 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1425 ) {
660: mType@var1432 =@expr1073745937 t@var1425 ;
661: }
662:
663:
664: const Token * mNameToken@var1426 ;
665:
666:
667: const Token * mTypeStartToken@var1427 ;
668:
669:
670: const Token * mTypeEndToken@var1428 ;
671:
672:
673: int mIndex@var1429 ;
674:
675:
676: AccessControl mAccess@var1430 ;
677:
678:
679: unsigned int mFlags@var1431 ;
680:
681:
682: const Type * mType@var1432 ;
683:
684:
685: const Scope * mScope@var1433 ;
686:
687: ValueType * mValueType@var1434 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1435 ;
691:
692:
693: void evaluate ( const Settings * settings@var1436 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous5 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1438 ) const {
735: return (@expr4114 (@expr4114 mFlags@var1487 &@expr1073745940 flag@var1438 ) !=@expr1073745941 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1439 , bool state@var1440 ) {
744: mFlags@var1487 =@expr1073745942 state@var1440 ?@expr1073745943 mFlags@var1487 |@expr1073745944 flag@var1439 :@expr1073745945 mFlags@var1487 &@expr1073745946 ~@expr1073745947 flag@var1439 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1441 , const Token * tok@var1442 , const Scope * scope@var1443 , const Token * tokDef@var1444 , const Token * tokArgDef@var1445 ) ;
751: Function ( const Token * tokenDef@var1446 , const std :: string & clangType@var1447 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1457 .@expr1073745948 str (@expr1073745949 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1465 .@expr1073745950 size (@expr1073745951 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1465 .@expr1073745952 size (@expr1073745953 ) -@expr1073745954 initArgCount@var1466 ;
764: }
765: const Variable * getArgumentVar ( int num@var1448 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1466 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1449 , const Scope * scope@var1450 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1451 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1452 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1467 ==@expr1073745955 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1467 ==@expr1073745956 eConstructor ||@expr1073745957
785: type@var1467 ==@expr1073745958 eCopyConstructor ||@expr1073745959
786: type@var1467 ==@expr1073745960 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1467 ==@expr1073745961 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1457 .@expr1073745962 isAttributeConstructor (@expr1073745963 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1457 .@expr1073745964 isAttributeDestructor (@expr1073745965 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1457 .@expr1073745966 isAttributePure (@expr1073745967 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1457 .@expr1073745968 isAttributeConst (@expr1073745969 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1457 .@expr1073745970 isAttributeNoreturn (@expr1073745971 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1457 .@expr1073745972 isAttributeNothrow (@expr1073745973 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1457 .@expr1073745974 isAttributeNodiscard (@expr1073745975 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745976 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745977 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745978 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745979 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745980 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745981 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745982 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745983 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745984 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745985 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745986 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745987 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745988 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745989 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745990 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745991 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745992 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745993 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745994 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745995 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745996 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745997 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1453 ) {
881: setFlag (@expr1073745998 fHasBody , state@var1453 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745999 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073746000 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1454 ) {
891: setFlag (@expr1073746001 fIsEscapeFunction , state@var1454 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073746002 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1455 ) {
898: setFlag (@expr1073746003 fIsConstexpr , state@var1455 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1456 ) const ;
901:
902: const Token * tokenDef@var1457 ;
903: const Token * argDef@var1458 ;
904: const Token * token@var1459 ;
905: const Token * arg@var1460 ;
906: const Token * retDef@var1461 ;
907: const :: Type * retType@var1462 ;
908: const Scope * functionScope@var1463 ;
909: const Scope * nestedIn@var1464 ;
910: std :: list < Variable > argumentList@var1465 ;
911: int initArgCount@var1466 ;
912: Type type@var1467 ;
913: AccessControl access@var1468 ;
914: const Token * noexceptArg@var1469 ;
915: const Token * throwArg@var1470 ;
916: const Token * templateDef@var1471 ;
917: const Token * functionPointerUsage@var1472 ;
918:
919: bool argsMatch ( const Scope * scope@var1473 , const Token * first@var1474 , const Token * second@var1475 , const std :: string & path@var1476 , int path_length@var1477 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1478 , bool unknown@var1479 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1480 , bool unknown@var1481 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1482 , bool unknown@var1483 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1484 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073746004 this@expr1073746005 .@expr1073746006 hasTrailingReturnType (@expr1073746007 ) ) {
931: return Token ::@expr1073746008 findmatch (@expr1073746009 retDef@var1461 , "{|;" ) ;
932: } else {
933: return tokenDef@var1457 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1485 , bool * foundAllBaseClasses@var1486 ) const ;
946:
947: unsigned int mFlags@var1487 ;
948:
949: void isInline ( bool state@var1488 ) {
950: setFlag (@expr1073746010 fIsInline , state@var1488 ) ;
951: }
952: void isConst ( bool state@var1489 ) {
953: setFlag (@expr1073746011 fIsConst , state@var1489 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1490 ) {
956: setFlag (@expr1073746012 fHasVirtualSpecifier , state@var1490 ) ;
957: }
958: void isPure ( bool state@var1491 ) {
959: setFlag (@expr1073746013 fIsPure , state@var1491 ) ;
960: }
961: void isStatic ( bool state@var1492 ) {
962: setFlag (@expr1073746014 fIsStatic , state@var1492 ) ;
963: }
964: void isStaticLocal ( bool state@var1493 ) {
965: setFlag (@expr1073746015 fIsStaticLocal , state@var1493 ) ;
966: }
967: void isExtern ( bool state@var1494 ) {
968: setFlag (@expr1073746016 fIsExtern , state@var1494 ) ;
969: }
970: void isFriend ( bool state@var1495 ) {
971: setFlag (@expr1073746017 fIsFriend , state@var1495 ) ;
972: }
973: void isExplicit ( bool state@var1496 ) {
974: setFlag (@expr1073746018 fIsExplicit , state@var1496 ) ;
975: }
976: void isDefault ( bool state@var1497 ) {
977: setFlag (@expr1073746019 fIsDefault , state@var1497 ) ;
978: }
979: void isDelete ( bool state@var1498 ) {
980: setFlag (@expr1073746020 fIsDelete , state@var1498 ) ;
981: }
982: void isNoExcept ( bool state@var1499 ) {
983: setFlag (@expr1073746021 fIsNoExcept , state@var1499 ) ;
984: }
985: void isThrow ( bool state@var1500 ) {
986: setFlag (@expr1073746022 fIsThrow , state@var1500 ) ;
987: }
988: void isOperator ( bool state@var1501 ) {
989: setFlag (@expr1073746023 fIsOperator , state@var1501 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1502 ) {
992: setFlag (@expr1073746024 fHasLvalRefQual , state@var1502 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1503 ) {
995: setFlag (@expr1073746025 fHasRvalRefQual , state@var1503 ) ;
996: }
997: void isVariadic ( bool state@var1504 ) {
998: setFlag (@expr1073746026 fIsVariadic , state@var1504 ) ;
999: }
1000: void isVolatile ( bool state@var1505 ) {
1001: setFlag (@expr1073746027 fIsVolatile , state@var1505 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1506 ) {
1004: return setFlag (@expr1073746028 fHasTrailingReturnType , state@var1506 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1507 ) {
1007: setFlag (@expr1073746029 fIsInlineKeyword , state@var1507 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1508 , const Scope * scope@var1509 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1510 ;
1019: const Scope * scope@var1511 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1512 , const Token * classDef_@var1513 , const Scope * nestedIn_@var1514 ) ;
1025: Scope ( const SymbolDatabase * check_@var1515 , const Token * classDef_@var1516 , const Scope * nestedIn_@var1517 , ScopeType type_@var1518 , const Token * start_@var1519 ) ;
1026:
1027: const SymbolDatabase * check@var1520 ;
1028: std :: string className@var1521 ;
1029: const Token * classDef@var1522 ;
1030: const Token * bodyStart@var1523 ;
1031: const Token * bodyEnd@var1524 ;
1032: std :: list < Function > functionList@var1525 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1526 ;
1034: std :: list < Variable > varlist@var1527 ;
1035: const Scope * nestedIn@var1528 ;
1036: std :: list < Scope * > nestedList@var1529 ;
1037: int numConstructors@var1530 ;
1038: int numCopyOrMoveConstructors@var1531 ;
1039: std :: list < UsingInfo > usingList@var1532 ;
1040: ScopeType type@var1533 ;
1041: Type * definedType@var1534 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1535 ;
1043: std :: vector < const Token * > bodyStartList@var1536 ;
1044:
1045:
1046: const Scope * functionOf@var1537 ;
1047: Function * function@var1538 ;
1048:
1049:
1050: const Token * enumType@var1539 ;
1051: bool enumClass@var1540 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1541 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1542 ) {
1056: bodyStart@var1523 =@expr1073746030 start@var1542 ;
1057: bodyEnd@var1524 =@expr1073746031 start@var1542 ?@expr1073746032 start@var1542 .@expr1073746033 link (@expr1073746034 ) :@expr1073746035 nullptr ;
1058: if (@expr1073746036 start@var1542 ) {
1059: bodyStartList@var1536 .@expr1073746037 push_back (@expr1073746038 start@var1542 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1521 .@expr1073746039 size (@expr1073746040 ) >@expr1073746041 9 &&@expr1073746042 className@var1521 .@expr1073746043 compare (@expr1073746044 0 , 9 , "Anonymous" ) ==@expr1073746045 0 &&@expr1073746046 std ::@expr1073746047 isdigit (@expr1073746048 className@var1521 [@expr1073746049 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1543 ) const {
1068: for (@expr1073746050 const Enumerator &@expr1073746051 i@var1544 :@expr1073746052 enumeratorList@var1541 ) {
1069: if (@expr1073746053 i@var1544 .@expr1073746054 name@var1545 .@expr1073746055 str (@expr1073746056 ) ==@expr1073746057 name@var1543 ) {
1070: return &@expr1073746058 i@var1544 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1546 ) const {
1076: if (@expr1073746059 !@expr1073746060 outer@var1546 ) {
1077: return false ; }
1078: if (@expr1073746061 outer@var1546 ==@expr1073746062 this@expr1073746063 ) {
1079: return true ; }
1080: const Scope * parent@var1547 ; parent@var1547 =@expr1073746064 nestedIn@var1528 ;
1081: while (@expr1073746065 outer@var1546 !=@expr1073746066 parent@var1547 &&@expr1073746067 parent@var1547 ) {
1082: parent@var1547 =@expr1073746068 parent@var1547 .@expr1073746069 nestedIn@var1548 ; }
1083: if (@expr1073746070 parent@var1547 &&@expr1073746071 parent@var1547 ==@expr1073746072 outer@var1546 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1549 ) {
1089: while (@expr1073746073 scope@var1549 ) {
1090: if (@expr1073746074 scope@var1549 .@expr1073746075 type@var1550 ==@expr1073746076 Scope ::@expr1073746077 eFunction ) {
1091: break ; }
1092: scope@var1549 =@expr1073746078 scope@var1549 .@expr1073746079 nestedIn@var1551 ;
1093: }
1094: if (@expr1073746080 !@expr1073746081 scope@var1549 ) {
1095: return nullptr ; }
1096: return scope@var1549 .@expr1073746082 function@var1552 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073746083 type@var1533 ==@expr1073746084 eClass ||@expr1073746085 type@var1533 ==@expr1073746086 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073746087 type@var1533 ==@expr1073746088 eClass ||@expr1073746089 type@var1533 ==@expr1073746090 eStruct ||@expr1073746091 type@var1533 ==@expr1073746092 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1533 !=@expr1073746093 eClass &&@expr1073746094 type@var1533 !=@expr1073746095 eStruct &&@expr1073746096 type@var1533 !=@expr1073746097 eUnion &&@expr1073746098 type@var1533 !=@expr1073746099 eGlobal &&@expr1073746100 type@var1533 !=@expr1073746101 eNamespace &&@expr1073746102 type@var1533 !=@expr1073746103 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1533 ==@expr1073746104 Scope ::@expr4281 ScopeType ::@expr1073746106 eFor ||@expr1073746107 type@var1533 ==@expr1073746108 Scope ::@expr4281 ScopeType ::@expr1073746110 eWhile ||@expr1073746111 type@var1533 ==@expr1073746112 Scope ::@expr4281 ScopeType ::@expr1073746114 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073746115 type@var1533 ==@expr1073746116 eIf ||@expr1073746117 type@var1533 ==@expr1073746118 eElse ||@expr1073746119
1117: type@var1533 ==@expr1073746120 eFor ||@expr1073746121 type@var1533 ==@expr1073746122 eWhile ||@expr1073746123 type@var1533 ==@expr1073746124 eDo ||@expr1073746125
1118: type@var1533 ==@expr1073746126 eSwitch ||@expr1073746127 type@var1533 ==@expr1073746128 eUnconditional ||@expr1073746129
1119: type@var1533 ==@expr1073746130 eTry ||@expr1073746131 type@var1533 ==@expr1073746132 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1553 , bool requireConst@var1554 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1555 , bool isC@var1556 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1557 ) {
1135: return const_cast < Scope *@expr4309 > (@expr1073746134 const_cast < const Scope *@expr4309 > (@expr1073746136 this@expr1073746137 ) .@expr1073746138 findRecordInNestedList (@expr1073746139 name@var1557 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1558 ) const ;
1139: Type * findType ( const std :: string & name@var1559 ) {
1140: return const_cast < Type *@expr4316 > (@expr1073746141 const_cast < const Scope *@expr4316 > (@expr1073746143 this@expr1073746144 ) .@expr1073746145 findType (@expr1073746146 name@var1559 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1560 ) ;
1148:
1149: void addVariable ( const Token * token_@var1561 , const Token * start_@var1562 ,
1150: const Token * end_@var1563 , AccessControl access_@var1564 , const Type * type_@var1565 ,
1151: const Scope * scope_@var1566 , const Settings * settings@var1567 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1568 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1569 ) {
1159: functionList@var1525 .@expr1073746147 push_back (@expr1073746148 func@var1569 ) ;
1160:
1161: const Function * back@var1570 ; back@var1570 =@expr1073746149 &@expr1073746150 functionList@var1525 .@expr1073746151 back (@expr1073746152 ) ;
1162:
1163: functionMap@var1526 .@expr1073746153 insert (@expr1073746154 make_pair (@expr1073746155 back@var1570 .@expr1073746156 tokenDef@var1571 .@expr1073746157 str (@expr1073746158 ) , back@var1570 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1572 , AccessControl varaccess@var1573 , const Settings * settings@var1574 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1575 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1576 , bool isCpp@var1577 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1578 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1579 , const Token * & vartok@var1580 , const Token * & typetok@var1581 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1582 , int args@var1583 , std :: vector < const Function * > & matches@var1584 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1585 , const Token * start@var1586 , const Token * end@var1587 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1588 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1589 ;
1239: int bits@var1590 ;
1240: int pointer@var1591 ;
1241: int constness@var1592 ;
1242: Reference reference@var1593 ; reference@var1593 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1594 ;
1245: const :: Type * smartPointerType@var1595 ;
1246: const Token * smartPointerTypeToken@var1596 ;
1247: const Library :: SmartPointer * smartPointer@var1597 ;
1248: const Library :: Container * container@var1598 ;
1249:
1250: const Token * containerTypeToken@var1599 ;
1251:
1252: std :: string originalTypeName@var1600 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1588 ( UNKNOWN_SIGN ) ,
1257: type@var1589 ( UNKNOWN_TYPE ) ,
1258: bits@var1590 ( 0 ) ,
1259: pointer@var1591 ( 0U ) ,
1260: constness@var1592 ( 0U ) ,
1261: typeScope@var1594 ( nullptr ) ,
1262: smartPointerType@var1595 ( nullptr ) ,
1263: smartPointerTypeToken@var1596 ( nullptr ) ,
1264: smartPointer@var1597 ( nullptr ) ,
1265: container@var1598 ( nullptr ) ,
1266: containerTypeToken@var1599 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1601 , enum Type t@var1602 , int p@var1603 )
1269: : sign@var1588 ( s@var1601 ) ,
1270: type@var1589 ( t@var1602 ) ,
1271: bits@var1590 ( 0 ) ,
1272: pointer@var1591 ( p@var1603 ) ,
1273: constness@var1592 ( 0U ) ,
1274: typeScope@var1594 ( nullptr ) ,
1275: smartPointerType@var1595 ( nullptr ) ,
1276: smartPointerTypeToken@var1596 ( nullptr ) ,
1277: smartPointer@var1597 ( nullptr ) ,
1278: container@var1598 ( nullptr ) ,
1279: containerTypeToken@var1599 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1604 , enum Type t@var1605 , int p@var1606 , int c@var1607 )
1282: : sign@var1588 ( s@var1604 ) ,
1283: type@var1589 ( t@var1605 ) ,
1284: bits@var1590 ( 0 ) ,
1285: pointer@var1591 ( p@var1606 ) ,
1286: constness@var1592 ( c@var1607 ) ,
1287: typeScope@var1594 ( nullptr ) ,
1288: smartPointerType@var1595 ( nullptr ) ,
1289: smartPointerTypeToken@var1596 ( nullptr ) ,
1290: smartPointer@var1597 ( nullptr ) ,
1291: container@var1598 ( nullptr ) ,
1292: containerTypeToken@var1599 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1608 , enum Type t@var1609 , int p@var1610 , int c@var1611 , const std :: string & otn@var1612 )
1295: : sign@var1588 ( s@var1608 ) ,
1296: type@var1589 ( t@var1609 ) ,
1297: bits@var1590 ( 0 ) ,
1298: pointer@var1591 ( p@var1610 ) ,
1299: constness@var1592 ( c@var1611 ) ,
1300: typeScope@var1594 ( nullptr ) ,
1301: smartPointerType@var1595 ( nullptr ) ,
1302: smartPointerTypeToken@var1596 ( nullptr ) ,
1303: smartPointer@var1597 ( nullptr ) ,
1304: container@var1598 ( nullptr ) ,
1305: containerTypeToken@var1599 ( nullptr ) ,
1306: originalTypeName@var1600 ( otn@var1612 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1613 , const Settings * settings@var1614 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1615 , bool longType@var1616 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1617 , const ValueType * func@var1618 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1619 , const Variable * callVar@var1620 , const Variable * funcVar@var1621 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073746159 type@var1589 >=@expr1073746160 ValueType ::@expr1073746161 Type ::@expr1073746162 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073746163 type@var1589 >=@expr1073746164 ValueType ::@expr4341 Type ::@expr1073746166 BOOL &&@expr1073746167 type@var1589 <=@expr1073746168 ValueType ::@expr4341 Type ::@expr1073746170 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073746171 type@var1589 >=@expr1073746172 ValueType ::@expr4349 Type ::@expr1073746174 FLOAT &&@expr1073746175 type@var1589 <=@expr1073746176 ValueType ::@expr4349 Type ::@expr1073746178 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1622 , const Settings * settings@var1623 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1594 &&@expr1073746179 typeScope@var1594 .@expr1073746180 type@var1624 ==@expr1073746181 Scope ::@expr1073746182 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1625 , bool p@var1626 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1627 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1628 , const Settings * settings@var1629 , ErrorLogger * errorLogger@var1630 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1631 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1632 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1633 ;
1359:
1360:
1361: std :: list < Type > typeList@var1634 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1635 , const Token * typeTok@var1636 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1637 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1638 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1639 , const Scope * startScope@var1640 , bool lookOutside@var1641 = false ) const ;
1382: Type * findType ( const Token * startTok@var1642 , Scope * startScope@var1643 , bool lookOutside@var1644 = false ) const {
1383: return const_cast < Type *@expr4359 > (@expr1073746184 this@expr1073746185 .@expr1073746186 findType (@expr1073746187 startTok@var1642 , const_cast < const Scope *@expr4359 > (@expr1073746189 startScope@var1643 ) , lookOutside@var1644 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1645 , const Scope * startScope@var1646 ) const ;
1387: Scope * findScope ( const Token * tok@var1647 , Scope * startScope@var1648 ) const {
1388: return const_cast < Scope *@expr4366 > (@expr1073746191 this@expr1073746192 .@expr1073746193 findScope (@expr1073746194 tok@var1647 , const_cast < const Scope *@expr4366 > (@expr1073746196 startScope@var1648 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1649 ) const {
1392: return varid@var1649 <@expr1073746197 mVariableList@var1706 .@expr1073746198 size (@expr1073746199 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1650 ) const {
1396: return mVariableList@var1706 .@expr1073746200 at (@expr1073746201 varId@var1650 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1706 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1651 , const std :: string & type@var1652 , const std :: string & msg@var1653 ) const ;
1407:
1408: void printOut ( const char * title@var1654 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1655 , const char * indent@var1656 ) const ;
1410: void printXml ( std :: ostream & out@var1657 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1658 , Token * tokens@var1659 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1660 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1661 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1662 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1663 , const Token * * tok@var1664 , const Token * argStart@var1665 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1666 , const Token * tok@var1667 , const Token * argStart@var1668 , const Token * funcStart@var1669 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1670 , const Token * & tok@var1671 , const Token * argStart@var1672 , const Token * funcStart@var1673 ) ;
1469: void addNewFunction ( Scope * * scope@var1674 , const Token * * tok@var1675 ) ;
1470: bool isFunction ( const Token * tok@var1676 , const Scope * outerScope@var1677 , const Token * * funcStart@var1678 , const Token * * argStart@var1679 , const Token * * declEnd@var1680 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1681 , const Scope * startScope@var1682 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1683 , const Scope * scope@var1684 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1685 , const Scope * ns@var1686 , const std :: string & path@var1687 , int path_length@var1688 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1689 , const Token * typeTok@var1690 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1691 , const Token * vartok@var1692 , Token * membertok@var1693 , const Variable * membervar@var1694 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1695 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1696 ) const ;
1485:
1486: void setValueType ( Token * tok@var1697 , const ValueType & valuetype@var1698 ) ;
1487: void setValueType ( Token * tok@var1699 , const Variable & var@var1700 ) ;
1488: void setValueType ( Token * tok@var1701 , const Enumerator & enumerator@var1702 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1703 ;
1491: const Settings * mSettings@var1704 ;
1492: ErrorLogger * mErrorLogger@var1705 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1706 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1707 ;
1499:
1500: bool mIsCpp@var1708 ;
1501: ValueType :: Sign mDefaultSignedness@var1709 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1710 ;
1505: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1711 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1712 ) {
47: mSettings@var1747 =@expr1073746202 settings@var1712 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1747 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1749 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1750 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1713 ) ;
72:
73: void addtoken ( const std :: string & str@var1714 , const int lineno@var1715 , const int column@var1716 , const int fileno@var1717 , bool split@var1718 = false ) ;
74: void addtoken ( const std :: string & str@var1719 , const Token * locationTok@var1720 ) ;
75:
76: void addtoken ( const Token * tok@var1721 , const int lineno@var1722 , const int column@var1723 , const int fileno@var1724 ) ;
77: void addtoken ( const Token * tok@var1725 , const Token * locationTok@var1726 ) ;
78: void addtoken ( const Token * tok@var1727 ) ;
79:
80: static void insertTokens ( Token * dest@var1728 , const Token * src@var1729 , int n@var1730 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1731 , const Token * first@var1732 , const Token * last@var1733 , bool one_line@var1734 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1735 , const std :: string & file0@var1736 = emptyString@var3 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1737 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1738 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1744 .@expr1073746203 front@var1751 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1744 .@expr1073746204 front@var1751 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1744 .@expr1073746205 back@var1752 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1744 .@expr1073746206 back@var1752 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1745 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1739 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1740 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1741 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1742 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1743 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1744 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1745 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1746 ;
212:
213:
214: const Settings * mSettings@var1747 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1748 ;
217:
218:
219: bool mIsC@var1749 ;
220: bool mIsCpp@var1750 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var1753 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var1754 ;
67: mutable int mVarId@var1755 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var1756 ) ;
73: bool hasVariable ( const std :: string & varname@var1757 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var1758 ) const {
75: return mVariableId@var1753 .@expr1073746207 find (@expr1073746208 varname@var1758 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var1753 .@expr1073746209 end (@expr1073746210 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var1753 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073746211 mVarId@var1755 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var1759 , ErrorLogger * errorLogger@var1760 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var1761 ) {
95: mTimerResults@var1881 =@expr1073746212 tr@var1761 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var1859 .@expr1073746213 isC (@expr1073746214 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var1859 .@expr1073746215 isCPP (@expr1073746216 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var1762 , bool * unknown@var1763 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var1764 , const std :: string & FileName@var1765 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var1766 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var1767 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var1768 ,
142: const char FileName@var1769 [ ] ,
143: const std :: string & configuration@var1770 = emptyString@var3 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var1771 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var1772 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var1773 , const Token * end@var1774 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var1775 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var1776 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var1777 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var1778 , const Token * const tokEnd@var1779 , const bool only_k_r_fpar@var1780 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var1781 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var1782 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var1783 , bool commandWithCondition@var1784 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var1785 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var1786 , Token * * _tok2@var1787 , Token * * _tok3@var1788 , std :: string & value@var1789 , int & valueVarId@var1790 , bool & valueIsPointer@var1791 , bool floatvar@var1792 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var1793 , Token * tok3@var1794 , int varid@var1795 , const std :: string & structname@var1796 , std :: string & value@var1797 , int valueVarId@var1798 , bool valueIsPointer@var1799 , const Token * const valueToken@var1800 , int indentlevel@var1801 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var1802 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var1803 , const std :: string & endsWith@var1804 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1805 , const std :: string & endsWith@var1806 , bool cpp@var1807 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1808 ) {
585: mPreprocessor@var1882 =@expr1073746217 preprocessor@var1808 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var1882 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1809 , const Token * end@var1810 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1811 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1812 , const std :: string & code@var1813 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1814 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1815 , const std :: string & what@var1816 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1817 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1818 , const std :: string & msg@var1819 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1820 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1821 , const std :: string & macroName@var1822 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1823 , const Token * end@var1824 , bool allowSemicolon@var1825 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1826 , const Severity :: SeverityType severity@var1827 , const std :: string & id@var1828 , const std :: string & msg@var1829 , bool inconclusive@var1830 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1831 , Severity :: SeverityType severity@var1832 , const std :: string & id@var1833 , const std :: string & msg@var1834 , bool inconclusive@var1835 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1836 , const Token * name@var1837 , const Token * typeDef@var1838 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1839 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1840 ,
821: const VariableMap & variableMap@var1841 ,
822: const int scopeStartVarId@var1842 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1843 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1844 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1845 ,
827: int * varId@var1846 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1847 ,
830: Token * const startToken@var1848 ,
831: const Token * const endToken@var1849 ,
832: const std :: map < std :: string , int > & varlist@var1850 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1851 ,
834: int * varId_@var1852 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1853 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1854 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var1880 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1855 ) {
861: mSettings@var1866 =@expr1073746218 settings@var1855 ;
862: list@var1859 .@expr1073746219 setSettings (@expr1073746220 settings@var1855 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var1868 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1856 ) const ;
877:
878: void dump ( std :: ostream & out@var1857 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var1858 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var1878 ;
888: }
889:
|
892:
893: TokenList list@var1859 ;
894:
895: const Token * tokens ( ) const {
896: return list@var1859 .@expr1073746221 front (@expr1073746222 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var1860 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var1861 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var1862 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var1863 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var1866 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var1864 , bool inOperator@var1865 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073746223 mVarId@var1878 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var1866 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var1867 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var1868 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var1869 ;
973:
974:
975:
976: std :: string mConfiguration@var1870 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var1871 ;
980:
981: struct TypedefInfo {
982: std :: string name@var1872 ;
983: std :: string filename@var1873 ;
984: int lineNumber@var1874 ;
985: int column@var1875 ;
986: bool used@var1876 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var1877 ;
989:
990:
991: int mVarId@var1878 ;
992:
993:
994: int mUnnamedCount@var1879 ;
995:
|
999:
1000: bool mCodeWithTemplates@var1880 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var1881 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var1882 ;
1013: } ;

##file cppcheck-2.8/lib/clangimport.cpp

1:
|
44:
45: static const std :: string AccessSpecDecl@var1883 = "AccessSpecDecl" ;
46: static const std :: string ArraySubscriptExpr@var1884 = "ArraySubscriptExpr" ;
47: static const std :: string BinaryOperator@var1885 = "BinaryOperator" ;
48: static const std :: string BreakStmt@var1886 = "BreakStmt" ;
49: static const std :: string CallExpr@var1887 = "CallExpr" ;
50: static const std :: string CaseStmt@var1888 = "CaseStmt" ;
51: static const std :: string CharacterLiteral@var1889 = "CharacterLiteral" ;
52: static const std :: string ClassTemplateDecl@var1890 = "ClassTemplateDecl" ;
53: static const std :: string ClassTemplateSpecializationDecl@var1891 = "ClassTemplateSpecializationDecl" ;
54: static const std :: string ConditionalOperator@var1892 = "ConditionalOperator" ;
55: static const std :: string ConstantExpr@var1893 = "ConstantExpr" ;
56: static const std :: string CompoundAssignOperator@var1894 = "CompoundAssignOperator" ;
57: static const std :: string CompoundStmt@var1895 = "CompoundStmt" ;
58: static const std :: string ContinueStmt@var1896 = "ContinueStmt" ;
59: static const std :: string CStyleCastExpr@var1897 = "CStyleCastExpr" ;
60: static const std :: string CXXBindTemporaryExpr@var1898 = "CXXBindTemporaryExpr" ;
61: static const std :: string CXXBoolLiteralExpr@var1899 = "CXXBoolLiteralExpr" ;
62: static const std :: string CXXConstructorDecl@var1900 = "CXXConstructorDecl" ;
63: static const std :: string CXXConstructExpr@var1901 = "CXXConstructExpr" ;
64: static const std :: string CXXDefaultArgExpr@var1902 = "CXXDefaultArgExpr" ;
65: static const std :: string CXXDeleteExpr@var1903 = "CXXDeleteExpr" ;
66: static const std :: string CXXDestructorDecl@var1904 = "CXXDestructorDecl" ;
67: static const std :: string CXXForRangeStmt@var1905 = "CXXForRangeStmt" ;
68: static const std :: string CXXFunctionalCastExpr@var1906 = "CXXFunctionalCastExpr" ;
69: static const std :: string CXXMemberCallExpr@var1907 = "CXXMemberCallExpr" ;
70: static const std :: string CXXMethodDecl@var1908 = "CXXMethodDecl" ;
71: static const std :: string CXXNewExpr@var1909 = "CXXNewExpr" ;
72: static const std :: string CXXNullPtrLiteralExpr@var1910 = "CXXNullPtrLiteralExpr" ;
73: static const std :: string CXXOperatorCallExpr@var1911 = "CXXOperatorCallExpr" ;
74: static const std :: string CXXRecordDecl@var1912 = "CXXRecordDecl" ;
75: static const std :: string CXXStaticCastExpr@var1913 = "CXXStaticCastExpr" ;
76: static const std :: string CXXStdInitializerListExpr@var1914 = "CXXStdInitializerListExpr" ;
77: static const std :: string CXXTemporaryObjectExpr@var1915 = "CXXTemporaryObjectExpr" ;
78: static const std :: string CXXThisExpr@var1916 = "CXXThisExpr" ;
79: static const std :: string CXXThrowExpr@var1917 = "CXXThrowExpr" ;
80: static const std :: string DeclRefExpr@var1918 = "DeclRefExpr" ;
81: static const std :: string DeclStmt@var1919 = "DeclStmt" ;
82: static const std :: string DefaultStmt@var1920 = "DefaultStmt" ;
83: static const std :: string DoStmt@var1921 = "DoStmt" ;
84: static const std :: string EnumConstantDecl@var1922 = "EnumConstantDecl" ;
85: static const std :: string EnumDecl@var1923 = "EnumDecl" ;
86: static const std :: string ExprWithCleanups@var1924 = "ExprWithCleanups" ;
87: static const std :: string FieldDecl@var1925 = "FieldDecl" ;
88: static const std :: string FloatingLiteral@var1926 = "FloatingLiteral" ;
89: static const std :: string ForStmt@var1927 = "ForStmt" ;
90: static const std :: string FunctionDecl@var1928 = "FunctionDecl" ;
91: static const std :: string FunctionTemplateDecl@var1929 = "FunctionTemplateDecl" ;
92: static const std :: string GotoStmt@var1930 = "GotoStmt" ;
93: static const std :: string IfStmt@var1931 = "IfStmt" ;
94: static const std :: string ImplicitCastExpr@var1932 = "ImplicitCastExpr" ;
95: static const std :: string InitListExpr@var1933 = "InitListExpr" ;
96: static const std :: string IntegerLiteral@var1934 = "IntegerLiteral" ;
97: static const std :: string LabelStmt@var1935 = "LabelStmt" ;
98: static const std :: string LinkageSpecDecl@var1936 = "LinkageSpecDecl" ;
99: static const std :: string MaterializeTemporaryExpr@var1937 = "MaterializeTemporaryExpr" ;
100: static const std :: string MemberExpr@var1938 = "MemberExpr" ;
101: static const std :: string NamespaceDecl@var1939 = "NamespaceDecl" ;
102: static const std :: string NullStmt@var1940 = "NullStmt" ;
103: static const std :: string ParenExpr@var1941 = "ParenExpr" ;
104: static const std :: string ParmVarDecl@var1942 = "ParmVarDecl" ;
105: static const std :: string RecordDecl@var1943 = "RecordDecl" ;
106: static const std :: string ReturnStmt@var1944 = "ReturnStmt" ;
107: static const std :: string StringLiteral@var1945 = "StringLiteral" ;
108: static const std :: string SwitchStmt@var1946 = "SwitchStmt" ;
109: static const std :: string TemplateArgument@var1947 = "TemplateArgument" ;
110: static const std :: string TypedefDecl@var1948 = "TypedefDecl" ;
111: static const std :: string UnaryOperator@var1949 = "UnaryOperator" ;
112: static const std :: string UnaryExprOrTypeTraitExpr@var1950 = "UnaryExprOrTypeTraitExpr" ;
113: static const std :: string VarDecl@var1951 = "VarDecl" ;
114: static const std :: string WhileStmt@var1952 = "WhileStmt" ;
115:
116: static std :: string unquote ( const std :: string & s@var1953 )
117: {
118: return (@expr1073746224 s@var1953 [@expr1073746225 0 ] ==@expr1073746226 '\'' ) ?@expr1073746227 s@var1953 .@expr1073746228 substr (@expr1073746229 1 , s@var1953 .@expr1073746230 size (@expr1073746231 ) -@expr1073746232 2 ) :@expr1073746233 s@var1953 ;
119: }
120:
121:
122: static std :: vector < std :: string > splitString ( const std :: string & line@var1954 )
123: {
124: std ::@expr1073746235 vector < std ::@expr4412 string > ret@var1955 ;
125: std ::@expr4413 string ::@expr1073746238 size_type pos1@var1956 ; pos1@var1956 =@expr1073746239 line@var1954 .@expr4416 find_first_not_of (@expr1073746241 " " ) ;
126: while (@expr1073746242 pos1@var1956 <@expr1073746243 line@var1954 .@expr4420 size (@expr4421 ) ) {
127: std ::@expr4413 string ::@expr1073746247 size_type pos2@var1957 ;
128: if (@expr1073746248 std ::@expr1073746249 strchr (@expr1073746250 "*()" , line@var1954 [@expr4427 pos1@var1956 ] ) ) {
129: ret@var1955 .@expr4428 push_back (@expr1073746253 line@var1954 .@expr4430 substr (@expr1073746255 pos1@var1956 , 1 ) ) ;
130: pos1@var1956 =@expr1073746256 line@var1954 .@expr4416 find_first_not_of (@expr1073746258 " " , pos1@var1956 +@expr4435 1 ) ;
131: continue ;
132: }
133: if (@expr1073746260 line@var1954 [@expr4427 pos1@var1956 ] ==@expr1073746262 '<' ) {
134: pos2@var1957 =@expr1073746263 line@var1954 .@expr4440 find (@expr4441 ">" , pos1@var1956 ) ; }
135: else { if (@expr1073746266 line@var1954 [@expr4427 pos1@var1956 ] ==@expr1073746268 '\"' ) {
136: pos2@var1957 =@expr1073746269 line@var1954 .@expr4440 find (@expr1073746271 "\"" , pos1@var1956 +@expr4435 1 ) ; }
137: else { if (@expr1073746273 line@var1954 [@expr4427 pos1@var1956 ] ==@expr1073746275 '\'' ) {
138: pos2@var1957 =@expr1073746276 line@var1954 .@expr4440 find (@expr1073746278 "\'" , pos1@var1956 +@expr4435 1 ) ;
139: if (@expr1073746280 pos2@var1957 <@expr1073746281 (@expr1073746282 int ) line@var1954 .@expr4420 size (@expr4421 ) -@expr1073746285 3 &&@expr1073746286 line@var1954 .@expr1073746287 compare (@expr1073746288 pos2@var1957 , 3 , "\':\'" , 0 , 3 ) ==@expr1073746289 0 ) {
140: pos2@var1957 =@expr1073746290 line@var1954 .@expr4440 find (@expr1073746292 "\'" , pos2@var1957 +@expr1073746293 3 ) ; }
141: } else {
142: pos2@var1957 =@expr1073746294 pos1@var1956 ;
143: while (@expr1073746295 pos2@var1957 <@expr4472 line@var1954 .@expr4420 size (@expr4421 ) &&@expr1073746299 (@expr1073746300 line@var1954 [@expr4477 pos2@var1957 ] ==@expr1073746302 '_' ||@expr1073746303 line@var1954 [@expr4477 pos2@var1957 ] ==@expr1073746305 ':' ||@expr1073746306 std ::@expr1073746307 isalnum (@expr1073746308 (@expr1073746309 unsigned char ) line@var1954 [@expr4477 pos2@var1957 ] ) ) ) {
144: ++@expr1073746311 pos2@var1957 ; }
145: if (@expr1073746312 pos2@var1957 >@expr1073746313 pos1@var1956 &&@expr1073746314 pos2@var1957 <@expr4472 line@var1954 .@expr4420 size (@expr4421 ) &&@expr1073746318 line@var1954 [@expr4477 pos2@var1957 ] ==@expr4496 '<' &&@expr1073746321 std ::@expr4498 isalpha (@expr4499 line@var1954 [@expr4427 pos1@var1956 ] ) ) {
146: int tlevel@var1958 ; tlevel@var1958 =@expr1073746325 1 ;
147: while (@expr1073746326 ++@expr1073746327 pos2@var1957 <@expr1073746328 line@var1954 .@expr4420 size (@expr4421 ) &&@expr1073746331 tlevel@var1958 >@expr1073746332 0 ) {
148: if (@expr4509 line@var1954 [@expr4477 pos2@var1957 ] ==@expr4496 '<' ) {
149: ++@expr1073746336 tlevel@var1958 ; }
150: else { if (@expr4513 line@var1954 [@expr4477 pos2@var1957 ] ==@expr4515 '>' ) {
151: --@expr1073746340 tlevel@var1958 ; } }
152: }
153: if (@expr1073746341 tlevel@var1958 ==@expr1073746342 0 &&@expr1073746343 pos2@var1957 <@expr4472 line@var1954 .@expr4420 size (@expr4421 ) &&@expr1073746347 line@var1954 [@expr4477 pos2@var1957 ] ==@expr1073746349 ' ' ) {
154: ret@var1955 .@expr4428 push_back (@expr4527 line@var1954 .@expr4430 substr (@expr4529 pos1@var1956 , pos2@var1957 -@expr4530 pos1@var1956 ) ) ;
155: pos1@var1956 =@expr1073746355 pos2@var1957 +@expr4532 1 ;
156: continue ;
157: }
158: }
159:
160: pos2@var1957 =@expr1073746357 line@var1954 .@expr4440 find (@expr1073746359 " " , pos1@var1956 ) -@expr1073746360 1 ;
161: if (@expr1073746361 (@expr1073746362 std ::@expr4498 isalpha (@expr4499 line@var1954 [@expr4427 pos1@var1956 ] ) ||@expr4542 line@var1954 [@expr4427 pos1@var1956 ] ==@expr4544 '_' ) &&@expr1073746369
162: line@var1954 .@expr4440 find (@expr4547 "::" , pos1@var1956 ) <@expr1073746372 pos2@var1957 &&@expr1073746373
163: line@var1954 .@expr4440 find (@expr4547 "::" , pos1@var1956 ) <@expr1073746376 line@var1954 .@expr4440 find (@expr4554 "<" , pos1@var1956 ) ) {
164: pos2@var1957 =@expr1073746379 line@var1954 .@expr4440 find (@expr4547 "::" , pos1@var1956 ) ;
165: ret@var1955 .@expr4428 push_back (@expr4527 line@var1954 .@expr4430 substr (@expr4529 pos1@var1956 , pos2@var1957 -@expr4530 pos1@var1956 ) ) ;
166: ret@var1955 .@expr4428 push_back (@expr1073746388 "::" ) ;
167: pos1@var1956 =@expr1073746389 pos2@var1957 +@expr1073746390 2 ;
168: continue ;
169: }
170: if (@expr1073746391 (@expr1073746392 std ::@expr4498 isalpha (@expr4499 line@var1954 [@expr4427 pos1@var1956 ] ) ||@expr4542 line@var1954 [@expr4427 pos1@var1956 ] ==@expr4544 '_' ) &&@expr1073746399
171: line@var1954 .@expr4440 find (@expr4554 "<" , pos1@var1956 ) <@expr1073746402 pos2@var1957 &&@expr1073746403
172: line@var1954 .@expr4440 find (@expr1073746405 "<<" , pos1@var1956 ) !=@expr1073746406 line@var1954 .@expr4440 find (@expr4554 "<" , pos1@var1956 ) &&@expr1073746409
173: line@var1954 .@expr4440 find (@expr4441 ">" , pos1@var1956 ) !=@expr1073746412 std ::@expr4413 string ::@expr4590 npos &&@expr1073746415
174: line@var1954 .@expr4440 find (@expr4441 ">" , pos1@var1956 ) >@expr1073746418 pos2@var1957 ) {
175: int level@var1959 ; level@var1959 =@expr1073746419 0 ;
176: for (@expr1073746420 pos2@var1957 =@expr1073746421 pos1@var1956 ; pos2@var1957 <@expr4472 line@var1954 .@expr4420 size (@expr4421 ) ; ++@expr1073746425 pos2@var1957 ) {
177: if (@expr4509 line@var1954 [@expr4477 pos2@var1957 ] ==@expr4496 '<' ) {
178: ++@expr1073746429 level@var1959 ; }
179: else { if (@expr4513 line@var1954 [@expr4477 pos2@var1957 ] ==@expr4515 '>' ) {
180: if (@expr1073746433 level@var1959 <=@expr1073746434 1 ) {
181: break ; }
182: --@expr1073746435 level@var1959 ;
183: } }
184: }
185: if (@expr1073746436 level@var1959 >@expr1073746437 1 &&@expr1073746438 pos2@var1957 +@expr4532 1 >=@expr1073746440 line@var1954 .@expr4420 size (@expr4421 ) ) {
186: return std ::@expr1073746443 vector < std ::@expr4412 string > {@expr1073746445 } ; }
187: pos2@var1957 =@expr1073746446 line@var1954 .@expr4440 find (@expr1073746448 " " , pos2@var1957 ) ;
188: if (@expr1073746449 pos2@var1957 !=@expr1073746450 std ::@expr4413 string ::@expr4590 npos@expr4410 ) {
189: --@expr1073746453 pos2@var1957 ; }
190: }
191: } } }
192: if (@expr1073746454 pos2@var1957 ==@expr1073746455 std ::@expr4413 string ::@expr4590 npos@expr4410 ) {
193: ret@var1955 .@expr4428 push_back (@expr1073746459 line@var1954 .@expr4430 substr (@expr1073746461 pos1@var1956 ) ) ;
194: break ;
195: }
196: ret@var1955 .@expr4428 push_back (@expr1073746463 line@var1954 .@expr4430 substr (@expr1073746465 pos1@var1956 , pos2@var1957 +@expr4532 1 -@expr1073746467 pos1@var1956 ) ) ;
197: pos1@var1956 =@expr1073746468 line@var1954 .@expr4416 find_first_not_of (@expr1073746470 " " , pos2@var1957 +@expr4532 1 ) ;
198: }
199: return ret@var1955 ;
200: }
201:
202:
203: namespace clangimport {
204: struct Data {
205: struct Decl {
206: explicit Decl ( Scope * scope@var1960 ) : def@var1968 ( nullptr ) , enumerator@var1969 ( nullptr ) , function@var1970 ( nullptr ) , scope@var1971 ( scope@var1960 ) , var@var1972 ( nullptr ) { }
207: Decl ( Token * def@var1961 , Variable * var@var1962 ) : def@var1968 ( def@var1961 ) , enumerator@var1969 ( nullptr ) , function@var1970 ( nullptr ) , scope@var1971 ( nullptr ) , var@var1972 ( var@var1962 ) { }
208: Decl ( Token * def@var1963 , Function * function@var1964 ) : def@var1968 ( def@var1963 ) , enumerator@var1969 ( nullptr ) , function@var1970 ( function@var1964 ) , scope@var1971 ( nullptr ) , var@var1972 ( nullptr ) { }
209: Decl ( Token * def@var1965 , Enumerator * enumerator@var1966 ) : def@var1968 ( def@var1965 ) , enumerator@var1969 ( enumerator@var1966 ) , function@var1970 ( nullptr ) , scope@var1971 ( nullptr ) , var@var1972 ( nullptr ) { }
210: void ref ( Token * tok@var1967 ) {
211: if (@expr1073746472 enumerator@var1969 ) {
212: tok@var1967 .@expr1073746473 enumerator (@expr1073746474 enumerator@var1969 ) ; }
213: if (@expr1073746475 function@var1970 ) {
214: tok@var1967 .@expr1073746476 function (@expr1073746477 function@var1970 ) ; }
215: if (@expr1073746478 var@var1972 ) {
216: tok@var1967 .@expr1073746479 variable (@expr1073746480 var@var1972 ) ;
217: tok@var1967 .@expr1073746481 varId (@expr1073746482 var@var1972 .@expr1073746483 declarationId (@expr1073746484 ) ) ;
218: }
219: }
220: Token * def@var1968 ;
221: Enumerator * enumerator@var1969 ;
222: Function * function@var1970 ;
223: Scope * scope@var1971 ;
224: Variable * var@var1972 ;
225: } ;
226:
227: const Settings * mSettings@var1973 ; mSettings@var1973 = nullptr ;
228: SymbolDatabase * mSymbolDatabase@var1974 ; mSymbolDatabase@var1974 = nullptr ;
229:
230: int enumValue@var1975 ; enumValue@var1975 = 0 ;
231:
232: void enumDecl ( const std :: string & addr@var1976 , Token * nameToken@var1977 , Enumerator * enumerator@var1978 ) {
233: Decl decl@var1979 (@expr1073746485 nameToken@var1977 , enumerator@var1978 ) ;
234: mDeclMap@var2016 .@expr1073746486 insert (@expr1073746487 std ::@expr1073746488 pair < std ::@expr1073746489 string , Decl > (@expr1073746490 addr@var1976 , decl@var1979 ) ) ;
235: nameToken@var1977 .@expr1073746491 enumerator (@expr1073746492 enumerator@var1978 ) ;
236: notFound (@expr1073746493 addr@var1976 ) ;
237: }
238:
239: void funcDecl ( const std :: string & addr@var1980 , Token * nameToken@var1981 , Function * function@var1982 ) {
240: Decl decl@var1983 (@expr1073746494 nameToken@var1981 , function@var1982 ) ;
241: mDeclMap@var2016 .@expr1073746495 insert (@expr1073746496 std ::@expr1073746497 pair < std ::@expr1073746498 string , Decl > (@expr1073746499 addr@var1980 , decl@var1983 ) ) ;
242: nameToken@var1981 .@expr1073746500 function (@expr1073746501 function@var1982 ) ;
243: notFound (@expr1073746502 addr@var1980 ) ;
244: }
245:
246: void scopeDecl ( const std :: string & addr@var1984 , Scope * scope@var1985 ) {
247: Decl decl@var1986 (@expr1073746503 scope@var1985 ) ;
248: mDeclMap@var2016 .@expr1073746504 insert (@expr1073746505 std ::@expr1073746506 pair < std ::@expr1073746507 string , Decl > (@expr1073746508 addr@var1984 , decl@var1986 ) ) ;
249: }
250:
251: void varDecl ( const std :: string & addr@var1987 , Token * def@var1988 , Variable * var@var1989 ) {
252: Decl decl@var1990 (@expr1073746509 def@var1988 , var@var1989 ) ;
253: mDeclMap@var2016 .@expr1073746510 insert (@expr1073746511 std ::@expr1073746512 pair < std ::@expr1073746513 string , Decl > (@expr1073746514 addr@var1987 , decl@var1990 ) ) ;
254: def@var1988 .@expr1073746515 varId (@expr1073746516 ++@expr1073746517 mVarId@var2018 ) ;
255: def@var1988 .@expr1073746518 variable (@expr1073746519 var@var1989 ) ;
256: if (@expr1073746520 def@var1988 .@expr4697 valueType (@expr4698 ) ) {
257: var@var1989 .@expr1073746523 setValueType (@expr1073746524 *@expr1073746525 def@var1988 .@expr4697 valueType (@expr4698 ) ) ; }
258: notFound (@expr1073746528 addr@var1987 ) ;
259: }
260:
261: void replaceVarDecl ( const Variable * from@var1991 , Variable * to@var1992 ) {
262: for (@expr1073746529 auto &@expr4706 it@var1993 :@expr1073746531 mDeclMap@var2016 ) {
263: Decl &@expr4706 decl@var1994 =@expr1073746533 it@var1993 .@expr1073746534 second@var1995 ;
264: if (@expr1073746535 decl@var1994 .@expr4712 var@var1996 ==@expr1073746537 from@var1991 ) {
265: decl@var1994 .@expr4712 var@var1996 =@expr1073746539 to@var1992 ; }
266: }
267: }
268:
269: void ref ( const std :: string & addr@var1997 , Token * tok@var1998 ) {
270: auto it@var1999 ; it@var1999 =@expr1073746540 mDeclMap@var2016 .@expr1073746541 find (@expr1073746542 addr@var1997 ) ;
271: if (@expr1073746543 it@var1999 !=@expr1073746544 mDeclMap@var2016 .@expr1073746545 end (@expr1073746546 ) ) {
272: it@var1999 .@expr1073746547 second@var2000 .@expr1073746548 ref (@expr1073746549 tok@var1998 ) ; }
273: else {
274: mNotFound@var2017 [@expr1073746550 addr@var1997 ] .@expr1073746551 push_back (@expr1073746552 tok@var1998 ) ; }
275: }
276:
277: std :: vector < const Variable * > getVariableList ( ) const {
278: std ::@expr1073746553 vector < const Variable *@expr1073746554 > ret@var2001 ;
279: ret@var2001 .@expr1073746555 resize (@expr1073746556 mVarId@var2018 +@expr1073746557 1 , nullptr ) ;
280: for (@expr1073746558 const auto &@expr1073746559 it@var2002 :@expr1073746560 mDeclMap@var2016 ) {
281: if (@expr1073746561 it@var2002 .@expr4738 second@var2003 .@expr4739 var@var2004 ) {
282: ret@var2001 [@expr1073746564 it@var2002 .@expr4738 second@var2003 .@expr4739 var@var2004 .@expr1073746567 declarationId (@expr1073746568 ) ] =@expr1073746569 it@var2002 .@expr4738 second@var2003 .@expr4739 var@var2004 ; }
283: }
284: return ret@var2001 ;
285: }
286:
287: bool hasDecl ( const std :: string & addr@var2005 ) const {
288: return mDeclMap@var2016 .@expr1073746572 find (@expr1073746573 addr@var2005 ) !=@expr1073746574 mDeclMap@var2016 .@expr1073746575 end (@expr1073746576 ) ;
289: }
290:
291: const Scope * getScope ( const std :: string & addr@var2006 ) {
292: auto it@var2007 ; it@var2007 =@expr1073746577 mDeclMap@var2016 .@expr1073746578 find (@expr1073746579 addr@var2006 ) ;
293: return (@expr1073746580 it@var2007 ==@expr1073746581 mDeclMap@var2016 .@expr1073746582 end (@expr1073746583 ) ?@expr1073746584 nullptr :@expr1073746585 it@var2007 .@expr1073746586 second@var2008 .@expr1073746587 scope@var2009 ) ;
294: }
295:
296:
297: std :: set < Token * > mNotScope@var2010 ;
298:
299: std :: map < const Scope * , AccessControl > scopeAccessControl@var2011 ;
300: private:
301: void notFound ( const std :: string & addr@var2012 ) {
302: auto it@var2013 ; it@var2013 =@expr1073746588 mNotFound@var2017 .@expr1073746589 find (@expr1073746590 addr@var2012 ) ;
303: if (@expr1073746591 it@var2013 !=@expr1073746592 mNotFound@var2017 .@expr1073746593 end (@expr1073746594 ) ) {
304: for (@expr1073746595 Token *@expr1073746596 reftok@var2014 :@expr1073746597 it@var2013 .@expr1073746598 second@var2015 ) {
305: ref (@expr1073746599 addr@var2012 , reftok@var2014 ) ; }
306: mNotFound@var2017 .@expr1073746600 erase (@expr1073746601 it@var2013 ) ;
307: }
308: }
309:
310: std :: map < std :: string , Decl > mDeclMap@var2016 ;
311: std :: map < std :: string , std :: vector < Token * > > mNotFound@var2017 ;
312: int mVarId@var2018 ; mVarId@var2018 = 0 ;
313: } ;
314:
315: class AstNode ;
316:
317:
318: class AstNode {
319: public:
320: AstNode ( const std :: string & nodeType@var2019 , const std :: string & ext@var2020 , Data * data@var2021 )
321: : nodeType@var2022 ( nodeType@var2019 ) , mExtTokens@var2062 ( splitString ( ext@var2020 ) ) , mData@var2063 ( data@var2021 )
322: { }
323: std :: string nodeType@var2022 ;
324: std :: vector < std :: shared_ptr < AstNode > > children@var2023 ;
325:
326: void setLocations ( TokenList * tokenList@var2024 , int file@var2025 , int line@var2026 , int col@var2027 ) ;
327:
328: void dumpAst ( int num@var2028 = 0 , int indent@var2029 = 0 ) const ;
329: void createTokens1 ( TokenList * tokenList@var2030 ) {
330:
331: if (@expr1073746602 !@expr1073746603 tokenList@var2030 .@expr4780 back (@expr4781 ) ) {
332: setLocations (@expr1073746606 tokenList@var2030 , 0 , 1 , 1 ) ; }
333: else {
334: setLocations (@expr1073746607 tokenList@var2030 , tokenList@var2030 .@expr4780 back (@expr4781 ) .@expr1073746610 fileIndex (@expr1073746611 ) , tokenList@var2030 .@expr4780 back (@expr4781 ) .@expr1073746614 linenr (@expr1073746615 ) , 1 ) ; }
335: createTokens (@expr1073746616 tokenList@var2030 ) ;
336: if (@expr1073746617 nodeType@var2022 ==@expr1073746618 VarDecl@var1951 ||@expr1073746619 nodeType@var2022 ==@expr1073746620 RecordDecl@var1943 ||@expr1073746621 nodeType@var2022 ==@expr1073746622 TypedefDecl@var1948 ) {
337: addtoken (@expr1073746623 tokenList@var2030 , ";" ) ; }
338: mData@var2063 .@expr1073746624 mNotScope@var2064 .@expr1073746625 clear (@expr1073746626 ) ;
339: }
340:
341: std :: shared_ptr < AstNode > getChild ( int c@var2031 ) {
342: if (@expr1073746627 c@var2031 >=@expr1073746628 children@var2023 .@expr4805 size (@expr4806 ) ) {
343: std ::@expr1073746631 ostringstream err@var2032 ;
344: err@var2032 <<@expr1073746632 "ClangImport: AstNodePtr::getChild(" <<@expr1073746633 c@var2031 <<@expr1073746634 ") out of bounds. children.size=" <<@expr1073746635 children@var2023 .@expr4805 size (@expr4806 ) <<@expr1073746638 " " <<@expr1073746639 nodeType@var2022 ;
345: for (@expr1073746640 const std ::@expr1073746641 string &@expr1073746642 s@var2033 :@expr1073746643 mExtTokens@var2062 ) {
346: err@var2032 <<@expr1073746644 " " <<@expr1073746645 s@var2033 ; }
347: throw InternalError (@expr1073746646 nullptr , err@var2032 .@expr1073746647 str (@expr1073746648 ) ) ;
348: }
349: return children@var2023 [@expr1073746649 c@var2031 ] ;
350: }
351: private:
352: Token * createTokens ( TokenList * tokenList@var2034 ) ;
353: Token * addtoken ( TokenList * tokenList@var2035 , const std :: string & str@var2036 , bool valueType@var2037 = true ) ;
354: const :: Type * addTypeTokens ( TokenList * tokenList@var2038 , const std :: string & str@var2039 , const Scope * scope@var2040 = nullptr ) ;
355: void addFullScopeNameTokens ( TokenList * tokenList@var2041 , const Scope * recordScope@var2042 ) ;
356: Scope * createScope ( TokenList * tokenList@var2043 , Scope :: ScopeType scopeType@var2044 , std :: shared_ptr < AstNode > astNode@var2045 , const Token * def@var2046 ) ;
357: Scope * createScope ( TokenList * tokenList@var2047 , Scope :: ScopeType scopeType@var2048 , const std :: vector < std :: shared_ptr < AstNode > > & children2@var2049 , const Token * def@var2050 ) ;
358: Token * createTokensCall ( TokenList * tokenList@var2051 ) ;
359: void createTokensFunctionDecl ( TokenList * tokenList@var2052 ) ;
360: void createTokensForCXXRecord ( TokenList * tokenList@var2053 ) ;
361: Token * createTokensVarDecl ( TokenList * tokenList@var2054 ) ;
362: std :: string getSpelling ( ) const ;
363: std :: string getType ( int index@var2055 = 0 ) const ;
364: std :: string getFullType ( int index@var2056 = 0 ) const ;
365: bool isDefinition ( ) const ;
366: std :: string getTemplateParameters ( ) const ;
367: const Scope * getNestedInScope ( TokenList * tokenList@var2057 ) ;
368: void setValueType ( Token * tok@var2058 ) ;
369:
370: int mFile@var2059 ; mFile@var2059 = 0 ;
371: int mLine@var2060 ; mLine@var2060 = 1 ;
372: int mCol@var2061 ; mCol@var2061 = 1 ;
373: std :: vector < std :: string > mExtTokens@var2062 ;
374: Data * mData@var2063 ;
375: } ;
376: }
377:
378: std :: string clangimport :: AstNode :: getSpelling ( ) const
379: {
380: if (@expr1073746650 nodeType@var2022 ==@expr1073746651 CompoundAssignOperator@var1894 ) {
381: int typeIndex@var2065 ; typeIndex@var2065 =@expr1073746652 1 ;
382: while (@expr1073746653 typeIndex@var2065 <@expr1073746654 mExtTokens@var2062 .@expr4831 size (@expr4832 ) &&@expr1073746657 mExtTokens@var2062 [@expr1073746658 typeIndex@var2065 ] [@expr1073746659 0 ] !=@expr1073746660 '\'' ) {
383: typeIndex@var2065 ++@expr1073746661 ; }
384:
385: int nameIndex@var2066 ; nameIndex@var2066 =@expr1073746662 typeIndex@var2065 +@expr1073746663 1 ;
386: while (@expr1073746664 nameIndex@var2066 <@expr4841 mExtTokens@var2062 .@expr4831 size (@expr4832 ) &&@expr1073746668 mExtTokens@var2062 [@expr4845 nameIndex@var2066 ] [@expr1073746670 0 ] !=@expr1073746671 '\'' ) {
387: nameIndex@var2066 ++@expr1073746672 ; }
388: return (@expr4849 nameIndex@var2066 <@expr4841 mExtTokens@var2062 .@expr4831 size (@expr4832 ) ) ?@expr1073746677 unquote (@expr1073746678 mExtTokens@var2062 [@expr4845 nameIndex@var2066 ] ) :@expr1073746680 "" ;
389: }
390:
391: if (@expr1073746681 nodeType@var2022 ==@expr1073746682 UnaryExprOrTypeTraitExpr@var1950 ) {
392: int typeIndex@var2067 ; typeIndex@var2067 =@expr1073746683 1 ;
393: while (@expr1073746684 typeIndex@var2067 <@expr1073746685 mExtTokens@var2062 .@expr4831 size (@expr4832 ) &&@expr1073746688 mExtTokens@var2062 [@expr1073746689 typeIndex@var2067 ] [@expr1073746690 0 ] !=@expr1073746691 '\'' ) {
394: typeIndex@var2067 ++@expr1073746692 ; }
395: int nameIndex@var2068 ; nameIndex@var2068 =@expr1073746693 typeIndex@var2067 +@expr1073746694 1 ;
396: return (@expr4849 nameIndex@var2068 <@expr1073746696 mExtTokens@var2062 .@expr4831 size (@expr4832 ) ) ?@expr1073746699 unquote (@expr1073746700 mExtTokens@var2062 [@expr1073746701 nameIndex@var2068 ] ) :@expr1073746702 "" ;
397: }
398:
399: int typeIndex@var2069 ; typeIndex@var2069 =@expr1073746703 mExtTokens@var2062 .@expr4831 size (@expr4832 ) -@expr1073746706 1 ;
400: if (@expr1073746707 nodeType@var2022 ==@expr1073746708 FunctionDecl@var1928 ||@expr1073746709 nodeType@var2022 ==@expr1073746710 CXXConstructorDecl@var1900 ||@expr1073746711 nodeType@var2022 ==@expr1073746712 CXXMethodDecl@var1908 ) {
401: while (@expr1073746713 typeIndex@var2069 >=@expr1073746714 0 &&@expr1073746715 mExtTokens@var2062 [@expr4892 typeIndex@var2069 ] [@expr4893 0 ] !=@expr1073746718 '\'' ) {
402: typeIndex@var2069 --@expr1073746719 ; }
403: if (@expr4896 typeIndex@var2069 <=@expr4897 0 ) {
404: return "" ; }
405: }
406: if (@expr1073746722 nodeType@var2022 ==@expr1073746723 DeclRefExpr@var1918 ) {
407: while (@expr1073746724 typeIndex@var2069 >@expr1073746725 0 &&@expr1073746726 std ::@expr1073746727 isalpha (@expr1073746728 mExtTokens@var2062 [@expr4892 typeIndex@var2069 ] [@expr4893 0 ] ) ) {
408: typeIndex@var2069 --@expr1073746731 ; }
409: if (@expr4896 typeIndex@var2069 <=@expr4897 0 ) {
410: return "" ; }
411: }
412: const std ::@expr1073746734 string &@expr1073746735 str@var2070 =@expr1073746736 mExtTokens@var2062 [@expr1073746737 typeIndex@var2069 -@expr1073746738 1 ] ;
413: if (@expr1073746739 str@var2070 .@expr4916 compare (@expr1073746741 0 , 4 , "col:" ) ==@expr1073746742 0 ) {
414: return "" ; }
415: if (@expr1073746743 str@var2070 .@expr4916 compare (@expr1073746745 0 , 8 , "<invalid" ) ==@expr1073746746 0 ) {
416: return "" ; }
417: if (@expr1073746747 nodeType@var2022 ==@expr1073746748 RecordDecl@var1943 &&@expr1073746749 str@var2070 ==@expr1073746750 "struct" ) {
418: return "" ; }
419: return str@var2070 ;
420: }
421:
422: std :: string clangimport :: AstNode :: getType ( int index@var2071 ) const
423: {
424: std ::@expr1073746752 string type@var2072 ; type@var2072 =@expr1073746753 getFullType (@expr1073746754 index@var2071 ) ;
425: if (@expr1073746755 type@var2072 .@expr4932 find (@expr4933 " (" ) !=@expr1073746758 std ::@expr4935 string ::@expr4936 npos@expr4927 ) {
426: std ::@expr4935 string ::@expr1073746762 size_type pos@var2073 ; pos@var2073 =@expr1073746763 type@var2072 .@expr4932 find (@expr4933 " (" ) ;
427: type@var2072 [@expr1073746766 pos@var2073 ] =@expr1073746767 '\'' ;
428: type@var2072 .@expr4944 erase (@expr1073746769 pos@var2073 +@expr1073746770 1 ) ;
429: }
430: if (@expr1073746771 type@var2072 .@expr4932 find (@expr4949 " *(" ) !=@expr1073746774 std ::@expr4935 string ::@expr4936 npos@expr4927 ) {
431: std ::@expr4935 string ::@expr1073746778 size_type pos@var2074 ; pos@var2074 =@expr1073746779 type@var2072 .@expr4932 find (@expr4949 " *(" ) +@expr1073746782 2 ;
432: type@var2072 [@expr1073746783 pos@var2074 ] =@expr1073746784 '\'' ;
433: type@var2072 .@expr4944 erase (@expr1073746786 pos@var2074 +@expr1073746787 1 ) ;
434: }
435: if (@expr1073746788 type@var2072 .@expr4932 find (@expr4966 " &(" ) !=@expr1073746791 std ::@expr4935 string ::@expr4936 npos@expr4927 ) {
436: std ::@expr4935 string ::@expr1073746795 size_type pos@var2075 ; pos@var2075 =@expr1073746796 type@var2072 .@expr4932 find (@expr4966 " &(" ) +@expr1073746799 2 ;
437: type@var2072 [@expr1073746800 pos@var2075 ] =@expr1073746801 '\'' ;
438: type@var2072 .@expr4944 erase (@expr1073746803 pos@var2075 +@expr1073746804 1 ) ;
439: }
440: return unquote (@expr1073746805 type@var2072 ) ;
441: }
442:
443: std :: string clangimport :: AstNode :: getFullType ( int index@var2076 ) const
444: {
445: int typeIndex@var2077 ; typeIndex@var2077 =@expr1073746807 1 ;
446: while (@expr1073746808 typeIndex@var2077 <@expr1073746809 mExtTokens@var2062 .@expr4986 size (@expr4987 ) &&@expr1073746812 mExtTokens@var2062 [@expr4989 typeIndex@var2077 ] [@expr1073746814 0 ] !=@expr1073746815 '\'' ) {
447: typeIndex@var2077 ++@expr1073746816 ; }
448: if (@expr1073746817 typeIndex@var2077 >=@expr1073746818 mExtTokens@var2062 .@expr4986 size (@expr4987 ) ) {
449: return "" ; }
450: std ::@expr1073746821 string type@var2078 ; type@var2078 =@expr1073746822 mExtTokens@var2062 [@expr4989 typeIndex@var2077 ] ;
451: if (@expr1073746824 type@var2078 .@expr5001 find (@expr5002 "\':\'" ) !=@expr1073746827 std ::@expr1073746828 string ::@expr1073746829 npos@expr1073746806 ) {
452: if (@expr1073746830 index@var2076 ==@expr1073746831 0 ) {
453: type@var2078 .@expr5008 erase (@expr1073746833 type@var2078 .@expr5001 find (@expr5002 "\':\'" ) +@expr1073746836 1 ) ; }
454: else {
455: type@var2078 .@expr5008 erase (@expr1073746838 0 , type@var2078 .@expr5001 find (@expr5002 "\':\'" ) +@expr1073746841 2 ) ; }
456: }
457: return type@var2078 ;
458: }
459:
460: bool clangimport :: AstNode :: isDefinition ( ) const
461: {
462: return contains (@expr1073746842 mExtTokens@var2062 , "definition" ) ;
463: }
464:
465: std :: string clangimport :: AstNode :: getTemplateParameters ( ) const
466: {
467: if (@expr1073746844 children@var2023 .@expr1073746845 empty (@expr1073746846 ) ||@expr1073746847 children@var2023 [@expr1073746848 0 ] .@expr1073746849 nodeType@expr1073746843 !=@expr1073746850 TemplateArgument@var1947 ) {
468: return "" ; }
469: std ::@expr1073746851 string templateParameters@var2079 ;
470: for (@expr1073746852 const std ::@expr1073746853 shared_ptr < AstNode > &@expr1073746854 child@var2080 :@expr1073746855 children@var2023 ) {
471: if (@expr1073746856 child@var2080 .@expr1073746857 nodeType@var2081 ==@expr1073746858 TemplateArgument@var1947 ) {
472: if (@expr1073746859 templateParameters@var2079 .@expr1073746860 empty (@expr1073746861 ) ) {
473: templateParameters@var2079 =@expr1073746862 "<" ; }
474: else {
475: templateParameters@var2079 +=@expr1073746863 "," ; }
476: templateParameters@var2079 +=@expr1073746864 unquote (@expr1073746865 child@var2080 .@expr1073746866 mExtTokens@var2082 .@expr1073746867 back (@expr1073746868 ) ) ;
477: }
478: }
479: return templateParameters@var2079 +@expr1073746869 ">" ;
480: }
481:
482: void clangimport :: AstNode :: dumpAst ( int num@var2083 , int indent@var2084 ) const
483: {
484: (@expr1073746872 void ) num@var2083 ;
485: std ::@expr5049 cout@expr5046 <<@expr1073746874 std ::@expr5051 string (@expr1073746876 indent@var2084 , ' ' ) <<@expr1073746877 nodeType@var2022 ;
486: for (@expr1073746878 const auto &@expr1073746879 tok@var2085 :@expr1073746880 mExtTokens@var2062 ) {
487: std ::@expr5049 cout@expr5046 <<@expr1073746882 " " <<@expr1073746883 tok@var2085 ; }
488: std ::@expr5049 cout@expr5046 <<@expr1073746885 std ::@expr5062 endl@expr5047 ;
489: for (@expr1073746887 int c@var2086 =@expr1073746888 0 ; c@var2086 <@expr1073746889 children@var2023 .@expr1073746890 size (@expr1073746891 ) ; ++@expr1073746892 c@var2086 ) {
490: if (@expr1073746893 children@var2023 [@expr5070 c@var2086 ] ) {
491: children@var2023 [@expr5070 c@var2086 ] .@expr1073746896 dumpAst (@expr1073746897 c@var2086 , indent@var2084 +@expr5074 2 ) ; }
492: else {
493: std ::@expr5049 cout@expr5046 <<@expr1073746900 std ::@expr5051 string (@expr1073746902 indent@var2084 +@expr5074 2 , ' ' ) <<@expr1073746904 "<<<<NULL>>>>>" <<@expr1073746905 std ::@expr5062 endl@expr5047 ; }
494: }
495: }
496:
497: void clangimport :: AstNode :: setLocations ( TokenList * tokenList@var2087 , int file@var2088 , int line@var2089 , int col@var2090 )
498: {
499: for (@expr1073746908 const std ::@expr1073746909 string &@expr5086 ext@var2091 :@expr1073746911 mExtTokens@var2062 ) {
500: if (@expr1073746912 ext@var2091 .@expr5089 compare (@expr1073746914 0 , 5 , "<col:" ) ==@expr1073746915 0 ) {
501: col@var2090 =@expr1073746916 std ::@expr5093 atoi (@expr1073746918 ext@var2091 .@expr5095 substr (@expr1073746920 5 ) .@expr1073746921 c_str (@expr1073746922 ) ) ; }
502: else { if (@expr1073746923 ext@var2091 .@expr5089 compare (@expr1073746925 0 , 6 , "<line:" ) ==@expr1073746926 0 ) {
503: line@var2089 =@expr1073746927 std ::@expr5093 atoi (@expr1073746929 ext@var2091 .@expr5095 substr (@expr1073746931 6 ) .@expr1073746932 c_str (@expr1073746933 ) ) ;
504: if (@expr1073746934 ext@var2091 .@expr5111 find (@expr5112 ", col:" ) !=@expr1073746937 std ::@expr5114 string ::@expr5115 npos@expr5083 ) {
505: col@var2090 =@expr1073746940 std ::@expr5093 atoi (@expr1073746942 ext@var2091 .@expr1073746943 c_str (@expr1073746944 ) +@expr1073746945 ext@var2091 .@expr5111 find (@expr5112 ", col:" ) +@expr1073746948 6 ) ; }
506: } else { if (@expr1073746949 ext@var2091 [@expr1073746950 0 ] ==@expr1073746951 '<' &&@expr1073746952 ext@var2091 .@expr5111 find (@expr5130 ":" ) !=@expr1073746955 std ::@expr5114 string ::@expr5115 npos@expr5083 ) {
507: std ::@expr5114 string ::@expr1073746959 size_type sep1@var2092 ; sep1@var2092 =@expr1073746960 ext@var2091 .@expr5111 find (@expr5130 ":" ) ;
508: std ::@expr5114 string ::@expr1073746964 size_type sep2@var2093 ; sep2@var2093 =@expr1073746965 ext@var2091 .@expr5111 find (@expr1073746967 ":" , sep1@var2092 +@expr5144 1 ) ;
509: file@var2088 =@expr1073746969 tokenList@var2087 .@expr1073746970 appendFileIfNew (@expr1073746971 ext@var2091 .@expr5095 substr (@expr1073746973 1 , sep1@var2092 -@expr1073746974 1 ) ) ;
510: line@var2089 =@expr1073746975 MathLib ::@expr1073746976 toLongNumber (@expr1073746977 ext@var2091 .@expr5095 substr (@expr1073746979 sep1@var2092 +@expr5144 1 , sep2@var2093 -@expr1073746981 sep1@var2092 ) ) ;
511: } } }
512: }
513: mFile@var2059 =@expr1073746982 file@var2088 ;
514: mLine@var2060 =@expr1073746983 line@var2089 ;
515: mCol@var2061 =@expr1073746984 col@var2090 ;
516: for (@expr1073746985 const auto &@expr5086 child@var2094 :@expr1073746987 children@var2023 ) {
517: if (@expr1073746988 child@var2094 ) {
518: child@var2094 .@expr1073746989 setLocations (@expr1073746990 tokenList@var2087 , file@var2088 , line@var2089 , col@var2090 ) ; }
519: }
520: }
521:
522: Token * clangimport :: AstNode :: addtoken ( TokenList * tokenList@var2095 , const std :: string & str@var2096 , bool valueType@var2097 )
523: {
524: const Scope * scope@var2098 ; scope@var2098 =@expr1073746991 getNestedInScope (@expr1073746992 tokenList@var2095 ) ;
525: tokenList@var2095 .@expr1073746993 addtoken (@expr1073746994 str@var2096 , mLine@var2060 , mCol@var2061 , mFile@var2059 ) ;
526: tokenList@var2095 .@expr5171 back (@expr5172 ) .@expr1073746997 scope (@expr1073746998 scope@var2098 ) ;
527: if (@expr1073746999 valueType@var2097 ) {
528: setValueType (@expr1073747000 tokenList@var2095 .@expr5171 back (@expr5172 ) ) ; }
529: return tokenList@var2095 .@expr5171 back (@expr5172 ) ;
530: }
531:
532: const :: Type * clangimport :: AstNode :: addTypeTokens ( TokenList * tokenList@var2099 , const std :: string & str@var2100 , const Scope * scope@var2101 )
533: {
534: if (@expr1073747006 str@var2100 .@expr5183 find (@expr5184 "\':\'" ) !=@expr1073747009 std ::@expr5186 string ::@expr5187 npos@expr5181 ) {
535: return addTypeTokens (@expr1073747012 tokenList@var2099 , str@var2100 .@expr5189 substr (@expr1073747014 0 , str@var2100 .@expr5183 find (@expr5184 "\':\'" ) +@expr1073747017 1 ) , scope@var2101 ) ;
536: }
537:
538: if (@expr1073747018 str@var2100 .@expr1073747019 compare (@expr1073747020 0 , 16 , "'enum (anonymous" ) ==@expr1073747021 0 ) {
539: return nullptr ; }
540:
541: std ::@expr1073747022 string type@var2102 ;
542: if (@expr1073747023 str@var2100 .@expr5183 find (@expr5201 " (" ) !=@expr1073747026 std ::@expr5186 string ::@expr5187 npos@expr5181 ) {
543: if (@expr1073747029 str@var2100 .@expr5183 find (@expr5207 "<" ) !=@expr1073747032 std ::@expr5186 string ::@expr5187 npos@expr5181 ) {
544: type@var2102 =@expr1073747035 str@var2100 .@expr5189 substr (@expr1073747037 1 , str@var2100 .@expr5183 find (@expr5207 "<" ) ) +@expr1073747040 "...>" ; }
545: else {
546: type@var2102 =@expr1073747041 str@var2100 .@expr5189 substr (@expr1073747043 1 , str@var2100 .@expr5183 find (@expr5201 " (" ) -@expr1073747046 1 ) ; }
547: } else {
548: type@var2102 =@expr1073747047 unquote (@expr1073747048 str@var2100 ) ; }
549:
550: if (@expr1073747049 type@var2102 .@expr5226 find (@expr5227 "(*)(" ) !=@expr1073747052 std ::@expr5186 string ::@expr5187 npos@expr5181 ) {
551: type@var2102 .@expr5231 erase (@expr1073747056 type@var2102 .@expr5226 find (@expr5227 "(*)(" ) ) ;
552: type@var2102 +=@expr1073747059 "*" ;
553: }
554: if (@expr1073747060 type@var2102 .@expr5226 find (@expr5238 "(" ) !=@expr1073747063 std ::@expr5186 string ::@expr5187 npos@expr5181 ) {
555: type@var2102 .@expr5231 erase (@expr1073747067 type@var2102 .@expr5226 find (@expr5238 "(" ) ) ; }
556:
557: std ::@expr1073747070 stack < Token *@expr5247 > lpar@var2103 ;
558: for (@expr1073747072 const std ::@expr1073747073 string &@expr1073747074 s@var2104 :@expr1073747075 splitString (@expr1073747076 type@var2102 ) ) {
559: Token * tok@var2105 ; tok@var2105 =@expr1073747077 addtoken (@expr1073747078 tokenList@var2099 , s@var2104 , false ) ;
560: if (@expr1073747079 tok@var2105 .@expr5256 str (@expr5257 ) ==@expr1073747082 "(" ) {
561: lpar@var2103 .@expr1073747083 push (@expr1073747084 tok@var2105 ) ; }
562: else { if (@expr1073747085 tok@var2105 .@expr5256 str (@expr5257 ) ==@expr1073747088 ")" ) {
563: Token ::@expr1073747089 createMutualLinks (@expr1073747090 tok@var2105 , lpar@var2103 .@expr1073747091 top (@expr1073747092 ) ) ;
564: lpar@var2103 .@expr1073747093 pop (@expr1073747094 ) ;
565: } }
566: }
567:
568:
569: if (@expr5271 !@expr5272 scope@var2101 ) {
570: scope@var2101 =@expr1073747097 tokenList@var2099 .@expr5274 back (@expr5275 ) ?@expr1073747100 tokenList@var2099 .@expr5274 back (@expr5275 ) .@expr1073747103 scope (@expr1073747104 ) :@expr1073747105 nullptr ;
571: if (@expr5271 !@expr5272 scope@var2101 ) {
572: return nullptr ; }
573: }
574: for (@expr1073747108 const Token *@expr5247 typeToken@var2106 =@expr1073747110 tokenList@var2099 .@expr5274 back (@expr5275 ) ; Token ::@expr1073747113 Match (@expr1073747114 typeToken@var2106 , "&|*|%name%" ) ; typeToken@var2106 =@expr1073747115 typeToken@var2106 .@expr1073747116 previous (@expr1073747117 ) ) {
575: if (@expr1073747118 !@expr1073747119 typeToken@var2106 .@expr1073747120 isName (@expr1073747121 ) ) {
576: continue ; }
577: const ::@expr1073747122 Type * recordType@var2107 ; recordType@var2107 =@expr1073747123 scope@var2101 .@expr1073747124 check@var2108 .@expr1073747125 findVariableType (@expr1073747126 scope@var2101 , typeToken@var2106 ) ;
578: if (@expr1073747127 recordType@var2107 ) {
579: const_cast < Token *@expr5247 > (@expr1073747129 typeToken@var2106 ) .@expr1073747130 type (@expr1073747131 recordType@var2107 ) ;
580: return recordType@var2107 ;
581: }
582: }
583: return nullptr ;
584: }
585:
586: void clangimport :: AstNode :: addFullScopeNameTokens ( TokenList * tokenList@var2109 , const Scope * recordScope@var2110 )
587: {
588: if (@expr1073747132 !@expr1073747133 recordScope@var2110 ) {
589: return ; }
590: std ::@expr1073747134 list < const Scope *@expr5311 > scopes@var2111 ;
591: while (@expr1073747136 recordScope@var2110 &&@expr1073747137 recordScope@var2110 !=@expr1073747138 tokenList@var2109 .@expr1073747139 back (@expr1073747140 ) .@expr1073747141 scope (@expr1073747142 ) &&@expr1073747143 !@expr1073747144 recordScope@var2110 .@expr1073747145 isExecutable (@expr1073747146 ) ) {
592: scopes@var2111 .@expr1073747147 push_front (@expr1073747148 recordScope@var2110 ) ;
593: recordScope@var2110 =@expr1073747149 recordScope@var2110 .@expr1073747150 nestedIn@var2112 ;
594: }
595: for (@expr1073747151 const Scope *@expr5311 s@var2113 :@expr1073747153 scopes@var2111 ) {
596: if (@expr1073747154 !@expr1073747155 s@var2113 .@expr5332 className@var2114 .@expr1073747157 empty (@expr1073747158 ) ) {
597: addtoken (@expr1073747159 tokenList@var2109 , s@var2113 .@expr5332 className@var2114 ) ;
598: addtoken (@expr1073747161 tokenList@var2109 , "::" ) ;
599: }
600: }
601: }
602:
603: const Scope * clangimport :: AstNode :: getNestedInScope ( TokenList * tokenList@var2115 )
604: {
605: if (@expr1073747162 !@expr1073747163 tokenList@var2115 .@expr5340 back (@expr5341 ) ) {
606: return &@expr1073747166 mData@var2063 .@expr1073747167 mSymbolDatabase@var2433 .@expr1073747168 scopeList@var2434 .@expr1073747169 front (@expr1073747170 ) ; }
607: if (@expr1073747171 tokenList@var2115 .@expr5340 back (@expr5341 ) .@expr1073747174 str (@expr1073747175 ) ==@expr1073747176 "}" &&@expr1073747177 mData@var2063 .@expr5354 mNotScope@var2435 .@expr1073747179 find (@expr1073747180 tokenList@var2115 .@expr5340 back (@expr5341 ) ) ==@expr1073747183 mData@var2063 .@expr5354 mNotScope@var2435 .@expr1073747185 end (@expr1073747186 ) ) {
608: return tokenList@var2115 .@expr5340 back (@expr5341 ) .@expr5365 scope (@expr5366 ) .@expr1073747191 nestedIn@var2453 ; }
609: return tokenList@var2115 .@expr5340 back (@expr5341 ) .@expr5365 scope (@expr5366 ) ;
610: }
611:
612: void clangimport :: AstNode :: setValueType ( Token * tok@var2116 )
613: {
614: for (@expr1073747197 int i@var2117 =@expr1073747198 0 ; i@var2117 <@expr1073747199 2 ; i@var2117 ++@expr1073747200 ) {
615: const std ::@expr1073747201 string &@expr1073747202 type@var2118 =@expr1073747203 getType (@expr1073747204 i@var2117 ) ;
616:
617: if (@expr1073747205 type@var2118 .@expr1073747206 find (@expr1073747207 "<" ) !=@expr1073747208 std ::@expr1073747209 string ::@expr1073747210 npos@expr1073747196 ) {
618:
619: continue ; }
620:
621: TokenList decl@var2119 (@expr1073747211 nullptr ) ;
622: addTypeTokens (@expr1073747212 &@expr1073747213 decl@var2119 , type@var2118 , tok@var2116 .@expr1073747214 scope (@expr1073747215 ) ) ;
623: if (@expr1073747216 !@expr1073747217 decl@var2119 .@expr5394 front (@expr5395 ) ) {
624: break ; }
625:
626: ValueType valueType@var2120 ; valueType@var2120 =@expr1073747220 ValueType ::@expr1073747221 parseDecl (@expr1073747222 decl@var2119 .@expr5394 front (@expr5395 ) , mData@var2063 .@expr1073747225 mSettings@var2436 ) ;
627: if (@expr1073747226 valueType@var2120 .@expr1073747227 type@var2121 !=@expr1073747228 ValueType ::@expr1073747229 Type ::@expr1073747230 UNKNOWN_TYPE ) {
628: tok@var2116 .@expr1073747231 setValueType (@expr1073747232 new ValueType (@expr1073747233 valueType@var2120 ) ) ;
629: break ;
630: }
631: }
632: }
633:
634: Scope * clangimport :: AstNode :: createScope ( TokenList * tokenList@var2122 , Scope :: ScopeType scopeType@var2123 , std :: shared_ptr < AstNode > astNode@var2124 , const Token * def@var2125 )
635: {
636: std ::@expr5410 vector < std ::@expr5410 shared_ptr < AstNode > > children2@var2126 {@expr1073747236 astNode@var2124 } ;
637: return createScope (@expr1073747237 tokenList@var2122 , scopeType@var2123 , children2@var2126 , def@var2125 ) ;
638: }
639:
640: Scope * clangimport :: AstNode :: createScope ( TokenList * tokenList@var2127 , Scope :: ScopeType scopeType@var2128 , const std :: vector < std :: shared_ptr < AstNode > > & children2@var2129 , const Token * def@var2130 )
641: {
642: SymbolDatabase * symbolDatabase@var2131 ; symbolDatabase@var2131 =@expr1073747239 mData@var2063 .@expr1073747240 mSymbolDatabase@var2433 ;
643:
644: Scope * nestedIn@var2132 ; nestedIn@var2132 =@expr1073747241 const_cast < Scope *@expr5418 > (@expr1073747243 getNestedInScope (@expr1073747244 tokenList@var2127 ) ) ;
645:
646: symbolDatabase@var2131 .@expr5421 scopeList@var2133 .@expr1073747246 push_back (@expr1073747247 Scope (@expr1073747248 nullptr , nullptr , nestedIn@var2132 ) ) ;
647: Scope * scope@var2134 ; scope@var2134 =@expr1073747249 &@expr1073747250 symbolDatabase@var2131 .@expr5421 scopeList@var2133 .@expr1073747252 back (@expr1073747253 ) ;
648: if (@expr5430 scopeType@var2128 ==@expr5431 Scope ::@expr5432 ScopeType ::@expr5433 eEnum ) {
649: scope@var2134 .@expr1073747258 enumeratorList@var2135 .@expr1073747259 reserve (@expr1073747260 children2@var2129 .@expr1073747261 size (@expr1073747262 ) ) ; }
650: nestedIn@var2132 .@expr1073747263 nestedList@var2136 .@expr1073747264 push_back (@expr1073747265 scope@var2134 ) ;
651: scope@var2134 .@expr1073747266 type@var2137 =@expr1073747267 scopeType@var2128 ;
652: scope@var2134 .@expr1073747268 classDef@var2138 =@expr1073747269 def@var2130 ;
653: scope@var2134 .@expr1073747270 check@var2139 =@expr1073747271 nestedIn@var2132 .@expr1073747272 check@var2140 ;
654: if (@expr1073747273 Token ::@expr5450 Match (@expr1073747275 def@var2130 , "if|for|while (" ) ) {
655: std ::@expr1073747276 map < const Variable *@expr5418 , const Variable *@expr5418 > replaceVar@var2141 ;
656: for (@expr1073747279 const Token *@expr5418 vartok@var2142 =@expr1073747281 def@var2130 .@expr1073747282 tokAt (@expr1073747283 2 ) ; vartok@var2142 ; vartok@var2142 =@expr1073747284 vartok@var2142 .@expr1073747285 next (@expr1073747286 ) ) {
657: if (@expr1073747287 !@expr1073747288 vartok@var2142 .@expr5465 variable (@expr5466 ) ) {
658: continue ; }
659: if (@expr1073747291 vartok@var2142 .@expr5465 variable (@expr5466 ) .@expr1073747294 nameToken (@expr1073747295 ) ==@expr1073747296 vartok@var2142 ) {
660: const Variable * from@var2143 ; from@var2143 =@expr1073747297 vartok@var2142 .@expr5465 variable (@expr5466 ) ;
661: scope@var2134 .@expr5476 varlist@var2144 .@expr1073747301 emplace_back (@expr1073747302 *@expr1073747303 from@var2143 , scope@var2134 ) ;
662: Variable * to@var2145 ; to@var2145 =@expr1073747304 &@expr1073747305 scope@var2134 .@expr5476 varlist@var2144 .@expr1073747307 back (@expr1073747308 ) ;
663: replaceVar@var2141 [@expr1073747309 from@var2143 ] =@expr1073747310 to@var2145 ;
664: mData@var2063 .@expr1073747311 replaceVarDecl (@expr1073747312 from@var2143 , to@var2145 ) ;
665: }
666: if (@expr1073747313 replaceVar@var2141 .@expr5490 find (@expr1073747315 vartok@var2142 .@expr5465 variable (@expr5466 ) ) !=@expr1073747318 replaceVar@var2141 .@expr5495 end (@expr5496 ) ) {
667: const_cast < Token *@expr5418 > (@expr1073747322 vartok@var2142 ) .@expr1073747323 variable (@expr1073747324 replaceVar@var2141 [@expr1073747325 vartok@var2142 .@expr5465 variable (@expr5466 ) ] ) ; }
668: }
669: std ::@expr1073747328 list < Variable > & varlist@var2146 =@expr1073747329 const_cast < Scope *@expr5418 > (@expr1073747331 def@var2130 .@expr1073747332 scope (@expr1073747333 ) ) .@expr1073747334 varlist@expr1073747238 ;
670: for (@expr1073747335 std ::@expr5512 list < Variable > ::@expr5512 iterator var@var2147 =@expr1073747338 varlist@var2146 .@expr1073747339 begin (@expr1073747340 ) ; var@var2147 !=@expr1073747341 varlist@var2146 .@expr1073747342 end (@expr1073747343 ) ; ) {
671: if (@expr1073747344 replaceVar@var2141 .@expr5490 find (@expr1073747346 &@expr1073747347 (@expr1073747348 *@expr1073747349 var@var2147 ) ) !=@expr1073747350 replaceVar@var2141 .@expr5495 end (@expr5496 ) ) {
672: varlist@var2146 .@expr1073747353 erase (@expr1073747354 var@var2147 ++@expr1073747355 ) ; }
673: else {
674: ++@expr1073747356 var@var2147 ; }
675: }
676: }
677: scope@var2134 .@expr5533 bodyStart@var2148 =@expr1073747358 addtoken (@expr1073747359 tokenList@var2127 , "{" ) ;
678: tokenList@var2127 .@expr5536 back (@expr5537 ) .@expr1073747362 scope (@expr1073747363 scope@var2134 ) ;
679: mData@var2063 .@expr5540 scopeAccessControl@var2437 [@expr5541 scope@var2134 ] =@expr1073747366 scope@var2134 .@expr1073747367 defaultAccess (@expr1073747368 ) ;
680: if (@expr1073747369 !@expr1073747370 children2@var2129 .@expr1073747371 empty (@expr1073747372 ) ) {
681: for (@expr1073747373 const AstNodePtr &@expr1073747374 astNode@var2149 :@expr1073747375 children2@var2129 ) {
682: if (@expr1073747376 astNode@var2149 .@expr5553 nodeType@var2150 ==@expr1073747378 "VisibilityAttr" ) {
683: continue ; }
684: if (@expr1073747379 astNode@var2149 .@expr5553 nodeType@var2150 ==@expr1073747381 AccessSpecDecl@var1883 ) {
685: if (@expr1073747382 contains (@expr1073747383 astNode@var2149 .@expr5560 mExtTokens@var2151 , "private" ) ) {
686: mData@var2063 .@expr5540 scopeAccessControl@var2437 [@expr5541 scope@var2134 ] =@expr1073747387 AccessControl ::@expr1073747388 Private ; }
687: else { if (@expr1073747389 contains (@expr1073747390 astNode@var2149 .@expr5560 mExtTokens@var2151 , "protected" ) ) {
688: mData@var2063 .@expr5540 scopeAccessControl@var2437 [@expr5541 scope@var2134 ] =@expr1073747394 AccessControl ::@expr1073747395 Protected ; }
689: else { if (@expr1073747396 contains (@expr1073747397 astNode@var2149 .@expr5560 mExtTokens@var2151 , "public" ) ) {
690: mData@var2063 .@expr5540 scopeAccessControl@var2437 [@expr5541 scope@var2134 ] =@expr1073747401 AccessControl ::@expr1073747402 Public ; } } }
691: continue ;
692: }
693: astNode@var2149 .@expr1073747403 createTokens (@expr1073747404 tokenList@var2127 ) ;
694: if (@expr5430 scopeType@var2128 ==@expr5431 Scope ::@expr5432 ScopeType ::@expr5433 eEnum ) {
695: astNode@var2149 .@expr5585 addtoken (@expr1073747410 tokenList@var2127 , "," ) ; }
696: else { if (@expr1073747411 !@expr1073747412 Token ::@expr5450 Match (@expr1073747414 tokenList@var2127 .@expr5536 back (@expr5537 ) , "[;{}]" ) ) {
697: astNode@var2149 .@expr5585 addtoken (@expr1073747418 tokenList@var2127 , ";" ) ; } }
698: }
699: }
700: scope@var2134 .@expr5595 bodyEnd@var2152 =@expr1073747420 addtoken (@expr1073747421 tokenList@var2127 , "}" ) ;
701: Token ::@expr1073747422 createMutualLinks (@expr1073747423 const_cast < Token *@expr5418 > (@expr1073747425 scope@var2134 .@expr5533 bodyStart@var2148 ) , const_cast < Token *@expr5418 > (@expr1073747428 scope@var2134 .@expr5595 bodyEnd@var2152 ) ) ;
702: mData@var2063 .@expr5540 scopeAccessControl@var2437 .@expr1073747431 erase (@expr1073747432 scope@var2134 ) ;
703: return scope@var2134 ;
704: }
705:
706: Token * clangimport :: AstNode :: createTokens ( TokenList * tokenList@var2153 )
707: {
708: if (@expr1073747441 nodeType@var2022 ==@expr1073747442 ArraySubscriptExpr@var1884 ) {
709: Token * array@var2154 ; array@var2154 =@expr1073747443 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
710: Token * bracket1@var2155 ; bracket1@var2155 =@expr1073747447 addtoken (@expr5624 tokenList@var2153 , "[" ) ;
711: Token * index@var2156 ; index@var2156 =@expr1073747449 children@var2023 [@expr5626 1 ] .@expr5627 createTokens (@expr5628 tokenList@var2153 ) ;
712: Token * bracket2@var2157 ; bracket2@var2157 =@expr1073747453 addtoken (@expr5630 tokenList@var2153 , "]" ) ;
713: bracket1@var2155 .@expr1073747455 astOperand1 (@expr1073747456 array@var2154 ) ;
714: bracket1@var2155 .@expr1073747457 astOperand2 (@expr1073747458 index@var2156 ) ;
715: bracket1@var2155 .@expr1073747459 link (@expr1073747460 bracket2@var2157 ) ;
716: bracket2@var2157 .@expr1073747461 link (@expr1073747462 bracket1@var2155 ) ;
717: return bracket1@var2155 ;
718: }
719: if (@expr1073747463 nodeType@var2022 ==@expr1073747464 BinaryOperator@var1885 ) {
720: Token * tok1@var2158 ; tok1@var2158 =@expr1073747465 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
721: Token * binop@var2159 ; binop@var2159 =@expr1073747469 addtoken (@expr5646 tokenList@var2153 , unquote (@expr5647 mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ) ;
722: Token * tok2@var2160 ; tok2@var2160 =@expr1073747474 children@var2023 [@expr5626 1 ] .@expr5627 createTokens (@expr5628 tokenList@var2153 ) ;
723: binop@var2159 .@expr1073747478 astOperand1 (@expr1073747479 tok1@var2158 ) ;
724: binop@var2159 .@expr1073747480 astOperand2 (@expr1073747481 tok2@var2160 ) ;
725: return binop@var2159 ;
726: }
727: if (@expr1073747482 nodeType@var2022 ==@expr1073747483 BreakStmt@var1886 ) {
728: return addtoken (@expr1073747484 tokenList@var2153 , "break" ) ; }
729: if (@expr1073747485 nodeType@var2022 ==@expr1073747486 CharacterLiteral@var1889 ) {
730: int c@var2161 ; c@var2161 =@expr1073747487 MathLib ::@expr1073747488 toLongNumber (@expr1073747489 mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ;
731: if (@expr1073747492 c@var2161 ==@expr1073747493 0 ) {
732: return addtoken (@expr1073747494 tokenList@var2153 , "\'\\0\'" ) ; }
733: if (@expr1073747495 c@var2161 ==@expr1073747496 '\r' ) {
734: return addtoken (@expr1073747497 tokenList@var2153 , "\'\\r\'" ) ; }
735: if (@expr1073747498 c@var2161 ==@expr1073747499 '\n' ) {
736: return addtoken (@expr1073747500 tokenList@var2153 , "\'\\n\'" ) ; }
737: if (@expr1073747501 c@var2161 ==@expr1073747502 '\t' ) {
738: return addtoken (@expr1073747503 tokenList@var2153 , "\'\\t\'" ) ; }
739: if (@expr1073747504 c@var2161 ==@expr1073747505 '\\' ) {
740: return addtoken (@expr1073747506 tokenList@var2153 , "\'\\\\\'" ) ; }
741: if (@expr1073747507 c@var2161 <@expr1073747508 ' ' ||@expr1073747509 c@var2161 >=@expr1073747510 0x80 ) {
742: std ::@expr1073747511 ostringstream hex@var2162 ;
743: hex@var2162 <<@expr1073747512 std ::@expr1073747513 hex@expr1073747433 <<@expr1073747514 (@expr1073747515 (@expr1073747516 c@var2161 >>@expr1073747517 4 ) &@expr1073747518 0xf ) <<@expr1073747519 (@expr1073747520 c@var2161 &@expr1073747521 0xf ) ;
744: return addtoken (@expr1073747522 tokenList@var2153 , "\'\\x" +@expr1073747523 hex@var2162 .@expr1073747524 str (@expr1073747525 ) +@expr1073747526 "\'" ) ;
745: }
746: return addtoken (@expr1073747527 tokenList@var2153 , std ::@expr5704 string (@expr5705 "\'" ) +@expr1073747530 char (@expr1073747531 c@var2161 ) +@expr1073747532 std ::@expr5704 string (@expr5705 "\'" ) ) ;
747: }
748: if (@expr1073747535 nodeType@var2022 ==@expr1073747536 CallExpr@var1887 ) {
749: return createTokensCall (@expr5713 tokenList@var2153 ) ; }
750: if (@expr1073747538 nodeType@var2022 ==@expr1073747539 CaseStmt@var1888 ) {
751: Token * caseToken@var2163 ; caseToken@var2163 =@expr1073747540 addtoken (@expr1073747541 tokenList@var2153 , "case" ) ;
752: Token * exprToken@var2164 ; exprToken@var2164 =@expr1073747542 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
753: caseToken@var2163 .@expr1073747546 astOperand1 (@expr1073747547 exprToken@var2164 ) ;
754: addtoken (@expr5724 tokenList@var2153 , ":" ) ;
755: children@var2023 .@expr5725 back (@expr5726 ) .@expr5727 createTokens (@expr5728 tokenList@var2153 ) ;
756: return nullptr ;
757: }
758: if (@expr1073747553 nodeType@var2022 ==@expr1073747554 ClassTemplateDecl@var1890 ) {
759: for (@expr1073747555 const AstNodePtr &@expr5732 child@var2165 :@expr1073747557 children@var2023 ) {
760: if (@expr1073747558 child@var2165 .@expr1073747559 nodeType@var2166 ==@expr1073747560 ClassTemplateSpecializationDecl@var1891 ) {
761: child@var2165 .@expr1073747561 createTokens (@expr1073747562 tokenList@var2153 ) ; }
762: }
763: return nullptr ;
764: }
765: if (@expr1073747563 nodeType@var2022 ==@expr1073747564 ClassTemplateSpecializationDecl@var1891 ) {
766: createTokensForCXXRecord (@expr5741 tokenList@var2153 ) ;
767: return nullptr ;
768: }
769: if (@expr1073747566 nodeType@var2022 ==@expr1073747567 ConditionalOperator@var1892 ) {
770: Token * expr1@var2167 ; expr1@var2167 =@expr1073747568 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
771: Token * tok1@var2168 ; tok1@var2168 =@expr1073747572 addtoken (@expr1073747573 tokenList@var2153 , "?" ) ;
772: Token * expr2@var2169 ; expr2@var2169 =@expr1073747574 children@var2023 [@expr5626 1 ] .@expr5627 createTokens (@expr5628 tokenList@var2153 ) ;
773: Token * tok2@var2170 ; tok2@var2170 =@expr1073747578 addtoken (@expr5724 tokenList@var2153 , ":" ) ;
774: Token * expr3@var2171 ; expr3@var2171 =@expr1073747580 children@var2023 [@expr5757 2 ] .@expr5758 createTokens (@expr5759 tokenList@var2153 ) ;
775: tok2@var2170 .@expr1073747584 astOperand1 (@expr1073747585 expr2@var2169 ) ;
776: tok2@var2170 .@expr1073747586 astOperand2 (@expr1073747587 expr3@var2171 ) ;
777: tok1@var2168 .@expr1073747588 astOperand1 (@expr1073747589 expr1@var2167 ) ;
778: tok1@var2168 .@expr1073747590 astOperand2 (@expr1073747591 tok2@var2170 ) ;
779: return tok1@var2168 ;
780: }
781: if (@expr1073747592 nodeType@var2022 ==@expr1073747593 CompoundAssignOperator@var1894 ) {
782: Token * lhs@var2172 ; lhs@var2172 =@expr1073747594 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
783: Token * assign@var2173 ; assign@var2173 =@expr1073747598 addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ;
784: Token * rhs@var2174 ; rhs@var2174 =@expr1073747601 children@var2023 [@expr5626 1 ] .@expr5627 createTokens (@expr5628 tokenList@var2153 ) ;
785: assign@var2173 .@expr1073747605 astOperand1 (@expr1073747606 lhs@var2172 ) ;
786: assign@var2173 .@expr1073747607 astOperand2 (@expr1073747608 rhs@var2174 ) ;
787: return assign@var2173 ;
788: }
789: if (@expr1073747609 nodeType@var2022 ==@expr1073747610 CompoundStmt@var1895 ) {
790: for (@expr1073747611 const AstNodePtr &@expr5732 child@var2175 :@expr1073747613 children@var2023 ) {
791: child@var2175 .@expr1073747614 createTokens (@expr1073747615 tokenList@var2153 ) ;
792: if (@expr1073747616 !@expr1073747617 Token ::@expr1073747618 Match (@expr1073747619 tokenList@var2153 .@expr5796 back (@expr5797 ) , "[;{}]" ) ) {
793: child@var2175 .@expr1073747622 addtoken (@expr1073747623 tokenList@var2153 , ";" ) ; }
794: }
795: return nullptr ;
796: }
797: if (@expr1073747624 nodeType@var2022 ==@expr1073747625 ConstantExpr@var1893 ) {
798: return children@var2023 .@expr5725 back (@expr5726 ) .@expr5727 createTokens (@expr5728 tokenList@var2153 ) ; }
799: if (@expr1073747630 nodeType@var2022 ==@expr1073747631 ContinueStmt@var1896 ) {
800: return addtoken (@expr1073747632 tokenList@var2153 , "continue" ) ; }
801: if (@expr1073747633 nodeType@var2022 ==@expr1073747634 CStyleCastExpr@var1897 ) {
802: Token * par1@var2176 ; par1@var2176 =@expr1073747635 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
803: addTypeTokens (@expr5813 tokenList@var2153 , '\'' +@expr5814 getType (@expr5815 ) +@expr5816 '\'' ) ;
804: Token * par2@var2177 ; par2@var2177 =@expr1073747641 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
805: par1@var2176 .@expr1073747643 link (@expr1073747644 par2@var2177 ) ;
806: par2@var2177 .@expr1073747645 link (@expr1073747646 par1@var2176 ) ;
807: par1@var2176 .@expr1073747647 astOperand1 (@expr1073747648 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ) ;
808: return par1@var2176 ;
809: }
810: if (@expr1073747652 nodeType@var2022 ==@expr1073747653 CXXBindTemporaryExpr@var1898 ) {
811: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
812: if (@expr1073747657 nodeType@var2022 ==@expr1073747658 CXXBoolLiteralExpr@var1899 ) {
813: addtoken (@expr5835 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ;
814: tokenList@var2153 .@expr5796 back (@expr5797 ) .@expr1073747664 setValueType (@expr1073747665 new ValueType (@expr1073747666 ValueType ::@expr1073747667 Sign ::@expr1073747668 UNKNOWN_SIGN , ValueType ::@expr1073747669 Type ::@expr1073747670 BOOL , 0 ) ) ;
815: return tokenList@var2153 .@expr5796 back (@expr5797 ) ;
816: }
817: if (@expr1073747673 nodeType@var2022 ==@expr1073747674 CXXConstructExpr@var1901 ) {
818: if (@expr5851 !@expr5852 children@var2023 .@expr5853 empty (@expr5854 ) ) {
819: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
820: addTypeTokens (@expr5813 tokenList@var2153 , '\'' +@expr5814 getType (@expr5815 ) +@expr5816 '\'' ) ;
821: Token * type@var2178 ; type@var2178 =@expr1073747686 tokenList@var2153 .@expr5796 back (@expr5797 ) ;
822: Token * par1@var2179 ; par1@var2179 =@expr1073747689 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
823: Token * par2@var2180 ; par2@var2180 =@expr1073747691 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
824: par1@var2179 .@expr1073747693 link (@expr1073747694 par2@var2180 ) ;
825: par2@var2180 .@expr1073747695 link (@expr1073747696 par1@var2179 ) ;
826: par1@var2179 .@expr1073747697 astOperand1 (@expr1073747698 type@var2178 ) ;
827: return par1@var2179 ;
828: }
829: if (@expr1073747699 nodeType@var2022 ==@expr1073747700 CXXConstructorDecl@var1900 ) {
830: createTokensFunctionDecl (@expr5877 tokenList@var2153 ) ;
831: return nullptr ;
832: }
833: if (@expr1073747702 nodeType@var2022 ==@expr1073747703 CXXDeleteExpr@var1903 ) {
834: addtoken (@expr1073747704 tokenList@var2153 , "delete" ) ;
835: getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
836: return nullptr ;
837: }
838: if (@expr1073747708 nodeType@var2022 ==@expr1073747709 CXXDestructorDecl@var1904 ) {
839: createTokensFunctionDecl (@expr5877 tokenList@var2153 ) ;
840: return nullptr ;
841: }
842: if (@expr1073747711 nodeType@var2022 ==@expr1073747712 CXXForRangeStmt@var1905 ) {
843: Token * forToken@var2181 ; forToken@var2181 =@expr1073747713 addtoken (@expr5890 tokenList@var2153 , "for" ) ;
844: Token * par1@var2182 ; par1@var2182 =@expr1073747715 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
845: AstNodePtr varDecl@var2183 ;
846: if (@expr1073747717 children@var2023 [@expr1073747718 6 ] .@expr1073747719 nodeType@expr1073747434 ==@expr1073747720 DeclStmt@var1919 ) {
847: varDecl@var2183 =@expr1073747721 getChild (@expr1073747722 6 ) .@expr1073747723 getChild (@expr1073747724 0 ) ; }
848: else {
849: varDecl@var2183 =@expr1073747725 getChild (@expr1073747726 5 ) .@expr1073747727 getChild (@expr1073747728 0 ) ; }
850: varDecl@var2183 .@expr1073747729 mExtTokens@var2184 .@expr1073747730 pop_back (@expr1073747731 ) ;
851: varDecl@var2183 .@expr1073747732 children@var2185 .@expr1073747733 clear (@expr1073747734 ) ;
852: Token * expr1@var2186 ; expr1@var2186 =@expr1073747735 varDecl@var2183 .@expr1073747736 createTokens (@expr1073747737 tokenList@var2153 ) ;
853: Token * colon@var2187 ; colon@var2187 =@expr1073747738 addtoken (@expr5724 tokenList@var2153 , ":" ) ;
854: AstNodePtr range@var2188 ;
855: for (@expr1073747740 int i@var2189 =@expr1073747741 0 ; i@var2189 <@expr1073747742 2 ; i@var2189 ++@expr1073747743 ) {
856: if (@expr1073747744 children@var2023 [@expr5921 i@var2189 ] &&@expr1073747746 children@var2023 [@expr5921 i@var2189 ] .@expr1073747748 nodeType@expr1073747435 ==@expr1073747749 DeclStmt@var1919 &&@expr1073747750 children@var2023 [@expr5921 i@var2189 ] .@expr5928 getChild (@expr5929 0 ) .@expr1073747754 nodeType@expr1073747436 ==@expr1073747755 VarDecl@var1951 ) {
857: range@var2188 =@expr1073747756 children@var2023 [@expr5921 i@var2189 ] .@expr5928 getChild (@expr5929 0 ) .@expr1073747760 getChild (@expr1073747761 0 ) ;
858: break ;
859: }
860: }
861: if (@expr1073747762 !@expr1073747763 range@var2188 ) {
862: throw InternalError (@expr1073747764 tokenList@var2153 .@expr5796 back (@expr5797 ) , "Failed to import CXXForRangeStmt. Range?" ) ; }
863: Token * expr2@var2190 ; expr2@var2190 =@expr1073747767 range@var2188 .@expr1073747768 createTokens (@expr1073747769 tokenList@var2153 ) ;
864: Token * par2@var2191 ; par2@var2191 =@expr1073747770 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
865:
866: par1@var2182 .@expr1073747772 link (@expr1073747773 par2@var2191 ) ;
867: par2@var2191 .@expr1073747774 link (@expr1073747775 par1@var2182 ) ;
868:
869: colon@var2187 .@expr1073747776 astOperand1 (@expr1073747777 expr1@var2186 ) ;
870: colon@var2187 .@expr1073747778 astOperand2 (@expr1073747779 expr2@var2190 ) ;
871: par1@var2182 .@expr1073747780 astOperand1 (@expr1073747781 forToken@var2181 ) ;
872: par1@var2182 .@expr1073747782 astOperand2 (@expr1073747783 colon@var2187 ) ;
873:
874: createScope (@expr1073747784 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr5962 eFor , children@var2023 .@expr5725 back (@expr5726 ) , forToken@var2181 ) ;
875: return nullptr ;
876: }
877: if (@expr1073747789 nodeType@var2022 ==@expr1073747790 CXXMethodDecl@var1908 ) {
878: for (@expr1073747791 int i@var2192 =@expr1073747792 0 ; i@var2192 +@expr5969 1 <@expr1073747794 mExtTokens@var2062 .@expr5971 size (@expr5972 ) ; ++@expr1073747797 i@var2192 ) {
879: if (@expr1073747798 mExtTokens@var2062 [@expr1073747799 i@var2192 ] ==@expr1073747800 "prev" &&@expr1073747801 !@expr1073747802 mData@var2063 .@expr1073747803 hasDecl (@expr1073747804 mExtTokens@var2062 [@expr1073747805 i@var2192 +@expr5969 1 ] ) ) {
880: return nullptr ; }
881: }
882: createTokensFunctionDecl (@expr5877 tokenList@var2153 ) ;
883: return nullptr ;
884: }
885: if (@expr1073747808 nodeType@var2022 ==@expr1073747809 CXXMemberCallExpr@var1907 ) {
886: return createTokensCall (@expr5713 tokenList@var2153 ) ; }
887: if (@expr1073747811 nodeType@var2022 ==@expr1073747812 CXXNewExpr@var1909 ) {
888: Token * newtok@var2193 ; newtok@var2193 =@expr1073747813 addtoken (@expr1073747814 tokenList@var2153 , "new" ) ;
889: if (@expr1073747815 children@var2023 .@expr5992 size (@expr5993 ) ==@expr1073747818 1 &&@expr1073747819 getChild (@expr5620 0 ) .@expr1073747821 nodeType@expr1073747437 ==@expr1073747822 CXXConstructExpr@var1901 ) {
890: newtok@var2193 .@expr1073747823 astOperand1 (@expr1073747824 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ) ;
891: return newtok@var2193 ;
892: }
893: std ::@expr1073747828 string type@var2194 ; type@var2194 =@expr1073747829 getType (@expr5815 ) ;
894: if (@expr1073747831 type@var2194 .@expr1073747832 find (@expr1073747833 "*" ) !=@expr1073747834 std ::@expr5704 string ::@expr1073747836 npos@expr1073747438 ) {
895: type@var2194 =@expr1073747837 type@var2194 .@expr1073747838 erase (@expr1073747839 type@var2194 .@expr1073747840 rfind (@expr1073747841 "*" ) ) ; }
896: addTypeTokens (@expr1073747842 tokenList@var2153 , type@var2194 ) ;
897: if (@expr5851 !@expr5852 children@var2023 .@expr5853 empty (@expr5854 ) ) {
898: Token * bracket1@var2195 ; bracket1@var2195 =@expr1073747847 addtoken (@expr5624 tokenList@var2153 , "[" ) ;
899: getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
900: Token * bracket2@var2196 ; bracket2@var2196 =@expr1073747852 addtoken (@expr5630 tokenList@var2153 , "]" ) ;
901: bracket1@var2195 .@expr1073747854 link (@expr1073747855 bracket2@var2196 ) ;
902: bracket2@var2196 .@expr1073747856 link (@expr1073747857 bracket1@var2195 ) ;
903: }
904: return newtok@var2193 ;
905: }
906: if (@expr1073747858 nodeType@var2022 ==@expr1073747859 CXXNullPtrLiteralExpr@var1910 ) {
907: return addtoken (@expr1073747860 tokenList@var2153 , "nullptr" ) ; }
908: if (@expr1073747861 nodeType@var2022 ==@expr1073747862 CXXOperatorCallExpr@var1911 ) {
909: return createTokensCall (@expr5713 tokenList@var2153 ) ; }
910: if (@expr1073747864 nodeType@var2022 ==@expr1073747865 CXXRecordDecl@var1912 ) {
911: createTokensForCXXRecord (@expr5741 tokenList@var2153 ) ;
912: return nullptr ;
913: }
914: if (@expr1073747867 nodeType@var2022 ==@expr1073747868 CXXStaticCastExpr@var1913 ||@expr1073747869 nodeType@var2022 ==@expr1073747870 CXXFunctionalCastExpr@var1906 ) {
915: Token * cast@var2197 ; cast@var2197 =@expr1073747871 addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ;
916: Token * par1@var2198 ; par1@var2198 =@expr1073747874 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
917: Token * expr@var2199 ; expr@var2199 =@expr1073747876 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
918: Token * par2@var2200 ; par2@var2200 =@expr1073747880 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
919: par1@var2198 .@expr1073747882 link (@expr1073747883 par2@var2200 ) ;
920: par2@var2200 .@expr1073747884 link (@expr1073747885 par1@var2198 ) ;
921: par1@var2198 .@expr1073747886 astOperand1 (@expr1073747887 cast@var2197 ) ;
922: par1@var2198 .@expr1073747888 astOperand2 (@expr1073747889 expr@var2199 ) ;
923: setValueType (@expr1073747890 par1@var2198 ) ;
924: return par1@var2198 ;
925: }
926: if (@expr1073747891 nodeType@var2022 ==@expr1073747892 CXXStdInitializerListExpr@var1914 ) {
927: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
928: if (@expr1073747896 nodeType@var2022 ==@expr1073747897 CXXTemporaryObjectExpr@var1915 &&@expr1073747898 !@expr5852 children@var2023 .@expr5853 empty (@expr5854 ) ) {
929: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
930: if (@expr1073747905 nodeType@var2022 ==@expr1073747906 CXXThisExpr@var1916 ) {
931: return addtoken (@expr1073747907 tokenList@var2153 , "this" ) ; }
932: if (@expr1073747908 nodeType@var2022 ==@expr1073747909 CXXThrowExpr@var1917 ) {
933: Token * t@var2201 ; t@var2201 =@expr1073747910 addtoken (@expr1073747911 tokenList@var2153 , "throw" ) ;
934: t@var2201 .@expr1073747912 astOperand1 (@expr1073747913 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ) ;
935: return t@var2201 ;
936: }
937: if (@expr1073747917 nodeType@var2022 ==@expr1073747918 DeclRefExpr@var1918 ) {
938: int addrIndex@var2202 ; addrIndex@var2202 =@expr1073747919 mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr6098 1 ;
939: while (@expr1073747923 addrIndex@var2202 >@expr1073747924 1 &&@expr1073747925 mExtTokens@var2062 [@expr6102 addrIndex@var2202 ] .@expr1073747927 compare (@expr1073747928 0 , 2 , "0x" ) !=@expr1073747929 0 ) {
940: --@expr1073747930 addrIndex@var2202 ; }
941: const std ::@expr6107 string addr@var2203 =@expr1073747932 mExtTokens@var2062 [@expr6102 addrIndex@var2202 ] ;
942: std ::@expr1073747934 string name@var2204 ; name@var2204 =@expr1073747935 unquote (@expr1073747936 getSpelling (@expr5776 ) ) ;
943: Token * reftok@var2205 ; reftok@var2205 =@expr1073747938 addtoken (@expr1073747939 tokenList@var2153 , name@var2204 .@expr1073747940 empty (@expr1073747941 ) ?@expr1073747942 "<NoName>" :@expr1073747943 name@var2204 ) ;
944: mData@var2063 .@expr6120 ref (@expr1073747945 addr@var2203 , reftok@var2205 ) ;
945: return reftok@var2205 ;
946: }
947: if (@expr1073747946 nodeType@var2022 ==@expr1073747947 DeclStmt@var1919 ) {
948: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
949: if (@expr1073747951 nodeType@var2022 ==@expr1073747952 DefaultStmt@var1920 ) {
950: addtoken (@expr1073747953 tokenList@var2153 , "default" ) ;
951: addtoken (@expr5724 tokenList@var2153 , ":" ) ;
952: children@var2023 .@expr5725 back (@expr5726 ) .@expr5727 createTokens (@expr5728 tokenList@var2153 ) ;
953: return nullptr ;
954: }
955: if (@expr1073747959 nodeType@var2022 ==@expr1073747960 DoStmt@var1921 ) {
956: addtoken (@expr1073747961 tokenList@var2153 , "do" ) ;
957: createScope (@expr1073747962 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073747964 eDo , getChild (@expr5620 0 ) , tokenList@var2153 .@expr5796 back (@expr5797 ) ) ;
958: Token * tok1@var2206 ; tok1@var2206 =@expr1073747968 addtoken (@expr6145 tokenList@var2153 , "while" ) ;
959: Token * par1@var2207 ; par1@var2207 =@expr1073747970 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
960: Token * expr@var2208 ; expr@var2208 =@expr1073747972 children@var2023 [@expr5626 1 ] .@expr5627 createTokens (@expr5628 tokenList@var2153 ) ;
961: Token * par2@var2209 ; par2@var2209 =@expr1073747976 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
962: par1@var2207 .@expr1073747978 link (@expr1073747979 par2@var2209 ) ;
963: par2@var2209 .@expr1073747980 link (@expr1073747981 par1@var2207 ) ;
964: par1@var2207 .@expr1073747982 astOperand1 (@expr1073747983 tok1@var2206 ) ;
965: par1@var2207 .@expr1073747984 astOperand2 (@expr1073747985 expr@var2208 ) ;
966: return nullptr ;
967: }
968: if (@expr1073747986 nodeType@var2022 ==@expr1073747987 EnumConstantDecl@var1922 ) {
969: Token * nameToken@var2210 ; nameToken@var2210 =@expr1073747988 addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ;
970: Scope * scope@var2211 ; scope@var2211 =@expr1073747991 const_cast < Scope *@expr6168 > (@expr1073747993 nameToken@var2210 .@expr6170 scope (@expr6171 ) ) ;
971: scope@var2211 .@expr6172 enumeratorList@var2212 .@expr1073747997 push_back (@expr1073747998 Enumerator (@expr1073747999 nameToken@var2210 .@expr6170 scope (@expr6171 ) ) ) ;
972: Enumerator * e@var2213 ; e@var2213 =@expr1073748002 &@expr1073748003 scope@var2211 .@expr6172 enumeratorList@var2212 .@expr1073748005 back (@expr1073748006 ) ;
973: e@var2213 .@expr1073748007 name@var2214 =@expr1073748008 nameToken@var2210 ;
974: e@var2213 .@expr1073748009 value@var2215 =@expr1073748010 mData@var2063 .@expr6187 enumValue@var2438 ++@expr1073748012 ;
975: e@var2213 .@expr1073748013 value_known@var2216 =@expr1073748014 true ;
976: mData@var2063 .@expr1073748015 enumDecl (@expr1073748016 mExtTokens@var2062 .@expr1073748017 front (@expr1073748018 ) , nameToken@var2210 , e@var2213 ) ;
977: return nameToken@var2210 ;
978: }
979: if (@expr1073748019 nodeType@var2022 ==@expr1073748020 EnumDecl@var1923 ) {
980: int colIndex@var2217 ; colIndex@var2217 =@expr1073748021 mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr6098 1 ;
981: while (@expr1073748025 colIndex@var2217 >@expr1073748026 0 &&@expr1073748027 mExtTokens@var2062 [@expr6204 colIndex@var2217 ] .@expr6205 compare (@expr1073748030 0 , 4 , "col:" ) !=@expr1073748031 0 &&@expr1073748032 mExtTokens@var2062 [@expr6204 colIndex@var2217 ] .@expr6205 compare (@expr1073748035 0 , 5 , "line:" ) !=@expr1073748036 0 ) {
982: --@expr1073748037 colIndex@var2217 ; }
983: if (@expr1073748038 colIndex@var2217 ==@expr1073748039 0 ) {
984: return nullptr ; }
985:
986: mData@var2063 .@expr6187 enumValue@var2438 =@expr1073748041 0 ;
987: Token * enumtok@var2218 ; enumtok@var2218 =@expr1073748042 addtoken (@expr1073748043 tokenList@var2153 , "enum" ) ;
988: Token * nametok@var2219 ; nametok@var2219 =@expr1073748044 nullptr ;
989: {
990: int nameIndex@var2220 ; nameIndex@var2220 =@expr1073748045 mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr6098 1 ;
991: while (@expr1073748049 nameIndex@var2220 >@expr6226 colIndex@var2217 &&@expr1073748051 mExtTokens@var2062 [@expr6228 nameIndex@var2220 ] [@expr1073748053 0 ] ==@expr1073748054 '\'' ) {
992: --@expr1073748055 nameIndex@var2220 ; }
993: if (@expr1073748056 nameIndex@var2220 >@expr6226 colIndex@var2217 ) {
994: nametok@var2219 =@expr1073748058 addtoken (@expr1073748059 tokenList@var2153 , mExtTokens@var2062 [@expr6228 nameIndex@var2220 ] ) ; }
995: if (@expr1073748061 mExtTokens@var2062 .@expr5648 back (@expr5649 ) [@expr1073748064 0 ] ==@expr1073748065 '\'' ) {
996: addtoken (@expr5724 tokenList@var2153 , ":" ) ;
997: addTypeTokens (@expr6243 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ;
998: }
999: }
1000: Scope * enumscope@var2221 ; enumscope@var2221 =@expr1073748070 createScope (@expr1073748071 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748073 eEnum , children@var2023 , enumtok@var2218 ) ;
1001: if (@expr6250 nametok@var2219 ) {
1002: enumscope@var2221 .@expr1073748075 className@var2222 =@expr1073748076 nametok@var2219 .@expr6253 str (@expr6254 ) ; }
1003: if (@expr1073748079 enumscope@var2221 .@expr6256 bodyEnd@var2223 &&@expr1073748081 Token ::@expr1073748082 simpleMatch (@expr1073748083 enumscope@var2221 .@expr6256 bodyEnd@var2223 .@expr1073748085 previous (@expr1073748086 ) , ", }" ) ) {
1004: const_cast < Token *@expr6168 > (@expr1073748088 enumscope@var2221 .@expr6256 bodyEnd@var2223 ) .@expr1073748090 deletePrevious (@expr1073748091 ) ; }
1005:
1006:
1007: mData@var2063 .@expr6268 mSymbolDatabase@var2433 .@expr6269 typeList@var2439 .@expr6270 push_back (@expr1073748095 Type (@expr1073748096 enumtok@var2218 , enumscope@var2221 , enumtok@var2218 .@expr6273 scope (@expr6274 ) ) ) ;
1008: enumscope@var2221 .@expr6275 definedType@var2224 =@expr1073748100 &@expr6277 mData@var2063 .@expr6268 mSymbolDatabase@var2433 .@expr6269 typeList@var2439 .@expr6280 back (@expr6281 ) ;
1009: if (@expr6250 nametok@var2219 ) {
1010: const_cast < Scope *@expr6168 > (@expr1073748108 enumtok@var2218 .@expr6273 scope (@expr6274 ) ) .@expr1073748111 definedTypesMap@expr1073747439 [@expr1073748112 nametok@var2219 .@expr6253 str (@expr6254 ) ] =@expr1073748115 enumscope@var2221 .@expr6275 definedType@var2224 ; }
1011:
1012: return nullptr ;
1013: }
1014: if (@expr1073748117 nodeType@var2022 ==@expr1073748118 ExprWithCleanups@var1924 ) {
1015: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
1016: if (@expr1073748122 nodeType@var2022 ==@expr1073748123 FieldDecl@var1925 ) {
1017: return createTokensVarDecl (@expr6300 tokenList@var2153 ) ; }
1018: if (@expr1073748125 nodeType@var2022 ==@expr1073748126 FloatingLiteral@var1926 ) {
1019: return addtoken (@expr5835 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ; }
1020: if (@expr1073748130 nodeType@var2022 ==@expr1073748131 ForStmt@var1927 ) {
1021: Token * forToken@var2225 ; forToken@var2225 =@expr1073748132 addtoken (@expr5890 tokenList@var2153 , "for" ) ;
1022: Token * par1@var2226 ; par1@var2226 =@expr1073748134 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1023: Token * expr1@var2227 ; expr1@var2227 =@expr1073748136 getChild (@expr5620 0 ) ?@expr1073748138 children@var2023 [@expr1073748139 0 ] .@expr1073748140 createTokens (@expr1073748141 tokenList@var2153 ) :@expr1073748142 nullptr ;
1024: Token * sep1@var2228 ; sep1@var2228 =@expr1073748143 addtoken (@expr6320 tokenList@var2153 , ";" ) ;
1025: Token * expr2@var2229 ; expr2@var2229 =@expr1073748145 children@var2023 [@expr5757 2 ] ?@expr1073748147 children@var2023 [@expr5757 2 ] .@expr5758 createTokens (@expr5759 tokenList@var2153 ) :@expr1073748151 nullptr ;
1026: Token * sep2@var2230 ; sep2@var2230 =@expr1073748152 addtoken (@expr6320 tokenList@var2153 , ";" ) ;
1027: Token * expr3@var2231 ; expr3@var2231 =@expr1073748154 children@var2023 [@expr6331 3 ] ?@expr1073748156 children@var2023 [@expr6331 3 ] .@expr1073748158 createTokens (@expr1073748159 tokenList@var2153 ) :@expr1073748160 nullptr ;
1028: Token * par2@var2232 ; par2@var2232 =@expr1073748161 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1029: par1@var2226 .@expr1073748163 link (@expr1073748164 par2@var2232 ) ;
1030: par2@var2232 .@expr1073748165 link (@expr1073748166 par1@var2226 ) ;
1031: par1@var2226 .@expr1073748167 astOperand1 (@expr1073748168 forToken@var2225 ) ;
1032: par1@var2226 .@expr1073748169 astOperand2 (@expr1073748170 sep1@var2228 ) ;
1033: sep1@var2228 .@expr1073748171 astOperand1 (@expr1073748172 expr1@var2227 ) ;
1034: sep1@var2228 .@expr1073748173 astOperand2 (@expr1073748174 sep2@var2230 ) ;
1035: sep2@var2230 .@expr1073748175 astOperand1 (@expr1073748176 expr2@var2229 ) ;
1036: sep2@var2230 .@expr1073748177 astOperand2 (@expr1073748178 expr3@var2231 ) ;
1037: createScope (@expr1073748179 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr5962 eFor , children@var2023 [@expr1073748182 4 ] , forToken@var2225 ) ;
1038: return nullptr ;
1039: }
1040: if (@expr1073748183 nodeType@var2022 ==@expr1073748184 FunctionDecl@var1928 ) {
1041: createTokensFunctionDecl (@expr5877 tokenList@var2153 ) ;
1042: return nullptr ;
1043: }
1044: if (@expr1073748186 nodeType@var2022 ==@expr1073748187 FunctionTemplateDecl@var1929 ) {
1045: bool first@var2233 ; first@var2233 =@expr1073748188 true ;
1046: for (@expr1073748189 const AstNodePtr &@expr5732 child@var2234 :@expr1073748191 children@var2023 ) {
1047: if (@expr1073748192 child@var2234 .@expr1073748193 nodeType@var2235 ==@expr1073748194 FunctionDecl@var1928 ) {
1048: if (@expr1073748195 !@expr1073748196 first@var2233 ) {
1049: child@var2234 .@expr1073748197 createTokens (@expr1073748198 tokenList@var2153 ) ; }
1050: first@var2233 =@expr1073748199 false ;
1051: }
1052: }
1053: return nullptr ;
1054: }
1055: if (@expr1073748200 nodeType@var2022 ==@expr1073748201 GotoStmt@var1930 ) {
1056: addtoken (@expr1073748202 tokenList@var2153 , "goto" ) ;
1057: addtoken (@expr1073748203 tokenList@var2153 , unquote (@expr1073748204 mExtTokens@var2062 [@expr6381 mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr6384 2 ] ) ) ;
1058: addtoken (@expr6320 tokenList@var2153 , ";" ) ;
1059: return nullptr ;
1060: }
1061: if (@expr1073748210 nodeType@var2022 ==@expr1073748211 IfStmt@var1931 ) {
1062: AstNodePtr cond@var2236 ;
1063: AstNodePtr thenCode@var2237 ;
1064: AstNodePtr elseCode@var2238 ;
1065: if (@expr1073748212 children@var2023 .@expr5992 size (@expr5993 ) ==@expr1073748215 2 ) {
1066: cond@var2236 =@expr1073748216 children@var2023 [@expr6393 children@var2023 .@expr5992 size (@expr5993 ) -@expr6396 2 ] ;
1067: thenCode@var2237 =@expr1073748221 children@var2023 [@expr6398 children@var2023 .@expr5992 size (@expr5993 ) -@expr6401 1 ] ;
1068: } else {
1069: cond@var2236 =@expr1073748226 children@var2023 [@expr1073748227 children@var2023 .@expr5992 size (@expr5993 ) -@expr1073748230 3 ] ;
1070: thenCode@var2237 =@expr1073748231 children@var2023 [@expr6393 children@var2023 .@expr5992 size (@expr5993 ) -@expr6396 2 ] ;
1071: elseCode@var2238 =@expr1073748236 children@var2023 [@expr6398 children@var2023 .@expr5992 size (@expr5993 ) -@expr6401 1 ] ;
1072: }
1073:
1074: Token * iftok@var2239 ; iftok@var2239 =@expr1073748241 addtoken (@expr1073748242 tokenList@var2153 , "if" ) ;
1075: Token * par1@var2240 ; par1@var2240 =@expr1073748243 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1076: par1@var2240 .@expr1073748245 astOperand1 (@expr1073748246 iftok@var2239 ) ;
1077: par1@var2240 .@expr1073748247 astOperand2 (@expr1073748248 cond@var2236 .@expr1073748249 createTokens (@expr1073748250 tokenList@var2153 ) ) ;
1078: Token * par2@var2241 ; par2@var2241 =@expr1073748251 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1079: par1@var2240 .@expr1073748253 link (@expr1073748254 par2@var2241 ) ;
1080: par2@var2241 .@expr1073748255 link (@expr1073748256 par1@var2240 ) ;
1081: createScope (@expr1073748257 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748259 eIf , thenCode@var2237 , iftok@var2239 ) ;
1082: if (@expr1073748260 elseCode@var2238 ) {
1083: elseCode@var2238 .@expr1073748261 addtoken (@expr1073748262 tokenList@var2153 , "else" ) ;
1084: createScope (@expr1073748263 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748265 eElse , elseCode@var2238 , tokenList@var2153 .@expr5796 back (@expr5797 ) ) ;
1085: }
1086: return nullptr ;
1087: }
1088: if (@expr1073748268 nodeType@var2022 ==@expr1073748269 ImplicitCastExpr@var1932 ) {
1089: Token * expr@var2242 ; expr@var2242 =@expr1073748270 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
1090: if (@expr1073748274 !@expr1073748275 expr@var2242 .@expr1073748276 valueType (@expr1073748277 ) ||@expr1073748278 contains (@expr1073748279 mExtTokens@var2062 , "<ArrayToPointerDecay>" ) ) {
1091: setValueType (@expr1073748280 expr@var2242 ) ; }
1092: return expr@var2242 ;
1093: }
1094: if (@expr1073748281 nodeType@var2022 ==@expr1073748282 InitListExpr@var1933 ) {
1095: const Scope * scope@var2243 ; scope@var2243 =@expr1073748283 tokenList@var2153 .@expr5796 back (@expr5797 ) .@expr1073748286 scope (@expr1073748287 ) ;
1096: Token * start@var2244 ; start@var2244 =@expr1073748288 addtoken (@expr1073748289 tokenList@var2153 , "{" ) ;
1097: start@var2244 .@expr1073748290 scope (@expr1073748291 scope@var2243 ) ;
1098: for (@expr1073748292 const AstNodePtr &@expr5732 child@var2245 :@expr1073748294 children@var2023 ) {
1099: if (@expr1073748295 tokenList@var2153 .@expr5796 back (@expr5797 ) .@expr1073748298 str (@expr1073748299 ) !=@expr1073748300 "{" ) {
1100: addtoken (@expr1073748301 tokenList@var2153 , "," ) ; }
1101: child@var2245 .@expr1073748302 createTokens (@expr1073748303 tokenList@var2153 ) ;
1102: }
1103: Token * end@var2246 ; end@var2246 =@expr1073748304 addtoken (@expr1073748305 tokenList@var2153 , "}" ) ;
1104: end@var2246 .@expr1073748306 scope (@expr1073748307 scope@var2243 ) ;
1105: start@var2244 .@expr1073748308 link (@expr1073748309 end@var2246 ) ;
1106: end@var2246 .@expr1073748310 link (@expr1073748311 start@var2244 ) ;
1107: mData@var2063 .@expr1073748312 mNotScope@var2435 .@expr1073748313 insert (@expr1073748314 end@var2246 ) ;
1108: return start@var2244 ;
1109: }
1110: if (@expr1073748315 nodeType@var2022 ==@expr1073748316 IntegerLiteral@var1934 ) {
1111: return addtoken (@expr5835 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ; }
1112: if (@expr1073748320 nodeType@var2022 ==@expr1073748321 LabelStmt@var1935 ) {
1113: addtoken (@expr5646 tokenList@var2153 , unquote (@expr5647 mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ) ;
1114: addtoken (@expr5724 tokenList@var2153 , ":" ) ;
1115: for (@expr1073748327 const auto &@expr5732 child@var2247 :@expr1073748329 children@var2023 ) {
1116: child@var2247 .@expr1073748330 createTokens (@expr1073748331 tokenList@var2153 ) ; }
1117: return nullptr ;
1118: }
1119: if (@expr1073748332 nodeType@var2022 ==@expr1073748333 LinkageSpecDecl@var1936 ) {
1120: return nullptr ; }
1121: if (@expr1073748334 nodeType@var2022 ==@expr1073748335 MaterializeTemporaryExpr@var1937 ) {
1122: return getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ; }
1123: if (@expr1073748339 nodeType@var2022 ==@expr1073748340 MemberExpr@var1938 ) {
1124: Token * s@var2248 ; s@var2248 =@expr1073748341 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
1125: Token * dot@var2249 ; dot@var2249 =@expr1073748345 addtoken (@expr1073748346 tokenList@var2153 , "." ) ;
1126: std ::@expr1073748347 string memberName@var2250 ; memberName@var2250 =@expr1073748348 getSpelling (@expr5776 ) ;
1127: if (@expr1073748350 memberName@var2250 .@expr6527 compare (@expr1073748352 0 , 2 , "->" ) ==@expr1073748353 0 ) {
1128: dot@var2249 .@expr1073748354 originalName (@expr1073748355 "->" ) ;
1129: memberName@var2250 =@expr1073748356 memberName@var2250 .@expr6533 substr (@expr1073748358 2 ) ;
1130: } else { if (@expr1073748359 memberName@var2250 .@expr6527 compare (@expr1073748361 0 , 1 , "." ) ==@expr1073748362 0 ) {
1131: memberName@var2250 =@expr1073748363 memberName@var2250 .@expr6533 substr (@expr1073748365 1 ) ;
1132: } }
1133: if (@expr1073748366 memberName@var2250 .@expr1073748367 empty (@expr1073748368 ) ) {
1134: memberName@var2250 =@expr1073748369 "<unknown>" ; }
1135: Token * member@var2251 ; member@var2251 =@expr1073748370 addtoken (@expr1073748371 tokenList@var2153 , memberName@var2250 ) ;
1136: mData@var2063 .@expr6120 ref (@expr1073748373 mExtTokens@var2062 .@expr5648 back (@expr5649 ) , member@var2251 ) ;
1137: dot@var2249 .@expr1073748376 astOperand1 (@expr1073748377 s@var2248 ) ;
1138: dot@var2249 .@expr1073748378 astOperand2 (@expr1073748379 member@var2251 ) ;
1139: return dot@var2249 ;
1140: }
1141: if (@expr1073748380 nodeType@var2022 ==@expr1073748381 NamespaceDecl@var1939 ) {
1142: if (@expr6558 children@var2023 .@expr5853 empty (@expr5854 ) ) {
1143: return nullptr ; }
1144: Token * defToken@var2252 ; defToken@var2252 =@expr1073748385 addtoken (@expr1073748386 tokenList@var2153 , "namespace" ) ;
1145: const std ::@expr6107 string &@expr5732 s@var2253 =@expr1073748389 mExtTokens@var2062 [@expr6381 mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr6384 2 ] ;
1146: Token * nameToken@var2254 ; nameToken@var2254 =@expr1073748394 (@expr1073748395 s@var2253 .@expr6572 compare (@expr1073748397 0 , 4 , "col:" ) ==@expr1073748398 0 ||@expr1073748399 s@var2253 .@expr6572 compare (@expr1073748401 0 , 5 , "line:" ) ==@expr1073748402 0 ) ?@expr1073748403
1147: addtoken (@expr5835 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) :@expr1073748407 nullptr ;
1148: Scope * scope@var2255 ; scope@var2255 =@expr1073748408 createScope (@expr1073748409 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748411 eNamespace , children@var2023 , defToken@var2252 ) ;
1149: if (@expr1073748412 nameToken@var2254 ) {
1150: scope@var2255 .@expr1073748413 className@var2256 =@expr1073748414 nameToken@var2254 .@expr1073748415 str (@expr1073748416 ) ; }
1151: return nullptr ;
1152: }
1153: if (@expr1073748417 nodeType@var2022 ==@expr1073748418 NullStmt@var1940 ) {
1154: return addtoken (@expr6320 tokenList@var2153 , ";" ) ; }
1155: if (@expr1073748420 nodeType@var2022 ==@expr1073748421 ParenExpr@var1941 ) {
1156: Token * par1@var2257 ; par1@var2257 =@expr1073748422 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1157: Token * expr@var2258 ; expr@var2258 =@expr1073748424 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ;
1158: Token * par2@var2259 ; par2@var2259 =@expr1073748428 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1159: par1@var2257 .@expr1073748430 link (@expr1073748431 par2@var2259 ) ;
1160: par2@var2259 .@expr1073748432 link (@expr1073748433 par1@var2257 ) ;
1161: return expr@var2258 ;
1162: }
1163: if (@expr1073748434 nodeType@var2022 ==@expr1073748435 RecordDecl@var1943 ) {
1164: const Token * classDef@var2260 ; classDef@var2260 =@expr1073748436 addtoken (@expr1073748437 tokenList@var2153 , "struct" ) ;
1165: const std ::@expr6107 string &@expr5732 recordName@var2261 =@expr1073748440 getSpelling (@expr5776 ) ;
1166: if (@expr6618 !@expr6619 recordName@var2261 .@expr6620 empty (@expr6621 ) ) {
1167: addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ; }
1168: if (@expr1073748448 !@expr1073748449 isDefinition (@expr1073748450 ) ) {
1169: addtoken (@expr6320 tokenList@var2153 , ";" ) ;
1170: return nullptr ;
1171: }
1172:
1173: Scope * recordScope@var2262 ; recordScope@var2262 =@expr1073748452 createScope (@expr1073748453 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748455 eStruct , children@var2023 , classDef@var2260 ) ;
1174: mData@var2063 .@expr6268 mSymbolDatabase@var2433 .@expr6269 typeList@var2439 .@expr6270 push_back (@expr1073748459 Type (@expr1073748460 classDef@var2260 , recordScope@var2262 , classDef@var2260 .@expr6637 scope (@expr6638 ) ) ) ;
1175: recordScope@var2262 .@expr6639 definedType@var2263 =@expr1073748464 &@expr6277 mData@var2063 .@expr6268 mSymbolDatabase@var2433 .@expr6269 typeList@var2439 .@expr6280 back (@expr6281 ) ;
1176: if (@expr6618 !@expr6619 recordName@var2261 .@expr6620 empty (@expr6621 ) ) {
1177: recordScope@var2262 .@expr1073748474 className@var2264 =@expr1073748475 recordName@var2261 ;
1178: const_cast < Scope *@expr6168 > (@expr1073748477 classDef@var2260 .@expr6637 scope (@expr6638 ) ) .@expr1073748480 definedTypesMap@expr1073747440 [@expr1073748481 recordName@var2261 ] =@expr1073748482 recordScope@var2262 .@expr6639 definedType@var2263 ;
1179: }
1180:
1181: return nullptr ;
1182: }
1183: if (@expr1073748484 nodeType@var2022 ==@expr1073748485 ReturnStmt@var1944 ) {
1184: Token * tok1@var2265 ; tok1@var2265 =@expr1073748486 addtoken (@expr1073748487 tokenList@var2153 , "return" ) ;
1185: if (@expr5851 !@expr5852 children@var2023 .@expr5853 empty (@expr5854 ) ) {
1186: getChild (@expr5620 0 ) .@expr1073748493 setValueType (@expr1073748494 tok1@var2265 ) ;
1187: tok1@var2265 .@expr1073748495 astOperand1 (@expr1073748496 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ) ;
1188: }
1189: return tok1@var2265 ;
1190: }
1191: if (@expr1073748500 nodeType@var2022 ==@expr1073748501 StringLiteral@var1945 ) {
1192: return addtoken (@expr5835 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ; }
1193: if (@expr1073748505 nodeType@var2022 ==@expr1073748506 SwitchStmt@var1946 ) {
1194: Token * tok1@var2266 ; tok1@var2266 =@expr1073748507 addtoken (@expr1073748508 tokenList@var2153 , "switch" ) ;
1195: Token * par1@var2267 ; par1@var2267 =@expr1073748509 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1196: Token * expr@var2268 ; expr@var2268 =@expr1073748511 children@var2023 [@expr6393 children@var2023 .@expr5992 size (@expr5993 ) -@expr6396 2 ] .@expr1073748516 createTokens (@expr1073748517 tokenList@var2153 ) ;
1197: Token * par2@var2269 ; par2@var2269 =@expr1073748518 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1198: par1@var2267 .@expr1073748520 link (@expr1073748521 par2@var2269 ) ;
1199: par2@var2269 .@expr1073748522 link (@expr1073748523 par1@var2267 ) ;
1200: par1@var2267 .@expr1073748524 astOperand1 (@expr1073748525 tok1@var2266 ) ;
1201: par1@var2267 .@expr1073748526 astOperand2 (@expr1073748527 expr@var2268 ) ;
1202: createScope (@expr1073748528 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748530 eSwitch , children@var2023 .@expr5725 back (@expr5726 ) , tok1@var2266 ) ;
1203: return nullptr ;
1204: }
1205: if (@expr1073748533 nodeType@var2022 ==@expr1073748534 TypedefDecl@var1948 ) {
1206: addtoken (@expr1073748535 tokenList@var2153 , "typedef" ) ;
1207: addTypeTokens (@expr1073748536 tokenList@var2153 , getType (@expr5815 ) ) ;
1208: return addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ;
1209: }
1210: if (@expr1073748540 nodeType@var2022 ==@expr1073748541 UnaryOperator@var1949 ) {
1211: int index@var2270 ; index@var2270 =@expr1073748542 (@expr1073748543 int ) mExtTokens@var2062 .@expr5971 size (@expr5972 ) -@expr1073748546 1 ;
1212: while (@expr1073748547 index@var2270 >@expr1073748548 0 &&@expr1073748549 mExtTokens@var2062 [@expr6726 index@var2270 ] [@expr1073748551 0 ] !=@expr1073748552 '\'' ) {
1213: --@expr1073748553 index@var2270 ; }
1214: Token * unop@var2271 ; unop@var2271 =@expr1073748554 addtoken (@expr1073748555 tokenList@var2153 , unquote (@expr1073748556 mExtTokens@var2062 [@expr6726 index@var2270 ] ) ) ;
1215: unop@var2271 .@expr1073748558 astOperand1 (@expr1073748559 getChild (@expr5620 0 ) .@expr5621 createTokens (@expr5622 tokenList@var2153 ) ) ;
1216: return unop@var2271 ;
1217: }
1218: if (@expr1073748563 nodeType@var2022 ==@expr1073748564 UnaryExprOrTypeTraitExpr@var1950 ) {
1219: Token * tok1@var2272 ; tok1@var2272 =@expr1073748565 addtoken (@expr5775 tokenList@var2153 , getSpelling (@expr5776 ) ) ;
1220: Token * par1@var2273 ; par1@var2273 =@expr1073748568 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1221: if (@expr6558 children@var2023 .@expr5853 empty (@expr5854 ) ) {
1222: addTypeTokens (@expr6243 tokenList@var2153 , mExtTokens@var2062 .@expr5648 back (@expr5649 ) ) ; }
1223: else {
1224: AstNodePtr child@var2274 ; child@var2274 =@expr1073748576 getChild (@expr5620 0 ) ;
1225: if (@expr1073748578 child@var2274 &&@expr1073748579 child@var2274 .@expr1073748580 nodeType@var2275 ==@expr1073748581 ParenExpr@var1941 ) {
1226: child@var2274 =@expr1073748582 child@var2274 .@expr1073748583 getChild (@expr1073748584 0 ) ; }
1227: Token * expr@var2276 ; expr@var2276 =@expr1073748585 child@var2274 .@expr1073748586 createTokens (@expr1073748587 tokenList@var2153 ) ;
1228: child@var2274 .@expr1073748588 setValueType (@expr1073748589 expr@var2276 ) ;
1229: par1@var2273 .@expr6766 astOperand2 (@expr1073748591 expr@var2276 ) ;
1230: }
1231: Token * par2@var2277 ; par2@var2277 =@expr1073748592 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1232: par1@var2273 .@expr1073748594 link (@expr1073748595 par2@var2277 ) ;
1233: par2@var2277 .@expr1073748596 link (@expr1073748597 par1@var2273 ) ;
1234: par1@var2273 .@expr1073748598 astOperand1 (@expr1073748599 tok1@var2272 ) ;
1235: par1@var2273 .@expr6766 astOperand2 (@expr1073748601 par1@var2273 .@expr1073748602 next (@expr1073748603 ) ) ;
1236: setValueType (@expr1073748604 par1@var2273 ) ;
1237: return par1@var2273 ;
1238: }
1239: if (@expr1073748605 nodeType@var2022 ==@expr1073748606 VarDecl@var1951 ) {
1240: return createTokensVarDecl (@expr6300 tokenList@var2153 ) ; }
1241: if (@expr1073748608 nodeType@var2022 ==@expr1073748609 WhileStmt@var1952 ) {
1242: AstNodePtr cond@var2278 ; cond@var2278 =@expr1073748610 children@var2023 [@expr6393 children@var2023 .@expr5992 size (@expr5993 ) -@expr6396 2 ] ;
1243: AstNodePtr body@var2279 ; body@var2279 =@expr1073748615 children@var2023 .@expr5725 back (@expr5726 ) ;
1244: Token * whiletok@var2280 ; whiletok@var2280 =@expr1073748618 addtoken (@expr6145 tokenList@var2153 , "while" ) ;
1245: Token * par1@var2281 ; par1@var2281 =@expr1073748620 addtoken (@expr5812 tokenList@var2153 , "(" ) ;
1246: par1@var2281 .@expr1073748622 astOperand1 (@expr1073748623 whiletok@var2280 ) ;
1247: par1@var2281 .@expr1073748624 astOperand2 (@expr1073748625 cond@var2278 .@expr1073748626 createTokens (@expr1073748627 tokenList@var2153 ) ) ;
1248: Token * par2@var2282 ; par2@var2282 =@expr1073748628 addtoken (@expr5818 tokenList@var2153 , ")" ) ;
1249: par1@var2281 .@expr1073748630 link (@expr1073748631 par2@var2282 ) ;
1250: par2@var2282 .@expr1073748632 link (@expr1073748633 par1@var2281 ) ;
1251: createScope (@expr1073748634 tokenList@var2153 , Scope ::@expr5961 ScopeType ::@expr1073748636 eWhile , body@var2279 , whiletok@var2280 ) ;
1252: return nullptr ;
1253: }
1254: return addtoken (@expr1073748637 tokenList@var2153 , "?" +@expr1073748638 nodeType@var2022 +@expr1073748639 "?" ) ;
1255: }
1256:
1257: Token * clangimport :: AstNode :: createTokensCall ( TokenList * tokenList@var2283 )
1258: {
1259: int firstParam@var2284 ;
1260: Token * f@var2285 ;
1261: if (@expr1073748641 nodeType@var2022 ==@expr1073748642 CXXOperatorCallExpr@var1911 ) {
1262: firstParam@var2284 =@expr1073748643 2 ;
1263: Token * obj@var2286 ; obj@var2286 =@expr1073748644 getChild (@expr1073748645 1 ) .@expr1073748646 createTokens (@expr1073748647 tokenList@var2283 ) ;
1264: Token * dot@var2287 ; dot@var2287 =@expr1073748648 addtoken (@expr1073748649 tokenList@var2283 , "." ) ;
1265: Token * op@var2288 ; op@var2288 =@expr1073748650 getChild (@expr6827 0 ) .@expr6828 createTokens (@expr6829 tokenList@var2283 ) ;
1266: dot@var2287 .@expr1073748654 astOperand1 (@expr1073748655 obj@var2286 ) ;
1267: dot@var2287 .@expr1073748656 astOperand2 (@expr1073748657 op@var2288 ) ;
1268: f@var2285 =@expr1073748658 dot@var2287 ;
1269: } else {
1270: firstParam@var2284 =@expr1073748659 1 ;
1271: f@var2285 =@expr1073748660 getChild (@expr6827 0 ) .@expr6828 createTokens (@expr6829 tokenList@var2283 ) ;
1272: }
1273: f@var2285 .@expr1073748664 setValueType (@expr1073748665 nullptr ) ;
1274: Token * par1@var2289 ; par1@var2289 =@expr1073748666 addtoken (@expr1073748667 tokenList@var2283 , "(" ) ;
1275: par1@var2289 .@expr1073748668 astOperand1 (@expr1073748669 f@var2285 ) ;
1276: int args@var2290 ; args@var2290 =@expr1073748670 0 ;
1277: while (@expr1073748671 args@var2290 <@expr1073748672 children@var2023 .@expr1073748673 size (@expr1073748674 ) &&@expr1073748675 children@var2023 [@expr1073748676 args@var2290 ] .@expr1073748677 nodeType@expr1073748640 !=@expr1073748678 CXXDefaultArgExpr@var1902 ) {
1278: args@var2290 ++@expr1073748679 ; }
1279: Token * child@var2291 ; child@var2291 =@expr1073748680 nullptr ;
1280: for (@expr1073748681 int c@var2292 =@expr1073748682 firstParam@var2284 ; c@var2292 <@expr1073748683 args@var2290 ; ++@expr1073748684 c@var2292 ) {
1281: if (@expr1073748685 child@var2291 ) {
1282: Token * comma@var2293 ; comma@var2293 =@expr1073748686 addtoken (@expr1073748687 tokenList@var2283 , "," ) ;
1283: comma@var2293 .@expr1073748688 setValueType (@expr1073748689 nullptr ) ;
1284: comma@var2293 .@expr1073748690 astOperand1 (@expr1073748691 child@var2291 ) ;
1285: comma@var2293 .@expr1073748692 astOperand2 (@expr1073748693 children@var2023 [@expr6870 c@var2292 ] .@expr6871 createTokens (@expr6872 tokenList@var2283 ) ) ;
1286: child@var2291 =@expr1073748697 comma@var2293 ;
1287: } else {
1288: child@var2291 =@expr1073748698 children@var2023 [@expr6870 c@var2292 ] .@expr6871 createTokens (@expr6872 tokenList@var2283 ) ;
1289: }
1290: }
1291: par1@var2289 .@expr1073748702 astOperand2 (@expr1073748703 child@var2291 ) ;
1292: Token * par2@var2294 ; par2@var2294 =@expr1073748704 addtoken (@expr1073748705 tokenList@var2283 , ")" ) ;
1293: par1@var2289 .@expr1073748706 link (@expr1073748707 par2@var2294 ) ;
1294: par2@var2294 .@expr1073748708 link (@expr1073748709 par1@var2289 ) ;
1295: return par1@var2289 ;
1296: }
1297:
1298: void clangimport :: AstNode :: createTokensFunctionDecl ( TokenList * tokenList@var2295 )
1299: {
1300: const bool prev@var2296 =@expr1073748711 contains (@expr1073748712 mExtTokens@var2062 , "prev" ) ;
1301: const bool hasBody@var2297 =@expr1073748713 !@expr1073748714 children@var2023 .@expr1073748715 empty (@expr1073748716 ) &&@expr1073748717 children@var2023 .@expr6894 back (@expr6895 ) .@expr1073748720 nodeType@expr1073748710 ==@expr1073748721 CompoundStmt@var1895 ;
1302: const bool isStatic@var2298 =@expr1073748722 contains (@expr1073748723 mExtTokens@var2062 , "static" ) ;
1303: const bool isInline@var2299 =@expr1073748724 contains (@expr1073748725 mExtTokens@var2062 , "inline" ) ;
1304:
1305: const Token * startToken@var2300 ; startToken@var2300 =@expr1073748726 nullptr ;
1306:
1307: SymbolDatabase * symbolDatabase@var2301 ; symbolDatabase@var2301 =@expr1073748727 mData@var2063 .@expr1073748728 mSymbolDatabase@var2433 ;
1308: if (@expr1073748729 nodeType@var2022 !=@expr1073748730 CXXConstructorDecl@var1900 &&@expr1073748731 nodeType@var2022 !=@expr1073748732 CXXDestructorDecl@var1904 ) {
1309: if (@expr1073748733 isStatic@var2298 ) {
1310: addtoken (@expr1073748734 tokenList@var2295 , "static" ) ; }
1311: if (@expr1073748735 isInline@var2299 ) {
1312: addtoken (@expr1073748736 tokenList@var2295 , "inline" ) ; }
1313: const Token * const before@var2302 ; before@var2302 =@expr1073748737 tokenList@var2295 .@expr6914 back (@expr6915 ) ;
1314: addTypeTokens (@expr1073748740 tokenList@var2295 , '\'' +@expr1073748741 getType (@expr1073748742 ) +@expr1073748743 '\'' ) ;
1315: startToken@var2300 =@expr1073748744 before@var2302 ?@expr1073748745 before@var2302 .@expr1073748746 next (@expr1073748747 ) :@expr1073748748 tokenList@var2295 .@expr1073748749 front (@expr1073748750 ) ;
1316: }
1317:
1318: if (@expr1073748751 mExtTokens@var2062 .@expr1073748752 size (@expr1073748753 ) >@expr1073748754 4 &&@expr1073748755 mExtTokens@var2062 [@expr1073748756 1 ] ==@expr1073748757 "parent" ) {
1319: addFullScopeNameTokens (@expr1073748758 tokenList@var2295 , mData@var2063 .@expr1073748759 getScope (@expr1073748760 mExtTokens@var2062 [@expr1073748761 2 ] ) ) ; }
1320:
1321: Token * nameToken@var2303 ; nameToken@var2303 =@expr1073748762 addtoken (@expr1073748763 tokenList@var2295 , getSpelling (@expr1073748764 ) +@expr1073748765 getTemplateParameters (@expr1073748766 ) ) ;
1322: Scope * nestedIn@var2304 ; nestedIn@var2304 =@expr1073748767 const_cast < Scope *@expr6944 > (@expr1073748769 nameToken@var2303 .@expr1073748770 scope (@expr1073748771 ) ) ;
1323:
1324: if (@expr1073748772 prev@var2296 ) {
1325: const std ::@expr6949 string addr@var2305 =@expr1073748774 *@expr1073748775 (@expr1073748776 std ::@expr1073748777 find (@expr1073748778 mExtTokens@var2062 .@expr1073748779 begin (@expr1073748780 ) , mExtTokens@var2062 .@expr1073748781 end (@expr1073748782 ) , "prev" ) +@expr1073748783 1 ) ;
1326: mData@var2063 .@expr6960 ref (@expr1073748785 addr@var2305 , nameToken@var2303 ) ;
1327: }
1328: if (@expr1073748786 !@expr1073748787 nameToken@var2303 .@expr6964 function (@expr6965 ) ) {
1329: nestedIn@var2304 .@expr6966 functionList@var2306 .@expr1073748791 push_back (@expr1073748792 Function (@expr1073748793 nameToken@var2303 , unquote (@expr1073748794 getFullType (@expr1073748795 ) ) ) ) ;
1330: mData@var2063 .@expr1073748796 funcDecl (@expr1073748797 mExtTokens@var2062 .@expr1073748798 front (@expr1073748799 ) , nameToken@var2303 , &@expr1073748800 nestedIn@var2304 .@expr6966 functionList@var2306 .@expr6978 back (@expr6979 ) ) ;
1331: if (@expr1073748804 nodeType@var2022 ==@expr6981 CXXConstructorDecl@var1900 ) {
1332: nestedIn@var2304 .@expr6966 functionList@var2306 .@expr6978 back (@expr6979 ) .@expr6985 type@var2449 =@expr1073748810 Function ::@expr6987 Type ::@expr1073748812 eConstructor ; }
1333: else { if (@expr1073748813 nodeType@var2022 ==@expr1073748814 CXXDestructorDecl@var1904 ) {
1334: nestedIn@var2304 .@expr6966 functionList@var2306 .@expr6978 back (@expr6979 ) .@expr6985 type@var2449 =@expr1073748819 Function ::@expr6987 Type ::@expr1073748821 eDestructor ; }
1335: else {
1336: nestedIn@var2304 .@expr6966 functionList@var2306 .@expr6978 back (@expr6979 ) .@expr1073748825 retDef@var2450 =@expr1073748826 startToken@var2300 ; } }
1337: }
1338:
1339: Function * const function@var2307 ; function@var2307 =@expr1073748827 const_cast < Function *@expr6944 > (@expr1073748829 nameToken@var2303 .@expr6964 function (@expr6965 ) ) ;
1340:
1341: if (@expr7008 !@expr7009 prev@var2296 ) {
1342: auto accessControl@var2308 ; accessControl@var2308 =@expr1073748834 mData@var2063 .@expr7011 scopeAccessControl@var2437 .@expr1073748836 find (@expr1073748837 tokenList@var2295 .@expr6914 back (@expr6915 ) .@expr1073748840 scope (@expr1073748841 ) ) ;
1343: if (@expr1073748842 accessControl@var2308 !=@expr1073748843 mData@var2063 .@expr7011 scopeAccessControl@var2437 .@expr1073748845 end (@expr1073748846 ) ) {
1344: function@var2307 .@expr1073748847 access@var2309 =@expr1073748848 accessControl@var2308 .@expr1073748849 second@var2310 ; }
1345: }
1346:
1347: Scope * scope@var2311 ; scope@var2311 =@expr1073748850 nullptr ;
1348: if (@expr7027 hasBody@var2297 ) {
1349: symbolDatabase@var2301 .@expr7028 scopeList@var2312 .@expr1073748853 push_back (@expr1073748854 Scope (@expr1073748855 nullptr , nullptr , nestedIn@var2304 ) ) ;
1350: scope@var2311 =@expr1073748856 &@expr1073748857 symbolDatabase@var2301 .@expr7028 scopeList@var2312 .@expr1073748859 back (@expr1073748860 ) ;
1351: scope@var2311 .@expr1073748861 check@var2313 =@expr1073748862 symbolDatabase@var2301 ;
1352: scope@var2311 .@expr1073748863 function@var2314 =@expr1073748864 function@var2307 ;
1353: scope@var2311 .@expr1073748865 classDef@var2315 =@expr1073748866 nameToken@var2303 ;
1354: scope@var2311 .@expr1073748867 type@var2316 =@expr1073748868 Scope ::@expr1073748869 ScopeType ::@expr1073748870 eFunction ;
1355: scope@var2311 .@expr1073748871 className@var2317 =@expr1073748872 nameToken@var2303 .@expr1073748873 str (@expr1073748874 ) ;
1356: nestedIn@var2304 .@expr1073748875 nestedList@var2318 .@expr1073748876 push_back (@expr1073748877 scope@var2311 ) ;
1357: function@var2307 .@expr1073748878 hasBody (@expr1073748879 true ) ;
1358: function@var2307 .@expr1073748880 functionScope@var2319 =@expr1073748881 scope@var2311 ;
1359: }
1360:
1361: Token * par1@var2320 ; par1@var2320 =@expr1073748882 addtoken (@expr1073748883 tokenList@var2295 , "(" ) ;
1362: if (@expr1073748884 !@expr1073748885 function@var2307 .@expr7062 arg@var2321 ) {
1363: function@var2307 .@expr7062 arg@var2321 =@expr1073748888 par1@var2320 ; }
1364: function@var2307 .@expr1073748889 token@var2322 =@expr1073748890 nameToken@var2303 ;
1365: if (@expr1073748891 !@expr1073748892 function@var2307 .@expr7069 nestedIn@var2323 ) {
1366: function@var2307 .@expr7069 nestedIn@var2323 =@expr1073748895 nestedIn@var2304 ; }
1367: function@var2307 .@expr1073748896 argDef@var2324 =@expr1073748897 par1@var2320 ;
1368:
1369: for (@expr1073748898 int i@var2325 =@expr1073748899 0 ; i@var2325 <@expr1073748900 children@var2023 .@expr1073748901 size (@expr1073748902 ) ; ++@expr1073748903 i@var2325 ) {
1370: AstNodePtr child@var2326 ; child@var2326 =@expr1073748904 children@var2023 [@expr1073748905 i@var2325 ] ;
1371: if (@expr1073748906 child@var2326 .@expr1073748907 nodeType@var2327 !=@expr1073748908 ParmVarDecl@var1942 ) {
1372: continue ; }
1373: if (@expr1073748909 tokenList@var2295 .@expr6914 back (@expr6915 ) !=@expr1073748912 par1@var2320 ) {
1374: addtoken (@expr1073748913 tokenList@var2295 , "," ) ; }
1375: const Type * recordType@var2328 ; recordType@var2328 =@expr1073748914 addTypeTokens (@expr1073748915 tokenList@var2295 , child@var2326 .@expr7092 mExtTokens@var2329 .@expr1073748917 back (@expr1073748918 ) , nestedIn@var2304 ) ;
1376: const Token * typeEndToken@var2330 ; typeEndToken@var2330 =@expr1073748919 tokenList@var2295 .@expr6914 back (@expr6915 ) ;
1377: const std ::@expr6949 string spelling@var2331 =@expr1073748923 child@var2326 .@expr1073748924 getSpelling (@expr1073748925 ) ;
1378: Token * vartok@var2332 ; vartok@var2332 =@expr1073748926 nullptr ;
1379: if (@expr1073748927 !@expr1073748928 spelling@var2331 .@expr1073748929 empty (@expr1073748930 ) ) {
1380: vartok@var2332 =@expr1073748931 child@var2326 .@expr1073748932 addtoken (@expr1073748933 tokenList@var2295 , spelling@var2331 ) ; }
1381: if (@expr7008 !@expr7009 prev@var2296 ) {
1382: function@var2307 .@expr7112 argumentList@var2333 .@expr1073748937 push_back (@expr1073748938 Variable (@expr1073748939 vartok@var2332 , child@var2326 .@expr1073748940 getType (@expr1073748941 ) , nullptr , typeEndToken@var2330 , i@var2325 , AccessControl ::@expr1073748942 Argument , recordType@var2328 , scope@var2311 ) ) ;
1383: if (@expr7119 vartok@var2332 ) {
1384: const std ::@expr6949 string addr@var2334 =@expr1073748945 child@var2326 .@expr7092 mExtTokens@var2329 [@expr7123 0 ] ;
1385: mData@var2063 .@expr1073748948 varDecl (@expr1073748949 addr@var2334 , vartok@var2332 , &@expr1073748950 function@var2307 .@expr7112 argumentList@var2333 .@expr1073748952 back (@expr1073748953 ) ) ;
1386: }
1387: } else { if (@expr7119 vartok@var2332 ) {
1388: const std ::@expr6949 string addr@var2335 =@expr1073748956 child@var2326 .@expr7092 mExtTokens@var2329 [@expr7123 0 ] ;
1389: mData@var2063 .@expr6960 ref (@expr1073748960 addr@var2335 , vartok@var2332 ) ;
1390: } }
1391: }
1392: Token * par2@var2336 ; par2@var2336 =@expr1073748961 addtoken (@expr1073748962 tokenList@var2295 , ")" ) ;
1393: par1@var2320 .@expr1073748963 link (@expr1073748964 par2@var2336 ) ;
1394: par2@var2336 .@expr1073748965 link (@expr1073748966 par1@var2320 ) ;
1395:
1396: if (@expr1073748967 function@var2307 .@expr1073748968 isConst (@expr1073748969 ) ) {
1397: addtoken (@expr1073748970 tokenList@var2295 , "const" ) ; }
1398:
1399:
1400: if (@expr7027 hasBody@var2297 ) {
1401: symbolDatabase@var2301 .@expr1073748972 functionScopes@var2337 .@expr1073748973 push_back (@expr1073748974 scope@var2311 ) ;
1402: Token * bodyStart@var2338 ; bodyStart@var2338 =@expr1073748975 addtoken (@expr1073748976 tokenList@var2295 , "{" ) ;
1403: bodyStart@var2338 .@expr1073748977 scope (@expr1073748978 scope@var2311 ) ;
1404: children@var2023 .@expr6894 back (@expr6895 ) .@expr1073748981 createTokens (@expr1073748982 tokenList@var2295 ) ;
1405: Token * bodyEnd@var2339 ; bodyEnd@var2339 =@expr1073748983 addtoken (@expr1073748984 tokenList@var2295 , "}" ) ;
1406: scope@var2311 .@expr1073748985 bodyStart@var2340 =@expr1073748986 bodyStart@var2338 ;
1407: scope@var2311 .@expr1073748987 bodyEnd@var2341 =@expr1073748988 bodyEnd@var2339 ;
1408: bodyStart@var2338 .@expr1073748989 link (@expr1073748990 bodyEnd@var2339 ) ;
1409: bodyEnd@var2339 .@expr1073748991 link (@expr1073748992 bodyStart@var2338 ) ;
1410: } else {
1411: if (@expr1073748993 nodeType@var2022 ==@expr6981 CXXConstructorDecl@var1900 &&@expr1073748995 contains (@expr1073748996 mExtTokens@var2062 , "default" ) ) {
1412: addtoken (@expr1073748997 tokenList@var2295 , "=" ) ;
1413: addtoken (@expr1073748998 tokenList@var2295 , "default" ) ;
1414: }
1415:
1416: addtoken (@expr1073748999 tokenList@var2295 , ";" ) ;
1417: }
1418: }
1419:
1420: void clangimport :: AstNode :: createTokensForCXXRecord ( TokenList * tokenList@var2342 )
1421: {
1422: bool isStruct@var2343 ; isStruct@var2343 =@expr1073749001 contains (@expr1073749002 mExtTokens@var2062 , "struct" ) ;
1423: Token * const classToken@var2344 ; classToken@var2344 =@expr1073749003 addtoken (@expr1073749004 tokenList@var2342 , isStruct@var2343 ?@expr7181 "struct" :@expr7182 "class" ) ;
1424: std ::@expr1073749007 string className@var2345 ;
1425: if (@expr1073749008 mExtTokens@var2062 [@expr7185 mExtTokens@var2062 .@expr7186 size (@expr7187 ) -@expr7188 2 ] ==@expr1073749013 (@expr1073749014 isStruct@var2343 ?@expr7181 "struct" :@expr7182 "class" ) ) {
1426: className@var2345 =@expr1073749017 mExtTokens@var2062 .@expr1073749018 back (@expr1073749019 ) ; }
1427: else {
1428: className@var2345 =@expr1073749020 mExtTokens@var2062 [@expr7185 mExtTokens@var2062 .@expr7186 size (@expr7187 ) -@expr7188 2 ] ; }
1429: className@var2345 +=@expr1073749025 getTemplateParameters (@expr1073749026 ) ;
1430: addtoken (@expr1073749027 tokenList@var2342 , className@var2345 ) ;
1431:
1432: bool firstBase@var2346 ; firstBase@var2346 =@expr1073749028 true ;
1433: for (@expr1073749029 const std ::@expr7206 shared_ptr < AstNode > &@expr7207 child@var2347 :@expr1073749032 children@var2023 ) {
1434: if (@expr1073749033 child@var2347 .@expr7210 nodeType@var2348 ==@expr1073749035 "public" ||@expr1073749036 child@var2347 .@expr7210 nodeType@var2348 ==@expr1073749038 "protected" ||@expr1073749039 child@var2347 .@expr7210 nodeType@var2348 ==@expr1073749041 "private" ) {
1435: addtoken (@expr1073749042 tokenList@var2342 , firstBase@var2346 ?@expr1073749043 ":" :@expr1073749044 "," ) ;
1436: addtoken (@expr1073749045 tokenList@var2342 , child@var2347 .@expr7210 nodeType@var2348 ) ;
1437: addtoken (@expr1073749047 tokenList@var2342 , unquote (@expr1073749048 child@var2347 .@expr1073749049 mExtTokens@var2349 .@expr1073749050 back (@expr1073749051 ) ) ) ;
1438: firstBase@var2346 =@expr1073749052 false ;
1439: }
1440: }
1441:
1442: if (@expr1073749053 isDefinition (@expr1073749054 ) ) {
1443: std ::@expr1073749055 vector < AstNodePtr > children2@var2350 ;
1444: for (@expr1073749056 const AstNodePtr &@expr7207 child@var2351 :@expr1073749058 children@var2023 ) {
1445: if (@expr1073749059 child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749061 CXXConstructorDecl@var1900 ||@expr1073749062
1446: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749064 CXXDestructorDecl@var1904 ||@expr1073749065
1447: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749067 CXXMethodDecl@var1908 ||@expr1073749068
1448: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749070 FieldDecl@var1925 ||@expr1073749071
1449: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749073 VarDecl@var1951 ||@expr1073749074
1450: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749076 AccessSpecDecl@var1883 ||@expr1073749077
1451: child@var2351 .@expr7236 nodeType@var2352 ==@expr1073749079 TypedefDecl@var1948 ) {
1452: children2@var2350 .@expr1073749080 push_back (@expr1073749081 child@var2351 ) ; }
1453: }
1454: Scope * scope@var2353 ; scope@var2353 =@expr1073749082 createScope (@expr1073749083 tokenList@var2342 , isStruct@var2343 ?@expr1073749084 Scope ::@expr7261 ScopeType ::@expr1073749086 eStruct :@expr1073749087 Scope ::@expr7261 ScopeType ::@expr1073749089 eClass , children2@var2350 , classToken@var2344 ) ;
1455: const std ::@expr7206 string addr@var2354 =@expr1073749091 mExtTokens@var2062 [@expr1073749092 0 ] ;
1456: mData@var2063 .@expr1073749093 scopeDecl (@expr1073749094 addr@var2354 , scope@var2353 ) ;
1457: scope@var2353 .@expr1073749095 className@var2355 =@expr1073749096 className@var2345 ;
1458: mData@var2063 .@expr7273 mSymbolDatabase@var2433 .@expr7274 typeList@var2439 .@expr1073749099 push_back (@expr1073749100 Type (@expr1073749101 classToken@var2344 , scope@var2353 , classToken@var2344 .@expr7278 scope (@expr7279 ) ) ) ;
1459: scope@var2353 .@expr7280 definedType@var2356 =@expr1073749105 &@expr1073749106 mData@var2063 .@expr7273 mSymbolDatabase@var2433 .@expr7274 typeList@var2439 .@expr1073749109 back (@expr1073749110 ) ;
1460: const_cast < Scope *@expr7287 > (@expr1073749112 classToken@var2344 .@expr7278 scope (@expr7279 ) ) .@expr1073749115 definedTypesMap@expr1073749000 [@expr1073749116 className@var2345 ] =@expr1073749117 scope@var2353 .@expr7280 definedType@var2356 ;
1461: }
1462: addtoken (@expr1073749119 tokenList@var2342 , ";" ) ;
1463: const_cast < Token *@expr7287 > (@expr1073749121 tokenList@var2342 .@expr1073749122 back (@expr1073749123 ) ) .@expr1073749124 scope (@expr1073749125 classToken@var2344 .@expr7278 scope (@expr7279 ) ) ;
1464: }
1465:
1466: Token * clangimport :: AstNode :: createTokensVarDecl ( TokenList * tokenList@var2357 )
1467: {
1468: const std ::@expr7304 string addr@var2358 =@expr1073749129 mExtTokens@var2062 .@expr1073749130 front (@expr1073749131 ) ;
1469: if (@expr1073749132 contains (@expr1073749133 mExtTokens@var2062 , "static" ) ) {
1470: addtoken (@expr1073749134 tokenList@var2357 , "static" ) ; }
1471: int typeIndex@var2359 ; typeIndex@var2359 =@expr1073749135 mExtTokens@var2062 .@expr1073749136 size (@expr1073749137 ) -@expr1073749138 1 ;
1472: while (@expr1073749139 typeIndex@var2359 >@expr1073749140 1 &&@expr1073749141 std ::@expr1073749142 isalpha (@expr1073749143 mExtTokens@var2062 [@expr7320 typeIndex@var2359 ] [@expr1073749145 0 ] ) ) {
1473: typeIndex@var2359 --@expr1073749146 ; }
1474: const std ::@expr7304 string type@var2360 =@expr1073749148 mExtTokens@var2062 [@expr7320 typeIndex@var2359 ] ;
1475: const std ::@expr7304 string name@var2361 =@expr1073749151 mExtTokens@var2062 [@expr1073749152 typeIndex@var2359 -@expr1073749153 1 ] ;
1476: const Token * startToken@var2362 ; startToken@var2362 =@expr1073749154 tokenList@var2357 .@expr7331 back (@expr7332 ) ;
1477: const ::@expr1073749157 Type * recordType@var2363 ; recordType@var2363 =@expr1073749158 addTypeTokens (@expr1073749159 tokenList@var2357 , type@var2360 ) ;
1478: if (@expr1073749160 !@expr1073749161 startToken@var2362 ) {
1479: startToken@var2362 =@expr1073749162 tokenList@var2357 .@expr1073749163 front (@expr1073749164 ) ; }
1480: else { if (@expr1073749165 startToken@var2362 .@expr1073749166 str (@expr1073749167 ) !=@expr1073749168 "static" ) {
1481: startToken@var2362 =@expr1073749169 startToken@var2362 .@expr1073749170 next (@expr1073749171 ) ; } }
1482: Token * vartok1@var2364 ; vartok1@var2364 =@expr1073749172 addtoken (@expr1073749173 tokenList@var2357 , name@var2361 ) ;
1483: Scope * scope@var2365 ; scope@var2365 =@expr1073749174 const_cast < Scope *@expr1073749175 > (@expr1073749176 tokenList@var2357 .@expr7331 back (@expr7332 ) .@expr1073749179 scope (@expr1073749180 ) ) ;
1484: scope@var2365 .@expr7357 varlist@var2366 .@expr1073749182 push_back (@expr1073749183 Variable (@expr1073749184 vartok1@var2364 , unquote (@expr1073749185 type@var2360 ) , startToken@var2362 , vartok1@var2364 .@expr1073749186 previous (@expr1073749187 ) , 0 , scope@var2365 .@expr1073749188 defaultAccess (@expr1073749189 ) , recordType@var2363 , scope@var2365 ) ) ;
1485: mData@var2063 .@expr1073749190 varDecl (@expr1073749191 addr@var2358 , vartok1@var2364 , &@expr1073749192 scope@var2365 .@expr7357 varlist@var2366 .@expr1073749194 back (@expr1073749195 ) ) ;
1486: if (@expr1073749196 mExtTokens@var2062 .@expr7373 back (@expr7374 ) ==@expr1073749199 "cinit" &&@expr1073749200 !@expr1073749201 children@var2023 .@expr1073749202 empty (@expr1073749203 ) ) {
1487: Token * eq@var2367 ; eq@var2367 =@expr1073749204 addtoken (@expr1073749205 tokenList@var2357 , "=" ) ;
1488: eq@var2367 .@expr1073749206 astOperand1 (@expr1073749207 vartok1@var2364 ) ;
1489: eq@var2367 .@expr1073749208 astOperand2 (@expr1073749209 children@var2023 .@expr1073749210 back (@expr1073749211 ) .@expr1073749212 createTokens (@expr1073749213 tokenList@var2357 ) ) ;
1490: return eq@var2367 ;
1491: } else { if (@expr1073749214 mExtTokens@var2062 .@expr7373 back (@expr7374 ) ==@expr1073749217 "callinit" ) {
1492: Token * par1@var2368 ; par1@var2368 =@expr1073749218 addtoken (@expr1073749219 tokenList@var2357 , "(" ) ;
1493: par1@var2368 .@expr1073749220 astOperand1 (@expr1073749221 vartok1@var2364 ) ;
1494: par1@var2368 .@expr1073749222 astOperand2 (@expr1073749223 getChild (@expr7400 0 ) .@expr7401 createTokens (@expr7402 tokenList@var2357 ) ) ;
1495: Token * par2@var2369 ; par2@var2369 =@expr1073749227 addtoken (@expr1073749228 tokenList@var2357 , ")" ) ;
1496: par1@var2368 .@expr1073749229 link (@expr1073749230 par2@var2369 ) ;
1497: par2@var2369 .@expr1073749231 link (@expr1073749232 par1@var2368 ) ;
1498: return par1@var2368 ;
1499: } else { if (@expr1073749233 mExtTokens@var2062 .@expr7373 back (@expr7374 ) ==@expr1073749236 "listinit" ) {
1500: return getChild (@expr7400 0 ) .@expr7401 createTokens (@expr7402 tokenList@var2357 ) ;
1501: } } }
1502: return vartok1@var2364 ;
1503: }
1504:
1505: static void setTypes ( TokenList * tokenList@var2370 )
1506: {
1507: for (@expr1073749240 Token *@expr7417 tok@var2371 =@expr1073749242 tokenList@var2370 .@expr1073749243 front (@expr1073749244 ) ; tok@var2371 ; tok@var2371 =@expr1073749245 tok@var2371 .@expr1073749246 next (@expr1073749247 ) ) {
1508: if (@expr1073749248 Token ::@expr1073749249 simpleMatch (@expr1073749250 tok@var2371 , "sizeof (" ) ) {
1509: for (@expr1073749251 Token *@expr7417 typeToken@var2372 =@expr1073749253 tok@var2371 .@expr1073749254 tokAt (@expr1073749255 2 ) ; typeToken@var2372 .@expr7432 str (@expr7433 ) !=@expr1073749258 ")" ; typeToken@var2372 =@expr1073749259 typeToken@var2372 .@expr1073749260 next (@expr1073749261 ) ) {
1510: if (@expr1073749262 typeToken@var2372 .@expr7439 type (@expr1073749264 ) ) {
1511: continue ; }
1512: typeToken@var2372 .@expr7439 type (@expr1073749266 typeToken@var2372 .@expr1073749267 scope (@expr1073749268 ) .@expr1073749269 findType (@expr1073749270 typeToken@var2372 .@expr7432 str (@expr7433 ) ) ) ;
1513: }
1514: }
1515: }
1516: }
1517:
1518: static void setValues ( Tokenizer * tokenizer@var2373 , SymbolDatabase * symbolDatabase@var2374 )
1519: {
1520: const Settings * const settings@var2375 ; settings@var2375 =@expr1073749273 tokenizer@var2373 .@expr1073749274 getSettings (@expr1073749275 ) ;
1521:
1522: for (@expr1073749276 Scope &@expr7453 scope@var2376 :@expr1073749278 symbolDatabase@var2374 .@expr1073749279 scopeList@var2377 ) {
1523: if (@expr1073749280 !@expr1073749281 scope@var2376 .@expr7458 definedType@var2378 ) {
1524: continue ; }
1525:
1526: int typeSize@var2379 ; typeSize@var2379 =@expr1073749283 0 ;
1527: for (@expr1073749284 const Variable &@expr7453 var@var2380 :@expr1073749286 scope@var2376 .@expr1073749287 varlist@var2381 ) {
1528: int mul@var2382 ; mul@var2382 =@expr1073749288 1 ;
1529: for (@expr1073749289 const auto &@expr7453 dim@var2383 :@expr1073749291 var@var2380 .@expr1073749292 dimensions (@expr1073749293 ) ) {
1530: mul@var2382 *=@expr1073749294 dim@var2383 .@expr1073749295 num@var2384 ;
1531: }
1532: if (@expr1073749296 var@var2380 .@expr7473 valueType (@expr7474 ) ) {
1533: typeSize@var2379 +=@expr1073749299 mul@var2382 *@expr1073749300 var@var2380 .@expr7473 valueType (@expr7474 ) .@expr1073749303 typeSize (@expr1073749304 *@expr7481 settings@var2375 , true ) ; }
1534: }
1535: scope@var2376 .@expr7458 definedType@var2378 .@expr1073749307 sizeOf@var2385 =@expr1073749308 typeSize@var2379 ;
1536: }
1537:
1538: for (@expr1073749309 Token *@expr7486 tok@var2386 =@expr1073749311 const_cast < Token *@expr7486 > (@expr1073749313 tokenizer@var2373 .@expr1073749314 tokens (@expr1073749315 ) ) ; tok@var2386 ; tok@var2386 =@expr1073749316 tok@var2386 .@expr7493 next (@expr7494 ) ) {
1539: if (@expr1073749319 Token ::@expr1073749320 simpleMatch (@expr1073749321 tok@var2386 , "sizeof (" ) ) {
1540: ValueType vt@var2387 ; vt@var2387 =@expr1073749322 ValueType ::@expr1073749323 parseDecl (@expr1073749324 tok@var2386 .@expr1073749325 tokAt (@expr1073749326 2 ) , settings@var2375 ) ;
1541: int sz@var2388 ; sz@var2388 =@expr1073749327 vt@var2387 .@expr1073749328 typeSize (@expr1073749329 *@expr7481 settings@var2375 , true ) ;
1542: if (@expr1073749331 sz@var2388 <=@expr1073749332 0 ) {
1543: continue ; }
1544: long long mul@var2389 ; mul@var2389 =@expr1073749333 1 ;
1545: for (@expr1073749334 Token *@expr7486 arrtok@var2390 =@expr1073749336 tok@var2386 .@expr1073749337 linkAt (@expr1073749338 1 ) .@expr1073749339 previous (@expr1073749340 ) ; arrtok@var2390 ; arrtok@var2390 =@expr1073749341 arrtok@var2390 .@expr1073749342 previous (@expr1073749343 ) ) {
1546: const std ::@expr1073749344 string &@expr7453 a@var2391 =@expr1073749346 arrtok@var2390 .@expr1073749347 str (@expr1073749348 ) ;
1547: if (@expr1073749349 a@var2391 .@expr1073749350 size (@expr1073749351 ) >@expr1073749352 2 &&@expr1073749353 a@var2391 [@expr1073749354 0 ] ==@expr1073749355 '[' &&@expr1073749356 a@var2391 .@expr1073749357 back (@expr1073749358 ) ==@expr1073749359 ']' ) {
1548: mul@var2389 *=@expr1073749360 std ::@expr1073749361 atoi (@expr1073749362 a@var2391 .@expr1073749363 substr (@expr1073749364 1 ) .@expr1073749365 c_str (@expr1073749366 ) ) ; }
1549: else {
1550: break ; }
1551: }
1552: ValueFlow ::@expr1073749367 Value v@var2392 (@expr1073749368 mul@var2389 *@expr1073749369 sz@var2388 ) ;
1553: v@var2392 .@expr1073749370 setKnown (@expr1073749371 ) ;
1554: tok@var2386 .@expr7493 next (@expr7494 ) .@expr1073749374 addValue (@expr1073749375 v@var2392 ) ;
1555: }
1556: }
1557: }
1558:
1559: void clangimport :: parseClangAstDump ( Tokenizer * tokenizer@var2393 , std :: istream & f@var2394 )
1560: {
1561: TokenList * tokenList@var2395 ; tokenList@var2395 =@expr1073749377 &@expr1073749378 tokenizer@var2393 .@expr1073749379 list@var2396 ;
1562:
1563: tokenizer@var2393 .@expr1073749380 createSymbolDatabase (@expr1073749381 ) ;
1564: SymbolDatabase * symbolDatabase@var2397 ; symbolDatabase@var2397 =@expr1073749382 const_cast < SymbolDatabase *@expr7559 > (@expr1073749384 tokenizer@var2393 .@expr1073749385 getSymbolDatabase (@expr1073749386 ) ) ;
1565: symbolDatabase@var2397 .@expr7563 scopeList@var2398 .@expr1073749388 push_back (@expr1073749389 Scope (@expr1073749390 nullptr , nullptr , nullptr ) ) ;
1566: symbolDatabase@var2397 .@expr7563 scopeList@var2398 .@expr7568 back (@expr7569 ) .@expr1073749394 type@var2451 =@expr1073749395 Scope ::@expr1073749396 ScopeType ::@expr1073749397 eGlobal ;
1567: symbolDatabase@var2397 .@expr7563 scopeList@var2398 .@expr7568 back (@expr7569 ) .@expr1073749401 check@var2452 =@expr1073749402 symbolDatabase@var2397 ;
1568:
1569: clangimport ::@expr1073749403 Data data@var2399 ;
1570: data@var2399 .@expr1073749404 mSettings@var2400 =@expr1073749405 tokenizer@var2393 .@expr1073749406 getSettings (@expr1073749407 ) ;
1571: data@var2399 .@expr1073749408 mSymbolDatabase@var2401 =@expr1073749409 symbolDatabase@var2397 ;
1572: std ::@expr1073749410 string line@var2402 ;
1573: std ::@expr1073749411 vector < std ::@expr7588 shared_ptr < AstNode > > tree@var2403 ;
1574: while (@expr1073749413 std ::@expr1073749414 getline (@expr1073749415 f@var2394 , line@var2402 ) ) {
1575: const std ::@expr7588 string ::@expr7588 size_type pos1@var2404 =@expr1073749418 line@var2402 .@expr7595 find (@expr1073749420 "-" ) ;
1576: if (@expr1073749421 pos1@var2404 ==@expr1073749422 std ::@expr7599 string ::@expr7600 npos@expr7552 ) {
1577: continue ; }
1578: if (@expr1073749425 !@expr7602 tree@var2403 .@expr7603 empty (@expr7604 ) &&@expr1073749429 line@var2402 .@expr7606 substr (@expr1073749431 pos1@var2404 ) ==@expr1073749432 "-<<<NULL>>>" ) {
1579: const int level@var2405 =@expr1073749433 (@expr1073749434 pos1@var2404 -@expr7611 1 ) /@expr7612 2 ;
1580: tree@var2403 [@expr1073749437 level@var2405 -@expr1073749438 1 ] .@expr1073749439 children .@expr1073749440 push_back (@expr1073749441 nullptr ) ;
1581: continue ;
1582: }
1583: const std ::@expr7588 string ::@expr7588 size_type pos2@var2406 =@expr1073749444 line@var2402 .@expr7595 find (@expr1073749446 " " , pos1@var2404 ) ;
1584: if (@expr1073749447 pos2@var2406 <@expr1073749448 pos1@var2404 +@expr1073749449 4 ||@expr1073749450 pos2@var2406 ==@expr1073749451 std ::@expr7599 string ::@expr7600 npos@expr7552 ) {
1585: continue ; }
1586: const std ::@expr7588 string nodeType@var2407 =@expr1073749455 line@var2402 .@expr7606 substr (@expr1073749457 pos1@var2404 +@expr1073749458 1 , pos2@var2406 -@expr1073749459 pos1@var2404 -@expr1073749460 1 ) ;
1587: const std ::@expr7588 string ext@var2408 =@expr1073749462 line@var2402 .@expr7606 substr (@expr1073749464 pos2@var2406 ) ;
1588:
1589: if (@expr1073749465 pos1@var2404 ==@expr1073749466 1 &&@expr1073749467 endsWith (@expr1073749468 nodeType@var2407 , "Decl" ) ) {
1590: if (@expr7645 !@expr7602 tree@var2403 .@expr7603 empty (@expr7604 ) ) {
1591: tree@var2403 [@expr7649 0 ] .@expr7650 createTokens1 (@expr7651 tokenList@var2395 ) ; }
1592: tree@var2403 .@expr1073749476 clear (@expr1073749477 ) ;
1593: tree@var2403 .@expr7654 push_back (@expr1073749479 std ::@expr7656 make_shared < AstNode > (@expr7657 nodeType@var2407 , ext@var2408 , &@expr7658 data@var2399 ) ) ;
1594: continue ;
1595: }
1596:
1597: const int level@var2409 =@expr1073749483 (@expr1073749484 pos1@var2404 -@expr7611 1 ) /@expr7612 2 ;
1598: if (@expr1073749487 level@var2409 ==@expr1073749488 0 ||@expr1073749489 level@var2409 >@expr1073749490 tree@var2403 .@expr7667 size (@expr7668 ) ) {
1599: continue ; }
1600:
1601: AstNodePtr newNode@var2410 ; newNode@var2410 =@expr1073749493 std ::@expr7656 make_shared < AstNode > (@expr7657 nodeType@var2407 , ext@var2408 , &@expr7658 data@var2399 ) ;
1602: tree@var2403 [@expr1073749497 level@var2409 -@expr1073749498 1 ] .@expr1073749499 children .@expr1073749500 push_back (@expr1073749501 newNode@var2410 ) ;
1603: if (@expr1073749502 level@var2409 >=@expr1073749503 tree@var2403 .@expr7667 size (@expr7668 ) ) {
1604: tree@var2403 .@expr7654 push_back (@expr1073749507 newNode@var2410 ) ; }
1605: else {
1606: tree@var2403 [@expr1073749508 level@var2409 ] =@expr1073749509 newNode@var2410 ; }
1607: }
1608:
1609: if (@expr7645 !@expr7602 tree@var2403 .@expr7603 empty (@expr7604 ) ) {
1610: tree@var2403 [@expr7649 0 ] .@expr7650 createTokens1 (@expr7651 tokenList@var2395 ) ; }
1611:
1612:
1613: for (@expr1073749517 const Token *@expr7559 tok@var2411 =@expr1073749519 tokenList@var2395 .@expr7696 front (@expr7697 ) ; tok@var2411 ; tok@var2411 =@expr1073749522 tok@var2411 .@expr1073749523 next (@expr1073749524 ) ) {
1614: if (@expr1073749525 Token ::@expr1073749526 Match (@expr1073749527 tok@var2411 , "(|)|[|]|{|}" ) &&@expr1073749528 !@expr1073749529 tok@var2411 .@expr1073749530 link (@expr1073749531 ) ) {
1615: throw InternalError (@expr1073749532 tok@var2411 , "Token::link() is not set properly" ) ; }
1616: }
1617:
1618: if (@expr1073749533 tokenList@var2395 .@expr7696 front (@expr7697 ) ) {
1619: tokenList@var2395 .@expr7696 front (@expr7697 ) .@expr1073749538 assignIndexes (@expr1073749539 ) ; }
1620: symbolDatabase@var2397 .@expr1073749540 clangSetVariables (@expr1073749541 data@var2399 .@expr1073749542 getVariableList (@expr1073749543 ) ) ;
1621: symbolDatabase@var2397 .@expr1073749544 createSymbolDatabaseExprIds (@expr1073749545 ) ;
1622: tokenList@var2395 .@expr1073749546 clangSetOrigFiles (@expr1073749547 ) ;
1623: setTypes (@expr1073749548 tokenList@var2395 ) ;
1624: setValues (@expr1073749549 tokenizer@var2393 , symbolDatabase@var2397 ) ;
1625: }

##file cppcheck-2.8/lib/settings.h

11:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2412 ; mFlags@var2412 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2412 ;
54: }
55: void clear ( ) {
56: mFlags@var2412 =@expr1073749550 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2412 =@expr1073749551 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2413 ) {
62: if (@expr1073749552 enabled@var2413 ) {
63: fill (@expr1073749553 ) ; }
64: else {
65: clear (@expr1073749554 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2414 ) const {
68: return (@expr7731 mFlags@var2412 &@expr1073749556 (@expr7731 1U <<@expr1073749558 (@expr1073749559 uint32_t ) flag@var2414 ) ) !=@expr1073749560 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2415 ) {
71: mFlags@var2412 |=@expr1073749561 (@expr1073749562 1U <<@expr1073749563 (@expr1073749564 uint32_t ) flag@var2415 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2416 ) {
74: mFlags@var2412 &=@expr1073749565 ~@expr1073749566 (@expr1073749567 1U <<@expr1073749568 (@expr1073749569 uint32_t ) flag@var2416 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2417 , bool enabled@var2418 ) {
77: if (@expr1073749570 enabled@var2418 ) {
78: enable (@expr1073749571 flag@var2417 ) ; }
79: else {
80: disable (@expr1073749572 flag@var2417 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2419 ; mFlags@var2419 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2419 ;
54: }
55: void clear ( ) {
56: mFlags@var2419 =@expr1073749573 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2419 =@expr1073749574 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2420 ) {
62: if (@expr1073749575 enabled@var2420 ) {
63: fill (@expr1073749576 ) ; }
64: else {
65: clear (@expr1073749577 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2421 ) const {
68: return (@expr7754 mFlags@var2419 &@expr1073749579 (@expr7754 1U <<@expr1073749581 (@expr1073749582 uint32_t ) flag@var2421 ) ) !=@expr1073749583 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2422 ) {
71: mFlags@var2419 |=@expr1073749584 (@expr1073749585 1U <<@expr1073749586 (@expr1073749587 uint32_t ) flag@var2422 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2423 ) {
74: mFlags@var2419 &=@expr1073749588 ~@expr1073749589 (@expr1073749590 1U <<@expr1073749591 (@expr1073749592 uint32_t ) flag@var2423 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2424 , bool enabled@var2425 ) {
77: if (@expr1073749593 enabled@var2425 ) {
78: enable (@expr1073749594 flag@var2424 ) ; }
79: else {
80: disable (@expr1073749595 flag@var2424 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2426 ; mFlags@var2426 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2426 ;
54: }
55: void clear ( ) {
56: mFlags@var2426 =@expr1073749596 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2426 =@expr1073749597 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2427 ) {
62: if (@expr1073749598 enabled@var2427 ) {
63: fill (@expr1073749599 ) ; }
64: else {
65: clear (@expr1073749600 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2428 ) const {
68: return (@expr7777 mFlags@var2426 &@expr1073749602 (@expr7777 1U <<@expr1073749604 (@expr1073749605 uint32_t ) flag@var2428 ) ) !=@expr1073749606 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2429 ) {
71: mFlags@var2426 |=@expr1073749607 (@expr1073749608 1U <<@expr1073749609 (@expr1073749610 uint32_t ) flag@var2429 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2430 ) {
74: mFlags@var2426 &=@expr1073749611 ~@expr1073749612 (@expr1073749613 1U <<@expr1073749614 (@expr1073749615 uint32_t ) flag@var2430 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2431 , bool enabled@var2432 ) {
77: if (@expr1073749616 enabled@var2432 ) {
78: enable (@expr1073749617 flag@var2431 ) ; }
79: else {
80: disable (@expr1073749618 flag@var2431 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@29947,34@30203}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  end possible "Decl"@4092
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end possible "Decl"@15
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@116,34@117}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@116,""@117,""@118,"U"@119,"U"@120,"u"@121,"u"@122,"u8"@123,"u8"@124}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@248,34@249}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@245,34@247}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@206,128@207,64@208,32@209,16@210,8@211,4@212,2@213,1@214}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@215,128@216,64@217,32@218,16@219,8@220,4@221,2@222,1@223}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@215,4294967167@216,4294967231@217,4294967263@218,4294967279@219,4294967287@220,4294967291@221,4294967293@222,4294967294@223}
  flag {!<=-1,256@215,128@216,64@217,32@218,16@219,8@220,4@221,2@222,1@223}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible 2@33
Line 246
  ( always !0
  this always !0
  index possible 1@34
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pattern possible {"sizeof ("@32,"sizeof ("@42,", }"@39}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@105,4@106,0@107}
  t possible {10@105,4@106,0@107}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@105,4@106,0@107}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@105,0@107}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@105,0@107}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@105}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@105}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@105}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@105}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@105}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@113}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1006
  = inconclusive {lifetime[Object]=(symbolDatabase->scopeList)@172,symbolic=(&symbolDatabase->scopeList.back())@172}
  s inconclusive {lifetime[Object]=(symbolDatabase->scopeList)@172,symbolic=(&symbolDatabase->scopeList.back())@172}
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = {0,lifetime[Object]=(scope->varlist)@15589,lifetime[Object]=(function->argumentList)@29669}
  v {0,lifetime[Object]=(scope->varlist)@15589,lifetime[Object]=(function->argumentList)@29669}
Line 1035
  v {lifetime[Object]=(scope->varlist)@15589,lifetime[Object]=(function->argumentList)@29669}
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible {0,lifetime[Object]=(scope->enumeratorList)@8426}
  e possible {0,lifetime[Object]=(scope->enumeratorList)@8426}
Line 1080
  e possible lifetime[Object]=(scope->enumeratorList)@8426
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@115,17179869184@126,8589934592@128,34359738368@130,4294967296@132,2147483648@134,1073741824@136,536870912@138,268435456@140}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@202,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@203}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@114,17179869184@125,8589934592@127,34359738368@129,4294967296@131,2147483648@133,1073741824@135,536870912@137,268435456@139}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@114,17179869184@125,8589934592@127,34359738368@129,4294967296@131,2147483648@133,1073741824@135,536870912@137,268435456@139}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@48,4096@51,16384@54,2048@55,1024@56,65536@57,512@58,256@59,128@60}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@13,4194304@15,8388608@16,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@247,2097152@248,1048576@249,524288@250,262144@251,131072@252,65536@253,32768@254,16384@255}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@247,4292870143@248,4293918719@249,4294443007@250,4294705151@251,4294836223@252,4294901759@253,4294934527@254,4294950911@255}
  flag {!<=-1,8388608@247,2097152@248,1048576@249,524288@250,262144@251,131072@252,65536@253,32768@254,16384@255}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state {!<=-1,!>=2,1@109}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 45
  = always "AccessSpecDecl"
  "AccessSpecDecl" always "AccessSpecDecl"
Line 46
  = always "ArraySubscriptExpr"
  "ArraySubscriptExpr" always "ArraySubscriptExpr"
Line 47
  = always "BinaryOperator"
  "BinaryOperator" always "BinaryOperator"
Line 48
  = always "BreakStmt"
  "BreakStmt" always "BreakStmt"
Line 49
  = always "CallExpr"
  "CallExpr" always "CallExpr"
Line 50
  = always "CaseStmt"
  "CaseStmt" always "CaseStmt"
Line 51
  = always "CharacterLiteral"
  "CharacterLiteral" always "CharacterLiteral"
Line 52
  = always "ClassTemplateDecl"
  "ClassTemplateDecl" always "ClassTemplateDecl"
Line 53
  = always "ClassTemplateSpecializationDecl"
  "ClassTemplateSpecializationDecl" always "ClassTemplateSpecializationDecl"
Line 54
  = always "ConditionalOperator"
  "ConditionalOperator" always "ConditionalOperator"
Line 55
  = always "ConstantExpr"
  "ConstantExpr" always "ConstantExpr"
Line 56
  = always "CompoundAssignOperator"
  "CompoundAssignOperator" always "CompoundAssignOperator"
Line 57
  = always "CompoundStmt"
  "CompoundStmt" always "CompoundStmt"
Line 58
  = always "ContinueStmt"
  "ContinueStmt" always "ContinueStmt"
Line 59
  = always "CStyleCastExpr"
  "CStyleCastExpr" always "CStyleCastExpr"
Line 60
  = always "CXXBindTemporaryExpr"
  "CXXBindTemporaryExpr" always "CXXBindTemporaryExpr"
Line 61
  = always "CXXBoolLiteralExpr"
  "CXXBoolLiteralExpr" always "CXXBoolLiteralExpr"
Line 62
  = always "CXXConstructorDecl"
  "CXXConstructorDecl" always "CXXConstructorDecl"
Line 63
  = always "CXXConstructExpr"
  "CXXConstructExpr" always "CXXConstructExpr"
Line 64
  = always "CXXDefaultArgExpr"
  "CXXDefaultArgExpr" always "CXXDefaultArgExpr"
Line 65
  = always "CXXDeleteExpr"
  "CXXDeleteExpr" always "CXXDeleteExpr"
Line 66
  = always "CXXDestructorDecl"
  "CXXDestructorDecl" always "CXXDestructorDecl"
Line 67
  = always "CXXForRangeStmt"
  "CXXForRangeStmt" always "CXXForRangeStmt"
Line 68
  = always "CXXFunctionalCastExpr"
  "CXXFunctionalCastExpr" always "CXXFunctionalCastExpr"
Line 69
  = always "CXXMemberCallExpr"
  "CXXMemberCallExpr" always "CXXMemberCallExpr"
Line 70
  = always "CXXMethodDecl"
  "CXXMethodDecl" always "CXXMethodDecl"
Line 71
  = always "CXXNewExpr"
  "CXXNewExpr" always "CXXNewExpr"
Line 72
  = always "CXXNullPtrLiteralExpr"
  "CXXNullPtrLiteralExpr" always "CXXNullPtrLiteralExpr"
Line 73
  = always "CXXOperatorCallExpr"
  "CXXOperatorCallExpr" always "CXXOperatorCallExpr"
Line 74
  = always "CXXRecordDecl"
  "CXXRecordDecl" always "CXXRecordDecl"
Line 75
  = always "CXXStaticCastExpr"
  "CXXStaticCastExpr" always "CXXStaticCastExpr"
Line 76
  = always "CXXStdInitializerListExpr"
  "CXXStdInitializerListExpr" always "CXXStdInitializerListExpr"
Line 77
  = always "CXXTemporaryObjectExpr"
  "CXXTemporaryObjectExpr" always "CXXTemporaryObjectExpr"
Line 78
  = always "CXXThisExpr"
  "CXXThisExpr" always "CXXThisExpr"
Line 79
  = always "CXXThrowExpr"
  "CXXThrowExpr" always "CXXThrowExpr"
Line 80
  = always "DeclRefExpr"
  "DeclRefExpr" always "DeclRefExpr"
Line 81
  = always "DeclStmt"
  "DeclStmt" always "DeclStmt"
Line 82
  = always "DefaultStmt"
  "DefaultStmt" always "DefaultStmt"
Line 83
  = always "DoStmt"
  "DoStmt" always "DoStmt"
Line 84
  = always "EnumConstantDecl"
  "EnumConstantDecl" always "EnumConstantDecl"
Line 85
  = always "EnumDecl"
  "EnumDecl" always "EnumDecl"
Line 86
  = always "ExprWithCleanups"
  "ExprWithCleanups" always "ExprWithCleanups"
Line 87
  = always "FieldDecl"
  "FieldDecl" always "FieldDecl"
Line 88
  = always "FloatingLiteral"
  "FloatingLiteral" always "FloatingLiteral"
Line 89
  = always "ForStmt"
  "ForStmt" always "ForStmt"
Line 90
  = always "FunctionDecl"
  "FunctionDecl" always "FunctionDecl"
Line 91
  = always "FunctionTemplateDecl"
  "FunctionTemplateDecl" always "FunctionTemplateDecl"
Line 92
  = always "GotoStmt"
  "GotoStmt" always "GotoStmt"
Line 93
  = always "IfStmt"
  "IfStmt" always "IfStmt"
Line 94
  = always "ImplicitCastExpr"
  "ImplicitCastExpr" always "ImplicitCastExpr"
Line 95
  = always "InitListExpr"
  "InitListExpr" always "InitListExpr"
Line 96
  = always "IntegerLiteral"
  "IntegerLiteral" always "IntegerLiteral"
Line 97
  = always "LabelStmt"
  "LabelStmt" always "LabelStmt"
Line 98
  = always "LinkageSpecDecl"
  "LinkageSpecDecl" always "LinkageSpecDecl"
Line 99
  = always "MaterializeTemporaryExpr"
  "MaterializeTemporaryExpr" always "MaterializeTemporaryExpr"
Line 100
  = always "MemberExpr"
  "MemberExpr" always "MemberExpr"
Line 101
  = always "NamespaceDecl"
  "NamespaceDecl" always "NamespaceDecl"
Line 102
  = always "NullStmt"
  "NullStmt" always "NullStmt"
Line 103
  = always "ParenExpr"
  "ParenExpr" always "ParenExpr"
Line 104
  = always "ParmVarDecl"
  "ParmVarDecl" always "ParmVarDecl"
Line 105
  = always "RecordDecl"
  "RecordDecl" always "RecordDecl"
Line 106
  = always "ReturnStmt"
  "ReturnStmt" always "ReturnStmt"
Line 107
  = always "StringLiteral"
  "StringLiteral" always "StringLiteral"
Line 108
  = always "SwitchStmt"
  "SwitchStmt" always "SwitchStmt"
Line 109
  = always "TemplateArgument"
  "TemplateArgument" always "TemplateArgument"
Line 110
  = always "TypedefDecl"
  "TypedefDecl" always "TypedefDecl"
Line 111
  = always "UnaryOperator"
  "UnaryOperator" always "UnaryOperator"
Line 112
  = always "UnaryExprOrTypeTraitExpr"
  "UnaryExprOrTypeTraitExpr" always "UnaryExprOrTypeTraitExpr"
Line 113
  = always "VarDecl"
  "VarDecl" always "VarDecl"
Line 114
  = always "WhileStmt"
  "WhileStmt" always "WhileStmt"
Line 118
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
  1 always 1
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 125
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
Line 126
  pos1 always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 127
  :: always !<=-1
  pos2 always !<=-1
Line 128
  "*()" always "*()"
  pos1 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
Line 129
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  1 always 1
Line 130
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  + always !<=0
  1 always 1
Line 133
  [ possible {34,39}
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  == {!<=-1,!>=2,0}
  '<' always 60
Line 134
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  ">" always ">"
  pos1 always {!<=-1,!>=symbolic=(line.size())}
Line 135
  [ {39,!60}
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  == {!<=-1,!>=2,0}
  '\"' always 34
Line 136
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  "\"" always "\""
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  + always !<=0
  1 always 1
Line 137
  [ always {!60,!34}
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  '\'' always 39
Line 138
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  "\'" always "\'"
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  + always !<=0
  1 always 1
Line 139
  pos2 always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=symbolic=(pos1)
  ( always {!<=-1,!<=symbolic=(pos1)}
  3 always 3
  && always {!<=-1,!>=2}
  pos2 {!<=-1,<=symbolic=((int)line.size()-3-1),!>=symbolic=((int)line.size()-3)}
  3 always 3
  "\':\'" always "\':\'"
  0 always 0
  3 always 3
  == always {!<=-1,!>=2}
  0 always 0
Line 140
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  "\'" always "\'"
  pos2 {!<=-1,<=symbolic=((int)line.size()-3-1),!>=symbolic=((int)line.size()-3)}
  + always !<=2
  3 always 3
Line 142
  pos2 always !<=-1
  = always {!<=-1,!>=symbolic=(line.size())}
  pos1 always {!<=-1,!>=symbolic=(line.size())}
Line 143
  pos2 {>=symbolic=(pos1),!<=-1,<=symbolic=(line.size()-1),>=symbolic=(line.size())}
  < always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(pos2+1),<=symbolic=(pos2),!<=symbolic=(pos1)}
  && always {!<=-1,!>=2}
  pos2 {symbolic=(pos1),!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  pos2 {symbolic=(pos1),!<=-1,!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  ':' always 58
  || always {!<=-1,!>=2}
  ( always !<=-1
  pos2 {symbolic=(pos1),!<=-1,!>=symbolic=(line.size())}
Line 144
  ++ {!<=0,<=symbolic=(line.size()),!>=symbolic=(line.size()+1)}
  pos2 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
Line 145
  pos2 {!<=-1,<=symbolic=(line.size()-1),>=symbolic=(line.size())}
  > {!<=-1,!>=2,0}
  pos1 {symbolic=(pos2),!<=-1,!>=symbolic=(line.size())}
  && always {!<=-1,!>=2}
  pos2 {!<=-1,>=symbolic=(pos1+1),!<=symbolic=(pos1)}
  < always {!<=-1,!>=2}
  ( always {!<=-1,!<=symbolic=(pos1)}
  && always {!<=-1,!>=2}
  pos2 {!<=-1,>=symbolic=(pos1+1),!<=symbolic=(pos1),<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
  [ always {!60,!34,!39}
  pos1 always {!<=-1,!>=symbolic=(line.size())}
Line 146
  = always 1
  1 always 1
Line 147
  ++ {!<=0,>=symbolic=(pos1+2),<=symbolic=(line.size())}
  pos2 {!<=-1,>=symbolic=(pos1+1),<=symbolic=(line.size()-1)}
  < always {!<=-1,!>=2}
  ( always {!<=-1,!<=symbolic=(pos1)}
  && always {!<=-1,!>=2}
  tlevel possible 1
  > {!<=-1,!>=2,1}
  0 always 0
Line 148
  [ possible 62
  pos2 always !<=-1
  == {!<=-1,!>=2,0}
  '<' always 60
Line 149
  ++ always !<=1
  tlevel always !<=0
Line 150
  [ always !60
  pos2 always !<=-1
  == always {!<=-1,!>=2}
  '>' always 62
Line 151
  -- always !<=-1
  tlevel always !<=0
Line 153
  tlevel possible <=0
  == {!<=-1,!>=2,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  pos2 always !<=-1
  < always {!<=-1,!>=2}
  ( always {!<=-1,!<=symbolic=(pos1)}
  && always {!<=-1,!>=2}
  pos2 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  ' ' always 32
Line 154
  pos1 always {!<=-1,!>=symbolic=(line.size())}
  pos2 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  - always !<=-1
  pos1 always {!<=-1,!>=symbolic=(line.size())}
Line 155
  pos1 always !<=-1
  = always !<=0
  pos2 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  + always !<=0
  1 always 1
Line 160
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  pos1 {symbolic=(pos2),!<=-1}
  - always !<=-1
  1 always 1
Line 161
  ( possible 0
  [ possible 95
  pos1 always !<=-1
  || always {!<=-1,!>=2}
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  '_' always 95
  && always {!<=-1,!>=2}
Line 162
  ( always !<=-1
  "::" always "::"
  pos1 always !<=-1
  < always {!<=-1,!>=2}
  pos2 always !<=-1
  && always {!<=-1,!>=2}
Line 163
  ( always !<=-1
  "::" always "::"
  pos1 always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  "<" always "<"
  pos1 always !<=-1
Line 164
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  "::" always "::"
  pos1 always !<=-1
Line 165
  pos1 always !<=-1
  pos2 always !<=-1
  - always !<=-1
  pos1 always !<=-1
Line 166
  ret always !size=0
  "::" always "::"
Line 167
  pos1 always !<=-1
  = always !<=1
  pos2 always !<=-1
  + always !<=1
  2 always 2
Line 170
  ( possible 0
  [ possible 95
  pos1 always !<=-1
  || always {!<=-1,!>=2}
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  '_' always 95
  && always {!<=-1,!>=2}
Line 171
  ( always !<=-1
  "<" always "<"
  pos1 always !<=-1
  < always {!<=-1,!>=2}
  pos2 always !<=-1
  && always {!<=-1,!>=2}
Line 172
  ( always !<=-1
  "<<" always "<<"
  pos1 always !<=-1
  != always {!<=-1,!>=2}
  ( always !<=-1
  "<" always "<"
  pos1 always !<=-1
  && always {!<=-1,!>=2}
Line 173
  ( always !<=-1
  ">" always ">"
  pos1 always !<=-1
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 174
  ( always !<=-1
  ">" always ">"
  pos1 always !<=-1
  > always {!<=-1,!>=2}
  pos2 always !<=-1
Line 175
  = always 0
  0 always 0
Line 176
  pos2 always !<=-1
  = always !<=-1
  pos1 always !<=-1
  pos2 always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  pos2 always !<=-1
Line 177
  [ possible 62
  pos2 {!<=-1,<=symbolic=(line.size()-1),!>=symbolic=(line.size())}
  == {!<=-1,!>=2,0}
  '<' always 60
Line 179
  [ always !60
  pos2 always {!<=-1,!>=symbolic=(line.size())}
  == always {!<=-1,!>=2}
  '>' always 62
Line 180
  <= always {!<=-1,!>=2}
  1 always 1
Line 182
  -- {!<=0,>=1}
  level {!<=1,>=2}
Line 185
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  pos2 always !<=-1
  + always !<=0
  1 always 1
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 186
  { always {size=0,{}
Line 187
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  pos2 {!<=-1,<=symbolic=(line.size()-2)}
Line 188
  pos2 always !<=-1
  != always {!<=-1,!>=2}
Line 189
  -- always !<=-1
  pos2 always !<=-1
Line 192
  pos2 always !<=-1
  == always {!<=-1,!>=2}
Line 193
  pos1 always !<=-1
Line 196
  pos1 always !<=-1
  pos2 always !<=-1
  + always !<=0
  1 always 1
  - always !<=-1
  pos1 always !<=-1
Line 197
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  pos2 always !<=-1
  + always !<=0
  1 always 1
Line 206
  nullptr always 0
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 207
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 208
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 209
  , possible lifetime[SubObject]=(enumerator)
  ( possible lifetime[SubObject]=(enumerator)
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 212
  enumerator always !0
Line 214
  function always !0
Line 216
  var always !0
Line 217
  var always !0
Line 227
  = always 0
  nullptr always 0
Line 228
  = always 0
  nullptr always 0
Line 230
  = always 0
  0 always 0
Line 233
  enumerator possible lifetime[Object]=(scope->enumeratorList)@32
Line 235
  enumerator possible lifetime[Object]=(scope->enumeratorList)@32
Line 240
  function possible lifetime[Object]=(nestedIn->functionList)@104
Line 242
  function possible lifetime[Object]=(nestedIn->functionList)@104
Line 248
  addr possible symbolic=(mExtTokens[0])@79
Line 252
  var possible {lifetime[Object]=(scope->varlist)@60,lifetime[Object]=(function->argumentList)@115}
Line 253
  addr possible symbolic=(child->mExtTokens[0])@115
Line 255
  var {lifetime[Object]=(scope->varlist)@60,lifetime[Object]=(function->argumentList)@115}
Line 257
  var possible lifetime[Object]=(scope->varlist)@60
  ( always !0
Line 258
  addr inconclusive symbolic=(child->mExtTokens[0])@115
Line 264
  decl always {symbolic=(it.second),symbolic=(decl)}
  == always {!<=-1,!>=2}
  from possible symbolic=(vartok->variable())@165
Line 265
  decl always {symbolic=(it.second),symbolic=(decl)}
Line 270
  = possible lifetime[Iterator]=(mDeclMap)
  ( possible lifetime[Iterator]=(mDeclMap)
  addr possible symbolic=(child->mExtTokens[0])@116
Line 271
  it {lifetime[Iterator]=(mDeclMap),symbolic=(mDeclMap.find(addr))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mDeclMap),end=0}
Line 272
  it {lifetime[Iterator]=(mDeclMap),symbolic=(mDeclMap.find(addr)),!symbolic=(mDeclMap.end()),!end=0}
Line 274
  [ possible lifetime[Object]=(tok)
Line 279
  ret always size=0
  1 always 1
  nullptr always 0
Line 282
  = always !0
  . always !0
Line 287
  ( always {!<=-1,!>=2}
Line 288
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mDeclMap)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mDeclMap),end=0}
Line 292
  = possible lifetime[Iterator]=(mDeclMap)
  ( possible lifetime[Iterator]=(mDeclMap)
Line 293
  it {lifetime[Iterator]=(mDeclMap),symbolic=(mDeclMap.find(addr))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mDeclMap),end=0}
  nullptr always 0
  : always 0
  it {lifetime[Iterator]=(mDeclMap),symbolic=(mDeclMap.find(addr)),!symbolic=(mDeclMap.end()),!end=0}
Line 302
  = possible lifetime[Iterator]=(mNotFound)
  ( possible lifetime[Iterator]=(mNotFound)
  addr inconclusive symbolic=(child->mExtTokens[0])@29672
Line 303
  it {lifetime[Iterator]=(mNotFound),symbolic=(mNotFound.find(addr))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mNotFound),end=0}
Line 304
  it {lifetime[Iterator]=(mNotFound),symbolic=(mNotFound.find(addr)),!symbolic=(mNotFound.end()),!end=0}
Line 306
  it {lifetime[Iterator]=(mNotFound),!end=0}
Line 312
  = always 0
  0 always 0
Line 328
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 331
  ! always {!<=-1,!>=2}
Line 332
  0 always 0
  1 always 1
  1 always 1
Line 334
  1 always 1
Line 336
  nodeType possible {symbolic=(RecordDecl),symbolic=(TypedefDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  nodeType always !symbolic=(VarDecl)
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  nodeType always {!symbolic=(VarDecl),!symbolic=(RecordDecl)}
  == always {!<=-1,!>=2}
Line 337
  ";" always ";"
Line 342
  c possible {0@64,1@131,6@216,5@218}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 344
  "ClangImport: AstNodePtr::getChild(" always "ClangImport: AstNodePtr::getChild("
  c {>=symbolic=(children.size()),!<=symbolic=(children.size()-1)}
  ") out of bounds. children.size=" always ") out of bounds. children.size="
  children possible <=size=6@216
  ( {!<=-1,<=6@216}
  " " always " "
Line 346
  " " always " "
Line 347
  nullptr always 0
Line 349
  children possible >=size=1@64
  c {!>=symbolic=(children.size()),<=symbolic=(children.size()-1),0@64,1@131,6@216,5@218}
Line 353
  , always 1
  = always 1
  true always 1
Line 354
  , always 0
  = always 0
  nullptr always 0
Line 363
  = always 0
  0 always 0
Line 364
  = always 0
  0 always 0
Line 365
  ( always {!<=-1,!>=2}
Line 370
  = always 0
  0 always 0
Line 371
  = always 1
  1 always 1
Line 372
  = always 1
  1 always 1
Line 380
  nodeType possible {symbolic=(UnaryExprOrTypeTraitExpr),symbolic=(FunctionDecl),symbolic=(CXXConstructorDecl),symbolic=(CXXMethodDecl),symbolic=(DeclRefExpr),symbolic=(RecordDecl)}
  == always {!<=-1,!>=2}
Line 381
  = always 1
  1 always 1
Line 382
  typeIndex possible 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size()),1}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 383
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  ++ {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
Line 385
  typeIndex possible >=symbolic=(mExtTokens.size())
  1 always 1
Line 386
  nameIndex possible symbolic=(typeIndex+1)
  < always {!<=-1,!>=2}
  ( {!<=-1,<=symbolic=(typeIndex)}
  && always {!<=-1,!>=2}
  nameIndex {symbolic=(typeIndex+1),<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 387
  nameIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  ++ {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
Line 388
  nameIndex possible >=symbolic=(mExtTokens.size())
  < {!<=-1,!>=2,0}
  ( {!<=-1,<=symbolic=(nameIndex)}
  nameIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  : always ""
  "" always ""
Line 391
  nodeType {symbolic=(FunctionDecl),symbolic=(CXXConstructorDecl),symbolic=(CXXMethodDecl),symbolic=(DeclRefExpr),symbolic=(RecordDecl),!symbolic=(CompoundAssignOperator)}
  == always {!<=-1,!>=2}
Line 392
  = always 1
  1 always 1
Line 393
  typeIndex possible 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size()),1}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 394
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  ++ {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
Line 395
  typeIndex possible >=symbolic=(mExtTokens.size())
  1 always 1
Line 396
  nameIndex always symbolic=(typeIndex+1)
  < always {!<=-1,!>=2}
  ( {!<=-1,<=symbolic=(typeIndex)}
  nameIndex {symbolic=(typeIndex+1),<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  : always ""
  "" always ""
Line 399
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 400
  nodeType {symbolic=(CXXConstructorDecl),symbolic=(CXXMethodDecl),symbolic=(DeclRefExpr),symbolic=(RecordDecl),!symbolic=(CompoundAssignOperator),!symbolic=(UnaryExprOrTypeTraitExpr)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  nodeType always {!symbolic=(CompoundAssignOperator),!symbolic=(UnaryExprOrTypeTraitExpr),!symbolic=(FunctionDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  nodeType always {!symbolic=(CompoundAssignOperator),!symbolic=(UnaryExprOrTypeTraitExpr),!symbolic=(FunctionDecl),!symbolic=(CXXConstructorDecl)}
  == always {!<=-1,!>=2}
Line 401
  typeIndex possible {<=0,>=1}
  >= {!<=-1,!>=2,<=1}
  0 always 0
  && always {!<=-1,!>=2}
  typeIndex {<=0,>=1,!<=-1}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 402
  typeIndex {>=0,!<=-1}
  -- {>=0,!<=-1}
Line 403
  typeIndex possible <=-1
  <= {!<=-1,!>=2,<=1}
  0 always 0
Line 404
  "" always ""
Line 406
  nodeType {symbolic=(RecordDecl),!symbolic=(CompoundAssignOperator),!symbolic=(UnaryExprOrTypeTraitExpr),symbolic=(FunctionDecl),symbolic=(CXXConstructorDecl),symbolic=(CXXMethodDecl)}
  == always {!<=-1,!>=2}
Line 407
  typeIndex possible {<=0,>=1}
  > {!<=-1,!>=2,<=0,>=1}
  0 always 0
  && always {!<=-1,!>=2}
  typeIndex {>=1,!<=0}
  0 always 0
Line 408
  typeIndex {>=1,!<=0}
  -- {>=1,!<=0}
Line 409
  typeIndex possible <=0
  <= {!<=-1,!>=2,<=1}
  0 always 0
Line 410
  "" always ""
Line 412
  typeIndex possible >=1
  - {>=0,!<=-1}
  1 always 1
Line 413
  str always symbolic=(mExtTokens[typeIndex-1])
  0 always 0
  4 always 4
  "col:" always "col:"
  == always {!<=-1,!>=2}
  0 always 0
Line 414
  "" always ""
Line 415
  str {symbolic=(mExtTokens[typeIndex-1]),size=6}
  0 always 0
  8 always 8
  "<invalid" always "<invalid"
  == always {!<=-1,!>=2}
  0 always 0
Line 416
  "" always ""
Line 417
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "struct" always "struct"
Line 418
  "" always ""
Line 424
  index possible {0@176,<=1@176}
Line 425
  ( always !<=-1
  " (" always " ("
  != always {!<=-1,!>=2}
Line 426
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  " (" always " ("
Line 427
  pos always !<=-1
  = always 39
  '\'' always 39
Line 428
  pos always !<=-1
  + always !<=0
  1 always 1
Line 430
  ( always !<=-1
  " *(" always " *("
  != always {!<=-1,!>=2}
Line 431
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always !<=1
  ( always !<=-1
  " *(" always " *("
  + always !<=1
  2 always 2
Line 432
  pos always !<=1
  = always 39
  '\'' always 39
Line 433
  pos always !<=1
  + always !<=2
  1 always 1
Line 435
  ( always !<=-1
  " &(" always " &("
  != always {!<=-1,!>=2}
Line 436
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always !<=1
  ( always !<=-1
  " &(" always " &("
  + always !<=1
  2 always 2
Line 437
  pos always !<=1
  = always 39
  '\'' always 39
Line 438
  pos always !<=1
  + always !<=2
  1 always 1
Line 445
  = always 1
  1 always 1
Line 446
  typeIndex possible {>=symbolic=(mExtTokens.size()),<=symbolic=(mExtTokens.size()-1),1}
  < always {!<=-1,!>=2}
  ( {!<=-1,<=symbolic=(typeIndex),>=symbolic=(typeIndex+1)}
  && always {!<=-1,!>=2}
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size()),1}
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 447
  typeIndex {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
  ++ {<=symbolic=(mExtTokens.size()-1),!>=symbolic=(mExtTokens.size())}
Line 448
  typeIndex possible >=symbolic=(mExtTokens.size())
  >= {!<=-1,!>=2,1}
  ( {!<=-1,<=symbolic=(typeIndex)}
Line 449
  "" always ""
Line 450
  typeIndex {!>=symbolic=(mExtTokens.size()),<=symbolic=(mExtTokens.size()-1)}
Line 451
  type always symbolic=(mExtTokens[typeIndex])
  ( always !<=-1
  "\':\'" always "\':\'"
  != always {!<=-1,!>=2}
Line 452
  == always {!<=-1,!>=2}
  0 always 0
Line 453
  type always symbolic=(mExtTokens[typeIndex])
  ( always !<=-1
  "\':\'" always "\':\'"
  + always !<=0
  1 always 1
Line 455
  type always symbolic=(mExtTokens[typeIndex])
  0 always 0
  ( always !<=-1
  "\':\'" always "\':\'"
  + always !<=1
  2 always 2
Line 457
  type possible symbolic=(mExtTokens[typeIndex])
Line 460
  ( always {!<=-1,!>=2}
Line 462
  return always {!<=-1,!>=2}
  "definition" always "definition"
Line 467
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  children always !size=0
  0 always 0
  != always {!<=-1,!>=2}
Line 468
  "" always ""
Line 470
  children always !size=0
Line 471
  == always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  = always "<"
  "<" always "<"
Line 475
  templateParameters always !size=0
  "," always ","
Line 479
  ">" always ">"
Line 485
  ' ' always 32
Line 487
  " " always " "
Line 489
  = always 0
  0 always 0
  c possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 490
  c {<=symbolic=(children.size()-1),!>=symbolic=(children.size())}
Line 491
  2 always 2
Line 493
  2 always 2
  ' ' always 32
  "<<<<NULL>>>>>" always "<<<<NULL>>>>>"
Line 500
  0 always 0
  5 always 5
  "<col:" always "<col:"
  == always {!<=-1,!>=2}
  0 always 0
Line 501
  5 always 5
  ( {lifetime[Object]=(ext.substr(5)),!0}
Line 502
  0 always 0
  6 always 6
  "<line:" always "<line:"
  == always {!<=-1,!>=2}
  0 always 0
Line 503
  6 always 6
  ( {lifetime[Object]=(ext.substr(6)),!0}
Line 504
  ( always !<=-1
  ", col:" always ", col:"
  != always {!<=-1,!>=2}
Line 505
  ( {lifetime[Object]=(ext),!0}
  + possible lifetime[Object]=(ext)
  ( always !<=-1
  ", col:" always ", col:"
  + possible lifetime[Object]=(ext)
  6 always 6
Line 506
  0 always 0
  == always {!<=-1,!>=2}
  '<' always 60
  && always {!<=-1,!>=2}
  ( always !<=-1
  ":" always ":"
  != always {!<=-1,!>=2}
Line 507
  :: always !<=-1
  sep1 always !<=-1
  sep1 always !<=-1
  = always !<=-1
  ( always !<=-1
  ":" always ":"
Line 508
  :: always !<=-1
  sep2 always !<=-1
  sep2 always !<=-1
  = always !<=-1
  ( always !<=-1
  ":" always ":"
  sep1 always !<=-1
  + always !<=0
  1 always 1
Line 509
  1 always 1
  sep1 always !<=-1
  - always !<=-1
  1 always 1
Line 510
  sep1 always !<=-1
  + always !<=0
  1 always 1
  sep2 always !<=-1
  - always !<=-1
  sep1 always !<=-1
Line 518
  child always !0
Line 522
  , always {!<=-1,!>=2}
  valueType always {!<=-1,!>=2}
Line 525
  str possible {"static"@49,"="@61,"("@63,")"@66,"struct"@71,"class"@71,":"@74,","@74,";"@83,"static"@87}
Line 527
  valueType {!<=-1,!>=2,0@197}
Line 534
  str possible symbolic=(mExtTokens[typeIndex])@51
  ( always !<=-1
  "\':\'" always "\':\'"
  != always {!<=-1,!>=2}
Line 535
  tokenList possible lifetime[Address]=(decl)@177
  0 always 0
  ( always !<=-1
  "\':\'" always "\':\'"
  + always !<=0
  1 always 1
Line 538
  str possible symbolic=(mExtTokens[typeIndex])@51
  0 always 0
  16 always 16
  "'enum (anonymous" always "'enum (anonymous"
  == always {!<=-1,!>=2}
  0 always 0
Line 539
  nullptr always 0
Line 542
  ( always !<=-1
  " (" always " ("
  != always {!<=-1,!>=2}
Line 543
  ( always !<=-1
  "<" always "<"
  != always {!<=-1,!>=2}
Line 544
  1 always 1
  ( always !<=-1
  "<" always "<"
  "...>" always "...>"
Line 546
  1 always 1
  ( always !<=-1
  " (" always " ("
  - always !<=-1
  1 always 1
Line 550
  type possible symbolic=(unquote(str))
  ( always !<=-1
  "(*)(" always "(*)("
  != always {!<=-1,!>=2}
Line 551
  ( always !<=-1
  "(*)(" always "(*)("
Line 552
  "*" always "*"
Line 554
  ( always !<=-1
  "(" always "("
  != always {!<=-1,!>=2}
Line 555
  ( always !<=-1
  "(" always "("
Line 559
  false always 0
Line 560
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 562
  == always {!<=-1,!>=2}
  ")" always ")"
Line 569
  ! always {!<=-1,!>=2}
Line 570
  ( always !0
  : always 0
  nullptr always 0
Line 571
  ! always {!<=-1,!>=2}
  scope always symbolic=(tokenList->back()?tokenList->back()->scope():nullptr)
Line 572
  nullptr always 0
Line 574
  ( always {!<=-1,!>=2}
  "&|*|%name%" always "&|*|%name%"
Line 575
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 579
  recordType always !0
Line 580
  recordType always !0
Line 583
  nullptr always 0
Line 588
  ! always {!<=-1,!>=2}
Line 591
  && always {!<=-1,!>=2}
  recordScope always !0
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  recordScope always {!symbolic=(tokenList->back()->scope()),!0}
  ( always {!<=-1,!>=2}
Line 592
  scopes possible lifetime[Object]=(recordScope)
  recordScope always {!symbolic=(tokenList->back()->scope()),!0}
Line 595
  scopes possible lifetime[Object]=(recordScope)
Line 596
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 597
  . always !size=0
Line 598
  "::" always "::"
Line 605
  ! always {!<=-1,!>=2}
Line 606
  & {lifetime[Object]=(mData->mSymbolDatabase->scopeList),!0}
Line 607
  ( always !0
  == always {!<=-1,!>=2}
  "}" always "}"
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mData->mNotScope)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mData->mNotScope),end=0}
Line 614
  = always 0
  0 always 0
  i possible 0
  < {!<=-1,!>=2,1}
  2 always 2
Line 615
  i {0,<=1,!>=2,!<=-1}
Line 617
  ( always !<=-1
  "<" always "<"
  != always {!<=-1,!>=2}
Line 621
  nullptr always 0
Line 622
  & {lifetime[Address]=(decl),!0}
Line 623
  ! always {!<=-1,!>=2}
Line 626
  ( always !0
Line 627
  != always {!<=-1,!>=2}
  :: always 0
  UNKNOWN_TYPE always 0
Line 637
  scopeType possible {8@228,10@18,11@132}
  children2 always {{,size=1}
Line 646
  nullptr always 0
  nullptr always 0
Line 647
  = {lifetime[Object]=(symbolDatabase->scopeList),!0}
  & {lifetime[Object]=(symbolDatabase->scopeList),!0}
Line 648
  scopeType possible {16,4@101,2@116,8@58543,10@4783,11@33967}
  == {!<=-1,!>=2,1}
  :: always 16
  eEnum always 16
Line 649
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
  ( always !<=-1
Line 650
  . possible lifetime[Object]=(symbolDatabase->scopeList)
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
Line 651
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  = possible {16,4@101,2@116,8@58543,10@4783,11@33967}
  scopeType possible {16,4@101,2@116,8@58543,10@4783,11@33967}
Line 652
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 653
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 654
  ( always {!<=-1,!>=2}
  "if|for|while (" always "if|for|while ("
Line 656
  2 always 2
  vartok possible symbolic=(vartok->variable()->nameToken())
Line 657
  ! always {!<=-1,!>=2}
  vartok possible symbolic=(vartok->variable()->nameToken())
Line 659
  ( always !0
  == always {!<=-1,!>=2}
Line 660
  = always !0
  vartok always symbolic=(vartok->variable()->nameToken())
  ( always !0
Line 661
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
  from {symbolic=(vartok->variable()),!0}
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
Line 662
  = {lifetime[Object]=(symbolDatabase->scopeList),!0}
  & {lifetime[Object]=(symbolDatabase->scopeList),!0}
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
Line 663
  from {symbolic=(vartok->variable()),!0}
  = {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&scope->varlist.back()),!0}
  to {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&scope->varlist.back()),!0}
Line 664
  from {symbolic=(vartok->variable()),!0}
  to {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&scope->varlist.back()),symbolic=(replaceVar[from]),!0}
Line 666
  ( possible lifetime[Iterator]=(replaceVar)
  vartok possible symbolic=(vartok->variable()->nameToken())
  ( always !0
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(replaceVar),end=0}
Line 670
  = {lifetime[Iterator]=(const_cast<Scope*>(def->scope())->varlist),start=0}
  ( {lifetime[Iterator]=(const_cast<Scope*>(def->scope())->varlist),start=0}
  var possible {lifetime[Iterator]=(const_cast<Scope*>(def->scope())->varlist),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(const_cast<Scope*>(def->scope())->varlist),end=0}
Line 671
  ( possible lifetime[Iterator]=(replaceVar)
  & {lifetime[Address]=(const_cast<Scope*>(def->scope())->varlist),!0}
  var possible lifetime[Iterator]=(const_cast<Scope*>(def->scope())->varlist)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(replaceVar),end=0}
Line 677
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  "{" always "{"
Line 678
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 679
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 680
  ! {!<=-1,!>=2,0}
  children2 possible size=0
  ( {!<=-1,!>=2,1}
Line 681
  children2 always !size=0
Line 682
  . possible symbolic=(AccessSpecDecl)
  == always {!<=-1,!>=2}
  "VisibilityAttr" always "VisibilityAttr"
Line 684
  == always {!<=-1,!>=2}
Line 685
  "private" always "private"
Line 686
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
  = always 2
  :: always 2
  Private always 2
Line 687
  "protected" always "protected"
Line 688
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
  = always 1
  :: always 1
  Protected always 1
Line 689
  "public" always "public"
Line 690
  scope inconclusive lifetime[Object]=(symbolDatabase->scopeList)
  = always 0
  :: always 0
  Public always 0
Line 694
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 695
  "," always ","
Line 696
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 697
  ";" always ";"
Line 700
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  "}" always "}"
Line 701
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 702
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 703
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 708
  == always {!<=-1,!>=2}
Line 709
  0 always 0
Line 710
  "[" always "["
Line 711
  [ possible lifetime[Lambda]=(getChild(0))
  1 always 1
Line 712
  "]" always "]"
Line 719
  == always {!<=-1,!>=2}
Line 720
  0 always 0
Line 722
  [ possible lifetime[Lambda]=(addtoken(tokenList,"break"))
  1 always 1
Line 727
  == always {!<=-1,!>=2}
Line 728
  "break" always "break"
Line 729
  == always {!<=-1,!>=2}
Line 731
  == always {!<=-1,!>=2}
  0 always 0
Line 732
  "\'\\0\'" always "\'\\0\'"
Line 733
  == always {!<=-1,!>=2}
  '\r' always 13
Line 734
  "\'\\r\'" always "\'\\r\'"
Line 735
  == always {!<=-1,!>=2}
  '\n' always 10
Line 736
  "\'\\n\'" always "\'\\n\'"
Line 737
  == always {!<=-1,!>=2}
  '\t' always 9
Line 738
  "\'\\t\'" always "\'\\t\'"
Line 739
  == always {!<=-1,!>=2}
  '\\' always 92
Line 740
  "\'\\\\\'" always "\'\\\\\'"
Line 741
  < always {!<=-1,!>=2}
  ' ' always 32
  || always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  0x80 always 128
Line 743
  4 always 4
  0xf always 15
  0xf always 15
Line 744
  "\'\\x" always "\'\\x"
  "\'" always "\'"
Line 746
  "\'" always "\'"
  "\'" always "\'"
Line 748
  == always {!<=-1,!>=2}
Line 750
  == always {!<=-1,!>=2}
Line 751
  "case" always "case"
Line 752
  0 always 0
Line 754
  ":" always ":"
Line 756
  nullptr always 0
Line 758
  == always {!<=-1,!>=2}
Line 760
  == always {!<=-1,!>=2}
Line 763
  nullptr always 0
Line 765
  == always {!<=-1,!>=2}
Line 767
  nullptr always 0
Line 769
  == always {!<=-1,!>=2}
Line 770
  0 always 0
Line 771
  "?" always "?"
Line 772
  [ possible lifetime[Lambda]=(getChild(0))
  1 always 1
Line 773
  ":" always ":"
Line 774
  [ possible lifetime[Lambda]=(getChild(0))
  2 always 2
Line 781
  == always {!<=-1,!>=2}
Line 782
  0 always 0
Line 784
  [ possible lifetime[Lambda]=(for(const AstNodePtr&child:children))
  1 always 1
Line 789
  == always {!<=-1,!>=2}
Line 792
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
Line 793
  ";" always ";"
Line 795
  nullptr always 0
Line 797
  == always {!<=-1,!>=2}
Line 799
  == always {!<=-1,!>=2}
Line 800
  "continue" always "continue"
Line 801
  == always {!<=-1,!>=2}
Line 802
  "(" always "("
Line 803
  '\'' always 39
  '\'' always 39
Line 804
  ")" always ")"
Line 807
  0 always 0
Line 810
  == always {!<=-1,!>=2}
Line 811
  0 always 0
Line 812
  == always {!<=-1,!>=2}
Line 814
  :: always 0
  UNKNOWN_SIGN always 0
  :: always 8
  BOOL always 8
  0 always 0
Line 817
  == always {!<=-1,!>=2}
Line 818
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 819
  0 always 0
Line 820
  '\'' always 39
  '\'' always 39
Line 822
  "(" always "("
Line 823
  ")" always ")"
Line 829
  == always {!<=-1,!>=2}
Line 831
  nullptr always 0
Line 833
  == always {!<=-1,!>=2}
Line 834
  "delete" always "delete"
Line 835
  0 always 0
Line 836
  nullptr always 0
Line 838
  == always {!<=-1,!>=2}
Line 840
  nullptr always 0
Line 842
  == always {!<=-1,!>=2}
Line 843
  "for" always "for"
Line 844
  "(" always "("
Line 846
  [ possible lifetime[Lambda]=(getChild(6))
  6 always 6
  == always {!<=-1,!>=2}
Line 847
  6 always 6
  0 always 0
Line 849
  5 always 5
  0 always 0
Line 853
  ":" always ":"
Line 855
  = always 0
  0 always 0
  < always {!<=-1,!>=2}
  2 always 2
Line 856
  i {>=0,!<=-1,<=1,!>=2}
  && always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(children)
  i {>=0,!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  [ possible lifetime[Lambda]=(children)
  i {>=0,!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
Line 857
  i always {!<=-1,!>=2}
  0 always 0
  0 always 0
Line 861
  ! always {!<=-1,!>=2}
Line 862
  "Failed to import CXXForRangeStmt. Range?" always "Failed to import CXXForRangeStmt. Range?"
Line 864
  ")" always ")"
Line 874
  :: always 8
  eFor always 8
Line 875
  nullptr always 0
Line 877
  == always {!<=-1,!>=2}
Line 878
  = always 0
  0 always 0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 879
  == always {!<=-1,!>=2}
  "prev" always "prev"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 880
  nullptr always 0
Line 883
  nullptr always 0
Line 885
  == always {!<=-1,!>=2}
Line 887
  == always {!<=-1,!>=2}
Line 888
  "new" always "new"
Line 889
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
Line 890
  0 always 0
Line 894
  ( always !<=-1
  "*" always "*"
  != always {!<=-1,!>=2}
Line 895
  ( always !<=-1
  "*" always "*"
Line 897
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 898
  "[" always "["
Line 899
  0 always 0
Line 900
  "]" always "]"
Line 906
  == always {!<=-1,!>=2}
Line 907
  "nullptr" always "nullptr"
Line 908
  == always {!<=-1,!>=2}
Line 910
  == always {!<=-1,!>=2}
Line 912
  nullptr always 0
Line 914
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 916
  "(" always "("
Line 917
  0 always 0
Line 918
  ")" always ")"
Line 926
  == always {!<=-1,!>=2}
Line 927
  0 always 0
Line 928
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 929
  0 always 0
Line 930
  == always {!<=-1,!>=2}
Line 931
  "this" always "this"
Line 932
  == always {!<=-1,!>=2}
Line 933
  "throw" always "throw"
Line 934
  0 always 0
Line 937
  == always {!<=-1,!>=2}
Line 938
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 939
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  0 always 0
  2 always 2
  "0x" always "0x"
  != always {!<=-1,!>=2}
  0 always 0
Line 943
  ( always {!<=-1,!>=2}
  "<NoName>" always "<NoName>"
  : always "<NoName>"
Line 947
  == always {!<=-1,!>=2}
Line 948
  0 always 0
Line 949
  == always {!<=-1,!>=2}
Line 950
  "default" always "default"
Line 951
  ":" always ":"
Line 953
  nullptr always 0
Line 955
  == always {!<=-1,!>=2}
Line 956
  "do" always "do"
Line 957
  :: always 10
  eDo always 10
  0 always 0
Line 958
  "while" always "while"
Line 959
  "(" always "("
Line 960
  [ possible lifetime[Lambda]=(addtoken(tokenList,getSpelling()))
  1 always 1
Line 961
  ")" always ")"
Line 966
  nullptr always 0
Line 968
  == always {!<=-1,!>=2}
Line 971
  scope always symbolic=(const_cast<Scope*>(nameToken->scope()))
Line 972
  = {lifetime[Object]=(scope->enumeratorList),!0}
  & {lifetime[Object]=(scope->enumeratorList),!0}
  scope always symbolic=(const_cast<Scope*>(nameToken->scope()))
Line 973
  e {lifetime[Object]=(scope->enumeratorList),symbolic=(&scope->enumeratorList.back())}
Line 974
  e {lifetime[Object]=(scope->enumeratorList),symbolic=(&scope->enumeratorList.back())}
Line 975
  e {lifetime[Object]=(scope->enumeratorList),symbolic=(&scope->enumeratorList.back())}
  . always {!<=-1,!>=2}
  value_known always {!<=-1,!>=2}
  = always 1
  true always 1
Line 976
  e possible lifetime[Object]=(scope->enumeratorList)
Line 979
  == always {!<=-1,!>=2}
Line 980
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 981
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  0 always 0
  4 always 4
  "col:" always "col:"
  != always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  0 always 0
  5 always 5
  "line:" always "line:"
  != always {!<=-1,!>=2}
  0 always 0
Line 983
  == always {!<=-1,!>=2}
  0 always 0
Line 984
  nullptr always 0
Line 986
  = always 0
  0 always 0
Line 987
  "enum" always "enum"
Line 988
  = always 0
  nullptr always 0
Line 990
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 991
  > always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
Line 993
  > always {!<=-1,!>=2}
Line 995
  0 always 0
  == always {!<=-1,!>=2}
  '\'' always 39
Line 996
  ":" always ":"
Line 1000
  :: always 16
  eEnum always 16
Line 1003
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ", }" always ", }"
Line 1008
  = {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
  & {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
Line 1010
  = possible lifetime[Object]=(mData->mSymbolDatabase->typeList)
  . possible lifetime[Object]=(mData->mSymbolDatabase->typeList)
Line 1012
  nullptr always 0
Line 1014
  == always {!<=-1,!>=2}
Line 1015
  0 always 0
Line 1016
  == always {!<=-1,!>=2}
Line 1018
  == always {!<=-1,!>=2}
Line 1020
  == always {!<=-1,!>=2}
Line 1021
  "for" always "for"
Line 1022
  "(" always "("
Line 1023
  0 always 0
  [ possible lifetime[Lambda]=(createTokensFunctionDecl(tokenList))
  0 always 0
  : always 0
  nullptr always 0
Line 1024
  ";" always ";"
Line 1025
  = possible 0
  2 always 2
  ? possible 0
  [ possible lifetime[Lambda]=(createTokensFunctionDecl(tokenList))
  2 always 2
  : always 0
  nullptr always 0
Line 1026
  ";" always ";"
Line 1027
  = possible 0
  3 always 3
  ? possible 0
  [ possible lifetime[Lambda]=(createTokensFunctionDecl(tokenList))
  3 always 3
  : always 0
  nullptr always 0
Line 1028
  ")" always ")"
Line 1037
  :: always 8
  eFor always 8
  4 always 4
Line 1038
  nullptr always 0
Line 1040
  == always {!<=-1,!>=2}
Line 1042
  nullptr always 0
Line 1044
  == always {!<=-1,!>=2}
Line 1045
  first always {!<=-1,!>=2}
  first always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1047
  == always {!<=-1,!>=2}
Line 1048
  ! always {!<=-1,!>=2}
  first always {!<=-1,!>=2}
Line 1050
  first always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1053
  nullptr always 0
Line 1055
  == always {!<=-1,!>=2}
Line 1056
  "goto" always "goto"
Line 1057
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1058
  ";" always ";"
Line 1059
  nullptr always 0
Line 1061
  == always {!<=-1,!>=2}
Line 1065
  ( always !<=-1
  == always {!<=-1,!>=2}
  2 always 2
Line 1066
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1067
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 1069
  ( always !<=-1
  - always !<=-1
  3 always 3
Line 1070
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1071
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 1074
  "if" always "if"
Line 1075
  "(" always "("
Line 1078
  ")" always ")"
Line 1081
  :: always 6
  eIf always 6
Line 1083
  "else" always "else"
Line 1084
  :: always 7
  eElse always 7
Line 1086
  nullptr always 0
Line 1088
  == always {!<=-1,!>=2}
Line 1089
  0 always 0
Line 1090
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  "<ArrayToPointerDecay>" always "<ArrayToPointerDecay>"
Line 1094
  == always {!<=-1,!>=2}
Line 1096
  "{" always "{"
Line 1099
  != always {!<=-1,!>=2}
  "{" always "{"
Line 1100
  "," always ","
Line 1103
  "}" always "}"
Line 1110
  == always {!<=-1,!>=2}
Line 1112
  == always {!<=-1,!>=2}
Line 1114
  ":" always ":"
Line 1117
  nullptr always 0
Line 1119
  == always {!<=-1,!>=2}
Line 1120
  nullptr always 0
Line 1121
  == always {!<=-1,!>=2}
Line 1122
  0 always 0
Line 1123
  == always {!<=-1,!>=2}
Line 1124
  0 always 0
Line 1125
  "." always "."
Line 1127
  memberName always symbolic=(getSpelling())
  0 always 0
  2 always 2
  "->" always "->"
  == always {!<=-1,!>=2}
  0 always 0
Line 1128
  "->" always "->"
Line 1129
  memberName always symbolic=(getSpelling())
  2 always 2
Line 1130
  memberName always symbolic=(getSpelling())
  0 always 0
  1 always 1
  "." always "."
  == always {!<=-1,!>=2}
  0 always 0
Line 1131
  memberName always symbolic=(getSpelling())
  1 always 1
Line 1133
  ( always {!<=-1,!>=2}
Line 1134
  = always "<unknown>"
  "<unknown>" always "<unknown>"
Line 1135
  memberName possible {"<unknown>",size=9}
Line 1141
  == always {!<=-1,!>=2}
Line 1142
  ( always {!<=-1,!>=2}
Line 1143
  nullptr always 0
Line 1144
  "namespace" always "namespace"
Line 1145
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1146
  s always {symbolic=(mExtTokens[mExtTokens.size()-2]),symbolic=(s)}
  0 always 0
  4 always 4
  "col:" always "col:"
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  s always {symbolic=(mExtTokens[mExtTokens.size()-2]),symbolic=(s)}
  0 always 0
  5 always 5
  "line:" always "line:"
  == always {!<=-1,!>=2}
  0 always 0
Line 1147
  : always 0
  nullptr always 0
Line 1148
  :: always 4
  eNamespace always 4
Line 1151
  nullptr always 0
Line 1153
  == always {!<=-1,!>=2}
Line 1154
  ";" always ";"
Line 1155
  == always {!<=-1,!>=2}
Line 1156
  "(" always "("
Line 1157
  0 always 0
Line 1158
  ")" always ")"
Line 1163
  == always {!<=-1,!>=2}
Line 1164
  "struct" always "struct"
Line 1166
  ! always {!<=-1,!>=2}
  recordName always {symbolic=(getSpelling()),symbolic=(recordName)}
  ( always {!<=-1,!>=2}
Line 1167
  ( always symbolic=(recordName)
Line 1168
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1169
  ";" always ";"
Line 1170
  nullptr always 0
Line 1173
  :: always 2
  eStruct always 2
Line 1175
  = {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
  & {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
Line 1176
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1178
  = possible lifetime[Object]=(mData->mSymbolDatabase->typeList)
  . possible lifetime[Object]=(mData->mSymbolDatabase->typeList)
Line 1181
  nullptr always 0
Line 1183
  == always {!<=-1,!>=2}
Line 1184
  "return" always "return"
Line 1185
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1186
  0 always 0
Line 1187
  0 always 0
Line 1191
  == always {!<=-1,!>=2}
Line 1193
  == always {!<=-1,!>=2}
Line 1194
  "switch" always "switch"
Line 1195
  "(" always "("
Line 1196
  [ possible lifetime[Lambda]=(addtoken(tokenList,"typedef"))
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1197
  ")" always ")"
Line 1202
  :: always 11
  eSwitch always 11
Line 1203
  nullptr always 0
Line 1205
  == always {!<=-1,!>=2}
Line 1206
  "typedef" always "typedef"
Line 1210
  == always {!<=-1,!>=2}
Line 1211
  ( always !<=-1
  1 always 1
Line 1212
  index possible symbolic=((int)mExtTokens.size()-1)
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  index possible symbolic=((int)mExtTokens.size()-1)
  0 always 0
  != always {!<=-1,!>=2}
  '\'' always 39
Line 1215
  0 always 0
Line 1218
  == always {!<=-1,!>=2}
Line 1220
  "(" always "("
Line 1221
  ( always {!<=-1,!>=2}
Line 1224
  0 always 0
Line 1225
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1226
  0 always 0
Line 1231
  ")" always ")"
Line 1239
  == always {!<=-1,!>=2}
Line 1241
  == always {!<=-1,!>=2}
Line 1242
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1244
  "while" always "while"
Line 1245
  "(" always "("
Line 1248
  ")" always ")"
Line 1251
  :: always 9
  eWhile always 9
Line 1252
  nullptr always 0
Line 1254
  "?" always "?"
  "?" always "?"
Line 1261
  == always {!<=-1,!>=2}
Line 1262
  = always 2
  2 always 2
Line 1263
  1 always 1
Line 1264
  "." always "."
Line 1265
  0 always 0
Line 1270
  = always 1
  1 always 1
Line 1271
  0 always 0
Line 1273
  f possible symbolic=(dot)
  nullptr always 0
Line 1274
  "(" always "("
Line 1275
  f possible symbolic=(dot)
Line 1276
  = always 0
  0 always 0
Line 1277
  args possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  args {<=symbolic=(children.size()-1),!>=symbolic=(children.size()),0}
  != always {!<=-1,!>=2}
Line 1278
  args {<=symbolic=(children.size()-1),!>=symbolic=(children.size())}
  ++ {<=symbolic=(children.size()-1),!>=symbolic=(children.size())}
Line 1279
  = always 0
  nullptr always 0
Line 1280
  < always {!<=-1,!>=2}
  args possible >=symbolic=(children.size())
Line 1282
  "," always ","
Line 1283
  nullptr always 0
Line 1284
  child always !0
Line 1285
  [ possible lifetime[Lambda]=(children)
  c always !>=symbolic=(args)
Line 1288
  [ possible lifetime[Lambda]=(contains(mExtTokens,"prev"))
  c always !>=symbolic=(args)
Line 1291
  child possible 0
Line 1292
  ")" always ")"
Line 1300
  prev always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "prev" always "prev"
Line 1301
  hasBody always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  children always !size=0
  == always {!<=-1,!>=2}
Line 1302
  isStatic always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "static" always "static"
Line 1303
  isInline always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "inline" always "inline"
Line 1305
  = always 0
  nullptr always 0
Line 1308
  nodeType possible symbolic=(CXXDestructorDecl)
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  nodeType always !symbolic=(CXXConstructorDecl)
  != always {!<=-1,!>=2}
Line 1309
  isStatic always {!<=-1,!>=2}
Line 1310
  "static" always "static"
Line 1311
  isInline always {!<=-1,!>=2}
Line 1312
  "inline" always "inline"
Line 1314
  '\'' always 39
  '\'' always 39
Line 1315
  before always !0
Line 1318
  ( always !<=-1
  > always {!<=-1,!>=2}
  4 always 4
  && always {!<=-1,!>=2}
  mExtTokens {>=size=5,!<=size=4}
  1 always 1
  == always {!<=-1,!>=2}
  "parent" always "parent"
Line 1319
  mExtTokens {>=size=5,!<=size=4}
  2 always 2
Line 1324
  prev {!<=-1,!>=2,0}
Line 1325
  ( possible lifetime[Iterator]=(mExtTokens)
  ( {lifetime[Iterator]=(mExtTokens),start=0}
  ( {lifetime[Iterator]=(mExtTokens),end=0}
  "prev" always "prev"
  1 always 1
Line 1328
  ! always {!<=-1,!>=2}
Line 1330
  & {lifetime[Object]=(nestedIn->functionList),!0}
Line 1331
  nodeType possible symbolic=(CXXDestructorDecl)
  == always {!<=-1,!>=2}
Line 1332
  = always 0
  :: always 0
  eConstructor always 0
Line 1333
  nodeType always !symbolic=(CXXConstructorDecl)
  == always {!<=-1,!>=2}
Line 1334
  = always 4
  :: always 4
  eDestructor always 4
Line 1341
  ! {!<=-1,!>=2,1}
  prev {!<=-1,!>=2,0}
Line 1342
  = possible lifetime[Iterator]=(mData->scopeAccessControl)
  ( possible lifetime[Iterator]=(mData->scopeAccessControl)
Line 1343
  accessControl {lifetime[Iterator]=(mData->scopeAccessControl),symbolic=(mData->scopeAccessControl.find(tokenList->back()->scope()))}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mData->scopeAccessControl),end=0}
Line 1344
  function always symbolic=(const_cast<Function*>(nameToken->function()))
  accessControl {lifetime[Iterator]=(mData->scopeAccessControl),!symbolic=(mData->scopeAccessControl.end()),!end=0}
Line 1347
  = always 0
  nullptr always 0
Line 1348
  hasBody {!<=-1,!>=2,0}
Line 1349
  nullptr always 0
  nullptr always 0
Line 1350
  = {lifetime[Object]=(symbolDatabase->scopeList),!0}
  & {lifetime[Object]=(symbolDatabase->scopeList),!0}
Line 1351
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
Line 1352
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
  = always symbolic=(const_cast<Function*>(nameToken->function()))
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1353
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
Line 1354
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
  = always 5
  :: always 5
  eFunction always 5
Line 1355
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
Line 1356
  . possible lifetime[Object]=(symbolDatabase->scopeList)
  scope {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back()),!0}
Line 1357
  function always symbolic=(const_cast<Function*>(nameToken->function()))
  true always 1
Line 1358
  function always symbolic=(const_cast<Function*>(nameToken->function()))
  = inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
  scope inconclusive {lifetime[Object]=(symbolDatabase->scopeList),symbolic=(&symbolDatabase->scopeList.back())}
Line 1361
  "(" always "("
Line 1362
  ! always {!<=-1,!>=2}
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1363
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1364
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1365
  ! always {!<=-1,!>=2}
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1366
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1367
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1369
  = always 0
  0 always 0
  i possible 0
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1370
  i {<=symbolic=(children.size()-1),!>=symbolic=(children.size())}
Line 1371
  child always symbolic=(children[i])
  != always {!<=-1,!>=2}
Line 1373
  != always {!<=-1,!>=2}
Line 1374
  "," always ","
Line 1378
  = always 0
  nullptr always 0
Line 1379
  ! {!<=-1,!>=2,0}
  spelling possible size=0
  ( {!<=-1,!>=2,1}
Line 1380
  spelling always !size=0
Line 1381
  ! always {!<=-1,!>=2}
  prev always {!<=-1,!>=2}
Line 1382
  function always symbolic=(const_cast<Function*>(nameToken->function()))
  vartok possible 0
  nullptr always 0
  :: always 5
  Argument always 5
Line 1384
  0 always 0
Line 1385
  addr always symbolic=(child->mExtTokens[0])
  vartok always !0
  & {lifetime[Object]=(function->argumentList),!0}
  function always symbolic=(const_cast<Function*>(nameToken->function()))
Line 1388
  0 always 0
Line 1389
  addr always symbolic=(child->mExtTokens[0])
  vartok always !0
Line 1392
  ")" always ")"
Line 1396
  function always symbolic=(const_cast<Function*>(nameToken->function()))
  ( always {!<=-1,!>=2}
Line 1397
  "const" always "const"
Line 1400
  hasBody always {!<=-1,!>=2}
Line 1402
  "{" always "{"
Line 1405
  "}" always "}"
Line 1411
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  "default" always "default"
Line 1412
  "=" always "="
Line 1413
  "default" always "default"
Line 1416
  ";" always ";"
Line 1422
  isStruct always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "struct" always "struct"
Line 1423
  isStruct {!<=-1,!>=2,0}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
Line 1425
  ( always !<=-1
  - always !<=-1
  2 always 2
  == always {!<=-1,!>=2}
  isStruct always {!<=-1,!>=2}
  ? possible {"struct","class"}
  "struct" always "struct"
  : always "class"
  "class" always "class"
Line 1428
  = always !symbolic=(isStruct?"struct":"class")
  [ always !symbolic=(isStruct?"struct":"class")
  ( always !<=-1
  - always !<=-1
  2 always 2
Line 1432
  firstBase {!<=-1,!>=2,1}
  firstBase always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1434
  == always {!<=-1,!>=2}
  "public" always "public"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "protected" always "protected"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "private" always "private"
Line 1435
  firstBase always {!<=-1,!>=2}
  ? possible {":",","}
  ":" always ":"
  : always ","
  "," always ","
Line 1438
  firstBase always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1442
  ( always {!<=-1,!>=2}
Line 1445
  . possible {symbolic=(CXXDestructorDecl),symbolic=(CXXMethodDecl),symbolic=(FieldDecl),symbolic=(VarDecl),symbolic=(AccessSpecDecl),symbolic=(TypedefDecl)}
  == {!<=-1,!>=2,1}
  CXXConstructorDecl possible symbolic=(child->nodeType)
  || always {!<=-1,!>=2}
Line 1446
  . always !symbolic=(CXXConstructorDecl)
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1447
  . always {!symbolic=(CXXConstructorDecl),!symbolic=(CXXDestructorDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1448
  . always {!symbolic=(CXXDestructorDecl),!symbolic=(CXXMethodDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1449
  . always {!symbolic=(CXXMethodDecl),!symbolic=(FieldDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1450
  . always {!symbolic=(FieldDecl),!symbolic=(VarDecl)}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 1451
  . always {!symbolic=(VarDecl),!symbolic=(AccessSpecDecl)}
  == always {!<=-1,!>=2}
Line 1454
  isStruct always {!<=-1,!>=2}
  ? possible {2,1}
  :: always 2
  eStruct always 2
  : always 1
  :: always 1
  eClass always 1
Line 1455
  0 always 0
Line 1456
  addr always symbolic=(mExtTokens[0])
Line 1459
  = {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
  & {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
Line 1460
  = {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
  . {lifetime[Object]=(mData->mSymbolDatabase->typeList),!0}
Line 1462
  ";" always ";"
Line 1469
  "static" always "static"
Line 1470
  "static" always "static"
Line 1471
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 1472
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  typeIndex {>=2,!<=1}
  0 always 0
Line 1473
  typeIndex {>=2,!<=1}
  -- {>=2,!<=1}
Line 1474
  typeIndex possible <=1
Line 1475
  typeIndex possible <=1
  - {<=0,!>=1}
  1 always 1
Line 1477
  type always symbolic=(mExtTokens[typeIndex])
Line 1478
  ! always {!<=-1,!>=2}
Line 1480
  startToken always !0
  != always {!<=-1,!>=2}
  "static" always "static"
Line 1481
  startToken always !0
Line 1484
  scope always symbolic=(const_cast<Scope*>(tokenList->back()->scope()))
  0 always 0
  scope always symbolic=(const_cast<Scope*>(tokenList->back()->scope()))
  scope always symbolic=(const_cast<Scope*>(tokenList->back()->scope()))
Line 1485
  & {lifetime[Object]=(scope->varlist),!0}
  scope always symbolic=(const_cast<Scope*>(tokenList->back()->scope()))
Line 1486
  ( possible size=8
  == {!<=-1,!>=2,0}
  "cinit" always "cinit"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1487
  "=" always "="
Line 1491
  ( possible size=8
  == always {!<=-1,!>=2}
  "callinit" always "callinit"
Line 1492
  "(" always "("
Line 1494
  0 always 0
Line 1495
  ")" always ")"
Line 1499
  == always {!<=-1,!>=2}
  "listinit" always "listinit"
Line 1500
  0 always 0
Line 1508
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 1509
  2 always 2
  != always {!<=-1,!>=2}
  ")" always ")"
Line 1523
  ! always {!<=-1,!>=2}
Line 1526
  = always 0
  0 always 0
Line 1528
  = always 1
  1 always 1
Line 1533
  ( always !0
  true always 1
Line 1539
  ( always {!<=-1,!>=2}
  "sizeof (" always "sizeof ("
Line 1540
  2 always 2
Line 1541
  true always 1
Line 1542
  <= always {!<=-1,!>=2}
  0 always 0
Line 1544
  = always 1
  1 always 1
Line 1545
  1 always 1
Line 1547
  a always symbolic=(arrtok->str())
  ( always !<=-1
  > always {!<=-1,!>=2}
  2 always 2
  && always {!<=-1,!>=2}
  a {symbolic=(arrtok->str()),>=size=3,!<=size=2}
  0 always 0
  == always {!<=-1,!>=2}
  '[' always 91
  && always {!<=-1,!>=2}
  a {symbolic=(arrtok->str()),>=size=3,!<=size=2}
  == always {!<=-1,!>=2}
  ']' always 93
Line 1548
  a {symbolic=(arrtok->str()),>=size=3,!<=size=2}
  1 always 1
  ( {lifetime[Object]=(a.substr(1)),!0}
Line 1552
  mul possible 1
  sz always !<=0
Line 1554
  ( always {!<=-1,!>=2}
Line 1561
  = {&,lifetime[Address]=(tokenizer->list),!0}
  & {&,lifetime[Address]=(tokenizer->list),!0}
Line 1565
  symbolDatabase always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 1566
  symbolDatabase always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
  = always 0
  :: always 0
  eGlobal always 0
Line 1567
  symbolDatabase always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
  = always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
  symbolDatabase always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
Line 1571
  = always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
  symbolDatabase always symbolic=(const_cast<SymbolDatabase*>(tokenizer->getSymbolDatabase()))
Line 1574
  line possible size=0
Line 1575
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  "-" always "-"
Line 1576
  pos1 always !<=-1
  == always {!<=-1,!>=2}
Line 1578
  ! {!<=-1,!>=2,1,0}
  tree possible size=0
  ( {!<=-1,!>=2,0,1}
  && always {!<=-1,!>=2}
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  "-<<<NULL>>>" always "-<<<NULL>>>"
Line 1579
  = always !<=-1
  pos1 always !<=-1
  - always !<=-1
  1 always 1
  / always !<=-1
  2 always 2
Line 1580
  tree always !size=0
  level {symbolic=((pos1-1)/2),!<=-1}
  - always !<=-2
  1 always 1
  nullptr always 0
Line 1583
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  " " always " "
  pos1 {!<=-1,1}
Line 1584
  pos2 always !<=-1
  < always {!<=-1,!>=2}
  pos1 {!<=-1,1}
  + {!<=3,5}
  4 always 4
  || always {!<=-1,!>=2}
  pos2 {!<=-1,!<=symbolic=(pos1+4-1),>=symbolic=(pos1+4)}
  == always {!<=-1,!>=2}
Line 1586
  pos1 {!<=-1,!>=symbolic=(pos2-3),<=symbolic=(pos2-4),1}
  + {!<=0,2}
  1 always 1
  pos2 {!<=-1,!<=symbolic=(pos1+4-1),>=symbolic=(pos1+4)}
  - always !<=3
  pos1 {!<=-1,!>=symbolic=(pos2-3),<=symbolic=(pos2-4),1}
  - always !<=2
  1 always 1
Line 1587
  pos2 {!<=-1,!<=symbolic=(pos1+4-1),>=symbolic=(pos1+4)}
Line 1589
  pos1 {!<=-1,!>=symbolic=(pos2-3),<=symbolic=(pos2-4)}
  == always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "Decl" always "Decl"
Line 1590
  ! {!<=-1,!>=2,0}
  tree possible size=0
  ( {!<=-1,!>=2,1}
Line 1591
  tree always !size=0
  0 always 0
Line 1592
  tree {size=0,NonMovedVariable}
Line 1593
  tree always {NonMovedVariable,size=0}
  ( always !0
  & {lifetime[Address]=(data),!0}
Line 1597
  = always !<=-1
  pos1 always {!<=-1,!>=symbolic=(pos2-3)}
  - always !<=-1
  1 always 1
  / always !<=-1
  2 always 2
Line 1598
  level {symbolic=((pos1-1)/2),>=symbolic=(tree.size()),<=symbolic=(tree.size()-1),!<=-1,0}
  == {!<=-1,!>=2,1}
  0 always 0
  || always {!<=-1,!>=2}
  level {symbolic=((pos1-1)/2),!<=0}
  > always {!<=-1,!>=2}
  ( always !<=-1
Line 1601
  = always !0
  ( always !0
  & {lifetime[Address]=(data),!0}
Line 1602
  level {symbolic=((pos1-1)/2),>=symbolic=(tree.size()),<=symbolic=(tree.size()-1),!>=symbolic=(tree.size()+1),!<=0}
  - always !<=-1
  1 always 1
  newNode {symbolic=(std::make_shared<AstNode>(nodeType,ext,&data)),!0}
Line 1603
  level {symbolic=((pos1-1)/2),!>=symbolic=(tree.size()+1),<=symbolic=(tree.size()),!<=0}
  >= always {!<=-1,!>=2}
  ( {!<=-1,!<=symbolic=(level-1),>=symbolic=(level)}
Line 1606
  level {symbolic=((pos1-1)/2),!<=0}
Line 1609
  ! {!<=-1,!>=2,0}
  tree possible size=0
  ( {!<=-1,!>=2,1}
Line 1610
  tree always !size=0
  0 always 0
Line 1614
  ( always {!<=-1,!>=2}
  "(|)|[|]|{|}" always "(|)|[|]|{|}"
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 1615
  "Token::link() is not set properly" always "Token::link() is not set properly"
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
