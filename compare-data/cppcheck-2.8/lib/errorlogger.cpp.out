

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var13 ;
43: std :: string errorId@var14 ;
44: void setFileName ( const std :: string & s@var15 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var19 ;
47: }
48: int lineNumber@var16 ;
49: Certainty :: CertaintyLevel certainty@var17 ;
50: std :: string symbolNames@var18 ;
51: private:
52: std :: string mFileName@var19 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var53 ( NO_LINE ) , hash@var55 ( 0 ) , thisAndNextLine@var56 ( false ) , matched@var57 ( false ) , checked@var58 ( false ) { }
57: Suppression ( const Suppression & other@var20 ) {
58: *@expr1073743669 this@expr1073743670 =@expr1073743671 other@var20 ;
59: }
60: Suppression ( const std :: string & id@var21 , const std :: string & file@var22 , int line@var23 = NO_LINE ) : errorId@var51 ( id@var21 ) , fileName@var52 ( file@var22 ) , lineNumber@var53 ( line@var23 ) , hash@var55 ( 0 ) , thisAndNextLine@var56 ( false ) , matched@var57 ( false ) , checked@var58 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var24 ) {
63: errorId@var51 =@expr1073743672 other@var24 .@expr1073743673 errorId@var25 ;
64: fileName@var52 =@expr1073743674 other@var24 .@expr1073743675 fileName@var26 ;
65: lineNumber@var53 =@expr1073743676 other@var24 .@expr1073743677 lineNumber@var27 ;
66: symbolName@var54 =@expr1073743678 other@var24 .@expr1073743679 symbolName@var28 ;
67: hash@var55 =@expr1073743680 other@var24 .@expr1073743681 hash@var29 ;
68: thisAndNextLine@var56 =@expr1073743682 other@var24 .@expr1073743683 thisAndNextLine@var30 ;
69: matched@var57 =@expr1073743684 other@var24 .@expr1073743685 matched@var31 ;
70: checked@var58 =@expr1073743686 other@var24 .@expr1073743687 checked@var32 ;
71: return *@expr1073743688 this@expr1073743689 ;
72: }
73:
74: bool operator< ( const Suppression & other@var33 ) const {
75: if (@expr1073743690 errorId@var51 !=@expr1073743691 other@var33 .@expr1868 errorId@var34 ) {
76: return errorId@var51 <@expr1073743693 other@var33 .@expr1868 errorId@var34 ; }
77: if (@expr1073743695 lineNumber@var53 <@expr1073743696 other@var33 .@expr1073743697 lineNumber@var35 ) {
78: return true ; }
79: if (@expr1073743698 fileName@var52 !=@expr1073743699 other@var33 .@expr1876 fileName@var36 ) {
80: return fileName@var52 <@expr1073743701 other@var33 .@expr1876 fileName@var36 ; }
81: if (@expr1073743703 symbolName@var54 !=@expr1073743704 other@var33 .@expr1881 symbolName@var37 ) {
82: return symbolName@var54 <@expr1073743706 other@var33 .@expr1881 symbolName@var37 ; }
83: if (@expr1073743708 hash@var55 !=@expr1073743709 other@var33 .@expr1886 hash@var38 ) {
84: return hash@var55 <@expr1073743711 other@var33 .@expr1886 hash@var38 ; }
85: if (@expr1073743713 thisAndNextLine@var56 !=@expr1073743714 other@var33 .@expr1073743715 thisAndNextLine@var39 ) {
86: return thisAndNextLine@var56 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var40 , std :: string * errorMessage@var41 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var42 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var43 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073743717 fileName@var52 .@expr1073743718 empty (@expr1073743719 ) &&@expr1073743720 fileName@var52 .@expr1073743721 find_first_of (@expr1073743722 "?*" ) ==@expr1073743723 std ::@expr1073743724 string ::@expr1073743725 npos@expr1073743716 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var44 ) const {
109: return errorId@var51 ==@expr1073743726 other@var44 .@expr1073743727 errorId@var45 &&@expr1073743728
110: fileName@var52 ==@expr1073743729 other@var44 .@expr1073743730 fileName@var46 &&@expr1073743731
111: lineNumber@var53 ==@expr1073743732 other@var44 .@expr1073743733 lineNumber@var47 &&@expr1073743734
112: symbolName@var54 ==@expr1073743735 other@var44 .@expr1073743736 symbolName@var48 &&@expr1073743737
113: hash@var55 ==@expr1073743738 other@var44 .@expr1073743739 hash@var49 &&@expr1073743740
114: thisAndNextLine@var56 ==@expr1073743741 other@var44 .@expr1073743742 thisAndNextLine@var50 ;
115: }
116:
117: std :: string errorId@var51 ;
118: std :: string fileName@var52 ;
119: int lineNumber@var53 ;
120: std :: string symbolName@var54 ;
121: unsigned long hash@var55 ;
122: bool thisAndNextLine@var56 ;
123: bool matched@var57 ;
124: bool checked@var58 ;
125:
126: enum Anonymous0 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var59 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var60 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var61 , std :: string * errorMessage@var62 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var63 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var64 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var65 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var66 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var67 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var68 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var69 , const bool unusedFunctionChecking@var70 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var71 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var72 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var73 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var74 , const Color & c@var75 ) ;
42:
43: std :: string toString ( const Color & c@var76 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var77 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var78 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var79 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var80 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var81 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var97 ( 0 ) , line@var98 ( 0 ) , column@var99 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var82 , int line@var83 , unsigned int column@var84 )
73: : fileIndex@var97 ( 0 ) , line@var98 ( line@var83 ) , column@var99 ( column@var84 ) , mOrigFileName@var101 ( file@var82 ) , mFileName@var102 ( file@var82 ) { }
74:
75: FileLocation ( const std :: string & file@var85 , const std :: string & info@var86 , int line@var87 , unsigned int column@var88 )
76: : fileIndex@var97 ( 0 ) , line@var98 ( line@var87 ) , column@var99 ( column@var88 ) , mOrigFileName@var101 ( file@var85 ) , mFileName@var102 ( file@var85 ) , mInfo@var103 ( info@var86 ) { }
77:
78: FileLocation ( const Token * tok@var89 , const TokenList * tokenList@var90 ) ;
79: FileLocation ( const Token * tok@var91 , const std :: string & info@var92 , const TokenList * tokenList@var93 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var94 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var95 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var96 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var97 ;
107: int line@var98 ;
108: unsigned int column@var99 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var103 ;
112: }
113: void setinfo ( const std :: string & i@var100 ) {
114: mInfo@var103 =@expr1073743743 i@var100 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var101 ;
119: std :: string mFileName@var102 ;
120: std :: string mInfo@var103 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var104 ,
124: const std :: string & file1@var105 ,
125: Severity :: SeverityType severity@var106 ,
126: const std :: string & msg@var107 ,
127: const std :: string & id@var108 , Certainty :: CertaintyLevel certainty@var109 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var110 ,
129: const std :: string & file1@var111 ,
130: Severity :: SeverityType severity@var112 ,
131: const std :: string & msg@var113 ,
132: const std :: string & id@var114 ,
133: const CWE & cwe@var115 ,
134: Certainty :: CertaintyLevel certainty@var116 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var117 ,
136: const TokenList * list@var118 ,
137: Severity :: SeverityType severity@var119 ,
138: const std :: string & id@var120 ,
139: const std :: string & msg@var121 ,
140: Certainty :: CertaintyLevel certainty@var122 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var123 ,
142: const TokenList * list@var124 ,
143: Severity :: SeverityType severity@var125 ,
144: const std :: string & id@var126 ,
145: const std :: string & msg@var127 ,
146: const CWE & cwe@var128 ,
147: Certainty :: CertaintyLevel certainty@var129 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var130 ,
149: const TokenList * tokenList@var131 ,
150: Severity :: SeverityType severity@var132 ,
151: const char id@var133 [ ] ,
152: const std :: string & msg@var134 ,
153: const CWE & cwe@var135 ,
154: Certainty :: CertaintyLevel certainty@var136 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var137 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var138 ,
176: const std :: string & templateFormat@var139 = emptyString@var1 ,
177: const std :: string & templateLocation@var140 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var141 ) ;
181:
182: std :: list < FileLocation > callStack@var142 ;
183: std :: string id@var143 ;
184:
185:
186: std :: string file0@var144 ;
187:
188: std :: string function@var145 ;
189:
190: bool incomplete@var146 ;
191:
192: Severity :: SeverityType severity@var147 ;
193: CWE cwe@var148 ;
194: Certainty :: CertaintyLevel certainty@var149 ;
195:
196:
197: unsigned long hash@var150 ;
198:
199:
200: void setmsg ( const std :: string & msg@var151 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var153 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var154 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var155 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var152 ) ;
221:
222:
223: std :: string mShortMessage@var153 ;
224:
225:
226: std :: string mVerboseMessage@var154 ;
227:
228:
229: std :: string mSymbolNames@var155 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var156 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073743744 plistFile@var156 .@expr1073743745 is_open (@expr1073743746 ) ) {
243: plistFile@var156 <<@expr1073743747 ErrorLogger ::@expr1073743748 plistFooter (@expr1073743749 ) ;
244: plistFile@var156 .@expr1073743750 close (@expr1073743751 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var157 , Color c@var158 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var159 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var160 , const char stage@var161 [ ] , const unsigned long value@var162 ) {
271: (@expr1073743752 void ) filename@var160 ;
272: (@expr1073743753 void ) stage@var161 ;
273: (@expr1073743754 void ) value@var162 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var163 ) {
281: reportErr (@expr1073743755 msg@var163 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var164 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var165 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var166 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var167 , const std :: vector < std :: string > & files@var168 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var169 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var170 , const std :: string & from@var171 , const std :: string & to@var172 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var173 ) {
44: if (@expr1073743756 bit@var173 >=@expr1073743757 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073743758 (@expr1073743759 1LL <<@expr1073743760 (@expr1073743761 bit@var173 -@expr1073743762 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var174 ) {
50: if (@expr1073743763 bit@var174 >=@expr1073743764 64 ) {
51: return (@expr1941 ~@expr1073743766 0ULL ) >>@expr1073743767 1 ; }
52: return (@expr1941 1LL <<@expr1073743769 (@expr1941 bit@var174 -@expr1073743771 1 ) ) -@expr1073743772 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var175 ) const {
59: return value@var175 >=@expr1073743773 min_value (@expr1073743774 int_bit@var185 ) &&@expr1073743775 value@var175 <=@expr1073743776 max_value (@expr1073743777 int_bit@var185 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var176 ) const {
63: unsigned long long intMax@var177 ; intMax@var177 =@expr1073743778 max_value (@expr1073743779 int_bit@var185 ) ;
64: return value@var176 <=@expr1073743780 intMax@var177 ;
65: }
66:
67: bool isLongValue ( long long value@var178 ) const {
68: return value@var178 >=@expr1073743781 min_value (@expr1073743782 long_bit@var186 ) &&@expr1073743783 value@var178 <=@expr1073743784 max_value (@expr1073743785 long_bit@var186 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var179 ) const {
72: unsigned long long longMax@var180 ; longMax@var180 =@expr1073743786 max_value (@expr1073743787 long_bit@var186 ) ;
73: return value@var179 <=@expr1073743788 longMax@var180 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var181 ) const {
77: unsigned long long longLongMax@var182 ; longLongMax@var182 =@expr1073743789 max_value (@expr1073743790 long_long_bit@var187 ) ;
78: return value@var181 <=@expr1073743791 longLongMax@var182 ;
79: }
80:
81: int char_bit@var183 ;
82: int short_bit@var184 ;
83: int int_bit@var185 ;
84: int long_bit@var186 ;
85: int long_long_bit@var187 ;
86:
87:
88: int sizeof_bool@var188 ;
89: int sizeof_short@var189 ;
90: int sizeof_int@var190 ;
91: int sizeof_long@var191 ;
92: int sizeof_long_long@var192 ;
93: int sizeof_float@var193 ;
94: int sizeof_double@var194 ;
95: int sizeof_long_double@var195 ;
96: int sizeof_wchar_t@var196 ;
97: int sizeof_size_t@var197 ;
98: int sizeof_pointer@var198 ;
99:
100: char defaultSign@var199 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var200 ;
115:
116:
117: bool platform ( PlatformType type@var201 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var202 [ ] , const std :: string & filename@var203 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var204 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var200 ==@expr1073743792 Win32A ||@expr1073743793
136: platformType@var200 ==@expr1073743794 Win32W ||@expr1073743795
137: platformType@var200 ==@expr1073743796 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073743797 platformType@var200 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var205 ) {
145: switch (@expr1073743798 pt@var205 ) {
146: case Unspecified :@expr1975 ;
147: return "Unspecified" ;
148: case Native :@expr1975 ;
149: return "Native" ;
150: case Win32A :@expr1975 ;
151: return "win32A" ;
152: case Win32W :@expr1975 ;
153: return "win32W" ;
154: case Win64 :@expr1975 ;
155: return "win64" ;
156: case Unix32 :@expr1975 ;
157: return "unix32" ;
158: case Unix64 :@expr1975 ;
159: return "unix64" ;
160: case PlatformFile :@expr1975 ;
161: return "platformFile" ;
162: default :@expr1975 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073743808 char_bit@var183 +@expr1073743809 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073743810 char_bit@var183 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073743811 char_bit@var183 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var206 ) const {
35: return p@var206 .@expr1073743812 first@var207 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var208 ) const {
42: return p@var208 .@expr1073743813 second@var209 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var210 , const T & x@var211 )
48: {
49: return std ::@expr1073743814 find (@expr1073743815 r@var210 .@expr1073743816 begin (@expr1073743817 ) , r@var210 .@expr1994 end (@expr1995 ) , x@var211 ) !=@expr1073743820 r@var210 .@expr1994 end (@expr1995 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var212 , const T & x@var213 )
54: {
55: return std ::@expr1073743823 find (@expr1073743824 r@var212 .@expr1073743825 begin (@expr1073743826 ) , r@var212 .@expr2003 end (@expr2004 ) , x@var213 ) !=@expr1073743829 r@var212 .@expr2003 end (@expr2004 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var214 , const U & x@var215 )
60: {
61: return std ::@expr1073743832 find (@expr1073743833 r@var214 .@expr1073743834 begin (@expr1073743835 ) , r@var214 .@expr2012 end (@expr2013 ) , x@var215 ) !=@expr1073743838 r@var214 .@expr2012 end (@expr2013 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var216 ) const
68: {
69: return static_cast < unsigned long > (@expr1073743841 t@var216 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var217 , char c@var218 )
74: {
75: return !@expr1073743842 str@var217 .@expr1073743843 empty (@expr1073743844 ) &&@expr1073743845 str@var217 .@expr1073743846 back (@expr1073743847 ) ==@expr1073743848 c@var218 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var219 , const char end@var220 [ ] , unsigned long endlen@var221 )
79: {
80: return (@expr2025 str@var219 .@expr2026 size (@expr2027 ) >=@expr1073743852 endlen@var221 ) &&@expr1073743853 (@expr2025 str@var219 .@expr1073743855 compare (@expr1073743856 str@var219 .@expr2026 size (@expr2027 ) -@expr1073743859 endlen@var221 , endlen@var221 , end@var220 ) ==@expr1073743860 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var222 , const char ( & end@var223 ) [ N ] )
85: {
86: return endsWith (@expr1073743862 str@var222 , end@var223 , N@expr1073743861 -@expr1073743863 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var224 , char q@var225 , const std :: string & p@var226 )
90: {
91: if (@expr1073743864 !@expr1073743865 endsWith (@expr1073743866 str@var224 , q@var225 ) ) {
92: return false ; }
93: if (@expr1073743867 (@expr1073743868 str@var224 .@expr1073743869 length (@expr1073743870 ) +@expr1073743871 1 ) >@expr1073743872 p@var226 .@expr1073743873 length (@expr1073743874 ) &&@expr1073743875 (@expr1073743876 str@var224 .@expr1073743877 compare (@expr1073743878 0 , p@var226 .@expr1073743879 size (@expr1073743880 ) +@expr1073743881 1 , p@var226 +@expr1073743882 q@var225 ) ==@expr1073743883 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var227 , char q@var228 )
99: {
100: static const std ::@expr2060 vector < std ::@expr2060 string > suffixes@var229 {@expr1073743886 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073743887 const std ::@expr2060 string &@expr1073743889 p@var230 :@expr1073743890 suffixes@var229 ) {
102: if (@expr1073743891 isPrefixStringCharLiteral (@expr1073743892 str@var227 , q@var228 , p@var230 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var231 )
109: {
110: return isStringCharLiteral (@expr1073743893 str@var231 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var232 )
114: {
115: return isStringCharLiteral (@expr1073743894 str@var232 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var233 , char q@var234 )
119: {
120: const unsigned long quotePos@var235 =@expr1073743895 str@var233 .@expr1073743896 find (@expr1073743897 q@var234 ) ;
121: return str@var233 .@expr1073743898 substr (@expr1073743899 quotePos@var235 +@expr1073743900 1U , str@var233 .@expr1073743901 size (@expr1073743902 ) -@expr1073743903 quotePos@var235 -@expr1073743904 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var236 )
125: {
126: if (@expr1073743905 isStringLiteral (@expr1073743906 str@var236 ) ) {
127: return getStringCharLiteral (@expr1073743907 str@var236 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var237 )
132: {
133: if (@expr1073743908 isCharLiteral (@expr1073743909 str@var237 ) ) {
134: return getStringCharLiteral (@expr1073743910 str@var237 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var238 )
139: {
140: if (@expr1073743911 i@var238 ==@expr1073743912 1 ) {
141: return "st" ; }
142: if (@expr1073743913 i@var238 ==@expr1073743914 2 ) {
143: return "nd" ; }
144: if (@expr1073743915 i@var238 ==@expr1073743916 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var239 , const std :: string & rhs@var240 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var241 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var242 , const std :: string & name@var243 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var244 , const std :: string & name@var245 ) ;
156:
157: void strTolower ( std :: string & str@var246 ) ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var247 , const std :: string & rhs@var248 ) const {
41: return caseInsensitiveStringCompare (@expr1073743917 lhs@var247 , rhs@var248 ) <@expr1073743918 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var256 ( cppcheck :: Platform :: Unspecified ) , msc@var257 ( false ) , useMfc@var258 ( false ) { }
67: std :: string cfg@var249 ;
68: std :: string filename@var250 ;
69: std :: string defines@var251 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var251 +@expr1073743919 (@expr1073743920 msc@var257 ?@expr1073743921 ";_MSC_VER=1900" :@expr1073743922 "" ) +@expr1073743923 (@expr1073743924 useMfc@var258 ?@expr1073743925 ";__AFXWIN_H__=1" :@expr1073743926 "" ) ;
72: }
73: std :: set < std :: string > undefs@var252 ;
74: std :: list < std :: string > includePaths@var253 ;
75: std :: list < std :: string > systemIncludePaths@var254 ;
76: std :: string standard@var255 ;
77: cppcheck :: Platform :: PlatformType platformType@var256 ;
78: bool msc@var257 ;
79: bool useMfc@var258 ;
80:
81: void parseCommand ( std :: string command@var259 ) ;
82: void setDefines ( std :: string defs@var260 ) ;
83: void setIncludePaths ( const std :: string & basepath@var261 , const std :: list < std :: string > & in@var262 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var263 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var264 ;
86: Type projectType@var265 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var266 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous1 {
96: std :: string analyzeAllVsConfigs@var267 ;
97: std :: vector < std :: string > pathNames@var268 ;
98: std :: list < std :: string > libraries@var269 ;
99: std :: list < std :: string > excludedPaths@var270 ;
100: std :: list < std :: string > checkVsConfigs@var271 ;
101: std :: string projectFile@var272 ;
102: std :: string platform@var273 ;
103: } ; struct Anonymous1 guiProject@var274 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var275 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var276 ) ;
107:
108: Type import ( const std :: string & filename@var277 , Settings * settings@var278 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var279 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var280 , Settings * settings@var281 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var282 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var283 , const std :: string & path@var284 , const std :: vector < std :: string > & fileFilters@var285 ) ;
115: bool importVcxproj ( const std :: string & filename@var286 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var287 , const std :: string & additionalIncludeDirectories@var288 , const std :: vector < std :: string > & fileFilters@var289 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var290 ) ;
117:
118: static void printError ( const std :: string & message@var291 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var292 ) ;
121:
122: std :: string mPath@var293 ;
123: std :: set < std :: string > mAllVSConfigs@var294 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var295 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var296 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var297 [ 2 ] = "1" ;
131: const char BuildDirElementName@var298 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var299 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var300 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var301 [ 7 ] = "parser" ;
135: const char BugHunting@var302 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var303 [ 11 ] = "includedir" ;
137: const char DirElementName@var304 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var305 [ 5 ] = "name" ;
139: const char DefinesElementName@var306 [ 8 ] = "defines" ;
140: const char DefineName@var307 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var308 [ 5 ] = "name" ;
142: const char UndefinesElementName@var309 [ 10 ] = "undefines" ;
143: const char UndefineName@var310 [ 9 ] = "undefine" ;
144: const char PathsElementName@var311 [ 6 ] = "paths" ;
145: const char PathName@var312 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var313 [ 5 ] = "name" ;
147: const char RootPathName@var314 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var315 [ 5 ] = "name" ;
149: const char IgnoreElementName@var316 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var317 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var318 [ 5 ] = "name" ;
152: const char ExcludeElementName@var319 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var320 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var321 [ 5 ] = "name" ;
155: const char FunctionContracts@var322 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var323 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var324 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var325 [ 8 ] = "library" ;
159: const char PlatformElementName@var326 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var327 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var328 [ 12 ] = "suppression" ;
162: const char AddonElementName@var329 [ 6 ] = "addon" ;
163: const char AddonsElementName@var330 [ 7 ] = "addons" ;
164: const char ToolElementName@var331 [ 5 ] = "tool" ;
165: const char ToolsElementName@var332 [ 6 ] = "tools" ;
166: const char TagsElementName@var333 [ 5 ] = "tags" ;
167: const char TagElementName@var334 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var335 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var336 [ 4 ] = "tag" ;
170: const char WarningElementName@var337 [ 8 ] = "warning" ;
171: const char HashAttributeName@var338 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var339 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var340 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var341 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var342 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var343 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var344 [ 11 ] = "clang-tidy" ;
178: const char Name@var345 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var346 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var347 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/analyzerinfo.h

1:
|
30:
31: class ErrorMessage ;
32:
|
48:
49: class AnalyzerInformation {
50: public:
51: ~ AnalyzerInformation ( ) ;
52:
53: static void writeFilesTxt ( const std :: string & buildDir@var348 , const std :: list < std :: string > & sourcefiles@var349 , const std :: string & userDefines@var350 , const std :: list < ImportProject :: FileSettings > & fileSettings@var351 ) ;
54:
55:
56: void close ( ) ;
57: bool analyzeFile ( const std :: string & buildDir@var352 , const std :: string & sourcefile@var353 , const std :: string & cfg@var354 , unsigned long long checksum@var355 , std :: list < ErrorMessage > * errors@var356 ) ;
58: void reportErr ( const ErrorMessage & msg@var357 , bool verbose@var358 ) ;
59: void setFileInfo ( const std :: string & check@var359 , const std :: string & fileInfo@var360 ) ;
60: static std :: string getAnalyzerInfoFile ( const std :: string & buildDir@var361 , const std :: string & sourcefile@var362 , const std :: string & cfg@var363 ) ;
61: private:
62: std :: ofstream mOutputStream@var364 ;
63: std :: string mAnalyzerInfoFile@var365 ;
64: } ;

##file cppcheck-2.8/lib/check.h

1:
|
29:
30: namespace tinyxml2 {
31: class XMLElement ;
32: }
33:
34: namespace CTU {
35: class FileInfo ;
36: }
37:
38: namespace ValueFlow {
39: class Value ;
40: }
41:
42: class Settings ;
43: class Token ;
44: class ErrorLogger ;
45: class ErrorMessage ;
46: class Tokenizer ;
47:
|
57:
58: class Check {
59: public:
60:
61: explicit Check ( const std :: string & aname@var366 ) ;
62:
63:
64: Check ( const std :: string & aname@var367 , const Tokenizer * tokenizer@var368 , const Settings * settings@var369 , ErrorLogger * errorLogger@var370 )
65: : mTokenizer@var381 ( tokenizer@var368 ) , mSettings@var382 ( settings@var369 ) , mErrorLogger@var383 ( errorLogger@var370 ) , mName@var416 ( aname@var367 ) { }
66:
67: virtual ~ Check ( ) {
68: if (@expr1073743927 !@expr1073743928 mTokenizer@var381 ) {
69: instances (@expr1073743929 ) .@expr1073743930 remove (@expr1073743931 this@expr1073743932 ) ; }
70: }
71:
72:
73: static std :: list < Check * > & instances ( ) ;
74:
75:
76: virtual void runChecks ( const Tokenizer * , const Settings * , ErrorLogger * ) = 0 ;
77:
78:
79: virtual void getErrorMessages ( ErrorLogger * errorLogger@var371 , const Settings * settings@var372 ) const = 0 ;
80:
81:
82: const std :: string & name ( ) const {
83: return mName@var416 ;
84: }
85:
86:
87: virtual std :: string classInfo ( ) const = 0 ;
88:
|
93:
94: static void reportError ( const ErrorMessage & errmsg@var373 ) ;
95:
96:
97: class FileInfo {
98: public:
99: FileInfo ( ) { }
100: virtual ~ FileInfo ( ) { }
101: virtual std :: string toString ( ) const {
102: return std ::@expr1073743933 string (@expr1073743934 ) ;
103: }
104: } ;
105:
106: virtual FileInfo * getFileInfo ( const Tokenizer * tokenizer@var374 , const Settings * settings@var375 ) const {
107: (@expr1073743935 void ) tokenizer@var374 ;
108: (@expr1073743936 void ) settings@var375 ;
109: return nullptr ;
110: }
111:
112: virtual FileInfo * loadFileInfoFromXml ( const tinyxml2 :: XMLElement * xmlElement@var376 ) const {
113: (@expr1073743937 void ) xmlElement@var376 ;
114: return nullptr ;
115: }
116:
117:
118: virtual bool analyseWholeProgram ( const CTU :: FileInfo * ctu@var377 , const std :: list < FileInfo * > & fileInfo@var378 , const Settings & , ErrorLogger & ) {
119: (@expr1073743938 void ) ctu@var377 ;
120: (@expr1073743939 void ) fileInfo@var378 ;
121:
122:
123: return false ;
124: }
125:
126: static std :: string getMessageId ( const ValueFlow :: Value & value@var379 , const char id@var380 [ ] ) ;
127:
128: protected:
129: const Tokenizer * const mTokenizer@var381 ;
130: const Settings * const mSettings@var382 ;
131: ErrorLogger * const mErrorLogger@var383 ;
132:
133:
134: void reportError ( const Token * tok@var384 , const Severity :: SeverityType severity@var385 , const std :: string & id@var386 , const std :: string & msg@var387 ) {
135: reportError (@expr1073743940 tok@var384 , severity@var385 , id@var386 , msg@var387 , CWE (@expr1073743941 0U ) , Certainty ::@expr1073743942 normal ) ;
136: }
137:
138:
139: void reportError ( const Token * tok@var388 , const Severity :: SeverityType severity@var389 , const std :: string & id@var390 , const std :: string & msg@var391 , const CWE & cwe@var392 , Certainty :: CertaintyLevel certainty@var393 ) {
140: const std ::@expr1073743943 list < const Token *@expr1073743944 > callstack@var394 (@expr1073743945 1 , tok@var388 ) ;
141: reportError (@expr1073743946 callstack@var394 , severity@var389 , id@var390 , msg@var391 , cwe@var392 , certainty@var393 ) ;
142: }
143:
144:
145: void reportError ( const std :: list < const Token * > & callstack@var395 , Severity :: SeverityType severity@var396 , const std :: string & id@var397 , const std :: string & msg@var398 ) {
146: reportError (@expr1073743947 callstack@var395 , severity@var396 , id@var397 , msg@var398 , CWE (@expr1073743948 0U ) , Certainty ::@expr1073743949 normal ) ;
147: }
148:
149:
150: void reportError ( const std :: list < const Token * > & callstack@var399 , Severity :: SeverityType severity@var400 , const std :: string & id@var401 , const std :: string & msg@var402 , const CWE & cwe@var403 , Certainty :: CertaintyLevel certainty@var404 ) ;
151:
152: void reportError ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var405 , Severity :: SeverityType severity@var406 , const char id@var407 [ ] , const std :: string & msg@var408 , const CWE & cwe@var409 , Certainty :: CertaintyLevel certainty@var410 ) ;
153:
154: std :: list < std :: pair < const Token * , std :: string > > getErrorPath ( const Token * errtok@var411 , const ValueFlow :: Value * value@var412 , const std :: string & bug@var413 ) const ;
155:
|
159:
160: bool wrongData ( const Token * tok@var414 , const char * str@var415 ) ;
161:
162:
163: void operator= ( const Check & ) = delete ;
164: Check ( const Check & ) = delete ;
165: private:
166: const std :: string mName@var416 ;
167: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var417 ;
42: double mDoubleValue@var418 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var419 ;
44: bool mIsUnsigned@var420 ;
45:
46: void promote ( const value & v@var421 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var422 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var419 !=@expr1073743950 Type ::@expr1073743951 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var419 ==@expr1073743952 Type ::@expr1073743953 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073743954 ) ?@expr1073743955 mDoubleValue@var418 :@expr1073743956 (@expr1073743957 double ) mIntValue@var417 ;
60: }
61:
62: static value calc ( char op@var423 , const value & v1@var424 , const value & v2@var425 ) ;
63: int compare ( const value & v@var426 ) const ;
64: value add ( int v@var427 ) const ;
65: value shiftLeft ( const value & v@var428 ) const ;
66: value shiftRight ( const value & v@var429 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var430 ;
72:
73: static long long toLongNumber ( const std :: string & str@var431 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var432 ) ;
75:
76: template < class T > static std :: string toString ( T value@var433 ) {
77: std ::@expr1073743958 ostringstream result@var434 ;
78: result@var434 <<@expr1073743959 value@var433 ;
79: return result@var434 .@expr1073743960 str (@expr1073743961 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var435 ) ;
82:
83: static bool isInt ( const std :: string & str@var436 ) ;
84: static bool isFloat ( const std :: string & str@var437 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var438 ) ;
86: static bool isNegative ( const std :: string & str@var439 ) ;
87: static bool isPositive ( const std :: string & str@var440 ) ;
88: static bool isDec ( const std :: string & str@var441 ) ;
89: static bool isFloatHex ( const std :: string & str@var442 ) ;
90: static bool isIntHex ( const std :: string & str@var443 ) ;
91: static bool isOct ( const std :: string & str@var444 ) ;
92: static bool isBin ( const std :: string & str@var445 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var446 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var447 , bool supportMicrosoftExtensions@var448 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var449 , const std :: string & second@var450 ) ;
105: static std :: string subtract ( const std :: string & first@var451 , const std :: string & second@var452 ) ;
106: static std :: string multiply ( const std :: string & first@var453 , const std :: string & second@var454 ) ;
107: static std :: string divide ( const std :: string & first@var455 , const std :: string & second@var456 ) ;
108: static std :: string mod ( const std :: string & first@var457 , const std :: string & second@var458 ) ;
109: static std :: string incdec ( const std :: string & var@var459 , const std :: string & op@var460 ) ;
110: static std :: string calculate ( const std :: string & first@var461 , const std :: string & second@var462 , char action@var463 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var464 ) ;
113: static std :: string cos ( const std :: string & tok@var465 ) ;
114: static std :: string tan ( const std :: string & tok@var466 ) ;
115: static std :: string abs ( const std :: string & tok@var467 ) ;
116: static bool isEqual ( const std :: string & first@var468 , const std :: string & second@var469 ) ;
117: static bool isNotEqual ( const std :: string & first@var470 , const std :: string & second@var471 ) ;
118: static bool isGreater ( const std :: string & first@var472 , const std :: string & second@var473 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var474 , const std :: string & second@var475 ) ;
120: static bool isLess ( const std :: string & first@var476 , const std :: string & second@var477 ) ;
121: static bool isLessEqual ( const std :: string & first@var478 , const std :: string & second@var479 ) ;
122: static bool isNullValue ( const std :: string & str@var480 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var481 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var482 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var483 , std :: string :: size_type iPos@var484 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var485 , const MathLib :: value & v2@var486 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var487 , const MathLib :: value & v2@var488 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var489 , const MathLib :: value & v2@var490 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var491 , const MathLib :: value & v2@var492 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var493 , const MathLib :: value & v2@var494 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var495 , const MathLib :: value & v2@var496 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var497 , const MathLib :: value & v2@var498 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var499 , const MathLib :: value & v2@var500 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var501 , const MathLib :: value & v2@var502 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var503 , const MathLib :: value & v2@var504 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var505 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var506 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var507 ;
42:
43:
44: std :: string stdValue@var508 ;
45:
46:
47: Standards ( ) : c@var506 ( CLatest ) , cpp@var507 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var509 ) {
50: stdValue@var508 =@expr1073743962 str@var509 ;
51: if (@expr1073743963 str@var509 ==@expr1073743964 "c89" ||@expr1073743965 str@var509 ==@expr1073743966 "C89" ) {
52: c@var506 =@expr1073743967 C89 ;
53: return true ;
54: }
55: if (@expr1073743968 str@var509 ==@expr1073743969 "c99" ||@expr1073743970 str@var509 ==@expr1073743971 "C99" ) {
56: c@var506 =@expr1073743972 C99 ;
57: return true ;
58: }
59: if (@expr1073743973 str@var509 ==@expr1073743974 "c11" ||@expr1073743975 str@var509 ==@expr1073743976 "C11" ) {
60: c@var506 =@expr1073743977 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073743978 c@var506 ) {
67: case C89 :@expr2155 ;
68: return "c89" ;
69: case C99 :@expr2155 ;
70: return "c99" ;
71: case C11 :@expr2155 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var510 ) {
77: if (@expr1073743982 std@var510 ==@expr1073743983 "c89" ) {
78: return Standards ::@expr1073743984 C89 ;
79: }
80: if (@expr1073743985 std@var510 ==@expr1073743986 "c99" ) {
81: return Standards ::@expr1073743987 C99 ;
82: }
83: if (@expr1073743988 std@var510 ==@expr1073743989 "c11" ) {
84: return Standards ::@expr1073743990 C11 ;
85: }
86: return Standards ::@expr1073743991 CLatest ;
87: }
88: bool setCPP ( std :: string str@var511 ) {
89: stdValue@var508 =@expr1073743992 str@var511 ;
90: strTolower (@expr1073743993 str@var511 ) ;
91: cpp@var507 =@expr1073743994 getCPP (@expr1073743995 str@var511 ) ;
92: return !@expr1073743996 stdValue@var508 .@expr1073743997 empty (@expr1073743998 ) &&@expr1073743999 str@var511 ==@expr1073744000 getCPP (@expr1073744001 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744002 cpp@var507 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var512 ) {
98: switch (@expr1073744003 std@var512 ) {
99: case CPP03 :@expr2180 ;
100: return "c++03" ;
101: case CPP11 :@expr2180 ;
102: return "c++11" ;
103: case CPP14 :@expr2180 ;
104: return "c++14" ;
105: case CPP17 :@expr2180 ;
106: return "c++17" ;
107: case CPP20 :@expr2180 ;
108: return "c++20" ;
109: case CPP23 :@expr2180 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var513 ) {
115: if (@expr1073744010 std@var513 ==@expr1073744011 "c++03" ) {
116: return Standards ::@expr1073744012 CPP03 ;
117: }
118: if (@expr1073744013 std@var513 ==@expr1073744014 "c++11" ) {
119: return Standards ::@expr1073744015 CPP11 ;
120: }
121: if (@expr1073744016 std@var513 ==@expr1073744017 "c++14" ) {
122: return Standards ::@expr1073744018 CPP14 ;
123: }
124: if (@expr1073744019 std@var513 ==@expr1073744020 "c++17" ) {
125: return Standards ::@expr1073744021 CPP17 ;
126: }
127: if (@expr1073744022 std@var513 ==@expr1073744023 "c++20" ) {
128: return Standards ::@expr1073744024 CPP20 ;
129: }
130: if (@expr1073744025 std@var513 ==@expr1073744026 "c++23" ) {
131: return Standards ::@expr1073744027 CPP23 ;
132: }
133: return Standards ::@expr1073744028 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var517 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var514 ) : errorcode@var517 ( e@var514 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var515 , T && r@var516 ) : errorcode@var517 ( e@var515 ) , reason@var518 ( r@var516 ) { }
66: ErrorCode errorcode@var517 ;
67: std :: string reason@var518 ;
68: } ;
69:
70: Error load ( const char exename@var519 [ ] , const char path@var520 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var521 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var522 [ ] , unsigned long len@var523 ) ;
75:
76: struct AllocFunc {
77: int groupId@var524 ;
78: int arg@var525 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var526 ;
81: int bufferSizeArg1@var527 ;
82: int bufferSizeArg2@var528 ;
83: int reallocArg@var529 ;
84: bool initData@var530 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var531 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var532 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var533 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var534 , int arg@var535 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var536 , int arg@var537 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var538 , int arg@var539 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var540 [ ] ) const {
107: return getAllocDealloc (@expr1073744029 mAlloc@var806 , name@var540 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var541 [ ] ) const {
112: return getAllocDealloc (@expr1073744030 mDealloc@var807 , name@var541 ) ;
113: }
114:
115:
116: int allocId ( const char name@var542 [ ] ) const {
117: const AllocFunc * af@var543 ; af@var543 =@expr1073744031 getAllocDealloc (@expr1073744032 mAlloc@var806 , name@var542 ) ;
118: return af@var543 ?@expr1073744033 af@var543 .@expr1073744034 groupId@var544 :@expr1073744035 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var545 [ ] ) const {
123: const AllocFunc * af@var546 ; af@var546 =@expr1073744036 getAllocDealloc (@expr1073744037 mDealloc@var807 , name@var545 ) ;
124: return af@var546 ?@expr1073744038 af@var546 .@expr1073744039 groupId@var547 :@expr1073744040 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var548 , int id@var549 , int arg@var550 ) {
129: mAlloc@var806 [@expr2217 functionname@var548 ] .@expr1073744042 groupId@var1846 =@expr1073744043 id@var549 ;
130: mAlloc@var806 [@expr2217 functionname@var548 ] .@expr1073744045 arg@var1847 =@expr1073744046 arg@var550 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var551 , int id@var552 , int arg@var553 ) {
134: mDealloc@var807 [@expr2223 functionname@var551 ] .@expr1073744048 groupId@var1848 =@expr1073744049 id@var552 ;
135: mDealloc@var807 [@expr2223 functionname@var551 ] .@expr1073744051 arg@var1849 =@expr1073744052 arg@var553 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var554 , int id@var555 , int arg@var556 , int reallocArg@var557 = 1 ) {
139: mRealloc@var808 [@expr2229 functionname@var554 ] .@expr1073744054 groupId@var1850 =@expr1073744055 id@var555 ;
140: mRealloc@var808 [@expr2229 functionname@var554 ] .@expr1073744057 arg@var1851 =@expr1073744058 arg@var556 ;
141: mRealloc@var808 [@expr2229 functionname@var554 ] .@expr1073744060 reallocArg@var1852 =@expr1073744061 reallocArg@var557 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var558 , bool noreturn@var559 ) {
146: mNoReturn@var809 [@expr1073744062 funcname@var558 ] =@expr1073744063 noreturn@var559 ?@expr1073744064 FalseTrueMaybe ::@expr1073744065 True :@expr1073744066 FalseTrueMaybe ::@expr1073744067 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var560 ) ;
150:
151:
152: static bool ismemory ( const int id@var561 ) {
153: return (@expr2244 (@expr2244 id@var561 >@expr1073744070 0 ) &&@expr1073744071 (@expr2244 (@expr2244 id@var561 &@expr1073744074 1 ) ==@expr1073744075 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var562 ) {
156: return (@expr2252 (@expr2252 func@var562 .@expr2254 groupId@var563 >@expr1073744079 0 ) &&@expr1073744080 (@expr2252 (@expr2252 func@var562 .@expr2254 groupId@var563 &@expr1073744084 1 ) ==@expr1073744085 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var564 ) {
161: return (@expr2262 (@expr2262 id@var564 >@expr1073744088 0 ) &&@expr1073744089 (@expr2262 (@expr2262 id@var564 &@expr1073744092 1 ) ==@expr1073744093 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var565 ) {
164: return (@expr2270 (@expr2270 func@var565 .@expr2272 groupId@var566 >@expr1073744097 0 ) &&@expr1073744098 (@expr2270 (@expr2270 func@var565 .@expr2272 groupId@var566 &@expr1073744102 1 ) ==@expr1073744103 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var567 ) const ;
168: int formatstr_argno ( const Token * ftok@var568 ) const ;
169: bool formatstr_scan ( const Token * ftok@var569 ) const ;
170: bool formatstr_secure ( const Token * ftok@var570 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var571 ;
174: int ptr2Arg@var572 ;
175: int sizeArg@var573 ;
176: int strlenArg@var574 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var575 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var576 ;
182: Standards standards@var577 ;
183: Severity :: SeverityType severity@var578 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var579 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var580 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var581 ) const ;
191: bool matchArguments ( const Token * ftok@var582 , const std :: string & functionName@var583 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var584 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var585 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var586 ) const ;
198: int returnValueContainer ( const Token * ftok@var587 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var588 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var589 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var590 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var591 , std :: string * unknownFunc@var592 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var602 ( -1 ) ,
210: size_templateArgNo@var604 ( -1 ) ,
211: arrayLike_indexOp@var605 ( false ) ,
212: stdStringLike@var606 ( false ) ,
213: stdAssociativeLike@var607 ( false ) ,
214: opLessAllowed@var608 ( true ) ,
215: hasInitializerListConstructor@var609 ( false ) ,
216: unstableErase@var610 ( false ) ,
217: unstableInsert@var611 ( false ) ,
218: view@var612 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var593 ;
248: Yield yield@var594 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var595 ;
252: int templateParameter@var596 ;
253: } ;
254: std :: string startPattern@var597 ; std :: string startPattern2@var598 ; std :: string endPattern@var599 ; std :: string itEndPattern@var600 ;
255: std :: map < std :: string , Function > functions@var601 ;
256: int type_templateArgNo@var602 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var603 ;
258: int size_templateArgNo@var604 ;
259: bool arrayLike_indexOp@var605 ;
260: bool stdStringLike@var606 ;
261: bool stdAssociativeLike@var607 ;
262: bool opLessAllowed@var608 ;
263: bool hasInitializerListConstructor@var609 ;
264: bool unstableErase@var610 ;
265: bool unstableInsert@var611 ;
266: bool view@var612 ;
267:
268: Action getAction ( const std :: string & function@var613 ) const {
269: const std ::@expr1073744104 map < std ::@expr1073744105 string , Function > ::@expr1073744106 const_iterator i@var614 =@expr1073744107 functions@var601 .@expr1073744108 find (@expr1073744109 function@var613 ) ;
270: if (@expr1073744110 i@var614 !=@expr1073744111 functions@var601 .@expr1073744112 end (@expr1073744113 ) ) {
271: return i@var614 .@expr1073744114 second@var615 .@expr1073744115 action@var616 ; }
272: return Action ::@expr1073744116 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var617 ) const {
276: const std ::@expr1073744117 map < std ::@expr1073744118 string , Function > ::@expr1073744119 const_iterator i@var618 =@expr1073744120 functions@var601 .@expr1073744121 find (@expr1073744122 function@var617 ) ;
277: if (@expr1073744123 i@var618 !=@expr1073744124 functions@var601 .@expr1073744125 end (@expr1073744126 ) ) {
278: return i@var618 .@expr1073744127 second@var619 .@expr1073744128 yield@var620 ; }
279: return Yield ::@expr1073744129 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var621 ) ;
283: static Action actionFrom ( const std :: string & actionName@var622 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var623 ;
286: const Container * detectContainer ( const Token * typeStart@var624 , bool iterator@var625 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var626 , bool * isIterator@var627 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var628 ( false ) ,
293: notnull@var629 ( false ) ,
294: notuninit@var630 ( -1 ) ,
295: formatstr@var631 ( false ) ,
296: strz@var632 ( false ) ,
297: optional@var633 ( false ) ,
298: variadic@var634 ( false ) ,
299: iteratorInfo@var640 ( ) ,
300: direction@var648 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var628 ;
303: bool notnull@var629 ;
304: int notuninit@var630 ;
305: bool formatstr@var631 ;
306: bool strz@var632 ;
307: bool optional@var633 ;
308: bool variadic@var634 ;
309: std :: string valid@var635 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var636 ( 0 ) , it@var637 ( false ) , first@var638 ( false ) , last@var639 ( false ) { }
314:
315: int container@var636 ;
316: bool it@var637 ;
317: bool first@var638 ;
318: bool last@var639 ;
319: } ;
320: IteratorInfo iteratorInfo@var640 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var641 , int a@var642 ) : type@var643 ( t@var641 ) , arg@var644 ( a@var642 ) , arg2@var645 ( 0 ) , value@var646 ( 0 ) { }
326: Type type@var643 ;
327: int arg@var644 ;
328: int arg2@var645 ;
329: long long value@var646 ;
330: } ;
331: std :: vector < MinSize > minsizes@var647 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var648 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var649 ;
344: bool use@var650 ;
345: bool leakignore@var651 ;
346: bool isconst@var652 ;
347: bool ispure@var653 ;
348: UseRetValType useretval@var654 ;
349: bool ignore@var655 ;
350: bool formatstr@var656 ;
351: bool formatstr_scan@var657 ;
352: bool formatstr_secure@var658 ;
353: Container :: Action containerAction@var659 ;
354: Container :: Yield containerYield@var660 ;
355: Function ( )
356: : use@var650 ( false ) ,
357: leakignore@var651 ( false ) ,
358: isconst@var652 ( false ) ,
359: ispure@var653 ( false ) ,
360: useretval@var654 ( UseRetValType :: NONE ) ,
361: ignore@var655 ( false ) ,
362: formatstr@var656 ( false ) ,
363: formatstr_scan@var657 ( false ) ,
364: formatstr_secure@var658 ( false ) ,
365: containerAction@var659 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var660 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var661 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var662 ;
372: bool isUse ( const std :: string & functionName@var663 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var664 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var665 , bool pure@var666 ) const ;
375: bool isFunctionConst ( const Token * ftok@var667 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var668 , int argnr@var669 ) const {
378: const ArgumentChecks * arg@var670 ; arg@var670 =@expr1073744130 getarg (@expr1073744131 ftok@var668 , argnr@var669 ) ;
379: return arg@var670 &&@expr1073744132 arg@var670 .@expr1073744133 notbool@var671 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var672 , int argnr@var673 ) const ;
383: bool isuninitargbad ( const Token * ftok@var674 , int argnr@var675 , int indirect@var676 = 0 , bool * hasIndirect@var677 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var678 , int argnr@var679 ) const {
386: const ArgumentChecks * arg@var680 ; arg@var680 =@expr1073744134 getarg (@expr1073744135 ftok@var678 , argnr@var679 ) ;
387: return arg@var680 &&@expr1073744136 arg@var680 .@expr1073744137 formatstr@var681 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var682 , int argnr@var683 ) const {
391: const ArgumentChecks * arg@var684 ; arg@var684 =@expr1073744138 getarg (@expr1073744139 ftok@var682 , argnr@var683 ) ;
392: return arg@var684 &&@expr1073744140 arg@var684 .@expr1073744141 strz@var685 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var686 , int argnr@var687 , const long long argvalue@var688 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var689 , int argnr@var690 , double argvalue@var691 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var692 , int argnr@var693 ) const {
399: const ArgumentChecks * arg@var694 ; arg@var694 =@expr1073744142 getarg (@expr1073744143 ftok@var692 , argnr@var693 ) ;
400: return arg@var694 ?@expr1073744144 arg@var694 .@expr1073744145 valid@var695 :@expr1073744146 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var696 ;
405: std :: string op1@var697 ;
406: std :: string op2@var698 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744147 isInt (@expr1073744148 op1@var697 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var699 , int argnr@var700 ) const {
413: const ArgumentChecks * arg@var701 ; arg@var701 =@expr1073744149 getarg (@expr1073744150 ftok@var699 , argnr@var700 ) ;
414: return arg@var701 &&@expr1073744151 arg@var701 .@expr2328 iteratorInfo@var702 .@expr1073744153 it@var703 ?@expr1073744154 &@expr1073744155 arg@var701 .@expr2328 iteratorInfo@var702 :@expr1073744157 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var704 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var705 , int argnr@var706 ) const {
420: const ArgumentChecks * arg@var707 ; arg@var707 =@expr1073744158 getarg (@expr1073744159 ftok@var705 , argnr@var706 ) ;
421: return arg@var707 ?@expr1073744160 &@expr1073744161 arg@var707 .@expr1073744162 minsizes@var708 :@expr1073744163 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var709 , int argnr@var710 ) const ;
425:
426: bool markupFile ( const std :: string & path@var711 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var712 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var816 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var713 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var714 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var715 , const std :: string & token@var716 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var717 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var718 ) const ;
443: const std :: string & blockend ( const std :: string & file@var719 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var720 , const std :: string & keyword@var721 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var722 ) const {
448: return mExporters@var819 .@expr1073744164 find (@expr1073744165 prefix@var722 ) !=@expr1073744166 mExporters@var819 .@expr1073744167 end (@expr1073744168 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var723 , const std :: string & token@var724 ) const {
452: const std ::@expr1073744169 map < std ::@expr1073744170 string , ExportedFunctions > ::@expr1073744171 const_iterator it@var725 =@expr1073744172 mExporters@var819 .@expr1073744173 find (@expr1073744174 prefix@var723 ) ;
453: return (@expr1073744175 it@var725 !=@expr1073744176 mExporters@var819 .@expr1073744177 end (@expr1073744178 ) &&@expr1073744179 it@var725 .@expr1073744180 second@var726 .@expr1073744181 isPrefix (@expr1073744182 token@var724 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var727 , const std :: string & token@var728 ) const {
457: const std ::@expr1073744183 map < std ::@expr1073744184 string , ExportedFunctions > ::@expr1073744185 const_iterator it@var729 =@expr1073744186 mExporters@var819 .@expr1073744187 find (@expr1073744188 prefix@var727 ) ;
458: return (@expr1073744189 it@var729 !=@expr1073744190 mExporters@var819 .@expr1073744191 end (@expr1073744192 ) &&@expr1073744193 it@var729 .@expr1073744194 second@var730 .@expr1073744195 isSuffix (@expr1073744196 token@var728 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var731 , const std :: string & importer@var732 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var733 , Container :: Yield yield@var734 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var735 , Container :: Action action@var736 ) const ;
465:
466: bool isreflection ( const std :: string & token@var737 ) const {
467: return mReflection@var821 .@expr1073744197 find (@expr1073744198 token@var737 ) !=@expr1073744199 mReflection@var821 .@expr1073744200 end (@expr1073744201 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var738 ) const {
471: const std ::@expr1073744202 map < std ::@expr1073744203 string , int > ::@expr1073744204 const_iterator it@var739 =@expr1073744205 mReflection@var821 .@expr1073744206 find (@expr1073744207 token@var738 ) ;
472: if (@expr1073744208 it@var739 !=@expr1073744209 mReflection@var821 .@expr1073744210 end (@expr1073744211 ) ) {
473: return it@var739 .@expr1073744212 second@var740 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var741 ;
478:
479: struct SmartPointer {
480: std :: string name@var742 ; name@var742 = "" ;
481: bool unique@var743 ; unique@var743 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var744 ;
485: bool isSmartPointer ( const Token * tok@var745 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var746 ) const ;
487:
488: struct PodType {
489: unsigned int size@var747 ;
490: char sign@var748 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var749 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var750 ) const {
494: const std ::@expr1073744213 unordered_map < std ::@expr1073744214 string , PodType > ::@expr1073744215 const_iterator it@var751 =@expr1073744216 mPodTypes@var822 .@expr1073744217 find (@expr1073744218 name@var750 ) ;
495: return (@expr2395 it@var751 !=@expr1073744220 mPodTypes@var822 .@expr1073744221 end (@expr1073744222 ) ) ?@expr1073744223 &@expr1073744224 (@expr2395 it@var751 .@expr1073744226 second@var752 ) :@expr1073744227 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var763 ( false )
501: , mUnsigned@var764 ( false )
502: , mLong@var765 ( false )
503: , mPointer@var766 ( false )
504: , mPtrPtr@var767 ( false )
505: , mConstPtr@var768 ( false ) { }
506: bool operator== ( const PlatformType & type@var753 ) const {
507: return (@expr1073744228 mSigned@var763 ==@expr1073744229 type@var753 .@expr1073744230 mSigned@var754 &&@expr1073744231
508: mUnsigned@var764 ==@expr1073744232 type@var753 .@expr1073744233 mUnsigned@var755 &&@expr1073744234
509: mLong@var765 ==@expr1073744235 type@var753 .@expr1073744236 mLong@var756 &&@expr1073744237
510: mPointer@var766 ==@expr1073744238 type@var753 .@expr1073744239 mPointer@var757 &&@expr1073744240
511: mPtrPtr@var767 ==@expr1073744241 type@var753 .@expr1073744242 mPtrPtr@var758 &&@expr1073744243
512: mConstPtr@var768 ==@expr1073744244 type@var753 .@expr1073744245 mConstPtr@var759 &&@expr1073744246
513: mType@var762 ==@expr1073744247 type@var753 .@expr1073744248 mType@var760 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var761 ) const {
516: return !@expr1073744249 (@expr1073744250 *@expr1073744251 this@expr1073744252 ==@expr1073744253 type@var761 ) ;
517: }
518: std :: string mType@var762 ;
519: bool mSigned@var763 ;
520: bool mUnsigned@var764 ;
521: bool mLong@var765 ;
522: bool mPointer@var766 ;
523: bool mPtrPtr@var767 ;
524: bool mConstPtr@var768 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var769 ) const {
529: const std ::@expr1073744254 map < std ::@expr1073744255 string , PlatformType > ::@expr1073744256 const_iterator it@var770 =@expr1073744257 mPlatformTypes@var772 .@expr1073744258 find (@expr1073744259 name@var769 ) ;
530: return (@expr2436 it@var770 !=@expr1073744261 mPlatformTypes@var772 .@expr1073744262 end (@expr1073744263 ) ) ?@expr1073744264 &@expr1073744265 (@expr2436 it@var770 .@expr1073744267 second@var771 ) :@expr1073744268 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var772 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var773 , const std :: string & platform@var774 ) const {
536: const std ::@expr1073744269 map < std ::@expr2446 string , Platform > ::@expr1073744271 const_iterator it@var775 =@expr1073744272 mPlatforms@var824 .@expr1073744273 find (@expr1073744274 platform@var774 ) ;
537: if (@expr1073744275 it@var775 !=@expr1073744276 mPlatforms@var824 .@expr1073744277 end (@expr1073744278 ) ) {
538: const PlatformType * const type@var776 ; type@var776 =@expr1073744279 it@var775 .@expr1073744280 second@var777 .@expr1073744281 platform_type (@expr1073744282 name@var773 ) ;
539: if (@expr1073744283 type@var776 ) {
540: return type@var776 ; }
541: }
542:
543: const std ::@expr1073744284 map < std ::@expr2446 string , PlatformType > ::@expr1073744286 const_iterator it2@var778 =@expr1073744287 mPlatformTypes@var823 .@expr1073744288 find (@expr1073744289 name@var773 ) ;
544: return (@expr2466 it2@var778 !=@expr1073744291 mPlatformTypes@var823 .@expr1073744292 end (@expr1073744293 ) ) ?@expr1073744294 &@expr1073744295 (@expr2466 it2@var778 .@expr1073744297 second@var779 ) :@expr1073744298 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var780 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var781 , Library :: Container :: Yield y@var782 , const std :: string & fallback@var783 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var784 , const std :: string & typeName@var785 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var786 , const std :: string & name@var787 , std :: set < std :: string > & unknown_elements@var788 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var789 ) {
565: mPrefixes@var793 .@expr1073744299 insert (@expr1073744300 prefix@var789 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var790 ) {
568: mSuffixes@var794 .@expr1073744301 insert (@expr1073744302 suffix@var790 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var791 ) const {
571: return (@expr1073744303 mPrefixes@var793 .@expr1073744304 find (@expr1073744305 prefix@var791 ) !=@expr1073744306 mPrefixes@var793 .@expr1073744307 end (@expr1073744308 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var792 ) const {
574: return (@expr1073744309 mSuffixes@var794 .@expr1073744310 find (@expr1073744311 suffix@var792 ) !=@expr1073744312 mSuffixes@var794 .@expr1073744313 end (@expr1073744314 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var793 ;
579: std :: set < std :: string > mSuffixes@var794 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var802 ( 0 ) { }
584:
585: void setStart ( const char * s@var795 ) {
586: mStart@var800 =@expr1073744315 s@var795 ;
587: }
588: void setEnd ( const char * e@var796 ) {
589: mEnd@var801 =@expr1073744316 e@var796 ;
590: }
591: void setOffset ( const int o@var797 ) {
592: mOffset@var802 =@expr1073744317 o@var797 ;
593: }
594: void addBlock ( const char * blockName@var798 ) {
595: mBlocks@var803 .@expr1073744318 insert (@expr1073744319 blockName@var798 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var800 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var801 ;
602: }
603: int offset ( ) const {
604: return mOffset@var802 ;
605: }
606: bool isBlock ( const std :: string & blockName@var799 ) const {
607: return mBlocks@var803 .@expr1073744320 find (@expr1073744321 blockName@var799 ) !=@expr1073744322 mBlocks@var803 .@expr1073744323 end (@expr1073744324 ) ;
608: }
609:
610: private:
611: std :: string mStart@var800 ;
612: std :: string mEnd@var801 ;
613: int mOffset@var802 ;
614: std :: set < std :: string > mBlocks@var803 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var804 ;
618: std :: set < std :: string > mFiles@var805 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var806 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var807 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var808 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var809 ;
623: std :: map < std :: string , std :: string > mReturnValue@var810 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var811 ;
625: std :: map < std :: string , int > mReturnValueContainer@var812 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var813 ;
627: std :: map < std :: string , bool > mReportErrors@var814 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var815 ;
629: std :: set < std :: string > mMarkupExtensions@var816 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var817 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var818 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var819 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var820 ;
634: std :: map < std :: string , int > mReflection@var821 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var822 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var823 ;
637: std :: map < std :: string , Platform > mPlatforms@var824 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var825 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var826 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var827 , int argnr@var828 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var829 , bool * error@var830 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var831 , const std :: string & name@var832 ) {
646: const std ::@expr1073744325 map < std ::@expr1073744326 string , AllocFunc > ::@expr1073744327 const_iterator it@var833 =@expr1073744328 data@var831 .@expr1073744329 find (@expr1073744330 name@var832 ) ;
647: return (@expr1073744331 it@var833 ==@expr1073744332 data@var831 .@expr1073744333 end (@expr1073744334 ) ) ?@expr1073744335 nullptr :@expr1073744336 &@expr1073744337 it@var833 .@expr1073744338 second@var834 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var835 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var836 ,
654: const Settings * settings@var837 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var838 = nullptr ) ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var839 , std :: clock_t clocks@var840 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var841 ;
45: long mNumberOfResults@var842 ;
46:
47: TimerResultsData ( )
48: : mClocks@var841 ( 0 )
49: , mNumberOfResults@var842 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var843 =@expr1073744340 (@expr1073744341 double ) (@expr1073744342 (@expr1073744343 unsigned long ) mClocks@var841 ) /@expr1073744344 (@expr1073744345 double ) CLOCKS_PER_SEC@expr1073744339 ;
53: return ret@var843 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var844 ) const ;
62: void addResults ( const std :: string & str@var845 , std :: clock_t clocks@var846 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var847 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var848 , SHOWTIME_MODES showtimeMode@var849 , TimerResultsIntf * timerResults@var850 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var851 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var852 ;
79: TimerResultsIntf * mTimerResults@var853 ;
80: std :: clock_t mStart@var854 ;
81: const SHOWTIME_MODES mShowTimeMode@var855 ;
82: bool mStopped@var856 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var857 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var858 ;
103:
104:
105: std :: string addonPython@var859 ;
106:
107:
108: std :: vector < std :: string > basePaths@var860 ;
109:
110:
111: std :: string buildDir@var861 ;
112:
113:
114: bool checkAllConfigurations@var862 ;
115:
116:
117: bool checkConfiguration@var863 ;
118:
|
121:
122: bool checkHeaders@var864 ;
123:
124:
125: bool checkLibrary@var865 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var866 ;
129:
130:
131: bool checkUnusedTemplates@var867 ;
132:
133:
134: bool clang@var868 ;
135:
136:
137: std :: string clangExecutable@var869 ;
138:
139:
140: bool clangTidy@var870 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var871 ;
144:
145:
146: std :: string cppcheckCfgProductName@var872 ;
147:
148:
149: std :: string cppcheckCfgAbout@var873 ;
150:
151:
152: bool daca@var874 ;
153:
154:
155: bool debugnormal@var875 ;
156:
157:
158: bool debugSimplified@var876 ;
159:
160:
161: bool debugtemplate@var877 ;
162:
163:
164: bool debugwarnings@var878 ;
165:
166:
167: bool dump@var879 ;
168: std :: string dumpFile@var880 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var881 ;
176:
177:
178: bool exceptionHandling@var882 ;
179:
180:
181: std :: string exename@var883 ;
182:
183:
184:
185: int exitCode@var884 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var885 ;
189:
190:
191: bool force@var886 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var887 ;
196:
197:
198: bool inlineSuppressions@var888 ;
199:
200:
201:
202: unsigned int jobs@var889 ;
203:
|
206:
207: bool jointSuppressionReport@var890 ;
208:
209:
210: std :: list < std :: string > libraries@var891 ;
211:
212:
213: Library library@var892 ;
214:
215:
216:
217: int loadAverage@var893 ;
218:
|
221:
222: int maxConfigs@var894 ;
223:
224:
225: int maxCtuDepth@var895 ;
226:
227:
228: int maxTemplateRecursion@var896 ;
229:
230:
231: Suppressions nofail@var897 ;
232:
233:
234: Suppressions nomsg@var898 ;
235:
236:
237: std :: string outputFile@var899 ;
238:
239:
240: std :: string plistOutput@var900 ;
241:
242:
243: bool preprocessOnly@var901 ;
244:
245: ImportProject project@var902 ;
246:
247:
248: bool quiet@var903 ;
249:
250:
251: bool relativePaths@var904 ;
252:
253:
254: bool reportProgress@var905 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var906 ( "simple" )
261: , id@var908 ( "rule" )
262: , severity@var910 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var906 ;
266: std :: string pattern@var907 ;
267: std :: string id@var908 ;
268: std :: string summary@var909 ;
269: Severity :: SeverityType severity@var910 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var911 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var917 ( false ) , externalFunctions@var918 ( false ) , internalFunctions@var919 ( false ) , externalVariables@var920 ( false ) { }
281:
282: static const char XmlRootName@var912 [ ] ;
283: static const char XmlClasses@var913 [ ] ;
284: static const char XmlExternalFunctions@var914 [ ] ;
285: static const char XmlInternalFunctions@var915 [ ] ;
286: static const char XmlExternalVariables@var916 [ ] ;
287:
288: void clear ( ) {
289: classes@var917 =@expr1073744346 externalFunctions@var918 =@expr1073744347 internalFunctions@var919 =@expr1073744348 externalVariables@var920 =@expr1073744349 false ;
290: }
291:
|
297:
298: bool classes@var917 ;
299:
|
304:
305: bool externalFunctions@var918 ;
306:
|
310:
311: bool internalFunctions@var919 ;
312:
|
316:
317: bool externalVariables@var920 ;
318: } ;
319:
320: SafeChecks safeChecks@var921 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var922 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var923 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var924 ;
325:
326:
327: SHOWTIME_MODES showtime@var925 ;
328:
329:
330: Standards standards@var926 ;
331:
332:
333:
334: std :: string templateFormat@var927 ;
335:
336:
337:
338: std :: string templateLocation@var928 ;
339:
340:
341: std :: string userDefines@var929 ;
342:
343:
344: std :: set < std :: string > userUndefs@var930 ;
345:
346:
347: std :: list < std :: string > userIncludes@var931 ;
348:
349:
350: bool verbose@var932 ;
351:
352:
353: bool xml@var933 ;
354:
355:
356: int xml_version@var934 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var935 ) const {
363: for (@expr1073744350 const std ::@expr1073744351 string &@expr1073744352 configExcludePath@var936 :@expr1073744353 configExcludePaths@var871 ) {
364: if (@expr1073744354 file@var935 .@expr1073744355 length (@expr1073744356 ) >=@expr1073744357 configExcludePath@var936 .@expr2534 length (@expr2535 ) &&@expr1073744360 file@var935 .@expr1073744361 compare (@expr1073744362 0 , configExcludePath@var936 .@expr2534 length (@expr2535 ) , configExcludePath@var936 ) ==@expr1073744365 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var937 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var938 , bool inconclusiveCheck@var939 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073744366 find (@expr1073744367 libraries@var891 .@expr1073744368 begin (@expr1073744369 ) , libraries@var891 .@expr2546 end (@expr2547 ) , "posix" ) !=@expr1073744372 libraries@var891 .@expr2546 end (@expr2547 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var940 = true ) {
392: Settings ::@expr1073744375 mTerminated@var857 =@expr1073744376 t@var940 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073744377 mTerminated@var857 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var941 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/cppcheck.h

1:
|
39:
40: class Tokenizer ;
41:
|
50:
51: class CppCheck : ErrorLogger {
52: public:
53:
54:
55:
56: CppCheck ( ErrorLogger & errorLogger@var942 ,
57: bool useGlobalSuppressions@var943 ,
58: std :: function < bool ( std :: string , std :: vector < std :: string > , std :: string , std :: string * ) > executeCommand@var944 ) ;
59:
|
62:
63: ~ CppCheck ( ) override ;
64:
|
78:
79: unsigned int check ( const std :: string & path@var945 ) ;
80: unsigned int check ( const ImportProject :: FileSettings & fs@var946 ) ;
81:
|
92:
93: unsigned int check ( const std :: string & path@var947 , const std :: string & content@var948 ) ;
94:
|
98:
99: Settings & settings ( ) ;
100:
|
104:
105: static const char * version ( ) ;
106:
|
112:
113: static const char * extraVersion ( ) ;
114:
115: virtual void reportStatus ( unsigned int fileindex@var949 , unsigned int filecount@var950 , unsigned long sizedone@var951 , unsigned long sizetotal@var952 ) ;
116:
|
120:
121: void getErrorMessages ( ) ;
122:
123: void tooManyConfigsError ( const std :: string & file@var953 , const int numberOfConfigurations@var954 ) ;
124: void purgedConfigurationMessage ( const std :: string & file@var955 , const std :: string & configuration@var956 ) ;
125:
126: void dontSimplify ( ) {
127: mSimplify@var987 =@expr1073744378 false ;
128: }
129:
|
134:
135: bool analyseWholeProgram ( ) ;
136:
137:
138: void analyseClangTidy ( const ImportProject :: FileSettings & fileSettings@var957 ) ;
139:
140:
141: void analyseWholeProgram ( const std :: string & buildDir@var958 , const std :: map < std :: string , unsigned long > & files@var959 ) ;
142:
143:
144:
145: bool isUnusedFunctionCheckEnabled ( ) const ;
146:
147: private:
148:
149: bool hasRule ( const std :: string & tokenlist@var960 ) const ;
150:
151:
152: void internalError ( const std :: string & filename@var961 , const std :: string & msg@var962 ) ;
153:
|
160:
161: unsigned int checkFile ( const std :: string & filename@var963 , const std :: string & cfgname@var964 , std :: istream & fileStream@var965 ) ;
162:
|
166:
167: void checkRawTokens ( const Tokenizer & tokenizer@var966 ) ;
168:
|
172:
173: void checkNormalTokens ( const Tokenizer & tokenizer@var967 ) ;
174:
|
177:
178: void executeAddons ( const std :: vector < std :: string > & files@var968 ) ;
179: void executeAddons ( const std :: string & dumpFile@var969 ) ;
180:
|
183:
184: void executeAddonsWholeProgram ( const std :: map < std :: string , unsigned long > & files@var970 ) ;
185:
|
190:
191: void executeRules ( const std :: string & tokenlist@var971 , const Tokenizer & tokenizer@var972 ) ;
192:
|
199:
200: void reportErr ( const ErrorMessage & msg@var973 ) override ;
201:
|
206:
207: void reportOut ( const std :: string & outmsg@var974 , Color c@var975 = Color :: Reset ) override ;
208:
209: std :: list < std :: string > mErrorList@var976 ;
210: Settings mSettings@var977 ;
211:
212: void reportProgress ( const std :: string & filename@var978 , const char stage@var979 [ ] , const unsigned long value@var980 ) override ;
213:
|
216:
217: void reportInfo ( const ErrorMessage & msg@var981 ) override ;
218:
219: ErrorLogger & mErrorLogger@var982 ;
220:
221:
222: std :: string mCurrentConfig@var983 ;
223:
224: unsigned int mExitCode@var984 ;
225:
226: bool mUseGlobalSuppressions@var985 ;
227:
228:
229: bool mTooManyConfigs@var986 ;
230:
231:
232: bool mSimplify@var987 ;
233:
234:
235: std :: list < Check :: FileInfo * > mFileInfo@var988 ;
236:
237: AnalyzerInformation mAnalyzerInformation@var989 ;
238:
239:
240: std :: function < bool ( std :: string , std :: vector < std :: string > , std :: string , std :: string * ) > mExecuteCommand@var990 ;
241: } ;

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var991 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var992 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var993 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var994 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var995 , const std :: string & fname2@var996 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var997 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var998 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var999 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var1000 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var1001 , const std :: vector < std :: string > & basePaths@var1002 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var1003 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var1004 ) {
135: const std ::@expr1073744379 set < std ::@expr1073744380 string > extra@var1005 ;
136: return acceptFile (@expr1073744381 filename@var1004 , extra@var1005 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var1006 , const std :: set < std :: string > & extra@var1007 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var1008 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var1009 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var1010 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var1011 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var1012 ) ;
182: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var1013 ) const {
54: x@var1013 ++@expr1073744382 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var1014 ) const {
60: x@var1014 --@expr1073744383 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var1015 , const U & y@var1016 ) const {
67: return x@var1015 <@expr1073744384 y@var1016 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var1017 , const U & y@var1018 ) const {
74: return std ::@expr1073744385 abs (@expr1073744386 x@var1017 -@expr1073744387 y@var1018 ) ==@expr1073744388 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var1019 , T x@var1020 , U y@var1021 ) const {
81: result@var1019 =@expr1073744389 !@expr1073744390 (@expr1073744391 x@var1020 >@expr1073744392 y@var1021 ||@expr1073744393 x@var1020 <@expr1073744394 y@var1021 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var1022 = 0 , Bound b@var1023 = Bound :: Point )
91: : valueType@var1063 ( ValueType :: INT ) ,
92: bound@var1064 ( b@var1023 ) ,
93: intvalue@var1065 ( val@var1022 ) ,
94: tokvalue@var1066 ( nullptr ) ,
95: floatValue@var1067 ( 0.0 ) ,
96: moveKind@var1068 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var1069 ( val@var1022 ) ,
98: condition@var1070 ( nullptr ) ,
99: varId@var1072 ( 0U ) ,
100: safe@var1073 ( false ) ,
101: conditional@var1074 ( false ) ,
102: macro@var1075 ( false ) ,
103: defaultArg@var1076 ( false ) ,
104: indirect@var1077 ( 0 ) ,
105: path@var1078 ( 0 ) ,
106: wideintvalue@var1079 ( val@var1022 ) ,
107: subexpressions@var1080 ( ) ,
108: capturetok@var1081 ( nullptr ) ,
109: lifetimeKind@var1082 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var1083 ( LifetimeScope :: Local ) ,
111: valueKind@var1088 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var1024 , long long val@var1025 , Bound b@var1026 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var1027 ) const {
118: if (@expr1073744395 valueType@var1063 !=@expr1073744396 rhs@var1027 .@expr1073744397 valueType@var1028 ) {
119: return false ; }
120: switch (@expr1073744398 valueType@var1063 ) {
121: case ValueType ::@expr1073744399 INT :@expr2576
122: case ValueType ::@expr1073744401 CONTAINER_SIZE :@expr2576
123: case ValueType ::@expr1073744403 BUFFER_SIZE :@expr2576
124: case ValueType ::@expr1073744405 ITERATOR_START :@expr2576
125: case ValueType ::@expr1073744407 ITERATOR_END :@expr2576 ;
126: if (@expr2585 intvalue@var1065 !=@expr2586 rhs@var1027 .@expr2587 intvalue@var1029 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744412 TOK :@expr2576 ;
130: if (@expr2590 tokvalue@var1066 !=@expr2591 rhs@var1027 .@expr2592 tokvalue@var1030 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744417 FLOAT :@expr2576 ;
134:
135: if (@expr1073744419 floatValue@var1067 >@expr1073744420 rhs@var1027 .@expr2597 floatValue@var1031 ||@expr1073744422 floatValue@var1067 <@expr1073744423 rhs@var1027 .@expr2597 floatValue@var1031 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744425 MOVED :@expr2576 ;
139: if (@expr1073744427 moveKind@var1068 !=@expr1073744428 rhs@var1027 .@expr1073744429 moveKind@var1032 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744430 UNINIT :@expr2576 ;
143: break ;
144: case ValueType ::@expr1073744432 LIFETIME :@expr2576 ;
145: if (@expr2590 tokvalue@var1066 !=@expr2591 rhs@var1027 .@expr2592 tokvalue@var1030 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744437 SYMBOLIC :@expr2576 ;
149: if (@expr1073744439 !@expr1073744440 sameToken (@expr1073744441 tokvalue@var1066 , rhs@var1027 .@expr2592 tokvalue@var1030 ) ) {
150: return false ; }
151: if (@expr2585 intvalue@var1065 !=@expr2586 rhs@var1027 .@expr2587 intvalue@var1029 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var1033 , F f@var1034 ) {
160: switch (@expr1073744446 self@var1033 .@expr1073744447 valueType@var1035 ) {
161: case ValueType ::@expr1073744448 INT :@expr2625
162: case ValueType ::@expr1073744450 SYMBOLIC :@expr2625
163: case ValueType ::@expr1073744452 BUFFER_SIZE :@expr2625
164: case ValueType ::@expr1073744454 CONTAINER_SIZE :@expr2625
165: case ValueType ::@expr1073744456 ITERATOR_START :@expr2625
166: case ValueType ::@expr1073744458 ITERATOR_END :@expr2625 ; {
167: f@var1034 (@expr1073744460 self@var1033 .@expr1073744461 intvalue@var1036 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744462 FLOAT :@expr2625 ; {
171: f@var1034 (@expr1073744464 self@var1033 .@expr1073744465 floatValue@var1037 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744466 UNINIT :@expr2625
175: case ValueType ::@expr1073744468 TOK :@expr2625
176: case ValueType ::@expr1073744470 LIFETIME :@expr2625
177: case ValueType ::@expr1073744472 MOVED :@expr2625 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var1038 , Compare compare@var1039 , T x@var1040 , U y@var1041 ) const {
186: result@var1038 =@expr1073744474 compare@var1039 (@expr1073744475 x@var1040 , y@var1041 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var1042 , const Value & rhs@var1043 , Compare compare@var1044 , T x@var1045 ) const {
191: visitValue (@expr1073744477 rhs@var1043 ,
192: std ::@expr1073744478 bind (@expr1073744479 innerVisitor {@expr1073744480 } , std ::@expr1073744481 ref (@expr1073744482 result@var1042 ) , std ::@expr1073744483 move (@expr1073744484 compare@var1044 ) , x@var1045 , std ::@expr1073744485 placeholders ::@expr1073744486 _1@expr1073744476 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var1046 , Compare compare@var1047 ) const {
198: assert (@expr1073744488 (@expr1073744489 !@expr1073744490 this@expr2667 .@expr1073744492 isSymbolicValue (@expr1073744493 ) &&@expr1073744494 !@expr1073744495 rhs@var1046 .@expr1073744496 isSymbolicValue (@expr1073744497 ) ) ||@expr1073744498
199: (@expr1073744499 this@expr2667 .@expr1073744500 valueType@var1063 ==@expr1073744501 rhs@var1046 .@expr1073744502 valueType@var1048 &&@expr1073744503 sameToken (@expr1073744504 this@expr2667 .@expr1073744505 tokvalue@var1066 , rhs@var1046 .@expr1073744506 tokvalue@var1049 ) ) ) ;
200: bool result@var1050 ; result@var1050 =@expr1073744507 false ;
201: visitValue (@expr1073744508
202: *@expr1073744509 this@expr2667 ,
203: std ::@expr1073744510 bind (@expr1073744511 compareVisitor {@expr1073744512 } , std ::@expr2689 ref (@expr1073744514 result@var1050 ) , std ::@expr2689 ref (@expr1073744516 rhs@var1046 ) , std ::@expr1073744517 move (@expr1073744518 compare@var1047 ) , std ::@expr1073744519 placeholders ::@expr1073744520 _1@expr1073744487 ) ) ;
204: return result@var1050 ;
205: }
206:
207: bool operator== ( const Value & rhs@var1051 ) const {
208: if (@expr1073744521 !@expr1073744522 equalValue (@expr1073744523 rhs@var1051 ) ) {
209: return false ; }
210:
211: return varvalue@var1069 ==@expr1073744524 rhs@var1051 .@expr1073744525 varvalue@var1052 &&@expr1073744526
212: condition@var1070 ==@expr1073744527 rhs@var1051 .@expr1073744528 condition@var1053 &&@expr1073744529
213: varId@var1072 ==@expr1073744530 rhs@var1051 .@expr1073744531 varId@var1054 &&@expr1073744532
214: conditional@var1074 ==@expr1073744533 rhs@var1051 .@expr1073744534 conditional@var1055 &&@expr1073744535
215: defaultArg@var1076 ==@expr1073744536 rhs@var1051 .@expr1073744537 defaultArg@var1056 &&@expr1073744538
216: indirect@var1077 ==@expr1073744539 rhs@var1051 .@expr1073744540 indirect@var1057 &&@expr1073744541
217: valueKind@var1088 ==@expr1073744542 rhs@var1051 .@expr1073744543 valueKind@var1058 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var1059 ) const {
221: return !@expr1073744544 (@expr1073744545 *@expr1073744546 this@expr1073744547 ==@expr1073744548 rhs@var1059 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var1060 ) const {
226: bool result@var1061 ; result@var1061 =@expr1073744550 false ;
227: visitValue (@expr1073744551 *@expr1073744552 this@expr1073744553 , std ::@expr1073744554 bind (@expr1073744555 equalVisitor {@expr1073744556 } , std ::@expr1073744557 ref (@expr1073744558 result@var1061 ) , x@var1060 , std ::@expr1073744559 placeholders ::@expr1073744560 _1@expr1073744549 ) ) ;
228: return result@var1061 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744561 bound@var1064 ==@expr1073744562 Bound ::@expr1073744563 Lower ) {
233: visitValue (@expr1073744564 *@expr2741 this@expr2742 , increment {@expr1073744567 } ) ; }
234: else { if (@expr1073744568 bound@var1064 ==@expr1073744569 Bound ::@expr1073744570 Upper ) {
235: visitValue (@expr1073744571 *@expr2741 this@expr2742 , decrement {@expr1073744573 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744574 bound@var1064 ==@expr1073744575 Bound ::@expr2752 Lower ) {
240: bound@var1064 =@expr1073744577 Bound ::@expr2754 Upper ; }
241: else { if (@expr1073744579 bound@var1064 ==@expr1073744580 Bound ::@expr2754 Upper ) {
242: bound@var1064 =@expr1073744582 Bound ::@expr2752 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744584 ) ;
247: decreaseRange (@expr1073744585 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var1062 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var1063 ;
267: bool isIntValue ( ) const {
268: return valueType@var1063 ==@expr1073744587 ValueType ::@expr1073744588 INT@expr1073744586 ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var1063 ==@expr1073744589 ValueType ::@expr1073744590 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var1063 ==@expr1073744591 ValueType ::@expr1073744592 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var1063 ==@expr1073744593 ValueType ::@expr1073744594 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var1063 ==@expr1073744595 ValueType ::@expr1073744596 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var1063 ==@expr1073744597 ValueType ::@expr1073744598 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var1063 ==@expr1073744599 ValueType ::@expr1073744600 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var1063 ==@expr1073744601 ValueType ::@expr1073744602 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var1063 ==@expr1073744603 ValueType ::@expr1073744604 ITERATOR_START ||@expr1073744605 valueType@var1063 ==@expr1073744606 ValueType ::@expr1073744607 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var1063 ==@expr1073744608 ValueType ::@expr1073744609 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var1063 ==@expr1073744610 ValueType ::@expr1073744611 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var1063 ==@expr1073744612 ValueType ::@expr1073744613 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var1063 ==@expr1073744615 ValueType ::@expr1073744616 LIFETIME &&@expr1073744617 lifetimeScope@var1083 ==@expr1073744618 LifetimeScope ::@expr1073744619 Local@expr1073744614 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var1063 ==@expr1073744620 ValueType ::@expr1073744621 LIFETIME &&@expr1073744622 lifetimeScope@var1083 ==@expr1073744623 LifetimeScope ::@expr1073744624 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var1063 ==@expr1073744625 ValueType ::@expr1073744626 LIFETIME &&@expr1073744627 lifetimeScope@var1083 ==@expr1073744628 LifetimeScope ::@expr1073744629 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744630 ) ||@expr1073744631 isUninitValue (@expr1073744632 ) ||@expr1073744633 isLifetimeValue (@expr1073744634 ) ;
318: }
319:
320:
321: Bound bound@var1064 ;
322:
323:
324: long long intvalue@var1065 ;
325:
326:
327: const Token * tokvalue@var1066 ;
328:
329:
330: double floatValue@var1067 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var1068 ;
334:
335:
336: long long varvalue@var1069 ;
337:
338:
339: const Token * condition@var1070 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1071 ;
342:
343:
344: int varId@var1072 ;
345:
346:
347: bool safe@var1073 ;
348:
349:
350: bool conditional@var1074 ;
351:
352:
353: bool macro@var1075 ;
354:
355:
356: bool defaultArg@var1076 ;
357:
358: int indirect@var1077 ;
359:
360:
361: long long path@var1078 ;
362:
363:
364: long long wideintvalue@var1079 ;
365:
366: std :: vector < std :: string > subexpressions@var1080 ;
367:
368:
369: const Token * capturetok@var1081 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var1082 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var1083 ;
385:
386: static const char * toString ( MoveKind moveKind@var1084 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var1085 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var1086 ) ;
389: static const char * toString ( Bound bound@var1087 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var1088 ;
402:
403: void setKnown ( ) {
404: valueKind@var1088 =@expr1073744635 ValueKind ::@expr1073744636 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var1088 ==@expr1073744637 ValueKind ::@expr1073744638 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var1088 =@expr1073744640 ValueKind ::@expr1073744641 Possible@expr1073744639 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var1088 ==@expr1073744643 ValueKind ::@expr1073744644 Possible@expr1073744642 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var1088 ==@expr1073744645 ValueKind ::@expr1073744646 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var1088 =@expr1073744647 ValueKind ::@expr1073744648 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var1089 = true ) {
428: if (@expr1073744649 inconclusive@var1089 ) {
429: valueKind@var1088 =@expr1073744650 ValueKind ::@expr1073744651 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var1088 ==@expr1073744652 ValueKind ::@expr1073744653 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744655 isKnown (@expr1073744656 ) ) {
438: valueKind@var1088 =@expr1073744657 ValueKind ::@expr1073744658 Possible@expr1073744654 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744659 condition@var1070 &&@expr1073744660 !@expr1073744661 defaultArg@var1076 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var1090 , const Token * tok2@var1091 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var1092 , const Settings * settings@var1093 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var1094 , SymbolDatabase * symboldatabase@var1095 , ErrorLogger * errorLogger@var1096 , const Settings * settings@var1097 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var1098 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var1099 , const Settings * settings@var1100 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var1101 ,
459: const Settings * settings@var1102 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var1103 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var1104 , const Token * indexTok@var1105 , bool possible@var1106 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var1107 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var1108 , const Settings * settings@var1109 = nullptr , int depth@var1110 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var1111 ;
471: bool addressOf@var1112 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1113 ;
473: bool inconclusive@var1114 ;
474:
475: LifetimeToken ( ) : token@var1111 ( nullptr ) , addressOf@var1112 ( false ) , errorPath@var1113 ( ) , inconclusive@var1114 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var1115 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1116 )
478: : token@var1111 ( token@var1115 ) , addressOf@var1112 ( false ) , errorPath@var1113 ( std :: move ( errorPath@var1116 ) ) , inconclusive@var1114 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var1117 , bool addressOf@var1118 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var1119 )
482: : token@var1111 ( token@var1117 ) , addressOf@var1112 ( addressOf@var1118 ) , errorPath@var1113 ( std :: move ( errorPath@var1119 ) ) , inconclusive@var1114 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var1120 , bool b@var1121 ) {
486: for (@expr1073744662 LifetimeToken &@expr1073744663 x@var1122 :@expr1073744664 v@var1120 ) {
487: x@var1122 .@expr1073744665 addressOf@var1123 =@expr1073744666 b@var1121 ; }
488: return v@var1120 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var1124 , bool b@var1125 ) {
492: for (@expr1073744667 LifetimeToken &@expr1073744668 x@var1126 :@expr1073744669 v@var1124 ) {
493: x@var1126 .@expr1073744670 inconclusive@var1127 =@expr1073744671 b@var1125 ; }
494: return v@var1124 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var1128 , ValueFlow :: Value & true_value@var1129 , ValueFlow :: Value & false_value@var1130 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var1131 ) ;
499: const Token * parseCompareInt ( const Token * tok@var1132 , ValueFlow :: Value & true_value@var1133 , ValueFlow :: Value & false_value@var1134 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var1135 , long long val@var1136 , const Token * varTok@var1137 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var1138 , const Token * varTok@var1139 , long long val@var1140 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var1141 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var1142 ,
508: ValueFlow :: Value & value@var1143 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var1144 ,
511: bool escape@var1145 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var1146 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var1147 , const Token * lifetime@var1148 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var1149 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1150 , bool * addressOf@var1151 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var1152 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var1153 , const Settings * settings@var1154 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var1155 , const ValueFlow :: Value * val@var1156 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var1157 , const ValueFlow :: Value * val@var1158 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1159 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var1160 , bool inconclusive@var1161 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var1162 ,
529: bool inconclusive@var1163 = false ,
530: long long path@var1164 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var1165 , const Scope * defaultScope@var1166 = nullptr , bool smallest@var1167 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var1168 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var1169 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var1170 ;
69: std :: string mScope@var1171 ;
70: std :: string mName@var1172 ;
71: std :: string mFullName@var1173 ;
72: const Token * mNameToken@var1174 ;
73: const Token * mParamEnd@var1175 ;
74: unsigned int mFlags@var1176 ;
75:
76: enum Anonymous2 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var1177 ) {
90: setFlag (@expr1073744672 fIsClass , state@var1177 ) ;
91: }
92: void isFunction ( bool state@var1178 ) {
93: setFlag (@expr1073744673 fIsFunction , state@var1178 ) ;
94: }
95: void isVariable ( bool state@var1179 ) {
96: setFlag (@expr1073744674 fIsVariable , state@var1179 ) ;
97: }
98: void isAlias ( bool state@var1180 ) {
99: setFlag (@expr1073744675 fIsAlias , state@var1180 ) ;
100: }
101: void isSpecialization ( bool state@var1181 ) {
102: setFlag (@expr1073744676 fIsSpecialization , state@var1181 ) ;
103: }
104: void isPartialSpecialization ( bool state@var1182 ) {
105: setFlag (@expr1073744677 fIsPartialSpecialization , state@var1182 ) ;
106: }
107: void isForwardDeclaration ( bool state@var1183 ) {
108: setFlag (@expr1073744678 fIsForwardDeclaration , state@var1183 ) ;
109: }
110: void isVariadic ( bool state@var1184 ) {
111: setFlag (@expr1073744679 fIsVariadic , state@var1184 ) ;
112: }
113: void isFriend ( bool state@var1185 ) {
114: setFlag (@expr1073744680 fIsFriend , state@var1185 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var1186 ) const {
123: return (@expr2857 (@expr2857 mFlags@var1176 &@expr1073744683 flag@var1186 ) !=@expr1073744684 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var1187 , bool state@var1188 ) {
132: mFlags@var1176 =@expr1073744685 state@var1188 ?@expr1073744686 mFlags@var1176 |@expr1073744687 flag@var1187 :@expr1073744688 mFlags@var1176 &@expr1073744689 ~@expr1073744690 flag@var1187 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var1189 , const std :: string & scope@var1190 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var1191 , const std :: string & scope@var1192 , const Token * nameToken@var1193 , const Token * paramEnd@var1194 ) ;
150: TokenAndName ( const TokenAndName & other@var1195 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var1196 ) const {
154: return mToken@var1170 ==@expr1073744691 rhs@var1196 .@expr1073744692 mToken@var1197 &&@expr1073744693 mScope@var1171 ==@expr1073744694 rhs@var1196 .@expr1073744695 mScope@var1198 &&@expr1073744696 mName@var1172 ==@expr1073744697 rhs@var1196 .@expr1073744698 mName@var1199 &&@expr1073744699 mFullName@var1173 ==@expr1073744700 rhs@var1196 .@expr1073744701 mFullName@var1200 &&@expr1073744702
155: mNameToken@var1174 ==@expr1073744703 rhs@var1196 .@expr1073744704 mNameToken@var1201 &&@expr1073744705 mParamEnd@var1175 ==@expr1073744706 rhs@var1196 .@expr1073744707 mParamEnd@var1202 &&@expr1073744708 mFlags@var1176 ==@expr1073744709 rhs@var1196 .@expr1073744710 mFlags@var1203 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var1170 ;
160: }
161: void token ( Token * token@var1204 ) {
162: mToken@var1170 =@expr1073744711 token@var1204 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var1171 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var1172 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var1173 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var1174 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var1175 ;
178: }
179: void paramEnd ( const Token * end@var1205 ) {
180: mParamEnd@var1175 =@expr1073744712 end@var1205 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744713 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744714 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744715 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744716 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744717 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744718 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744719 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744720 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744721 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var1206 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var1207 ) const {
243:
244:
245: return (@expr2898 (@expr2898 mFlags@var1176 &@expr1073744724 fFamilyMask ) &@expr1073744725 (@expr2898 decl@var1207 .@expr1073744727 mFlags@var1208 &@expr1073744728 fFamilyMask ) ) !=@expr1073744729 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var1209 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var1210 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var1211 , const unsigned long numberOfArguments@var1212 , bool variadic@var1213 , const char patternAfter@var1214 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var1215 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var1216 , int & namepos@var1217 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var1218 , int & namepos@var1219 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var1220 , int & namepos@var1221 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var1222 ,
306: bool & codeWithTemplates@var1223 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var1224 , bool isTemplate@var1225 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var1226 = nullptr , Token * backToken@var1227 = nullptr , bool isTemplate@var1228 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var1229 , Token * end@var1230 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var1231 , const std :: string & scope@var1232 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var1233 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var1234 ,
393: const std :: list < const Token * > & specializations@var1235 ,
394: const std :: time_t maxtime@var1236 ,
395: std :: set < std :: string > & expandedtemplates@var1237 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var1238 , const Token * tok@var1239 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1240 , const Token * tok@var1241 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var1242 ,
422: const TokenAndName & templateInstantiation@var1243 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var1244 ,
424: const std :: string & newName@var1245 ,
425: bool copy@var1246 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var1247 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1248 ,
435: const std :: string & newName@var1249 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var1250 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var1251 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var1252 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var1253 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var1254 ,
458: const Token * templateInstantiationNameToken@var1255 ,
459: const std :: list < const Token * > & specializations@var1256 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var1257 , const Token * end@var1258 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var1259 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var1260 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1261 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var1262 ,
487: const std :: string & indent@var1263 = "    " ) const ;
488: void printOut ( const std :: string & text@var1264 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var1265 ;
491: TokenList & mTokenList@var1266 ;
492: const Settings * mSettings@var1267 ;
493: ErrorLogger * mErrorLogger@var1268 ;
494: bool mChanged@var1269 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var1270 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var1271 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var1272 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var1273 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var1274 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var1275 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var1276 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var1277 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var1278 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var1279 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var1280 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1281 ;
57: Token * back@var1282 ;
58: const TokenList * list@var1283 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1284 , const Token * bodyEnd_@var1285 , const std :: set < std :: string > & usingNamespaces_@var1286 = std :: set < std :: string > ( ) ) : name@var1287 ( name_@var1284 ) , bodyEnd@var1288 ( bodyEnd_@var1285 ) , usingNamespaces@var1289 ( usingNamespaces_@var1286 ) { }
63: std :: string name@var1287 ;
64: const Token * const bodyEnd@var1288 ;
65: std :: set < std :: string > usingNamespaces@var1289 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1290 ;
70: int mFileIndex@var1291 ;
71: int mLineNumber@var1292 ;
72: int mColumn@var1293 ;
73: int mExprId@var1294 ;
74:
75:
76: Token * mAstOperand1@var1295 ;
77: Token * mAstOperand2@var1296 ;
78: Token * mAstParent@var1297 ;
79:
80:
81: const Scope * mScope@var1298 ;
82: union {
83: const Function * mFunction@var1299 ;
84: const Variable * mVariable@var1300 ;
85: const :: Type * mType@var1301 ;
86: const Enumerator * mEnumerator@var1302 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1303 ;
94:
|
97:
98: int mIndex@var1304 ;
99:
100:
101: std :: string * mOriginalName@var1305 ;
102:
103:
104: ValueType * mValueType@var1306 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1307 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1308 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1309 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1310 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1311 ;
119: long long value@var1312 ;
120: struct CppcheckAttributes * next@var1313 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1314 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1315 ;
126:
127:
128: unsigned char mBits@var1316 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1317 , long long value@var1318 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1319 , long long * value@var1320 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1290 ( 0 )
135: , mFileIndex@var1291 ( 0 )
136: , mLineNumber@var1292 ( 0 )
137: , mColumn@var1293 ( 0 )
138: , mExprId@var1294 ( 0 )
139: , mAstOperand1@var1295 ( nullptr )
140: , mAstOperand2@var1296 ( nullptr )
141: , mAstParent@var1297 ( nullptr )
142: , mScope@var1298 ( nullptr )
143: , mFunction@var1299 ( nullptr )
144: , mProgressValue@var1303 ( 0 )
145: , mIndex@var1304 ( 0 )
146: , mOriginalName@var1305 ( nullptr )
147: , mValueType@var1306 ( nullptr )
148: , mValues@var1307 ( nullptr )
149: , mTemplateSimplifierPointers@var1309 ( nullptr )
150: , mScopeInfo@var1310 ( nullptr )
151: , mCppcheckAttributes@var1314 ( nullptr )
152: , mCpp11init@var1315 ( Cpp11init :: UNKNOWN )
153: , mBits@var1316 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1321 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1322 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1323 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1324 ) {
199: mStr@var1536 =@expr1073744730 s@var1324 ;
200: mImpl@var1542 .@expr1073744731 mVarId@var1573 =@expr1073744732 0 ;
201:
202: update_property_info (@expr1073744733 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1325 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1536 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1326 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1327 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1328 ) const ;
236: Token * tokAt ( int index@var1329 ) {
237: return const_cast < Token *@expr2910 > (@expr1073744735 const_cast < const Token *@expr2910 > (@expr1073744737 this@expr1073744738 ) .@expr1073744739 tokAt (@expr1073744740 index@var1329 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1330 ) const ;
245: Token * linkAt ( int index@var1331 ) {
246: return const_cast < Token *@expr2917 > (@expr1073744742 const_cast < const Token *@expr2917 > (@expr1073744744 this@expr1073744745 ) .@expr1073744746 linkAt (@expr1073744747 index@var1331 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1332 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1333 , const char ( & pattern@var1334 ) [ count ] ) {
276: return simpleMatch (@expr1073744749 tok@var1333 , pattern@var1334 , count@expr1073744748 -@expr1073744750 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1335 , const char pattern@var1336 [ ] , unsigned long pattern_len@var1337 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1338 , const char pattern@var1339 [ ] , int varid@var1340 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1341 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1342 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1343 , const Settings * const settings@var1344 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1345 , long long index@var1346 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1542 .@expr1073744751 mValueType@var1574 ;
366: }
367: void setValueType ( ValueType * vt@var1347 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1348 ; top@var1348 =@expr1073744752 this@expr1073744753 ;
371: while (@expr1073744754 top@var1348 &&@expr1073744755 !@expr1073744756 Token ::@expr1073744757 Match (@expr1073744758 top@var1348 .@expr2935 astParent (@expr2936 ) , ",|(" ) ) {
372: top@var1348 =@expr1073744761 top@var1348 .@expr2935 astParent (@expr2936 ) ; }
373: return top@var1348 ?@expr1073744764 top@var1348 .@expr1073744765 mImpl@var1349 .@expr1073744766 mValueType@var1350 :@expr1073744767 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1540 ;
378: }
379: void tokType ( Token :: Type t@var1351 ) {
380: mTokType@var1540 =@expr1073744768 t@var1351 ;
381:
382: const bool memoizedIsName@var1352 =@expr1073744769 mTokType@var1540 ==@expr1073744770 eName ||@expr1073744771 mTokType@var1540 ==@expr1073744772 eType ||@expr1073744773 mTokType@var1540 ==@expr1073744774 eVariable ||@expr1073744775
383: mTokType@var1540 ==@expr1073744776 eFunction ||@expr1073744777 mTokType@var1540 ==@expr1073744778 eKeyword ||@expr1073744779 mTokType@var1540 ==@expr2956 eBoolean ||@expr1073744781
384: mTokType@var1540 ==@expr2958 eEnumerator ;
385: setFlag (@expr1073744783 fIsName , memoizedIsName@var1352 ) ;
386:
387: const bool memoizedIsLiteral@var1353 =@expr1073744784 mTokType@var1540 ==@expr1073744785 eNumber ||@expr1073744786 mTokType@var1540 ==@expr1073744787 eString ||@expr1073744788 mTokType@var1540 ==@expr1073744789 eChar ||@expr1073744790
388: mTokType@var1540 ==@expr2956 eBoolean ||@expr1073744792 mTokType@var1540 ==@expr1073744793 eLiteral ||@expr1073744794 mTokType@var1540 ==@expr2958 eEnumerator ;
389: setFlag (@expr1073744796 fIsLiteral , memoizedIsLiteral@var1353 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1540 ==@expr1073744797 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073744798 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1541 ==@expr1073744799 fIsName &&@expr1073744800 mTokType@var1540 ==@expr1073744801 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073744802 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1540 ==@expr1073744803 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1540 ==@expr1073744804 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073744805 isConstOp (@expr1073744806 ) ||@expr1073744807
412: isAssignmentOp (@expr1073744808 ) ||@expr1073744809
413: mTokType@var1540 ==@expr1073744810 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073744811 isArithmeticalOp (@expr1073744812 ) ||@expr1073744813
417: mTokType@var1540 ==@expr1073744814 eLogicalOp ||@expr1073744815
418: mTokType@var1540 ==@expr1073744816 eComparisonOp ||@expr1073744817
419: mTokType@var1540 ==@expr1073744818 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073744819 ) ||@expr1073744820
423: mTokType@var1540 ==@expr1073744821 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1540 ==@expr1073744822 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1540 ==@expr1073744823 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1540 ==@expr1073744824 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1540 ==@expr1073744825 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1540 ==@expr1073744826 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073744827 ) !=@expr1073744828 nullptr &&@expr1073744829 astOperand2 (@expr1073744830 ) !=@expr1073744831 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1354 ) const {
444: return s@var1354 ==@expr1073744832 mStr@var1536 &&@expr1073744833 astOperand1 (@expr1073744834 ) !=@expr1073744835 nullptr &&@expr1073744836 astOperand2 (@expr1073744837 ) ==@expr1073744838 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1541 ;
450: }
451: void flags ( const unsigned int flags_@var1355 ) {
452: mFlags@var1541 =@expr1073744839 flags_@var1355 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073744840 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1356 ) {
458: setFlag (@expr1073744841 fIsUnsigned , sign@var1356 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073744842 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1357 ) {
464: setFlag (@expr1073744843 fIsSigned , sign@var1357 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073744844 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1358 ) {
470: setFlag (@expr1073744845 fIsPointerCompare , b@var1358 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073744846 fIsLong ) ;
474: }
475: void isLong ( bool size@var1359 ) {
476: setFlag (@expr1073744847 fIsLong , size@var1359 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073744848 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1360 ) {
482: setFlag (@expr1073744849 fIsStandardType , b@var1360 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073744850 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1361 ) {
488: setFlag (@expr1073744851 fIsExpandedMacro , m@var1361 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073744852 fIsCast ) ;
492: }
493: void isCast ( bool c@var1362 ) {
494: setFlag (@expr1073744853 fIsCast , c@var1362 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073744854 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1363 ) {
500: setFlag (@expr1073744855 fIsAttributeConstructor , ac@var1363 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073744856 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1364 ) {
506: setFlag (@expr1073744857 fIsAttributeDestructor , value@var1364 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073744858 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1365 ) {
512: setFlag (@expr1073744859 fIsAttributeUnused , unused@var1365 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073744860 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1366 ) {
518: setFlag (@expr1073744861 fIsAttributeUsed , unused@var1366 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073744862 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1367 ) {
524: setFlag (@expr1073744863 fIsAttributePure , value@var1367 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073744864 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1368 ) {
530: setFlag (@expr1073744865 fIsAttributeConst , value@var1368 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073744866 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1369 ) {
536: setFlag (@expr1073744867 fIsAttributeNoreturn , value@var1369 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073744868 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1370 ) {
542: setFlag (@expr1073744869 fIsAttributeNothrow , value@var1370 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073744870 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1371 ) {
548: setFlag (@expr1073744871 fIsAttributePacked , value@var1371 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073744872 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1372 ) {
554: setFlag (@expr1073744873 fIsAttributeNodiscard , value@var1372 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073744874 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1373 ) {
560: setFlag (@expr1073744875 fIsAttributeMaybeUnused , value@var1373 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1374 , long long value@var1375 ) {
563: mImpl@var1542 .@expr1073744876 setCppcheckAttribute (@expr1073744877 type@var1374 , value@var1375 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1376 , long long * value@var1377 ) const {
566: return mImpl@var1542 .@expr1073744878 getCppcheckAttribute (@expr1073744879 type@var1376 , value@var1377 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073744880 mImpl@var1542 .@expr1073744881 mCppcheckAttributes@var1575 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073744882 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073744883 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1378 ) {
578: setFlag (@expr1073744884 fIsOperatorKeyword , value@var1378 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073744885 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1379 ) {
584: setFlag (@expr1073744886 fIsComplex , value@var1379 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073744887 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1380 ) {
590: setFlag (@expr1073744888 fIsEnumType , value@var1380 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073744889 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1381 ) {
596: setFlag (@expr1073744890 fAtAddress , b@var1381 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073744891 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1382 ) {
602: setFlag (@expr1073744892 fIncompleteVar , b@var1382 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073744893 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1383 ) {
609: setFlag (@expr1073744894 fIsIncompleteConstant , b@var1383 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073744895 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1384 ) {
616: setFlag (@expr1073744896 fConstexpr , b@var1384 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073744897 fExternC ) ;
621: }
622: void isExternC ( bool b@var1385 ) {
623: setFlag (@expr1073744898 fExternC , b@var1385 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073744899 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1386 ) {
630: setFlag (@expr1073744900 fIsSplitVarDeclComma , b@var1386 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073744901 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1387 ) {
637: setFlag (@expr1073744902 fIsSplitVarDeclEq , b@var1387 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073744903 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1388 ) {
644: setFlag (@expr1073744904 fIsImplicitInt , b@var1388 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073744905 fIsInline ) ;
649: }
650: void isInline ( bool b@var1389 ) {
651: setFlag (@expr1073744906 fIsInline , b@var1389 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073744907 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1390 ) {
658: setFlag (@expr1073744908 fIsRemovedVoidParameter , b@var1390 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073744909 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1391 ) {
665: setFlag (@expr1073744910 fIsTemplate , b@var1391 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073744911 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1392 ) {
672: setFlag (@expr1073744912 fIsSimplifedScope , b@var1392 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1542 .@expr1073744913 mBits@var1576 >@expr1073744914 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1542 .@expr1073744915 mBits@var1576 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1542 .@expr1073744916 mTemplateSimplifierPointers@var1577 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1393 ) {
685: if (@expr1073744917 !@expr1073744918 mImpl@var1542 .@expr3095 mTemplateSimplifierPointers@var1577 ) {
686: mImpl@var1542 .@expr3095 mTemplateSimplifierPointers@var1577 =@expr1073744921 new std ::@expr1073744922 set < TemplateSimplifier ::@expr1073744923 TokenAndName *@expr1073744924 > ; }
687: mImpl@var1542 .@expr3095 mTemplateSimplifierPointers@var1577 .@expr1073744926 insert (@expr1073744927 tokenAndName@var1393 ) ;
688: }
689: void setBits ( const unsigned char b@var1394 ) {
690: mImpl@var1542 .@expr1073744928 mBits@var1576 =@expr1073744929 b@var1394 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3106 (@expr3106 (@expr3106 mTokType@var1540 ==@expr1073744933 eString ) &&@expr1073744934 isPrefixStringCharLiteral (@expr1073744935 mStr@var1536 , '"' , "u8" ) ) ||@expr1073744936
695: (@expr3106 (@expr3106 mTokType@var1540 ==@expr1073744939 eChar ) &&@expr1073744940 isPrefixStringCharLiteral (@expr1073744941 mStr@var1536 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3118 (@expr3118 (@expr3118 mTokType@var1540 ==@expr1073744945 eString ) &&@expr1073744946 isPrefixStringCharLiteral (@expr1073744947 mStr@var1536 , '"' , "u" ) ) ||@expr1073744948
700: (@expr3118 (@expr3118 mTokType@var1540 ==@expr1073744951 eChar ) &&@expr1073744952 isPrefixStringCharLiteral (@expr1073744953 mStr@var1536 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3130 (@expr3130 (@expr3130 mTokType@var1540 ==@expr1073744957 eString ) &&@expr1073744958 isPrefixStringCharLiteral (@expr1073744959 mStr@var1536 , '"' , "U" ) ) ||@expr1073744960
705: (@expr3130 (@expr3130 mTokType@var1540 ==@expr1073744963 eChar ) &&@expr1073744964 isPrefixStringCharLiteral (@expr1073744965 mStr@var1536 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3142 (@expr3142 (@expr3142 mTokType@var1540 ==@expr1073744969 eString ) &&@expr1073744970 isPrefixStringCharLiteral (@expr1073744971 mStr@var1536 , '"' , "" ) ) ||@expr1073744972
710: (@expr3142 (@expr3142 mTokType@var1540 ==@expr1073744975 eChar ) &&@expr1073744976 isPrefixStringCharLiteral (@expr1073744977 mStr@var1536 , '\'' , "" ) &&@expr1073744978 mStr@var1536 .@expr1073744979 length (@expr1073744980 ) ==@expr1073744981 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3158 (@expr3158 (@expr3158 mTokType@var1540 ==@expr1073744985 eChar ) &&@expr1073744986 isPrefixStringCharLiteral (@expr1073744987 mStr@var1536 , '\'' , "" ) ) &&@expr1073744988
715: (@expr3158 mStr@var1536 .@expr1073744990 length (@expr1073744991 ) >@expr1073744992 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073744993 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1395 ) {
738: setFlag (@expr1073744994 fIsTemplateArg , value@var1395 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1396 , const char ( & pattern@var1397 ) [ count ] ) {
743: return findsimplematch (@expr1073744996 startTok@var1396 , pattern@var1397 , count@expr1073744995 -@expr1073744997 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1398 , const char pattern@var1399 [ ] , unsigned long pattern_len@var1400 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1401 , const char ( & pattern@var1402 ) [ count ] , const Token * const end@var1403 ) {
749: return findsimplematch (@expr1073744999 startTok@var1401 , pattern@var1402 , count@expr1073744998 -@expr1073745000 1 , end@var1403 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1404 , const char pattern@var1405 [ ] , unsigned long pattern_len@var1406 , const Token * const end@var1407 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1408 , const char pattern@var1409 [ ] , const int varId@var1410 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1411 , const char pattern@var1412 [ ] , const Token * const end@var1413 , const int varId@var1414 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1415 , const char ( & pattern@var1416 ) [ count ] ) {
758: return findsimplematch (@expr1073745002 startTok@var1415 , pattern@var1416 , count@expr1073745001 -@expr1073745003 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1417 , const char pattern@var1418 [ ] , unsigned long pattern_len@var1419 ) {
761: return const_cast < Token *@expr3180 > (@expr1073745005 findsimplematch (@expr1073745006 const_cast < const Token *@expr3180 > (@expr1073745008 startTok@var1417 ) , pattern@var1418 , pattern_len@var1419 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1420 , const char ( & pattern@var1421 ) [ count ] , const Token * const end@var1422 ) {
765: return findsimplematch (@expr1073745010 startTok@var1420 , pattern@var1421 , count@expr1073745009 -@expr1073745011 1 , end@var1422 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1423 , const char pattern@var1424 [ ] , unsigned long pattern_len@var1425 , const Token * const end@var1426 ) {
768: return const_cast < Token *@expr3188 > (@expr1073745013 findsimplematch (@expr1073745014 const_cast < const Token *@expr3188 > (@expr1073745016 startTok@var1423 ) , pattern@var1424 , pattern_len@var1425 , end@var1426 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1427 , const char pattern@var1428 [ ] , const int varId@var1429 = 0 ) {
772: return const_cast < Token *@expr3193 > (@expr1073745018 findmatch (@expr1073745019 const_cast < const Token *@expr3193 > (@expr1073745021 startTok@var1427 ) , pattern@var1428 , varId@var1429 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1430 , const char pattern@var1431 [ ] , const Token * const end@var1432 , const int varId@var1433 = 0 ) {
775: return const_cast < Token *@expr3198 > (@expr1073745023 findmatch (@expr1073745024 const_cast < const Token *@expr3198 > (@expr1073745026 startTok@var1430 ) , pattern@var1431 , end@var1432 , varId@var1433 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1434 , const char * haystack@var1435 , int varid@var1436 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1542 .@expr1073745027 mFileIndex@var1578 ;
796: }
797: void fileIndex ( int indexOfFile@var1437 ) {
798: mImpl@var1542 .@expr1073745028 mFileIndex@var1578 =@expr1073745029 indexOfFile@var1437 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1542 .@expr1073745030 mLineNumber@var1579 ;
803: }
804: void linenr ( int lineNumber@var1438 ) {
805: mImpl@var1542 .@expr1073745031 mLineNumber@var1579 =@expr1073745032 lineNumber@var1438 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1542 .@expr1073745033 mColumn@var1580 ;
810: }
811: void column ( int c@var1439 ) {
812: mImpl@var1542 .@expr1073745034 mColumn@var1580 =@expr1073745035 c@var1439 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1537 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1440 , const Token * end@var1441 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1442 , const std :: string & originalNameStr@var1443 = emptyString@var1 , bool prepend@var1444 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1445 , const std :: string & originalNameStr@var1446 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745036 tokenStr@var1445 , originalNameStr@var1446 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1538 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1542 .@expr1073745037 mVarId@var1573 ;
851: }
852: void varId ( int id@var1447 ) {
853: mImpl@var1542 .@expr1073745038 mVarId@var1573 =@expr1073745039 id@var1447 ;
854: if (@expr1073745040 id@var1447 !=@expr1073745041 0 ) {
855: tokType (@expr1073745042 eVariable ) ;
856: isStandardType (@expr1073745043 false ) ;
857: } else {
858: update_property_info (@expr1073745044 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745045 mImpl@var1542 .@expr3222 mExprId@var1581 ) {
864: return mImpl@var1542 .@expr3222 mExprId@var1581 ; }
865: return mImpl@var1542 .@expr1073745048 mVarId@var1573 ;
866: }
867: void exprId ( int id@var1448 ) {
868: mImpl@var1542 .@expr1073745049 mExprId@var1581 =@expr1073745050 id@var1448 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1449 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1450 , const std :: vector < std :: string > & fileNames@var1451 ) const ;
888:
|
891:
892: void printLines ( int lines@var1452 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1453 , Token * start@var1454 , Token * end@var1455 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1456 ; varid@var1456 = false ;
905: bool exprid@var1457 ; exprid@var1457 = false ;
906: bool idtype@var1458 ; idtype@var1458 = false ;
907: bool attributes@var1459 ; attributes@var1459 = false ;
908: bool macro@var1460 ; macro@var1460 = false ;
909: bool linenumbers@var1461 ; linenumbers@var1461 = false ;
910: bool linebreaks@var1462 ; linebreaks@var1462 = false ;
911: bool files@var1463 ; files@var1463 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1464 ;
914: options@var1464 .@expr1073745051 attributes@var1465 =@expr1073745052 true ;
915: options@var1464 .@expr1073745053 macro@var1466 =@expr1073745054 true ;
916: options@var1464 .@expr1073745055 linenumbers@var1467 =@expr1073745056 true ;
917: options@var1464 .@expr1073745057 linebreaks@var1468 =@expr1073745058 true ;
918: options@var1464 .@expr1073745059 files@var1469 =@expr1073745060 true ;
919: return options@var1464 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1470 ; options@var1470 =@expr1073745061 forDebug (@expr1073745062 ) ;
923: options@var1470 .@expr1073745063 varid@var1471 =@expr1073745064 true ;
924: return options@var1470 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1472 ; options@var1472 =@expr1073745065 forDebug (@expr1073745066 ) ;
928: options@var1472 .@expr1073745067 exprid@var1473 =@expr1073745068 true ;
929: return options@var1472 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1474 ; options@var1474 =@expr1073745069 forDebug (@expr1073745070 ) ;
933: options@var1474 .@expr1073745071 exprid@var1475 =@expr1073745072 true ;
934: options@var1474 .@expr1073745073 varid@var1476 =@expr1073745074 true ;
935: options@var1474 .@expr1073745075 idtype@var1477 =@expr1073745076 true ;
936: return options@var1474 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1478 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1479 , bool attributes@var1480 , bool macro@var1481 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1482 , const std :: vector < std :: string > * fileNames@var1483 = nullptr , const Token * end@var1484 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1485 , bool attributes@var1486 = true ) const ;
952: std :: string stringifyList ( bool varid@var1487 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1488 , bool attributes@var1489 , bool linenumbers@var1490 , bool linebreaks@var1491 , bool files@var1492 , const std :: vector < std :: string > * fileNames@var1493 = nullptr , const Token * end@var1494 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1495 ) {
983: mLink@var1539 =@expr1073745077 linkToToken@var1495 ;
984: if (@expr1073745078 mStr@var1536 ==@expr1073745079 "<" ||@expr1073745080 mStr@var1536 ==@expr1073745081 ">" ) {
985: update_property_info (@expr1073745082 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1539 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1496 ) {
1006: mImpl@var1542 .@expr1073745083 mScope@var1582 =@expr1073745084 s@var1496 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1542 .@expr1073745085 mScope@var1582 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1497 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1540 ==@expr1073745086 eFunction ||@expr1073745087 mTokType@var1540 ==@expr1073745088 eLambda ?@expr1073745089 mImpl@var1542 .@expr1073745090 mFunction@var1583 :@expr1073745091 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1498 ) {
1034: mImpl@var1542 .@expr1073745092 mVariable@var1584 =@expr1073745093 v@var1498 ;
1035: if (@expr1073745094 v@var1498 ||@expr1073745095 mImpl@var1542 .@expr1073745096 mVarId@var1573 ) {
1036: tokType (@expr1073745097 eVariable ) ; }
1037: else { if (@expr1073745098 mTokType@var1540 ==@expr1073745099 eVariable ) {
1038: tokType (@expr1073745100 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1540 ==@expr1073745101 eVariable ?@expr1073745102 mImpl@var1542 .@expr1073745103 mVariable@var1584 :@expr1073745104 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1499 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1540 ==@expr1073745105 eType ?@expr1073745106 mImpl@var1542 .@expr1073745107 mType@var1585 :@expr1073745108 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1500 , const Token * * typeTok@var1501 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1502 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1503 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1540 ==@expr1073745109 eEnumerator ?@expr1073745110 mImpl@var1542 .@expr1073745111 mEnumerator@var1586 :@expr1073745112 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1504 ) {
1079: mImpl@var1542 .@expr1073745113 mEnumerator@var1586 =@expr1073745114 e@var1504 ;
1080: if (@expr1073745115 e@var1504 ) {
1081: tokType (@expr1073745116 eEnumerator ) ; }
1082: else { if (@expr1073745117 mTokType@var1540 ==@expr1073745118 eEnumerator ) {
1083: tokType (@expr1073745119 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1505 , Token * end@var1506 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1507 , Token * srcEnd@var1508 , Token * newLocation@var1509 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1542 .@expr1073745120 mProgressValue@var1587 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1510 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1542 .@expr3297 mOriginalName@var1588 ?@expr1073745122 *@expr1073745123 mImpl@var1542 .@expr3297 mOriginalName@var1588 :@expr1073745125 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1542 .@expr3302 mValues@var1561 ?@expr1073745127 *@expr1073745128 mImpl@var1542 .@expr3302 mValues@var1561 :@expr1073745130 TokenImpl ::@expr1073745131 mEmptyValueList@var1308 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1511 ) {
1164: if (@expr1073745132 !@expr1073745133 mImpl@var1542 .@expr3310 mOriginalName@var1588 ) {
1165: mImpl@var1542 .@expr3310 mOriginalName@var1588 =@expr1073745136 new std ::@expr1073745137 string (@expr1073745138 name@var1511 ) ; }
1166: else {
1167: *@expr1073745139 mImpl@var1542 .@expr3310 mOriginalName@var1588 =@expr1073745141 name@var1511 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1512 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1513 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1514 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1542 .@expr1073745143 mValues@var1561 .@expr1073745144 front (@expr1073745145 ) .@expr1073745146 intvalue@expr1073745142 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1515 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1516 , long long path@var1517 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1518 , const Settings * settings@var1519 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1520 , const Settings * settings@var1521 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1522 , int argnr@var1523 , const Settings * settings@var1524 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1525 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1526 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1527 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1528 ) {
1200: if (@expr1073745147 mImpl@var1542 .@expr3324 mValues@var1561 ) {
1201: mImpl@var1542 .@expr3324 mValues@var1561 .@expr1073745150 remove_if (@expr1073745151 pred@var1528 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1542 .@expr1073745152 mIndex@var1589 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1529 ) {
1213: mNext@var1537 =@expr1073745153 nextToken@var1529 ;
1214: }
1215: void previous ( Token * previousToken@var1530 ) {
1216: mPrevious@var1538 =@expr1073745154 previousToken@var1530 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1531 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1532 , const char * word@var1533 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1534 , char c@var1535 ) ;
1235:
1236: std :: string mStr@var1536 ;
1237:
1238: Token * mNext@var1537 ;
1239: Token * mPrevious@var1538 ;
1240: Token * mLink@var1539 ;
1241:
1242: enum Anonymous3 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1540 ;
1283:
1284: uint64_t mFlags@var1541 ;
1285:
1286: TokenImpl * mImpl@var1542 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1543 ) const {
1294: return (@expr3331 (@expr3331 mFlags@var1541 &@expr1073745157 flag_@var1543 ) !=@expr1073745158 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1544 , bool state_@var1545 ) {
1303: mFlags@var1541 =@expr1073745159 state_@var1545 ?@expr1073745160 mFlags@var1541 |@expr1073745161 flag_@var1544 :@expr1073745162 mFlags@var1541 &@expr1073745163 ~@expr1073745164 flag_@var1544 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1546 , const int indent1@var1547 = 0 , const int indent2@var1548 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1549 ) ;
1321: void astOperand2 ( Token * tok@var1550 ) ;
1322: void astParent ( Token * tok@var1551 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1542 .@expr1073745165 mAstOperand1@var1552 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1542 .@expr1073745166 mAstOperand1@var1552 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1542 .@expr1073745167 mAstOperand2@var1553 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1542 .@expr1073745168 mAstOperand2@var1553 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1542 .@expr1073745169 mAstParent@var1554 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1542 .@expr1073745170 mAstParent@var1554 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745171 !@expr1073745172 astParent (@expr3349 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745174 this@expr3351 ==@expr1073745176 astParent (@expr3349 ) .@expr3354 astOperand1 (@expr3355 ) ) {
1346: return astParent (@expr3349 ) .@expr3357 astOperand2 (@expr3358 ) ; }
1347: else { if (@expr1073745183 this@expr3351 ==@expr1073745184 astParent (@expr3349 ) .@expr3357 astOperand2 (@expr3358 ) ) {
1348: return astParent (@expr3349 ) .@expr3354 astOperand1 (@expr3355 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745191 !@expr1073745192 astParent (@expr3369 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745194 this@expr3371 ==@expr1073745196 astParent (@expr3369 ) .@expr3374 astOperand1 (@expr3375 ) ) {
1356: return astParent (@expr3369 ) .@expr3377 astOperand2 (@expr3378 ) ; }
1357: else { if (@expr1073745203 this@expr3371 ==@expr1073745204 astParent (@expr3369 ) .@expr3377 astOperand2 (@expr3378 ) ) {
1358: return astParent (@expr3369 ) .@expr3374 astOperand1 (@expr3375 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1555 ; ret@var1555 =@expr1073745211 this@expr1073745212 ;
1364: while (@expr1073745213 ret@var1555 .@expr3390 mImpl@var1556 .@expr3391 mAstParent@var1557 ) {
1365: ret@var1555 =@expr1073745216 ret@var1555 .@expr3390 mImpl@var1556 .@expr3391 mAstParent@var1557 ; }
1366: return ret@var1555 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1558 ; ret@var1558 =@expr1073745219 this@expr1073745220 ;
1371: while (@expr1073745221 ret@var1558 .@expr3398 mImpl@var1559 .@expr3399 mAstParent@var1560 ) {
1372: ret@var1558 =@expr1073745224 ret@var1558 .@expr3398 mImpl@var1559 .@expr3399 mAstParent@var1560 ; }
1373: return ret@var1558 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1542 .@expr1073745227 mAstOperand1@var1552 =@expr1073745228 mImpl@var1542 .@expr1073745229 mAstOperand2@var1553 =@expr1073745230 mImpl@var1542 .@expr1073745231 mAstParent@var1554 =@expr1073745232 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1542 .@expr3409 mValues@var1561 ;
1393: mImpl@var1542 .@expr3409 mValues@var1561 =@expr1073745235 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1562 = "" ) const {
1397: std ::@expr1073745236 string ret@var1563 ;
1398: if (@expr1073745237 mImpl@var1542 .@expr3414 mAstOperand1@var1552 ) {
1399: ret@var1563 =@expr1073745239 mImpl@var1542 .@expr3414 mAstOperand1@var1552 .@expr1073745241 astString (@expr1073745242 sep@var1562 ) ; }
1400: if (@expr1073745243 mImpl@var1542 .@expr3420 mAstOperand2@var1553 ) {
1401: ret@var1563 +=@expr1073745245 mImpl@var1542 .@expr3420 mAstOperand2@var1553 .@expr1073745247 astString (@expr1073745248 sep@var1562 ) ; }
1402: return ret@var1563 +@expr1073745249 sep@var1562 +@expr1073745250 mStr@var1536 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1564 , bool xml@var1565 , const std :: vector < std :: string > & fileNames@var1566 , std :: ostream & out@var1567 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1568 , std :: ostream & out@var1569 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1570 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1571 ) const {
1419: mImpl@var1542 .@expr1073745251 mCpp11init@var1572 =@expr1073745252 cpp11init@var1571 ?@expr1073745253 TokenImpl ::@expr3430 Cpp11init ::@expr1073745255 CPP11INIT :@expr1073745256 TokenImpl ::@expr3430 Cpp11init ::@expr1073745258 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1542 .@expr1073745259 mCpp11init@var1572 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1590 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1591 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1592 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1593 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1594 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1595 ) {
47: mSettings@var1630 =@expr1073745260 settings@var1595 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1630 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1632 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1633 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1596 ) ;
72:
73: void addtoken ( const std :: string & str@var1597 , const int lineno@var1598 , const int column@var1599 , const int fileno@var1600 , bool split@var1601 = false ) ;
74: void addtoken ( const std :: string & str@var1602 , const Token * locationTok@var1603 ) ;
75:
76: void addtoken ( const Token * tok@var1604 , const int lineno@var1605 , const int column@var1606 , const int fileno@var1607 ) ;
77: void addtoken ( const Token * tok@var1608 , const Token * locationTok@var1609 ) ;
78: void addtoken ( const Token * tok@var1610 ) ;
79:
80: static void insertTokens ( Token * dest@var1611 , const Token * src@var1612 , int n@var1613 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1614 , const Token * first@var1615 , const Token * last@var1616 , bool one_line@var1617 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1618 , const std :: string & file0@var1619 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1620 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1621 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1627 .@expr1073745261 front@var1634 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1627 .@expr1073745262 front@var1634 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1627 .@expr1073745263 back@var1635 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1627 .@expr1073745264 back@var1635 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1628 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1622 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1623 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1624 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1625 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1626 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1627 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1628 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1629 ;
212:
213:
214: const Settings * mSettings@var1630 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1631 ;
217:
218:
219: bool mIsC@var1632 ;
220: bool mIsCpp@var1633 ;
221: } ;

##file cppcheck-2.8/lib/errorlogger.cpp

1:
|
39:
40: InternalError :: InternalError ( const Token * tok@var1636 , const std :: string & errorMsg@var1637 , Type type@var1638 ) :
41: token@var5 ( tok@var1636 ) , errorMessage@var6 ( errorMsg@var1637 ) , type@var7 ( type@var1638 )
42: {
43: switch (@expr1073745265 type@var1638 ) {
44: case AST :@expr3442 ;
45: id@var8 =@expr1073745267 "internalAstError" ;
46: break ;
47: case SYNTAX :@expr3442 ;
48: id@var8 =@expr1073745269 "syntaxError" ;
49: break ;
50: case UNKNOWN_MACRO :@expr3442 ;
51: id@var8 =@expr1073745271 "unknownMacro" ;
52: break ;
53: case INTERNAL :@expr3442 ;
54: id@var8 =@expr1073745273 "cppcheckError" ;
55: break ;
56: case LIMIT :@expr3442 ;
57: id@var8 =@expr1073745275 "cppcheckLimit" ;
58: break ;
59: case INSTANTIATION :@expr3442 ;
60: id@var8 =@expr1073745277 "instantiationError" ;
61: break ;
62: }
63: }
64: ErrorMessage :: ErrorMessage ( )
65: : incomplete@var146 ( false ) , severity@var147 ( Severity :: none ) , cwe@var148 ( 0U ) , certainty@var149 ( Certainty :: normal ) , hash@var150 ( 0 )
66: { }
67:
68: ErrorMessage :: ErrorMessage ( const std :: list < FileLocation > & callStack@var1639 , const std :: string & file1@var1640 , Severity :: SeverityType severity@var1641 , const std :: string & msg@var1642 , const std :: string & id@var1643 , Certainty :: CertaintyLevel certainty@var1644 ) :
69: callStack@var142 ( callStack@var1639 ) ,
70: id@var143 ( id@var1643 ) ,
71: file0@var144 ( file1@var1640 ) ,
72: incomplete@var146 ( false ) ,
73: severity@var147 ( severity@var1641 ) ,
74: cwe@var148 ( 0U ) ,
75: certainty@var149 ( certainty@var1644 ) ,
76: hash@var150 ( 0 )
77: {
78:
79: setmsg (@expr1073745278 msg@var1642 ) ;
80: }
81:
82:
83:
84: ErrorMessage :: ErrorMessage ( const std :: list < FileLocation > & callStack@var1645 , const std :: string & file1@var1646 , Severity :: SeverityType severity@var1647 , const std :: string & msg@var1648 , const std :: string & id@var1649 , const CWE & cwe@var1650 , Certainty :: CertaintyLevel certainty@var1651 ) :
85: callStack@var142 ( callStack@var1645 ) ,
86: id@var143 ( id@var1649 ) ,
87: file0@var144 ( file1@var1646 ) ,
88: incomplete@var146 ( false ) ,
89: severity@var147 ( severity@var1647 ) ,
90: cwe@var148 ( cwe@var1650 . id@var1652 ) ,
91: certainty@var149 ( certainty@var1651 ) ,
92: hash@var150 ( 0 )
93: {
94:
95: setmsg (@expr1073745279 msg@var1648 ) ;
96: }
97:
98: ErrorMessage :: ErrorMessage ( const std :: list < const Token * > & callstack@var1653 , const TokenList * list@var1654 , Severity :: SeverityType severity@var1655 , const std :: string & id@var1656 , const std :: string & msg@var1657 , Certainty :: CertaintyLevel certainty@var1658 )
99: : id@var143 ( id@var1656 ) , incomplete@var146 ( false ) , severity@var147 ( severity@var1655 ) , cwe@var148 ( 0U ) , certainty@var149 ( certainty@var1658 ) , hash@var150 ( 0 )
100: {
101:
102: for (@expr1073745280 std ::@expr3457 list < const Token *@expr1073745282 > ::@expr3457 const_iterator it@var1659 =@expr1073745284 callstack@var1653 .@expr1073745285 begin (@expr1073745286 ) ; it@var1659 !=@expr1073745287 callstack@var1653 .@expr1073745288 end (@expr1073745289 ) ; ++@expr1073745290 it@var1659 ) {
103:
104: if (@expr1073745291 !@expr1073745292 (@expr1073745293 *@expr3470 it@var1659 ) ) {
105: continue ; }
106:
107: callStack@var142 .@expr1073745295 emplace_back (@expr1073745296 *@expr3470 it@var1659 , list@var1654 ) ;
108: }
109:
110: if (@expr1073745298 list@var1654 &&@expr1073745299 !@expr1073745300 list@var1654 .@expr3477 getFiles (@expr3478 ) .@expr1073745303 empty (@expr1073745304 ) ) {
111: file0@var144 =@expr1073745305 list@var1654 .@expr3477 getFiles (@expr3478 ) [@expr1073745308 0 ] ; }
112:
113: setmsg (@expr1073745309 msg@var1657 ) ;
114: }
115:
116:
117: ErrorMessage :: ErrorMessage ( const std :: list < const Token * > & callstack@var1660 , const TokenList * list@var1661 , Severity :: SeverityType severity@var1662 , const std :: string & id@var1663 , const std :: string & msg@var1664 , const CWE & cwe@var1665 , Certainty :: CertaintyLevel certainty@var1666 )
118: : id@var143 ( id@var1663 ) , incomplete@var146 ( false ) , severity@var147 ( severity@var1662 ) , cwe@var148 ( cwe@var1665 . id@var1667 ) , certainty@var149 ( certainty@var1666 )
119: {
120:
121: for (@expr1073745310 const Token *@expr1073745311 tok@var1668 :@expr1073745312 callstack@var1660 ) {
122:
123: if (@expr1073745313 !@expr1073745314 tok@var1668 ) {
124: continue ; }
125:
126: callStack@var142 .@expr1073745315 emplace_back (@expr1073745316 tok@var1668 , list@var1661 ) ;
127: }
128:
129: if (@expr1073745317 list@var1661 &&@expr1073745318 !@expr1073745319 list@var1661 .@expr3496 getFiles (@expr3497 ) .@expr1073745322 empty (@expr1073745323 ) ) {
130: file0@var144 =@expr1073745324 list@var1661 .@expr3496 getFiles (@expr3497 ) [@expr1073745327 0 ] ; }
131:
132: setmsg (@expr1073745328 msg@var1664 ) ;
133:
134: hash@var150 =@expr1073745329 0 ;
135: }
136:
137: ErrorMessage :: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var1669 , const TokenList * tokenList@var1670 , Severity :: SeverityType severity@var1671 , const char id@var1672 [ ] , const std :: string & msg@var1673 , const CWE & cwe@var1674 , Certainty :: CertaintyLevel certainty@var1675 )
138: : id@var143 ( id@var1672 ) , incomplete@var146 ( false ) , severity@var147 ( severity@var1671 ) , cwe@var148 ( cwe@var1674 . id@var1676 ) , certainty@var149 ( certainty@var1675 )
139: {
140:
141: for (@expr1073745330 const std ::@expr3507 pair < const Token *@expr1073745332 , std ::@expr3507 string > &@expr3510 e@var1677 :@expr1073745335 errorPath@var1669 ) {
142: const Token * tok@var1678 ; tok@var1678 =@expr1073745336 e@var1677 .@expr1073745337 first@var1679 ;
143: std ::@expr1073745338 string info@var1680 ; info@var1680 =@expr1073745339 e@var1677 .@expr1073745340 second@var1681 ;
144:
145: if (@expr1073745341 info@var1680 .@expr1073745342 compare (@expr1073745343 0 , 8 , "$symbol:" ) ==@expr1073745344 0 &&@expr1073745345 info@var1680 .@expr3522 find (@expr3523 "\n" ) <@expr1073745348 info@var1680 .@expr1073745349 size (@expr1073745350 ) ) {
146: const std ::@expr3507 string ::@expr3507 size_type pos@var1682 =@expr1073745353 info@var1680 .@expr3522 find (@expr3523 "\n" ) ;
147: const std ::@expr3507 string &@expr3510 symbolName@var1683 =@expr1073745358 info@var1680 .@expr3535 substr (@expr1073745360 8 , pos@var1682 -@expr1073745361 8 ) ;
148: info@var1680 =@expr1073745362 replaceStr (@expr1073745363 info@var1680 .@expr3535 substr (@expr1073745365 pos@var1682 +@expr1073745366 1 ) , "$symbol" , symbolName@var1683 ) ;
149: }
150:
151:
152: if (@expr1073745367 tok@var1678 ) {
153: callStack@var142 .@expr1073745368 emplace_back (@expr1073745369 tok@var1678 , info@var1680 , tokenList@var1670 ) ; }
154: }
155:
156: if (@expr1073745370 tokenList@var1670 &&@expr1073745371 !@expr1073745372 tokenList@var1670 .@expr3549 getFiles (@expr3550 ) .@expr1073745375 empty (@expr1073745376 ) ) {
157: file0@var144 =@expr1073745377 tokenList@var1670 .@expr3549 getFiles (@expr3550 ) [@expr1073745380 0 ] ; }
158:
159: setmsg (@expr1073745381 msg@var1673 ) ;
160:
161: hash@var150 =@expr1073745382 0 ;
162: }
163:
164: ErrorMessage :: ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var1684 )
165: : incomplete@var146 ( false ) ,
166: severity@var147 ( Severity :: none ) ,
167: cwe@var148 ( 0U ) ,
168: certainty@var149 ( Certainty :: normal )
169: {
170: const char * const unknown@var1685 ; unknown@var1685 =@expr1073745385 "<UNKNOWN>" ;
171:
172: const char * attr@var1686 ; attr@var1686 =@expr1073745386 errmsg@var1684 .@expr3563 Attribute (@expr1073745388 "id" ) ;
173: id@var143 =@expr1073745389 attr@var1686 ?@expr1073745390 attr@var1686 :@expr1073745391 unknown@var1685 ;
174:
175: attr@var1686 =@expr1073745392 errmsg@var1684 .@expr3563 Attribute (@expr1073745394 "severity" ) ;
176: severity@var147 =@expr1073745395 attr@var1686 ?@expr1073745396 Severity ::@expr1073745397 fromString (@expr1073745398 attr@var1686 ) :@expr1073745399 Severity ::@expr1073745400 none@expr1073745383 ;
177:
178: attr@var1686 =@expr1073745401 errmsg@var1684 .@expr3563 Attribute (@expr1073745403 "cwe" ) ;
179: std ::@expr3580 istringstream (@expr3581 attr@var1686 ?@expr3582 attr@var1686 :@expr3583 "0" ) >>@expr1073745408 cwe@var148 .@expr1073745409 id@var1845 ;
180:
181: attr@var1686 =@expr1073745410 errmsg@var1684 .@expr3563 Attribute (@expr1073745412 "inconclusive" ) ;
182: certainty@var149 =@expr1073745413 (@expr1073745414 attr@var1686 &&@expr1073745415 (@expr1073745416 std ::@expr3593 strcmp (@expr1073745418 attr@var1686 , "true" ) ==@expr1073745419 0 ) ) ?@expr1073745420 Certainty ::@expr1073745421 inconclusive :@expr1073745422 Certainty ::@expr1073745423 normal@expr1073745384 ;
183:
184: attr@var1686 =@expr1073745424 errmsg@var1684 .@expr3563 Attribute (@expr1073745426 "msg" ) ;
185: mShortMessage@var153 =@expr1073745427 attr@var1686 ?@expr3604 attr@var1686 :@expr3605 "" ;
186:
187: attr@var1686 =@expr1073745430 errmsg@var1684 .@expr3563 Attribute (@expr1073745432 "verbose" ) ;
188: mVerboseMessage@var154 =@expr1073745433 attr@var1686 ?@expr3604 attr@var1686 :@expr3605 "" ;
189:
190: attr@var1686 =@expr1073745436 errmsg@var1684 .@expr3563 Attribute (@expr1073745438 "hash" ) ;
191: std ::@expr3580 istringstream (@expr3581 attr@var1686 ?@expr3582 attr@var1686 :@expr3583 "0" ) >>@expr1073745443 hash@var150 ;
192:
193: for (@expr1073745444 const tinyxml2 ::@expr1073745445 XMLElement *@expr1073745446 e@var1687 =@expr1073745447 errmsg@var1684 .@expr1073745448 FirstChildElement (@expr1073745449 ) ; e@var1687 ; e@var1687 =@expr1073745450 e@var1687 .@expr1073745451 NextSiblingElement (@expr1073745452 ) ) {
194: if (@expr1073745453 std ::@expr3593 strcmp (@expr1073745455 e@var1687 .@expr3632 Name (@expr3633 ) , "location" ) ==@expr1073745458 0 ) {
195: const char * strfile@var1688 ; strfile@var1688 =@expr1073745459 e@var1687 .@expr3636 Attribute (@expr1073745461 "file" ) ;
196: const char * strinfo@var1689 ; strinfo@var1689 =@expr1073745462 e@var1687 .@expr3636 Attribute (@expr1073745464 "info" ) ;
197: const char * strline@var1690 ; strline@var1690 =@expr1073745465 e@var1687 .@expr3636 Attribute (@expr1073745467 "line" ) ;
198: const char * strcolumn@var1691 ; strcolumn@var1691 =@expr1073745468 e@var1687 .@expr3636 Attribute (@expr1073745470 "column" ) ;
199:
200: const char * file@var1692 ; file@var1692 =@expr1073745471 strfile@var1688 ?@expr1073745472 strfile@var1688 :@expr1073745473 unknown@var1685 ;
201: const char * info@var1693 ; info@var1693 =@expr1073745474 strinfo@var1689 ?@expr1073745475 strinfo@var1689 :@expr1073745476 "" ;
202: const int line@var1694 =@expr1073745477 strline@var1690 ?@expr1073745478 std ::@expr3655 atoi (@expr1073745480 strline@var1690 ) :@expr1073745481 0 ;
203: const int column@var1695 =@expr1073745482 strcolumn@var1691 ?@expr1073745483 std ::@expr3655 atoi (@expr1073745485 strcolumn@var1691 ) :@expr1073745486 0 ;
204: callStack@var142 .@expr1073745487 emplace_front (@expr1073745488 file@var1692 , info@var1693 , line@var1694 , column@var1695 ) ;
205: } else { if (@expr1073745489 std ::@expr3593 strcmp (@expr1073745491 e@var1687 .@expr3632 Name (@expr3633 ) , "symbol" ) ==@expr1073745494 0 ) {
206: mSymbolNames@var155 +=@expr1073745495 e@var1687 .@expr1073745496 GetText (@expr1073745497 ) ;
207: } }
208: }
209: }
210:
211: void ErrorMessage :: setmsg ( const std :: string & msg@var1696 )
212: {
213:
|
217:
218: assert (@expr1073745499 !@expr1073745500 endsWith (@expr1073745501 msg@var1696 , '\n' ) ) ;
219:
|
222:
223: const std ::@expr3678 string ::@expr3678 size_type pos@var1697 =@expr1073745504 msg@var1696 .@expr1073745505 find (@expr1073745506 '\n' ) ;
224: const std ::@expr3678 string symbolName@var1698 =@expr1073745508 mSymbolNames@var155 .@expr1073745509 empty (@expr1073745510 ) ?@expr1073745511 std ::@expr3688 string (@expr1073745513 ) :@expr1073745514 mSymbolNames@var155 .@expr1073745515 substr (@expr1073745516 0 , mSymbolNames@var155 .@expr1073745517 find (@expr1073745518 '\n' ) ) ;
225: if (@expr1073745519 pos@var1697 ==@expr1073745520 std ::@expr3688 string ::@expr1073745522 npos@expr1073745498 ) {
226: mShortMessage@var153 =@expr1073745523 replaceStr (@expr3700 msg@var1696 , "$symbol" , symbolName@var1698 ) ;
227: mVerboseMessage@var154 =@expr1073745525 replaceStr (@expr3700 msg@var1696 , "$symbol" , symbolName@var1698 ) ;
228: } else { if (@expr1073745527 msg@var1696 .@expr1073745528 compare (@expr1073745529 0 , 8 , "$symbol:" ) ==@expr1073745530 0 ) {
229: mSymbolNames@var155 +=@expr1073745531 msg@var1696 .@expr3708 substr (@expr1073745533 8 , pos@var1697 -@expr1073745534 7 ) ;
230: setmsg (@expr1073745535 msg@var1696 .@expr3708 substr (@expr3713 pos@var1697 +@expr3714 1 ) ) ;
231: } else {
232: mShortMessage@var153 =@expr1073745539 replaceStr (@expr1073745540 msg@var1696 .@expr3708 substr (@expr1073745542 0 , pos@var1697 ) , "$symbol" , symbolName@var1698 ) ;
233: mVerboseMessage@var154 =@expr1073745543 replaceStr (@expr1073745544 msg@var1696 .@expr3708 substr (@expr3713 pos@var1697 +@expr3714 1 ) , "$symbol" , symbolName@var1698 ) ;
234: } }
235: }
236:
237: Suppressions :: ErrorMessage ErrorMessage :: toSuppressionsErrorMessage ( ) const
238: {
239: Suppressions ::@expr1073745548 ErrorMessage ret@var1699 ;
240: ret@var1699 .@expr1073745549 hash@var1700 =@expr1073745550 hash@var150 ;
241: ret@var1699 .@expr1073745551 errorId@var1701 =@expr1073745552 id@var143 ;
242: if (@expr1073745553 !@expr1073745554 callStack@var142 .@expr1073745555 empty (@expr1073745556 ) ) {
243: ret@var1699 .@expr1073745557 setFileName (@expr1073745558 callStack@var142 .@expr3735 back (@expr3736 ) .@expr1073745561 getfile (@expr1073745562 false ) ) ;
244: ret@var1699 .@expr3739 lineNumber@var1702 =@expr1073745564 callStack@var142 .@expr3735 back (@expr3736 ) .@expr1073745567 line@var1853 ;
245: } else {
246: ret@var1699 .@expr3739 lineNumber@var1702 =@expr1073745569 Suppressions ::@expr1073745570 Suppression ::@expr1073745571 NO_LINE ;
247: }
248: ret@var1699 .@expr1073745572 certainty@var1703 =@expr1073745573 certainty@var149 ;
249: ret@var1699 .@expr1073745574 symbolNames@var1704 =@expr1073745575 mSymbolNames@var155 ;
250: return ret@var1699 ;
251: }
252:
253:
254: std :: string ErrorMessage :: serialize ( ) const
255: {
256:
257: std ::@expr1073745576 ostringstream oss@var1705 ;
258: oss@var1705 <<@expr1073745577 id@var143 .@expr1073745578 length (@expr1073745579 ) <<@expr1073745580 " " <<@expr1073745581 id@var143 ;
259: oss@var1705 <<@expr1073745582 Severity ::@expr3759 toString (@expr3760 severity@var147 ) .@expr1073745585 length (@expr1073745586 ) <<@expr1073745587 " " <<@expr1073745588 Severity ::@expr3759 toString (@expr3760 severity@var147 ) ;
260: oss@var1705 <<@expr1073745591 MathLib ::@expr3768 toString (@expr3769 cwe@var148 .@expr3770 id@var1845 ) .@expr1073745595 length (@expr1073745596 ) <<@expr1073745597 " " <<@expr1073745598 MathLib ::@expr3768 toString (@expr3769 cwe@var148 .@expr3770 id@var1845 ) ;
261: oss@var1705 <<@expr1073745602 MathLib ::@expr3768 toString (@expr3780 hash@var150 ) .@expr1073745605 length (@expr1073745606 ) <<@expr1073745607 " " <<@expr1073745608 MathLib ::@expr3768 toString (@expr3780 hash@var150 ) ;
262: oss@var1705 <<@expr1073745611 file0@var144 .@expr1073745612 size (@expr1073745613 ) <<@expr1073745614 " " <<@expr1073745615 file0@var144 ;
263: if (@expr1073745616 certainty@var149 ==@expr1073745617 Certainty ::@expr1073745618 inconclusive ) {
264: const std ::@expr1073745619 string text@var1706 (@expr1073745620 "inconclusive" ) ;
265: oss@var1705 <<@expr1073745621 text@var1706 .@expr1073745622 length (@expr1073745623 ) <<@expr1073745624 " " <<@expr1073745625 text@var1706 ;
266: }
267:
268: const std ::@expr3802 string saneShortMessage@var1707 =@expr1073745627 fixInvalidChars (@expr1073745628 mShortMessage@var153 ) ;
269: const std ::@expr3802 string saneVerboseMessage@var1708 =@expr1073745630 fixInvalidChars (@expr1073745631 mVerboseMessage@var154 ) ;
270:
271: oss@var1705 <<@expr1073745632 saneShortMessage@var1707 .@expr1073745633 length (@expr1073745634 ) <<@expr1073745635 " " <<@expr1073745636 saneShortMessage@var1707 ;
272: oss@var1705 <<@expr1073745637 saneVerboseMessage@var1708 .@expr1073745638 length (@expr1073745639 ) <<@expr1073745640 " " <<@expr1073745641 saneVerboseMessage@var1708 ;
273: oss@var1705 <<@expr1073745642 callStack@var142 .@expr1073745643 size (@expr1073745644 ) <<@expr1073745645 " " ;
274:
275: for (@expr1073745646 std ::@expr3802 list < ErrorMessage ::@expr3802 FileLocation > ::@expr3802 const_iterator loc@var1709 =@expr1073745650 callStack@var142 .@expr1073745651 begin (@expr1073745652 ) ; loc@var1709 !=@expr1073745653 callStack@var142 .@expr1073745654 end (@expr1073745655 ) ; ++@expr1073745656 loc@var1709 ) {
276: std ::@expr1073745657 ostringstream smallStream@var1710 ;
277: smallStream@var1710 <<@expr1073745658 (@expr3835 *@expr3836 loc@var1709 ) .@expr1073745661 line@var1711 <<@expr1073745662 '\t' <<@expr1073745663 (@expr3835 *@expr3836 loc@var1709 ) .@expr1073745666 column@var1712 <<@expr1073745667 '\t' <<@expr1073745668 (@expr3835 *@expr3836 loc@var1709 ) .@expr1073745671 getfile (@expr1073745672 false ) <<@expr1073745673 '\t' <<@expr1073745674 loc@var1709 .@expr1073745675 getOrigFile (@expr1073745676 false ) <<@expr1073745677 '\t' <<@expr1073745678 loc@var1709 .@expr1073745679 getinfo (@expr1073745680 ) ;
278: oss@var1705 <<@expr1073745681 smallStream@var1710 .@expr3858 str (@expr3859 ) .@expr1073745684 length (@expr1073745685 ) <<@expr1073745686 " " <<@expr1073745687 smallStream@var1710 .@expr3858 str (@expr3859 ) ;
279: }
280:
281: return oss@var1705 .@expr1073745690 str (@expr1073745691 ) ;
282: }
283:
284: bool ErrorMessage :: deserialize ( const std :: string & data@var1713 )
285: {
286: certainty@var149 =@expr1073745694 Certainty ::@expr1073745695 normal@expr1073745692 ;
287: callStack@var142 .@expr1073745696 clear (@expr1073745697 ) ;
288: std ::@expr1073745698 istringstream iss@var1714 (@expr1073745699 data@var1713 ) ;
289: std ::@expr1073745700 array < std ::@expr3877 string , 7 > results@var1715 ;
290: unsigned long elem@var1716 ; elem@var1716 =@expr1073745702 0 ;
291: while (@expr1073745703 iss@var1714 .@expr3880 good (@expr3881 ) &&@expr1073745706 elem@var1716 <@expr1073745707 7 ) {
292: unsigned int len@var1717 ; len@var1717 =@expr1073745708 0 ;
293: if (@expr1073745709 !@expr1073745710 (@expr1073745711 iss@var1714 >>@expr1073745712 len@var1717 ) ) {
294: return false ; }
295:
296: iss@var1714 .@expr3889 get (@expr3890 ) ;
297: std ::@expr1073745715 string temp@var1718 ;
298: for (@expr1073745716 unsigned int i@var1719 =@expr1073745717 0 ; i@var1719 <@expr1073745718 len@var1717 &&@expr1073745719 iss@var1714 .@expr3880 good (@expr3881 ) ; ++@expr1073745722 i@var1719 ) {
299: const char c@var1720 =@expr1073745723 static_cast < char > (@expr3900 iss@var1714 .@expr3889 get (@expr3890 ) ) ;
300: temp@var1718 .@expr1073745727 append (@expr1073745728 1 , c@var1720 ) ;
301: }
302:
303: if (@expr1073745729 temp@var1718 ==@expr1073745730 "inconclusive" ) {
304: certainty@var149 =@expr1073745731 Certainty ::@expr1073745732 inconclusive ;
305: continue ;
306: }
307:
308: results@var1715 [@expr1073745733 elem@var1716 ++@expr1073745734 ] =@expr1073745735 temp@var1718 ;
309: }
310:
311: if (@expr1073745736 elem@var1716 !=@expr1073745737 7 ) {
312: throw InternalError (@expr1073745738 nullptr , "Internal Error: Deserialization of error message failed" ) ; }
313:
314: id@var143 =@expr1073745739 results@var1715 [@expr1073745740 0 ] ;
315: severity@var147 =@expr1073745741 Severity ::@expr1073745742 fromString (@expr1073745743 results@var1715 [@expr1073745744 1 ] ) ;
316: std ::@expr3921 istringstream (@expr1073745746 results@var1715 [@expr1073745747 2 ] ) >>@expr1073745748 cwe@var148 .@expr1073745749 id@var1845 ;
317: std ::@expr3921 istringstream (@expr1073745751 results@var1715 [@expr1073745752 3 ] ) >>@expr1073745753 hash@var150 ;
318: std ::@expr3921 istringstream (@expr1073745755 results@var1715 [@expr1073745756 4 ] ) >>@expr1073745757 file0@var144 ;
319: mShortMessage@var153 =@expr1073745758 results@var1715 [@expr1073745759 5 ] ;
320: mVerboseMessage@var154 =@expr1073745760 results@var1715 [@expr1073745761 6 ] ;
321:
322: unsigned int stackSize@var1721 ; stackSize@var1721 =@expr1073745762 0 ;
323: if (@expr1073745763 !@expr1073745764 (@expr1073745765 iss@var1714 >>@expr1073745766 stackSize@var1721 ) ) {
324: return false ; }
325:
326: while (@expr1073745767 iss@var1714 .@expr3880 good (@expr3881 ) ) {
327: unsigned int len@var1722 ; len@var1722 =@expr1073745770 0 ;
328: if (@expr1073745771 !@expr1073745772 (@expr1073745773 iss@var1714 >>@expr1073745774 len@var1722 ) ) {
329: return false ; }
330:
331: iss@var1714 .@expr3889 get (@expr3890 ) ;
332: std ::@expr1073745777 string temp@var1723 ;
333: for (@expr1073745778 unsigned int i@var1724 =@expr1073745779 0 ; i@var1724 <@expr1073745780 len@var1722 &&@expr1073745781 iss@var1714 .@expr3880 good (@expr3881 ) ; ++@expr1073745784 i@var1724 ) {
334: const char c@var1725 =@expr1073745785 static_cast < char > (@expr3900 iss@var1714 .@expr3889 get (@expr3890 ) ) ;
335: temp@var1723 .@expr1073745789 append (@expr1073745790 1 , c@var1725 ) ;
336: }
337:
338: std ::@expr1073745791 vector < std ::@expr3877 string > substrings@var1726 ;
339: for (@expr1073745793 std ::@expr3877 string ::@expr3877 size_type pos@var1727 =@expr1073745796 0 ; pos@var1727 <@expr1073745797 temp@var1723 .@expr1073745798 size (@expr1073745799 ) &&@expr1073745800 substrings@var1726 .@expr3977 size (@expr3978 ) <@expr1073745803 5 ; ++@expr1073745804 pos@var1727 ) {
340: if (@expr1073745805 substrings@var1726 .@expr3977 size (@expr3978 ) ==@expr1073745808 4 ) {
341: substrings@var1726 .@expr3985 push_back (@expr1073745810 temp@var1723 .@expr3987 substr (@expr1073745812 pos@var1727 ) ) ;
342: break ;
343: }
344: const std ::@expr3877 string ::@expr3877 size_type start@var1728 =@expr1073745815 pos@var1727 ;
345: pos@var1727 =@expr1073745816 temp@var1723 .@expr1073745817 find (@expr1073745818 "\t" , pos@var1727 ) ;
346: if (@expr1073745819 pos@var1727 ==@expr1073745820 std ::@expr1073745821 string ::@expr1073745822 npos@expr1073745693 ) {
347: substrings@var1726 .@expr3985 push_back (@expr1073745824 temp@var1723 .@expr3987 substr (@expr1073745826 start@var1728 ) ) ;
348: break ;
349: }
350: substrings@var1726 .@expr3985 push_back (@expr1073745828 temp@var1723 .@expr3987 substr (@expr1073745830 start@var1728 , pos@var1727 -@expr1073745831 start@var1728 ) ) ;
351: }
352: if (@expr1073745832 substrings@var1726 .@expr3977 size (@expr3978 ) <@expr1073745835 4 ) {
353: throw InternalError (@expr1073745836 nullptr , "Internal Error: serializing/deserializing of error message failed!" ) ; }
354:
355:
356:
357: ErrorMessage ::@expr1073745837 FileLocation loc@var1729 (@expr1073745838 substrings@var1726 [@expr1073745839 3 ] , MathLib ::@expr4016 toLongNumber (@expr1073745841 substrings@var1726 [@expr1073745842 0 ] ) , MathLib ::@expr4016 toLongNumber (@expr1073745844 substrings@var1726 [@expr1073745845 1 ] ) ) ;
358: loc@var1729 .@expr1073745846 setfile (@expr1073745847 substrings@var1726 [@expr1073745848 2 ] ) ;
359: if (@expr1073745849 substrings@var1726 .@expr3977 size (@expr3978 ) ==@expr1073745852 5 ) {
360: loc@var1729 .@expr1073745853 setinfo (@expr1073745854 substrings@var1726 [@expr1073745855 4 ] ) ; }
361:
362: callStack@var142 .@expr1073745856 push_back (@expr1073745857 loc@var1729 ) ;
363:
364: if (@expr1073745858 callStack@var142 .@expr1073745859 size (@expr1073745860 ) >=@expr1073745861 stackSize@var1721 ) {
365: break ; }
366: }
367:
368: return true ;
369: }
370:
371: std :: string ErrorMessage :: getXMLHeader ( )
372: {
373: tinyxml2 ::@expr1073745862 XMLPrinter printer@var1730 ;
374:
375:
376: printer@var1730 .@expr1073745863 PushDeclaration (@expr1073745864 "xml version=\"1.0\" encoding=\"UTF-8\"" ) ;
377:
378:
379: printer@var1730 .@expr4041 OpenElement (@expr1073745866 "results" , false ) ;
380:
381: printer@var1730 .@expr4043 PushAttribute (@expr1073745868 "version" , 2 ) ;
382: printer@var1730 .@expr4041 OpenElement (@expr1073745870 "cppcheck" , false ) ;
383: printer@var1730 .@expr4043 PushAttribute (@expr1073745872 "version" , CppCheck ::@expr1073745873 version (@expr1073745874 ) ) ;
384: printer@var1730 .@expr1073745875 CloseElement (@expr1073745876 false ) ;
385: printer@var1730 .@expr4041 OpenElement (@expr1073745878 "errors" , false ) ;
386:
387: return std ::@expr1073745879 string (@expr1073745880 printer@var1730 .@expr1073745881 CStr (@expr1073745882 ) ) +@expr1073745883 '>' ;
388: }
389:
390: std :: string ErrorMessage :: getXMLFooter ( )
391: {
392: return "    </errors>\n</results>" ;
393: }
394:
395:
396:
397: std :: string ErrorMessage :: fixInvalidChars ( const std :: string & raw@var1731 )
398: {
399: std ::@expr1073745884 string result@var1732 ;
400: result@var1732 .@expr1073745885 reserve (@expr1073745886 raw@var1731 .@expr1073745887 length (@expr1073745888 ) ) ;
401: std ::@expr1073745889 string ::@expr1073745890 const_iterator from@var1733 ; from@var1733 =@expr1073745891 raw@var1731 .@expr1073745892 begin (@expr1073745893 ) ;
402: while (@expr1073745894 from@var1733 !=@expr1073745895 raw@var1731 .@expr1073745896 end (@expr1073745897 ) ) {
403: if (@expr1073745898 std ::@expr1073745899 isprint (@expr1073745900 static_cast < unsigned char > (@expr1073745901 *@expr4078 from@var1733 ) ) ) {
404: result@var1732 .@expr1073745903 push_back (@expr1073745904 *@expr4078 from@var1733 ) ;
405: } else {
406: std ::@expr1073745906 ostringstream es@var1734 ;
407:
408: const unsigned int uFrom@var1735 =@expr1073745907 (@expr1073745908 unsigned char ) *@expr4078 from@var1733 ;
409: es@var1734 <<@expr1073745910 '\\' <<@expr1073745911 std ::@expr1073745912 setbase (@expr1073745913 8 ) <<@expr1073745914 std ::@expr1073745915 setw (@expr1073745916 3 ) <<@expr1073745917 std ::@expr1073745918 setfill (@expr1073745919 '0' ) <<@expr1073745920 uFrom@var1735 ;
410: result@var1732 +=@expr1073745921 es@var1734 .@expr1073745922 str (@expr1073745923 ) ;
411: }
412: ++@expr1073745924 from@var1733 ;
413: }
414: return result@var1732 ;
415: }
416:
417: std :: string ErrorMessage :: toXML ( ) const
418: {
419: tinyxml2 ::@expr1073745926 XMLPrinter printer@var1736 (@expr1073745927 nullptr , false , 2 ) ;
420: printer@var1736 .@expr4104 OpenElement (@expr1073745929 "error" , false ) ;
421: printer@var1736 .@expr4106 PushAttribute (@expr1073745931 "id" , id@var143 .@expr1073745932 c_str (@expr1073745933 ) ) ;
422: printer@var1736 .@expr4106 PushAttribute (@expr1073745935 "severity" , Severity ::@expr1073745936 toString (@expr1073745937 severity@var147 ) .@expr1073745938 c_str (@expr1073745939 ) ) ;
423: printer@var1736 .@expr4106 PushAttribute (@expr1073745941 "msg" , fixInvalidChars (@expr1073745942 mShortMessage@var153 ) .@expr1073745943 c_str (@expr1073745944 ) ) ;
424: printer@var1736 .@expr4106 PushAttribute (@expr1073745946 "verbose" , fixInvalidChars (@expr1073745947 mVerboseMessage@var154 ) .@expr1073745948 c_str (@expr1073745949 ) ) ;
425: if (@expr1073745950 cwe@var148 .@expr4127 id@var1845 ) {
426: printer@var1736 .@expr4106 PushAttribute (@expr1073745953 "cwe" , cwe@var148 .@expr4127 id@var1845 ) ; }
427: if (@expr1073745955 hash@var150 ) {
428: printer@var1736 .@expr4106 PushAttribute (@expr1073745957 "hash" , MathLib ::@expr1073745958 toString (@expr1073745959 hash@var150 ) .@expr1073745960 c_str (@expr1073745961 ) ) ; }
429: if (@expr1073745962 certainty@var149 ==@expr1073745963 Certainty ::@expr1073745964 inconclusive ) {
430: printer@var1736 .@expr4106 PushAttribute (@expr1073745966 "inconclusive" , "true" ) ; }
431:
432: if (@expr1073745967 !@expr1073745968 file0@var144 .@expr1073745969 empty (@expr1073745970 ) ) {
433: printer@var1736 .@expr4106 PushAttribute (@expr1073745972 "file0" , file0@var144 .@expr1073745973 c_str (@expr1073745974 ) ) ; }
434:
435: for (@expr1073745975 std ::@expr4152 list < FileLocation > ::@expr4152 const_reverse_iterator it@var1737 =@expr1073745978 callStack@var142 .@expr1073745979 rbegin (@expr1073745980 ) ; it@var1737 !=@expr1073745981 callStack@var142 .@expr1073745982 rend (@expr1073745983 ) ; ++@expr1073745984 it@var1737 ) {
436: printer@var1736 .@expr4104 OpenElement (@expr1073745986 "location" , false ) ;
437: printer@var1736 .@expr4106 PushAttribute (@expr1073745988 "file" , (@expr4165 *@expr4166 it@var1737 ) .@expr1073745991 getfile (@expr1073745992 ) .@expr1073745993 c_str (@expr1073745994 ) ) ;
438: printer@var1736 .@expr4106 PushAttribute (@expr1073745996 "line" , std ::@expr1073745997 max (@expr1073745998 (@expr4165 *@expr4166 it@var1737 ) .@expr1073746001 line@var1738 , 0 ) ) ;
439: printer@var1736 .@expr4106 PushAttribute (@expr1073746003 "column" , (@expr4165 *@expr4166 it@var1737 ) .@expr1073746006 column@var1739 ) ;
440: if (@expr1073746007 !@expr1073746008 it@var1737 .@expr4185 getinfo (@expr4186 ) .@expr1073746011 empty (@expr1073746012 ) ) {
441: printer@var1736 .@expr4106 PushAttribute (@expr1073746014 "info" , fixInvalidChars (@expr1073746015 it@var1737 .@expr4185 getinfo (@expr4186 ) ) .@expr1073746018 c_str (@expr1073746019 ) ) ; }
442: printer@var1736 .@expr4196 CloseElement (@expr4197 false ) ;
443: }
444: for (@expr1073746022 std ::@expr4152 string ::@expr4152 size_type pos@var1740 =@expr1073746025 0 ; pos@var1740 <@expr1073746026 mSymbolNames@var155 .@expr1073746027 size (@expr1073746028 ) ; ) {
445: const std ::@expr4152 string ::@expr4152 size_type pos2@var1741 =@expr1073746031 mSymbolNames@var155 .@expr1073746032 find (@expr1073746033 '\n' , pos@var1740 ) ;
446: std ::@expr1073746034 string symbolName@var1742 ;
447: if (@expr1073746035 pos2@var1741 ==@expr1073746036 std ::@expr1073746037 string ::@expr1073746038 npos@expr1073745925 ) {
448: symbolName@var1742 =@expr1073746039 mSymbolNames@var155 .@expr4216 substr (@expr1073746041 pos@var1740 ) ;
449: pos@var1740 =@expr1073746042 pos2@var1741 ;
450: } else {
451: symbolName@var1742 =@expr1073746043 mSymbolNames@var155 .@expr4216 substr (@expr1073746045 pos@var1740 , pos2@var1741 -@expr1073746046 pos@var1740 ) ;
452: pos@var1740 =@expr1073746047 pos2@var1741 +@expr1073746048 1 ;
453: }
454: printer@var1736 .@expr4104 OpenElement (@expr1073746050 "symbol" , false ) ;
455: printer@var1736 .@expr1073746051 PushText (@expr1073746052 symbolName@var1742 .@expr1073746053 c_str (@expr1073746054 ) ) ;
456: printer@var1736 .@expr4196 CloseElement (@expr4197 false ) ;
457: }
458: printer@var1736 .@expr4196 CloseElement (@expr4197 false ) ;
459: return printer@var1736 .@expr1073746059 CStr (@expr1073746060 ) ;
460: }
461:
|
468:
469: static void findAndReplace ( std :: string & source@var1743 , const std :: string & searchFor@var1744 , const std :: string & replaceWith@var1745 )
470: {
471: std ::@expr4238 string ::@expr1073746063 size_type index@var1746 ; index@var1746 =@expr1073746064 0 ;
472: while (@expr1073746065 (@expr1073746066 index@var1746 =@expr1073746067 source@var1743 .@expr1073746068 find (@expr1073746069 searchFor@var1744 , index@var1746 ) ) !=@expr1073746070 std ::@expr4238 string ::@expr1073746072 npos@expr1073746061 ) {
473: source@var1743 .@expr1073746073 replace (@expr1073746074 index@var1746 , searchFor@var1744 .@expr1073746075 length (@expr1073746076 ) , replaceWith@var1745 ) ;
474: index@var1746 +=@expr1073746077 replaceWith@var1745 .@expr1073746078 length (@expr1073746079 ) ;
475: }
476: }
477:
478:
479: static std :: string readCode ( const std :: string & file@var1747 , int linenr@var1748 , int column@var1749 , const char endl@var1750 [ ] )
480: {
481: std ::@expr1073746081 ifstream fin@var1751 (@expr1073746082 file@var1747 ) ;
482: std ::@expr1073746083 string line@var1752 ;
483: while (@expr1073746084 linenr@var1748 >@expr1073746085 0 &&@expr1073746086 std ::@expr1073746087 getline (@expr1073746088 fin@var1751 , line@var1752 ) ) {
484: linenr@var1748 --@expr1073746089 ;
485: }
486: const std ::@expr4266 string ::@expr4266 size_type endPos@var1753 =@expr1073746092 line@var1752 .@expr1073746093 find_last_not_of (@expr1073746094 "\r\n\t " ) ;
487: if (@expr1073746095 endPos@var1753 +@expr4272 1 <@expr1073746097 line@var1752 .@expr1073746098 size (@expr1073746099 ) ) {
488: line@var1752 .@expr1073746100 erase (@expr1073746101 endPos@var1753 +@expr4272 1 ) ; }
489: std ::@expr4279 string ::@expr1073746104 size_type pos@var1754 ; pos@var1754 =@expr1073746105 0 ;
490: while (@expr1073746106 (@expr1073746107 pos@var1754 =@expr1073746108 line@var1752 .@expr1073746109 find (@expr1073746110 '\t' , pos@var1754 ) ) !=@expr1073746111 std ::@expr4279 string ::@expr1073746113 npos@expr1073746080 ) {
491: line@var1752 [@expr1073746114 pos@var1754 ] =@expr1073746115 ' ' ; }
492: return line@var1752 +@expr1073746116 endl@var1750 +@expr1073746117 std ::@expr4279 string (@expr1073746119 column@var1749 >@expr1073746120 0 ?@expr1073746121 column@var1749 -@expr1073746122 1 :@expr1073746123 column@var1749 , ' ' ) +@expr1073746124 '^' ;
493: }
494:
495: static void replaceColors ( std :: string & source@var1755 )
496: {
497: findAndReplace (@expr1073746125 source@var1755 , "{reset}" , ::@expr4302 toString (@expr1073746127 Color ::@expr1073746128 Reset ) ) ;
498: findAndReplace (@expr1073746129 source@var1755 , "{bold}" , ::@expr4302 toString (@expr1073746131 Color ::@expr1073746132 Bold ) ) ;
499: findAndReplace (@expr1073746133 source@var1755 , "{dim}" , ::@expr4302 toString (@expr1073746135 Color ::@expr1073746136 Dim ) ) ;
500: findAndReplace (@expr1073746137 source@var1755 , "{red}" , ::@expr4302 toString (@expr1073746139 Color ::@expr1073746140 FgRed ) ) ;
501: findAndReplace (@expr1073746141 source@var1755 , "{green}" , ::@expr4302 toString (@expr1073746143 Color ::@expr1073746144 FgGreen ) ) ;
502: findAndReplace (@expr1073746145 source@var1755 , "{blue}" , ::@expr4302 toString (@expr1073746147 Color ::@expr1073746148 FgBlue ) ) ;
503: findAndReplace (@expr1073746149 source@var1755 , "{magenta}" , ::@expr4302 toString (@expr1073746151 Color ::@expr1073746152 FgMagenta ) ) ;
504: findAndReplace (@expr1073746153 source@var1755 , "{default}" , ::@expr4302 toString (@expr1073746155 Color ::@expr1073746156 FgDefault ) ) ;
505: }
506:
507: std :: string ErrorMessage :: toString ( bool verbose@var1756 , const std :: string & templateFormat@var1757 , const std :: string & templateLocation@var1758 ) const
508: {
509:
510:
511:
512: if (@expr1073746159 templateFormat@var1757 .@expr1073746160 empty (@expr1073746161 ) ) {
513: std ::@expr1073746162 ostringstream text@var1759 ;
514: if (@expr4339 !@expr4340 callStack@var142 .@expr4341 empty (@expr4342 ) ) {
515: text@var1759 <<@expr1073746167 ErrorLogger ::@expr4344 callStackToString (@expr4345 callStack@var142 ) <<@expr1073746170 ": " ; }
516: if (@expr1073746171 severity@var147 !=@expr1073746172 Severity ::@expr1073746173 none@expr1073746157 ) {
517: text@var1759 <<@expr1073746174 '(' <<@expr1073746175 Severity ::@expr4352 toString (@expr4353 severity@var147 ) ;
518: if (@expr1073746178 certainty@var149 ==@expr4355 Certainty ::@expr4356 inconclusive ) {
519: text@var1759 <<@expr1073746181 ", inconclusive" ; }
520: text@var1759 <<@expr1073746182 ") " ;
521: }
522: text@var1759 <<@expr1073746183 (@expr1073746184 verbose@var1756 ?@expr4361 mVerboseMessage@var154 :@expr4362 mShortMessage@var153 ) ;
523: return text@var1759 .@expr1073746187 str (@expr1073746188 ) ;
524: }
525:
526:
527: std ::@expr1073746189 string result@var1760 ; result@var1760 =@expr1073746190 templateFormat@var1757 ;
528:
529:
530: findAndReplace (@expr1073746191 result@var1760 , "\\b" , "\b" ) ;
531: findAndReplace (@expr1073746192 result@var1760 , "\\n" , "\n" ) ;
532: findAndReplace (@expr1073746193 result@var1760 , "\\r" , "\r" ) ;
533: findAndReplace (@expr1073746194 result@var1760 , "\\t" , "\t" ) ;
534:
535: replaceColors (@expr1073746195 result@var1760 ) ;
536: findAndReplace (@expr1073746196 result@var1760 , "{id}" , id@var143 ) ;
537:
538: std ::@expr4373 string ::@expr1073746198 size_type pos1@var1761 ; pos1@var1761 =@expr1073746199 result@var1760 .@expr4376 find (@expr1073746201 "{inconclusive:" ) ;
539: while (@expr1073746202 pos1@var1761 !=@expr1073746203 std ::@expr4373 string ::@expr4381 npos@expr4334 ) {
540: const std ::@expr4382 string ::@expr4382 size_type pos2@var1762 =@expr1073746208 result@var1760 .@expr4376 find (@expr1073746210 '}' , pos1@var1761 +@expr1073746211 1 ) ;
541: const std ::@expr4382 string replaceFrom@var1763 =@expr1073746213 result@var1760 .@expr4390 substr (@expr1073746215 pos1@var1761 , pos2@var1762 -@expr4392 pos1@var1761 +@expr1073746217 1 ) ;
542: const std ::@expr4382 string replaceWith@var1764 =@expr1073746219 (@expr1073746220 certainty@var149 ==@expr4355 Certainty ::@expr4356 inconclusive ) ?@expr1073746223 result@var1760 .@expr4390 substr (@expr1073746225 pos1@var1761 +@expr1073746226 14 , pos2@var1762 -@expr4392 pos1@var1761 -@expr1073746228 14 ) :@expr1073746229 std ::@expr4373 string (@expr1073746231 ) ;
543: findAndReplace (@expr1073746232 result@var1760 , replaceFrom@var1763 , replaceWith@var1764 ) ;
544: pos1@var1761 =@expr1073746233 result@var1760 .@expr4376 find (@expr1073746235 "{inconclusive:" , pos1@var1761 ) ;
545: }
546: findAndReplace (@expr1073746236 result@var1760 , "{severity}" , Severity ::@expr4352 toString (@expr4353 severity@var147 ) ) ;
547: findAndReplace (@expr1073746239 result@var1760 , "{cwe}" , MathLib ::@expr4416 toString (@expr1073746241 cwe@var148 .@expr1073746242 id@var1845 ) ) ;
548: findAndReplace (@expr1073746243 result@var1760 , "{message}" , verbose@var1756 ?@expr4361 mVerboseMessage@var154 :@expr4362 mShortMessage@var153 ) ;
549: findAndReplace (@expr1073746246 result@var1760 , "{callstack}" , callStack@var142 .@expr4341 empty (@expr4342 ) ?@expr1073746249 emptyString@var1 :@expr1073746250 ErrorLogger ::@expr4344 callStackToString (@expr4345 callStack@var142 ) ) ;
550: if (@expr4339 !@expr4340 callStack@var142 .@expr4341 empty (@expr4342 ) ) {
551: findAndReplace (@expr1073746257 result@var1760 , "{file}" , callStack@var142 .@expr4434 back (@expr4435 ) .@expr1073746260 getfile (@expr1073746261 ) ) ;
552: findAndReplace (@expr1073746262 result@var1760 , "{line}" , MathLib ::@expr4416 toString (@expr1073746264 callStack@var142 .@expr4434 back (@expr4435 ) .@expr4443 line@var1853 ) ) ;
553: findAndReplace (@expr1073746268 result@var1760 , "{column}" , MathLib ::@expr4416 toString (@expr1073746270 callStack@var142 .@expr4434 back (@expr4435 ) .@expr4449 column@var1854 ) ) ;
554: if (@expr1073746274 result@var1760 .@expr4376 find (@expr1073746276 "{code}" ) !=@expr1073746277 std ::@expr4373 string ::@expr4381 npos@expr4334 ) {
555: const std ::@expr4382 string ::@expr4382 size_type pos@var1765 =@expr1073746282 result@var1760 .@expr4376 find (@expr1073746284 '\r' ) ;
556: const char * endl@var1766 ;
557: if (@expr1073746285 pos@var1765 ==@expr1073746286 std ::@expr4373 string ::@expr4381 npos@expr4334 ) {
558: endl@var1766 =@expr1073746289 "\n" ; }
559: else { if (@expr1073746290 pos@var1765 +@expr4467 1 <@expr1073746292 result@var1760 .@expr1073746293 size (@expr1073746294 ) &&@expr1073746295 result@var1760 [@expr1073746296 pos@var1765 +@expr4467 1 ] ==@expr1073746298 '\n' ) {
560: endl@var1766 =@expr1073746299 "\r\n" ; }
561: else {
562: endl@var1766 =@expr1073746300 "\r" ; } }
563: findAndReplace (@expr1073746301 result@var1760 , "{code}" , readCode (@expr1073746302 callStack@var142 .@expr4434 back (@expr4435 ) .@expr1073746305 getOrigFile (@expr1073746306 ) , callStack@var142 .@expr4434 back (@expr4435 ) .@expr4443 line@var1853 , callStack@var142 .@expr4434 back (@expr4435 ) .@expr4449 column@var1854 , endl@var1766 ) ) ;
564: }
565: } else {
566: findAndReplace (@expr1073746313 result@var1760 , "{file}" , "nofile" ) ;
567: findAndReplace (@expr1073746314 result@var1760 , "{line}" , "0" ) ;
568: findAndReplace (@expr1073746315 result@var1760 , "{column}" , "0" ) ;
569: findAndReplace (@expr1073746316 result@var1760 , "{code}" , emptyString@var1 ) ;
570: }
571:
572: if (@expr1073746317 !@expr1073746318 templateLocation@var1758 .@expr1073746319 empty (@expr1073746320 ) &&@expr1073746321 callStack@var142 .@expr1073746322 size (@expr1073746323 ) >=@expr1073746324 2U ) {
573: for (@expr1073746325 const FileLocation &@expr1073746326 fileLocation@var1767 :@expr1073746327 callStack@var142 ) {
574: std ::@expr1073746328 string text@var1768 ; text@var1768 =@expr1073746329 templateLocation@var1758 ;
575:
576: findAndReplace (@expr1073746330 text@var1768 , "\\b" , "\b" ) ;
577: findAndReplace (@expr1073746331 text@var1768 , "\\n" , "\n" ) ;
578: findAndReplace (@expr1073746332 text@var1768 , "\\r" , "\r" ) ;
579: findAndReplace (@expr1073746333 text@var1768 , "\\t" , "\t" ) ;
580:
581: replaceColors (@expr1073746334 text@var1768 ) ;
582: findAndReplace (@expr1073746335 text@var1768 , "{file}" , fileLocation@var1767 .@expr1073746336 getfile (@expr1073746337 ) ) ;
583: findAndReplace (@expr1073746338 text@var1768 , "{line}" , MathLib ::@expr4416 toString (@expr1073746340 fileLocation@var1767 .@expr4517 line@var1769 ) ) ;
584: findAndReplace (@expr1073746342 text@var1768 , "{column}" , MathLib ::@expr4416 toString (@expr1073746344 fileLocation@var1767 .@expr4521 column@var1770 ) ) ;
585: findAndReplace (@expr1073746346 text@var1768 , "{info}" , fileLocation@var1767 .@expr4523 getinfo (@expr4524 ) .@expr1073746349 empty (@expr1073746350 ) ?@expr1073746351 mShortMessage@var153 :@expr1073746352 fileLocation@var1767 .@expr4523 getinfo (@expr4524 ) ) ;
586: if (@expr1073746355 text@var1768 .@expr4532 find (@expr1073746357 "{code}" ) !=@expr1073746358 std ::@expr4373 string ::@expr4381 npos@expr4334 ) {
587: const std ::@expr4382 string ::@expr4382 size_type pos@var1771 =@expr1073746363 text@var1768 .@expr4532 find (@expr1073746365 '\r' ) ;
588: const char * endl@var1772 ;
589: if (@expr1073746366 pos@var1771 ==@expr1073746367 std ::@expr4373 string ::@expr4381 npos@expr4334 ) {
590: endl@var1772 =@expr1073746370 "\n" ; }
591: else { if (@expr1073746371 pos@var1771 +@expr4548 1 <@expr1073746373 text@var1768 .@expr1073746374 size (@expr1073746375 ) &&@expr1073746376 text@var1768 [@expr1073746377 pos@var1771 +@expr4548 1 ] ==@expr1073746379 '\n' ) {
592: endl@var1772 =@expr1073746380 "\r\n" ; }
593: else {
594: endl@var1772 =@expr1073746381 "\r" ; } }
595: findAndReplace (@expr1073746382 text@var1768 , "{code}" , readCode (@expr1073746383 fileLocation@var1767 .@expr1073746384 getOrigFile (@expr1073746385 ) , fileLocation@var1767 .@expr4517 line@var1769 , fileLocation@var1767 .@expr4521 column@var1770 , endl@var1772 ) ) ;
596: }
597: result@var1760 +=@expr1073746388 '\n' +@expr1073746389 text@var1768 ;
598: }
599: }
600:
601: return result@var1760 ;
602: }
603:
604: bool ErrorLogger :: reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var1773 )
605: {
606: bool err@var1774 ; err@var1774 =@expr1073746391 false ;
607:
608: for (@expr1073746392 const Suppressions ::@expr4569 Suppression &@expr4570 s@var1775 :@expr1073746395 unmatched@var1773 ) {
609:
610: if (@expr1073746396 s@var1775 .@expr4573 errorId@var1776 ==@expr1073746398 "unmatchedSuppression" ) {
611: continue ; }
612:
613:
614: bool suppressed@var1777 ; suppressed@var1777 =@expr1073746399 false ;
615: for (@expr1073746400 const Suppressions ::@expr4569 Suppression &@expr4570 s2@var1778 :@expr1073746403 unmatched@var1773 ) {
616: if (@expr1073746404 s2@var1778 .@expr1073746405 errorId@var1779 ==@expr1073746406 "unmatchedSuppression" ) {
617: if (@expr1073746407 (@expr1073746408 s2@var1778 .@expr4585 fileName@var1780 .@expr1073746410 empty (@expr1073746411 ) ||@expr1073746412 s2@var1778 .@expr4585 fileName@var1780 ==@expr1073746414 "*" ||@expr1073746415 s2@var1778 .@expr4585 fileName@var1780 ==@expr1073746417 s@var1775 .@expr4594 fileName@var1781 ) &&@expr1073746419
618: (@expr1073746420 s2@var1778 .@expr4597 lineNumber@var1782 ==@expr1073746422 Suppressions ::@expr1073746423 Suppression ::@expr1073746424 NO_LINE ||@expr1073746425 s2@var1778 .@expr4597 lineNumber@var1782 ==@expr1073746427 s@var1775 .@expr4604 lineNumber@var1783 ) ) {
619: suppressed@var1777 =@expr1073746429 true ;
620: break ;
621: }
622: }
623: }
624:
625: if (@expr1073746430 suppressed@var1777 ) {
626: continue ; }
627:
628: std ::@expr1073746431 list < ErrorMessage ::@expr4569 FileLocation > callStack@var1784 ;
629: if (@expr1073746433 !@expr1073746434 s@var1775 .@expr4594 fileName@var1781 .@expr1073746436 empty (@expr1073746437 ) ) {
630: callStack@var1784 .@expr1073746438 emplace_back (@expr1073746439 s@var1775 .@expr4594 fileName@var1781 , s@var1775 .@expr4604 lineNumber@var1783 , 0 ) ; }
631: reportErr (@expr1073746442 ErrorMessage (@expr1073746443 callStack@var1784 , emptyString@var1 , Severity ::@expr1073746444 information , "Unmatched suppression: " +@expr1073746445 s@var1775 .@expr4573 errorId@var1776 , "unmatchedSuppression" , Certainty ::@expr1073746447 normal@expr1073746390 ) ) ;
632: err@var1774 =@expr1073746448 true ;
633: }
634: return err@var1774 ;
635: }
636:
637: std :: string ErrorLogger :: callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var1785 )
638: {
639: std ::@expr1073746449 string str@var1786 ;
640: for (@expr1073746450 std ::@expr4627 list < ErrorMessage ::@expr4627 FileLocation > ::@expr4627 const_iterator tok@var1787 =@expr1073746454 callStack@var1785 .@expr4631 begin (@expr4632 ) ; tok@var1787 !=@expr1073746457 callStack@var1785 .@expr1073746458 end (@expr1073746459 ) ; ++@expr1073746460 tok@var1787 ) {
641: str@var1786 +=@expr1073746461 (@expr1073746462 tok@var1787 ==@expr1073746463 callStack@var1785 .@expr4631 begin (@expr4632 ) ?@expr1073746466 "" :@expr1073746467 " -> " ) ;
642: str@var1786 +=@expr1073746468 tok@var1787 .@expr1073746469 stringify (@expr1073746470 ) ;
643: }
644: return str@var1786 ;
645: }
646:
647:
648: ErrorMessage :: FileLocation :: FileLocation ( const Token * tok@var1788 , const TokenList * tokenList@var1789 )
649: : fileIndex@var97 ( tok@var1788 . fileIndex ( ) ) , line@var98 ( tok@var1788 . linenr ( ) ) , column@var99 ( tok@var1788 . column ( ) ) , mOrigFileName@var101 ( tokenList@var1789 . getOrigFile ( tok@var1788 ) ) , mFileName@var102 ( tokenList@var1789 . file ( tok@var1788 ) )
650: { }
651:
652: ErrorMessage :: FileLocation :: FileLocation ( const Token * tok@var1790 , const std :: string & info@var1791 , const TokenList * tokenList@var1792 )
653: : fileIndex@var97 ( tok@var1790 . fileIndex ( ) ) , line@var98 ( tok@var1790 . linenr ( ) ) , column@var99 ( tok@var1790 . column ( ) ) , mOrigFileName@var101 ( tokenList@var1792 . getOrigFile ( tok@var1790 ) ) , mFileName@var102 ( tokenList@var1792 . file ( tok@var1790 ) ) , mInfo@var103 ( info@var1791 )
654: { }
655:
656: std :: string ErrorMessage :: FileLocation :: getfile ( bool convert@var1793 ) const
657: {
658: if (@expr1073746471 convert@var1793 ) {
659: return Path ::@expr1073746472 toNativeSeparators (@expr1073746473 mFileName@var102 ) ; }
660: return mFileName@var102 ;
661: }
662:
663: std :: string ErrorMessage :: FileLocation :: getOrigFile ( bool convert@var1794 ) const
664: {
665: if (@expr1073746474 convert@var1794 ) {
666: return Path ::@expr1073746475 toNativeSeparators (@expr1073746476 mOrigFileName@var101 ) ; }
667: return mOrigFileName@var101 ;
668: }
669:
670: void ErrorMessage :: FileLocation :: setfile ( const std :: string & file@var1795 )
671: {
672: mFileName@var102 =@expr1073746477 file@var1795 ;
673: mFileName@var102 =@expr1073746478 Path ::@expr1073746479 fromNativeSeparators (@expr1073746480 mFileName@var102 ) ;
674: mFileName@var102 =@expr1073746481 Path ::@expr1073746482 simplifyPath (@expr1073746483 mFileName@var102 ) ;
675: }
676:
677: std :: string ErrorMessage :: FileLocation :: stringify ( ) const
678: {
679: std ::@expr1073746484 string str@var1796 ;
680: str@var1796 +=@expr1073746485 '[' ;
681: str@var1796 +=@expr1073746486 Path ::@expr1073746487 toNativeSeparators (@expr1073746488 mFileName@var102 ) ;
682: if (@expr1073746489 line@var98 !=@expr1073746490 Suppressions ::@expr1073746491 Suppression ::@expr1073746492 NO_LINE ) {
683: str@var1796 +=@expr1073746493 ':' ;
684: str@var1796 +=@expr1073746494 std ::@expr1073746495 to_string (@expr1073746496 line@var98 ) ;
685: }
686: str@var1796 +=@expr1073746497 ']' ;
687: return str@var1796 ;
688: }
689:
690: std :: string ErrorLogger :: toxml ( const std :: string & str@var1797 )
691: {
692: std ::@expr1073746498 ostringstream xml@var1798 ;
693: for (@expr1073746499 unsigned char c@var1799 :@expr1073746500 str@var1797 ) {
694: switch (@expr1073746501 c@var1799 ) {
695: case '<' :@expr4678 ;
696: xml@var1798 <<@expr1073746503 "&lt;" ;
697: break ;
698: case '>' :@expr4678 ;
699: xml@var1798 <<@expr1073746505 "&gt;" ;
700: break ;
701: case '&' :@expr4678 ;
702: xml@var1798 <<@expr1073746507 "&amp;" ;
703: break ;
704: case '\"' :@expr4678 ;
705: xml@var1798 <<@expr1073746509 "&quot;" ;
706: break ;
707: case '\'' :@expr4678 ;
708: xml@var1798 <<@expr1073746511 "&apos;" ;
709: break ;
710: case '\0' :@expr4678 ;
711: xml@var1798 <<@expr1073746513 "\\0" ;
712: break ;
713: default :@expr4678 ;
714: if (@expr1073746515 c@var1799 >=@expr1073746516 ' ' &&@expr1073746517 c@var1799 <=@expr1073746518 0x7f ) {
715: xml@var1798 <<@expr1073746519 c@var1799 ; }
716: else {
717: xml@var1798 <<@expr1073746520 'x' ; }
718: break ;
719: }
720: }
721: return xml@var1798 .@expr1073746521 str (@expr1073746522 ) ;
722: }
723:
724: std :: string ErrorLogger :: plistHeader ( const std :: string & version@var1800 , const std :: vector < std :: string > & files@var1801 )
725: {
726: std ::@expr1073746523 ostringstream ostr@var1802 ;
727: ostr@var1802 <<@expr1073746524 "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
728: <<@expr1073746525 "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\r\n"
729: <<@expr1073746526 "<plist version=\"1.0\">\r\n"
730: <<@expr1073746527 "<dict>\r\n"
731: <<@expr1073746528 " <key>clang_version</key>\r\n"
732: <<@expr1073746529 "<string>cppcheck version " <<@expr1073746530 version@var1800 <<@expr1073746531 "</string>\r\n"
733: <<@expr1073746532 " <key>files</key>\r\n"
734: <<@expr1073746533 " <array>\r\n" ;
735: for (@expr1073746534 const std ::@expr1073746535 string &@expr1073746536 file@var1803 :@expr1073746537 files@var1801 ) {
736: ostr@var1802 <<@expr1073746538 "  <string>" <<@expr1073746539 ErrorLogger ::@expr1073746540 toxml (@expr1073746541 file@var1803 ) <<@expr1073746542 "</string>\r\n" ; }
737: ostr@var1802 <<@expr1073746543 " </array>\r\n"
738: <<@expr1073746544 " <key>diagnostics</key>\r\n"
739: <<@expr1073746545 " <array>\r\n" ;
740: return ostr@var1802 .@expr1073746546 str (@expr1073746547 ) ;
741: }
742:
743: static std :: string plistLoc ( const char indent@var1804 [ ] , const ErrorMessage :: FileLocation & loc@var1805 )
744: {
745: std ::@expr1073746548 ostringstream ostr@var1806 ;
746: ostr@var1806 <<@expr1073746549 indent@var1804 <<@expr1073746550 "<dict>\r\n"
747: <<@expr1073746551 indent@var1804 <<@expr1073746552 ' ' <<@expr1073746553 "<key>line</key><integer>" <<@expr1073746554 loc@var1805 .@expr1073746555 line@var1807 <<@expr1073746556 "</integer>\r\n"
748: <<@expr1073746557 indent@var1804 <<@expr1073746558 ' ' <<@expr1073746559 "<key>col</key><integer>" <<@expr1073746560 loc@var1805 .@expr1073746561 column@var1808 <<@expr1073746562 "</integer>\r\n"
749: <<@expr1073746563 indent@var1804 <<@expr1073746564 ' ' <<@expr1073746565 "<key>file</key><integer>" <<@expr1073746566 loc@var1805 .@expr1073746567 fileIndex@var1809 <<@expr1073746568 "</integer>\r\n"
750: <<@expr1073746569 indent@var1804 <<@expr1073746570 "</dict>\r\n" ;
751: return ostr@var1806 .@expr1073746571 str (@expr1073746572 ) ;
752: }
753:
754: std :: string ErrorLogger :: plistData ( const ErrorMessage & msg@var1810 )
755: {
756: std ::@expr1073746573 ostringstream plist@var1811 ;
757: plist@var1811 <<@expr1073746574 "  <dict>\r\n"
758: <<@expr1073746575 "   <key>path</key>\r\n"
759: <<@expr1073746576 "   <array>\r\n" ;
760:
761: std ::@expr4753 list < ErrorMessage ::@expr4754 FileLocation > ::@expr1073746579 const_iterator prev@var1812 ; prev@var1812 =@expr1073746580 msg@var1810 .@expr4757 callStack@var1813 .@expr4758 begin (@expr4759 ) ;
762:
763: for (@expr1073746584 std ::@expr4754 list < ErrorMessage ::@expr4754 FileLocation > ::@expr4754 const_iterator it@var1814 =@expr1073746588 msg@var1810 .@expr4757 callStack@var1813 .@expr4758 begin (@expr4759 ) ; it@var1814 !=@expr1073746592 msg@var1810 .@expr4757 callStack@var1813 .@expr4770 end (@expr4771 ) ; ++@expr1073746596 it@var1814 ) {
764: if (@expr1073746597 prev@var1812 !=@expr1073746598 it@var1814 ) {
765: plist@var1811 <<@expr4775 "    <dict>\r\n"
766: <<@expr1073746600 "     <key>kind</key><string>control</string>\r\n"
767: <<@expr1073746601 "     <key>edges</key>\r\n"
768: <<@expr1073746602 "      <array>\r\n"
769: <<@expr1073746603 "       <dict>\r\n"
770: <<@expr1073746604 "        <key>start</key>\r\n"
771: <<@expr1073746605 "         <array>\r\n"
772: <<@expr1073746606 plistLoc (@expr4783 "          " , *@expr4784 prev@var1812 )
773: <<@expr1073746609 plistLoc (@expr4783 "          " , *@expr4784 prev@var1812 )
774: <<@expr1073746612 "         </array>\r\n"
775: <<@expr1073746613 "        <key>end</key>\r\n"
776: <<@expr1073746614 "         <array>\r\n"
777: <<@expr1073746615 plistLoc (@expr4792 "          " , *@expr4793 it@var1814 )
778: <<@expr1073746618 plistLoc (@expr4792 "          " , *@expr4793 it@var1814 )
779: <<@expr1073746621 "         </array>\r\n"
780: <<@expr1073746622 "       </dict>\r\n"
781: <<@expr1073746623 "      </array>\r\n"
782: <<@expr1073746624 "    </dict>\r\n" ;
783: prev@var1812 =@expr1073746625 it@var1814 ;
784: }
785:
786: std ::@expr4753 list < ErrorMessage ::@expr4754 FileLocation > ::@expr1073746628 const_iterator next@var1815 ; next@var1815 =@expr1073746629 it@var1814 ;
787: ++@expr1073746630 next@var1815 ;
788: const std ::@expr4754 string message@var1816 =@expr1073746632 it@var1814 .@expr4809 getinfo (@expr4810 ) .@expr1073746635 empty (@expr1073746636 ) &&@expr1073746637 next@var1815 ==@expr1073746638 msg@var1810 .@expr4757 callStack@var1813 .@expr4770 end (@expr4771 ) ?@expr1073746642 msg@var1810 .@expr4819 shortMessage (@expr4820 ) :@expr1073746645 it@var1814 .@expr4809 getinfo (@expr4810 ) ;
789:
790: plist@var1811 <<@expr4775 "    <dict>\r\n"
791: <<@expr1073746649 "     <key>kind</key><string>event</string>\r\n"
792: <<@expr1073746650 "     <key>location</key>\r\n"
793: <<@expr1073746651 plistLoc (@expr1073746652 "     " , *@expr4793 it@var1814 )
794: <<@expr1073746654 "     <key>ranges</key>\r\n"
795: <<@expr1073746655 "     <array>\r\n"
796: <<@expr1073746656 "       <array>\r\n"
797: <<@expr1073746657 plistLoc (@expr4834 "        " , *@expr4793 it@var1814 )
798: <<@expr1073746660 plistLoc (@expr4834 "        " , *@expr4793 it@var1814 )
799: <<@expr1073746663 "       </array>\r\n"
800: <<@expr1073746664 "     </array>\r\n"
801: <<@expr1073746665 "     <key>depth</key><integer>0</integer>\r\n"
802: <<@expr1073746666 "     <key>extended_message</key>\r\n"
803: <<@expr1073746667 "     <string>" <<@expr1073746668 ErrorLogger ::@expr4845 toxml (@expr4846 message@var1816 ) <<@expr1073746671 "</string>\r\n"
804: <<@expr1073746672 "     <key>message</key>\r\n"
805: <<@expr1073746673 "     <string>" <<@expr1073746674 ErrorLogger ::@expr4845 toxml (@expr4846 message@var1816 ) <<@expr1073746677 "</string>\r\n"
806: <<@expr1073746678 "    </dict>\r\n" ;
807: }
808:
809: plist@var1811 <<@expr1073746679 "   </array>\r\n"
810: <<@expr1073746680 "   <key>description</key><string>" <<@expr1073746681 ErrorLogger ::@expr4845 toxml (@expr4859 msg@var1810 .@expr4819 shortMessage (@expr4820 ) ) <<@expr1073746686 "</string>\r\n"
811: <<@expr1073746687 "   <key>category</key><string>" <<@expr1073746688 Severity ::@expr1073746689 toString (@expr1073746690 msg@var1810 .@expr1073746691 severity@var1817 ) <<@expr1073746692 "</string>\r\n"
812: <<@expr1073746693 "   <key>type</key><string>" <<@expr1073746694 ErrorLogger ::@expr4845 toxml (@expr4859 msg@var1810 .@expr4819 shortMessage (@expr4820 ) ) <<@expr1073746699 "</string>\r\n"
813: <<@expr1073746700 "   <key>check_name</key><string>" <<@expr1073746701 msg@var1810 .@expr1073746702 id@var1818 <<@expr1073746703 "</string>\r\n"
814: <<@expr1073746704 "   <!-- This hash is experimental and going to change! -->\r\n"
815: <<@expr1073746705 "   <key>issue_hash_content_of_line_in_context</key><string>" <<@expr1073746706 0 <<@expr1073746707 "</string>\r\n"
816: <<@expr1073746708 "  <key>issue_context_kind</key><string></string>\r\n"
817: <<@expr1073746709 "  <key>issue_context</key><string></string>\r\n"
818: <<@expr1073746710 "  <key>issue_hash_function_offset</key><string></string>\r\n"
819: <<@expr1073746711 "  <key>location</key>\r\n"
820: <<@expr1073746712 plistLoc (@expr1073746713 "  " , msg@var1810 .@expr4757 callStack@var1813 .@expr1073746715 back (@expr1073746716 ) )
821: <<@expr1073746717 "  </dict>\r\n" ;
822: return plist@var1811 .@expr1073746718 str (@expr1073746719 ) ;
823: }
824:
825:
826: std :: string replaceStr ( std :: string s@var1819 , const std :: string & from@var1820 , const std :: string & to@var1821 )
827: {
828: std ::@expr4897 string ::@expr1073746722 size_type pos1@var1822 ; pos1@var1822 =@expr1073746723 0 ;
829: while (@expr1073746724 pos1@var1822 <@expr1073746725 s@var1819 .@expr4902 size (@expr4903 ) ) {
830: pos1@var1822 =@expr1073746728 s@var1819 .@expr1073746729 find (@expr1073746730 from@var1820 , pos1@var1822 ) ;
831: if (@expr1073746731 pos1@var1822 ==@expr1073746732 std ::@expr4897 string ::@expr1073746734 npos@expr1073746720 ) {
832: return s@var1819 ; }
833: if (@expr1073746735 pos1@var1822 >@expr1073746736 0 &&@expr1073746737 (@expr1073746738 s@var1819 [@expr4915 pos1@var1822 -@expr4916 1 ] ==@expr1073746741 '_' ||@expr1073746742 std ::@expr4919 isalnum (@expr1073746744 s@var1819 [@expr4915 pos1@var1822 -@expr4916 1 ] ) ) ) {
834: pos1@var1822 ++@expr1073746747 ;
835: continue ;
836: }
837: const std ::@expr4924 string ::@expr4924 size_type pos2@var1823 =@expr1073746750 pos1@var1822 +@expr1073746751 from@var1820 .@expr1073746752 size (@expr1073746753 ) ;
838: if (@expr1073746754 pos2@var1823 >=@expr1073746755 s@var1819 .@expr4902 size (@expr4903 ) ) {
839: return s@var1819 .@expr4934 substr (@expr4935 0 , pos1@var1822 ) +@expr4936 to@var1821 ; }
840: if (@expr1073746761 s@var1819 [@expr4938 pos2@var1823 ] ==@expr1073746763 '_' ||@expr1073746764 std ::@expr4919 isalnum (@expr1073746766 s@var1819 [@expr4938 pos2@var1823 ] ) ) {
841: pos1@var1822 ++@expr1073746768 ;
842: continue ;
843: }
844: s@var1819 =@expr1073746769 s@var1819 .@expr4934 substr (@expr4935 0 , pos1@var1822 ) +@expr4936 to@var1821 +@expr1073746773 s@var1819 .@expr4934 substr (@expr1073746775 pos2@var1823 ) ;
845: pos1@var1822 +=@expr1073746776 to@var1821 .@expr1073746777 size (@expr1073746778 ) ;
846: }
847: return s@var1819 ;
848: }

##file cppcheck-2.8/lib/settings.h

4:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var1824 ; mFlags@var1824 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1824 ;
54: }
55: void clear ( ) {
56: mFlags@var1824 =@expr1073746779 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1824 =@expr1073746780 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1825 ) {
62: if (@expr1073746781 enabled@var1825 ) {
63: fill (@expr1073746782 ) ; }
64: else {
65: clear (@expr1073746783 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var1826 ) const {
68: return (@expr4960 mFlags@var1824 &@expr1073746785 (@expr4960 1U <<@expr1073746787 (@expr1073746788 uint32_t ) flag@var1826 ) ) !=@expr1073746789 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var1827 ) {
71: mFlags@var1824 |=@expr1073746790 (@expr1073746791 1U <<@expr1073746792 (@expr1073746793 uint32_t ) flag@var1827 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var1828 ) {
74: mFlags@var1824 &=@expr1073746794 ~@expr1073746795 (@expr1073746796 1U <<@expr1073746797 (@expr1073746798 uint32_t ) flag@var1828 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var1829 , bool enabled@var1830 ) {
77: if (@expr1073746799 enabled@var1830 ) {
78: enable (@expr1073746800 flag@var1829 ) ; }
79: else {
80: disable (@expr1073746801 flag@var1829 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var1831 ; mFlags@var1831 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1831 ;
54: }
55: void clear ( ) {
56: mFlags@var1831 =@expr1073746802 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1831 =@expr1073746803 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1832 ) {
62: if (@expr1073746804 enabled@var1832 ) {
63: fill (@expr1073746805 ) ; }
64: else {
65: clear (@expr1073746806 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var1833 ) const {
68: return (@expr4983 mFlags@var1831 &@expr1073746808 (@expr4983 1U <<@expr1073746810 (@expr1073746811 uint32_t ) flag@var1833 ) ) !=@expr1073746812 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var1834 ) {
71: mFlags@var1831 |=@expr1073746813 (@expr1073746814 1U <<@expr1073746815 (@expr1073746816 uint32_t ) flag@var1834 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var1835 ) {
74: mFlags@var1831 &=@expr1073746817 ~@expr1073746818 (@expr1073746819 1U <<@expr1073746820 (@expr1073746821 uint32_t ) flag@var1835 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var1836 , bool enabled@var1837 ) {
77: if (@expr1073746822 enabled@var1837 ) {
78: enable (@expr1073746823 flag@var1836 ) ; }
79: else {
80: disable (@expr1073746824 flag@var1836 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var1838 ; mFlags@var1838 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1838 ;
54: }
55: void clear ( ) {
56: mFlags@var1838 =@expr1073746825 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1838 =@expr1073746826 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1839 ) {
62: if (@expr1073746827 enabled@var1839 ) {
63: fill (@expr1073746828 ) ; }
64: else {
65: clear (@expr1073746829 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var1840 ) const {
68: return (@expr5006 mFlags@var1838 &@expr1073746831 (@expr5006 1U <<@expr1073746833 (@expr1073746834 uint32_t ) flag@var1840 ) ) !=@expr1073746835 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var1841 ) {
71: mFlags@var1838 |=@expr1073746836 (@expr1073746837 1U <<@expr1073746838 (@expr1073746839 uint32_t ) flag@var1841 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var1842 ) {
74: mFlags@var1838 &=@expr1073746840 ~@expr1073746841 (@expr1073746842 1U <<@expr1073746843 (@expr1073746844 uint32_t ) flag@var1842 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var1843 , bool enabled@var1844 ) {
77: if (@expr1073746845 enabled@var1844 ) {
78: enable (@expr1073746846 flag@var1843 ) ; }
79: else {
80: disable (@expr1073746847 flag@var1843 ) ; }
81: }
82: } ;



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  = always 1
  true always 1
Line 93
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {10@100,39@38176,34@38432}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@149,34@150}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@149,""@150,""@151,"U"@152,"U"@153,"u"@154,"u"@155,"u8"@156,"u8"@157}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@29,34@30}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@26,34@28}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 57
  ( always {!<=-1,!>=2}
  , always !<=-1
  checksum always !<=-1
Line 58
  , always {!<=-1,!>=2}
  verbose always {!<=-1,!>=2}
Line 65
  , inconclusive lifetime[SubObject]=(errorLogger)
  ( inconclusive lifetime[SubObject]=(errorLogger)
Line 68
  ! always {!<=-1,!>=2}
Line 69
  this always !0
Line 76
  = always 0
  0 always 0
Line 79
  = always 0
  0 always 0
Line 87
  = always 0
  0 always 0
Line 109
  nullptr always 0
Line 114
  nullptr always 0
Line 118
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  false always 0
Line 135
  0U always 0
  :: always 0
  normal always 0
Line 140
  1 always 1
Line 141
  callstack always size=1
  certainty possible 0@23
Line 146
  0U always 0
  :: always 0
  normal always 0
Line 160
  ( always {!<=-1,!>=2}
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 56
  , always {!<=-1,!>=2}
Line 57
  useGlobalSuppressions always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 79
  ( always !<=-1
Line 80
  ( always !<=-1
Line 93
  ( always !<=-1
Line 115
  fileindex always !<=-1
  filecount always !<=-1
  sizedone always !<=-1
  sizetotal always !<=-1
Line 127
  mSimplify always {!<=-1,!>=2}
  = always 0
  false always 0
Line 135
  ( always {!<=-1,!>=2}
Line 145
  ( always {!<=-1,!>=2}
Line 149
  ( always {!<=-1,!>=2}
Line 161
  ( always !<=-1
Line 207
  = always 0
  :: always 0
  Reset always 0
Line 212
  value always !<=-1
Line 224
  mExitCode always !<=-1
Line 226
  mUseGlobalSuppressions always {!<=-1,!>=2}
Line 229
  mTooManyConfigs always {!<=-1,!>=2}
Line 232
  mSimplify always {!<=-1,!>=2}
Line 240
  ( always {!<=-1,!>=2}
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@239,128@240,64@241,32@242,16@243,8@244,4@245,2@246,1@247}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@248,128@249,64@250,32@251,16@252,8@253,4@254,2@255,1}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@248,4294967167@249,4294967231@250,4294967263@251,4294967279@252,4294967287@253,4294967291@254,4294967293@255,4294967294}
  flag {!<=-1,256@248,128@249,64@250,32@251,16@252,8@253,4@254,2@255,1}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@138,4@139,0@140}
  t possible {10@138,4@139,0@140}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@138,4@139,0@140}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@138,0@140}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@138,0@140}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@138}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@138}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@138}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@138}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@138}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@146}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@148,17179869184@159,8589934592@161,34359738368@163,4294967296@165,2147483648@167,1073741824@169,536870912@171,268435456@173}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@235,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@236}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@147,17179869184@158,8589934592@160,34359738368@162,4294967296@164,2147483648@166,1073741824@168,536870912@170,268435456@172}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@147,17179869184@158,8589934592@160,34359738368@162,4294967296@164,2147483648@166,1073741824@168,536870912@170,268435456@172}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 44
  AST always 0
Line 45
  = always "internalAstError"
  "internalAstError" always "internalAstError"
Line 47
  SYNTAX always 1
Line 48
  = always "syntaxError"
  "syntaxError" always "syntaxError"
Line 50
  UNKNOWN_MACRO always 2
Line 51
  = always "unknownMacro"
  "unknownMacro" always "unknownMacro"
Line 53
  INTERNAL always 3
Line 54
  = always "cppcheckError"
  "cppcheckError" always "cppcheckError"
Line 56
  LIMIT always 4
Line 57
  = always "cppcheckLimit"
  "cppcheckLimit" always "cppcheckLimit"
Line 59
  INSTANTIATION always 5
Line 60
  = always "instantiationError"
  "instantiationError" always "instantiationError"
Line 65
  incomplete always {!<=-1,!>=2}
  false always 0
  0U always 0
  hash always !<=-1
  0 always 0
Line 72
  incomplete always {!<=-1,!>=2}
  false always 0
Line 74
  0U always 0
Line 76
  hash always !<=-1
  0 always 0
Line 88
  incomplete always {!<=-1,!>=2}
  false always 0
Line 90
  . always !<=-1
  id always !<=-1
Line 92
  hash always !<=-1
  0 always 0
Line 99
  incomplete always {!<=-1,!>=2}
  false always 0
  0U always 0
  hash always !<=-1
  0 always 0
Line 102
  = {lifetime[Iterator]=(callstack),start=0}
  ( {lifetime[Iterator]=(callstack),start=0}
  it possible {lifetime[Iterator]=(callstack),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callstack),end=0}
Line 104
  ! always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(callstack)
Line 107
  * always !0
Line 110
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  list always !0
  ( always {!<=-1,!>=2}
Line 111
  list always !0
  ( always !size=0
  0 always 0
Line 118
  incomplete always {!<=-1,!>=2}
  false always 0
  . always !<=-1
  id always !<=-1
Line 123
  ! always {!<=-1,!>=2}
Line 126
  tok always !0
Line 129
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  list always !0
  ( always {!<=-1,!>=2}
Line 130
  list always !0
  ( always !size=0
  0 always 0
Line 134
  hash always !<=-1
  = always 0
  0 always 0
Line 138
  incomplete always {!<=-1,!>=2}
  false always 0
  . always !<=-1
  id always !<=-1
Line 145
  info always symbolic=(e.second)
  0 always 0
  8 always 8
  "$symbol:" always "$symbol:"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  info always symbolic=(e.second)
  ( always !<=-1
  "\n" always "\n"
  < always {!<=-1,!>=2}
  info always symbolic=(e.second)
  ( always !<=-1
Line 146
  pos always !<=-1
  = {!<=-1,<=symbolic=(info.size()-1),!>=symbolic=(info.size())}
  info always symbolic=(e.second)
  ( {!<=-1,<=symbolic=(info.size()-1),!>=symbolic=(info.size())}
  "\n" always "\n"
Line 147
  info always symbolic=(e.second)
  8 always 8
  pos {!<=-1,<=symbolic=(info.size()-1),!>=symbolic=(info.size())}
  - always !<=-1
  8 always 8
Line 148
  pos always !<=-1
  + always !<=0
  1 always 1
  "$symbol" always "$symbol"
Line 152
  tok possible symbolic=(e.first)
Line 153
  tok always !0
Line 156
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tokenList always !0
  ( always {!<=-1,!>=2}
Line 157
  tokenList always !0
  ( always !size=0
  0 always 0
Line 161
  hash always !<=-1
  = always 0
  0 always 0
Line 165
  incomplete always {!<=-1,!>=2}
  false always 0
Line 167
  0U always 0
Line 170
  = always "<UNKNOWN>"
  "<UNKNOWN>" always "<UNKNOWN>"
Line 172
  "id" always "id"
Line 173
  = possible {"<UNKNOWN>",1}
  ? possible {"<UNKNOWN>",1}
  attr always !0
  : always {1,"<UNKNOWN>"}
  unknown always "<UNKNOWN>"
Line 175
  "severity" always "severity"
Line 176
  attr always !0
Line 178
  "cwe" always "cwe"
Line 179
  ? possible {"0",1}
  attr always !0
  : always {1,"0"}
  "0" always "0"
  . always !<=-1
  id always !<=-1
Line 181
  "inconclusive" always "inconclusive"
Line 182
  && always {!<=-1,!>=2}
  attr always !0
  "true" always "true"
  == always {!<=-1,!>=2}
  0 always 0
  :: always 1
  inconclusive always 1
  : always 1
Line 184
  "msg" always "msg"
Line 185
  = possible {"",1}
  ? possible {"",1}
  attr always !0
  : always {1,""}
  "" always ""
Line 187
  "verbose" always "verbose"
Line 188
  = possible {"",1}
  ? possible {"",1}
  attr always !0
  : always {1,""}
  "" always ""
Line 190
  "hash" always "hash"
Line 191
  ? possible {"0",1}
  attr always !0
  : always {1,"0"}
  "0" always "0"
  hash always !<=-1
Line 194
  "location" always "location"
  == always {!<=-1,!>=2}
  0 always 0
Line 195
  "file" always "file"
Line 196
  "info" always "info"
Line 197
  "line" always "line"
Line 198
  "column" always "column"
Line 200
  = possible {"<UNKNOWN>",1}
  ? possible {"<UNKNOWN>",1}
  strfile always !0
  : always {1,"<UNKNOWN>"}
  unknown always "<UNKNOWN>"
Line 201
  = possible {"",1}
  ? possible {"",1}
  strinfo always !0
  : always {1,""}
  "" always ""
Line 202
  = possible 0
  ? possible 0
  strline always !0
  : always 0
  0 always 0
Line 203
  = possible 0
  ? possible 0
  strcolumn always !0
  : always 0
  0 always 0
Line 204
  file always symbolic=(strfile?strfile:unknown)
  info always symbolic=(strinfo?strinfo:"")
  line always symbolic=(strline?std::atoi(strline):0)
  column {symbolic=(strcolumn?std::atoi(strcolumn):0),0}
Line 205
  "symbol" always "symbol"
  == always {!<=-1,!>=2}
  0 always 0
Line 218
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\n' always 10
Line 223
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\n' always 10
Line 224
  ( always {!<=-1,!>=2}
  mSymbolNames always !size=0
  0 always 0
  mSymbolNames always !size=0
  ( always !<=-1
  '\n' always 10
Line 225
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 226
  "$symbol" always "$symbol"
Line 227
  "$symbol" always "$symbol"
Line 228
  0 always 0
  8 always 8
  "$symbol:" always "$symbol:"
  == always {!<=-1,!>=2}
  0 always 0
Line 229
  8 always 8
  pos always !<=-1
  - always !<=-1
  7 always 7
Line 230
  pos always !<=-1
  + always !<=0
  1 always 1
Line 232
  0 always 0
  pos always !<=-1
  "$symbol" always "$symbol"
Line 233
  pos always !<=-1
  + always !<=0
  1 always 1
  "$symbol" always "$symbol"
Line 240
  . always !<=-1
  hash always !<=-1
  = always !<=-1
  hash always !<=-1
Line 242
  ! {!<=-1,!>=2,0}
  callStack possible size=0
  ( {!<=-1,!>=2,1}
Line 243
  ret always Uninit
  callStack always !size=0
  false always 0
Line 244
  callStack always !size=0
Line 246
  = always -1
  :: always -1
  NO_LINE always -1
Line 258
  ( always !<=-1
  " " always " "
Line 259
  ( always !<=-1
  " " always " "
Line 260
  . always !<=-1
  id always !<=-1
  ( always !<=-1
  " " always " "
  . always !<=-1
  id always !<=-1
Line 261
  hash always !<=-1
  ( always !<=-1
  " " always " "
  hash always !<=-1
Line 262
  ( always !<=-1
  " " always " "
Line 263
  == always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
Line 264
  "inconclusive" always "inconclusive"
Line 265
  ( always !<=-1
  " " always " "
Line 271
  ( always !<=-1
  " " always " "
Line 272
  ( always !<=-1
  " " always " "
Line 273
  ( always !<=-1
  " " always " "
Line 275
  = {lifetime[Iterator]=(callStack),start=0}
  ( {lifetime[Iterator]=(callStack),start=0}
  loc possible {lifetime[Iterator]=(callStack),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callStack),end=0}
Line 277
  loc possible lifetime[Iterator]=(callStack)
  '\t' always 9
  loc possible lifetime[Iterator]=(callStack)
  . always !<=-1
  '\t' always 9
  loc possible lifetime[Iterator]=(callStack)
  false always 0
  '\t' always 9
  loc possible lifetime[Iterator]=(callStack)
  false always 0
  '\t' always 9
Line 278
  ( always !<=-1
  " " always " "
Line 284
  ( always {!<=-1,!>=2}
Line 289
  7 always 7
Line 290
  elem always !<=-1
  elem always !<=-1
  = always 0
  0 always 0
Line 291
  && always {!<=-1,!>=2}
  elem {!<=-1,0}
  < {!<=-1,!>=2,1}
  7 always 7
Line 292
  len always !<=-1
  len always !<=-1
  = always 0
  0 always 0
Line 293
  ! always {!<=-1,!>=2}
  len always !<=-1
Line 294
  return always {!<=-1,!>=2}
  false always 0
Line 298
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  len always !<=-1
  && always {!<=-1,!>=2}
  ++ always !<=0
  i always !<=-1
Line 300
  1 always 1
Line 303
  temp possible size=0
  == {!<=-1,!>=2,0}
  "inconclusive" always "inconclusive"
Line 304
  = always 1
  :: always 1
  inconclusive always 1
Line 308
  results always size=7
  elem always !<=-1
  ++ always !<=-1
Line 311
  elem {!<=-1,>=7}
  != {!<=-1,!>=2,>=0}
  7 always 7
Line 312
  nullptr always 0
  "Internal Error: Deserialization of error message failed" always "Internal Error: Deserialization of error message failed"
Line 314
  results always size=7
  0 always 0
Line 315
  results always size=7
  1 always 1
Line 316
  results always size=7
  2 always 2
  . always !<=-1
  id always !<=-1
Line 317
  results always size=7
  3 always 3
  hash always !<=-1
Line 318
  results always size=7
  4 always 4
Line 319
  results always size=7
  5 always 5
Line 320
  results always size=7
  6 always 6
Line 322
  stackSize always !<=-1
  stackSize always !<=-1
  = always 0
  0 always 0
Line 323
  ! always {!<=-1,!>=2}
  stackSize always !<=-1
Line 324
  return always {!<=-1,!>=2}
  false always 0
Line 327
  len always !<=-1
  len always !<=-1
  = always 0
  0 always 0
Line 328
  ! always {!<=-1,!>=2}
  len always !<=-1
Line 329
  return always {!<=-1,!>=2}
  false always 0
Line 333
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,0}
  < always {!<=-1,!>=2}
  len always !<=-1
  && always {!<=-1,!>=2}
  ++ always !<=0
  i always !<=-1
Line 335
  1 always 1
Line 339
  pos always !<=-1
  = always 0
  0 always 0
  pos {!<=-1,0}
  < {!<=-1,!>=2,0}
  temp possible size=0
  ( {!<=-1,0}
  && {!<=-1,!>=2,0}
  substrings possible size=0
  ( {!<=-1,0}
  < {!<=-1,!>=2,1}
  5 always 5
  ++ always !<=0
  pos always !<=-1
Line 340
  ( always !<=-1
  == always {!<=-1,!>=2}
  4 always 4
Line 341
  substrings always size=4
  pos always !<=-1
Line 344
  start always !<=-1
  = always !<=-1
  pos always !<=-1
Line 345
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "\t" always "\t"
  pos {symbolic=(start),!<=-1}
Line 346
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 347
  substrings always !size=4
  start always !<=-1
Line 350
  substrings always !size=4
  start always !<=-1
  pos always !<=-1
  - always !<=-1
  start always !<=-1
Line 352
  substrings possible size=5
  ( {!<=-1,5}
  < {!<=-1,!>=2,0}
  4 always 4
Line 353
  nullptr always 0
  "Internal Error: serializing/deserializing of error message failed!" always "Internal Error: serializing/deserializing of error message failed!"
Line 357
  substrings {size=5,!<=size=3,>=size=4}
  3 always 3
  substrings {size=5,!<=size=3,>=size=4}
  0 always 0
  substrings {size=5,!<=size=3,>=size=4}
  1 always 1
Line 358
  substrings {size=5,!<=size=3,>=size=4}
  2 always 2
Line 359
  substrings {!<=size=3,>=size=4}
  ( {!<=3,>=4}
  == {!<=-1,!>=2,>=0}
  5 always 5
Line 360
  substrings always size=5
  4 always 4
Line 364
  callStack always !size=0
  ( always !<=0
  >= always {!<=-1,!>=2}
  stackSize always !<=-1
Line 368
  return always {!<=-1,!>=2}
  true always 1
Line 376
  "xml version=\"1.0\" encoding=\"UTF-8\"" always "xml version=\"1.0\" encoding=\"UTF-8\""
Line 379
  "results" always "results"
  false always 0
Line 381
  "version" always "version"
  2 always 2
Line 382
  "cppcheck" always "cppcheck"
  false always 0
Line 383
  "version" always "version"
Line 384
  false always 0
Line 385
  "errors" always "errors"
  false always 0
Line 387
  '>' always 62
Line 392
  "    </errors>\n</results>" always "    </errors>\n</results>"
Line 400
  result always size=0
  ( always !<=-1
Line 401
  = {lifetime[Iterator]=(raw),start=0}
  ( {lifetime[Iterator]=(raw),start=0}
Line 402
  from possible {lifetime[Iterator]=(raw),symbolic=(raw.begin()),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(raw),end=0}
Line 403
  ( always !<=-1
  from {lifetime[Iterator]=(raw),!symbolic=(raw.end()),!end=0}
Line 404
  result possible lifetime[Object]=(raw)
  from {lifetime[Iterator]=(raw),!symbolic=(raw.end()),!end=0}
Line 408
  uFrom always !<=-1
  = always !<=-1
  ( always !<=-1
  from {lifetime[Iterator]=(raw),!symbolic=(raw.end()),!end=0}
Line 409
  '\\' always 92
  8 always 8
  3 always 3
  '0' always 48
  uFrom {symbolic=((unsigned char)*from),!<=-1}
Line 412
  ++ always !symbolic=(raw.end()+1)
  from {lifetime[Iterator]=(raw),!symbolic=(raw.end()),!end=0}
Line 419
  nullptr always 0
  false always 0
  2 always 2
Line 420
  "error" always "error"
  false always 0
Line 421
  "id" always "id"
  ( {lifetime[Object]=(id),!0}
Line 422
  "severity" always "severity"
  ( {lifetime[Object]=(Severity::toString(severity)),!0}
Line 423
  "msg" always "msg"
  ( {lifetime[Object]=(fixInvalidChars(mShortMessage)),!0}
Line 424
  "verbose" always "verbose"
  ( {lifetime[Object]=(fixInvalidChars(mVerboseMessage)),!0}
Line 425
  . always !<=-1
  id always !<=-1
Line 426
  "cwe" always "cwe"
  . always !<=-1
  id always !<=-1
Line 427
  hash always !<=-1
Line 428
  "hash" always "hash"
  hash always !<=0
  ( {lifetime[Object]=(MathLib::toString(hash)),!0}
Line 429
  == always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
Line 430
  "inconclusive" always "inconclusive"
  "true" always "true"
Line 432
  ! {!<=-1,!>=2,0}
  file0 possible size=0
  ( {!<=-1,!>=2,1}
Line 433
  "file0" always "file0"
  file0 always !size=0
  ( {lifetime[Object]=(file0),!0}
Line 435
  = {lifetime[Iterator]=(callStack),start=0}
  ( {lifetime[Iterator]=(callStack),start=0}
  it possible {lifetime[Iterator]=(callStack),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callStack),end=0}
Line 436
  "location" always "location"
  false always 0
Line 437
  "file" always "file"
  it possible lifetime[Iterator]=(callStack)
  ( {lifetime[Object]=((*it).getfile()),!0}
Line 438
  "line" always "line"
  it possible lifetime[Iterator]=(callStack)
  0 always 0
Line 439
  "column" always "column"
  it possible lifetime[Iterator]=(callStack)
  . always !<=-1
  column always !<=-1
Line 440
  ! {!<=-1,!>=2,0}
  ( possible size=0
  ( {!<=-1,!>=2,1}
Line 441
  "info" always "info"
  ( always !size=0
  ( {lifetime[Object]=(fixInvalidChars(it->getinfo())),!0}
Line 442
  false always 0
Line 444
  pos always !<=-1
  = always 0
  0 always 0
  pos {symbolic=(pos2),symbolic=(pos2+1),!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 445
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  '\n' always 10
  pos {!<=-1,0}
Line 447
  pos2 always !<=-1
  == always {!<=-1,!>=2}
Line 448
  pos always !<=-1
Line 449
  pos always !<=-1
  = always !<=-1
  pos2 always !<=-1
Line 451
  pos always !<=-1
  pos2 always !<=-1
  - always !<=-1
  pos always !<=-1
Line 452
  pos always !<=-1
  = always !<=0
  pos2 always !<=-1
  + always !<=0
  1 always 1
Line 454
  "symbol" always "symbol"
  false always 0
Line 455
  ( {lifetime[Object]=(symbolName),!0}
Line 456
  false always 0
Line 458
  false always 0
Line 471
  :: always !<=-1
  index always !<=-1
  index always !<=-1
  = always 0
  0 always 0
Line 472
  index always !<=-1
  = always !<=-1
  ( always !<=-1
  searchFor inconclusive {"\\b"@30,"\\n"@31,"\\r"@32,"\\t"@33,"{id}"@35,"{severity}"@37,"{cwe}"@38,"{message}"@40,"{callstack}"@41,"{file}"@43}
  index {!<=-1,0}
  != always {!<=-1,!>=2}
Line 473
  index always !<=-1
  searchFor inconclusive {"\\b"@30,"\\n"@31,"\\r"@32,"\\t"@33,"{id}"@35,"{severity}"@37,"{cwe}"@38,"{message}"@40,"{callstack}"@41,"{file}"@43}
  ( always !<=-1
  replaceWith inconclusive {"\b"@30,"\n"@31,"\r"@32,"\t"@33,"nofile"@52,"0"@53,"0"@54,"\b"@56,"\n"@57,"\r"@58}
Line 474
  index always !<=-1
  += always !<=-1
  replaceWith inconclusive {"\b"@30,"\n"@31,"\r"@32,"\t"@33,"nofile"@52,"0"@53,"0"@54,"\b"@56,"\n"@57,"\r"@58}
  ( always !<=-1
Line 483
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  line possible size=0
Line 484
  linenr {>=1,!<=0}
  -- {>=1,!<=0}
Line 486
  endPos always !<=-1
  = always !<=-1
  ( always !<=-1
  "\r\n\t " always "\r\n\t "
Line 487
  endPos always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 488
  endPos always !<=-1
  + always !<=0
  1 always 1
Line 489
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 490
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\t' always 9
  pos {!<=-1,0}
  != always {!<=-1,!>=2}
Line 491
  pos always !<=-1
  = always 32
  ' ' always 32
Line 492
  > always {!<=-1,!>=2}
  0 always 0
  ? possible 0
  column {>=1,!<=0}
  - {>=0,!<=-1}
  1 always 1
  : always 0
  column {!>=1,<=0}
  ' ' always 32
  '^' always 94
Line 497
  "{reset}" always "{reset}"
  :: always 0
  Reset always 0
Line 498
  "{bold}" always "{bold}"
  :: always 1
  Bold always 1
Line 499
  "{dim}" always "{dim}"
  :: always 2
  Dim always 2
Line 500
  "{red}" always "{red}"
  :: always 31
  FgRed always 31
Line 501
  "{green}" always "{green}"
  :: always 32
  FgGreen always 32
Line 502
  "{blue}" always "{blue}"
  :: always 34
  FgBlue always 34
Line 503
  "{magenta}" always "{magenta}"
  :: always 35
  FgMagenta always 35
Line 504
  "{default}" always "{default}"
  :: always 39
  FgDefault always 39
Line 507
  verbose always {!<=-1,!>=2}
Line 512
  ( always {!<=-1,!>=2}
Line 514
  ! {!<=-1,!>=2,0}
  callStack possible size=0
  ( {!<=-1,!>=2,1}
Line 515
  callStack always !size=0
  ": " always ": "
Line 516
  != always {!<=-1,!>=2}
Line 517
  '(' always 40
Line 518
  == always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
Line 519
  ", inconclusive" always ", inconclusive"
Line 520
  ") " always ") "
Line 522
  verbose always {!<=-1,!>=2}
Line 530
  "\\b" always "\\b"
  "\b" always "\b"
Line 531
  "\\n" always "\\n"
  "\n" always "\n"
Line 532
  "\\r" always "\\r"
  "\r" always "\r"
Line 533
  "\\t" always "\\t"
  "\t" always "\t"
Line 536
  "{id}" always "{id}"
Line 538
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  "{inconclusive:" always "{inconclusive:"
Line 539
  pos1 always !<=-1
  != always {!<=-1,!>=2}
Line 540
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  '}' always 125
  pos1 always !<=-1
  + always !<=0
  1 always 1
Line 541
  pos1 always !<=-1
  pos2 always !<=-1
  - always !<=-1
  pos1 always !<=-1
  + always !<=0
  1 always 1
Line 542
  == always {!<=-1,!>=2}
  :: always 1
  inconclusive always 1
  pos1 always !<=-1
  + always !<=13
  14 always 14
  pos2 always !<=-1
  - always !<=-1
  pos1 always !<=-1
  - always !<=-1
  14 always 14
Line 544
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  "{inconclusive:" always "{inconclusive:"
  pos1 always !<=-1
Line 546
  "{severity}" always "{severity}"
Line 547
  "{cwe}" always "{cwe}"
  . always !<=-1
  id always !<=-1
Line 548
  "{message}" always "{message}"
  verbose always {!<=-1,!>=2}
Line 549
  "{callstack}" always "{callstack}"
  callStack possible size=0
  ( {!<=-1,!>=2,0,1}
  callStack always !size=0
Line 550
  ! {!<=-1,!>=2,0}
  callStack possible size=0
  ( {!<=-1,!>=2,1}
Line 551
  "{file}" always "{file}"
  callStack always !size=0
Line 552
  "{line}" always "{line}"
  callStack always !size=0
Line 553
  "{column}" always "{column}"
  callStack always !size=0
  . always !<=-1
  column always !<=-1
Line 554
  ( always !<=-1
  "{code}" always "{code}"
  != always {!<=-1,!>=2}
Line 555
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\r' always 13
Line 557
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 558
  = always "\n"
  "\n" always "\n"
Line 559
  pos always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(result.size()-2),!>=symbolic=(result.size()-1)}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 560
  = always "\r\n"
  "\r\n" always "\r\n"
Line 562
  = always "\r"
  "\r" always "\r"
Line 563
  "{code}" always "{code}"
  callStack always !size=0
  callStack always !size=0
  callStack always !size=0
  . always !<=-1
  column always !<=-1
  endl possible {"\n","\r\n","\r"}
Line 566
  "{file}" always "{file}"
  "nofile" always "nofile"
Line 567
  "{line}" always "{line}"
  "0" always "0"
Line 568
  "{column}" always "{column}"
  "0" always "0"
Line 569
  "{code}" always "{code}"
Line 572
  ! {!<=-1,!>=2,0}
  templateLocation possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  2U always 2
Line 573
  callStack {>=size=2,!<=size=1}
Line 576
  "\\b" always "\\b"
  "\b" always "\b"
Line 577
  "\\n" always "\\n"
  "\n" always "\n"
Line 578
  "\\r" always "\\r"
  "\r" always "\r"
Line 579
  "\\t" always "\\t"
  "\t" always "\t"
Line 582
  "{file}" always "{file}"
Line 583
  "{line}" always "{line}"
Line 584
  "{column}" always "{column}"
  . always !<=-1
  column always !<=-1
Line 585
  "{info}" always "{info}"
  ( always {!<=-1,!>=2}
  ( always !size=0
Line 586
  ( always !<=-1
  "{code}" always "{code}"
  != always {!<=-1,!>=2}
Line 587
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  '\r' always 13
Line 589
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 590
  = always "\n"
  "\n" always "\n"
Line 591
  pos always !<=-1
  + always !<=0
  1 always 1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(text.size()-2),!>=symbolic=(text.size()-1)}
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '\n' always 10
Line 592
  = always "\r\n"
  "\r\n" always "\r\n"
Line 594
  = always "\r"
  "\r" always "\r"
Line 595
  "{code}" always "{code}"
  . always !<=-1
  column always !<=-1
  endl possible {"\n","\r\n","\r"}
Line 597
  '\n' always 10
Line 604
  ( always {!<=-1,!>=2}
Line 606
  err always {!<=-1,!>=2}
  err always {!<=-1,!>=2}
  = always 0
  false always 0
Line 610
  == always {!<=-1,!>=2}
  "unmatchedSuppression" always "unmatchedSuppression"
Line 614
  suppressed always {!<=-1,!>=2}
  suppressed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 616
  == always {!<=-1,!>=2}
  "unmatchedSuppression" always "unmatchedSuppression"
Line 617
  . possible {symbolic=(s.fileName),size=1}
  ( {!<=-1,!>=2,0}
  || always {!<=-1,!>=2}
  . {size=1,!size=0}
  == always {!<=-1,!>=2}
  "*" always "*"
  || always {!<=-1,!>=2}
  . always !size=0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 618
  == always {!<=-1,!>=2}
  :: always -1
  NO_LINE always -1
  || always {!<=-1,!>=2}
  . always !-1
  == always {!<=-1,!>=2}
Line 619
  suppressed always {!<=-1,!>=2}
  = always 1
  true always 1
Line 625
  suppressed {!<=-1,!>=2,1}
Line 629
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 630
  . always !size=0
  0 always 0
Line 631
  :: always 6
  information always 6
  "Unmatched suppression: " always "Unmatched suppression: "
  "unmatchedSuppression" always "unmatchedSuppression"
Line 632
  err always {!<=-1,!>=2}
  = always 1
  true always 1
Line 634
  return always {!<=-1,!>=2}
  err always {!<=-1,!>=2}
Line 640
  = {lifetime[Iterator]=(callStack),start=0}
  ( {lifetime[Iterator]=(callStack),start=0}
  tok possible {lifetime[Iterator]=(callStack),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callStack),end=0}
Line 641
  tok possible lifetime[Iterator]=(callStack)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(callStack),start=0}
  "" always ""
  : always " -> "
  " -> " always " -> "
Line 642
  tok possible lifetime[Iterator]=(callStack)
Line 644
  str possible size=0
Line 649
  fileIndex always !<=-1
  column always !<=-1
Line 653
  fileIndex always !<=-1
  column always !<=-1
Line 656
  convert always {!<=-1,!>=2}
Line 658
  convert {!<=-1,!>=2,0@98}
Line 663
  convert always {!<=-1,!>=2}
Line 665
  convert always {!<=-1,!>=2}
Line 680
  '[' always 91
Line 682
  != always {!<=-1,!>=2}
  :: always -1
  NO_LINE always -1
Line 683
  ':' always 58
Line 684
  line always !-1
Line 686
  ']' always 93
Line 687
  str always !<=size=0
Line 693
  c always !<=-1
  : always !<=-1
Line 694
  c always !<=-1
Line 695
  '<' always 60
Line 696
  "&lt;" always "&lt;"
Line 698
  '>' always 62
Line 699
  "&gt;" always "&gt;"
Line 701
  '&' always 38
Line 702
  "&amp;" always "&amp;"
Line 704
  '\"' always 34
Line 705
  "&quot;" always "&quot;"
Line 707
  '\'' always 39
Line 708
  "&apos;" always "&apos;"
Line 710
  '\0' always 0
Line 711
  "\\0" always "\\0"
Line 714
  c {!<=-1,<=127,>=128}
  >= {!<=-1,!>=2,<=1}
  ' ' always 32
  && always {!<=-1,!>=2}
  c {>=32,!<=31}
  <= {!<=-1,!>=2,>=1}
  0x7f always 127
Line 715
  c {>=32,!<=31,<=127,!>=128}
Line 717
  'x' always 120
Line 727
  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n" always "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
Line 728
  "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\r\n" always "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\r\n"
Line 729
  "<plist version=\"1.0\">\r\n" always "<plist version=\"1.0\">\r\n"
Line 730
  "<dict>\r\n" always "<dict>\r\n"
Line 731
  " <key>clang_version</key>\r\n" always " <key>clang_version</key>\r\n"
Line 732
  "<string>cppcheck version " always "<string>cppcheck version "
  "</string>\r\n" always "</string>\r\n"
Line 733
  " <key>files</key>\r\n" always " <key>files</key>\r\n"
Line 734
  " <array>\r\n" always " <array>\r\n"
Line 736
  "  <string>" always "  <string>"
  "</string>\r\n" always "</string>\r\n"
Line 737
  " </array>\r\n" always " </array>\r\n"
Line 738
  " <key>diagnostics</key>\r\n" always " <key>diagnostics</key>\r\n"
Line 739
  " <array>\r\n" always " <array>\r\n"
Line 746
  indent possible {"          "@13,"          "@14,"          "@15,"          "@16,"     "@18,"        "@19,"        "@20,"  "@27}
  "<dict>\r\n" always "<dict>\r\n"
Line 747
  indent possible {"          "@13,"          "@14,"          "@15,"          "@16,"     "@18,"        "@19,"        "@20,"  "@27}
  ' ' always 32
  "<key>line</key><integer>" always "<key>line</key><integer>"
  "</integer>\r\n" always "</integer>\r\n"
Line 748
  indent possible {"          "@13,"          "@14,"          "@15,"          "@16,"     "@18,"        "@19,"        "@20,"  "@27}
  ' ' always 32
  "<key>col</key><integer>" always "<key>col</key><integer>"
  . always !<=-1
  column always !<=-1
  "</integer>\r\n" always "</integer>\r\n"
Line 749
  indent possible {"          "@13,"          "@14,"          "@15,"          "@16,"     "@18,"        "@19,"        "@20,"  "@27}
  ' ' always 32
  "<key>file</key><integer>" always "<key>file</key><integer>"
  . always !<=-1
  fileIndex always !<=-1
  "</integer>\r\n" always "</integer>\r\n"
Line 750
  indent possible {"          "@13,"          "@14,"          "@15,"          "@16,"     "@18,"        "@19,"        "@20,"  "@27}
  "</dict>\r\n" always "</dict>\r\n"
Line 757
  "  <dict>\r\n" always "  <dict>\r\n"
Line 758
  "   <key>path</key>\r\n" always "   <key>path</key>\r\n"
Line 759
  "   <array>\r\n" always "   <array>\r\n"
Line 761
  = {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),start=0}
  ( {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),start=0}
Line 763
  = {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev),start=0}
  ( {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev),start=0}
  it possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),end=0}
Line 764
  prev possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack)}
  != always {!<=-1,!>=2}
  it possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack)}
Line 765
  "    <dict>\r\n" always "    <dict>\r\n"
Line 766
  "     <key>kind</key><string>control</string>\r\n" always "     <key>kind</key><string>control</string>\r\n"
Line 767
  "     <key>edges</key>\r\n" always "     <key>edges</key>\r\n"
Line 768
  "      <array>\r\n" always "      <array>\r\n"
Line 769
  "       <dict>\r\n" always "       <dict>\r\n"
Line 770
  "        <key>start</key>\r\n" always "        <key>start</key>\r\n"
Line 771
  "         <array>\r\n" always "         <array>\r\n"
Line 772
  "          " always "          "
  prev {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(it),lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack)}
Line 773
  "          " always "          "
  prev {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(it),lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack)}
Line 774
  "         </array>\r\n" always "         </array>\r\n"
Line 775
  "        <key>end</key>\r\n" always "        <key>end</key>\r\n"
Line 776
  "         <array>\r\n" always "         <array>\r\n"
Line 777
  "          " always "          "
  it {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(prev)}
Line 778
  "          " always "          "
  it {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(prev)}
Line 779
  "         </array>\r\n" always "         </array>\r\n"
Line 780
  "       </dict>\r\n" always "       </dict>\r\n"
Line 781
  "      </array>\r\n" always "      </array>\r\n"
Line 782
  "    </dict>\r\n" always "    </dict>\r\n"
Line 783
  = {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(prev)}
  it {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),!symbolic=(prev)}
Line 786
  :: possible lifetime[Iterator]=(msg.callStack)
  next possible lifetime[Iterator]=(msg.callStack)
  = possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev)}
  it possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev)}
Line 787
  ++ {symbolic=(it+1),symbolic=(prev+1)}
  next {symbolic=(it),lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev)}
Line 788
  it possible {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),symbolic=(prev)}
  && always {!<=-1,!>=2}
  next possible lifetime[Iterator]=(msg.callStack)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(msg.callStack),lifetime[Object]=(callStack),end=0}
Line 790
  "    <dict>\r\n" always "    <dict>\r\n"
Line 791
  "     <key>kind</key><string>event</string>\r\n" always "     <key>kind</key><string>event</string>\r\n"
Line 792
  "     <key>location</key>\r\n" always "     <key>location</key>\r\n"
Line 793
  "     " always "     "
Line 794
  "     <key>ranges</key>\r\n" always "     <key>ranges</key>\r\n"
Line 795
  "     <array>\r\n" always "     <array>\r\n"
Line 796
  "       <array>\r\n" always "       <array>\r\n"
Line 797
  "        " always "        "
Line 798
  "        " always "        "
Line 799
  "       </array>\r\n" always "       </array>\r\n"
Line 800
  "     </array>\r\n" always "     </array>\r\n"
Line 801
  "     <key>depth</key><integer>0</integer>\r\n" always "     <key>depth</key><integer>0</integer>\r\n"
Line 802
  "     <key>extended_message</key>\r\n" always "     <key>extended_message</key>\r\n"
Line 803
  "     <string>" always "     <string>"
  "</string>\r\n" always "</string>\r\n"
Line 804
  "     <key>message</key>\r\n" always "     <key>message</key>\r\n"
Line 805
  "     <string>" always "     <string>"
  "</string>\r\n" always "</string>\r\n"
Line 806
  "    </dict>\r\n" always "    </dict>\r\n"
Line 809
  "   </array>\r\n" always "   </array>\r\n"
Line 810
  "   <key>description</key><string>" always "   <key>description</key><string>"
  "</string>\r\n" always "</string>\r\n"
Line 811
  "   <key>category</key><string>" always "   <key>category</key><string>"
  "</string>\r\n" always "</string>\r\n"
Line 812
  "   <key>type</key><string>" always "   <key>type</key><string>"
  "</string>\r\n" always "</string>\r\n"
Line 813
  "   <key>check_name</key><string>" always "   <key>check_name</key><string>"
  "</string>\r\n" always "</string>\r\n"
Line 814
  "   <!-- This hash is experimental and going to change! -->\r\n" always "   <!-- This hash is experimental and going to change! -->\r\n"
Line 815
  "   <key>issue_hash_content_of_line_in_context</key><string>" always "   <key>issue_hash_content_of_line_in_context</key><string>"
  << always symbolic=(plist<<"   </array>\r\n"<<"   <key>description</key><string>"<<ErrorLogger::toxml(msg.shortMessage())<<"</string>\r\n"<<"   <key>category</key><string>"<<Severity::toString(msg.severity)<<"</string>\r\n"<<"   <key>type</key><string>"<<ErrorLogger::toxml(msg.shortMessage())<<"</string>\r\n"<<"   <key>check_name</key><string>"<<msg.id<<"</string>\r\n"<<"   <!-- This hash is experimental and going to change! -->\r\n"<<"   <key>issue_hash_content_of_line_in_context</key><string>")
  0 always 0
  "</string>\r\n" always "</string>\r\n"
Line 816
  "  <key>issue_context_kind</key><string></string>\r\n" always "  <key>issue_context_kind</key><string></string>\r\n"
Line 817
  "  <key>issue_context</key><string></string>\r\n" always "  <key>issue_context</key><string></string>\r\n"
Line 818
  "  <key>issue_hash_function_offset</key><string></string>\r\n" always "  <key>issue_hash_function_offset</key><string></string>\r\n"
Line 819
  "  <key>location</key>\r\n" always "  <key>location</key>\r\n"
Line 820
  "  " always "  "
Line 821
  "  </dict>\r\n" always "  </dict>\r\n"
Line 828
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always 0
  0 always 0
Line 829
  pos1 {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 830
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  from inconclusive {"$symbol"@101,"$symbol"@102,"$symbol"@104,"$symbol"@105,"$symbol"@106}
  pos1 {!<=-1,<=symbolic=(s.size()-1),!>=symbolic=(s.size())}
Line 831
  pos1 {!<=-1,<=0}
  == always {!<=-1,!>=2}
Line 833
  pos1 always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  pos1 {>=1,!<=0}
  - {!<=-1,>=0}
  1 always 1
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  pos1 always !<=0
  - always !<=-1
  1 always 1
Line 834
  pos1 {>=1,!<=0}
  ++ {>=1,!<=0}
Line 837
  pos2 always !<=-1
  = always !<=-1
  pos1 {!<=-1,<=0}
  + always !<=-1
  ( always !<=-1
Line 838
  pos2 {symbolic=(pos1+from.size()),!<=-1}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 839
  0 always 0
  pos1 always !<=-1
Line 840
  pos2 {symbolic=(pos1+from.size()),!<=-1,!>=symbolic=(s.size()),<=symbolic=(s.size()-1)}
  == always {!<=-1,!>=2}
  '_' always 95
  || always {!<=-1,!>=2}
  pos2 {symbolic=(pos1+from.size()),!<=-1,!>=symbolic=(s.size())}
Line 841
  pos1 always !<=-1
  ++ always !<=-1
Line 844
  0 always 0
  pos1 always !<=-1
  pos2 always !<=-1
Line 845
  pos1 always !<=-1
  += always !<=-1
  ( always !<=-1
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
