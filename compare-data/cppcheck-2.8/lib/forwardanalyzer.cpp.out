

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073744155 Type ::@expr1073744156 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073744157 Type ::@expr1073744158 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744159 ) ?@expr1073744160 mDoubleValue@var3 :@expr1073744161 (@expr1073744162 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073744163 ostringstream result@var19 ;
78: result@var19 <<@expr1073744164 value@var18 ;
79: return result@var19 .@expr1073744165 str (@expr1073744166 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/analyzer.h

1:
|
27:
28: class Token ;
29: template < class T >
30: class ValuePtr ;
31:
32: struct Analyzer {
33: struct Action {
34:
35: Action ( ) : mFlag@var107 ( 0 ) { }
36:
37: template < class T ,
38: $class $= $typename $std $:: $enable_if $< std :: is_convertible < T , unsigned int > $:: $value $> $:: $type ,
39: $class $= $typename $std $:: $enable_if $< ! std :: is_same < T , bool > $:: $value $> $:: $type >
40: Action ( T f@var91 ) : mFlag@var107 ( f@var91 )
41: { }
42:
43: enum Anonymous0 {
44: None = 0 ,
45: Read = ( 1 << 0 ) ,
46: Write = ( 1 << 1 ) ,
47: Invalid = ( 1 << 2 ) ,
48: Inconclusive = ( 1 << 3 ) ,
49: Match = ( 1 << 4 ) ,
50: Idempotent = ( 1 << 5 ) ,
51: Incremental = ( 1 << 6 ) ,
52: SymbolicMatch = ( 1 << 7 ) ,
53: Internal = ( 1 << 8 ) ,
54: } ;
55:
56: void set ( unsigned int f@var92 , bool state@var93 = true ) {
57: mFlag@var107 =@expr1073744167 state@var93 ?@expr1073744168 mFlag@var107 |@expr1073744169 f@var92 :@expr1073744170 mFlag@var107 &@expr1073744171 ~@expr1073744172 f@var92 ;
58: }
59:
60: bool get ( unsigned int f@var94 ) const {
61: return (@expr2349 (@expr2349 mFlag@var107 &@expr1073744175 f@var94 ) !=@expr1073744176 0 ) ;
62: }
63:
64: bool isRead ( ) const {
65: return get (@expr1073744177 Read ) ;
66: }
67:
68: bool isWrite ( ) const {
69: return get (@expr1073744178 Write ) ;
70: }
71:
72: bool isInvalid ( ) const {
73: return get (@expr1073744179 Invalid ) ;
74: }
75:
76: bool isInconclusive ( ) const {
77: return get (@expr1073744180 Inconclusive ) ;
78: }
79:
80: bool isNone ( ) const {
81: return mFlag@var107 ==@expr1073744181 None ;
82: }
83:
84: bool isModified ( ) const {
85: return isWrite (@expr1073744182 ) ||@expr1073744183 isInvalid (@expr1073744184 ) ;
86: }
87:
88: bool isIdempotent ( ) const {
89: return get (@expr1073744185 Idempotent ) ;
90: }
91:
92: bool isIncremental ( ) const {
93: return get (@expr1073744186 Incremental ) ;
94: }
95:
96: bool isSymbolicMatch ( ) const {
97: return get (@expr1073744187 SymbolicMatch ) ;
98: }
99:
100: bool isInternal ( ) const {
101: return get (@expr1073744188 Internal ) ;
102: }
103:
104: bool matches ( ) const {
105: return get (@expr1073744189 Match ) ;
106: }
107:
108: Action & operator|= ( Action a@var95 ) {
109: set (@expr1073744190 a@var95 .@expr1073744191 mFlag@var96 ) ;
110: return *@expr1073744192 this@expr1073744193 ;
111: }
112:
113: friend Action operator| ( Action a@var97 , Action b@var98 ) {
114: a@var97 |=@expr1073744194 b@var98 ;
115: return a@var97 ;
116: }
117:
118: friend bool operator== ( Action a@var99 , Action b@var100 ) {
119: return a@var99 .@expr1073744195 mFlag@var101 ==@expr1073744196 b@var100 .@expr1073744197 mFlag@var102 ;
120: }
121:
122: friend bool operator!= ( Action a@var103 , Action b@var104 ) {
123: return a@var103 .@expr1073744198 mFlag@var105 !=@expr1073744199 b@var104 .@expr1073744200 mFlag@var106 ;
124: }
125:
126: private:
127: unsigned int mFlag@var107 ;
128: } ;
129:
130: enum class Terminate { None , Bail , Escape , Modified , Inconclusive , Conditional } ;
131:
132: struct Result {
133: Result ( Action action@var108 = Action :: None , Terminate terminate@var109 = Terminate :: None )
134: : action@var110 ( action@var108 ) , terminate@var111 ( terminate@var109 )
135: { }
136: Action action@var110 ;
137: Terminate terminate@var111 ;
138:
139: void update ( Result rhs@var112 ) {
140: if (@expr1073744201 terminate@var111 ==@expr1073744202 Terminate ::@expr1073744203 None ) {
141: terminate@var111 =@expr1073744204 rhs@var112 .@expr1073744205 terminate@var113 ; }
142: action@var110 |=@expr1073744206 rhs@var112 .@expr1073744207 action@var114 ;
143: }
144: } ;
145:
146: enum class Direction { Forward , Reverse } ;
147:
148: struct Assume {
149: enum Flags {
150: None = 0 ,
151: Quiet = ( 1 << 0 ) ,
152: Absolute = ( 1 << 1 ) ,
153: ContainerEmpty = ( 1 << 2 ) ,
154: } ;
155: } ;
156:
157: enum class Evaluate { Integral , ContainerEmpty } ;
158:
159:
160: virtual Action analyze ( const Token * tok@var115 , Direction d@var116 ) const = 0 ;
161:
162: virtual void update ( Token * tok@var117 , Action a@var118 , Direction d@var119 ) = 0 ;
163:
164: virtual std :: vector < long long > evaluate ( Evaluate e@var120 , const Token * tok@var121 , const Token * ctx@var122 = nullptr ) const = 0 ;
165: std :: vector < long long > evaluate ( const Token * tok@var123 , const Token * ctx@var124 = nullptr ) const
166: {
167: return evaluate (@expr1073744208 Evaluate ::@expr1073744209 Integral , tok@var123 , ctx@var124 ) ;
168: }
169:
170: virtual bool lowerToPossible ( ) = 0 ;
171:
172: virtual bool lowerToInconclusive ( ) = 0 ;
173:
174: virtual bool updateScope ( const Token * endBlock@var125 , bool modified@var126 ) const = 0 ;
175:
176: virtual void forkScope ( const Token * ) { }
177:
178: virtual bool isConditional ( ) const = 0 ;
179:
180: virtual bool stopOnCondition ( const Token * condTok@var127 ) const = 0 ;
181:
182: virtual void assume ( const Token * tok@var128 , bool state@var129 , unsigned int flags@var130 = 0 ) = 0 ;
183:
184: virtual ValuePtr<Analyzer> reanalyze ( Token * tok@var131 , const std :: string & msg@var132 = "" ) const = 0 ;
185: virtual ~ Analyzer ( ) { }
186: } ;

##file cppcheck-2.8/lib/forwardanalyzer.h

1:
|
23:
24: class Settings ;
25: class Token ;
26: template < class T > class ValuePtr ;
27:
28: Analyzer :: Result valueFlowGenericForward ( Token * start@var133 ,
29: const Token * end@var134 ,
30: const ValuePtr<Analyzer> & a@var135 ,
31: const Settings * settings@var136 ) ;
32:
33: Analyzer :: Result valueFlowGenericForward ( Token * start@var137 , const ValuePtr<Analyzer> & a@var138 , const Settings * settings@var139 ) ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var140 , const std :: string & errorMsg@var141 , Type type@var142 = INTERNAL ) ;
38: const Token * token@var143 ;
39: std :: string errorMessage@var144 ;
40: Type type@var145 ;
41: std :: string id@var146 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var147 ) ;
117: static SeverityType fromString ( const std :: string & severity@var148 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var149 ) : id@var150 ( cweId@var149 ) { }
122: unsigned short id@var150 ;
123: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var151 ) const {
35: return p@var151 .@expr1073744210 first@var152 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var153 ) const {
42: return p@var153 .@expr1073744211 second@var154 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var155 , const T & x@var156 )
48: {
49: return std ::@expr1073744212 find (@expr1073744213 r@var155 .@expr1073744214 begin (@expr1073744215 ) , r@var155 .@expr2392 end (@expr2393 ) , x@var156 ) !=@expr1073744218 r@var155 .@expr2392 end (@expr2393 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var157 , const T & x@var158 )
54: {
55: return std ::@expr1073744221 find (@expr1073744222 r@var157 .@expr1073744223 begin (@expr1073744224 ) , r@var157 .@expr2401 end (@expr2402 ) , x@var158 ) !=@expr1073744227 r@var157 .@expr2401 end (@expr2402 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var159 , const U & x@var160 )
60: {
61: return std ::@expr1073744230 find (@expr1073744231 r@var159 .@expr1073744232 begin (@expr1073744233 ) , r@var159 .@expr2410 end (@expr2411 ) , x@var160 ) !=@expr1073744236 r@var159 .@expr2410 end (@expr2411 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var161 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744239 t@var161 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var162 , char c@var163 )
74: {
75: return !@expr1073744240 str@var162 .@expr1073744241 empty (@expr1073744242 ) &&@expr1073744243 str@var162 .@expr1073744244 back (@expr1073744245 ) ==@expr1073744246 c@var163 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var164 , const char end@var165 [ ] , unsigned long endlen@var166 )
79: {
80: return (@expr2423 str@var164 .@expr2424 size (@expr2425 ) >=@expr1073744250 endlen@var166 ) &&@expr1073744251 (@expr2423 str@var164 .@expr1073744253 compare (@expr1073744254 str@var164 .@expr2424 size (@expr2425 ) -@expr1073744257 endlen@var166 , endlen@var166 , end@var165 ) ==@expr1073744258 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var167 , const char ( & end@var168 ) [ N ] )
85: {
86: return endsWith (@expr1073744260 str@var167 , end@var168 , N@expr1073744259 -@expr1073744261 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var169 , char q@var170 , const std :: string & p@var171 )
90: {
91: if (@expr1073744262 !@expr1073744263 endsWith (@expr1073744264 str@var169 , q@var170 ) ) {
92: return false ; }
93: if (@expr1073744265 (@expr1073744266 str@var169 .@expr1073744267 length (@expr1073744268 ) +@expr1073744269 1 ) >@expr1073744270 p@var171 .@expr1073744271 length (@expr1073744272 ) &&@expr1073744273 (@expr1073744274 str@var169 .@expr1073744275 compare (@expr1073744276 0 , p@var171 .@expr1073744277 size (@expr1073744278 ) +@expr1073744279 1 , p@var171 +@expr1073744280 q@var170 ) ==@expr1073744281 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var172 , char q@var173 )
99: {
100: static const std ::@expr2458 vector < std ::@expr2458 string > suffixes@var174 {@expr1073744284 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744285 const std ::@expr2458 string &@expr1073744287 p@var175 :@expr1073744288 suffixes@var174 ) {
102: if (@expr1073744289 isPrefixStringCharLiteral (@expr1073744290 str@var172 , q@var173 , p@var175 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var176 )
109: {
110: return isStringCharLiteral (@expr1073744291 str@var176 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var177 )
114: {
115: return isStringCharLiteral (@expr1073744292 str@var177 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var178 , char q@var179 )
119: {
120: const unsigned long quotePos@var180 =@expr1073744293 str@var178 .@expr1073744294 find (@expr1073744295 q@var179 ) ;
121: return str@var178 .@expr1073744296 substr (@expr1073744297 quotePos@var180 +@expr1073744298 1U , str@var178 .@expr1073744299 size (@expr1073744300 ) -@expr1073744301 quotePos@var180 -@expr1073744302 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var181 )
125: {
126: if (@expr1073744303 isStringLiteral (@expr1073744304 str@var181 ) ) {
127: return getStringCharLiteral (@expr1073744305 str@var181 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var182 )
132: {
133: if (@expr1073744306 isCharLiteral (@expr1073744307 str@var182 ) ) {
134: return getStringCharLiteral (@expr1073744308 str@var182 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var183 )
139: {
140: if (@expr1073744309 i@var183 ==@expr1073744310 1 ) {
141: return "st" ; }
142: if (@expr1073744311 i@var183 ==@expr1073744312 2 ) {
143: return "nd" ; }
144: if (@expr1073744313 i@var183 ==@expr1073744314 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var184 , const std :: string & rhs@var185 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var186 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var187 , const std :: string & name@var188 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var189 , const std :: string & name@var190 ) ;
156:
157: void strTolower ( std :: string & str@var191 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var192 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var193 ;
42:
43:
44: std :: string stdValue@var194 ;
45:
46:
47: Standards ( ) : c@var192 ( CLatest ) , cpp@var193 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var195 ) {
50: stdValue@var194 =@expr1073744315 str@var195 ;
51: if (@expr1073744316 str@var195 ==@expr1073744317 "c89" ||@expr1073744318 str@var195 ==@expr1073744319 "C89" ) {
52: c@var192 =@expr1073744320 C89 ;
53: return true ;
54: }
55: if (@expr1073744321 str@var195 ==@expr1073744322 "c99" ||@expr1073744323 str@var195 ==@expr1073744324 "C99" ) {
56: c@var192 =@expr1073744325 C99 ;
57: return true ;
58: }
59: if (@expr1073744326 str@var195 ==@expr1073744327 "c11" ||@expr1073744328 str@var195 ==@expr1073744329 "C11" ) {
60: c@var192 =@expr1073744330 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744331 c@var192 ) {
67: case C89 :@expr2508 ;
68: return "c89" ;
69: case C99 :@expr2508 ;
70: return "c99" ;
71: case C11 :@expr2508 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var196 ) {
77: if (@expr1073744335 std@var196 ==@expr1073744336 "c89" ) {
78: return Standards ::@expr1073744337 C89 ;
79: }
80: if (@expr1073744338 std@var196 ==@expr1073744339 "c99" ) {
81: return Standards ::@expr1073744340 C99 ;
82: }
83: if (@expr1073744341 std@var196 ==@expr1073744342 "c11" ) {
84: return Standards ::@expr1073744343 C11 ;
85: }
86: return Standards ::@expr1073744344 CLatest ;
87: }
88: bool setCPP ( std :: string str@var197 ) {
89: stdValue@var194 =@expr1073744345 str@var197 ;
90: strTolower (@expr1073744346 str@var197 ) ;
91: cpp@var193 =@expr1073744347 getCPP (@expr1073744348 str@var197 ) ;
92: return !@expr1073744349 stdValue@var194 .@expr1073744350 empty (@expr1073744351 ) &&@expr1073744352 str@var197 ==@expr1073744353 getCPP (@expr1073744354 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744355 cpp@var193 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var198 ) {
98: switch (@expr1073744356 std@var198 ) {
99: case CPP03 :@expr2533 ;
100: return "c++03" ;
101: case CPP11 :@expr2533 ;
102: return "c++11" ;
103: case CPP14 :@expr2533 ;
104: return "c++14" ;
105: case CPP17 :@expr2533 ;
106: return "c++17" ;
107: case CPP20 :@expr2533 ;
108: return "c++20" ;
109: case CPP23 :@expr2533 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var199 ) {
115: if (@expr1073744363 std@var199 ==@expr1073744364 "c++03" ) {
116: return Standards ::@expr1073744365 CPP03 ;
117: }
118: if (@expr1073744366 std@var199 ==@expr1073744367 "c++11" ) {
119: return Standards ::@expr1073744368 CPP11 ;
120: }
121: if (@expr1073744369 std@var199 ==@expr1073744370 "c++14" ) {
122: return Standards ::@expr1073744371 CPP14 ;
123: }
124: if (@expr1073744372 std@var199 ==@expr1073744373 "c++17" ) {
125: return Standards ::@expr1073744374 CPP17 ;
126: }
127: if (@expr1073744375 std@var199 ==@expr1073744376 "c++20" ) {
128: return Standards ::@expr1073744377 CPP20 ;
129: }
130: if (@expr1073744378 std@var199 ==@expr1073744379 "c++23" ) {
131: return Standards ::@expr1073744380 CPP23 ;
132: }
133: return Standards ::@expr1073744381 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var203 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var200 ) : errorcode@var203 ( e@var200 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var201 , T && r@var202 ) : errorcode@var203 ( e@var201 ) , reason@var204 ( r@var202 ) { }
66: ErrorCode errorcode@var203 ;
67: std :: string reason@var204 ;
68: } ;
69:
70: Error load ( const char exename@var205 [ ] , const char path@var206 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var207 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var208 [ ] , unsigned long len@var209 ) ;
75:
76: struct AllocFunc {
77: int groupId@var210 ;
78: int arg@var211 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var212 ;
81: int bufferSizeArg1@var213 ;
82: int bufferSizeArg2@var214 ;
83: int reallocArg@var215 ;
84: bool initData@var216 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var217 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var218 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var219 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var220 , int arg@var221 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var222 , int arg@var223 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var224 , int arg@var225 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var226 [ ] ) const {
107: return getAllocDealloc (@expr1073744382 mAlloc@var492 , name@var226 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var227 [ ] ) const {
112: return getAllocDealloc (@expr1073744383 mDealloc@var493 , name@var227 ) ;
113: }
114:
115:
116: int allocId ( const char name@var228 [ ] ) const {
117: const AllocFunc * af@var229 ; af@var229 =@expr1073744384 getAllocDealloc (@expr1073744385 mAlloc@var492 , name@var228 ) ;
118: return af@var229 ?@expr1073744386 af@var229 .@expr1073744387 groupId@var230 :@expr1073744388 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var231 [ ] ) const {
123: const AllocFunc * af@var232 ; af@var232 =@expr1073744389 getAllocDealloc (@expr1073744390 mDealloc@var493 , name@var231 ) ;
124: return af@var232 ?@expr1073744391 af@var232 .@expr1073744392 groupId@var233 :@expr1073744393 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var234 , int id@var235 , int arg@var236 ) {
129: mAlloc@var492 [@expr2570 functionname@var234 ] .@expr1073744395 groupId@var2331 =@expr1073744396 id@var235 ;
130: mAlloc@var492 [@expr2570 functionname@var234 ] .@expr1073744398 arg@var2332 =@expr1073744399 arg@var236 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var237 , int id@var238 , int arg@var239 ) {
134: mDealloc@var493 [@expr2576 functionname@var237 ] .@expr1073744401 groupId@var2333 =@expr1073744402 id@var238 ;
135: mDealloc@var493 [@expr2576 functionname@var237 ] .@expr1073744404 arg@var2334 =@expr1073744405 arg@var239 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var240 , int id@var241 , int arg@var242 , int reallocArg@var243 = 1 ) {
139: mRealloc@var494 [@expr2582 functionname@var240 ] .@expr1073744407 groupId@var2335 =@expr1073744408 id@var241 ;
140: mRealloc@var494 [@expr2582 functionname@var240 ] .@expr1073744410 arg@var2336 =@expr1073744411 arg@var242 ;
141: mRealloc@var494 [@expr2582 functionname@var240 ] .@expr1073744413 reallocArg@var2337 =@expr1073744414 reallocArg@var243 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var244 , bool noreturn@var245 ) {
146: mNoReturn@var495 [@expr1073744415 funcname@var244 ] =@expr1073744416 noreturn@var245 ?@expr1073744417 FalseTrueMaybe ::@expr1073744418 True :@expr1073744419 FalseTrueMaybe ::@expr1073744420 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var246 ) ;
150:
151:
152: static bool ismemory ( const int id@var247 ) {
153: return (@expr2597 (@expr2597 id@var247 >@expr1073744423 0 ) &&@expr1073744424 (@expr2597 (@expr2597 id@var247 &@expr1073744427 1 ) ==@expr1073744428 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var248 ) {
156: return (@expr2605 (@expr2605 func@var248 .@expr2607 groupId@var249 >@expr1073744432 0 ) &&@expr1073744433 (@expr2605 (@expr2605 func@var248 .@expr2607 groupId@var249 &@expr1073744437 1 ) ==@expr1073744438 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var250 ) {
161: return (@expr2615 (@expr2615 id@var250 >@expr1073744441 0 ) &&@expr1073744442 (@expr2615 (@expr2615 id@var250 &@expr1073744445 1 ) ==@expr1073744446 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var251 ) {
164: return (@expr2623 (@expr2623 func@var251 .@expr2625 groupId@var252 >@expr1073744450 0 ) &&@expr1073744451 (@expr2623 (@expr2623 func@var251 .@expr2625 groupId@var252 &@expr1073744455 1 ) ==@expr1073744456 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var253 ) const ;
168: int formatstr_argno ( const Token * ftok@var254 ) const ;
169: bool formatstr_scan ( const Token * ftok@var255 ) const ;
170: bool formatstr_secure ( const Token * ftok@var256 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var257 ;
174: int ptr2Arg@var258 ;
175: int sizeArg@var259 ;
176: int strlenArg@var260 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var261 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var262 ;
182: Standards standards@var263 ;
183: Severity :: SeverityType severity@var264 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var265 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var266 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var267 ) const ;
191: bool matchArguments ( const Token * ftok@var268 , const std :: string & functionName@var269 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var270 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var271 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var272 ) const ;
198: int returnValueContainer ( const Token * ftok@var273 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var274 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var275 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var276 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var277 , std :: string * unknownFunc@var278 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var288 ( -1 ) ,
210: size_templateArgNo@var290 ( -1 ) ,
211: arrayLike_indexOp@var291 ( false ) ,
212: stdStringLike@var292 ( false ) ,
213: stdAssociativeLike@var293 ( false ) ,
214: opLessAllowed@var294 ( true ) ,
215: hasInitializerListConstructor@var295 ( false ) ,
216: unstableErase@var296 ( false ) ,
217: unstableInsert@var297 ( false ) ,
218: view@var298 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var279 ;
248: Yield yield@var280 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var281 ;
252: int templateParameter@var282 ;
253: } ;
254: std :: string startPattern@var283 ; std :: string startPattern2@var284 ; std :: string endPattern@var285 ; std :: string itEndPattern@var286 ;
255: std :: map < std :: string , Function > functions@var287 ;
256: int type_templateArgNo@var288 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var289 ;
258: int size_templateArgNo@var290 ;
259: bool arrayLike_indexOp@var291 ;
260: bool stdStringLike@var292 ;
261: bool stdAssociativeLike@var293 ;
262: bool opLessAllowed@var294 ;
263: bool hasInitializerListConstructor@var295 ;
264: bool unstableErase@var296 ;
265: bool unstableInsert@var297 ;
266: bool view@var298 ;
267:
268: Action getAction ( const std :: string & function@var299 ) const {
269: const std ::@expr1073744457 map < std ::@expr1073744458 string , Function > ::@expr1073744459 const_iterator i@var300 =@expr1073744460 functions@var287 .@expr1073744461 find (@expr1073744462 function@var299 ) ;
270: if (@expr1073744463 i@var300 !=@expr1073744464 functions@var287 .@expr1073744465 end (@expr1073744466 ) ) {
271: return i@var300 .@expr1073744467 second@var301 .@expr1073744468 action@var302 ; }
272: return Action ::@expr1073744469 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var303 ) const {
276: const std ::@expr1073744470 map < std ::@expr1073744471 string , Function > ::@expr1073744472 const_iterator i@var304 =@expr1073744473 functions@var287 .@expr1073744474 find (@expr1073744475 function@var303 ) ;
277: if (@expr1073744476 i@var304 !=@expr1073744477 functions@var287 .@expr1073744478 end (@expr1073744479 ) ) {
278: return i@var304 .@expr1073744480 second@var305 .@expr1073744481 yield@var306 ; }
279: return Yield ::@expr1073744482 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var307 ) ;
283: static Action actionFrom ( const std :: string & actionName@var308 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var309 ;
286: const Container * detectContainer ( const Token * typeStart@var310 , bool iterator@var311 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var312 , bool * isIterator@var313 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var314 ( false ) ,
293: notnull@var315 ( false ) ,
294: notuninit@var316 ( -1 ) ,
295: formatstr@var317 ( false ) ,
296: strz@var318 ( false ) ,
297: optional@var319 ( false ) ,
298: variadic@var320 ( false ) ,
299: iteratorInfo@var326 ( ) ,
300: direction@var334 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var314 ;
303: bool notnull@var315 ;
304: int notuninit@var316 ;
305: bool formatstr@var317 ;
306: bool strz@var318 ;
307: bool optional@var319 ;
308: bool variadic@var320 ;
309: std :: string valid@var321 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var322 ( 0 ) , it@var323 ( false ) , first@var324 ( false ) , last@var325 ( false ) { }
314:
315: int container@var322 ;
316: bool it@var323 ;
317: bool first@var324 ;
318: bool last@var325 ;
319: } ;
320: IteratorInfo iteratorInfo@var326 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var327 , int a@var328 ) : type@var329 ( t@var327 ) , arg@var330 ( a@var328 ) , arg2@var331 ( 0 ) , value@var332 ( 0 ) { }
326: Type type@var329 ;
327: int arg@var330 ;
328: int arg2@var331 ;
329: long long value@var332 ;
330: } ;
331: std :: vector < MinSize > minsizes@var333 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var334 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var335 ;
344: bool use@var336 ;
345: bool leakignore@var337 ;
346: bool isconst@var338 ;
347: bool ispure@var339 ;
348: UseRetValType useretval@var340 ;
349: bool ignore@var341 ;
350: bool formatstr@var342 ;
351: bool formatstr_scan@var343 ;
352: bool formatstr_secure@var344 ;
353: Container :: Action containerAction@var345 ;
354: Container :: Yield containerYield@var346 ;
355: Function ( )
356: : use@var336 ( false ) ,
357: leakignore@var337 ( false ) ,
358: isconst@var338 ( false ) ,
359: ispure@var339 ( false ) ,
360: useretval@var340 ( UseRetValType :: NONE ) ,
361: ignore@var341 ( false ) ,
362: formatstr@var342 ( false ) ,
363: formatstr_scan@var343 ( false ) ,
364: formatstr_secure@var344 ( false ) ,
365: containerAction@var345 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var346 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var347 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var348 ;
372: bool isUse ( const std :: string & functionName@var349 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var350 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var351 , bool pure@var352 ) const ;
375: bool isFunctionConst ( const Token * ftok@var353 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var354 , int argnr@var355 ) const {
378: const ArgumentChecks * arg@var356 ; arg@var356 =@expr1073744483 getarg (@expr1073744484 ftok@var354 , argnr@var355 ) ;
379: return arg@var356 &&@expr1073744485 arg@var356 .@expr1073744486 notbool@var357 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var358 , int argnr@var359 ) const ;
383: bool isuninitargbad ( const Token * ftok@var360 , int argnr@var361 , int indirect@var362 = 0 , bool * hasIndirect@var363 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var364 , int argnr@var365 ) const {
386: const ArgumentChecks * arg@var366 ; arg@var366 =@expr1073744487 getarg (@expr1073744488 ftok@var364 , argnr@var365 ) ;
387: return arg@var366 &&@expr1073744489 arg@var366 .@expr1073744490 formatstr@var367 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var368 , int argnr@var369 ) const {
391: const ArgumentChecks * arg@var370 ; arg@var370 =@expr1073744491 getarg (@expr1073744492 ftok@var368 , argnr@var369 ) ;
392: return arg@var370 &&@expr1073744493 arg@var370 .@expr1073744494 strz@var371 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var372 , int argnr@var373 , const long long argvalue@var374 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var375 , int argnr@var376 , double argvalue@var377 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var378 , int argnr@var379 ) const {
399: const ArgumentChecks * arg@var380 ; arg@var380 =@expr1073744495 getarg (@expr1073744496 ftok@var378 , argnr@var379 ) ;
400: return arg@var380 ?@expr1073744497 arg@var380 .@expr1073744498 valid@var381 :@expr1073744499 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var382 ;
405: std :: string op1@var383 ;
406: std :: string op2@var384 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744500 isInt (@expr1073744501 op1@var383 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var385 , int argnr@var386 ) const {
413: const ArgumentChecks * arg@var387 ; arg@var387 =@expr1073744502 getarg (@expr1073744503 ftok@var385 , argnr@var386 ) ;
414: return arg@var387 &&@expr1073744504 arg@var387 .@expr2681 iteratorInfo@var388 .@expr1073744506 it@var389 ?@expr1073744507 &@expr1073744508 arg@var387 .@expr2681 iteratorInfo@var388 :@expr1073744510 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var390 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var391 , int argnr@var392 ) const {
420: const ArgumentChecks * arg@var393 ; arg@var393 =@expr1073744511 getarg (@expr1073744512 ftok@var391 , argnr@var392 ) ;
421: return arg@var393 ?@expr1073744513 &@expr1073744514 arg@var393 .@expr1073744515 minsizes@var394 :@expr1073744516 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var395 , int argnr@var396 ) const ;
425:
426: bool markupFile ( const std :: string & path@var397 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var398 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var502 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var399 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var400 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var401 , const std :: string & token@var402 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var403 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var404 ) const ;
443: const std :: string & blockend ( const std :: string & file@var405 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var406 , const std :: string & keyword@var407 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var408 ) const {
448: return mExporters@var505 .@expr1073744517 find (@expr1073744518 prefix@var408 ) !=@expr1073744519 mExporters@var505 .@expr1073744520 end (@expr1073744521 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var409 , const std :: string & token@var410 ) const {
452: const std ::@expr1073744522 map < std ::@expr1073744523 string , ExportedFunctions > ::@expr1073744524 const_iterator it@var411 =@expr1073744525 mExporters@var505 .@expr1073744526 find (@expr1073744527 prefix@var409 ) ;
453: return (@expr1073744528 it@var411 !=@expr1073744529 mExporters@var505 .@expr1073744530 end (@expr1073744531 ) &&@expr1073744532 it@var411 .@expr1073744533 second@var412 .@expr1073744534 isPrefix (@expr1073744535 token@var410 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var413 , const std :: string & token@var414 ) const {
457: const std ::@expr1073744536 map < std ::@expr1073744537 string , ExportedFunctions > ::@expr1073744538 const_iterator it@var415 =@expr1073744539 mExporters@var505 .@expr1073744540 find (@expr1073744541 prefix@var413 ) ;
458: return (@expr1073744542 it@var415 !=@expr1073744543 mExporters@var505 .@expr1073744544 end (@expr1073744545 ) &&@expr1073744546 it@var415 .@expr1073744547 second@var416 .@expr1073744548 isSuffix (@expr1073744549 token@var414 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var417 , const std :: string & importer@var418 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var419 , Container :: Yield yield@var420 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var421 , Container :: Action action@var422 ) const ;
465:
466: bool isreflection ( const std :: string & token@var423 ) const {
467: return mReflection@var507 .@expr1073744550 find (@expr1073744551 token@var423 ) !=@expr1073744552 mReflection@var507 .@expr1073744553 end (@expr1073744554 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var424 ) const {
471: const std ::@expr1073744555 map < std ::@expr1073744556 string , int > ::@expr1073744557 const_iterator it@var425 =@expr1073744558 mReflection@var507 .@expr1073744559 find (@expr1073744560 token@var424 ) ;
472: if (@expr1073744561 it@var425 !=@expr1073744562 mReflection@var507 .@expr1073744563 end (@expr1073744564 ) ) {
473: return it@var425 .@expr1073744565 second@var426 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var427 ;
478:
479: struct SmartPointer {
480: std :: string name@var428 ; name@var428 = "" ;
481: bool unique@var429 ; unique@var429 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var430 ;
485: bool isSmartPointer ( const Token * tok@var431 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var432 ) const ;
487:
488: struct PodType {
489: unsigned int size@var433 ;
490: char sign@var434 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var435 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var436 ) const {
494: const std ::@expr1073744566 unordered_map < std ::@expr1073744567 string , PodType > ::@expr1073744568 const_iterator it@var437 =@expr1073744569 mPodTypes@var508 .@expr1073744570 find (@expr1073744571 name@var436 ) ;
495: return (@expr2748 it@var437 !=@expr1073744573 mPodTypes@var508 .@expr1073744574 end (@expr1073744575 ) ) ?@expr1073744576 &@expr1073744577 (@expr2748 it@var437 .@expr1073744579 second@var438 ) :@expr1073744580 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var449 ( false )
501: , mUnsigned@var450 ( false )
502: , mLong@var451 ( false )
503: , mPointer@var452 ( false )
504: , mPtrPtr@var453 ( false )
505: , mConstPtr@var454 ( false ) { }
506: bool operator== ( const PlatformType & type@var439 ) const {
507: return (@expr1073744581 mSigned@var449 ==@expr1073744582 type@var439 .@expr1073744583 mSigned@var440 &&@expr1073744584
508: mUnsigned@var450 ==@expr1073744585 type@var439 .@expr1073744586 mUnsigned@var441 &&@expr1073744587
509: mLong@var451 ==@expr1073744588 type@var439 .@expr1073744589 mLong@var442 &&@expr1073744590
510: mPointer@var452 ==@expr1073744591 type@var439 .@expr1073744592 mPointer@var443 &&@expr1073744593
511: mPtrPtr@var453 ==@expr1073744594 type@var439 .@expr1073744595 mPtrPtr@var444 &&@expr1073744596
512: mConstPtr@var454 ==@expr1073744597 type@var439 .@expr1073744598 mConstPtr@var445 &&@expr1073744599
513: mType@var448 ==@expr1073744600 type@var439 .@expr1073744601 mType@var446 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var447 ) const {
516: return !@expr1073744602 (@expr1073744603 *@expr1073744604 this@expr1073744605 ==@expr1073744606 type@var447 ) ;
517: }
518: std :: string mType@var448 ;
519: bool mSigned@var449 ;
520: bool mUnsigned@var450 ;
521: bool mLong@var451 ;
522: bool mPointer@var452 ;
523: bool mPtrPtr@var453 ;
524: bool mConstPtr@var454 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var455 ) const {
529: const std ::@expr1073744607 map < std ::@expr1073744608 string , PlatformType > ::@expr1073744609 const_iterator it@var456 =@expr1073744610 mPlatformTypes@var458 .@expr1073744611 find (@expr1073744612 name@var455 ) ;
530: return (@expr2789 it@var456 !=@expr1073744614 mPlatformTypes@var458 .@expr1073744615 end (@expr1073744616 ) ) ?@expr1073744617 &@expr1073744618 (@expr2789 it@var456 .@expr1073744620 second@var457 ) :@expr1073744621 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var458 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var459 , const std :: string & platform@var460 ) const {
536: const std ::@expr1073744622 map < std ::@expr2799 string , Platform > ::@expr1073744624 const_iterator it@var461 =@expr1073744625 mPlatforms@var510 .@expr1073744626 find (@expr1073744627 platform@var460 ) ;
537: if (@expr1073744628 it@var461 !=@expr1073744629 mPlatforms@var510 .@expr1073744630 end (@expr1073744631 ) ) {
538: const PlatformType * const type@var462 ; type@var462 =@expr1073744632 it@var461 .@expr1073744633 second@var463 .@expr1073744634 platform_type (@expr1073744635 name@var459 ) ;
539: if (@expr1073744636 type@var462 ) {
540: return type@var462 ; }
541: }
542:
543: const std ::@expr1073744637 map < std ::@expr2799 string , PlatformType > ::@expr1073744639 const_iterator it2@var464 =@expr1073744640 mPlatformTypes@var509 .@expr1073744641 find (@expr1073744642 name@var459 ) ;
544: return (@expr2819 it2@var464 !=@expr1073744644 mPlatformTypes@var509 .@expr1073744645 end (@expr1073744646 ) ) ?@expr1073744647 &@expr1073744648 (@expr2819 it2@var464 .@expr1073744650 second@var465 ) :@expr1073744651 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var466 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var467 , Library :: Container :: Yield y@var468 , const std :: string & fallback@var469 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var470 , const std :: string & typeName@var471 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var472 , const std :: string & name@var473 , std :: set < std :: string > & unknown_elements@var474 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var475 ) {
565: mPrefixes@var479 .@expr1073744652 insert (@expr1073744653 prefix@var475 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var476 ) {
568: mSuffixes@var480 .@expr1073744654 insert (@expr1073744655 suffix@var476 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var477 ) const {
571: return (@expr1073744656 mPrefixes@var479 .@expr1073744657 find (@expr1073744658 prefix@var477 ) !=@expr1073744659 mPrefixes@var479 .@expr1073744660 end (@expr1073744661 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var478 ) const {
574: return (@expr1073744662 mSuffixes@var480 .@expr1073744663 find (@expr1073744664 suffix@var478 ) !=@expr1073744665 mSuffixes@var480 .@expr1073744666 end (@expr1073744667 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var479 ;
579: std :: set < std :: string > mSuffixes@var480 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var488 ( 0 ) { }
584:
585: void setStart ( const char * s@var481 ) {
586: mStart@var486 =@expr1073744668 s@var481 ;
587: }
588: void setEnd ( const char * e@var482 ) {
589: mEnd@var487 =@expr1073744669 e@var482 ;
590: }
591: void setOffset ( const int o@var483 ) {
592: mOffset@var488 =@expr1073744670 o@var483 ;
593: }
594: void addBlock ( const char * blockName@var484 ) {
595: mBlocks@var489 .@expr1073744671 insert (@expr1073744672 blockName@var484 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var486 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var487 ;
602: }
603: int offset ( ) const {
604: return mOffset@var488 ;
605: }
606: bool isBlock ( const std :: string & blockName@var485 ) const {
607: return mBlocks@var489 .@expr1073744673 find (@expr1073744674 blockName@var485 ) !=@expr1073744675 mBlocks@var489 .@expr1073744676 end (@expr1073744677 ) ;
608: }
609:
610: private:
611: std :: string mStart@var486 ;
612: std :: string mEnd@var487 ;
613: int mOffset@var488 ;
614: std :: set < std :: string > mBlocks@var489 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var490 ;
618: std :: set < std :: string > mFiles@var491 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var492 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var493 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var494 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var495 ;
623: std :: map < std :: string , std :: string > mReturnValue@var496 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var497 ;
625: std :: map < std :: string , int > mReturnValueContainer@var498 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var499 ;
627: std :: map < std :: string , bool > mReportErrors@var500 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var501 ;
629: std :: set < std :: string > mMarkupExtensions@var502 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var503 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var504 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var505 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var506 ;
634: std :: map < std :: string , int > mReflection@var507 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var508 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var509 ;
637: std :: map < std :: string , Platform > mPlatforms@var510 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var511 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var512 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var513 , int argnr@var514 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var515 , bool * error@var516 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var517 , const std :: string & name@var518 ) {
646: const std ::@expr1073744678 map < std ::@expr1073744679 string , AllocFunc > ::@expr1073744680 const_iterator it@var519 =@expr1073744681 data@var517 .@expr1073744682 find (@expr1073744683 name@var518 ) ;
647: return (@expr1073744684 it@var519 ==@expr1073744685 data@var517 .@expr1073744686 end (@expr1073744687 ) ) ?@expr1073744688 nullptr :@expr1073744689 &@expr1073744690 it@var519 .@expr1073744691 second@var520 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var521 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var522 ,
654: const Settings * settings@var523 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var524 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
|
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var525 ) const {
54: x@var525 ++@expr1073744692 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var526 ) const {
60: x@var526 --@expr1073744693 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var527 , const U & y@var528 ) const {
67: return x@var527 <@expr1073744694 y@var528 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var529 , const U & y@var530 ) const {
74: return std ::@expr1073744695 abs (@expr1073744696 x@var529 -@expr1073744697 y@var530 ) ==@expr1073744698 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var531 , T x@var532 , U y@var533 ) const {
81: result@var531 =@expr1073744699 !@expr1073744700 (@expr1073744701 x@var532 >@expr1073744702 y@var533 ||@expr1073744703 x@var532 <@expr1073744704 y@var533 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var534 = 0 , Bound b@var535 = Bound :: Point )
91: : valueType@var575 ( ValueType :: INT ) ,
92: bound@var576 ( b@var535 ) ,
93: intvalue@var577 ( val@var534 ) ,
94: tokvalue@var578 ( nullptr ) ,
95: floatValue@var579 ( 0.0 ) ,
96: moveKind@var580 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var581 ( val@var534 ) ,
98: condition@var582 ( nullptr ) ,
99: varId@var584 ( 0U ) ,
100: safe@var585 ( false ) ,
101: conditional@var586 ( false ) ,
102: macro@var587 ( false ) ,
103: defaultArg@var588 ( false ) ,
104: indirect@var589 ( 0 ) ,
105: path@var590 ( 0 ) ,
106: wideintvalue@var591 ( val@var534 ) ,
107: subexpressions@var592 ( ) ,
108: capturetok@var593 ( nullptr ) ,
109: lifetimeKind@var594 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var595 ( LifetimeScope :: Local ) ,
111: valueKind@var600 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var536 , long long val@var537 , Bound b@var538 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var539 ) const {
118: if (@expr1073744705 valueType@var575 !=@expr1073744706 rhs@var539 .@expr1073744707 valueType@var540 ) {
119: return false ; }
120: switch (@expr1073744708 valueType@var575 ) {
121: case ValueType ::@expr1073744709 INT :@expr2886
122: case ValueType ::@expr1073744711 CONTAINER_SIZE :@expr2886
123: case ValueType ::@expr1073744713 BUFFER_SIZE :@expr2886
124: case ValueType ::@expr1073744715 ITERATOR_START :@expr2886
125: case ValueType ::@expr1073744717 ITERATOR_END :@expr2886 ;
126: if (@expr2895 intvalue@var577 !=@expr2896 rhs@var539 .@expr2897 intvalue@var541 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744722 TOK :@expr2886 ;
130: if (@expr2900 tokvalue@var578 !=@expr2901 rhs@var539 .@expr2902 tokvalue@var542 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744727 FLOAT :@expr2886 ;
134:
135: if (@expr1073744729 floatValue@var579 >@expr1073744730 rhs@var539 .@expr2907 floatValue@var543 ||@expr1073744732 floatValue@var579 <@expr1073744733 rhs@var539 .@expr2907 floatValue@var543 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744735 MOVED :@expr2886 ;
139: if (@expr1073744737 moveKind@var580 !=@expr1073744738 rhs@var539 .@expr1073744739 moveKind@var544 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744740 UNINIT :@expr2886 ;
143: break ;
144: case ValueType ::@expr1073744742 LIFETIME :@expr2886 ;
145: if (@expr2900 tokvalue@var578 !=@expr2901 rhs@var539 .@expr2902 tokvalue@var542 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744747 SYMBOLIC :@expr2886 ;
149: if (@expr1073744749 !@expr1073744750 sameToken (@expr1073744751 tokvalue@var578 , rhs@var539 .@expr2902 tokvalue@var542 ) ) {
150: return false ; }
151: if (@expr2895 intvalue@var577 !=@expr2896 rhs@var539 .@expr2897 intvalue@var541 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var545 , F f@var546 ) {
160: switch (@expr1073744756 self@var545 .@expr1073744757 valueType@var547 ) {
161: case ValueType ::@expr1073744758 INT :@expr2935
162: case ValueType ::@expr1073744760 SYMBOLIC :@expr2935
163: case ValueType ::@expr1073744762 BUFFER_SIZE :@expr2935
164: case ValueType ::@expr1073744764 CONTAINER_SIZE :@expr2935
165: case ValueType ::@expr1073744766 ITERATOR_START :@expr2935
166: case ValueType ::@expr1073744768 ITERATOR_END :@expr2935 ; {
167: f@var546 (@expr1073744770 self@var545 .@expr1073744771 intvalue@var548 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744772 FLOAT :@expr2935 ; {
171: f@var546 (@expr1073744774 self@var545 .@expr1073744775 floatValue@var549 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744776 UNINIT :@expr2935
175: case ValueType ::@expr1073744778 TOK :@expr2935
176: case ValueType ::@expr1073744780 LIFETIME :@expr2935
177: case ValueType ::@expr1073744782 MOVED :@expr2935 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var550 , Compare compare@var551 , T x@var552 , U y@var553 ) const {
186: result@var550 =@expr1073744784 compare@var551 (@expr1073744785 x@var552 , y@var553 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var554 , const Value & rhs@var555 , Compare compare@var556 , T x@var557 ) const {
191: visitValue (@expr1073744787 rhs@var555 ,
192: std ::@expr1073744788 bind (@expr1073744789 innerVisitor {@expr1073744790 } , std ::@expr1073744791 ref (@expr1073744792 result@var554 ) , std ::@expr1073744793 move (@expr1073744794 compare@var556 ) , x@var557 , std ::@expr1073744795 placeholders ::@expr1073744796 _1@expr1073744786 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var558 , Compare compare@var559 ) const {
198: assert (@expr1073744798 (@expr1073744799 !@expr1073744800 this@expr2977 .@expr1073744802 isSymbolicValue (@expr1073744803 ) &&@expr1073744804 !@expr1073744805 rhs@var558 .@expr1073744806 isSymbolicValue (@expr1073744807 ) ) ||@expr1073744808
199: (@expr1073744809 this@expr2977 .@expr1073744810 valueType@var575 ==@expr1073744811 rhs@var558 .@expr1073744812 valueType@var560 &&@expr1073744813 sameToken (@expr1073744814 this@expr2977 .@expr1073744815 tokvalue@var578 , rhs@var558 .@expr1073744816 tokvalue@var561 ) ) ) ;
200: bool result@var562 ; result@var562 =@expr1073744817 false ;
201: visitValue (@expr1073744818
202: *@expr1073744819 this@expr2977 ,
203: std ::@expr1073744820 bind (@expr1073744821 compareVisitor {@expr1073744822 } , std ::@expr2999 ref (@expr1073744824 result@var562 ) , std ::@expr2999 ref (@expr1073744826 rhs@var558 ) , std ::@expr1073744827 move (@expr1073744828 compare@var559 ) , std ::@expr1073744829 placeholders ::@expr1073744830 _1@expr1073744797 ) ) ;
204: return result@var562 ;
205: }
206:
207: bool operator== ( const Value & rhs@var563 ) const {
208: if (@expr1073744831 !@expr1073744832 equalValue (@expr1073744833 rhs@var563 ) ) {
209: return false ; }
210:
211: return varvalue@var581 ==@expr1073744834 rhs@var563 .@expr1073744835 varvalue@var564 &&@expr1073744836
212: condition@var582 ==@expr1073744837 rhs@var563 .@expr1073744838 condition@var565 &&@expr1073744839
213: varId@var584 ==@expr1073744840 rhs@var563 .@expr1073744841 varId@var566 &&@expr1073744842
214: conditional@var586 ==@expr1073744843 rhs@var563 .@expr1073744844 conditional@var567 &&@expr1073744845
215: defaultArg@var588 ==@expr1073744846 rhs@var563 .@expr1073744847 defaultArg@var568 &&@expr1073744848
216: indirect@var589 ==@expr1073744849 rhs@var563 .@expr1073744850 indirect@var569 &&@expr1073744851
217: valueKind@var600 ==@expr1073744852 rhs@var563 .@expr1073744853 valueKind@var570 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var571 ) const {
221: return !@expr1073744854 (@expr1073744855 *@expr1073744856 this@expr1073744857 ==@expr1073744858 rhs@var571 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var572 ) const {
226: bool result@var573 ; result@var573 =@expr1073744860 false ;
227: visitValue (@expr1073744861 *@expr1073744862 this@expr1073744863 , std ::@expr1073744864 bind (@expr1073744865 equalVisitor {@expr1073744866 } , std ::@expr1073744867 ref (@expr1073744868 result@var573 ) , x@var572 , std ::@expr1073744869 placeholders ::@expr1073744870 _1@expr1073744859 ) ) ;
228: return result@var573 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744871 bound@var576 ==@expr1073744872 Bound ::@expr1073744873 Lower ) {
233: visitValue (@expr1073744874 *@expr3051 this@expr3052 , increment {@expr1073744877 } ) ; }
234: else { if (@expr1073744878 bound@var576 ==@expr1073744879 Bound ::@expr1073744880 Upper ) {
235: visitValue (@expr1073744881 *@expr3051 this@expr3052 , decrement {@expr1073744883 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744884 bound@var576 ==@expr1073744885 Bound ::@expr3062 Lower ) {
240: bound@var576 =@expr1073744887 Bound ::@expr3064 Upper ; }
241: else { if (@expr1073744889 bound@var576 ==@expr1073744890 Bound ::@expr3064 Upper ) {
242: bound@var576 =@expr1073744892 Bound ::@expr3062 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744894 ) ;
247: decreaseRange (@expr1073744895 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var574 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var575 ;
267: bool isIntValue ( ) const {
268: return valueType@var575 ==@expr1073744896 ValueType ::@expr1073744897 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var575 ==@expr1073744898 ValueType ::@expr1073744899 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var575 ==@expr1073744900 ValueType ::@expr1073744901 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var575 ==@expr1073744902 ValueType ::@expr1073744903 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var575 ==@expr1073744904 ValueType ::@expr1073744905 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var575 ==@expr1073744906 ValueType ::@expr1073744907 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var575 ==@expr1073744908 ValueType ::@expr1073744909 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var575 ==@expr1073744910 ValueType ::@expr1073744911 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var575 ==@expr1073744912 ValueType ::@expr1073744913 ITERATOR_START ||@expr1073744914 valueType@var575 ==@expr1073744915 ValueType ::@expr1073744916 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var575 ==@expr1073744917 ValueType ::@expr1073744918 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var575 ==@expr1073744919 ValueType ::@expr1073744920 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var575 ==@expr1073744921 ValueType ::@expr1073744922 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var575 ==@expr1073744924 ValueType ::@expr1073744925 LIFETIME &&@expr1073744926 lifetimeScope@var595 ==@expr1073744927 LifetimeScope ::@expr1073744928 Local@expr1073744923 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var575 ==@expr1073744929 ValueType ::@expr1073744930 LIFETIME &&@expr1073744931 lifetimeScope@var595 ==@expr1073744932 LifetimeScope ::@expr1073744933 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var575 ==@expr1073744934 ValueType ::@expr1073744935 LIFETIME &&@expr1073744936 lifetimeScope@var595 ==@expr1073744937 LifetimeScope ::@expr1073744938 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744939 ) ||@expr1073744940 isUninitValue (@expr1073744941 ) ||@expr1073744942 isLifetimeValue (@expr1073744943 ) ;
318: }
319:
320:
321: Bound bound@var576 ;
322:
323:
324: long long intvalue@var577 ;
325:
326:
327: const Token * tokvalue@var578 ;
328:
329:
330: double floatValue@var579 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var580 ;
334:
335:
336: long long varvalue@var581 ;
337:
338:
339: const Token * condition@var582 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var583 ;
342:
343:
344: int varId@var584 ;
345:
346:
347: bool safe@var585 ;
348:
349:
350: bool conditional@var586 ;
351:
352:
353: bool macro@var587 ;
354:
355:
356: bool defaultArg@var588 ;
357:
358: int indirect@var589 ;
359:
360:
361: long long path@var590 ;
362:
363:
364: long long wideintvalue@var591 ;
365:
366: std :: vector < std :: string > subexpressions@var592 ;
367:
368:
369: const Token * capturetok@var593 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var594 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var595 ;
385:
386: static const char * toString ( MoveKind moveKind@var596 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var597 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var598 ) ;
389: static const char * toString ( Bound bound@var599 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var600 ;
402:
403: void setKnown ( ) {
404: valueKind@var600 =@expr1073744944 ValueKind ::@expr1073744945 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var600 ==@expr1073744946 ValueKind ::@expr1073744947 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var600 =@expr1073744949 ValueKind ::@expr1073744950 Possible@expr1073744948 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var600 ==@expr1073744952 ValueKind ::@expr1073744953 Possible@expr1073744951 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var600 ==@expr1073744954 ValueKind ::@expr1073744955 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var600 =@expr1073744956 ValueKind ::@expr1073744957 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var601 = true ) {
428: if (@expr1073744958 inconclusive@var601 ) {
429: valueKind@var600 =@expr1073744959 ValueKind ::@expr1073744960 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var600 ==@expr1073744961 ValueKind ::@expr1073744962 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744964 isKnown (@expr1073744965 ) ) {
438: valueKind@var600 =@expr1073744966 ValueKind ::@expr1073744967 Possible@expr1073744963 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744968 condition@var582 &&@expr1073744969 !@expr1073744970 defaultArg@var588 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var602 , const Token * tok2@var603 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var604 , const Settings * settings@var605 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var606 , SymbolDatabase * symboldatabase@var607 , ErrorLogger * errorLogger@var608 , const Settings * settings@var609 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var610 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var611 , const Settings * settings@var612 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var613 ,
459: const Settings * settings@var614 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var615 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var616 , const Token * indexTok@var617 , bool possible@var618 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var619 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var620 , const Settings * settings@var621 = nullptr , int depth@var622 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var623 ;
471: bool addressOf@var624 ;
472: ValueFlow :: Value :: ErrorPath errorPath@var625 ;
473: bool inconclusive@var626 ;
474:
475: LifetimeToken ( ) : token@var623 ( nullptr ) , addressOf@var624 ( false ) , errorPath@var625 ( ) , inconclusive@var626 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var627 , ValueFlow :: Value :: ErrorPath errorPath@var628 )
478: : token@var623 ( token@var627 ) , addressOf@var624 ( false ) , errorPath@var625 ( std :: move ( errorPath@var628 ) ) , inconclusive@var626 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var629 , bool addressOf@var630 , ValueFlow :: Value :: ErrorPath errorPath@var631 )
482: : token@var623 ( token@var629 ) , addressOf@var624 ( addressOf@var630 ) , errorPath@var625 ( std :: move ( errorPath@var631 ) ) , inconclusive@var626 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var632 , bool b@var633 ) {
486: for (@expr1073744971 LifetimeToken &@expr1073744972 x@var634 :@expr1073744973 v@var632 ) {
487: x@var634 .@expr1073744974 addressOf@var635 =@expr1073744975 b@var633 ; }
488: return v@var632 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var636 , bool b@var637 ) {
492: for (@expr1073744976 LifetimeToken &@expr1073744977 x@var638 :@expr1073744978 v@var636 ) {
493: x@var638 .@expr1073744979 inconclusive@var639 =@expr1073744980 b@var637 ; }
494: return v@var636 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var640 , ValueFlow :: Value & true_value@var641 , ValueFlow :: Value & false_value@var642 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var643 ) ;
499: const Token * parseCompareInt ( const Token * tok@var644 , ValueFlow :: Value & true_value@var645 , ValueFlow :: Value & false_value@var646 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var647 , long long val@var648 , const Token * varTok@var649 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var650 , const Token * varTok@var651 , long long val@var652 ) ;
503:
504: ValuePtr<InferModel> makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var653 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var654 ,
508: ValueFlow :: Value & value@var655 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var656 ,
511: bool escape@var657 = false ,
512: ValueFlow :: Value :: ErrorPath errorPath@var658 = ValueFlow :: Value :: ErrorPath { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var659 , const Token * lifetime@var660 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var661 , ValueFlow :: Value :: ErrorPath & errorPath@var662 , bool * addressOf@var663 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var664 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var665 , const Settings * settings@var666 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var667 , const ValueFlow :: Value * val@var668 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var669 , const ValueFlow :: Value * val@var670 , ValueFlow :: Value :: ErrorPath & errorPath@var671 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var672 , bool inconclusive@var673 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var674 ,
529: bool inconclusive@var675 = false ,
530: long long path@var676 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var677 , const Scope * defaultScope@var678 = nullptr , bool smallest@var679 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var680 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var681 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var682 ;
69: std :: string mScope@var683 ;
70: std :: string mName@var684 ;
71: std :: string mFullName@var685 ;
72: const Token * mNameToken@var686 ;
73: const Token * mParamEnd@var687 ;
74: unsigned int mFlags@var688 ;
75:
76: enum Anonymous1 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var689 ) {
90: setFlag (@expr1073744981 fIsClass , state@var689 ) ;
91: }
92: void isFunction ( bool state@var690 ) {
93: setFlag (@expr1073744982 fIsFunction , state@var690 ) ;
94: }
95: void isVariable ( bool state@var691 ) {
96: setFlag (@expr1073744983 fIsVariable , state@var691 ) ;
97: }
98: void isAlias ( bool state@var692 ) {
99: setFlag (@expr1073744984 fIsAlias , state@var692 ) ;
100: }
101: void isSpecialization ( bool state@var693 ) {
102: setFlag (@expr1073744985 fIsSpecialization , state@var693 ) ;
103: }
104: void isPartialSpecialization ( bool state@var694 ) {
105: setFlag (@expr1073744986 fIsPartialSpecialization , state@var694 ) ;
106: }
107: void isForwardDeclaration ( bool state@var695 ) {
108: setFlag (@expr1073744987 fIsForwardDeclaration , state@var695 ) ;
109: }
110: void isVariadic ( bool state@var696 ) {
111: setFlag (@expr1073744988 fIsVariadic , state@var696 ) ;
112: }
113: void isFriend ( bool state@var697 ) {
114: setFlag (@expr1073744989 fIsFriend , state@var697 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var698 ) const {
123: return (@expr3166 (@expr3166 mFlags@var688 &@expr1073744992 flag@var698 ) !=@expr1073744993 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var699 , bool state@var700 ) {
132: mFlags@var688 =@expr1073744994 state@var700 ?@expr1073744995 mFlags@var688 |@expr1073744996 flag@var699 :@expr1073744997 mFlags@var688 &@expr1073744998 ~@expr1073744999 flag@var699 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var701 , const std :: string & scope@var702 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var703 , const std :: string & scope@var704 , const Token * nameToken@var705 , const Token * paramEnd@var706 ) ;
150: TokenAndName ( const TokenAndName & other@var707 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var708 ) const {
154: return mToken@var682 ==@expr1073745000 rhs@var708 .@expr1073745001 mToken@var709 &&@expr1073745002 mScope@var683 ==@expr1073745003 rhs@var708 .@expr1073745004 mScope@var710 &&@expr1073745005 mName@var684 ==@expr1073745006 rhs@var708 .@expr1073745007 mName@var711 &&@expr1073745008 mFullName@var685 ==@expr1073745009 rhs@var708 .@expr1073745010 mFullName@var712 &&@expr1073745011
155: mNameToken@var686 ==@expr1073745012 rhs@var708 .@expr1073745013 mNameToken@var713 &&@expr1073745014 mParamEnd@var687 ==@expr1073745015 rhs@var708 .@expr1073745016 mParamEnd@var714 &&@expr1073745017 mFlags@var688 ==@expr1073745018 rhs@var708 .@expr1073745019 mFlags@var715 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var682 ;
160: }
161: void token ( Token * token@var716 ) {
162: mToken@var682 =@expr1073745020 token@var716 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var683 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var684 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var685 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var686 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var687 ;
178: }
179: void paramEnd ( const Token * end@var717 ) {
180: mParamEnd@var687 =@expr1073745021 end@var717 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073745022 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073745023 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073745024 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073745025 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073745026 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073745027 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073745028 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073745029 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073745030 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var718 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var719 ) const {
243:
244:
245: return (@expr3207 (@expr3207 mFlags@var688 &@expr1073745033 fFamilyMask ) &@expr1073745034 (@expr3207 decl@var719 .@expr1073745036 mFlags@var720 &@expr1073745037 fFamilyMask ) ) !=@expr1073745038 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var721 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var722 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var723 , const unsigned long numberOfArguments@var724 , bool variadic@var725 , const char patternAfter@var726 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var727 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var728 , int & namepos@var729 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var730 , int & namepos@var731 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var732 , int & namepos@var733 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var734 ,
306: bool & codeWithTemplates@var735 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var736 , bool isTemplate@var737 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var738 = nullptr , Token * backToken@var739 = nullptr , bool isTemplate@var740 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var741 , Token * end@var742 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var743 , const std :: string & scope@var744 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var745 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var746 ,
393: const std :: list < const Token * > & specializations@var747 ,
394: const std :: time_t maxtime@var748 ,
395: std :: set < std :: string > & expandedtemplates@var749 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var750 , const Token * tok@var751 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var752 , const Token * tok@var753 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var754 ,
422: const TokenAndName & templateInstantiation@var755 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var756 ,
424: const std :: string & newName@var757 ,
425: bool copy@var758 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var759 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var760 ,
435: const std :: string & newName@var761 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var762 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var763 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var764 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var765 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var766 ,
458: const Token * templateInstantiationNameToken@var767 ,
459: const std :: list < const Token * > & specializations@var768 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var769 , const Token * end@var770 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var771 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var772 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var773 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var774 ,
487: const std :: string & indent@var775 = "    " ) const ;
488: void printOut ( const std :: string & text@var776 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var777 ;
491: TokenList & mTokenList@var778 ;
492: const Settings * mSettings@var779 ;
493: ErrorLogger * mErrorLogger@var780 ;
494: bool mChanged@var781 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var782 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var783 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var784 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var785 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var786 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var787 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var788 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var789 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var790 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var791 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var792 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var793 ;
57: Token * back@var794 ;
58: const TokenList * list@var795 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var796 , const Token * bodyEnd_@var797 , const std :: set < std :: string > & usingNamespaces_@var798 = std :: set < std :: string > ( ) ) : name@var799 ( name_@var796 ) , bodyEnd@var800 ( bodyEnd_@var797 ) , usingNamespaces@var801 ( usingNamespaces_@var798 ) { }
63: std :: string name@var799 ;
64: const Token * const bodyEnd@var800 ;
65: std :: set < std :: string > usingNamespaces@var801 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var802 ;
70: int mFileIndex@var803 ;
71: int mLineNumber@var804 ;
72: int mColumn@var805 ;
73: int mExprId@var806 ;
74:
75:
76: Token * mAstOperand1@var807 ;
77: Token * mAstOperand2@var808 ;
78: Token * mAstParent@var809 ;
79:
80:
81: const Scope * mScope@var810 ;
82: union {
83: const Function * mFunction@var811 ;
84: const Variable * mVariable@var812 ;
85: const :: Type * mType@var813 ;
86: const Enumerator * mEnumerator@var814 ;
87: } ;
88:
|
92:
93: int mProgressValue@var815 ;
94:
|
97:
98: int mIndex@var816 ;
99:
100:
101: std :: string * mOriginalName@var817 ;
102:
103:
104: ValueType * mValueType@var818 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var819 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var820 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var821 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var822 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var823 ;
119: long long value@var824 ;
120: struct CppcheckAttributes * next@var825 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var826 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var827 ;
126:
127:
128: unsigned char mBits@var828 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var829 , long long value@var830 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var831 , long long * value@var832 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var802 ( 0 )
135: , mFileIndex@var803 ( 0 )
136: , mLineNumber@var804 ( 0 )
137: , mColumn@var805 ( 0 )
138: , mExprId@var806 ( 0 )
139: , mAstOperand1@var807 ( nullptr )
140: , mAstOperand2@var808 ( nullptr )
141: , mAstParent@var809 ( nullptr )
142: , mScope@var810 ( nullptr )
143: , mFunction@var811 ( nullptr )
144: , mProgressValue@var815 ( 0 )
145: , mIndex@var816 ( 0 )
146: , mOriginalName@var817 ( nullptr )
147: , mValueType@var818 ( nullptr )
148: , mValues@var819 ( nullptr )
149: , mTemplateSimplifierPointers@var821 ( nullptr )
150: , mScopeInfo@var822 ( nullptr )
151: , mCppcheckAttributes@var826 ( nullptr )
152: , mCpp11init@var827 ( Cpp11init :: UNKNOWN )
153: , mBits@var828 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var833 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var834 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var835 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var836 ) {
199: mStr@var1048 =@expr1073745039 s@var836 ;
200: mImpl@var1054 .@expr1073745040 mVarId@var1085 =@expr1073745041 0 ;
201:
202: update_property_info (@expr1073745042 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var837 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1048 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var838 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var839 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var840 ) const ;
236: Token * tokAt ( int index@var841 ) {
237: return const_cast < Token *@expr3219 > (@expr1073745044 const_cast < const Token *@expr3219 > (@expr1073745046 this@expr1073745047 ) .@expr1073745048 tokAt (@expr1073745049 index@var841 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var842 ) const ;
245: Token * linkAt ( int index@var843 ) {
246: return const_cast < Token *@expr3226 > (@expr1073745051 const_cast < const Token *@expr3226 > (@expr1073745053 this@expr1073745054 ) .@expr1073745055 linkAt (@expr1073745056 index@var843 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var844 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var845 , const char ( & pattern@var846 ) [ count ] ) {
276: return simpleMatch (@expr1073745058 tok@var845 , pattern@var846 , count@expr1073745057 -@expr1073745059 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var847 , const char pattern@var848 [ ] , unsigned long pattern_len@var849 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var850 , const char pattern@var851 [ ] , int varid@var852 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var853 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var854 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var855 , const Settings * const settings@var856 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var857 , long long index@var858 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1054 .@expr1073745060 mValueType@var1086 ;
366: }
367: void setValueType ( ValueType * vt@var859 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var860 ; top@var860 =@expr1073745061 this@expr1073745062 ;
371: while (@expr1073745063 top@var860 &&@expr1073745064 !@expr1073745065 Token ::@expr1073745066 Match (@expr1073745067 top@var860 .@expr3244 astParent (@expr3245 ) , ",|(" ) ) {
372: top@var860 =@expr1073745070 top@var860 .@expr3244 astParent (@expr3245 ) ; }
373: return top@var860 ?@expr1073745073 top@var860 .@expr1073745074 mImpl@var861 .@expr1073745075 mValueType@var862 :@expr1073745076 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1052 ;
378: }
379: void tokType ( Token :: Type t@var863 ) {
380: mTokType@var1052 =@expr1073745077 t@var863 ;
381:
382: const bool memoizedIsName@var864 =@expr1073745078 mTokType@var1052 ==@expr1073745079 eName ||@expr1073745080 mTokType@var1052 ==@expr1073745081 eType ||@expr1073745082 mTokType@var1052 ==@expr1073745083 eVariable ||@expr1073745084
383: mTokType@var1052 ==@expr1073745085 eFunction ||@expr1073745086 mTokType@var1052 ==@expr1073745087 eKeyword ||@expr1073745088 mTokType@var1052 ==@expr3265 eBoolean ||@expr1073745090
384: mTokType@var1052 ==@expr3267 eEnumerator ;
385: setFlag (@expr1073745092 fIsName , memoizedIsName@var864 ) ;
386:
387: const bool memoizedIsLiteral@var865 =@expr1073745093 mTokType@var1052 ==@expr1073745094 eNumber ||@expr1073745095 mTokType@var1052 ==@expr1073745096 eString ||@expr1073745097 mTokType@var1052 ==@expr1073745098 eChar ||@expr1073745099
388: mTokType@var1052 ==@expr3265 eBoolean ||@expr1073745101 mTokType@var1052 ==@expr1073745102 eLiteral ||@expr1073745103 mTokType@var1052 ==@expr3267 eEnumerator ;
389: setFlag (@expr1073745105 fIsLiteral , memoizedIsLiteral@var865 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1052 ==@expr1073745106 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745107 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1053 ==@expr1073745108 fIsName &&@expr1073745109 mTokType@var1052 ==@expr1073745110 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745111 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1052 ==@expr1073745112 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1052 ==@expr1073745113 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745114 isConstOp (@expr1073745115 ) ||@expr1073745116
412: isAssignmentOp (@expr1073745117 ) ||@expr1073745118
413: mTokType@var1052 ==@expr1073745119 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745120 isArithmeticalOp (@expr1073745121 ) ||@expr1073745122
417: mTokType@var1052 ==@expr1073745123 eLogicalOp ||@expr1073745124
418: mTokType@var1052 ==@expr1073745125 eComparisonOp ||@expr1073745126
419: mTokType@var1052 ==@expr1073745127 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745128 ) ||@expr1073745129
423: mTokType@var1052 ==@expr1073745130 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1052 ==@expr1073745131 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1052 ==@expr1073745132 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1052 ==@expr1073745133 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1052 ==@expr1073745134 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1052 ==@expr1073745135 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745136 ) !=@expr1073745137 nullptr &&@expr1073745138 astOperand2 (@expr1073745139 ) !=@expr1073745140 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var866 ) const {
444: return s@var866 ==@expr1073745141 mStr@var1048 &&@expr1073745142 astOperand1 (@expr1073745143 ) !=@expr1073745144 nullptr &&@expr1073745145 astOperand2 (@expr1073745146 ) ==@expr1073745147 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1053 ;
450: }
451: void flags ( const unsigned int flags_@var867 ) {
452: mFlags@var1053 =@expr1073745148 flags_@var867 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745149 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var868 ) {
458: setFlag (@expr1073745150 fIsUnsigned , sign@var868 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745151 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var869 ) {
464: setFlag (@expr1073745152 fIsSigned , sign@var869 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745153 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var870 ) {
470: setFlag (@expr1073745154 fIsPointerCompare , b@var870 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745155 fIsLong ) ;
474: }
475: void isLong ( bool size@var871 ) {
476: setFlag (@expr1073745156 fIsLong , size@var871 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745157 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var872 ) {
482: setFlag (@expr1073745158 fIsStandardType , b@var872 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745159 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var873 ) {
488: setFlag (@expr1073745160 fIsExpandedMacro , m@var873 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745161 fIsCast ) ;
492: }
493: void isCast ( bool c@var874 ) {
494: setFlag (@expr1073745162 fIsCast , c@var874 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745163 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var875 ) {
500: setFlag (@expr1073745164 fIsAttributeConstructor , ac@var875 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745165 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var876 ) {
506: setFlag (@expr1073745166 fIsAttributeDestructor , value@var876 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745167 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var877 ) {
512: setFlag (@expr1073745168 fIsAttributeUnused , unused@var877 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745169 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var878 ) {
518: setFlag (@expr1073745170 fIsAttributeUsed , unused@var878 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745171 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var879 ) {
524: setFlag (@expr1073745172 fIsAttributePure , value@var879 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745173 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var880 ) {
530: setFlag (@expr1073745174 fIsAttributeConst , value@var880 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745175 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var881 ) {
536: setFlag (@expr1073745176 fIsAttributeNoreturn , value@var881 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745177 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var882 ) {
542: setFlag (@expr1073745178 fIsAttributeNothrow , value@var882 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745179 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var883 ) {
548: setFlag (@expr1073745180 fIsAttributePacked , value@var883 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745181 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var884 ) {
554: setFlag (@expr1073745182 fIsAttributeNodiscard , value@var884 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745183 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var885 ) {
560: setFlag (@expr1073745184 fIsAttributeMaybeUnused , value@var885 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var886 , long long value@var887 ) {
563: mImpl@var1054 .@expr1073745185 setCppcheckAttribute (@expr1073745186 type@var886 , value@var887 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var888 , long long * value@var889 ) const {
566: return mImpl@var1054 .@expr1073745187 getCppcheckAttribute (@expr1073745188 type@var888 , value@var889 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745189 mImpl@var1054 .@expr1073745190 mCppcheckAttributes@var1087 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745191 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745192 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var890 ) {
578: setFlag (@expr1073745193 fIsOperatorKeyword , value@var890 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745194 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var891 ) {
584: setFlag (@expr1073745195 fIsComplex , value@var891 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745196 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var892 ) {
590: setFlag (@expr1073745197 fIsEnumType , value@var892 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745198 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var893 ) {
596: setFlag (@expr1073745199 fAtAddress , b@var893 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745200 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var894 ) {
602: setFlag (@expr1073745201 fIncompleteVar , b@var894 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745202 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var895 ) {
609: setFlag (@expr1073745203 fIsIncompleteConstant , b@var895 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745204 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var896 ) {
616: setFlag (@expr1073745205 fConstexpr , b@var896 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745206 fExternC ) ;
621: }
622: void isExternC ( bool b@var897 ) {
623: setFlag (@expr1073745207 fExternC , b@var897 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745208 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var898 ) {
630: setFlag (@expr1073745209 fIsSplitVarDeclComma , b@var898 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745210 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var899 ) {
637: setFlag (@expr1073745211 fIsSplitVarDeclEq , b@var899 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745212 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var900 ) {
644: setFlag (@expr1073745213 fIsImplicitInt , b@var900 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745214 fIsInline ) ;
649: }
650: void isInline ( bool b@var901 ) {
651: setFlag (@expr1073745215 fIsInline , b@var901 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745216 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var902 ) {
658: setFlag (@expr1073745217 fIsRemovedVoidParameter , b@var902 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745218 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var903 ) {
665: setFlag (@expr1073745219 fIsTemplate , b@var903 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745220 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var904 ) {
672: setFlag (@expr1073745221 fIsSimplifedScope , b@var904 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1054 .@expr1073745222 mBits@var1088 >@expr1073745223 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1054 .@expr1073745224 mBits@var1088 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1054 .@expr1073745225 mTemplateSimplifierPointers@var1089 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var905 ) {
685: if (@expr1073745226 !@expr1073745227 mImpl@var1054 .@expr3404 mTemplateSimplifierPointers@var1089 ) {
686: mImpl@var1054 .@expr3404 mTemplateSimplifierPointers@var1089 =@expr1073745230 new std ::@expr1073745231 set < TemplateSimplifier ::@expr1073745232 TokenAndName *@expr1073745233 > ; }
687: mImpl@var1054 .@expr3404 mTemplateSimplifierPointers@var1089 .@expr1073745235 insert (@expr1073745236 tokenAndName@var905 ) ;
688: }
689: void setBits ( const unsigned char b@var906 ) {
690: mImpl@var1054 .@expr1073745237 mBits@var1088 =@expr1073745238 b@var906 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3415 (@expr3415 (@expr3415 mTokType@var1052 ==@expr1073745242 eString ) &&@expr1073745243 isPrefixStringCharLiteral (@expr1073745244 mStr@var1048 , '"' , "u8" ) ) ||@expr1073745245
695: (@expr3415 (@expr3415 mTokType@var1052 ==@expr1073745248 eChar ) &&@expr1073745249 isPrefixStringCharLiteral (@expr1073745250 mStr@var1048 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3427 (@expr3427 (@expr3427 mTokType@var1052 ==@expr1073745254 eString ) &&@expr1073745255 isPrefixStringCharLiteral (@expr1073745256 mStr@var1048 , '"' , "u" ) ) ||@expr1073745257
700: (@expr3427 (@expr3427 mTokType@var1052 ==@expr1073745260 eChar ) &&@expr1073745261 isPrefixStringCharLiteral (@expr1073745262 mStr@var1048 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3439 (@expr3439 (@expr3439 mTokType@var1052 ==@expr1073745266 eString ) &&@expr1073745267 isPrefixStringCharLiteral (@expr1073745268 mStr@var1048 , '"' , "U" ) ) ||@expr1073745269
705: (@expr3439 (@expr3439 mTokType@var1052 ==@expr1073745272 eChar ) &&@expr1073745273 isPrefixStringCharLiteral (@expr1073745274 mStr@var1048 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3451 (@expr3451 (@expr3451 mTokType@var1052 ==@expr1073745278 eString ) &&@expr1073745279 isPrefixStringCharLiteral (@expr1073745280 mStr@var1048 , '"' , "" ) ) ||@expr1073745281
710: (@expr3451 (@expr3451 mTokType@var1052 ==@expr1073745284 eChar ) &&@expr1073745285 isPrefixStringCharLiteral (@expr1073745286 mStr@var1048 , '\'' , "" ) &&@expr1073745287 mStr@var1048 .@expr1073745288 length (@expr1073745289 ) ==@expr1073745290 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3467 (@expr3467 (@expr3467 mTokType@var1052 ==@expr1073745294 eChar ) &&@expr1073745295 isPrefixStringCharLiteral (@expr1073745296 mStr@var1048 , '\'' , "" ) ) &&@expr1073745297
715: (@expr3467 mStr@var1048 .@expr1073745299 length (@expr1073745300 ) >@expr1073745301 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745302 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var907 ) {
738: setFlag (@expr1073745303 fIsTemplateArg , value@var907 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var908 , const char ( & pattern@var909 ) [ count ] ) {
743: return findsimplematch (@expr1073745305 startTok@var908 , pattern@var909 , count@expr1073745304 -@expr1073745306 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var910 , const char pattern@var911 [ ] , unsigned long pattern_len@var912 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var913 , const char ( & pattern@var914 ) [ count ] , const Token * const end@var915 ) {
749: return findsimplematch (@expr1073745308 startTok@var913 , pattern@var914 , count@expr1073745307 -@expr1073745309 1 , end@var915 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var916 , const char pattern@var917 [ ] , unsigned long pattern_len@var918 , const Token * const end@var919 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var920 , const char pattern@var921 [ ] , const int varId@var922 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var923 , const char pattern@var924 [ ] , const Token * const end@var925 , const int varId@var926 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var927 , const char ( & pattern@var928 ) [ count ] ) {
758: return findsimplematch (@expr1073745311 startTok@var927 , pattern@var928 , count@expr1073745310 -@expr1073745312 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var929 , const char pattern@var930 [ ] , unsigned long pattern_len@var931 ) {
761: return const_cast < Token *@expr3489 > (@expr1073745314 findsimplematch (@expr1073745315 const_cast < const Token *@expr3489 > (@expr1073745317 startTok@var929 ) , pattern@var930 , pattern_len@var931 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var932 , const char ( & pattern@var933 ) [ count ] , const Token * const end@var934 ) {
765: return findsimplematch (@expr1073745319 startTok@var932 , pattern@var933 , count@expr1073745318 -@expr1073745320 1 , end@var934 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var935 , const char pattern@var936 [ ] , unsigned long pattern_len@var937 , const Token * const end@var938 ) {
768: return const_cast < Token *@expr3497 > (@expr1073745322 findsimplematch (@expr1073745323 const_cast < const Token *@expr3497 > (@expr1073745325 startTok@var935 ) , pattern@var936 , pattern_len@var937 , end@var938 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var939 , const char pattern@var940 [ ] , const int varId@var941 = 0 ) {
772: return const_cast < Token *@expr3502 > (@expr1073745327 findmatch (@expr1073745328 const_cast < const Token *@expr3502 > (@expr1073745330 startTok@var939 ) , pattern@var940 , varId@var941 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var942 , const char pattern@var943 [ ] , const Token * const end@var944 , const int varId@var945 = 0 ) {
775: return const_cast < Token *@expr3507 > (@expr1073745332 findmatch (@expr1073745333 const_cast < const Token *@expr3507 > (@expr1073745335 startTok@var942 ) , pattern@var943 , end@var944 , varId@var945 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var946 , const char * haystack@var947 , int varid@var948 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1054 .@expr1073745336 mFileIndex@var1090 ;
796: }
797: void fileIndex ( int indexOfFile@var949 ) {
798: mImpl@var1054 .@expr1073745337 mFileIndex@var1090 =@expr1073745338 indexOfFile@var949 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1054 .@expr1073745339 mLineNumber@var1091 ;
803: }
804: void linenr ( int lineNumber@var950 ) {
805: mImpl@var1054 .@expr1073745340 mLineNumber@var1091 =@expr1073745341 lineNumber@var950 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1054 .@expr1073745342 mColumn@var1092 ;
810: }
811: void column ( int c@var951 ) {
812: mImpl@var1054 .@expr1073745343 mColumn@var1092 =@expr1073745344 c@var951 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1049 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var952 , const Token * end@var953 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var954 , const std :: string & originalNameStr@var955 = emptyString@var1 , bool prepend@var956 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var957 , const std :: string & originalNameStr@var958 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745345 tokenStr@var957 , originalNameStr@var958 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1050 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1054 .@expr1073745346 mVarId@var1085 ;
851: }
852: void varId ( int id@var959 ) {
853: mImpl@var1054 .@expr1073745347 mVarId@var1085 =@expr1073745348 id@var959 ;
854: if (@expr1073745349 id@var959 !=@expr1073745350 0 ) {
855: tokType (@expr1073745351 eVariable ) ;
856: isStandardType (@expr1073745352 false ) ;
857: } else {
858: update_property_info (@expr1073745353 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745354 mImpl@var1054 .@expr3531 mExprId@var1093 ) {
864: return mImpl@var1054 .@expr3531 mExprId@var1093 ; }
865: return mImpl@var1054 .@expr1073745357 mVarId@var1085 ;
866: }
867: void exprId ( int id@var960 ) {
868: mImpl@var1054 .@expr1073745358 mExprId@var1093 =@expr1073745359 id@var960 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var961 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var962 , const std :: vector < std :: string > & fileNames@var963 ) const ;
888:
|
891:
892: void printLines ( int lines@var964 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var965 , Token * start@var966 , Token * end@var967 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var968 ; varid@var968 = false ;
905: bool exprid@var969 ; exprid@var969 = false ;
906: bool idtype@var970 ; idtype@var970 = false ;
907: bool attributes@var971 ; attributes@var971 = false ;
908: bool macro@var972 ; macro@var972 = false ;
909: bool linenumbers@var973 ; linenumbers@var973 = false ;
910: bool linebreaks@var974 ; linebreaks@var974 = false ;
911: bool files@var975 ; files@var975 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var976 ;
914: options@var976 .@expr1073745360 attributes@var977 =@expr1073745361 true ;
915: options@var976 .@expr1073745362 macro@var978 =@expr1073745363 true ;
916: options@var976 .@expr1073745364 linenumbers@var979 =@expr1073745365 true ;
917: options@var976 .@expr1073745366 linebreaks@var980 =@expr1073745367 true ;
918: options@var976 .@expr1073745368 files@var981 =@expr1073745369 true ;
919: return options@var976 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var982 ; options@var982 =@expr1073745370 forDebug (@expr1073745371 ) ;
923: options@var982 .@expr1073745372 varid@var983 =@expr1073745373 true ;
924: return options@var982 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var984 ; options@var984 =@expr1073745374 forDebug (@expr1073745375 ) ;
928: options@var984 .@expr1073745376 exprid@var985 =@expr1073745377 true ;
929: return options@var984 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var986 ; options@var986 =@expr1073745378 forDebug (@expr1073745379 ) ;
933: options@var986 .@expr1073745380 exprid@var987 =@expr1073745381 true ;
934: options@var986 .@expr1073745382 varid@var988 =@expr1073745383 true ;
935: options@var986 .@expr1073745384 idtype@var989 =@expr1073745385 true ;
936: return options@var986 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var990 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var991 , bool attributes@var992 , bool macro@var993 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var994 , const std :: vector < std :: string > * fileNames@var995 = nullptr , const Token * end@var996 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var997 , bool attributes@var998 = true ) const ;
952: std :: string stringifyList ( bool varid@var999 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1000 , bool attributes@var1001 , bool linenumbers@var1002 , bool linebreaks@var1003 , bool files@var1004 , const std :: vector < std :: string > * fileNames@var1005 = nullptr , const Token * end@var1006 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1007 ) {
983: mLink@var1051 =@expr1073745386 linkToToken@var1007 ;
984: if (@expr1073745387 mStr@var1048 ==@expr1073745388 "<" ||@expr1073745389 mStr@var1048 ==@expr1073745390 ">" ) {
985: update_property_info (@expr1073745391 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1051 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1008 ) {
1006: mImpl@var1054 .@expr1073745392 mScope@var1094 =@expr1073745393 s@var1008 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1054 .@expr1073745394 mScope@var1094 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1009 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1052 ==@expr1073745395 eFunction ||@expr1073745396 mTokType@var1052 ==@expr1073745397 eLambda ?@expr1073745398 mImpl@var1054 .@expr1073745399 mFunction@var1095 :@expr1073745400 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1010 ) {
1034: mImpl@var1054 .@expr1073745401 mVariable@var1096 =@expr1073745402 v@var1010 ;
1035: if (@expr1073745403 v@var1010 ||@expr1073745404 mImpl@var1054 .@expr1073745405 mVarId@var1085 ) {
1036: tokType (@expr1073745406 eVariable ) ; }
1037: else { if (@expr1073745407 mTokType@var1052 ==@expr1073745408 eVariable ) {
1038: tokType (@expr1073745409 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1052 ==@expr1073745410 eVariable ?@expr1073745411 mImpl@var1054 .@expr1073745412 mVariable@var1096 :@expr1073745413 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1011 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1052 ==@expr1073745414 eType ?@expr1073745415 mImpl@var1054 .@expr1073745416 mType@var1097 :@expr1073745417 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1012 , const Token * * typeTok@var1013 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1014 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1015 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1052 ==@expr1073745418 eEnumerator ?@expr1073745419 mImpl@var1054 .@expr1073745420 mEnumerator@var1098 :@expr1073745421 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1016 ) {
1079: mImpl@var1054 .@expr1073745422 mEnumerator@var1098 =@expr1073745423 e@var1016 ;
1080: if (@expr1073745424 e@var1016 ) {
1081: tokType (@expr1073745425 eEnumerator ) ; }
1082: else { if (@expr1073745426 mTokType@var1052 ==@expr1073745427 eEnumerator ) {
1083: tokType (@expr1073745428 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1017 , Token * end@var1018 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1019 , Token * srcEnd@var1020 , Token * newLocation@var1021 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1054 .@expr1073745429 mProgressValue@var1099 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1022 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1054 .@expr3606 mOriginalName@var1100 ?@expr1073745431 *@expr1073745432 mImpl@var1054 .@expr3606 mOriginalName@var1100 :@expr1073745434 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1054 .@expr3611 mValues@var1073 ?@expr1073745436 *@expr1073745437 mImpl@var1054 .@expr3611 mValues@var1073 :@expr1073745439 TokenImpl ::@expr1073745440 mEmptyValueList@var820 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1023 ) {
1164: if (@expr1073745441 !@expr1073745442 mImpl@var1054 .@expr3619 mOriginalName@var1100 ) {
1165: mImpl@var1054 .@expr3619 mOriginalName@var1100 =@expr1073745445 new std ::@expr1073745446 string (@expr1073745447 name@var1023 ) ; }
1166: else {
1167: *@expr1073745448 mImpl@var1054 .@expr3619 mOriginalName@var1100 =@expr1073745450 name@var1023 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1024 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1025 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1026 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1054 .@expr1073745452 mValues@var1073 .@expr1073745453 front (@expr1073745454 ) .@expr1073745455 intvalue@expr1073745451 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1027 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1028 , long long path@var1029 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1030 , const Settings * settings@var1031 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1032 , const Settings * settings@var1033 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1034 , int argnr@var1035 , const Settings * settings@var1036 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1037 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1038 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1039 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1040 ) {
1200: if (@expr1073745456 mImpl@var1054 .@expr3633 mValues@var1073 ) {
1201: mImpl@var1054 .@expr3633 mValues@var1073 .@expr1073745459 remove_if (@expr1073745460 pred@var1040 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1054 .@expr1073745461 mIndex@var1101 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1041 ) {
1213: mNext@var1049 =@expr1073745462 nextToken@var1041 ;
1214: }
1215: void previous ( Token * previousToken@var1042 ) {
1216: mPrevious@var1050 =@expr1073745463 previousToken@var1042 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1043 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1044 , const char * word@var1045 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1046 , char c@var1047 ) ;
1235:
1236: std :: string mStr@var1048 ;
1237:
1238: Token * mNext@var1049 ;
1239: Token * mPrevious@var1050 ;
1240: Token * mLink@var1051 ;
1241:
1242: enum Anonymous2 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1052 ;
1283:
1284: uint64_t mFlags@var1053 ;
1285:
1286: TokenImpl * mImpl@var1054 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1055 ) const {
1294: return (@expr3640 (@expr3640 mFlags@var1053 &@expr1073745466 flag_@var1055 ) !=@expr1073745467 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1056 , bool state_@var1057 ) {
1303: mFlags@var1053 =@expr1073745468 state_@var1057 ?@expr1073745469 mFlags@var1053 |@expr1073745470 flag_@var1056 :@expr1073745471 mFlags@var1053 &@expr1073745472 ~@expr1073745473 flag_@var1056 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1058 , const int indent1@var1059 = 0 , const int indent2@var1060 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1061 ) ;
1321: void astOperand2 ( Token * tok@var1062 ) ;
1322: void astParent ( Token * tok@var1063 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1054 .@expr1073745474 mAstOperand1@var1064 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1054 .@expr1073745475 mAstOperand1@var1064 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1054 .@expr1073745476 mAstOperand2@var1065 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1054 .@expr1073745477 mAstOperand2@var1065 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1054 .@expr1073745478 mAstParent@var1066 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1054 .@expr1073745479 mAstParent@var1066 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745480 !@expr1073745481 astParent (@expr3658 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745483 this@expr3660 ==@expr1073745485 astParent (@expr3658 ) .@expr3663 astOperand1 (@expr3664 ) ) {
1346: return astParent (@expr3658 ) .@expr3666 astOperand2 (@expr3667 ) ; }
1347: else { if (@expr1073745492 this@expr3660 ==@expr1073745493 astParent (@expr3658 ) .@expr3666 astOperand2 (@expr3667 ) ) {
1348: return astParent (@expr3658 ) .@expr3663 astOperand1 (@expr3664 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745500 !@expr1073745501 astParent (@expr3678 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745503 this@expr3680 ==@expr1073745505 astParent (@expr3678 ) .@expr3683 astOperand1 (@expr3684 ) ) {
1356: return astParent (@expr3678 ) .@expr3686 astOperand2 (@expr3687 ) ; }
1357: else { if (@expr1073745512 this@expr3680 ==@expr1073745513 astParent (@expr3678 ) .@expr3686 astOperand2 (@expr3687 ) ) {
1358: return astParent (@expr3678 ) .@expr3683 astOperand1 (@expr3684 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1067 ; ret@var1067 =@expr1073745520 this@expr1073745521 ;
1364: while (@expr1073745522 ret@var1067 .@expr3699 mImpl@var1068 .@expr3700 mAstParent@var1069 ) {
1365: ret@var1067 =@expr1073745525 ret@var1067 .@expr3699 mImpl@var1068 .@expr3700 mAstParent@var1069 ; }
1366: return ret@var1067 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1070 ; ret@var1070 =@expr1073745528 this@expr1073745529 ;
1371: while (@expr1073745530 ret@var1070 .@expr3707 mImpl@var1071 .@expr3708 mAstParent@var1072 ) {
1372: ret@var1070 =@expr1073745533 ret@var1070 .@expr3707 mImpl@var1071 .@expr3708 mAstParent@var1072 ; }
1373: return ret@var1070 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1054 .@expr1073745536 mAstOperand1@var1064 =@expr1073745537 mImpl@var1054 .@expr1073745538 mAstOperand2@var1065 =@expr1073745539 mImpl@var1054 .@expr1073745540 mAstParent@var1066 =@expr1073745541 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1054 .@expr3718 mValues@var1073 ;
1393: mImpl@var1054 .@expr3718 mValues@var1073 =@expr1073745544 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1074 = "" ) const {
1397: std ::@expr1073745545 string ret@var1075 ;
1398: if (@expr1073745546 mImpl@var1054 .@expr3723 mAstOperand1@var1064 ) {
1399: ret@var1075 =@expr1073745548 mImpl@var1054 .@expr3723 mAstOperand1@var1064 .@expr1073745550 astString (@expr1073745551 sep@var1074 ) ; }
1400: if (@expr1073745552 mImpl@var1054 .@expr3729 mAstOperand2@var1065 ) {
1401: ret@var1075 +=@expr1073745554 mImpl@var1054 .@expr3729 mAstOperand2@var1065 .@expr1073745556 astString (@expr1073745557 sep@var1074 ) ; }
1402: return ret@var1075 +@expr1073745558 sep@var1074 +@expr1073745559 mStr@var1048 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1076 , bool xml@var1077 , const std :: vector < std :: string > & fileNames@var1078 , std :: ostream & out@var1079 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1080 , std :: ostream & out@var1081 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1082 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1083 ) const {
1419: mImpl@var1054 .@expr1073745560 mCpp11init@var1084 =@expr1073745561 cpp11init@var1083 ?@expr1073745562 TokenImpl ::@expr3739 Cpp11init ::@expr1073745564 CPP11INIT :@expr1073745565 TokenImpl ::@expr3739 Cpp11init ::@expr1073745567 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1054 .@expr1073745568 mCpp11init@var1084 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1102 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1103 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1104 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1105 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1106 ( nullptr ) , num@var1107 ( 0 ) , known@var1108 ( true ) { }
62:
63: const Token * tok@var1106 ;
64: long long num@var1107 ;
65: bool known@var1108 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1109 ;
72: const Scope * classScope@var1110 ;
73: const Scope * enclosingScope@var1111 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1112 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1114 ( nullptr ) , nameTok@var1115 ( nullptr ) , access@var1116 ( AccessControl :: Public ) , isVirtual@var1117 ( false ) { }
82:
83: std :: string name@var1113 ;
84: const Type * type@var1114 ;
85: const Token * nameTok@var1115 ;
86: AccessControl access@var1116 ;
87: bool isVirtual@var1117 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1118 ) const {
90: return this@expr1073745569 .@expr1073745570 type@var1114 <@expr1073745571 rhs@var1118 .@expr1073745572 type@var1119 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1120 ( nullptr ) , nameEnd@var1121 ( nullptr ) , type@var1122 ( nullptr ) { }
97:
98: const Token * nameStart@var1120 ;
99: const Token * nameEnd@var1121 ;
100: const Type * type@var1122 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1123 ;
104: std :: vector < FriendInfo > friendList@var1124 ;
105:
106: const Token * typeStart@var1125 ;
107: const Token * typeEnd@var1126 ;
108: long long sizeOf@var1127 ;
109:
110: Type ( const Token * classDef_@var1128 = nullptr , const Scope * classScope_@var1129 = nullptr , const Scope * enclosingScope_@var1130 = nullptr ) :
111: classDef@var1109 ( classDef_@var1128 ) ,
112: classScope@var1110 ( classScope_@var1129 ) ,
113: enclosingScope@var1111 ( enclosingScope_@var1130 ) ,
114: needInitialization@var1112 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1125 ( nullptr ) ,
116: typeEnd@var1126 ( nullptr ) ,
117: sizeOf@var1127 ( 0 ) {
118: if (@expr1073745573 classDef_@var1128 &&@expr1073745574 classDef_@var1128 .@expr3751 str (@expr3752 ) ==@expr1073745577 "enum" ) {
119: needInitialization@var1112 =@expr1073745578 NeedInitialization ::@expr1073745579 True ; }
120: else { if (@expr1073745580 classDef_@var1128 &&@expr1073745581 classDef_@var1128 .@expr3751 str (@expr3752 ) ==@expr1073745584 "using" ) {
121: typeStart@var1125 =@expr1073745585 classDef@var1109 .@expr1073745586 tokAt (@expr1073745587 3 ) ;
122: typeEnd@var1126 =@expr1073745588 typeStart@var1125 ;
123: while (@expr1073745589 typeEnd@var1126 .@expr3766 next (@expr3767 ) &&@expr1073745592 typeEnd@var1126 .@expr3766 next (@expr3767 ) .@expr1073745595 str (@expr1073745596 ) !=@expr1073745597 ";" ) {
124: typeEnd@var1126 =@expr1073745598 typeEnd@var1126 .@expr3766 next (@expr3767 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1109 ?@expr1073745601 classDef@var1109 .@expr1073745602 str (@expr1073745603 ) :@expr1073745604 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1109 &&@expr1073745605 classDef@var1109 .@expr1073745606 str (@expr1073745607 ) ==@expr1073745608 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1131 , const Token * tok1@var1132 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1133 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1134 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1135 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1136 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1137 ) : scope@var1138 ( scope_@var1137 ) , name@var1139 ( nullptr ) , value@var1140 ( 0 ) , start@var1141 ( nullptr ) , end@var1142 ( nullptr ) , value_known@var1143 ( false ) { }
167: const Scope * scope@var1138 ;
168: const Token * name@var1139 ;
169: long long value@var1140 ;
170: const Token * start@var1141 ;
171: const Token * end@var1142 ;
172: bool value_known@var1143 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous3 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1144 ) const {
204: return (@expr3785 (@expr3785 mFlags@var1180 &@expr1073745611 flag_@var1144 ) !=@expr1073745612 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1145 , bool state_@var1146 ) {
213: mFlags@var1180 =@expr1073745613 state_@var1146 ?@expr1073745614 mFlags@var1180 |@expr1073745615 flag_@var1145 :@expr1073745616 mFlags@var1180 &@expr1073745617 ~@expr1073745618 flag_@var1145 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1147 , bool * isContainer@var1148 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1149 , const Token * start_@var1150 , const Token * end_@var1151 ,
226: int index_@var1152 , AccessControl access_@var1153 , const Type * type_@var1154 ,
227: const Scope * scope_@var1155 , const Settings * settings@var1156 )
228: : mNameToken@var1175 ( name_@var1149 ) ,
229: mTypeStartToken@var1176 ( start_@var1150 ) ,
230: mTypeEndToken@var1177 ( end_@var1151 ) ,
231: mIndex@var1178 ( index_@var1152 ) ,
232: mAccess@var1179 ( access_@var1153 ) ,
233: mFlags@var1180 ( 0 ) ,
234: mType@var1181 ( type_@var1154 ) ,
235: mScope@var1182 ( scope_@var1155 ) ,
236: mValueType@var1183 ( nullptr ) {
237: evaluate (@expr1073745619 settings@var1156 ) ;
238: }
239:
240: Variable ( const Token * name_@var1157 , const std :: string & clangType@var1158 , const Token * typeStart@var1159 ,
241: const Token * typeEnd@var1160 , int index_@var1161 , AccessControl access_@var1162 ,
242: const Type * type_@var1163 , const Scope * scope_@var1164 ) ;
243:
244: Variable ( const Variable & var@var1165 , const Scope * scope@var1166 ) ;
245:
246: Variable ( const Variable & var@var1167 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1168 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1175 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1176 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1177 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745620 mNameToken@var1175 ) {
300: return mNameToken@var1175 .@expr1073745621 str (@expr1073745622 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745623 mNameToken@var1175 ) {
312: return mNameToken@var1175 .@expr1073745624 varId (@expr1073745625 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1178 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1179 ==@expr1073745626 AccessControl ::@expr1073745627 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1179 ==@expr1073745628 AccessControl ::@expr1073745629 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1179 ==@expr1073745630 AccessControl ::@expr1073745631 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1179 ==@expr1073745632 AccessControl ::@expr1073745633 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1179 ==@expr1073745634 AccessControl ::@expr1073745635 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1179 ==@expr1073745636 AccessControl ::@expr1073745637 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745639 mAccess@var1179 ==@expr1073745640 AccessControl ::@expr1073745641 Local@expr1073745638 ) &&@expr1073745642 !@expr1073745643 isExtern (@expr1073745644 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745645 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745646 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745647 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745648 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745649 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1179 ==@expr1073745650 AccessControl ::@expr1073745651 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745652 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745653 fIsArray ) &&@expr1073745654 !@expr1073745655 getFlag (@expr1073745656 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745657 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745658 ) &&@expr1073745659 getFlag (@expr1073745660 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745661 fIsArray ) ||@expr1073745662 getFlag (@expr1073745663 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745664 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745665 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745666 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745667 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1181 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1181 ?@expr1073745668 mType@var1181 .@expr1073745669 classScope@var1186 :@expr1073745670 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1182 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1184 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1169 ) const {
550: return mDimensions@var1184 [@expr1073745671 index_@var1169 ] .@expr1073745672 num@var2338 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1170 ) const {
558: return mDimensions@var1184 [@expr1073745673 index_@var1170 ] .@expr1073745674 known@var2339 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745675 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745676 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745677 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1171 ) const {
602: return isStlType (@expr1073745678 ) &&@expr1073745679 stlType@var1171 ==@expr1073745680 mTypeStartToken@var1176 .@expr1073745681 strAt (@expr1073745682 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1172 ) const {
616: return isStlType (@expr1073745683 ) &&@expr1073745684 stlTypes@var1172 .@expr1073745685 find (@expr1073745686 mTypeStartToken@var1176 .@expr1073745687 strAt (@expr1073745688 2 ) ) !=@expr1073745689 stlTypes@var1172 .@expr1073745690 end (@expr1073745691 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745692 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr3869 ) &&@expr1073745694 type (@expr3869 ) .@expr1073745696 isEnumType (@expr1073745697 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745698 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1183 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1173 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1179 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1174 ) {
660: mType@var1181 =@expr1073745699 t@var1174 ;
661: }
662:
663:
664: const Token * mNameToken@var1175 ;
665:
666:
667: const Token * mTypeStartToken@var1176 ;
668:
669:
670: const Token * mTypeEndToken@var1177 ;
671:
672:
673: int mIndex@var1178 ;
674:
675:
676: AccessControl mAccess@var1179 ;
677:
678:
679: unsigned int mFlags@var1180 ;
680:
681:
682: const Type * mType@var1181 ;
683:
684:
685: const Scope * mScope@var1182 ;
686:
687: ValueType * mValueType@var1183 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1184 ;
691:
692:
693: void evaluate ( const Settings * settings@var1185 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous4 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1187 ) const {
735: return (@expr3876 (@expr3876 mFlags@var1236 &@expr1073745702 flag@var1187 ) !=@expr1073745703 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1188 , bool state@var1189 ) {
744: mFlags@var1236 =@expr1073745704 state@var1189 ?@expr1073745705 mFlags@var1236 |@expr1073745706 flag@var1188 :@expr1073745707 mFlags@var1236 &@expr1073745708 ~@expr1073745709 flag@var1188 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1190 , const Token * tok@var1191 , const Scope * scope@var1192 , const Token * tokDef@var1193 , const Token * tokArgDef@var1194 ) ;
751: Function ( const Token * tokenDef@var1195 , const std :: string & clangType@var1196 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1206 .@expr1073745710 str (@expr1073745711 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1214 .@expr1073745712 size (@expr1073745713 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1214 .@expr1073745714 size (@expr1073745715 ) -@expr1073745716 initArgCount@var1215 ;
764: }
765: const Variable * getArgumentVar ( int num@var1197 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1215 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1198 , const Scope * scope@var1199 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1200 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1201 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1216 ==@expr1073745717 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1216 ==@expr1073745718 eConstructor ||@expr1073745719
785: type@var1216 ==@expr1073745720 eCopyConstructor ||@expr1073745721
786: type@var1216 ==@expr1073745722 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1216 ==@expr1073745723 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1206 .@expr1073745724 isAttributeConstructor (@expr1073745725 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1206 .@expr1073745726 isAttributeDestructor (@expr1073745727 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1206 .@expr1073745728 isAttributePure (@expr1073745729 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1206 .@expr1073745730 isAttributeConst (@expr1073745731 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1206 .@expr1073745732 isAttributeNoreturn (@expr1073745733 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1206 .@expr1073745734 isAttributeNothrow (@expr1073745735 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1206 .@expr1073745736 isAttributeNodiscard (@expr1073745737 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745738 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745739 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745740 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745741 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745742 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745743 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745744 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745745 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745746 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745747 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745748 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745749 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745750 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745751 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745752 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745753 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745754 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745755 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745756 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745757 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745758 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745759 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1202 ) {
881: setFlag (@expr1073745760 fHasBody , state@var1202 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745761 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745762 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1203 ) {
891: setFlag (@expr1073745763 fIsEscapeFunction , state@var1203 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745764 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1204 ) {
898: setFlag (@expr1073745765 fIsConstexpr , state@var1204 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1205 ) const ;
901:
902: const Token * tokenDef@var1206 ;
903: const Token * argDef@var1207 ;
904: const Token * token@var1208 ;
905: const Token * arg@var1209 ;
906: const Token * retDef@var1210 ;
907: const :: Type * retType@var1211 ;
908: const Scope * functionScope@var1212 ;
909: const Scope * nestedIn@var1213 ;
910: std :: list < Variable > argumentList@var1214 ;
911: int initArgCount@var1215 ;
912: Type type@var1216 ;
913: AccessControl access@var1217 ;
914: const Token * noexceptArg@var1218 ;
915: const Token * throwArg@var1219 ;
916: const Token * templateDef@var1220 ;
917: const Token * functionPointerUsage@var1221 ;
918:
919: bool argsMatch ( const Scope * scope@var1222 , const Token * first@var1223 , const Token * second@var1224 , const std :: string & path@var1225 , int path_length@var1226 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1227 , bool unknown@var1228 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1229 , bool unknown@var1230 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1231 , bool unknown@var1232 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1233 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745766 this@expr1073745767 .@expr1073745768 hasTrailingReturnType (@expr1073745769 ) ) {
931: return Token ::@expr1073745770 findmatch (@expr1073745771 retDef@var1210 , "{|;" ) ;
932: } else {
933: return tokenDef@var1206 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1234 , bool * foundAllBaseClasses@var1235 ) const ;
946:
947: unsigned int mFlags@var1236 ;
948:
949: void isInline ( bool state@var1237 ) {
950: setFlag (@expr1073745772 fIsInline , state@var1237 ) ;
951: }
952: void isConst ( bool state@var1238 ) {
953: setFlag (@expr1073745773 fIsConst , state@var1238 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1239 ) {
956: setFlag (@expr1073745774 fHasVirtualSpecifier , state@var1239 ) ;
957: }
958: void isPure ( bool state@var1240 ) {
959: setFlag (@expr1073745775 fIsPure , state@var1240 ) ;
960: }
961: void isStatic ( bool state@var1241 ) {
962: setFlag (@expr1073745776 fIsStatic , state@var1241 ) ;
963: }
964: void isStaticLocal ( bool state@var1242 ) {
965: setFlag (@expr1073745777 fIsStaticLocal , state@var1242 ) ;
966: }
967: void isExtern ( bool state@var1243 ) {
968: setFlag (@expr1073745778 fIsExtern , state@var1243 ) ;
969: }
970: void isFriend ( bool state@var1244 ) {
971: setFlag (@expr1073745779 fIsFriend , state@var1244 ) ;
972: }
973: void isExplicit ( bool state@var1245 ) {
974: setFlag (@expr1073745780 fIsExplicit , state@var1245 ) ;
975: }
976: void isDefault ( bool state@var1246 ) {
977: setFlag (@expr1073745781 fIsDefault , state@var1246 ) ;
978: }
979: void isDelete ( bool state@var1247 ) {
980: setFlag (@expr1073745782 fIsDelete , state@var1247 ) ;
981: }
982: void isNoExcept ( bool state@var1248 ) {
983: setFlag (@expr1073745783 fIsNoExcept , state@var1248 ) ;
984: }
985: void isThrow ( bool state@var1249 ) {
986: setFlag (@expr1073745784 fIsThrow , state@var1249 ) ;
987: }
988: void isOperator ( bool state@var1250 ) {
989: setFlag (@expr1073745785 fIsOperator , state@var1250 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1251 ) {
992: setFlag (@expr1073745786 fHasLvalRefQual , state@var1251 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1252 ) {
995: setFlag (@expr1073745787 fHasRvalRefQual , state@var1252 ) ;
996: }
997: void isVariadic ( bool state@var1253 ) {
998: setFlag (@expr1073745788 fIsVariadic , state@var1253 ) ;
999: }
1000: void isVolatile ( bool state@var1254 ) {
1001: setFlag (@expr1073745789 fIsVolatile , state@var1254 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1255 ) {
1004: return setFlag (@expr1073745790 fHasTrailingReturnType , state@var1255 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1256 ) {
1007: setFlag (@expr1073745791 fIsInlineKeyword , state@var1256 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1257 , const Scope * scope@var1258 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1259 ;
1019: const Scope * scope@var1260 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1261 , const Token * classDef_@var1262 , const Scope * nestedIn_@var1263 ) ;
1025: Scope ( const SymbolDatabase * check_@var1264 , const Token * classDef_@var1265 , const Scope * nestedIn_@var1266 , ScopeType type_@var1267 , const Token * start_@var1268 ) ;
1026:
1027: const SymbolDatabase * check@var1269 ;
1028: std :: string className@var1270 ;
1029: const Token * classDef@var1271 ;
1030: const Token * bodyStart@var1272 ;
1031: const Token * bodyEnd@var1273 ;
1032: std :: list < Function > functionList@var1274 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1275 ;
1034: std :: list < Variable > varlist@var1276 ;
1035: const Scope * nestedIn@var1277 ;
1036: std :: list < Scope * > nestedList@var1278 ;
1037: int numConstructors@var1279 ;
1038: int numCopyOrMoveConstructors@var1280 ;
1039: std :: list < UsingInfo > usingList@var1281 ;
1040: ScopeType type@var1282 ;
1041: Type * definedType@var1283 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1284 ;
1043: std :: vector < const Token * > bodyStartList@var1285 ;
1044:
1045:
1046: const Scope * functionOf@var1286 ;
1047: Function * function@var1287 ;
1048:
1049:
1050: const Token * enumType@var1288 ;
1051: bool enumClass@var1289 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1290 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1291 ) {
1056: bodyStart@var1272 =@expr1073745792 start@var1291 ;
1057: bodyEnd@var1273 =@expr1073745793 start@var1291 ?@expr1073745794 start@var1291 .@expr1073745795 link (@expr1073745796 ) :@expr1073745797 nullptr ;
1058: if (@expr1073745798 start@var1291 ) {
1059: bodyStartList@var1285 .@expr1073745799 push_back (@expr1073745800 start@var1291 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1270 .@expr1073745801 size (@expr1073745802 ) >@expr1073745803 9 &&@expr1073745804 className@var1270 .@expr1073745805 compare (@expr1073745806 0 , 9 , "Anonymous" ) ==@expr1073745807 0 &&@expr1073745808 std ::@expr1073745809 isdigit (@expr1073745810 className@var1270 [@expr1073745811 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1292 ) const {
1068: for (@expr1073745812 const Enumerator &@expr1073745813 i@var1293 :@expr1073745814 enumeratorList@var1290 ) {
1069: if (@expr1073745815 i@var1293 .@expr1073745816 name@var1294 .@expr1073745817 str (@expr1073745818 ) ==@expr1073745819 name@var1292 ) {
1070: return &@expr1073745820 i@var1293 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1295 ) const {
1076: if (@expr1073745821 !@expr1073745822 outer@var1295 ) {
1077: return false ; }
1078: if (@expr1073745823 outer@var1295 ==@expr1073745824 this@expr1073745825 ) {
1079: return true ; }
1080: const Scope * parent@var1296 ; parent@var1296 =@expr1073745826 nestedIn@var1277 ;
1081: while (@expr1073745827 outer@var1295 !=@expr1073745828 parent@var1296 &&@expr1073745829 parent@var1296 ) {
1082: parent@var1296 =@expr1073745830 parent@var1296 .@expr1073745831 nestedIn@var1297 ; }
1083: if (@expr1073745832 parent@var1296 &&@expr1073745833 parent@var1296 ==@expr1073745834 outer@var1295 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1298 ) {
1089: while (@expr1073745835 scope@var1298 ) {
1090: if (@expr1073745836 scope@var1298 .@expr1073745837 type@var1299 ==@expr1073745838 Scope ::@expr1073745839 eFunction ) {
1091: break ; }
1092: scope@var1298 =@expr1073745840 scope@var1298 .@expr1073745841 nestedIn@var1300 ;
1093: }
1094: if (@expr1073745842 !@expr1073745843 scope@var1298 ) {
1095: return nullptr ; }
1096: return scope@var1298 .@expr1073745844 function@var1301 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073745845 type@var1282 ==@expr1073745846 eClass ||@expr1073745847 type@var1282 ==@expr1073745848 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073745849 type@var1282 ==@expr1073745850 eClass ||@expr1073745851 type@var1282 ==@expr1073745852 eStruct ||@expr1073745853 type@var1282 ==@expr1073745854 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1282 !=@expr1073745855 eClass &&@expr1073745856 type@var1282 !=@expr1073745857 eStruct &&@expr1073745858 type@var1282 !=@expr1073745859 eUnion &&@expr1073745860 type@var1282 !=@expr1073745861 eGlobal &&@expr1073745862 type@var1282 !=@expr1073745863 eNamespace &&@expr1073745864 type@var1282 !=@expr1073745865 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1282 ==@expr1073745866 Scope ::@expr4043 ScopeType ::@expr1073745868 eFor ||@expr1073745869 type@var1282 ==@expr1073745870 Scope ::@expr4043 ScopeType ::@expr1073745872 eWhile ||@expr1073745873 type@var1282 ==@expr1073745874 Scope ::@expr4043 ScopeType ::@expr1073745876 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073745877 type@var1282 ==@expr1073745878 eIf ||@expr1073745879 type@var1282 ==@expr1073745880 eElse ||@expr1073745881
1117: type@var1282 ==@expr1073745882 eFor ||@expr1073745883 type@var1282 ==@expr1073745884 eWhile ||@expr1073745885 type@var1282 ==@expr1073745886 eDo ||@expr1073745887
1118: type@var1282 ==@expr1073745888 eSwitch ||@expr1073745889 type@var1282 ==@expr1073745890 eUnconditional ||@expr1073745891
1119: type@var1282 ==@expr1073745892 eTry ||@expr1073745893 type@var1282 ==@expr1073745894 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1302 , bool requireConst@var1303 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1304 , bool isC@var1305 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1306 ) {
1135: return const_cast < Scope *@expr4071 > (@expr1073745896 const_cast < const Scope *@expr4071 > (@expr1073745898 this@expr1073745899 ) .@expr1073745900 findRecordInNestedList (@expr1073745901 name@var1306 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1307 ) const ;
1139: Type * findType ( const std :: string & name@var1308 ) {
1140: return const_cast < Type *@expr4078 > (@expr1073745903 const_cast < const Scope *@expr4078 > (@expr1073745905 this@expr1073745906 ) .@expr1073745907 findType (@expr1073745908 name@var1308 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1309 ) ;
1148:
1149: void addVariable ( const Token * token_@var1310 , const Token * start_@var1311 ,
1150: const Token * end_@var1312 , AccessControl access_@var1313 , const Type * type_@var1314 ,
1151: const Scope * scope_@var1315 , const Settings * settings@var1316 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1317 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1318 ) {
1159: functionList@var1274 .@expr1073745909 push_back (@expr1073745910 func@var1318 ) ;
1160:
1161: const Function * back@var1319 ; back@var1319 =@expr1073745911 &@expr1073745912 functionList@var1274 .@expr1073745913 back (@expr1073745914 ) ;
1162:
1163: functionMap@var1275 .@expr1073745915 insert (@expr1073745916 make_pair (@expr1073745917 back@var1319 .@expr1073745918 tokenDef@var1320 .@expr1073745919 str (@expr1073745920 ) , back@var1319 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1321 , AccessControl varaccess@var1322 , const Settings * settings@var1323 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1324 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1325 , bool isCpp@var1326 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1327 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1328 , const Token * & vartok@var1329 , const Token * & typetok@var1330 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1331 , int args@var1332 , std :: vector < const Function * > & matches@var1333 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1334 , const Token * start@var1335 , const Token * end@var1336 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1337 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1338 ;
1239: int bits@var1339 ;
1240: int pointer@var1340 ;
1241: int constness@var1341 ;
1242: Reference reference@var1342 ; reference@var1342 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1343 ;
1245: const :: Type * smartPointerType@var1344 ;
1246: const Token * smartPointerTypeToken@var1345 ;
1247: const Library :: SmartPointer * smartPointer@var1346 ;
1248: const Library :: Container * container@var1347 ;
1249:
1250: const Token * containerTypeToken@var1348 ;
1251:
1252: std :: string originalTypeName@var1349 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1337 ( UNKNOWN_SIGN ) ,
1257: type@var1338 ( UNKNOWN_TYPE ) ,
1258: bits@var1339 ( 0 ) ,
1259: pointer@var1340 ( 0U ) ,
1260: constness@var1341 ( 0U ) ,
1261: typeScope@var1343 ( nullptr ) ,
1262: smartPointerType@var1344 ( nullptr ) ,
1263: smartPointerTypeToken@var1345 ( nullptr ) ,
1264: smartPointer@var1346 ( nullptr ) ,
1265: container@var1347 ( nullptr ) ,
1266: containerTypeToken@var1348 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1350 , enum Type t@var1351 , int p@var1352 )
1269: : sign@var1337 ( s@var1350 ) ,
1270: type@var1338 ( t@var1351 ) ,
1271: bits@var1339 ( 0 ) ,
1272: pointer@var1340 ( p@var1352 ) ,
1273: constness@var1341 ( 0U ) ,
1274: typeScope@var1343 ( nullptr ) ,
1275: smartPointerType@var1344 ( nullptr ) ,
1276: smartPointerTypeToken@var1345 ( nullptr ) ,
1277: smartPointer@var1346 ( nullptr ) ,
1278: container@var1347 ( nullptr ) ,
1279: containerTypeToken@var1348 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1353 , enum Type t@var1354 , int p@var1355 , int c@var1356 )
1282: : sign@var1337 ( s@var1353 ) ,
1283: type@var1338 ( t@var1354 ) ,
1284: bits@var1339 ( 0 ) ,
1285: pointer@var1340 ( p@var1355 ) ,
1286: constness@var1341 ( c@var1356 ) ,
1287: typeScope@var1343 ( nullptr ) ,
1288: smartPointerType@var1344 ( nullptr ) ,
1289: smartPointerTypeToken@var1345 ( nullptr ) ,
1290: smartPointer@var1346 ( nullptr ) ,
1291: container@var1347 ( nullptr ) ,
1292: containerTypeToken@var1348 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1357 , enum Type t@var1358 , int p@var1359 , int c@var1360 , const std :: string & otn@var1361 )
1295: : sign@var1337 ( s@var1357 ) ,
1296: type@var1338 ( t@var1358 ) ,
1297: bits@var1339 ( 0 ) ,
1298: pointer@var1340 ( p@var1359 ) ,
1299: constness@var1341 ( c@var1360 ) ,
1300: typeScope@var1343 ( nullptr ) ,
1301: smartPointerType@var1344 ( nullptr ) ,
1302: smartPointerTypeToken@var1345 ( nullptr ) ,
1303: smartPointer@var1346 ( nullptr ) ,
1304: container@var1347 ( nullptr ) ,
1305: containerTypeToken@var1348 ( nullptr ) ,
1306: originalTypeName@var1349 ( otn@var1361 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1362 , const Settings * settings@var1363 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1364 , bool longType@var1365 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1366 , const ValueType * func@var1367 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1368 , const Variable * callVar@var1369 , const Variable * funcVar@var1370 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073745921 type@var1338 >=@expr1073745922 ValueType ::@expr1073745923 Type ::@expr1073745924 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073745925 type@var1338 >=@expr1073745926 ValueType ::@expr4103 Type ::@expr1073745928 BOOL &&@expr1073745929 type@var1338 <=@expr1073745930 ValueType ::@expr4103 Type ::@expr1073745932 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073745933 type@var1338 >=@expr1073745934 ValueType ::@expr4111 Type ::@expr1073745936 FLOAT &&@expr1073745937 type@var1338 <=@expr1073745938 ValueType ::@expr4111 Type ::@expr1073745940 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1371 , const Settings * settings@var1372 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1343 &&@expr1073745941 typeScope@var1343 .@expr1073745942 type@var1373 ==@expr1073745943 Scope ::@expr1073745944 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1374 , bool p@var1375 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1376 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1377 , const Settings * settings@var1378 , ErrorLogger * errorLogger@var1379 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1380 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1381 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1382 ;
1359:
1360:
1361: std :: list < Type > typeList@var1383 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1384 , const Token * typeTok@var1385 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1386 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1387 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1388 , const Scope * startScope@var1389 , bool lookOutside@var1390 = false ) const ;
1382: Type * findType ( const Token * startTok@var1391 , Scope * startScope@var1392 , bool lookOutside@var1393 = false ) const {
1383: return const_cast < Type *@expr4121 > (@expr1073745946 this@expr1073745947 .@expr1073745948 findType (@expr1073745949 startTok@var1391 , const_cast < const Scope *@expr4121 > (@expr1073745951 startScope@var1392 ) , lookOutside@var1393 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1394 , const Scope * startScope@var1395 ) const ;
1387: Scope * findScope ( const Token * tok@var1396 , Scope * startScope@var1397 ) const {
1388: return const_cast < Scope *@expr4128 > (@expr1073745953 this@expr1073745954 .@expr1073745955 findScope (@expr1073745956 tok@var1396 , const_cast < const Scope *@expr4128 > (@expr1073745958 startScope@var1397 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1398 ) const {
1392: return varid@var1398 <@expr1073745959 mVariableList@var1455 .@expr1073745960 size (@expr1073745961 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1399 ) const {
1396: return mVariableList@var1455 .@expr1073745962 at (@expr1073745963 varId@var1399 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1455 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1400 , const std :: string & type@var1401 , const std :: string & msg@var1402 ) const ;
1407:
1408: void printOut ( const char * title@var1403 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1404 , const char * indent@var1405 ) const ;
1410: void printXml ( std :: ostream & out@var1406 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1407 , Token * tokens@var1408 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1409 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1410 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1411 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1412 , const Token * * tok@var1413 , const Token * argStart@var1414 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1415 , const Token * tok@var1416 , const Token * argStart@var1417 , const Token * funcStart@var1418 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1419 , const Token * & tok@var1420 , const Token * argStart@var1421 , const Token * funcStart@var1422 ) ;
1469: void addNewFunction ( Scope * * scope@var1423 , const Token * * tok@var1424 ) ;
1470: bool isFunction ( const Token * tok@var1425 , const Scope * outerScope@var1426 , const Token * * funcStart@var1427 , const Token * * argStart@var1428 , const Token * * declEnd@var1429 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1430 , const Scope * startScope@var1431 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1432 , const Scope * scope@var1433 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1434 , const Scope * ns@var1435 , const std :: string & path@var1436 , int path_length@var1437 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1438 , const Token * typeTok@var1439 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1440 , const Token * vartok@var1441 , Token * membertok@var1442 , const Variable * membervar@var1443 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1444 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1445 ) const ;
1485:
1486: void setValueType ( Token * tok@var1446 , const ValueType & valuetype@var1447 ) ;
1487: void setValueType ( Token * tok@var1448 , const Variable & var@var1449 ) ;
1488: void setValueType ( Token * tok@var1450 , const Enumerator & enumerator@var1451 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1452 ;
1491: const Settings * mSettings@var1453 ;
1492: ErrorLogger * mErrorLogger@var1454 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1455 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1456 ;
1499:
1500: bool mIsCpp@var1457 ;
1501: ValueType :: Sign mDefaultSignedness@var1458 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1459 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1460 , const TFunc & visitor@var1461 )
52: {
53: if (@expr1073745964 !@expr1073745965 ast@var1460 ) {
54: return ; }
55:
56: std ::@expr1073745966 stack < T *@expr4143 , std ::@expr1073745968 vector < T *@expr4143 > > tokens@var1462 ;
57: T * tok@var1463 ; tok@var1463 =@expr1073745970 ast@var1460 ;
58: do {
59: ChildrenToVisit c@var1464 ; c@var1464 =@expr1073745971 visitor@var1461 (@expr1073745972 tok@var1463 ) ;
60:
61: if (@expr1073745973 c@var1464 ==@expr1073745974 ChildrenToVisit ::@expr1073745975 done ) {
62: break ; }
63: if (@expr1073745976 c@var1464 ==@expr1073745977 ChildrenToVisit ::@expr1073745978 op2 ||@expr1073745979 c@var1464 ==@expr4156 ChildrenToVisit ::@expr4157 op1_and_op2 ) {
64: T * t2@var1465 ; t2@var1465 =@expr1073745982 tok@var1463 .@expr1073745983 astOperand2 (@expr1073745984 ) ;
65: if (@expr1073745985 t2@var1465 ) {
66: tokens@var1462 .@expr4162 push (@expr1073745987 t2@var1465 ) ; }
67: }
68: if (@expr1073745988 c@var1464 ==@expr1073745989 ChildrenToVisit ::@expr1073745990 op1 ||@expr1073745991 c@var1464 ==@expr4156 ChildrenToVisit ::@expr4157 op1_and_op2 ) {
69: T * t1@var1466 ; t1@var1466 =@expr1073745994 tok@var1463 .@expr1073745995 astOperand1 (@expr1073745996 ) ;
70: if (@expr1073745997 t1@var1466 ) {
71: tokens@var1462 .@expr4162 push (@expr1073745999 t1@var1466 ) ; }
72: }
73:
74: if (@expr1073746000 tokens@var1462 .@expr1073746001 empty (@expr1073746002 ) ) {
75: break ; }
76:
77: tok@var1463 =@expr1073746003 tokens@var1462 .@expr1073746004 top (@expr1073746005 ) ;
78: tokens@var1462 .@expr1073746006 pop (@expr1073746007 ) ;
79: } while (@expr1073746008 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1467 , const std :: function < bool ( const Token * ) > & pred@var1468 ) ;
83: const Token * findExpression ( const int exprid@var1469 ,
84: const Token * start@var1470 ,
85: const Token * end@var1471 ,
86: const std :: function < bool ( const Token * ) > & pred@var1472 ) ;
87: const Token * findExpression ( const Token * start@var1473 , const int exprid@var1474 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1475 , const char * op@var1476 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1477 , const char * op@var1478 ) ;
91:
92: int astCount ( const Token * tok@var1479 , const char * op@var1480 , int depth@var1481 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1482 , const Token * tok@var1483 ) ;
95:
96: bool astHasVar ( const Token * tok@var1484 , int varid@var1485 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1486 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1487 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1488 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1489 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1490 , bool unknown@var1491 ) ;
107: bool astIsUnsigned ( const Token * tok@var1492 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1493 , bool unknown@var1494 ) ;
110:
111: bool astIsBool ( const Token * tok@var1495 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1496 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1497 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1498 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1499 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1500 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1501 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1502 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1503 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1504 , const std :: string & comp@var1505 , const std :: string & rhs@var1506 , const Token * * vartok@var1507 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1508 ) ;
140:
141: bool isTemporary ( bool cpp@var1509 , const Token * tok@var1510 , const Library * library@var1511 , bool unknown@var1512 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1513 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1514 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1515 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1516 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1517 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1518 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1519 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1520 ) ;
155: const Token * getParentLifetime ( bool cpp@var1521 , const Token * tok@var1522 , const Library * library@var1523 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1524 ) ;
158: bool astIsRHS ( const Token * tok@var1525 ) ;
159:
160: Token * getCondTok ( Token * tok@var1526 ) ;
161: const Token * getCondTok ( const Token * tok@var1527 ) ;
162:
163: Token * getInitTok ( Token * tok@var1528 ) ;
164: const Token * getInitTok ( const Token * tok@var1529 ) ;
165:
166: Token * getStepTok ( Token * tok@var1530 ) ;
167: const Token * getStepTok ( const Token * tok@var1531 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1532 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1533 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1534 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1535 ,
180: int * const varid@var1536 ,
181: bool * const knownInitValue@var1537 ,
182: long long * const initValue@var1538 ,
183: bool * const partialCond@var1539 ,
184: long long * const stepValue@var1540 ,
185: long long * const lastValue@var1541 ) ;
186:
187: bool precedes ( const Token * tok1@var1542 , const Token * tok2@var1543 ) ;
188: bool succeeds ( const Token * tok1@var1544 , const Token * tok2@var1545 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1546 , bool onVar@var1547 = true , int depth@var1548 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1549 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1550 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1551 ,
198: bool temporary@var1552 = true ,
199: bool inconclusive@var1553 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1554 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1555 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1556 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1557 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1558 , bool macro@var1559 , const Token * tok1@var1560 , const Token * tok2@var1561 , const Library & library@var1562 , bool pure@var1563 , bool followVar@var1564 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1565 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1566 , const Token * const tok2@var1567 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1568 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1569 , bool cpp@var1570 , const Token * const cond1@var1571 , const Token * const cond2@var1572 , const Library & library@var1573 , bool pure@var1574 , bool followVar@var1575 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1576 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1577 , const Token * const tok1@var1578 , const Token * const tok2@var1579 , const Library & library@var1580 , bool pure@var1581 , bool followVar@var1582 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1583 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1584 , const Library & library@var1585 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1586 , const Library & library@var1587 , bool pure@var1588 , bool cpp@var1589 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1590 , const Token * tok@var1591 , bool checkArrayAccess@var1592 = false , bool checkReference@var1593 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1594 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1595 , const Library * library@var1596 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1597 ,
238: const Library * library@var1598 = nullptr ,
239: const Token * * unknownFunc@var1599 = nullptr ,
240: bool functionScope@var1600 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1601 ,
244: const Variable * var@var1602 ,
245: Scope :: ScopeType type@var1603 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1604 , int & argn@var1605 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1606 , int & argn@var1607 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1608 , int argnr@var1609 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1610 , int indirect@var1611 , int varid@var1612 , const Settings * settings@var1613 , bool * inconclusive@var1614 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1615 , int indirect@var1616 , const Settings * settings@var1617 , bool * inconclusive@var1618 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1619 , const Token * end@var1620 , const int exprid@var1621 , bool globalvar@var1622 , const Settings * settings@var1623 , bool cpp@var1624 , int depth@var1625 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1626 , const Token * end@var1627 , int indirect@var1628 , const int exprid@var1629 , bool globalvar@var1630 , const Settings * settings@var1631 , bool cpp@var1632 , int depth@var1633 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1634 , int indirect@var1635 , const Settings * settings@var1636 , bool cpp@var1637 , int depth@var1638 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1639 , const Settings * settings@var1640 , bool cpp@var1641 , int depth@var1642 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1643 ,
283: const Token * end@var1644 ,
284: int indirect@var1645 ,
285: std :: vector < const Variable * > vars@var1646 ,
286: const Settings * settings@var1647 ,
287: bool cpp@var1648 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1649 , int indirect@var1650 , const Settings * settings@var1651 , bool cpp@var1652 ) ;
290: bool isThisChanged ( const Token * start@var1653 , const Token * end@var1654 , int indirect@var1655 , const Settings * settings@var1656 , bool cpp@var1657 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1658 , const Token * end@var1659 , int indirect@var1660 , const int exprid@var1661 , bool globalvar@var1662 , const Settings * settings@var1663 , bool cpp@var1664 , int depth@var1665 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1666 , const Token * end@var1667 , int indirect@var1668 , const int exprid@var1669 , bool globalvar@var1670 , const Settings * settings@var1671 , bool cpp@var1672 , int depth@var1673 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1674 ,
296: const Token * start@var1675 ,
297: const Token * end@var1676 ,
298: const Settings * settings@var1677 ,
299: bool cpp@var1678 ,
300: int depth@var1679 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1680 ,
303: const Token * tok@var1681 ,
304: int indirect@var1682 ,
305: bool globalvar@var1683 ,
306: const Settings * settings@var1684 ,
307: bool cpp@var1685 ,
308: int depth@var1686 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1687 , int varid@var1688 , bool * inconclusive@var1689 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1690 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1691 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1692 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1693 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1694 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1695 , const Function * f@var1696 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1697 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1698 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1699 ) ;
346: Token * findLambdaEndToken ( Token * first@var1700 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1701 , const Token * stream@var1702 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1703 , const Token * op@var1704 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1705 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1706 , const char * skipMatch@var1707 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1708 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1709 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1710 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1711 , const Library & library@var1712 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1713 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1714 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1715 , bool cpp@var1716 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1717 , const Library & library@var1718 ) : mCpp@var1751 ( cpp@var1717 ) , mLibrary@var1752 ( library@var1718 ) , mWhat@var1753 ( What :: Reassign ) , mValueFlowKnown@var1755 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1719 , const Token * lhs@var1720 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1721 , const Token * startToken@var1722 , const Token * endToken@var1723 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1724 , const Token * startToken@var1725 , const Token * endToken@var1726 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1727 ;
407: const Token * token@var1728 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1729 , const Token * startToken@var1730 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1731 , bool * localOut@var1732 = nullptr , bool * unknownVarIdOut@var1733 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1734 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1735 ;
420: explicit Result ( Type type@var1736 ) : type@var1735 ( type@var1736 ) , token@var1739 ( nullptr ) { }
421: Result ( Type type@var1737 , const Token * token@var1738 ) : type@var1735 ( type@var1737 ) , token@var1739 ( token@var1738 ) { }
422: const Token * token@var1739 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1740 , const Token * startToken@var1741 , const Token * endToken@var1742 ) ;
426: struct Result checkRecursive ( const Token * expr@var1743 , const Token * startToken@var1744 , const Token * endToken@var1745 , const std :: set < int > & exprVarIds@var1746 , bool local@var1747 , bool inInnerClass@var1748 , int depth@var1749 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1750 ) const ;
430:
431: const bool mCpp@var1751 ;
432: const Library & mLibrary@var1752 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1753 ;
434: std :: vector < KnownAndToken > mValueFlow@var1754 ;
435: bool mValueFlowKnown@var1755 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1756 ) ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var1757 ) {
44: if (@expr1073746009 bit@var1757 >=@expr1073746010 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073746011 (@expr1073746012 1LL <<@expr1073746013 (@expr1073746014 bit@var1757 -@expr1073746015 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var1758 ) {
50: if (@expr1073746016 bit@var1758 >=@expr1073746017 64 ) {
51: return (@expr4194 ~@expr1073746019 0ULL ) >>@expr1073746020 1 ; }
52: return (@expr4194 1LL <<@expr1073746022 (@expr4194 bit@var1758 -@expr1073746024 1 ) ) -@expr1073746025 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var1759 ) const {
59: return value@var1759 >=@expr1073746026 min_value (@expr1073746027 int_bit@var1769 ) &&@expr1073746028 value@var1759 <=@expr1073746029 max_value (@expr1073746030 int_bit@var1769 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var1760 ) const {
63: unsigned long long intMax@var1761 ; intMax@var1761 =@expr1073746031 max_value (@expr1073746032 int_bit@var1769 ) ;
64: return value@var1760 <=@expr1073746033 intMax@var1761 ;
65: }
66:
67: bool isLongValue ( long long value@var1762 ) const {
68: return value@var1762 >=@expr1073746034 min_value (@expr1073746035 long_bit@var1770 ) &&@expr1073746036 value@var1762 <=@expr1073746037 max_value (@expr1073746038 long_bit@var1770 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var1763 ) const {
72: unsigned long long longMax@var1764 ; longMax@var1764 =@expr1073746039 max_value (@expr1073746040 long_bit@var1770 ) ;
73: return value@var1763 <=@expr1073746041 longMax@var1764 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var1765 ) const {
77: unsigned long long longLongMax@var1766 ; longLongMax@var1766 =@expr1073746042 max_value (@expr1073746043 long_long_bit@var1771 ) ;
78: return value@var1765 <=@expr1073746044 longLongMax@var1766 ;
79: }
80:
81: int char_bit@var1767 ;
82: int short_bit@var1768 ;
83: int int_bit@var1769 ;
84: int long_bit@var1770 ;
85: int long_long_bit@var1771 ;
86:
87:
88: int sizeof_bool@var1772 ;
89: int sizeof_short@var1773 ;
90: int sizeof_int@var1774 ;
91: int sizeof_long@var1775 ;
92: int sizeof_long_long@var1776 ;
93: int sizeof_float@var1777 ;
94: int sizeof_double@var1778 ;
95: int sizeof_long_double@var1779 ;
96: int sizeof_wchar_t@var1780 ;
97: int sizeof_size_t@var1781 ;
98: int sizeof_pointer@var1782 ;
99:
100: char defaultSign@var1783 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var1784 ;
115:
116:
117: bool platform ( PlatformType type@var1785 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var1786 [ ] , const std :: string & filename@var1787 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var1788 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var1784 ==@expr1073746045 Win32A ||@expr1073746046
136: platformType@var1784 ==@expr1073746047 Win32W ||@expr1073746048
137: platformType@var1784 ==@expr1073746049 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073746050 platformType@var1784 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var1789 ) {
145: switch (@expr1073746051 pt@var1789 ) {
146: case Unspecified :@expr4228 ;
147: return "Unspecified" ;
148: case Native :@expr4228 ;
149: return "Native" ;
150: case Win32A :@expr4228 ;
151: return "win32A" ;
152: case Win32W :@expr4228 ;
153: return "win32W" ;
154: case Win64 :@expr4228 ;
155: return "win64" ;
156: case Unix32 :@expr4228 ;
157: return "unix32" ;
158: case Unix64 :@expr4228 ;
159: return "unix64" ;
160: case PlatformFile :@expr4228 ;
161: return "platformFile" ;
162: default :@expr4228 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073746061 char_bit@var1767 +@expr1073746062 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073746063 char_bit@var1767 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073746064 char_bit@var1767 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var1790 , const std :: string & rhs@var1791 ) const {
41: return caseInsensitiveStringCompare (@expr1073746065 lhs@var1790 , rhs@var1791 ) <@expr1073746066 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var1799 ( cppcheck :: Platform :: Unspecified ) , msc@var1800 ( false ) , useMfc@var1801 ( false ) { }
67: std :: string cfg@var1792 ;
68: std :: string filename@var1793 ;
69: std :: string defines@var1794 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var1794 +@expr1073746067 (@expr1073746068 msc@var1800 ?@expr1073746069 ";_MSC_VER=1900" :@expr1073746070 "" ) +@expr1073746071 (@expr1073746072 useMfc@var1801 ?@expr1073746073 ";__AFXWIN_H__=1" :@expr1073746074 "" ) ;
72: }
73: std :: set < std :: string > undefs@var1795 ;
74: std :: list < std :: string > includePaths@var1796 ;
75: std :: list < std :: string > systemIncludePaths@var1797 ;
76: std :: string standard@var1798 ;
77: cppcheck :: Platform :: PlatformType platformType@var1799 ;
78: bool msc@var1800 ;
79: bool useMfc@var1801 ;
80:
81: void parseCommand ( std :: string command@var1802 ) ;
82: void setDefines ( std :: string defs@var1803 ) ;
83: void setIncludePaths ( const std :: string & basepath@var1804 , const std :: list < std :: string > & in@var1805 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1806 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var1807 ;
86: Type projectType@var1808 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var1809 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous5 {
96: std :: string analyzeAllVsConfigs@var1810 ;
97: std :: vector < std :: string > pathNames@var1811 ;
98: std :: list < std :: string > libraries@var1812 ;
99: std :: list < std :: string > excludedPaths@var1813 ;
100: std :: list < std :: string > checkVsConfigs@var1814 ;
101: std :: string projectFile@var1815 ;
102: std :: string platform@var1816 ;
103: } ; struct Anonymous5 guiProject@var1817 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var1818 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var1819 ) ;
107:
108: Type import ( const std :: string & filename@var1820 , Settings * settings@var1821 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var1822 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var1823 , Settings * settings@var1824 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var1825 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var1826 , const std :: string & path@var1827 , const std :: vector < std :: string > & fileFilters@var1828 ) ;
115: bool importVcxproj ( const std :: string & filename@var1829 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1830 , const std :: string & additionalIncludeDirectories@var1831 , const std :: vector < std :: string > & fileFilters@var1832 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var1833 ) ;
117:
118: static void printError ( const std :: string & message@var1834 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var1835 ) ;
121:
122: std :: string mPath@var1836 ;
123: std :: set < std :: string > mAllVSConfigs@var1837 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var1838 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var1839 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var1840 [ 2 ] = "1" ;
131: const char BuildDirElementName@var1841 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var1842 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var1843 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var1844 [ 7 ] = "parser" ;
135: const char BugHunting@var1845 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var1846 [ 11 ] = "includedir" ;
137: const char DirElementName@var1847 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var1848 [ 5 ] = "name" ;
139: const char DefinesElementName@var1849 [ 8 ] = "defines" ;
140: const char DefineName@var1850 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var1851 [ 5 ] = "name" ;
142: const char UndefinesElementName@var1852 [ 10 ] = "undefines" ;
143: const char UndefineName@var1853 [ 9 ] = "undefine" ;
144: const char PathsElementName@var1854 [ 6 ] = "paths" ;
145: const char PathName@var1855 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var1856 [ 5 ] = "name" ;
147: const char RootPathName@var1857 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var1858 [ 5 ] = "name" ;
149: const char IgnoreElementName@var1859 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var1860 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var1861 [ 5 ] = "name" ;
152: const char ExcludeElementName@var1862 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var1863 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var1864 [ 5 ] = "name" ;
155: const char FunctionContracts@var1865 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var1866 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var1867 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var1868 [ 8 ] = "library" ;
159: const char PlatformElementName@var1869 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var1870 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var1871 [ 12 ] = "suppression" ;
162: const char AddonElementName@var1872 [ 6 ] = "addon" ;
163: const char AddonsElementName@var1873 [ 7 ] = "addons" ;
164: const char ToolElementName@var1874 [ 5 ] = "tool" ;
165: const char ToolsElementName@var1875 [ 6 ] = "tools" ;
166: const char TagsElementName@var1876 [ 5 ] = "tags" ;
167: const char TagElementName@var1877 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var1878 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var1879 [ 4 ] = "tag" ;
170: const char WarningElementName@var1880 [ 8 ] = "warning" ;
171: const char HashAttributeName@var1881 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var1882 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var1883 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var1884 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var1885 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var1886 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var1887 [ 11 ] = "clang-tidy" ;
178: const char Name@var1888 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var1889 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var1890 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var1891 ;
43: std :: string errorId@var1892 ;
44: void setFileName ( const std :: string & s@var1893 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var1897 ;
47: }
48: int lineNumber@var1894 ;
49: Certainty :: CertaintyLevel certainty@var1895 ;
50: std :: string symbolNames@var1896 ;
51: private:
52: std :: string mFileName@var1897 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var1931 ( NO_LINE ) , hash@var1933 ( 0 ) , thisAndNextLine@var1934 ( false ) , matched@var1935 ( false ) , checked@var1936 ( false ) { }
57: Suppression ( const Suppression & other@var1898 ) {
58: *@expr1073746075 this@expr1073746076 =@expr1073746077 other@var1898 ;
59: }
60: Suppression ( const std :: string & id@var1899 , const std :: string & file@var1900 , int line@var1901 = NO_LINE ) : errorId@var1929 ( id@var1899 ) , fileName@var1930 ( file@var1900 ) , lineNumber@var1931 ( line@var1901 ) , hash@var1933 ( 0 ) , thisAndNextLine@var1934 ( false ) , matched@var1935 ( false ) , checked@var1936 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var1902 ) {
63: errorId@var1929 =@expr1073746078 other@var1902 .@expr1073746079 errorId@var1903 ;
64: fileName@var1930 =@expr1073746080 other@var1902 .@expr1073746081 fileName@var1904 ;
65: lineNumber@var1931 =@expr1073746082 other@var1902 .@expr1073746083 lineNumber@var1905 ;
66: symbolName@var1932 =@expr1073746084 other@var1902 .@expr1073746085 symbolName@var1906 ;
67: hash@var1933 =@expr1073746086 other@var1902 .@expr1073746087 hash@var1907 ;
68: thisAndNextLine@var1934 =@expr1073746088 other@var1902 .@expr1073746089 thisAndNextLine@var1908 ;
69: matched@var1935 =@expr1073746090 other@var1902 .@expr1073746091 matched@var1909 ;
70: checked@var1936 =@expr1073746092 other@var1902 .@expr1073746093 checked@var1910 ;
71: return *@expr1073746094 this@expr1073746095 ;
72: }
73:
74: bool operator< ( const Suppression & other@var1911 ) const {
75: if (@expr1073746096 errorId@var1929 !=@expr1073746097 other@var1911 .@expr4274 errorId@var1912 ) {
76: return errorId@var1929 <@expr1073746099 other@var1911 .@expr4274 errorId@var1912 ; }
77: if (@expr1073746101 lineNumber@var1931 <@expr1073746102 other@var1911 .@expr1073746103 lineNumber@var1913 ) {
78: return true ; }
79: if (@expr1073746104 fileName@var1930 !=@expr1073746105 other@var1911 .@expr4282 fileName@var1914 ) {
80: return fileName@var1930 <@expr1073746107 other@var1911 .@expr4282 fileName@var1914 ; }
81: if (@expr1073746109 symbolName@var1932 !=@expr1073746110 other@var1911 .@expr4287 symbolName@var1915 ) {
82: return symbolName@var1932 <@expr1073746112 other@var1911 .@expr4287 symbolName@var1915 ; }
83: if (@expr1073746114 hash@var1933 !=@expr1073746115 other@var1911 .@expr4292 hash@var1916 ) {
84: return hash@var1933 <@expr1073746117 other@var1911 .@expr4292 hash@var1916 ; }
85: if (@expr1073746119 thisAndNextLine@var1934 !=@expr1073746120 other@var1911 .@expr1073746121 thisAndNextLine@var1917 ) {
86: return thisAndNextLine@var1934 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var1918 , std :: string * errorMessage@var1919 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var1920 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var1921 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073746123 fileName@var1930 .@expr1073746124 empty (@expr1073746125 ) &&@expr1073746126 fileName@var1930 .@expr1073746127 find_first_of (@expr1073746128 "?*" ) ==@expr1073746129 std ::@expr1073746130 string ::@expr1073746131 npos@expr1073746122 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var1922 ) const {
109: return errorId@var1929 ==@expr1073746132 other@var1922 .@expr1073746133 errorId@var1923 &&@expr1073746134
110: fileName@var1930 ==@expr1073746135 other@var1922 .@expr1073746136 fileName@var1924 &&@expr1073746137
111: lineNumber@var1931 ==@expr1073746138 other@var1922 .@expr1073746139 lineNumber@var1925 &&@expr1073746140
112: symbolName@var1932 ==@expr1073746141 other@var1922 .@expr1073746142 symbolName@var1926 &&@expr1073746143
113: hash@var1933 ==@expr1073746144 other@var1922 .@expr1073746145 hash@var1927 &&@expr1073746146
114: thisAndNextLine@var1934 ==@expr1073746147 other@var1922 .@expr1073746148 thisAndNextLine@var1928 ;
115: }
116:
117: std :: string errorId@var1929 ;
118: std :: string fileName@var1930 ;
119: int lineNumber@var1931 ;
120: std :: string symbolName@var1932 ;
121: unsigned long hash@var1933 ;
122: bool thisAndNextLine@var1934 ;
123: bool matched@var1935 ;
124: bool checked@var1936 ;
125:
126: enum Anonymous6 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var1937 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var1938 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var1939 , std :: string * errorMessage@var1940 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var1941 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var1942 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var1943 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var1944 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var1945 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var1946 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var1947 , const bool unusedFunctionChecking@var1948 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1949 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1950 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var1951 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var1952 , std :: clock_t clocks@var1953 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var1954 ;
45: long mNumberOfResults@var1955 ;
46:
47: TimerResultsData ( )
48: : mClocks@var1954 ( 0 )
49: , mNumberOfResults@var1955 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var1956 =@expr1073746150 (@expr1073746151 double ) (@expr1073746152 (@expr1073746153 unsigned long ) mClocks@var1954 ) /@expr1073746154 (@expr1073746155 double ) CLOCKS_PER_SEC@expr1073746149 ;
53: return ret@var1956 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var1957 ) const ;
62: void addResults ( const std :: string & str@var1958 , std :: clock_t clocks@var1959 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var1960 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var1961 , SHOWTIME_MODES showtimeMode@var1962 , TimerResultsIntf * timerResults@var1963 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var1964 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var1965 ;
79: TimerResultsIntf * mTimerResults@var1966 ;
80: std :: clock_t mStart@var1967 ;
81: const SHOWTIME_MODES mShowTimeMode@var1968 ;
82: bool mStopped@var1969 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var1970 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var1971 ;
103:
104:
105: std :: string addonPython@var1972 ;
106:
107:
108: std :: vector < std :: string > basePaths@var1973 ;
109:
110:
111: std :: string buildDir@var1974 ;
112:
113:
114: bool checkAllConfigurations@var1975 ;
115:
116:
117: bool checkConfiguration@var1976 ;
118:
|
121:
122: bool checkHeaders@var1977 ;
123:
124:
125: bool checkLibrary@var1978 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var1979 ;
129:
130:
131: bool checkUnusedTemplates@var1980 ;
132:
133:
134: bool clang@var1981 ;
135:
136:
137: std :: string clangExecutable@var1982 ;
138:
139:
140: bool clangTidy@var1983 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var1984 ;
144:
145:
146: std :: string cppcheckCfgProductName@var1985 ;
147:
148:
149: std :: string cppcheckCfgAbout@var1986 ;
150:
151:
152: bool daca@var1987 ;
153:
154:
155: bool debugnormal@var1988 ;
156:
157:
158: bool debugSimplified@var1989 ;
159:
160:
161: bool debugtemplate@var1990 ;
162:
163:
164: bool debugwarnings@var1991 ;
165:
166:
167: bool dump@var1992 ;
168: std :: string dumpFile@var1993 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var1994 ;
176:
177:
178: bool exceptionHandling@var1995 ;
179:
180:
181: std :: string exename@var1996 ;
182:
183:
184:
185: int exitCode@var1997 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var1998 ;
189:
190:
191: bool force@var1999 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var2000 ;
196:
197:
198: bool inlineSuppressions@var2001 ;
199:
200:
201:
202: unsigned int jobs@var2002 ;
203:
|
206:
207: bool jointSuppressionReport@var2003 ;
208:
209:
210: std :: list < std :: string > libraries@var2004 ;
211:
212:
213: Library library@var2005 ;
214:
215:
216:
217: int loadAverage@var2006 ;
218:
|
221:
222: int maxConfigs@var2007 ;
223:
224:
225: int maxCtuDepth@var2008 ;
226:
227:
228: int maxTemplateRecursion@var2009 ;
229:
230:
231: Suppressions nofail@var2010 ;
232:
233:
234: Suppressions nomsg@var2011 ;
235:
236:
237: std :: string outputFile@var2012 ;
238:
239:
240: std :: string plistOutput@var2013 ;
241:
242:
243: bool preprocessOnly@var2014 ;
244:
245: ImportProject project@var2015 ;
246:
247:
248: bool quiet@var2016 ;
249:
250:
251: bool relativePaths@var2017 ;
252:
253:
254: bool reportProgress@var2018 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var2019 ( "simple" )
261: , id@var2021 ( "rule" )
262: , severity@var2023 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var2019 ;
266: std :: string pattern@var2020 ;
267: std :: string id@var2021 ;
268: std :: string summary@var2022 ;
269: Severity :: SeverityType severity@var2023 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var2024 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var2030 ( false ) , externalFunctions@var2031 ( false ) , internalFunctions@var2032 ( false ) , externalVariables@var2033 ( false ) { }
281:
282: static const char XmlRootName@var2025 [ ] ;
283: static const char XmlClasses@var2026 [ ] ;
284: static const char XmlExternalFunctions@var2027 [ ] ;
285: static const char XmlInternalFunctions@var2028 [ ] ;
286: static const char XmlExternalVariables@var2029 [ ] ;
287:
288: void clear ( ) {
289: classes@var2030 =@expr1073746156 externalFunctions@var2031 =@expr1073746157 internalFunctions@var2032 =@expr1073746158 externalVariables@var2033 =@expr1073746159 false ;
290: }
291:
|
297:
298: bool classes@var2030 ;
299:
|
304:
305: bool externalFunctions@var2031 ;
306:
|
310:
311: bool internalFunctions@var2032 ;
312:
|
316:
317: bool externalVariables@var2033 ;
318: } ;
319:
320: SafeChecks safeChecks@var2034 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var2035 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var2036 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var2037 ;
325:
326:
327: SHOWTIME_MODES showtime@var2038 ;
328:
329:
330: Standards standards@var2039 ;
331:
332:
333:
334: std :: string templateFormat@var2040 ;
335:
336:
337:
338: std :: string templateLocation@var2041 ;
339:
340:
341: std :: string userDefines@var2042 ;
342:
343:
344: std :: set < std :: string > userUndefs@var2043 ;
345:
346:
347: std :: list < std :: string > userIncludes@var2044 ;
348:
349:
350: bool verbose@var2045 ;
351:
352:
353: bool xml@var2046 ;
354:
355:
356: int xml_version@var2047 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var2048 ) const {
363: for (@expr1073746160 const std ::@expr1073746161 string &@expr1073746162 configExcludePath@var2049 :@expr1073746163 configExcludePaths@var1984 ) {
364: if (@expr1073746164 file@var2048 .@expr1073746165 length (@expr1073746166 ) >=@expr1073746167 configExcludePath@var2049 .@expr4344 length (@expr4345 ) &&@expr1073746170 file@var2048 .@expr1073746171 compare (@expr1073746172 0 , configExcludePath@var2049 .@expr4344 length (@expr4345 ) , configExcludePath@var2049 ) ==@expr1073746175 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var2050 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var2051 , bool inconclusiveCheck@var2052 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073746176 find (@expr1073746177 libraries@var2004 .@expr1073746178 begin (@expr1073746179 ) , libraries@var2004 .@expr4356 end (@expr4357 ) , "posix" ) !=@expr1073746182 libraries@var2004 .@expr4356 end (@expr4357 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var2053 = true ) {
392: Settings ::@expr1073746185 mTerminated@var1970 =@expr1073746186 t@var2053 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073746187 mTerminated@var1970 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var2054 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueptr.h

1:
|
27:
28: class ValuePtr<Analyzer> ; class ValuePtr<InferModel> ;

##file cppcheck-2.8/lib/forwardanalyzer.cpp

1:
|
41:
42: struct OnExit {
43: std :: function < void ( ) > f@var2055 ;
44:
45: ~ OnExit ( ) {
46: f@var2055 (@expr1073746188 ) ;
47: }
48: } ;
49:
50: struct ForwardTraversal {
51: enum class Progress { Continue , Break , Skip } ;
52: enum class Terminate { None , Bail , Escape , Modified , Inconclusive , Conditional } ;
53: ForwardTraversal ( const ValuePtr<Analyzer> & analyzer@var2056 , const Settings * settings@var2057 )
54: : analyzer@var2058 ( analyzer@var2056 ) , settings@var2059 ( settings@var2057 ) , actions@var2060 ( Analyzer :: Action :: None ) , analyzeOnly@var2061 ( false ) , analyzeTerminate@var2062 ( false )
55: { }
56: ValuePtr<Analyzer> analyzer@var2058 ;
57: const Settings * settings@var2059 ;
58: Analyzer :: Action actions@var2060 ;
59: bool analyzeOnly@var2061 ;
60: bool analyzeTerminate@var2062 ;
61: Analyzer :: Terminate terminate@var2063 ; terminate@var2063 = Analyzer :: Terminate :: None ;
62: bool forked@var2064 ; forked@var2064 = false ;
63: std :: vector < Token * > loopEnds@var2065 ; loopEnds@var2065 = { } ;
64:
65: Progress Break ( Analyzer :: Terminate t@var2066 = Analyzer :: Terminate :: None ) {
66: if (@expr1073746189 (@expr1073746190 !@expr1073746191 analyzeOnly@var2061 ||@expr1073746192 analyzeTerminate@var2062 ) &&@expr1073746193 t@var2066 !=@expr1073746194 Analyzer ::@expr1073746195 Terminate ::@expr1073746196 None ) {
67: terminate@var2063 =@expr1073746197 t@var2066 ; }
68: return Progress ::@expr1073746198 Break ;
69: }
70:
71: struct Branch {
72: Branch ( Token * tok@var2067 = nullptr ) : endBlock@var2068 ( tok@var2067 ) { }
73: Token * endBlock@var2068 ; endBlock@var2068 = nullptr ;
74: Analyzer :: Action action@var2069 ; action@var2069 = Analyzer :: Action :: None ;
75: bool check@var2070 ; check@var2070 = false ;
76: bool escape@var2071 ; escape@var2071 = false ;
77: bool escapeUnknown@var2072 ; escapeUnknown@var2072 = false ;
78: bool active@var2073 ; active@var2073 = false ;
79: bool isEscape ( ) const {
80: return escape@var2071 ||@expr1073746199 escapeUnknown@var2072 ;
81: }
82: bool isConclusiveEscape ( ) const {
83: return escape@var2071 &&@expr1073746200 !@expr1073746201 escapeUnknown@var2072 ;
84: }
85: bool isModified ( ) const {
86: return action@var2069 .@expr1073746202 isModified (@expr1073746203 ) &&@expr1073746204 !@expr1073746205 isConclusiveEscape (@expr1073746206 ) ;
87: }
88: bool isInconclusive ( ) const {
89: return action@var2069 .@expr1073746207 isInconclusive (@expr1073746208 ) &&@expr1073746209 !@expr1073746210 isConclusiveEscape (@expr1073746211 ) ;
90: }
91: bool isDead ( ) const {
92: return action@var2069 .@expr1073746212 isModified (@expr1073746213 ) ||@expr1073746214 action@var2069 .@expr1073746215 isInconclusive (@expr1073746216 ) ||@expr1073746217 isEscape (@expr1073746218 ) ;
93: }
94: } ;
95:
96: bool stopUpdates ( ) {
97: analyzeOnly@var2061 =@expr1073746219 true ;
98: return actions@var2060 .@expr1073746220 isModified (@expr1073746221 ) ;
99: }
100:
101: std :: pair < bool , bool > evalCond ( const Token * tok@var2074 , const Token * ctx@var2075 = nullptr ) const {
102: if (@expr1073746222 !@expr1073746223 tok@var2074 ) {
103: return std ::@expr4400 make_pair (@expr1073746225 false , false ) ; }
104: std ::@expr1073746226 vector < long long > result@var2076 ; result@var2076 =@expr1073746227 analyzer@var2058 .@expr1073746228 evaluate (@expr1073746229 tok@var2074 , ctx@var2075 ) ;
105:
106: bool checkThen@var2077 ; checkThen@var2077 =@expr1073746230 std ::@expr4407 any_of (@expr1073746232 result@var2076 .@expr4409 begin (@expr4410 ) , result@var2076 .@expr4411 end (@expr4412 ) , [@expr1073746237 ] (@expr1073746238 int x@var2078 ) {
107: return x@var2078 !=@expr1073746239 0 ;
108: } ) ;
109: bool checkElse@var2079 ; checkElse@var2079 =@expr1073746240 std ::@expr4407 any_of (@expr1073746242 result@var2076 .@expr4409 begin (@expr4410 ) , result@var2076 .@expr4411 end (@expr4412 ) , [@expr1073746247 ] (@expr1073746248 int x@var2080 ) {
110: return x@var2080 ==@expr1073746249 0 ;
111: } ) ;
112: return std ::@expr4400 make_pair (@expr1073746251 checkThen@var2077 , checkElse@var2079 ) ;
113: }
114:
115: bool isConditionTrue ( const Token * tok@var2081 , const Token * ctx@var2082 = nullptr ) const {
116: return evalCond (@expr1073746252 tok@var2081 , ctx@var2082 ) .@expr1073746253 first@var2083 ;
117: }
118:
119:
120: bool isConditionFalse ( const Token * tok@var2084 , const Token * ctx@var2085 = nullptr ) const {
121: return evalCond (@expr1073746254 tok@var2084 , ctx@var2085 ) .@expr1073746255 second@var2086 ;
122: }
123:
124: template < class T , class F , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
125: Progress traverseTok ( T * tok@var2087 , F f@var2088 , bool traverseUnknown@var2089 , T * * out@var2090 = nullptr ) {
126: if (@expr1073746256 Token ::@expr4433 Match (@expr1073746258 tok@var2087 , "asm|goto" ) ) {
127: return Break (@expr4435 Analyzer ::@expr4436 Terminate ::@expr4437 Bail ) ; }
128: else { if (@expr1073746262 Token ::@expr4433 Match (@expr1073746264 tok@var2087 , "setjmp|longjmp (" ) ) {
129:
130: traverseRecursive (@expr4441 tok@var2087 .@expr4442 next (@expr4443 ) .@expr4444 astOperand2 (@expr4445 ) , f@var2088 , traverseUnknown@var2089 ) ;
131: return Break (@expr4435 Analyzer ::@expr4436 Terminate ::@expr4437 Bail ) ;
132: } else { if (@expr1073746273 Token ::@expr1073746274 simpleMatch (@expr1073746275 tok@var2087 , "continue" ) ) {
133: if (@expr1073746276 loopEnds@var2065 .@expr1073746277 empty (@expr1073746278 ) ) {
134: return Break (@expr4455 Analyzer ::@expr4436 Terminate ::@expr4457 Escape ) ; }
135:
136: if (@expr4458 out@var2090 ) {
137: *@expr4459 out@var2090 =@expr1073746284 loopEnds@var2065 .@expr1073746285 back (@expr1073746286 ) ; }
138: } else { if (@expr1073746287 Token ::@expr4433 Match (@expr1073746289 tok@var2087 , "return|throw" ) ) {
139: traverseRecursive (@expr1073746290 tok@var2087 .@expr4467 astOperand2 (@expr4468 ) , f@var2088 , traverseUnknown@var2089 ) ;
140: traverseRecursive (@expr1073746293 tok@var2087 .@expr4470 astOperand1 (@expr4471 ) , f@var2088 , traverseUnknown@var2089 ) ;
141: return Break (@expr4455 Analyzer ::@expr4436 Terminate ::@expr4457 Escape ) ;
142: } else { if (@expr1073746299 Token ::@expr4433 Match (@expr1073746301 tok@var2087 , "%name% (" ) &&@expr1073746302 isEscapeFunction (@expr1073746303 tok@var2087 , &@expr1073746304 settings@var2059 .@expr1073746305 library@var2091 ) ) {
143:
144: traverseRecursive (@expr4441 tok@var2087 .@expr4442 next (@expr4443 ) .@expr4444 astOperand2 (@expr4445 ) , f@var2088 , traverseUnknown@var2089 ) ;
145: return Break (@expr4455 Analyzer ::@expr4436 Terminate ::@expr4457 Escape ) ;
146: } else { if (@expr1073746314 isUnevaluated (@expr1073746315 tok@var2087 ) ) {
147: if (@expr4458 out@var2090 ) {
148: *@expr4459 out@var2090 =@expr1073746318 tok@var2087 .@expr4495 link (@expr4496 ) ; }
149: return Progress ::@expr4497 Skip ;
150: } else { if (@expr1073746322 tok@var2087 .@expr4470 astOperand1 (@expr4471 ) &&@expr1073746325 tok@var2087 .@expr4467 astOperand2 (@expr4468 ) &&@expr1073746328 Token ::@expr4433 Match (@expr1073746330 tok@var2087 , "?|&&|%oror%" ) ) {
151: if (@expr1073746331 traverseConditional (@expr1073746332 tok@var2087 , f@var2088 , traverseUnknown@var2089 ) ==@expr1073746333 Progress ::@expr4510 Break ) {
152: return Break (@expr4511 ) ; }
153: if (@expr4458 out@var2090 ) {
154: *@expr4459 out@var2090 =@expr1073746338 nextAfterAstRightmostLeaf (@expr1073746339 tok@var2087 ) ; }
155: return Progress ::@expr4497 Skip ;
156:
157: } else { if (@expr1073746341 T *@expr1073746342 lambdaEndToken@var2092 =@expr1073746343 findLambdaEndToken (@expr1073746344 tok@var2087 ) ) {
158: if (@expr1073746345 checkScope (@expr1073746346 lambdaEndToken@var2092 ) .@expr1073746347 isModified (@expr1073746348 ) ) {
159: return Break (@expr4435 Analyzer ::@expr4436 Terminate ::@expr4437 Bail ) ; }
160: if (@expr4458 out@var2090 ) {
161: *@expr4459 out@var2090 =@expr1073746354 lambdaEndToken@var2092 .@expr1073746355 next (@expr1073746356 ) ; }
162:
163: } else { if (@expr1073746357 tok@var2087 .@expr1073746358 str (@expr1073746359 ) ==@expr1073746360 "{" &&@expr1073746361 tok@var2087 .@expr4538 scope (@expr4539 ) &&@expr1073746364 tok@var2087 .@expr4538 scope (@expr4539 ) .@expr1073746367 isClassOrStruct (@expr1073746368 ) ) {
164: if (@expr4458 out@var2090 ) {
165: *@expr4459 out@var2090 =@expr1073746371 tok@var2087 .@expr4495 link (@expr4496 ) ; }
166: } else {
167: if (@expr1073746374 f@var2088 (@expr1073746375 tok@var2087 ) ==@expr1073746376 Progress ::@expr4510 Break ) {
168: return Break (@expr4511 ) ; }
169: } } } } } } } } }
170: return Progress ::@expr1073746379 Continue ;
171: }
172:
173: template < class T , class F , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
174: Progress traverseRecursive ( T * tok@var2093 , F f@var2094 , bool traverseUnknown@var2095 , unsigned int recursion@var2096 = 0 ) {
175: if (@expr1073746380 !@expr1073746381 tok@var2093 ) {
176: return Progress ::@expr4558 Continue ; }
177: if (@expr1073746383 recursion@var2096 >@expr1073746384 10000 ) {
178: return Progress ::@expr1073746385 Skip ; }
179: T * firstOp@var2097 ; firstOp@var2097 =@expr1073746386 tok@var2093 .@expr1073746387 astOperand1 (@expr1073746388 ) ;
180: T * secondOp@var2098 ; secondOp@var2098 =@expr1073746389 tok@var2093 .@expr1073746390 astOperand2 (@expr1073746391 ) ;
181:
|
184:
185: if (@expr1073746392 tok@var2093 .@expr4569 isAssignmentOp (@expr4570 ) ||@expr1073746395 !@expr1073746396 secondOp@var2098 ||@expr1073746397 isFunctionCall (@expr1073746398 tok@var2093 ) ) {
186: std ::@expr1073746399 swap (@expr1073746400 firstOp@var2097 , secondOp@var2098 ) ; }
187: if (@expr1073746401 firstOp@var2097 &&@expr1073746402 traverseRecursive (@expr1073746403 firstOp@var2097 , f@var2094 , traverseUnknown@var2095 , recursion@var2096 +@expr4580 1 ) ==@expr1073746405 Progress ::@expr4582 Break ) {
188: return Break (@expr4583 ) ; }
189: Progress p@var2099 ; p@var2099 =@expr1073746408 tok@var2093 .@expr4569 isAssignmentOp (@expr4570 ) ?@expr1073746411 Progress ::@expr4558 Continue :@expr1073746413 traverseTok (@expr4590 tok@var2093 , f@var2094 , traverseUnknown@var2095 ) ;
190: if (@expr1073746415 p@var2099 ==@expr1073746416 Progress ::@expr4582 Break ) {
191: return Break (@expr4583 ) ; }
192: if (@expr1073746419 p@var2099 ==@expr1073746420 Progress ::@expr4558 Continue &&@expr1073746422 secondOp@var2098 &&@expr1073746423 traverseRecursive (@expr1073746424 secondOp@var2098 , f@var2094 , traverseUnknown@var2095 , recursion@var2096 +@expr4580 1 ) ==@expr1073746426 Progress ::@expr4582 Break ) {
193: return Break (@expr4583 ) ; }
194: if (@expr1073746429 tok@var2093 .@expr4569 isAssignmentOp (@expr4570 ) &&@expr1073746432 traverseTok (@expr4590 tok@var2093 , f@var2094 , traverseUnknown@var2095 ) ==@expr1073746434 Progress ::@expr4582 Break ) {
195: return Break (@expr4583 ) ; }
196: return Progress ::@expr4558 Continue ;
197: }
198:
199: template < class T , class F , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
200: Progress traverseConditional ( T * tok@var2100 , F f@var2101 , bool traverseUnknown@var2102 ) {
201: if (@expr1073746438 Token ::@expr1073746439 Match (@expr1073746440 tok@var2100 , "?|&&|%oror%" ) &&@expr1073746441 tok@var2100 .@expr4618 astOperand1 (@expr4619 ) &&@expr1073746444 tok@var2100 .@expr4621 astOperand2 (@expr4622 ) ) {
202: T * condTok@var2103 ; condTok@var2103 =@expr1073746447 tok@var2100 .@expr4618 astOperand1 (@expr4619 ) ;
203: T * childTok@var2104 ; childTok@var2104 =@expr1073746450 tok@var2100 .@expr4621 astOperand2 (@expr4622 ) ;
204: bool checkThen@var2105 ; bool checkElse@var2106 ;
205: std ::@expr1073746453 tie (@expr1073746454 checkThen@var2105 , checkElse@var2106 ) =@expr1073746455 evalCond (@expr1073746456 condTok@var2103 ) ;
206: if (@expr1073746457 !@expr4634 checkThen@var2105 &&@expr1073746459 !@expr4636 checkElse@var2106 ) {
207: if (@expr1073746461 !@expr1073746462 traverseUnknown@var2102 &&@expr1073746463 analyzer@var2058 .@expr1073746464 stopOnCondition (@expr1073746465 condTok@var2103 ) &&@expr1073746466 stopUpdates (@expr1073746467 ) ) {
208: return Progress ::@expr4644 Continue ;
209: }
210: checkThen@var2105 =@expr1073746469 true ;
211: checkElse@var2106 =@expr1073746470 true ;
212: }
213: if (@expr1073746471 childTok@var2104 .@expr1073746472 str (@expr1073746473 ) ==@expr1073746474 ":" ) {
214: if (@expr1073746475 checkThen@var2105 &&@expr1073746476 traverseRecursive (@expr1073746477 childTok@var2104 .@expr1073746478 astOperand1 (@expr1073746479 ) , f@var2101 , traverseUnknown@var2102 ) ==@expr1073746480 Progress ::@expr4657 Break ) {
215: return Break (@expr4658 ) ; }
216: if (@expr1073746483 checkElse@var2106 &&@expr1073746484 traverseRecursive (@expr1073746485 childTok@var2104 .@expr1073746486 astOperand2 (@expr1073746487 ) , f@var2101 , traverseUnknown@var2102 ) ==@expr1073746488 Progress ::@expr4657 Break ) {
217: return Break (@expr4658 ) ; }
218: } else {
219: if (@expr1073746491 !@expr4634 checkThen@var2105 &&@expr1073746493 tok@var2100 .@expr4670 str (@expr4671 ) ==@expr1073746496 "&&" ) {
220: return Progress ::@expr4644 Continue ; }
221: if (@expr1073746498 !@expr4636 checkElse@var2106 &&@expr1073746500 tok@var2100 .@expr4670 str (@expr4671 ) ==@expr1073746503 "||" ) {
222: return Progress ::@expr4644 Continue ; }
223: if (@expr1073746505 traverseRecursive (@expr1073746506 childTok@var2104 , f@var2101 , traverseUnknown@var2102 ) ==@expr1073746507 Progress ::@expr4657 Break ) {
224: return Break (@expr4658 ) ; }
225: }
226: }
227: return Progress ::@expr4644 Continue ;
228: }
229:
230: Progress update ( Token * tok@var2107 ) {
231: Analyzer ::@expr1073746511 Action action@var2108 ; action@var2108 =@expr1073746512 analyzer@var2058 .@expr1073746513 analyze (@expr1073746514 tok@var2107 , Analyzer ::@expr4691 Direction ::@expr4692 Forward ) ;
232: actions@var2060 |=@expr1073746517 action@var2108 ;
233: if (@expr1073746518 !@expr1073746519 action@var2108 .@expr1073746520 isNone (@expr1073746521 ) &&@expr1073746522 !@expr1073746523 analyzeOnly@var2061 ) {
234: analyzer@var2058 .@expr1073746524 update (@expr1073746525 tok@var2107 , action@var2108 , Analyzer ::@expr4691 Direction ::@expr4692 Forward ) ; }
235: if (@expr1073746528 action@var2108 .@expr1073746529 isInconclusive (@expr1073746530 ) &&@expr1073746531 !@expr1073746532 analyzer@var2058 .@expr1073746533 lowerToInconclusive (@expr1073746534 ) ) {
236: return Break (@expr1073746535 Analyzer ::@expr4712 Terminate ::@expr1073746537 Inconclusive ) ; }
237: if (@expr1073746538 action@var2108 .@expr1073746539 isInvalid (@expr1073746540 ) ) {
238: return Break (@expr4717 Analyzer ::@expr4712 Terminate ::@expr4719 Modified ) ; }
239: if (@expr1073746544 action@var2108 .@expr1073746545 isWrite (@expr1073746546 ) &&@expr1073746547 !@expr1073746548 action@var2108 .@expr1073746549 isRead (@expr1073746550 ) ) {
240:
241: return Break (@expr4717 Analyzer ::@expr4712 Terminate ::@expr4719 Modified ) ; }
242: return Progress ::@expr1073746554 Continue ;
243: }
244:
245: Progress updateTok ( Token * tok@var2109 , Token * * out@var2110 = nullptr ) {
246: auto f@var2111 ; f@var2111 =@expr1073746555 [@expr1073746556 this@expr1073746557 ] (@expr1073746558 Token *@expr1073746559 tok2@var2112 ) {
247: return update (@expr1073746560 tok2@var2112 ) ;
248: } ;
249: return traverseTok (@expr1073746561 tok@var2109 , f@var2111 , false , out@var2110 ) ;
250: }
251:
252: Progress updateRecursive ( Token * tok@var2113 ) {
253: forked@var2064 =@expr1073746562 false ;
254: auto f@var2114 ; f@var2114 =@expr1073746563 [@expr1073746564 this@expr1073746565 ] (@expr1073746566 Token *@expr1073746567 tok2@var2115 ) {
255: return update (@expr1073746568 tok2@var2115 ) ;
256: } ;
257: return traverseRecursive (@expr1073746569 tok@var2113 , f@var2114 , false ) ;
258: }
259:
260: template < class T , class F >
261: T * findRange ( T * start@var2116 , const Token * end@var2117 , F pred@var2118 ) {
262: for (@expr1073746570 T *@expr1073746571 tok@var2119 =@expr1073746572 start@var2116 ; tok@var2119 &&@expr1073746573 tok@var2119 !=@expr1073746574 end@var2117 ; tok@var2119 =@expr1073746575 tok@var2119 .@expr1073746576 next (@expr1073746577 ) ) {
263: Analyzer ::@expr1073746578 Action action@var2120 ; action@var2120 =@expr1073746579 analyzer@var2058 .@expr1073746580 analyze (@expr1073746581 tok@var2119 , Analyzer ::@expr1073746582 Direction ::@expr1073746583 Forward ) ;
264: if (@expr1073746584 pred@var2118 (@expr1073746585 action@var2120 ) ) {
265: return tok@var2119 ; }
266: }
267: return nullptr ;
268: }
269:
270: Analyzer :: Action analyzeRecursive ( const Token * start@var2121 ) {
271: Analyzer ::@expr1073746586 Action result@var2122 ; result@var2122 =@expr1073746587 Analyzer ::@expr1073746588 Action ::@expr1073746589 None ;
272: auto f@var2123 ; f@var2123 =@expr1073746590 [@expr1073746591 &@expr1073746592 ] (@expr1073746593 const Token *@expr1073746594 tok@var2124 ) {
273: result@var2122 =@expr1073746595 analyzer@var2058 .@expr1073746596 analyze (@expr1073746597 tok@var2124 , Analyzer ::@expr1073746598 Direction ::@expr1073746599 Forward ) ;
274: if (@expr1073746600 result@var2122 .@expr1073746601 isModified (@expr1073746602 ) ||@expr1073746603 result@var2122 .@expr1073746604 isInconclusive (@expr1073746605 ) ) {
275: return Break (@expr1073746606 ) ; }
276: return Progress ::@expr1073746607 Continue ;
277: } ;
278: traverseRecursive (@expr1073746608 start@var2121 , f@var2123 , true ) ;
279: return result@var2122 ;
280: }
281:
282: Analyzer :: Action analyzeRange ( const Token * start@var2125 , const Token * end@var2126 ) {
283: Analyzer ::@expr1073746609 Action result@var2127 ; result@var2127 =@expr1073746610 Analyzer ::@expr1073746611 Action ::@expr1073746612 None ;
284: for (@expr1073746613 const Token *@expr1073746614 tok@var2128 =@expr1073746615 start@var2125 ; tok@var2128 &&@expr1073746616 tok@var2128 !=@expr1073746617 end@var2126 ; tok@var2128 =@expr1073746618 tok@var2128 .@expr1073746619 next (@expr1073746620 ) ) {
285: Analyzer ::@expr1073746621 Action action@var2129 ; action@var2129 =@expr1073746622 analyzer@var2058 .@expr1073746623 analyze (@expr1073746624 tok@var2128 , Analyzer ::@expr1073746625 Direction ::@expr1073746626 Forward ) ;
286: if (@expr1073746627 action@var2129 .@expr1073746628 isModified (@expr1073746629 ) ||@expr1073746630 action@var2129 .@expr1073746631 isInconclusive (@expr1073746632 ) ) {
287: return action@var2129 ; }
288: result@var2127 |=@expr1073746633 action@var2129 ;
289: }
290: return result@var2127 ;
291: }
292:
293: ForwardTraversal fork ( bool analyze@var2130 = false ) const {
294: ForwardTraversal ft@var2131 ; ft@var2131 =@expr1073746634 *@expr1073746635 this@expr1073746636 ;
295: if (@expr1073746637 analyze@var2130 ) {
296: ft@var2131 .@expr1073746638 analyzeOnly@var2132 =@expr1073746639 true ;
297: ft@var2131 .@expr1073746640 analyzeTerminate@var2133 =@expr1073746641 true ;
298: }
299: ft@var2131 .@expr1073746642 actions@var2134 =@expr1073746643 Analyzer ::@expr1073746644 Action ::@expr1073746645 None ;
300: ft@var2131 .@expr1073746646 forked@var2135 =@expr1073746647 true ;
301: return ft@var2131 ;
302: }
303:
304: std :: vector < ForwardTraversal > tryForkScope ( Token * endBlock@var2136 , bool isModified@var2137 = false ) {
305: if (@expr1073746648 analyzer@var2058 .@expr1073746649 updateScope (@expr1073746650 endBlock@var2136 , isModified@var2137 ) ) {
306: ForwardTraversal ft@var2138 ; ft@var2138 =@expr1073746651 fork (@expr1073746652 ) ;
307: return {@expr1073746653 ft@var2138 } ;
308: }
309: return std ::@expr1073746654 vector < ForwardTraversal > {@expr1073746655 } ;
310: }
311:
312: std :: vector < ForwardTraversal > tryForkUpdateScope ( Token * endBlock@var2139 , bool isModified@var2140 = false ) {
313: std ::@expr1073746656 vector < ForwardTraversal > result@var2141 ; result@var2141 =@expr1073746657 tryForkScope (@expr1073746658 endBlock@var2139 , isModified@var2140 ) ;
314: for (@expr1073746659 ForwardTraversal &@expr1073746660 ft@var2142 :@expr1073746661 result@var2141 ) {
315: ft@var2142 .@expr1073746662 updateScope (@expr1073746663 endBlock@var2139 ) ; }
316: return result@var2141 ;
317: }
318:
319: static bool hasGoto ( const Token * endBlock@var2143 ) {
320: return Token ::@expr1073746664 findsimplematch (@expr1073746665 endBlock@var2143 .@expr1073746666 link (@expr1073746667 ) , "goto" , endBlock@var2143 ) ;
321: }
322:
323: static bool hasJump ( const Token * endBlock@var2144 ) {
324: return Token ::@expr1073746668 findmatch (@expr1073746669 endBlock@var2144 .@expr1073746670 link (@expr1073746671 ) , "goto|break" , endBlock@var2144 ) ;
325: }
326:
327: bool hasInnerReturnScope ( const Token * start@var2145 , const Token * end@var2146 ) const {
328: for (@expr1073746672 const Token *@expr1073746673 tok@var2147 =@expr1073746674 start@var2145 ; tok@var2147 !=@expr1073746675 end@var2146 ; tok@var2147 =@expr1073746676 tok@var2147 .@expr1073746677 previous (@expr1073746678 ) ) {
329: if (@expr1073746679 Token ::@expr1073746680 simpleMatch (@expr1073746681 tok@var2147 , "}" ) ) {
330: const Token * ftok@var2148 ; ftok@var2148 =@expr1073746682 nullptr ;
331: bool r@var2149 ; r@var2149 =@expr1073746683 isReturnScope (@expr1073746684 tok@var2147 , &@expr1073746685 settings@var2059 .@expr1073746686 library@var2091 , &@expr1073746687 ftok@var2148 ) ;
332: if (@expr1073746688 r@var2149 ) {
333: return true ; }
334: }
335: }
336: return false ;
337: }
338:
339: bool isEscapeScope ( const Token * endBlock@var2150 , bool & unknown@var2151 ) {
340: const Token * ftok@var2152 ; ftok@var2152 =@expr1073746689 nullptr ;
341: bool r@var2153 ; r@var2153 =@expr1073746690 isReturnScope (@expr1073746691 endBlock@var2150 , &@expr1073746692 settings@var2059 .@expr1073746693 library@var2091 , &@expr1073746694 ftok@var2152 ) ;
342: if (@expr1073746695 !@expr1073746696 r@var2153 &&@expr1073746697 ftok@var2152 ) {
343: unknown@var2151 =@expr1073746698 true ; }
344: return r@var2153 ;
345: }
346:
347: enum class Status {
348: None ,
349: Escaped ,
350: Modified ,
351: Inconclusive ,
352: } ;
353:
354: Analyzer :: Action analyzeScope ( const Token * endBlock@var2154 ) {
355: return analyzeRange (@expr1073746699 endBlock@var2154 .@expr1073746700 link (@expr1073746701 ) , endBlock@var2154 ) ;
356: }
357:
358: Analyzer :: Action checkScope ( Token * endBlock@var2155 ) {
359: Analyzer ::@expr1073746702 Action a@var2156 ; a@var2156 =@expr1073746703 analyzeScope (@expr1073746704 endBlock@var2155 ) ;
360: tryForkUpdateScope (@expr1073746705 endBlock@var2155 , a@var2156 .@expr1073746706 isModified (@expr1073746707 ) ) ;
361: return a@var2156 ;
362: }
363:
364: Analyzer :: Action checkScope ( const Token * endBlock@var2157 ) {
365: Analyzer ::@expr1073746708 Action a@var2158 ; a@var2158 =@expr1073746709 analyzeScope (@expr1073746710 endBlock@var2157 ) ;
366: return a@var2158 ;
367: }
368:
369: bool checkBranch ( Branch & branch@var2159 ) {
370: Analyzer ::@expr1073746711 Action a@var2160 ; a@var2160 =@expr1073746712 analyzeScope (@expr1073746713 branch@var2159 .@expr4890 endBlock@var2161 ) ;
371: branch@var2159 .@expr1073746715 action@var2162 =@expr1073746716 a@var2160 ;
372: std ::@expr1073746717 vector < ForwardTraversal > ft1@var2163 ; ft1@var2163 =@expr1073746718 tryForkUpdateScope (@expr1073746719 branch@var2159 .@expr4890 endBlock@var2161 , a@var2160 .@expr4897 isModified (@expr4898 ) ) ;
373: bool bail@var2164 ; bail@var2164 =@expr1073746723 hasGoto (@expr1073746724 branch@var2159 .@expr4890 endBlock@var2161 ) ;
374: if (@expr1073746726 !@expr1073746727 a@var2160 .@expr4897 isModified (@expr4898 ) &&@expr1073746730 !@expr1073746731 bail@var2164 ) {
375: if (@expr1073746732 ft1@var2163 .@expr1073746733 empty (@expr1073746734 ) ) {
376:
377: if (@expr1073746735 !@expr1073746736 branch@var2159 .@expr4913 escape@var2165 &&@expr1073746738 hasInnerReturnScope (@expr1073746739 branch@var2159 .@expr4890 endBlock@var2161 .@expr1073746741 previous (@expr1073746742 ) , branch@var2159 .@expr4890 endBlock@var2161 .@expr1073746744 link (@expr1073746745 ) ) ) {
378: ForwardTraversal ft2@var2166 ; ft2@var2166 =@expr1073746746 fork (@expr1073746747 true ) ;
379: ft2@var2166 .@expr1073746748 updateScope (@expr1073746749 branch@var2159 .@expr4890 endBlock@var2161 ) ;
380: if (@expr1073746751 ft2@var2166 .@expr1073746752 terminate@var2167 ==@expr1073746753 Analyzer ::@expr4930 Terminate ::@expr4931 Escape ) {
381: branch@var2159 .@expr4913 escape@var2165 =@expr1073746757 true ;
382: branch@var2159 .@expr4934 escapeUnknown@var2168 =@expr1073746759 false ;
383: }
384: }
385: } else {
386: if (@expr1073746760 ft1@var2163 .@expr1073746761 front (@expr1073746762 ) .@expr1073746763 terminate@var2340 ==@expr1073746764 Analyzer ::@expr4930 Terminate ::@expr4931 Escape ) {
387: branch@var2159 .@expr4913 escape@var2165 =@expr1073746768 true ;
388: branch@var2159 .@expr4934 escapeUnknown@var2168 =@expr1073746770 false ;
389: }
390: }
391: }
392: return bail@var2164 ;
393: }
394:
395: bool reentersLoop ( Token * endBlock@var2169 , const Token * condTok@var2170 , const Token * stepTok@var2171 ) {
396: if (@expr1073746771 !@expr1073746772 condTok@var2170 ) {
397: return true ; }
398: if (@expr1073746773 Token ::@expr1073746774 simpleMatch (@expr1073746775 condTok@var2170 , ":" ) ) {
399: return true ; }
400: bool changed@var2172 ; changed@var2172 =@expr1073746776 false ;
401: if (@expr1073746777 stepTok@var2171 ) {
402: std ::@expr1073746778 pair < const Token *@expr4955 , const Token *@expr4955 > exprToks@var2173 ; exprToks@var2173 =@expr1073746781 stepTok@var2171 .@expr1073746782 findExpressionStartEndTokens (@expr1073746783 ) ;
403: if (@expr1073746784 exprToks@var2173 .@expr4961 first@var2174 !=@expr1073746786 nullptr &&@expr1073746787 exprToks@var2173 .@expr4964 second@var2175 !=@expr1073746789 nullptr ) {
404: changed@var2172 |=@expr1073746790 isExpressionChanged (@expr1073746791 condTok@var2170 , exprToks@var2173 .@expr4961 first@var2174 , exprToks@var2173 .@expr4964 second@var2175 .@expr1073746794 next (@expr1073746795 ) , settings@var2059 , true ) ; }
405: }
406: changed@var2172 |=@expr1073746796 isExpressionChanged (@expr1073746797 condTok@var2170 , endBlock@var2169 .@expr1073746798 link (@expr1073746799 ) , endBlock@var2169 , settings@var2059 , true ) ;
407:
408: changed@var2172 |=@expr1073746800 nullptr !=@expr1073746801
409: findAstNode (@expr1073746802 condTok@var2170 , [@expr1073746803 &@expr1073746804 ] (@expr1073746805 const Token *@expr4955 tok@var2176 ) {
410: return isVariableChanged (@expr1073746807 tok@var2176 , 0 , settings@var2059 , true ) ;
411: } ) ;
412: if (@expr1073746808 !@expr1073746809 changed@var2172 ) {
413: return true ; }
414: ForwardTraversal ft@var2177 ; ft@var2177 =@expr1073746810 fork (@expr1073746811 true ) ;
415: ft@var2177 .@expr1073746812 analyzer@var2178 .@expr1073746813 assume (@expr1073746814 condTok@var2170 , false , Analyzer ::@expr1073746815 Assume ::@expr1073746816 Absolute ) ;
416: ft@var2177 .@expr1073746817 updateScope (@expr1073746818 endBlock@var2169 ) ;
417: return ft@var2177 .@expr1073746819 isConditionTrue (@expr1073746820 condTok@var2170 ) ;
418: }
419:
420: Progress updateInnerLoop ( Token * endBlock@var2179 , Token * stepTok@var2180 , Token * condTok@var2181 ) {
421: loopEnds@var2065 .@expr1073746821 push_back (@expr1073746822 endBlock@var2179 ) ;
422: OnExit oe@var2182 {@expr1073746823 [@expr1073746824 &@expr1073746825 ] {
423: loopEnds@var2065 .@expr1073746826 pop_back (@expr1073746827 ) ;
424: } } ;
425: if (@expr1073746828 endBlock@var2179 &&@expr1073746829 updateScope (@expr1073746830 endBlock@var2179 ) ==@expr1073746831 Progress ::@expr5008 Break ) {
426: return Break (@expr5009 ) ; }
427: if (@expr1073746834 stepTok@var2180 &&@expr1073746835 updateRecursive (@expr1073746836 stepTok@var2180 ) ==@expr1073746837 Progress ::@expr5008 Break ) {
428: return Break (@expr5009 ) ; }
429: if (@expr1073746840 condTok@var2181 &&@expr1073746841 updateRecursive (@expr1073746842 condTok@var2181 ) ==@expr1073746843 Progress ::@expr5008 Break ) {
430: return Break (@expr5009 ) ; }
431: return Progress ::@expr1073746846 Continue ;
432: }
433:
434: Progress updateLoop ( const Token * endToken@var2183 ,
435: Token * endBlock@var2184 ,
436: Token * condTok@var2185 ,
437: Token * initTok@var2186 = nullptr ,
438: Token * stepTok@var2187 = nullptr ,
439: bool exit@var2188 = false ) {
440: if (@expr1073746847 initTok@var2186 &&@expr1073746848 updateRecursive (@expr1073746849 initTok@var2186 ) ==@expr1073746850 Progress ::@expr5027 Break ) {
441: return Break (@expr5028 ) ; }
442: const bool isDoWhile@var2189 =@expr1073746853 precedes (@expr1073746854 endBlock@var2184 , condTok@var2185 ) ;
443: bool checkThen@var2190 ; checkThen@var2190 =@expr1073746855 true ;
444: bool checkElse@var2191 ; checkElse@var2191 =@expr1073746856 false ;
445: if (@expr5033 condTok@var2185 &&@expr5034 !@expr5035 Token ::@expr5036 simpleMatch (@expr5037 condTok@var2185 , ":" ) ) {
446: std ::@expr1073746862 tie (@expr1073746863 checkThen@var2190 , checkElse@var2191 ) =@expr1073746864 evalCond (@expr1073746865 condTok@var2185 , isDoWhile@var2189 ?@expr1073746866 endBlock@var2184 .@expr1073746867 previous (@expr1073746868 ) :@expr1073746869 nullptr ) ; }
447:
448: if (@expr1073746870 checkElse@var2191 &&@expr1073746871 exit@var2188 ) {
449: if (@expr1073746872 hasJump (@expr1073746873 endBlock@var2184 ) ) {
450: if (@expr5050 !@expr5051 analyzer@var2058 .@expr5052 lowerToPossible (@expr5053 ) ) {
451: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
452: if (@expr5057 analyzer@var2058 .@expr5058 isConditional (@expr5059 ) &&@expr5060 stopUpdates (@expr5061 ) ) {
453: return Break (@expr5062 Analyzer ::@expr5055 Terminate ::@expr5064 Conditional ) ; }
454: }
455: return Progress ::@expr5065 Continue ;
456: }
457: Analyzer ::@expr1073746890 Action bodyAnalysis@var2192 ; bodyAnalysis@var2192 =@expr1073746891 analyzeScope (@expr1073746892 endBlock@var2184 ) ;
458: Analyzer ::@expr1073746893 Action allAnalysis@var2193 ; allAnalysis@var2193 =@expr1073746894 bodyAnalysis@var2192 ;
459: Analyzer ::@expr1073746895 Action condAnalysis@var2194 ;
460: if (@expr5072 condTok@var2185 ) {
461: condAnalysis@var2194 =@expr1073746897 analyzeRecursive (@expr1073746898 condTok@var2185 ) ;
462: allAnalysis@var2193 |=@expr1073746899 condAnalysis@var2194 ;
463: }
464: if (@expr1073746900 stepTok@var2187 ) {
465: allAnalysis@var2193 |=@expr1073746901 analyzeRecursive (@expr1073746902 stepTok@var2187 ) ; }
466: actions@var2060 |=@expr1073746903 allAnalysis@var2193 ;
467:
468: if (@expr1073746904 checkElse@var2191 &&@expr1073746905 isDoWhile@var2189 &&@expr1073746906
469: (@expr1073746907 condTok@var2185 .@expr1073746908 hasKnownIntValue (@expr1073746909 ) ||@expr1073746910
470: (@expr1073746911 !@expr5088 bodyAnalysis@var2192 .@expr5089 isModified (@expr5090 ) &&@expr1073746915 !@expr1073746916 condAnalysis@var2194 .@expr1073746917 isModified (@expr1073746918 ) &&@expr1073746919 condAnalysis@var2194 .@expr1073746920 isRead (@expr1073746921 ) ) ) ) {
471: if (@expr1073746922 updateRange (@expr1073746923 endBlock@var2184 .@expr1073746924 link (@expr1073746925 ) , endBlock@var2184 ) ==@expr1073746926 Progress ::@expr5027 Break ) {
472: return Break (@expr5028 ) ; }
473: return updateRecursive (@expr5105 condTok@var2185 ) ;
474: }
475: if (@expr1073746930 allAnalysis@var2193 .@expr1073746931 isInconclusive (@expr1073746932 ) ) {
476: if (@expr1073746933 !@expr1073746934 analyzer@var2058 .@expr1073746935 lowerToInconclusive (@expr1073746936 ) ) {
477: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
478: } else { if (@expr1073746940 allAnalysis@var2193 .@expr5117 isModified (@expr5118 ) ||@expr1073746943 (@expr1073746944 exit@var2188 &&@expr1073746945 allAnalysis@var2193 .@expr1073746946 isIdempotent (@expr1073746947 ) ) ) {
479: if (@expr5050 !@expr5051 analyzer@var2058 .@expr5052 lowerToPossible (@expr5053 ) ) {
480: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
481: } }
482:
483: if (@expr5033 condTok@var2185 &&@expr5034 !@expr5035 Token ::@expr5036 simpleMatch (@expr5037 condTok@var2185 , ":" ) ) {
484: if (@expr1073746960 !@expr5137 isDoWhile@var2189 ||@expr1073746962 (@expr1073746963 !@expr5088 bodyAnalysis@var2192 .@expr5089 isModified (@expr5090 ) &&@expr1073746967 !@expr1073746968 bodyAnalysis@var2192 .@expr1073746969 isIdempotent (@expr1073746970 ) ) ) {
485: if (@expr1073746971 updateRecursive (@expr5105 condTok@var2185 ) ==@expr1073746973 Progress ::@expr5027 Break ) {
486: return Break (@expr5028 ) ; } }
487: }
488: if (@expr1073746976 !@expr1073746977 checkThen@var2190 &&@expr1073746978 !@expr1073746979 checkElse@var2191 &&@expr1073746980 !@expr5137 isDoWhile@var2189 &&@expr1073746982 analyzer@var2058 .@expr1073746983 stopOnCondition (@expr1073746984 condTok@var2185 ) &&@expr1073746985 stopUpdates (@expr5061 ) ) {
489: return Break (@expr5062 Analyzer ::@expr5055 Terminate ::@expr5064 Conditional ) ; }
490:
491: if (@expr1073746990 checkElse@var2191 ) {
492: return Progress ::@expr5065 Continue ; }
493: if (@expr1073746992 checkThen@var2190 ||@expr1073746993 isDoWhile@var2189 ) {
494:
495: if (@expr1073746994 exit@var2188 ) {
496: analyzer@var2058 .@expr5171 assume (@expr1073746996 condTok@var2185 , true , Analyzer ::@expr5173 Assume ::@expr5174 Quiet |@expr1073746999 Analyzer ::@expr5173 Assume ::@expr1073747001 Absolute ) ; }
497: if (@expr5178 updateInnerLoop (@expr5179 endBlock@var2184 , stepTok@var2187 , condTok@var2185 ) ==@expr5180 Progress ::@expr5027 Break ) {
498: return Break (@expr5028 ) ; }
499:
500: if (@expr1073747007 allAnalysis@var2193 .@expr5117 isModified (@expr5118 ) &&@expr1073747010 reentersLoop (@expr1073747011 endBlock@var2184 , condTok@var2185 , stepTok@var2187 ) ) {
501: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
502: if (@expr5191 allAnalysis@var2193 .@expr5192 isIncremental (@expr5193 ) ) {
503: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
504: } else { if (@expr1073747021 allAnalysis@var2193 .@expr5117 isModified (@expr5118 ) ) {
505: std ::@expr1073747024 vector < ForwardTraversal > ftv@var2195 ; ftv@var2195 =@expr1073747025 tryForkScope (@expr1073747026 endBlock@var2184 , allAnalysis@var2193 .@expr5117 isModified (@expr5118 ) ) ;
506: bool forkContinue@var2196 ; forkContinue@var2196 =@expr1073747029 true ;
507: for (@expr1073747030 ForwardTraversal &@expr5207 ft@var2197 :@expr1073747032 ftv@var2195 ) {
508: if (@expr5072 condTok@var2185 ) {
509: ft@var2197 .@expr1073747034 analyzer@var2198 .@expr1073747035 assume (@expr1073747036 condTok@var2185 , false , Analyzer ::@expr5173 Assume ::@expr5174 Quiet ) ; }
510: if (@expr1073747039 ft@var2197 .@expr1073747040 updateInnerLoop (@expr1073747041 endBlock@var2184 , stepTok@var2187 , condTok@var2185 ) ==@expr1073747042 Progress ::@expr5027 Break ) {
511: forkContinue@var2196 =@expr1073747044 false ; }
512: }
513:
514: if (@expr1073747045 allAnalysis@var2193 .@expr5117 isModified (@expr5118 ) ||@expr1073747048 !@expr1073747049 forkContinue@var2196 ) {
515:
516: if (@expr1073747050 !@expr1073747051 condTok@var2185 ) {
517: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
518: if (@expr5057 analyzer@var2058 .@expr5058 isConditional (@expr5059 ) &&@expr5060 stopUpdates (@expr5061 ) ) {
519: return Break (@expr5062 Analyzer ::@expr5055 Terminate ::@expr5064 Conditional ) ; }
520: analyzer@var2058 .@expr5171 assume (@expr1073747064 condTok@var2185 , false ) ;
521: }
522: if (@expr1073747065 forkContinue@var2196 ) {
523: for (@expr1073747066 ForwardTraversal &@expr5207 ft@var2199 :@expr1073747068 ftv@var2195 ) {
524: if (@expr1073747069 !@expr1073747070 ft@var2199 .@expr1073747071 actions@var2200 .@expr1073747072 isIncremental (@expr1073747073 ) ) {
525: ft@var2199 .@expr1073747074 updateRange (@expr1073747075 endBlock@var2184 , endToken@var2183 ) ; }
526: }
527: }
528: if (@expr5191 allAnalysis@var2193 .@expr5192 isIncremental (@expr5193 ) ) {
529: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
530: } else {
531: if (@expr5178 updateInnerLoop (@expr5179 endBlock@var2184 , stepTok@var2187 , condTok@var2185 ) ==@expr5180 Progress ::@expr5027 Break ) {
532: return Progress ::@expr5027 Break ; }
533: if (@expr5191 allAnalysis@var2193 .@expr5192 isIncremental (@expr5193 ) ) {
534: return Break (@expr5054 Analyzer ::@expr5055 Terminate ::@expr5056 Bail ) ; }
535: } }
536: return Progress ::@expr5065 Continue ;
537: }
538:
539: Progress updateLoopExit ( const Token * endToken@var2201 ,
540: Token * endBlock@var2202 ,
541: Token * condTok@var2203 ,
542: Token * initTok@var2204 = nullptr ,
543: Token * stepTok@var2205 = nullptr ) {
544: return updateLoop (@expr1073747094 endToken@var2201 , endBlock@var2202 , condTok@var2203 , initTok@var2204 , stepTok@var2205 , true ) ;
545: }
546:
547: Progress updateScope ( Token * endBlock@var2206 ) {
548: if (@expr1073747095 forked@var2064 ) {
549: analyzer@var2058 .@expr1073747096 forkScope (@expr1073747097 endBlock@var2206 ) ; }
550: return updateRange (@expr1073747098 endBlock@var2206 .@expr1073747099 link (@expr1073747100 ) , endBlock@var2206 ) ;
551: }
552:
553: Progress updateRange ( Token * start@var2207 , const Token * end@var2208 , int depth@var2209 = 20 ) {
554: forked@var2064 =@expr1073747102 false ;
555: if (@expr1073747103 depth@var2209 <@expr1073747104 0 ) {
556: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
557: unsigned long i@var2210 ; i@var2210 =@expr1073747108 0 ;
558: for (@expr1073747109 Token *@expr5286 tok@var2211 =@expr1073747111 start@var2207 ; precedes (@expr1073747112 tok@var2211 , end@var2208 ) ; tok@var2211 =@expr1073747113 tok@var2211 .@expr5290 next (@expr5291 ) ) {
559: Token * next@var2212 ; next@var2212 =@expr1073747116 nullptr ;
560: if (@expr1073747117 tok@var2211 .@expr5294 index (@expr5295 ) <=@expr1073747120 i@var2210 ) {
561: throw InternalError (@expr1073747121 tok@var2211 , "Cyclic forward analysis." ) ; }
562: i@var2210 =@expr1073747122 tok@var2211 .@expr5294 index (@expr5295 ) ;
563:
564: if (@expr1073747125 tok@var2211 .@expr5302 link (@expr5303 ) ) {
565:
566: if (@expr1073747128 tok@var2211 .@expr5305 str (@expr5306 ) ==@expr1073747131 "(" &&@expr1073747132 !@expr1073747133 tok@var2211 .@expr1073747134 astOperand2 (@expr1073747135 ) &&@expr1073747136 tok@var2211 .@expr1073747137 isCast (@expr1073747138 ) ) {
567: tok@var2211 =@expr1073747139 tok@var2211 .@expr5302 link (@expr5303 ) ;
568: continue ;
569: }
570:
571: if (@expr1073747142 tok@var2211 .@expr5305 str (@expr5306 ) ==@expr1073747145 "<" ) {
572: tok@var2211 =@expr1073747146 tok@var2211 .@expr5302 link (@expr5303 ) ;
573: continue ;
574: }
575: }
576:
577:
578: if (@expr1073747149 Token *@expr5286 assignTok@var2213 =@expr1073747151 assignExpr (@expr1073747152 tok@var2211 ) ) {
579: if (@expr1073747153 updateRecursive (@expr1073747154 assignTok@var2213 ) ==@expr1073747155 Progress ::@expr5332 Break ) {
580: return Break (@expr5333 ) ; }
581: tok@var2211 =@expr1073747158 nextAfterAstRightmostLeaf (@expr1073747159 assignTok@var2213 ) ;
582: if (@expr5336 !@expr5337 tok@var2211 ) {
583: return Break (@expr5333 ) ; }
584: } else { if (@expr1073747163 tok@var2211 .@expr5305 str (@expr5306 ) ==@expr1073747166 "break" ) {
585: const Token * scopeEndToken@var2214 ; scopeEndToken@var2214 =@expr1073747167 findNextTokenFromBreak (@expr1073747168 tok@var2211 ) ;
586: if (@expr1073747169 !@expr1073747170 scopeEndToken@var2214 ) {
587: return Break (@expr5333 ) ; }
588: tok@var2211 =@expr1073747172 skipTo (@expr1073747173 tok@var2211 , scopeEndToken@var2214 , end@var2208 ) ;
589: if (@expr5350 !@expr5351 analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ) {
590: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
591:
592: if (@expr5336 !@expr5337 tok@var2211 ) {
593: return Break (@expr5333 ) ; }
594: } else { if (@expr1073747184 Token ::@expr5361 Match (@expr1073747186 tok@var2211 , "%name% :" ) ||@expr1073747187 tok@var2211 .@expr5305 str (@expr5306 ) ==@expr1073747190 "case" ) {
595: if (@expr5350 !@expr5351 analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ) {
596: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
597: } else { if (@expr1073747198 tok@var2211 .@expr5302 link (@expr5303 ) &&@expr1073747201 tok@var2211 .@expr5305 str (@expr5306 ) ==@expr1073747204 "}" ) {
598: const Scope * scope@var2215 ; scope@var2215 =@expr1073747205 tok@var2211 .@expr1073747206 scope (@expr1073747207 ) ;
599: if (@expr1073747208 !@expr1073747209 scope@var2215 ) {
600: return Break (@expr5333 ) ; }
601: if (@expr1073747211 Token ::@expr5361 Match (@expr1073747213 tok@var2211 .@expr5302 link (@expr5303 ) .@expr5392 previous (@expr5393 ) , ")|else {" ) ) {
602: const Token * tok2@var2216 ; tok2@var2216 =@expr1073747218 tok@var2211 .@expr5302 link (@expr5303 ) .@expr5392 previous (@expr5393 ) ;
603: const bool inElse@var2217 =@expr1073747223 Token ::@expr5400 simpleMatch (@expr1073747225 tok2@var2216 , "else {" ) ;
604: const bool inLoop@var2218 =@expr1073747226 inElse@var2217 ?@expr1073747227 false :@expr1073747228 Token ::@expr5361 Match (@expr1073747230 tok2@var2216 .@expr1073747231 link (@expr1073747232 ) .@expr1073747233 previous (@expr1073747234 ) , "while|for (" ) ;
605: Token * condTok@var2219 ; condTok@var2219 =@expr1073747235 getCondTokFromEnd (@expr1073747236 tok@var2211 ) ;
606: if (@expr1073747237 !@expr1073747238 condTok@var2219 ) {
607: return Break (@expr5333 ) ; }
608: if (@expr1073747240 !@expr1073747241 condTok@var2219 .@expr1073747242 hasKnownIntValue (@expr1073747243 ) ||@expr1073747244 inLoop@var2218 ) {
609: if (@expr5350 !@expr5351 analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ) {
610: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
611: } else { if (@expr1073747252 condTok@var2219 .@expr1073747253 values (@expr1073747254 ) .@expr1073747255 front (@expr1073747256 ) .@expr1073747257 intvalue@expr1073747101 ==@expr1073747258 inElse@var2217 ) {
612: return Break (@expr5333 ) ;
613: } }
614:
615: Token * stepTok@var2220 ; stepTok@var2220 =@expr1073747260 getStepTokFromEnd (@expr1073747261 tok@var2211 ) ;
616: bool checkThen@var2221 ; bool checkElse@var2222 ;
617: std ::@expr5438 tie (@expr1073747263 checkThen@var2221 , checkElse@var2222 ) =@expr1073747264 evalCond (@expr1073747265 condTok@var2219 ) ;
618: if (@expr1073747266 stepTok@var2220 &&@expr1073747267 !@expr1073747268 checkElse@var2222 ) {
619: if (@expr1073747269 updateRecursive (@expr1073747270 stepTok@var2220 ) ==@expr1073747271 Progress ::@expr5332 Break ) {
620: return Break (@expr5333 ) ; }
621: if (@expr1073747274 updateRecursive (@expr1073747275 condTok@var2219 ) ==@expr1073747276 Progress ::@expr5332 Break ) {
622: return Break (@expr5333 ) ; }
623: }
624: analyzer@var2058 .@expr5455 assume (@expr1073747280 condTok@var2219 , !@expr1073747281 inElse@var2217 , Analyzer ::@expr5458 Assume ::@expr5459 Quiet ) ;
625: if (@expr1073747284 Token ::@expr5400 simpleMatch (@expr1073747286 tok@var2211 , "} else {" ) ) {
626: tok@var2211 =@expr1073747287 tok@var2211 .@expr5464 linkAt (@expr5465 2 ) ; }
627: } else { if (@expr1073747290 scope@var2215 .@expr5467 type@var2223 ==@expr1073747292 Scope ::@expr1073747293 eTry ) {
628: if (@expr5350 !@expr5351 analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ) {
629: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
630: } else { if (@expr1073747301 scope@var2215 .@expr5467 type@var2223 ==@expr1073747303 Scope ::@expr1073747304 eLambda ) {
631: return Break (@expr5333 ) ;
632: } else { if (@expr1073747306 scope@var2215 .@expr5467 type@var2223 ==@expr1073747308 Scope ::@expr1073747309 eDo &&@expr1073747310 Token ::@expr5400 simpleMatch (@expr1073747312 tok@var2211 , "} while (" ) ) {
633: if (@expr1073747313 updateLoopExit (@expr1073747314 end@var2208 , tok@var2211 , tok@var2211 .@expr1073747315 tokAt (@expr1073747316 2 ) .@expr1073747317 astOperand2 (@expr1073747318 ) ) ==@expr1073747319 Progress ::@expr5332 Break ) {
634: return Break (@expr5333 ) ; }
635: tok@var2211 =@expr1073747322 tok@var2211 .@expr5464 linkAt (@expr5465 2 ) ;
636: } else { if (@expr1073747325 Token ::@expr5400 simpleMatch (@expr1073747327 tok@var2211 .@expr5290 next (@expr5291 ) , "else {" ) ) {
637: tok@var2211 =@expr1073747330 tok@var2211 .@expr5464 linkAt (@expr5465 2 ) ;
638: } } } } }
639: } else { if (@expr1073747333 tok@var2211 .@expr1073747334 isControlFlowKeyword (@expr1073747335 ) &&@expr1073747336 Token ::@expr5361 Match (@expr1073747338 tok@var2211 , "if|while|for (" ) &&@expr1073747339 Token ::@expr5400 simpleMatch (@expr1073747341 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5520 link (@expr5521 ) , ") {" ) ) {
640: Token * endCond@var2224 ; endCond@var2224 =@expr1073747346 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5520 link (@expr5521 ) ;
641: Token * endBlock@var2225 ; endBlock@var2225 =@expr1073747351 endCond@var2224 .@expr5528 next (@expr5529 ) .@expr1073747354 link (@expr1073747355 ) ;
642: Token * condTok@var2226 ; condTok@var2226 =@expr1073747356 getCondTok (@expr1073747357 tok@var2211 ) ;
643: Token * initTok@var2227 ; initTok@var2227 =@expr1073747358 getInitTok (@expr1073747359 tok@var2211 ) ;
644: if (@expr1073747360 initTok@var2227 &&@expr1073747361 updateRecursive (@expr1073747362 initTok@var2227 ) ==@expr1073747363 Progress ::@expr5332 Break ) {
645: return Break (@expr5333 ) ; }
646: if (@expr1073747366 Token ::@expr5361 Match (@expr1073747368 tok@var2211 , "for|while (" ) ) {
647:
648: if (@expr1073747369 Token ::@expr5400 simpleMatch (@expr1073747371 condTok@var2226 , ":" ) ) {
649: Token * conTok@var2228 ; conTok@var2228 =@expr1073747372 condTok@var2226 .@expr1073747373 astOperand2 (@expr1073747374 ) ;
650: if (@expr1073747375 conTok@var2228 &&@expr1073747376 updateRecursive (@expr1073747377 conTok@var2228 ) ==@expr1073747378 Progress ::@expr5332 Break ) {
651: return Break (@expr5333 ) ; }
652: bool isEmpty@var2229 ; isEmpty@var2229 =@expr1073747381 false ;
653: std ::@expr1073747382 vector < long long > result@var2230 ; result@var2230 =@expr1073747383
654: analyzer@var2058 .@expr1073747384 evaluate (@expr1073747385 Analyzer ::@expr1073747386 Evaluate ::@expr1073747387 ContainerEmpty , conTok@var2228 ) ;
655: if (@expr1073747388 result@var2230 .@expr1073747389 empty (@expr1073747390 ) ) {
656: analyzer@var2058 .@expr5455 assume (@expr1073747392 conTok@var2228 , false , Analyzer ::@expr5458 Assume ::@expr1073747394 ContainerEmpty ) ; }
657: else {
658: isEmpty@var2229 =@expr1073747395 result@var2230 .@expr1073747396 front (@expr1073747397 ) !=@expr1073747398 0 ; }
659: if (@expr1073747399 !@expr1073747400 isEmpty@var2229 &&@expr1073747401 updateLoop (@expr1073747402 end@var2208 , endBlock@var2225 , condTok@var2226 ) ==@expr1073747403 Progress ::@expr5332 Break ) {
660: return Break (@expr5333 ) ; }
661: } else {
662: Token * stepTok@var2231 ; stepTok@var2231 =@expr1073747406 getStepTok (@expr1073747407 tok@var2211 ) ;
663: if (@expr1073747408 updateLoop (@expr1073747409 end@var2208 , endBlock@var2225 , condTok@var2226 , initTok@var2227 , stepTok@var2231 ) ==@expr1073747410 Progress ::@expr5332 Break ) {
664: return Break (@expr5333 ) ; }
665: }
666: tok@var2211 =@expr1073747413 endBlock@var2225 ;
667: } else {
668:
669: if (@expr1073747414 updateRecursive (@expr1073747415 condTok@var2226 ) ==@expr1073747416 Progress ::@expr5332 Break ) {
670: return Break (@expr5333 ) ; }
671: Branch thenBranch@var2232 {@expr1073747419 endBlock@var2225 } ;
672: Branch elseBranch@var2233 {@expr1073747420 endBlock@var2225 .@expr5597 tokAt (@expr5598 2 ) ?@expr1073747423 endBlock@var2225 .@expr5600 linkAt (@expr5601 2 ) :@expr1073747426 nullptr } ;
673:
674: std ::@expr5438 tie (@expr1073747428 thenBranch@var2232 .@expr5605 check@var2234 , elseBranch@var2233 .@expr5606 check@var2235 ) =@expr1073747431 evalCond (@expr1073747432 condTok@var2226 ) ;
675: if (@expr1073747433 !@expr5610 thenBranch@var2232 .@expr5605 check@var2234 &&@expr1073747436 !@expr5613 elseBranch@var2233 .@expr5606 check@var2235 &&@expr1073747439 analyzer@var2058 .@expr1073747440 stopOnCondition (@expr1073747441 condTok@var2226 ) &&@expr1073747442 stopUpdates (@expr5619 ) ) {
676: return Break (@expr5620 Analyzer ::@expr5282 Terminate ::@expr5622 Conditional ) ; }
677: bool hasElse@var2236 ; hasElse@var2236 =@expr1073747447 Token ::@expr5400 simpleMatch (@expr1073747449 endBlock@var2225 , "} else {" ) ;
678: bool bail@var2237 ; bail@var2237 =@expr1073747450 false ;
679:
680:
681: thenBranch@var2232 .@expr1073747451 escape@var2238 =@expr1073747452 isEscapeScope (@expr1073747453 endBlock@var2225 , thenBranch@var2232 .@expr1073747454 escapeUnknown@var2239 ) ;
682: if (@expr5631 thenBranch@var2232 .@expr5605 check@var2234 ) {
683: thenBranch@var2232 .@expr5633 active@var2240 =@expr1073747458 true ;
684: if (@expr1073747459 updateRange (@expr1073747460 endCond@var2224 .@expr5528 next (@expr5529 ) , endBlock@var2225 , depth@var2209 -@expr5639 1 ) ==@expr1073747464 Progress ::@expr5332 Break ) {
685: return Break (@expr5333 ) ; }
686: } else { if (@expr1073747467 !@expr5613 elseBranch@var2233 .@expr5606 check@var2235 ) {
687: thenBranch@var2232 .@expr5633 active@var2240 =@expr1073747471 true ;
688: if (@expr1073747472 checkBranch (@expr1073747473 thenBranch@var2232 ) ) {
689: bail@var2237 =@expr1073747474 true ; }
690: } }
691:
692: if (@expr1073747475 hasElse@var2236 ) {
693: elseBranch@var2233 .@expr1073747476 escape@var2241 =@expr1073747477 isEscapeScope (@expr1073747478 endBlock@var2225 .@expr5600 linkAt (@expr5601 2 ) , elseBranch@var2233 .@expr1073747481 escapeUnknown@var2242 ) ;
694: if (@expr1073747482 elseBranch@var2233 .@expr5606 check@var2235 ) {
695: elseBranch@var2233 .@expr5660 active@var2243 =@expr1073747485 true ;
696: Progress result@var2244 ; result@var2244 =@expr1073747486 updateRange (@expr1073747487 endBlock@var2225 .@expr5597 tokAt (@expr5598 2 ) , endBlock@var2225 .@expr5600 linkAt (@expr5601 2 ) , depth@var2209 -@expr5639 1 ) ;
697: if (@expr1073747493 result@var2244 ==@expr1073747494 Progress ::@expr5332 Break ) {
698: return Break (@expr5333 ) ; }
699: } else { if (@expr1073747497 !@expr5610 thenBranch@var2232 .@expr5605 check@var2234 ) {
700: elseBranch@var2233 .@expr5660 active@var2243 =@expr1073747501 true ;
701: if (@expr1073747502 checkBranch (@expr1073747503 elseBranch@var2233 ) ) {
702: bail@var2237 =@expr1073747504 true ; }
703: } }
704: tok@var2211 =@expr1073747505 endBlock@var2225 .@expr5600 linkAt (@expr5601 2 ) ;
705: } else {
706: tok@var2211 =@expr1073747508 endBlock@var2225 ;
707: }
708: if (@expr1073747509 thenBranch@var2232 .@expr5633 active@var2240 ) {
709: actions@var2060 |=@expr1073747511 thenBranch@var2232 .@expr1073747512 action@var2245 ; }
710: if (@expr1073747513 elseBranch@var2233 .@expr5660 active@var2243 ) {
711: actions@var2060 |=@expr1073747515 elseBranch@var2233 .@expr1073747516 action@var2246 ; }
712: if (@expr1073747517 bail@var2237 ) {
713: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
714: if (@expr1073747521 thenBranch@var2232 .@expr1073747522 isDead (@expr1073747523 ) &&@expr1073747524 elseBranch@var2233 .@expr1073747525 isDead (@expr1073747526 ) ) {
715: if (@expr1073747527 thenBranch@var2232 .@expr5704 isModified (@expr5705 ) &&@expr1073747530 elseBranch@var2233 .@expr5707 isModified (@expr5708 ) ) {
716: return Break (@expr1073747533 Analyzer ::@expr5282 Terminate ::@expr1073747535 Modified ) ; }
717: if (@expr1073747536 thenBranch@var2232 .@expr5713 isConclusiveEscape (@expr5714 ) &&@expr1073747539 elseBranch@var2233 .@expr1073747540 isConclusiveEscape (@expr1073747541 ) ) {
718: return Break (@expr1073747542 Analyzer ::@expr5282 Terminate ::@expr1073747544 Escape ) ; }
719: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ;
720: }
721:
722: if (@expr1073747548 thenBranch@var2232 .@expr5633 active@var2240 &&@expr1073747550 thenBranch@var2232 .@expr1073747551 isEscape (@expr1073747552 ) &&@expr1073747553 !@expr5730 hasElse@var2236 ) {
723: if (@expr1073747555 !@expr1073747556 thenBranch@var2232 .@expr5713 isConclusiveEscape (@expr5714 ) ) {
724: if (@expr5735 !@expr5736 analyzer@var2058 .@expr5737 lowerToInconclusive (@expr5738 ) ) {
725: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
726: } else { if (@expr5631 thenBranch@var2232 .@expr5605 check@var2234 ) {
727: return Break (@expr5333 ) ;
728: } else {
729: if (@expr1073747569 analyzer@var2058 .@expr5746 isConditional (@expr5747 ) &&@expr1073747572 stopUpdates (@expr5619 ) ) {
730: return Break (@expr5620 Analyzer ::@expr5282 Terminate ::@expr5622 Conditional ) ; }
731: analyzer@var2058 .@expr5455 assume (@expr1073747578 condTok@var2226 , false ) ;
732: } }
733: }
734: if (@expr1073747579 thenBranch@var2232 .@expr1073747580 isInconclusive (@expr1073747581 ) ||@expr1073747582 elseBranch@var2233 .@expr1073747583 isInconclusive (@expr1073747584 ) ) {
735: if (@expr5735 !@expr5736 analyzer@var2058 .@expr5737 lowerToInconclusive (@expr5738 ) ) {
736: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
737: } else { if (@expr1073747592 thenBranch@var2232 .@expr5704 isModified (@expr5705 ) ||@expr1073747595 elseBranch@var2233 .@expr5707 isModified (@expr5708 ) ) {
738: if (@expr1073747598 !@expr5730 hasElse@var2236 &&@expr1073747600 analyzer@var2058 .@expr5746 isConditional (@expr5747 ) &&@expr1073747603 stopUpdates (@expr5619 ) ) {
739: return Break (@expr5620 Analyzer ::@expr5282 Terminate ::@expr5622 Conditional ) ; }
740: if (@expr5350 !@expr5351 analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ) {
741: return Break (@expr5281 Analyzer ::@expr5282 Terminate ::@expr5283 Bail ) ; }
742: analyzer@var2058 .@expr5455 assume (@expr1073747616 condTok@var2226 , elseBranch@var2233 .@expr5707 isModified (@expr5708 ) ) ;
743: } }
744: }
745: } else { if (@expr1073747619 Token ::@expr5400 simpleMatch (@expr1073747621 tok@var2211 , "try {" ) ) {
746: Token * endBlock@var2247 ; endBlock@var2247 =@expr1073747622 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5520 link (@expr5521 ) ;
747: ForwardTraversal tryTraversal@var2248 ; tryTraversal@var2248 =@expr1073747627 fork (@expr5804 ) ;
748: tryTraversal@var2248 .@expr1073747629 updateRange (@expr1073747630 tok@var2211 .@expr5290 next (@expr5291 ) , endBlock@var2247 , depth@var2209 -@expr5639 1 ) ;
749: bool bail@var2249 ; bail@var2249 =@expr1073747634 tryTraversal@var2248 .@expr1073747635 actions@var2250 .@expr1073747636 isModified (@expr1073747637 ) ;
750: if (@expr5814 bail@var2249 ) {
751: analyzer@var2058 .@expr5352 lowerToPossible (@expr5353 ) ; }
752:
753: while (@expr1073747641 Token ::@expr5400 simpleMatch (@expr1073747643 endBlock@var2247 , "} catch (" ) ) {
754: Token * endCatch@var2251 ; endCatch@var2251 =@expr1073747644 endBlock@var2247 .@expr1073747645 linkAt (@expr1073747646 2 ) ;
755: if (@expr1073747647 !@expr1073747648 Token ::@expr5400 simpleMatch (@expr1073747650 endCatch@var2251 , ") {" ) ) {
756: return Break (@expr5333 ) ; }
757: endBlock@var2247 =@expr1073747652 endCatch@var2251 .@expr1073747653 linkAt (@expr1073747654 1 ) ;
758: ForwardTraversal ft@var2252 ; ft@var2252 =@expr1073747655 fork (@expr5804 ) ;
759: ft@var2252 .@expr1073747657 updateRange (@expr1073747658 endBlock@var2247 .@expr1073747659 link (@expr1073747660 ) , endBlock@var2247 , depth@var2209 -@expr5639 1 ) ;
760: bail@var2249 |=@expr1073747662 ft@var2252 .@expr1073747663 terminate@var2253 !=@expr1073747664 Analyzer ::@expr5282 Terminate ::@expr1073747666 None ||@expr1073747667 ft@var2252 .@expr1073747668 actions@var2254 .@expr1073747669 isModified (@expr1073747670 ) ;
761: }
762: if (@expr5814 bail@var2249 ) {
763: return Break (@expr5333 ) ; }
764: tok@var2211 =@expr1073747673 endBlock@var2247 ;
765: } else { if (@expr1073747674 Token ::@expr5400 simpleMatch (@expr1073747676 tok@var2211 , "do {" ) ) {
766: Token * endBlock@var2255 ; endBlock@var2255 =@expr1073747677 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5520 link (@expr5521 ) ;
767: Token * condTok@var2256 ; condTok@var2256 =@expr1073747682 Token ::@expr5400 simpleMatch (@expr1073747684 endBlock@var2255 , "} while (" ) ?@expr1073747685 endBlock@var2255 .@expr1073747686 tokAt (@expr1073747687 2 ) .@expr1073747688 astOperand2 (@expr1073747689 ) :@expr1073747690 nullptr ;
768: if (@expr1073747691 updateLoop (@expr1073747692 end@var2208 , endBlock@var2255 , condTok@var2256 ) ==@expr1073747693 Progress ::@expr5332 Break ) {
769: return Break (@expr5333 ) ; }
770: if (@expr1073747696 condTok@var2256 ) {
771: tok@var2211 =@expr1073747697 endBlock@var2255 .@expr1073747698 linkAt (@expr1073747699 2 ) .@expr1073747700 next (@expr1073747701 ) ; }
772: else {
773: tok@var2211 =@expr1073747702 endBlock@var2255 ; }
774: } else { if (@expr1073747703 Token ::@expr5361 Match (@expr1073747705 tok@var2211 , "assert|ASSERT (" ) ) {
775: const Token * condTok@var2257 ; condTok@var2257 =@expr1073747706 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5885 astOperand2 (@expr5886 ) ;
776: bool checkThen@var2258 ; bool checkElse@var2259 ;
777: std ::@expr5438 tie (@expr1073747712 checkThen@var2258 , checkElse@var2259 ) =@expr1073747713 evalCond (@expr1073747714 condTok@var2257 ) ;
778: if (@expr1073747715 checkElse@var2259 ) {
779: return Break (@expr5333 ) ; }
780: if (@expr1073747717 !@expr1073747718 checkThen@var2258 ) {
781: analyzer@var2058 .@expr5455 assume (@expr1073747720 condTok@var2257 , true , Analyzer ::@expr5458 Assume ::@expr5459 Quiet |@expr1073747723 Analyzer ::@expr5458 Assume ::@expr1073747725 Absolute ) ; }
782: } else { if (@expr1073747726 Token ::@expr5400 simpleMatch (@expr1073747728 tok@var2211 , "switch (" ) ) {
783: if (@expr1073747729 updateRecursive (@expr1073747730 tok@var2211 .@expr5290 next (@expr5291 ) .@expr5885 astOperand2 (@expr5886 ) ) ==@expr1073747735 Progress ::@expr5332 Break ) {
784: return Break (@expr5333 ) ; }
785: return Break (@expr5333 ) ;
786: } else {
787: if (@expr1073747739 updateTok (@expr1073747740 tok@var2211 , &@expr1073747741 next@var2212 ) ==@expr1073747742 Progress ::@expr5332 Break ) {
788: return Break (@expr5333 ) ; }
789: if (@expr1073747745 next@var2212 ) {
790: if (@expr1073747746 precedes (@expr1073747747 next@var2212 , end@var2208 ) ) {
791: tok@var2211 =@expr1073747748 next@var2212 .@expr1073747749 previous (@expr1073747750 ) ; }
792: else {
793: return Break (@expr5333 ) ; }
794: }
795: } } } } } } } } }
796:
797: if (@expr1073747752 tok@var2211 .@expr5290 next (@expr5291 ) ==@expr1073747755 start@var2207 ) {
798: break ; }
799: }
800: return Progress ::@expr1073747756 Continue ;
801: }
802:
803: static bool isUnevaluated ( const Token * tok@var2260 ) {
804: if (@expr1073747757 Token ::@expr1073747758 Match (@expr1073747759 tok@var2260 .@expr1073747760 previous (@expr1073747761 ) , "sizeof|decltype (" ) ) {
805: return true ; }
806: return false ;
807: }
808:
809: static bool isFunctionCall ( const Token * tok@var2261 )
810: {
811: if (@expr1073747762 !@expr1073747763 Token ::@expr5940 simpleMatch (@expr1073747765 tok@var2261 , "(" ) ) {
812: return false ; }
813: if (@expr1073747766 tok@var2261 .@expr1073747767 isCast (@expr1073747768 ) ) {
814: return false ; }
815: if (@expr1073747769 !@expr1073747770 tok@var2261 .@expr1073747771 isBinaryOp (@expr1073747772 ) ) {
816: return false ; }
817: if (@expr1073747773 Token ::@expr5940 simpleMatch (@expr1073747775 tok@var2261 .@expr1073747776 link (@expr1073747777 ) , ") {" ) ) {
818: return false ; }
819: if (@expr1073747778 isUnevaluated (@expr1073747779 tok@var2261 ) ) {
820: return false ; }
821: return Token ::@expr1073747780 Match (@expr1073747781 tok@var2261 .@expr1073747782 previous (@expr1073747783 ) , "%name%|)|]|>" ) ;
822: }
823:
824: static Token * assignExpr ( Token * tok@var2262 ) {
825: while (@expr1073747784 tok@var2262 .@expr5961 astParent (@expr5962 ) &&@expr1073747787 astIsLHS (@expr1073747788 tok@var2262 ) ) {
826: if (@expr1073747789 tok@var2262 .@expr5961 astParent (@expr5962 ) .@expr1073747792 isAssignmentOp (@expr1073747793 ) ) {
827: return tok@var2262 .@expr5961 astParent (@expr5962 ) ; }
828: tok@var2262 =@expr1073747796 tok@var2262 .@expr5961 astParent (@expr5962 ) ;
829: }
830: return nullptr ;
831: }
832:
833: static Token * skipTo ( Token * tok@var2263 , const Token * dest@var2264 , const Token * end@var2265 = nullptr ) {
834: if (@expr1073747799 end@var2265 &&@expr1073747800 dest@var2264 .@expr5977 index (@expr5978 ) >@expr1073747803 end@var2265 .@expr1073747804 index (@expr1073747805 ) ) {
835: return nullptr ; }
836: int i@var2266 ; i@var2266 =@expr1073747806 dest@var2264 .@expr5977 index (@expr5978 ) -@expr5985 tok@var2263 .@expr5986 index (@expr5987 ) ;
837: if (@expr1073747812 i@var2266 >@expr1073747813 0 ) {
838: return tok@var2263 .@expr1073747814 tokAt (@expr1073747815 dest@var2264 .@expr5977 index (@expr5978 ) -@expr5985 tok@var2263 .@expr5986 index (@expr5987 ) ) ; }
839: return nullptr ;
840: }
841:
842: static bool isConditional ( const Token * tok@var2267 ) {
843: const Token * parent@var2268 ; parent@var2268 =@expr1073747821 tok@var2267 .@expr1073747822 astParent (@expr1073747823 ) ;
844: while (@expr1073747824 parent@var2268 &&@expr1073747825 !@expr1073747826 Token ::@expr1073747827 Match (@expr1073747828 parent@var2268 , "%oror%|&&|:" ) ) {
845: tok@var2267 =@expr1073747829 parent@var2268 ;
846: parent@var2268 =@expr1073747830 parent@var2268 .@expr1073747831 astParent (@expr1073747832 ) ;
847: }
848: return parent@var2268 &&@expr1073747833 (@expr1073747834 parent@var2268 .@expr1073747835 str (@expr1073747836 ) ==@expr1073747837 ":" ||@expr1073747838 parent@var2268 .@expr1073747839 astOperand2 (@expr1073747840 ) ==@expr1073747841 tok@var2267 ) ;
849: }
850:
851: static Token * getStepTokFromEnd ( Token * tok@var2269 ) {
852: if (@expr1073747842 !@expr1073747843 Token ::@expr6020 simpleMatch (@expr1073747845 tok@var2269 , "}" ) ) {
853: return nullptr ; }
854: Token * end@var2270 ; end@var2270 =@expr1073747846 tok@var2269 .@expr1073747847 link (@expr1073747848 ) .@expr1073747849 previous (@expr1073747850 ) ;
855: if (@expr1073747851 !@expr1073747852 Token ::@expr6020 simpleMatch (@expr1073747854 end@var2270 , ")" ) ) {
856: return nullptr ; }
857: return getStepTok (@expr1073747855 end@var2270 .@expr1073747856 link (@expr1073747857 ) ) ;
858: }
859:
860: } ;
861:
862: Analyzer :: Result valueFlowGenericForward ( Token * start@var2271 , const Token * end@var2272 , const ValuePtr<Analyzer> & a@var2273 , const Settings * settings@var2274 )
863: {
864: ForwardTraversal ft@var2275 {@expr1073747858 a@var2273 , settings@var2274 } ;
865: ft@var2275 .@expr1073747859 updateRange (@expr1073747860 start@var2271 , end@var2272 ) ;
866: return {@expr1073747861 ft@var2275 .@expr1073747862 actions@var2276 , ft@var2275 .@expr1073747863 terminate@var2277 } ;
867: }
868:
869: Analyzer :: Result valueFlowGenericForward ( Token * start@var2278 , const ValuePtr<Analyzer> & a@var2279 , const Settings * settings@var2280 )
870: {
871: ForwardTraversal ft@var2281 {@expr1073747864 a@var2279 , settings@var2280 } ;
872: ft@var2281 .@expr1073747865 updateRecursive (@expr1073747866 start@var2278 ) ;
873: return {@expr1073747867 ft@var2281 .@expr1073747868 actions@var2282 , ft@var2281 .@expr1073747869 terminate@var2283 } ;
874: }

##file cppcheck-2.8/lib/valueptr.h

1:
|
28:
29: class ValuePtr<Analyzer> {
30: struct cloner<Analyzer> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<Analyzer> :: apply ) ;
41:
42: ValuePtr<Analyzer> ( ) : mPtr@var2294 ( nullptr ) , mClone@var2295 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<Analyzer> ( const U & value@var2284 ) : mPtr@var2294 ( cloner < U > :: apply ( & value@var2284 ) ) , mClone@var2295 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<Analyzer> ( const ValuePtr<Analyzer> & rhs@var2285 ) : mPtr@var2294 ( nullptr ) , mClone@var2295 ( rhs@var2285 . mClone@var2286 ) {
50: if (@expr1073747870 rhs@var2285 ) {
51: mPtr@var2294 .@expr1073747871 reset (@expr1073747872 mClone@var2295 (@expr1073747873 rhs@var2285 .@expr1073747874 get (@expr1073747875 ) ) ) ;
52: }
53: }
54: ValuePtr<Analyzer> ( ValuePtr<Analyzer> && rhs@var2287 ) : mPtr@var2294 ( std :: move ( rhs@var2287 . mPtr@var2288 ) ) , mClone@var2295 ( std :: move ( rhs@var2287 . mClone@var2289 ) ) { }
55:
56: Analyzer * release ( ) {
57: return mPtr@var2294 .@expr1073747876 release (@expr1073747877 ) ;
58: }
59:
60: Analyzer * get ( ) {
61: return mPtr@var2294 .@expr1073747878 get (@expr1073747879 ) ;
62: }
63: const Analyzer * get ( ) const {
64: return mPtr@var2294 .@expr1073747880 get (@expr1073747881 ) ;
65: }
66:
67: Analyzer & operator* ( ) {
68: return *@expr1073747882 get (@expr1073747883 ) ;
69: }
70: const Analyzer & operator* ( ) const {
71: return *@expr1073747884 get (@expr1073747885 ) ;
72: }
73:
74: Analyzer * operator-> ( ) {
75: return get (@expr1073747886 ) ;
76: }
77: const Analyzer * operator-> ( ) const {
78: return get (@expr1073747887 ) ;
79: }
80:
81: void swap ( ValuePtr<Analyzer> & rhs@var2290 ) {
82:
83: std ::@expr6064 swap (@expr1073747889 mPtr@var2294 , rhs@var2290 .@expr1073747890 mPtr@var2291 ) ;
84: std ::@expr6064 swap (@expr1073747892 mClone@var2295 , rhs@var2290 .@expr1073747893 mClone@var2292 ) ;
85: }
86:
87: ValuePtr<Analyzer> & operator= ( ValuePtr<Analyzer> rhs@var2293 ) {
88: swap (@expr1073747894 rhs@var2293 ) ;
89: return *@expr1073747895 this@expr1073747896 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073747897 !@expr1073747898 mPtr@var2294 ;
94: }
95: ~ ValuePtr<Analyzer> ( ) { }
96:
97: private:
98: std :: shared_ptr < Analyzer > mPtr@var2294 ;
99: cloner_type mClone@var2295 ;
100: } ;
29: class ValuePtr<InferModel> {
30: struct cloner<InferModel> ;
31:
|
36:
37: public:
38:
39:
40: using cloner_type = decltype ( & cloner<InferModel> :: apply ) ;
41:
42: ValuePtr<InferModel> ( ) : mPtr@var2306 ( nullptr ) , mClone@var2307 ( ) { }
43:
44: template < class U >
45:
46: ValuePtr<InferModel> ( const U & value@var2296 ) : mPtr@var2306 ( cloner < U > :: apply ( & value@var2296 ) ) , mClone@var2307 ( & cloner < U > :: apply )
47: { }
48:
49: ValuePtr<InferModel> ( const ValuePtr<InferModel> & rhs@var2297 ) : mPtr@var2306 ( nullptr ) , mClone@var2307 ( rhs@var2297 . mClone@var2298 ) {
50: if (@expr1073747899 rhs@var2297 ) {
51: mPtr@var2306 .@expr1073747900 reset (@expr1073747901 mClone@var2307 (@expr1073747902 rhs@var2297 .@expr1073747903 get (@expr1073747904 ) ) ) ;
52: }
53: }
54: ValuePtr<InferModel> ( ValuePtr<InferModel> && rhs@var2299 ) : mPtr@var2306 ( std :: move ( rhs@var2299 . mPtr@var2300 ) ) , mClone@var2307 ( std :: move ( rhs@var2299 . mClone@var2301 ) ) { }
55:
56: InferModel * release ( ) {
57: return mPtr@var2306 .@expr1073747905 release (@expr1073747906 ) ;
58: }
59:
60: InferModel * get ( ) {
61: return mPtr@var2306 .@expr1073747907 get (@expr1073747908 ) ;
62: }
63: const InferModel * get ( ) const {
64: return mPtr@var2306 .@expr1073747909 get (@expr1073747910 ) ;
65: }
66:
67: InferModel & operator* ( ) {
68: return *@expr1073747911 get (@expr1073747912 ) ;
69: }
70: const InferModel & operator* ( ) const {
71: return *@expr1073747913 get (@expr1073747914 ) ;
72: }
73:
74: InferModel * operator-> ( ) {
75: return get (@expr1073747915 ) ;
76: }
77: const InferModel * operator-> ( ) const {
78: return get (@expr1073747916 ) ;
79: }
80:
81: void swap ( ValuePtr<InferModel> & rhs@var2302 ) {
82:
83: std ::@expr6093 swap (@expr1073747918 mPtr@var2306 , rhs@var2302 .@expr1073747919 mPtr@var2303 ) ;
84: std ::@expr6093 swap (@expr1073747921 mClone@var2307 , rhs@var2302 .@expr1073747922 mClone@var2304 ) ;
85: }
86:
87: ValuePtr<InferModel> & operator= ( ValuePtr<InferModel> rhs@var2305 ) {
88: swap (@expr1073747923 rhs@var2305 ) ;
89: return *@expr1073747924 this@expr1073747925 ;
90: }
91:
92: operatorbool ( ) const {
93: return !@expr1073747926 !@expr1073747927 mPtr@var2306 ;
94: }
95: ~ ValuePtr<InferModel> ( ) { }
96:
97: private:
98: std :: shared_ptr < InferModel > mPtr@var2306 ;
99: cloner_type mClone@var2307 ;
100: } ;

##file cppcheck-2.8/lib/settings.h

11:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var2308 ; mFlags@var2308 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2308 ;
54: }
55: void clear ( ) {
56: mFlags@var2308 =@expr1073747928 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2308 =@expr1073747929 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2309 ) {
62: if (@expr1073747930 enabled@var2309 ) {
63: fill (@expr1073747931 ) ; }
64: else {
65: clear (@expr1073747932 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var2310 ) const {
68: return (@expr6109 mFlags@var2308 &@expr1073747934 (@expr6109 1U <<@expr1073747936 (@expr1073747937 uint32_t ) flag@var2310 ) ) !=@expr1073747938 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var2311 ) {
71: mFlags@var2308 |=@expr1073747939 (@expr1073747940 1U <<@expr1073747941 (@expr1073747942 uint32_t ) flag@var2311 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var2312 ) {
74: mFlags@var2308 &=@expr1073747943 ~@expr1073747944 (@expr1073747945 1U <<@expr1073747946 (@expr1073747947 uint32_t ) flag@var2312 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var2313 , bool enabled@var2314 ) {
77: if (@expr1073747948 enabled@var2314 ) {
78: enable (@expr1073747949 flag@var2313 ) ; }
79: else {
80: disable (@expr1073747950 flag@var2313 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var2315 ; mFlags@var2315 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2315 ;
54: }
55: void clear ( ) {
56: mFlags@var2315 =@expr1073747951 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2315 =@expr1073747952 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2316 ) {
62: if (@expr1073747953 enabled@var2316 ) {
63: fill (@expr1073747954 ) ; }
64: else {
65: clear (@expr1073747955 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var2317 ) const {
68: return (@expr6132 mFlags@var2315 &@expr1073747957 (@expr6132 1U <<@expr1073747959 (@expr1073747960 uint32_t ) flag@var2317 ) ) !=@expr1073747961 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var2318 ) {
71: mFlags@var2315 |=@expr1073747962 (@expr1073747963 1U <<@expr1073747964 (@expr1073747965 uint32_t ) flag@var2318 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var2319 ) {
74: mFlags@var2315 &=@expr1073747966 ~@expr1073747967 (@expr1073747968 1U <<@expr1073747969 (@expr1073747970 uint32_t ) flag@var2319 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var2320 , bool enabled@var2321 ) {
77: if (@expr1073747971 enabled@var2321 ) {
78: enable (@expr1073747972 flag@var2320 ) ; }
79: else {
80: disable (@expr1073747973 flag@var2320 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var2322 ; mFlags@var2322 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var2322 ;
54: }
55: void clear ( ) {
56: mFlags@var2322 =@expr1073747974 0 ;
57: }
58: void fill ( ) {
59: mFlags@var2322 =@expr1073747975 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var2323 ) {
62: if (@expr1073747976 enabled@var2323 ) {
63: fill (@expr1073747977 ) ; }
64: else {
65: clear (@expr1073747978 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var2324 ) const {
68: return (@expr6155 mFlags@var2322 &@expr1073747980 (@expr6155 1U <<@expr1073747982 (@expr1073747983 uint32_t ) flag@var2324 ) ) !=@expr1073747984 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var2325 ) {
71: mFlags@var2322 |=@expr1073747985 (@expr1073747986 1U <<@expr1073747987 (@expr1073747988 uint32_t ) flag@var2325 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var2326 ) {
74: mFlags@var2322 &=@expr1073747989 ~@expr1073747990 (@expr1073747991 1U <<@expr1073747992 (@expr1073747993 uint32_t ) flag@var2326 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var2327 , bool enabled@var2328 ) {
77: if (@expr1073747994 enabled@var2328 ) {
78: enable (@expr1073747995 flag@var2327 ) ; }
79: else {
80: disable (@expr1073747996 flag@var2327 ) ; }
81: }
82: } ;

##file cppcheck-2.8/lib/valueptr.h

8:
|
30:
31: struct ValuePtr<InferModel> :: cloner<InferModel> {
32: static InferModel * apply ( const InferModel * x@var2329 ) {
33: return new InferModel (@expr1073747997 *@expr1073747998 static_cast < const InferModel *@expr1073747999 > (@expr1073748000 x@var2329 ) ) ;
34: }
35: } ;
31: struct ValuePtr<Analyzer> :: cloner<Analyzer> {
32: static Analyzer * apply ( const Analyzer * x@var2330 ) {
33: return new Analyzer (@expr1073748001 *@expr1073748002 static_cast < const Analyzer *@expr1073748003 > (@expr1073748004 x@var2330 ) ) ;
34: }
35: } ;



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 35
  mFlag always !<=-1
  0 always 0
Line 39
  ! always {!<=-1,!>=2}
Line 40
  mFlag always !<=-1
Line 44
  None always 0
  = always 0
  0 always 0
  , always 1
Line 45
  Read always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 46
  Write always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 47
  Invalid always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 48
  Inconclusive always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 49
  Match always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 50
  Idempotent always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 51
  Incremental always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 52
  SymbolicMatch always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 53
  Internal always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
Line 56
  f always !<=-1
  state always {!<=-1,!>=2}
  = always 1
  true always 1
Line 57
  mFlag always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlag always !<=-1
  | always !<=-1
  f always !<=-1
  : always !<=-1
  mFlag always !<=-1
  & always !<=-1
  ~ always !<=0
  f always !<=-1
Line 60
  ( always {!<=-1,!>=2}
  f always !<=-1
Line 61
  return always {!<=-1,!>=2}
  mFlag always !<=-1
  & always !<=-1
  f {!<=-1,16@135,256@136,128@137,64@138,32@139,8@142,4@143,2@144,1@145}
  != always {!<=-1,!>=2}
  0 always 0
Line 64
  ( always {!<=-1,!>=2}
Line 65
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Read always 1
Line 68
  ( always {!<=-1,!>=2}
Line 69
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Write always 2
Line 72
  ( always {!<=-1,!>=2}
Line 73
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Invalid always 4
Line 76
  ( always {!<=-1,!>=2}
Line 77
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Inconclusive always 8
Line 80
  ( always {!<=-1,!>=2}
Line 81
  return always {!<=-1,!>=2}
  mFlag always !<=-1
  == always {!<=-1,!>=2}
  None always 0
Line 84
  ( always {!<=-1,!>=2}
Line 85
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Idempotent always 32
Line 92
  ( always {!<=-1,!>=2}
Line 93
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Incremental always 64
Line 96
  ( always {!<=-1,!>=2}
Line 97
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  SymbolicMatch always 128
Line 100
  ( always {!<=-1,!>=2}
Line 101
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Internal always 256
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  Match always 16
Line 109
  . always !<=-1
  mFlag always !<=-1
Line 110
  this always !0
Line 118
  ( always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
Line 122
  ( always {!<=-1,!>=2}
Line 123
  return always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  mFlag always !<=-1
Line 127
  mFlag always !<=-1
Line 130
  None always 0
  Bail always 1
  Escape always 2
  Modified always 3
  Inconclusive always 4
  Conditional always 5
Line 133
  = always 0
  :: always 0
  None always 0
  = always 0
  :: always 0
  None always 0
Line 140
  == always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 146
  Forward always 0
  Reverse always 1
Line 150
  None always 0
  = always 0
  0 always 0
  , always 1
Line 151
  Quiet always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 152
  Absolute always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 153
  ContainerEmpty always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
Line 157
  Integral always 0
  ContainerEmpty always 1
Line 160
  = always 0
  0 always 0
Line 162
  = always 0
  0 always 0
Line 164
  = always 0
  nullptr always 0
  = always 0
  0 always 0
Line 165
  = always 0
  nullptr always 0
Line 167
  :: always 0
  Integral always 0
Line 170
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 172
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 174
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  modified always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 178
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 180
  ( always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 182
  state always {!<=-1,!>=2}
  flags always !<=-1
  = always 0
  0 always 0
  = always 0
  0 always 0
Line 184
  , always ""
  = always ""
  "" always ""
  = always 0
  0 always 0
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@64900,34@65156}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@253,34@254}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@253,""@254,""@255,"U","U"@1,"u"@2,"u"@3,"u8"@4,"u8"@5}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@129,34@130}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@126,34@128}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@87,128@88,64@89,32@90,16@91,8@92,4@93,2@94,1@95}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@96,128@97,64@98,32@99,16@100,8@101,4@102,2@103,1@104}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@96,4294967167@97,4294967231@98,4294967263@99,4294967279@100,4294967287@101,4294967291@102,4294967293@103,4294967294@104}
  flag {!<=-1,256@96,128@97,64@98,32@99,16@100,8@101,4@102,2@103,1@104}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
  index possible {symbolic=(i)@40,>=1@40,2@105}
Line 246
  ( always !0
  this always !0
  index possible {2@100,1@187}
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok possible {symbolic=(tok->link()->previous())@30,symbolic=(tok->link()->previous())@86,symbolic=(tok->next()->link())@196}
  pattern possible {"}"@27,")"@30,"("@48,") {"@51,"else {"@86,"} else {"@99,"} while ("@103,"else {"@109,") {"@113,":"@122}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@242,4@243,0@244}
  t possible {10@242,4@243,0@244}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@242,4@243,0@244}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@242,0@244}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@242,0@244}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@242}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@242}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@242}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@242}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@242}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@250}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  pattern possible "goto"@48
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@252,17179869184@7,8589934592@9,34359738368@11,4294967296@13,2147483648@15,1073741824@17,536870912@19,268435456@21}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@83,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@84}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@251,17179869184@6,8589934592@8,34359738368@10,4294967296@12,2147483648@14,1073741824@16,536870912@18,268435456@20}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@251,17179869184@6,8589934592@8,34359738368@10,4294967296@12,2147483648@14,1073741824@16,536870912@18,268435456@20}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@185,4096@188,16384@191,2048@192,1024@193,65536@194,512@195,256@196,128@197}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@150,4194304@152,8388608@153,2097152@155,1048576@156,524288@157,262144@158,131072@159,65536@160}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@128,2097152@129,1048576@130,524288@131,262144@132,131072@133,65536@134,32768@135,16384@136}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@128,4292870143@129,4293918719@130,4294443007@131,4294705151@132,4294836223@133,4294901759@134,4294934527@135,4294950911@136}
  flag {!<=-1,8388608@128,2097152@129,1048576@130,524288@131,262144@132,131072@133,65536@134,32768@135,16384@136}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 43
  ( always 0
Line 51
  Continue always 0
  Skip always 2
Line 52
  None always 0
  Bail always 1
  Escape always 2
  Modified always 3
  Inconclusive always 4
  Conditional always 5
Line 54
  :: always 0
  None always 0
  analyzeOnly always {!<=-1,!>=2}
  false always 0
  analyzeTerminate always {!<=-1,!>=2}
  false always 0
Line 59
  analyzeOnly always {!<=-1,!>=2}
Line 60
  analyzeTerminate always {!<=-1,!>=2}
Line 61
  = always 0
  :: always 0
  None always 0
Line 62
  forked always {!<=-1,!>=2}
  forked always {!<=-1,!>=2}
  = always 0
  false always 0
Line 65
  = always 0
  :: always 0
  None always 0
Line 66
  ! always {!<=-1,!>=2}
  analyzeOnly always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  analyzeTerminate always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  t possible {1@56,5@136,3@156,2@159,4@66}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
Line 67
  = always !0
  t always !0
Line 68
  :: always 1
  Break always 1
Line 72
  = always 0
  nullptr always 0
Line 73
  = always 0
  nullptr always 0
Line 74
  = always 0
  :: always 0
  None always 0
Line 75
  check always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
  = always 0
  false always 0
Line 76
  escape always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 77
  escapeUnknown always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 78
  active always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  = always 0
  false always 0
Line 79
  ( always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
Line 82
  ( always {!<=-1,!>=2}
Line 83
  return always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 97
  analyzeOnly always {!<=-1,!>=2}
  = always 1
  true always 1
Line 98
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 101
  = always 0
  nullptr always 0
Line 102
  ! always {!<=-1,!>=2}
  tok possible symbolic=(tok->next()->astOperand2())@205
Line 103
  false always 0
  false always 0
Line 104
  tok {!0,symbolic=(tok->next()->astOperand2())@205}
Line 106
  checkThen always {!<=-1,!>=2}
  checkThen always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(result),start=0}
  ( {lifetime[Iterator]=(result),end=0}
Line 107
  != always {!<=-1,!>=2}
  0 always 0
Line 109
  checkElse always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(result),start=0}
  ( {lifetime[Iterator]=(result),end=0}
Line 110
  == always {!<=-1,!>=2}
  0 always 0
Line 112
  checkThen always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  return always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 121
  return always {!<=-1,!>=2}
Line 125
  , always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 126
  ( always {!<=-1,!>=2}
  "asm|goto" always "asm|goto"
Line 127
  ( always 1
  :: always 1
  Bail always 1
Line 128
  ( always {!<=-1,!>=2}
  "setjmp|longjmp (" always "setjmp|longjmp ("
Line 130
  traverseUnknown always {!<=-1,!>=2}
Line 131
  ( always 1
  :: always 1
  Bail always 1
Line 132
  ( always {!<=-1,!>=2}
  "continue" always "continue"
Line 133
  ( always {!<=-1,!>=2}
Line 134
  ( always 1
  :: always 2
  Escape always 2
Line 137
  out always !0
  loopEnds always !size=0
Line 138
  ( always {!<=-1,!>=2}
  "return|throw" always "return|throw"
Line 139
  traverseUnknown always {!<=-1,!>=2}
Line 140
  traverseUnknown always {!<=-1,!>=2}
Line 141
  ( always 1
  :: always 2
  Escape always 2
Line 142
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
Line 144
  traverseUnknown always {!<=-1,!>=2}
Line 145
  ( always 1
  :: always 2
  Escape always 2
Line 146
  ( always {!<=-1,!>=2}
Line 148
  out always !0
Line 149
  :: always 2
  Skip always 2
Line 150
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "?|&&|%oror%" always "?|&&|%oror%"
Line 151
  traverseUnknown always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 152
  ( always 1
Line 154
  out always !0
Line 155
  :: always 2
  Skip always 2
Line 158
  lambdaEndToken always !0
Line 159
  ( always 1
  :: always 1
  Bail always 1
Line 161
  out always !0
Line 163
  == always {!<=-1,!>=2}
  "{" always "{"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 165
  out always !0
Line 167
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 168
  ( always 1
Line 170
  :: always 0
  Continue always 0
Line 174
  , always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  , always 0
  recursion always !<=-1
  = always 0
  0 always 0
Line 175
  ! always {!<=-1,!>=2}
Line 176
  :: always 0
  Continue always 0
Line 177
  recursion always !<=-1
  > always {!<=-1,!>=2}
  10000 always 10000
Line 178
  :: always 2
  Skip always 2
Line 179
  tok always !0
Line 180
  tok always !0
Line 185
  tok always !0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 186
  secondOp possible 0
Line 187
  firstOp possible 0
  && always {!<=-1,!>=2}
  firstOp always !0
  traverseUnknown always {!<=-1,!>=2}
  recursion always {!<=-1,!>=10001}
  + always {!<=0,!>=10002}
  1 always 1
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 188
  ( always 1
Line 189
  tok always !0
  :: always 0
  Continue always 0
  : always 0
  tok always !0
  traverseUnknown always {!<=-1,!>=2}
Line 190
  p possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Break always 1
Line 191
  ( always 1
Line 192
  p always !1
  == always {!<=-1,!>=2}
  :: always 0
  Continue always 0
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  secondOp always !0
  traverseUnknown always {!<=-1,!>=2}
  recursion always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 193
  ( always 1
Line 194
  && always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 195
  ( always 1
Line 196
  :: always 0
  Continue always 0
Line 200
  , always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
Line 201
  ( always {!<=-1,!>=2}
  "?|&&|%oror%" always "?|&&|%oror%"
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 204
  checkThen always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 205
  ( possible {lifetime[Object]=(checkThen),lifetime[Object]=(checkElse)}
  checkThen {!<=-1,!>=2,Uninit}
  checkElse {!<=-1,!>=2,Uninit}
Line 206
  ! always {!<=-1,!>=2}
  checkThen always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 207
  ! always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 208
  :: always 0
  Continue always 0
Line 210
  checkThen always {!<=-1,!>=2}
  = always 1
  true always 1
Line 211
  checkElse always {!<=-1,!>=2}
  = always 1
  true always 1
Line 213
  == always {!<=-1,!>=2}
  ":" always ":"
Line 214
  checkThen always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 215
  ( always 1
Line 216
  checkElse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  traverseUnknown always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 217
  ( always 1
Line 219
  ! always {!<=-1,!>=2}
  checkThen always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "&&" always "&&"
Line 220
  :: always 0
  Continue always 0
Line 221
  ! always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "||" always "||"
Line 222
  :: always 0
  Continue always 0
Line 223
  traverseUnknown always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 224
  ( always 1
Line 227
  :: always 0
  Continue always 0
Line 231
  :: always 0
  Forward always 0
Line 233
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  analyzeOnly always {!<=-1,!>=2}
Line 234
  :: always 0
  Forward always 0
Line 235
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 236
  ( always 1
  :: always 4
  Inconclusive always 4
Line 237
  ( always {!<=-1,!>=2}
Line 238
  ( always 1
  :: always 3
  Modified always 3
Line 239
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 241
  ( always 1
  :: always 3
  Modified always 3
Line 242
  :: always 0
  Continue always 0
Line 245
  , always 0
  = always 0
  nullptr always 0
Line 246
  = possible lifetime[Lambda]=(this)
  [ possible lifetime[Lambda]=(this)
  this always !0
Line 249
  f possible lifetime[Lambda]=(this)
  false always 0
  out possible lifetime[Address]=(next)@213
Line 253
  forked always {!<=-1,!>=2}
  = always 0
  false always 0
Line 254
  = possible lifetime[Lambda]=(this)
  [ possible lifetime[Lambda]=(this)
  this always !0
Line 257
  tok possible symbolic=(condTok->astOperand2())@124
  f possible lifetime[Lambda]=(this)
  false always 0
Line 262
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 263
  :: always 0
  Forward always 0
Line 267
  nullptr always 0
Line 271
  = always 0
  :: always 0
  None always 0
Line 272
  = possible {lifetime[Lambda]=(result),lifetime[Lambda]=(analyzer)}
  [ possible {lifetime[Lambda]=(result),lifetime[Lambda]=(analyzer)}
Line 273
  :: always 0
  Forward always 0
Line 274
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 275
  ( always 1
Line 276
  :: always 0
  Continue always 0
Line 278
  f possible {lifetime[Lambda]=(result),lifetime[Lambda]=(analyzer)}
  true always 1
Line 283
  = always 0
  :: always 0
  None always 0
Line 284
  && always {!<=-1,!>=2}
  tok always !0
  != always {!<=-1,!>=2}
Line 285
  :: always 0
  Forward always 0
Line 286
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 290
  result possible 0
Line 293
  analyze always {!<=-1,!>=2}
  = always 0
  false always 0
Line 294
  this always !0
Line 295
  analyze {!<=-1,!>=2,1@26}
Line 296
  ft always symbolic=(*this)
  . always {!<=-1,!>=2}
  analyzeOnly always {!<=-1,!>=2}
  = always 1
  true always 1
Line 297
  . always {!<=-1,!>=2}
  analyzeTerminate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 299
  ft possible symbolic=(*this)
  = always 0
  :: always 0
  None always 0
Line 300
  . always {!<=-1,!>=2}
  forked always {!<=-1,!>=2}
  = always 1
  true always 1
Line 304
  isModified always {!<=-1,!>=2}
  = always 0
  false always 0
Line 305
  isModified {!<=-1,!>=2,1@4,0@7730}
Line 307
  { always {size=1,{}
Line 309
  { always {size=0,{}
Line 312
  isModified always {!<=-1,!>=2}
  = always 0
  false always 0
Line 313
  isModified {!<=-1,!>=2,0@30}
Line 319
  ( always {!<=-1,!>=2}
Line 320
  return always {!<=-1,!>=2}
  "goto" always "goto"
Line 323
  ( always {!<=-1,!>=2}
Line 324
  return always {!<=-1,!>=2}
  "goto|break" always "goto|break"
Line 327
  ( always {!<=-1,!>=2}
Line 328
  != always {!<=-1,!>=2}
Line 329
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 330
  = always 0
  nullptr always 0
Line 331
  r always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
  & {lifetime[Address]=(ftok),!0}
  ftok always 0
Line 332
  r always {!<=-1,!>=2}
Line 333
  return always {!<=-1,!>=2}
  true always 1
Line 336
  return always {!<=-1,!>=2}
  false always 0
Line 339
  ( always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 340
  = always 0
  nullptr always 0
Line 341
  r always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(settings->library),!0}
  & {lifetime[Address]=(ftok),!0}
  ftok always 0
Line 342
  ! always {!<=-1,!>=2}
  r always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 343
  unknown always {!<=-1,!>=2}
  = always 1
  true always 1
Line 344
  return always {!<=-1,!>=2}
  r {!<=-1,!>=2,0}
Line 348
  None always 0
Line 349
  Escaped always 1
Line 350
  Modified always 2
Line 351
  Inconclusive always 3
Line 360
  ( always {!<=-1,!>=2}
Line 369
  ( always {!<=-1,!>=2}
Line 372
  ( {!<=-1,!>=2,0}
Line 373
  bail always {!<=-1,!>=2}
  bail always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 374
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  bail always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 378
  true always 1
Line 380
  == always {!<=-1,!>=2}
  :: always 2
  Escape always 2
Line 381
  . always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always 1
  true always 1
Line 382
  . always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ft1 always !size=0
  == always {!<=-1,!>=2}
  :: always 2
  Escape always 2
Line 387
  . always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always 1
  true always 1
Line 388
  . always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 392
  return always {!<=-1,!>=2}
  bail {!<=-1,!>=2,0}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ! always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
  true always 1
Line 398
  ( always {!<=-1,!>=2}
  condTok always !0
  ":" always ":"
Line 399
  return always {!<=-1,!>=2}
  true always 1
Line 400
  changed always {!<=-1,!>=2}
  changed always {!<=-1,!>=2}
  = always 0
  false always 0
Line 402
  stepTok always !0
Line 403
  exprToks always symbolic=(stepTok->findExpressionStartEndTokens())
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  exprToks always symbolic=(stepTok->findExpressionStartEndTokens())
  != always {!<=-1,!>=2}
  nullptr always 0
Line 404
  changed always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  exprToks always symbolic=(stepTok->findExpressionStartEndTokens())
  . always !0
  exprToks always symbolic=(stepTok->findExpressionStartEndTokens())
  true always 1
Line 406
  changed always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  true always 1
Line 408
  changed always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 409
  condTok always !0
  [ possible lifetime[Lambda]=(isVariableChanged(tok,0,settings,true))
Line 410
  ( always {!<=-1,!>=2}
  0 always 0
  true always 1
Line 412
  ! always {!<=-1,!>=2}
  changed always {!<=-1,!>=2}
Line 413
  return always {!<=-1,!>=2}
  true always 1
Line 414
  true always 1
Line 415
  false always 0
  :: always 2
  Absolute always 2
Line 417
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 421
  loopEnds possible lifetime[Object]=(endBlock)
Line 422
  { possible lifetime[SubObject]=(loopEnds)
  [ possible lifetime[Lambda]=(loopEnds)
Line 423
  loopEnds possible lifetime[Object]=(endBlock)
Line 425
  && always {!<=-1,!>=2}
  endBlock always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 426
  ( always 1
Line 427
  && always {!<=-1,!>=2}
  stepTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 428
  ( always 1
Line 429
  && always {!<=-1,!>=2}
  condTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 430
  ( always 1
Line 431
  :: always 0
  Continue always 0
Line 436
  , always 0
Line 437
  = always 0
  nullptr always 0
  , always 0
Line 438
  = always 0
  nullptr always 0
  , always 0
Line 439
  exit always {!<=-1,!>=2}
  = always 0
  false always 0
Line 440
  && always {!<=-1,!>=2}
  initTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 441
  ( always 1
Line 442
  isDoWhile always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok possible 0
Line 443
  checkThen always {!<=-1,!>=2}
  checkThen always {!<=-1,!>=2}
  = always 1
  true always 1
Line 444
  checkElse always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
  = always 0
  false always 0
Line 445
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  ":" always ":"
Line 446
  ( possible {lifetime[Object]=(checkThen),lifetime[Object]=(checkElse)}
  checkThen always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
  condTok always !0
  isDoWhile always {!<=-1,!>=2}
  ? possible 0
  : always 0
  nullptr always 0
Line 448
  checkElse {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  exit always {!<=-1,!>=2}
Line 449
  ( always {!<=-1,!>=2}
Line 450
  ! always {!<=-1,!>=2}
Line 451
  ( always 1
  :: always 1
  Bail always 1
Line 452
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 453
  ( always 1
  :: always 5
  Conditional always 5
Line 455
  :: always 0
  Continue always 0
Line 461
  condTok always !0
Line 465
  stepTok always !0
Line 468
  checkElse {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  isDoWhile always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 469
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 470
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 471
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 472
  ( always 1
Line 475
  ( always {!<=-1,!>=2}
Line 476
  ! always {!<=-1,!>=2}
Line 477
  ( always 1
  :: always 1
  Bail always 1
Line 478
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  exit always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 479
  ! always {!<=-1,!>=2}
Line 480
  ( always 1
  :: always 1
  Bail always 1
Line 483
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  condTok always !0
  ":" always ":"
Line 484
  ! always {!<=-1,!>=2}
  isDoWhile always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 485
  condTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 486
  ( always 1
Line 488
  ! {!<=-1,!>=2,1}
  checkThen {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isDoWhile always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 489
  ( always 1
  :: always 5
  Conditional always 5
Line 491
  checkElse always {!<=-1,!>=2}
Line 492
  :: always 0
  Continue always 0
Line 493
  checkThen always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  isDoWhile always {!<=-1,!>=2}
Line 495
  exit always {!<=-1,!>=2}
Line 496
  true always 1
  :: always 1
  Quiet always 1
  | always 3
  :: always 2
  Absolute always 2
Line 497
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 498
  ( always 1
Line 500
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 501
  ( always 1
  :: always 1
  Bail always 1
Line 502
  ( always {!<=-1,!>=2}
Line 503
  ( always 1
  :: always 1
  Bail always 1
Line 504
  ( {!<=-1,!>=2,0}
Line 505
  ( always 1
Line 506
  forkContinue always {!<=-1,!>=2}
  forkContinue always {!<=-1,!>=2}
  = always 1
  true always 1
Line 509
  condTok always !0
  false always 0
  :: always 1
  Quiet always 1
Line 510
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 511
  forkContinue always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  forkContinue always {!<=-1,!>=2}
Line 516
  ! always {!<=-1,!>=2}
Line 517
  ( always 1
  :: always 1
  Bail always 1
Line 518
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 519
  ( always 1
  :: always 5
  Conditional always 5
Line 520
  condTok always !0
  false always 0
Line 522
  forkContinue always {!<=-1,!>=2}
Line 524
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 528
  ( always {!<=-1,!>=2}
Line 529
  ( always 1
  :: always 1
  Bail always 1
Line 531
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 532
  :: always 1
  Break always 1
Line 533
  ( always {!<=-1,!>=2}
Line 534
  ( always 1
  :: always 1
  Bail always 1
Line 536
  :: always 0
  Continue always 0
Line 541
  , always 0
Line 542
  = always 0
  nullptr always 0
  , always 0
Line 543
  = always 0
  nullptr always 0
Line 544
  true always 1
Line 548
  forked always {!<=-1,!>=2}
Line 553
  , always 20
  = always 20
  20 always 20
Line 554
  forked always {!<=-1,!>=2}
  = always 0
  false always 0
Line 555
  depth possible 20
  < {!<=-1,!>=2,0}
  0 always 0
Line 556
  ( always 1
  :: always 1
  Bail always 1
Line 557
  i always !<=-1
  i always !<=-1
  = always 0
  0 always 0
Line 558
  ( always {!<=-1,!>=2}
  end possible symbolic=(tok->next()->link())@180
Line 559
  = always 0
  nullptr always 0
Line 560
  <= always {!<=-1,!>=2}
  i always !<=-1
Line 561
  "Cyclic forward analysis." always "Cyclic forward analysis."
Line 562
  i always !<=-1
  = {!<=-1,!<=symbolic=(i),>=symbolic=(i+1)}
  ( {!<=symbolic=(i),>=symbolic=(i+1)}
Line 566
  == always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 571
  == always {!<=-1,!>=2}
  "<" always "<"
Line 579
  assignTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 580
  ( always 1
Line 581
  assignTok always !0
Line 582
  ! always {!<=-1,!>=2}
Line 583
  ( always 1
Line 584
  ( possible {size=4,size=1}
  == {!<=-1,!>=2,0}
  "break" always "break"
Line 586
  ! always {!<=-1,!>=2}
Line 587
  ( always 1
Line 588
  scopeEndToken always !0
Line 589
  ! always {!<=-1,!>=2}
Line 590
  ( always 1
  :: always 1
  Bail always 1
Line 592
  ! always {!<=-1,!>=2}
Line 593
  ( always 1
Line 594
  ( always {!<=-1,!>=2}
  "%name% :" always "%name% :"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "case" always "case"
Line 595
  ! always {!<=-1,!>=2}
Line 596
  ( always 1
  :: always 1
  Bail always 1
Line 597
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "}" always "}"
Line 599
  ! always {!<=-1,!>=2}
  scope always symbolic=(tok->scope())
Line 600
  ( always 1
Line 601
  ( always {!<=-1,!>=2}
  ( always !0
  ")|else {" always ")|else {"
Line 602
  ( always !0
Line 603
  inElse always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->link()->previous())
  "else {" always "else {"
Line 604
  inLoop always {!<=-1,!>=2}
  = {0,!<=-1,!>=2}
  inElse always {!<=-1,!>=2}
  ? {0,!<=-1,!>=2}
  false always 0
  : always 0
  ( always {!<=-1,!>=2}
  tok2 always symbolic=(tok->link()->previous())
  "while|for (" always "while|for ("
Line 606
  ! always {!<=-1,!>=2}
Line 607
  ( always 1
Line 608
  ! always {!<=-1,!>=2}
  condTok always !0
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  inLoop always {!<=-1,!>=2}
Line 609
  ! always {!<=-1,!>=2}
Line 610
  ( always 1
  :: always 1
  Bail always 1
Line 611
  condTok always !0
  == always {!<=-1,!>=2}
  inElse always {!<=-1,!>=2}
Line 612
  ( always 1
Line 616
  checkThen always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 617
  ( possible {lifetime[Object]=(checkThen),lifetime[Object]=(checkElse)}
  checkThen {!<=-1,!>=2,Uninit}
  checkElse {!<=-1,!>=2,Uninit}
  condTok always !0
Line 618
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 619
  stepTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 620
  ( always 1
Line 621
  condTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 622
  ( always 1
Line 624
  condTok always !0
  ! always {!<=-1,!>=2}
  inElse always {!<=-1,!>=2}
  :: always 1
  Quiet always 1
Line 625
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 626
  2 always 2
Line 627
  scope {symbolic=(tok->scope()),!0}
  . possible {15,10}
  == {!<=-1,!>=2,0}
  :: always 13
  eTry always 13
Line 628
  ! always {!<=-1,!>=2}
Line 629
  ( always 1
  :: always 1
  Bail always 1
Line 630
  scope {symbolic=(tok->scope()),!0}
  . {10,!13}
  == {!<=-1,!>=2,0}
  :: always 15
  eLambda always 15
Line 631
  ( always 1
Line 632
  scope {symbolic=(tok->scope()),!0}
  . always {!13,!15}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} while (" always "} while ("
Line 633
  2 always 2
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 634
  ( always 1
Line 635
  2 always 2
Line 636
  ( always {!<=-1,!>=2}
  "else {" always "else {"
Line 637
  2 always 2
Line 639
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "if|while|for (" always "if|while|for ("
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 641
  endCond always symbolic=(tok->next()->link())
Line 644
  && always {!<=-1,!>=2}
  initTok always !0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 645
  ( always 1
Line 646
  ( always {!<=-1,!>=2}
  "for|while (" always "for|while ("
Line 648
  ( always {!<=-1,!>=2}
  ":" always ":"
Line 650
  conTok always symbolic=(condTok->astOperand2())
  && always {!<=-1,!>=2}
  conTok {symbolic=(condTok->astOperand2()),!0}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 651
  ( always 1
Line 652
  isEmpty always {!<=-1,!>=2}
  isEmpty always {!<=-1,!>=2}
  = always 0
  false always 0
Line 654
  :: always 1
  ContainerEmpty always 1
  conTok {symbolic=(condTok->astOperand2()),0}
Line 655
  ( always {!<=-1,!>=2}
Line 656
  false always 0
  :: always 4
  ContainerEmpty always 4
Line 658
  isEmpty always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  result always !size=0
  != always {!<=-1,!>=2}
  0 always 0
Line 659
  ! always {!<=-1,!>=2}
  isEmpty {symbolic=(result.front()!=0),!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 660
  ( always 1
Line 663
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 664
  ( always 1
Line 669
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 670
  ( always 1
Line 672
  2 always 2
  2 always 2
  : always 0
  nullptr always 0
Line 674
  ( possible {lifetime[Object]=(check),lifetime[Object]=(check)}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 675
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 676
  ( always 1
  :: always 5
  Conditional always 5
Line 677
  hasElse always {!<=-1,!>=2}
  hasElse always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "} else {" always "} else {"
Line 678
  bail {!<=-1,!>=2,0}
  bail always {!<=-1,!>=2}
  = always 0
  false always 0
Line 681
  . always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
Line 682
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 683
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  = always 1
  true always 1
Line 684
  1 always 1
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 685
  ( always 1
Line 686
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 687
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  = always 1
  true always 1
Line 688
  ( always {!<=-1,!>=2}
Line 689
  bail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 692
  hasElse {!<=-1,!>=2,0}
Line 693
  . always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  2 always 2
  . always {!<=-1,!>=2}
  escapeUnknown always {!<=-1,!>=2}
Line 694
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 695
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  = always 1
  true always 1
Line 696
  2 always 2
  2 always 2
  1 always 1
Line 697
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 698
  ( always 1
Line 699
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 700
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  = always 1
  true always 1
Line 701
  ( always {!<=-1,!>=2}
Line 702
  bail always {!<=-1,!>=2}
  = always 1
  true always 1
Line 704
  2 always 2
Line 708
  . {!<=-1,!>=2,0}
  active always {!<=-1,!>=2}
Line 710
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
Line 712
  bail always {!<=-1,!>=2}
Line 713
  ( always 1
  :: always 1
  Bail always 1
Line 714
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 715
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 716
  ( always 1
  :: always 3
  Modified always 3
Line 717
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 718
  ( always 1
  :: always 2
  Escape always 2
Line 719
  ( always 1
  :: always 1
  Bail always 1
Line 722
  . always {!<=-1,!>=2}
  active always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  hasElse always {!<=-1,!>=2}
Line 723
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 724
  ! always {!<=-1,!>=2}
Line 725
  ( always 1
  :: always 1
  Bail always 1
Line 726
  . always {!<=-1,!>=2}
  check always {!<=-1,!>=2}
Line 727
  ( always 1
Line 729
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 730
  ( always 1
  :: always 5
  Conditional always 5
Line 731
  false always 0
Line 734
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 735
  ! always {!<=-1,!>=2}
Line 736
  ( always 1
  :: always 1
  Bail always 1
Line 737
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 738
  ! always {!<=-1,!>=2}
  hasElse always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 739
  ( always 1
  :: always 5
  Conditional always 5
Line 740
  ! always {!<=-1,!>=2}
Line 741
  ( always 1
  :: always 1
  Bail always 1
Line 742
  ( always {!<=-1,!>=2}
Line 745
  ( always {!<=-1,!>=2}
  "try {" always "try {"
Line 748
  endBlock always symbolic=(tok->next()->link())
  depth always !<=-1
  - always !<=-2
  1 always 1
Line 749
  bail always {!<=-1,!>=2}
  bail always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 750
  bail {symbolic=(tryTraversal.actions.isModified()),!<=-1,!>=2}
Line 753
  ( always {!<=-1,!>=2}
  endBlock inconclusive symbolic=(tok->next()->link())
  "} catch (" always "} catch ("
Line 754
  2 always 2
Line 755
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 756
  ( always 1
Line 757
  1 always 1
Line 759
  1 always 1
Line 760
  bail always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 0
  None always 0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 762
  bail {symbolic=(tryTraversal.actions.isModified()),!<=-1,!>=2}
Line 763
  ( always 1
Line 765
  ( always {!<=-1,!>=2}
  "do {" always "do {"
Line 767
  ( always {!<=-1,!>=2}
  endBlock always symbolic=(tok->next()->link())
  "} while (" always "} while ("
  endBlock always symbolic=(tok->next()->link())
  2 always 2
  : always 0
  nullptr always 0
Line 768
  endBlock always symbolic=(tok->next()->link())
  condTok possible 0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 769
  ( always 1
Line 771
  endBlock always symbolic=(tok->next()->link())
  2 always 2
Line 773
  = always symbolic=(tok->next()->link())
  endBlock always symbolic=(tok->next()->link())
Line 774
  ( always {!<=-1,!>=2}
  "assert|ASSERT (" always "assert|ASSERT ("
Line 776
  checkThen always {!<=-1,!>=2}
  checkElse always {!<=-1,!>=2}
Line 777
  ( possible {lifetime[Object]=(checkThen),lifetime[Object]=(checkElse)}
  checkThen {!<=-1,!>=2,Uninit}
  checkElse {!<=-1,!>=2,Uninit}
  condTok always symbolic=(tok->next()->astOperand2())
Line 778
  checkElse always {!<=-1,!>=2}
Line 779
  ( always 1
Line 780
  ! always {!<=-1,!>=2}
  checkThen always {!<=-1,!>=2}
Line 781
  condTok always symbolic=(tok->next()->astOperand2())
  true always 1
  :: always 1
  Quiet always 1
  | always 3
  :: always 2
  Absolute always 2
Line 782
  ( always {!<=-1,!>=2}
  "switch (" always "switch ("
Line 783
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 784
  ( always 1
Line 785
  ( always 1
Line 787
  & {lifetime[Address]=(next),!0}
  next always 0
  == always {!<=-1,!>=2}
  :: always 1
  Break always 1
Line 788
  ( always 1
Line 790
  ( always {!<=-1,!>=2}
  next always !0
Line 791
  next always !0
Line 793
  ( always 1
Line 797
  tok possible {symbolic=(endBlock),symbolic=(endBlock),symbolic=(endBlock),symbolic=(next->previous()),symbolic=(tok->next()->link())}
  == always {!<=-1,!>=2}
Line 800
  :: always 0
  Continue always 0
Line 803
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
  "sizeof|decltype (" always "sizeof|decltype ("
Line 805
  return always {!<=-1,!>=2}
  true always 1
Line 806
  return always {!<=-1,!>=2}
  false always 0
Line 809
  ( always {!<=-1,!>=2}
Line 811
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "(" always "("
Line 812
  return always {!<=-1,!>=2}
  false always 0
Line 813
  ( always {!<=-1,!>=2}
Line 814
  return always {!<=-1,!>=2}
  false always 0
Line 815
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 816
  return always {!<=-1,!>=2}
  false always 0
Line 817
  ( always {!<=-1,!>=2}
  ") {" always ") {"
Line 818
  return always {!<=-1,!>=2}
  false always 0
Line 819
  ( always {!<=-1,!>=2}
Line 820
  return always {!<=-1,!>=2}
  false always 0
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name%|)|]|>" always "%name%|)|]|>"
Line 825
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 826
  ( always !0
  ( always {!<=-1,!>=2}
Line 830
  nullptr always 0
Line 833
  , always 0
  = always 0
  nullptr always 0
Line 834
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  end always !0
Line 835
  nullptr always 0
Line 836
  ( possible <=symbolic=(end->index())
Line 837
  i always symbolic=(dest->index()-tok->index())
  > always {!<=-1,!>=2}
  0 always 0
Line 838
  - {symbolic=(i),>=1,!<=0}
Line 839
  nullptr always 0
Line 842
  ( always {!<=-1,!>=2}
Line 844
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  parent {symbolic=(tok->astParent()),!0}
  "%oror%|&&|:" always "%oror%|&&|:"
Line 845
  = always !0
  parent always !0
Line 846
  parent {symbolic=(tok),!0}
Line 848
  return always {!<=-1,!>=2}
  parent possible {symbolic=(tok->astParent()),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  ":" always ":"
  || always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
Line 852
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "}" always "}"
Line 853
  nullptr always 0
Line 855
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end always symbolic=(tok->link()->previous())
  ")" always ")"
Line 856
  nullptr always 0
Line 857
  end always symbolic=(tok->link()->previous())
Line 864
  { possible lifetime[SubObject]=(a)
Line 865
  ft possible lifetime[SubObject]=(a)
Line 871
  { possible lifetime[SubObject]=(a)
Line 872
  ft possible lifetime[SubObject]=(a)
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 40
  & {lifetime[Address]=(apply),!0}
Line 42
  nullptr always 0
Line 46
  & {lifetime[Address]=(value),!0}
  & {lifetime[Address]=(apply),!0}
Line 49
  nullptr always 0
  rhs possible 0
Line 54
  && always {!<=-1,!>=2}
Line 61
  ( always symbolic=(mPtr)
Line 64
  ( always symbolic=(mPtr)
Line 89
  this always !0
Line 92
  ( always !>=2
Line 93
  ! always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
