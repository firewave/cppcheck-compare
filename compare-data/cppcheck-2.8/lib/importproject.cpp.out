

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/platform.h

1:
|
31:
32: namespace tinyxml2 {
33: class XMLDocument ;
34: }
35:
36: namespace cppcheck {
37:
|
40:
41: class Platform {
42: private:
43: static long long min_value ( int bit@var2 ) {
44: if (@expr1073743718 bit@var2 >=@expr1073743719 64 ) {
45: return LLONG_MIN ; }
46: return -@expr1073743720 (@expr1073743721 1LL <<@expr1073743722 (@expr1073743723 bit@var2 -@expr1073743724 1 ) ) ;
47: }
48:
49: static long long max_value ( int bit@var3 ) {
50: if (@expr1073743725 bit@var3 >=@expr1073743726 64 ) {
51: return (@expr1903 ~@expr1073743728 0ULL ) >>@expr1073743729 1 ; }
52: return (@expr1903 1LL <<@expr1073743731 (@expr1903 bit@var3 -@expr1073743733 1 ) ) -@expr1073743734 1LL ;
53: }
54: public:
55: Platform ( ) ;
56: virtual ~ Platform ( ) { }
57:
58: bool isIntValue ( long long value@var4 ) const {
59: return value@var4 >=@expr1073743735 min_value (@expr1073743736 int_bit@var14 ) &&@expr1073743737 value@var4 <=@expr1073743738 max_value (@expr1073743739 int_bit@var14 ) ;
60: }
61:
62: bool isIntValue ( unsigned long long value@var5 ) const {
63: unsigned long long intMax@var6 ; intMax@var6 =@expr1073743740 max_value (@expr1073743741 int_bit@var14 ) ;
64: return value@var5 <=@expr1073743742 intMax@var6 ;
65: }
66:
67: bool isLongValue ( long long value@var7 ) const {
68: return value@var7 >=@expr1073743743 min_value (@expr1073743744 long_bit@var15 ) &&@expr1073743745 value@var7 <=@expr1073743746 max_value (@expr1073743747 long_bit@var15 ) ;
69: }
70:
71: bool isLongValue ( unsigned long long value@var8 ) const {
72: unsigned long long longMax@var9 ; longMax@var9 =@expr1073743748 max_value (@expr1073743749 long_bit@var15 ) ;
73: return value@var8 <=@expr1073743750 longMax@var9 ;
74: }
75:
76: bool isLongLongValue ( unsigned long long value@var10 ) const {
77: unsigned long long longLongMax@var11 ; longLongMax@var11 =@expr1073743751 max_value (@expr1073743752 long_long_bit@var16 ) ;
78: return value@var10 <=@expr1073743753 longLongMax@var11 ;
79: }
80:
81: int char_bit@var12 ;
82: int short_bit@var13 ;
83: int int_bit@var14 ;
84: int long_bit@var15 ;
85: int long_long_bit@var16 ;
86:
87:
88: int sizeof_bool@var17 ;
89: int sizeof_short@var18 ;
90: int sizeof_int@var19 ;
91: int sizeof_long@var20 ;
92: int sizeof_long_long@var21 ;
93: int sizeof_float@var22 ;
94: int sizeof_double@var23 ;
95: int sizeof_long_double@var24 ;
96: int sizeof_wchar_t@var25 ;
97: int sizeof_size_t@var26 ;
98: int sizeof_pointer@var27 ;
99:
100: char defaultSign@var28 ;
101:
102: enum PlatformType {
103: Unspecified ,
104: Native ,
105: Win32A ,
106: Win32W ,
107: Win64 ,
108: Unix32 ,
109: Unix64 ,
110: PlatformFile
111: } ;
112:
113:
114: PlatformType platformType@var29 ;
115:
116:
117: bool platform ( PlatformType type@var30 ) ;
118:
|
124:
125: bool loadPlatformFile ( const char exename@var31 [ ] , const std :: string & filename@var32 ) ;
126:
127:
128: bool loadFromXmlDocument ( const tinyxml2 :: XMLDocument * doc@var33 ) ;
129:
|
133:
134: bool isWindowsPlatform ( ) const {
135: return platformType@var29 ==@expr1073743754 Win32A ||@expr1073743755
136: platformType@var29 ==@expr1073743756 Win32W ||@expr1073743757
137: platformType@var29 ==@expr1073743758 Win64 ;
138: }
139:
140: const char * platformString ( ) const {
141: return platformString (@expr1073743759 platformType@var29 ) ;
142: }
143:
144: static const char * platformString ( PlatformType pt@var34 ) {
145: switch (@expr1073743760 pt@var34 ) {
146: case Unspecified :@expr1937 ;
147: return "Unspecified" ;
148: case Native :@expr1937 ;
149: return "Native" ;
150: case Win32A :@expr1937 ;
151: return "win32A" ;
152: case Win32W :@expr1937 ;
153: return "win32W" ;
154: case Win64 :@expr1937 ;
155: return "win64" ;
156: case Unix32 :@expr1937 ;
157: return "unix32" ;
158: case Unix64 :@expr1937 ;
159: return "unix64" ;
160: case PlatformFile :@expr1937 ;
161: return "platformFile" ;
162: default :@expr1937 ;
163: return "unknown" ;
164: }
165: }
166:
167: long long unsignedCharMax ( ) const {
168: return max_value (@expr1073743770 char_bit@var12 +@expr1073743771 1 ) ;
169: }
170:
171: long long signedCharMax ( ) const {
172: return max_value (@expr1073743772 char_bit@var12 ) ;
173: }
174:
175: long long signedCharMin ( ) const {
176: return min_value (@expr1073743773 char_bit@var12 ) ;
177: }
178: } ;
179:
180: }

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var35 ) const {
35: return p@var35 .@expr1073743774 first@var36 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var37 ) const {
42: return p@var37 .@expr1073743775 second@var38 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var39 , const T & x@var40 )
48: {
49: return std ::@expr1073743776 find (@expr1073743777 r@var39 .@expr1073743778 begin (@expr1073743779 ) , r@var39 .@expr1956 end (@expr1957 ) , x@var40 ) !=@expr1073743782 r@var39 .@expr1956 end (@expr1957 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var41 , const T & x@var42 )
54: {
55: return std ::@expr1073743785 find (@expr1073743786 r@var41 .@expr1073743787 begin (@expr1073743788 ) , r@var41 .@expr1965 end (@expr1966 ) , x@var42 ) !=@expr1073743791 r@var41 .@expr1965 end (@expr1966 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var43 , const U & x@var44 )
60: {
61: return std ::@expr1073743794 find (@expr1073743795 r@var43 .@expr1073743796 begin (@expr1073743797 ) , r@var43 .@expr1974 end (@expr1975 ) , x@var44 ) !=@expr1073743800 r@var43 .@expr1974 end (@expr1975 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var45 ) const
68: {
69: return static_cast < unsigned long > (@expr1073743803 t@var45 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var46 , char c@var47 )
74: {
75: return !@expr1073743804 str@var46 .@expr1073743805 empty (@expr1073743806 ) &&@expr1073743807 str@var46 .@expr1073743808 back (@expr1073743809 ) ==@expr1073743810 c@var47 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var48 , const char end@var49 [ ] , unsigned long endlen@var50 )
79: {
80: return (@expr1987 str@var48 .@expr1988 size (@expr1989 ) >=@expr1073743814 endlen@var50 ) &&@expr1073743815 (@expr1987 str@var48 .@expr1073743817 compare (@expr1073743818 str@var48 .@expr1988 size (@expr1989 ) -@expr1073743821 endlen@var50 , endlen@var50 , end@var49 ) ==@expr1073743822 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var51 , const char ( & end@var52 ) [ N ] )
85: {
86: return endsWith (@expr1073743824 str@var51 , end@var52 , N@expr1073743823 -@expr1073743825 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var53 , char q@var54 , const std :: string & p@var55 )
90: {
91: if (@expr1073743826 !@expr1073743827 endsWith (@expr1073743828 str@var53 , q@var54 ) ) {
92: return false ; }
93: if (@expr1073743829 (@expr1073743830 str@var53 .@expr1073743831 length (@expr1073743832 ) +@expr1073743833 1 ) >@expr1073743834 p@var55 .@expr1073743835 length (@expr1073743836 ) &&@expr1073743837 (@expr1073743838 str@var53 .@expr1073743839 compare (@expr1073743840 0 , p@var55 .@expr1073743841 size (@expr1073743842 ) +@expr1073743843 1 , p@var55 +@expr1073743844 q@var54 ) ==@expr1073743845 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var56 , char q@var57 )
99: {
100: static const std ::@expr2022 vector < std ::@expr2022 string > suffixes@var58 {@expr1073743848 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073743849 const std ::@expr2022 string &@expr1073743851 p@var59 :@expr1073743852 suffixes@var58 ) {
102: if (@expr1073743853 isPrefixStringCharLiteral (@expr1073743854 str@var56 , q@var57 , p@var59 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var60 )
109: {
110: return isStringCharLiteral (@expr1073743855 str@var60 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var61 )
114: {
115: return isStringCharLiteral (@expr1073743856 str@var61 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var62 , char q@var63 )
119: {
120: const unsigned long quotePos@var64 =@expr1073743857 str@var62 .@expr1073743858 find (@expr1073743859 q@var63 ) ;
121: return str@var62 .@expr1073743860 substr (@expr1073743861 quotePos@var64 +@expr1073743862 1U , str@var62 .@expr1073743863 size (@expr1073743864 ) -@expr1073743865 quotePos@var64 -@expr1073743866 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var65 )
125: {
126: if (@expr1073743867 isStringLiteral (@expr1073743868 str@var65 ) ) {
127: return getStringCharLiteral (@expr1073743869 str@var65 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var66 )
132: {
133: if (@expr1073743870 isCharLiteral (@expr1073743871 str@var66 ) ) {
134: return getStringCharLiteral (@expr1073743872 str@var66 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var67 )
139: {
140: if (@expr1073743873 i@var67 ==@expr1073743874 1 ) {
141: return "st" ; }
142: if (@expr1073743875 i@var67 ==@expr1073743876 2 ) {
143: return "nd" ; }
144: if (@expr1073743877 i@var67 ==@expr1073743878 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var68 , const std :: string & rhs@var69 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var70 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var71 , const std :: string & name@var72 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var73 , const std :: string & name@var74 ) ;
156:
157: void strTolower ( std :: string & str@var75 ) ;

##file cppcheck-2.8/lib/importproject.h

1:
|
37:
38: namespace cppcheck {
39: struct stricmp {
40: bool operator() ( const std :: string & lhs@var76 , const std :: string & rhs@var77 ) const {
41: return caseInsensitiveStringCompare (@expr1073743879 lhs@var76 , rhs@var77 ) <@expr1073743880 0 ;
42: }
43: } ;
44: }
45:
46: class Settings ;
47:
|
50:
51: class ImportProject {
52: public:
53: enum class Type {
54: UNKNOWN ,
55: MISSING ,
56: FAILURE ,
57: COMPILE_DB ,
58: VS_SLN ,
59: VS_VCXPROJ ,
60: BORLAND ,
61: CPPCHECK_GUI
62: } ;
63:
64:
65: struct FileSettings {
66: FileSettings ( ) : platformType@var85 ( cppcheck :: Platform :: Unspecified ) , msc@var86 ( false ) , useMfc@var87 ( false ) { }
67: std :: string cfg@var78 ;
68: std :: string filename@var79 ;
69: std :: string defines@var80 ;
70: std :: string cppcheckDefines ( ) const {
71: return defines@var80 +@expr1073743881 (@expr1073743882 msc@var86 ?@expr1073743883 ";_MSC_VER=1900" :@expr1073743884 "" ) +@expr1073743885 (@expr1073743886 useMfc@var87 ?@expr1073743887 ";__AFXWIN_H__=1" :@expr1073743888 "" ) ;
72: }
73: std :: set < std :: string > undefs@var81 ;
74: std :: list < std :: string > includePaths@var82 ;
75: std :: list < std :: string > systemIncludePaths@var83 ;
76: std :: string standard@var84 ;
77: cppcheck :: Platform :: PlatformType platformType@var85 ;
78: bool msc@var86 ;
79: bool useMfc@var87 ;
80:
81: void parseCommand ( std :: string command@var88 ) ;
82: void setDefines ( std :: string defs@var89 ) ;
83: void setIncludePaths ( const std :: string & basepath@var90 , const std :: list < std :: string > & in@var91 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var92 ) ;
84: } ;
85: std :: list < FileSettings > fileSettings@var93 ;
86: Type projectType@var94 ;
87:
88: ImportProject ( ) ;
89:
90: void selectOneVsConfig ( cppcheck :: Platform :: PlatformType platform@var95 ) ;
91:
92: std :: list < std :: string > getVSConfigs ( ) ;
93:
94:
95: struct Anonymous0 {
96: std :: string analyzeAllVsConfigs@var96 ;
97: std :: vector < std :: string > pathNames@var97 ;
98: std :: list < std :: string > libraries@var98 ;
99: std :: list < std :: string > excludedPaths@var99 ;
100: std :: list < std :: string > checkVsConfigs@var100 ;
101: std :: string projectFile@var101 ;
102: std :: string platform@var102 ;
103: } ; struct Anonymous0 guiProject@var103 ;
104:
105: void ignorePaths ( const std :: vector < std :: string > & ipaths@var104 ) ;
106: void ignoreOtherConfigs ( const std :: string & cfg@var105 ) ;
107:
108: Type import ( const std :: string & filename@var106 , Settings * settings@var107 = nullptr ) ;
109: protected:
110: bool importCompileCommands ( std :: istream & istr@var108 ) ;
111: bool importCppcheckGuiProject ( std :: istream & istr@var109 , Settings * settings@var110 ) ;
112: virtual bool sourceFileExists ( const std :: string & file@var111 ) ;
113: private:
114: bool importSln ( std :: istream & istr@var112 , const std :: string & path@var113 , const std :: vector < std :: string > & fileFilters@var114 ) ;
115: bool importVcxproj ( const std :: string & filename@var115 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var116 , const std :: string & additionalIncludeDirectories@var117 , const std :: vector < std :: string > & fileFilters@var118 ) ;
116: bool importBcb6Prj ( const std :: string & projectFilename@var119 ) ;
117:
118: static void printError ( const std :: string & message@var120 ) ;
119:
120: void setRelativePaths ( const std :: string & filename@var121 ) ;
121:
122: std :: string mPath@var122 ;
123: std :: set < std :: string > mAllVSConfigs@var123 ;
124: } ;
125:
126:
127: namespace CppcheckXml {
128: const char ProjectElementName@var124 [ 8 ] = "project" ;
129: const char ProjectVersionAttrib@var125 [ 8 ] = "version" ;
130: const char ProjectFileVersion@var126 [ 2 ] = "1" ;
131: const char BuildDirElementName@var127 [ 9 ] = "builddir" ;
132: const char ImportProjectElementName@var128 [ 14 ] = "importproject" ;
133: const char AnalyzeAllVsConfigsElementName@var129 [ 23 ] = "analyze-all-vs-configs" ;
134: const char Parser@var130 [ 7 ] = "parser" ;
135: const char BugHunting@var131 [ 12 ] = "bug-hunting" ;
136: const char IncludeDirElementName@var132 [ 11 ] = "includedir" ;
137: const char DirElementName@var133 [ 4 ] = "dir" ;
138: const char DirNameAttrib@var134 [ 5 ] = "name" ;
139: const char DefinesElementName@var135 [ 8 ] = "defines" ;
140: const char DefineName@var136 [ 7 ] = "define" ;
141: const char DefineNameAttrib@var137 [ 5 ] = "name" ;
142: const char UndefinesElementName@var138 [ 10 ] = "undefines" ;
143: const char UndefineName@var139 [ 9 ] = "undefine" ;
144: const char PathsElementName@var140 [ 6 ] = "paths" ;
145: const char PathName@var141 [ 4 ] = "dir" ;
146: const char PathNameAttrib@var142 [ 5 ] = "name" ;
147: const char RootPathName@var143 [ 5 ] = "root" ;
148: const char RootPathNameAttrib@var144 [ 5 ] = "name" ;
149: const char IgnoreElementName@var145 [ 7 ] = "ignore" ;
150: const char IgnorePathName@var146 [ 5 ] = "path" ;
151: const char IgnorePathNameAttrib@var147 [ 5 ] = "name" ;
152: const char ExcludeElementName@var148 [ 8 ] = "exclude" ;
153: const char ExcludePathName@var149 [ 5 ] = "path" ;
154: const char ExcludePathNameAttrib@var150 [ 5 ] = "name" ;
155: const char FunctionContracts@var151 [ 19 ] = "function-contracts" ;
156: const char VariableContractsElementName@var152 [ 19 ] = "variable-contracts" ;
157: const char LibrariesElementName@var153 [ 10 ] = "libraries" ;
158: const char LibraryElementName@var154 [ 8 ] = "library" ;
159: const char PlatformElementName@var155 [ 9 ] = "platform" ;
160: const char SuppressionsElementName@var156 [ 13 ] = "suppressions" ;
161: const char SuppressionElementName@var157 [ 12 ] = "suppression" ;
162: const char AddonElementName@var158 [ 6 ] = "addon" ;
163: const char AddonsElementName@var159 [ 7 ] = "addons" ;
164: const char ToolElementName@var160 [ 5 ] = "tool" ;
165: const char ToolsElementName@var161 [ 6 ] = "tools" ;
166: const char TagsElementName@var162 [ 5 ] = "tags" ;
167: const char TagElementName@var163 [ 4 ] = "tag" ;
168: const char TagWarningsElementName@var164 [ 13 ] = "tag-warnings" ;
169: const char TagAttributeName@var165 [ 4 ] = "tag" ;
170: const char WarningElementName@var166 [ 8 ] = "warning" ;
171: const char HashAttributeName@var167 [ 5 ] = "hash" ;
172: const char CheckHeadersElementName@var168 [ 14 ] = "check-headers" ;
173: const char CheckUnusedTemplatesElementName@var169 [ 23 ] = "check-unused-templates" ;
174: const char MaxCtuDepthElementName@var170 [ 14 ] = "max-ctu-depth" ;
175: const char MaxTemplateRecursionElementName@var171 [ 23 ] = "max-template-recursion" ;
176: const char CheckUnknownFunctionReturn@var172 [ 37 ] = "check-unknown-function-return-values" ;
177: const char ClangTidy@var173 [ 11 ] = "clang-tidy" ;
178: const char Name@var174 [ 5 ] = "name" ;
179: const char VSConfigurationElementName@var175 [ 18 ] = "vs-configurations" ;
180: const char VSConfigurationName@var176 [ 7 ] = "config" ;
181: }

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var177 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var178 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var179 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var180 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var181 , const std :: string & fname2@var182 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var183 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var184 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var185 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var186 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var187 , const std :: vector < std :: string > & basePaths@var188 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var189 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var190 ) {
135: const std ::@expr1073743889 set < std ::@expr1073743890 string > extra@var191 ;
136: return acceptFile (@expr1073743891 filename@var190 , extra@var191 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var192 , const std :: set < std :: string > & extra@var193 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var194 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var195 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var196 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var197 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var198 ) ;
182: } ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var199 , const std :: string & errorMsg@var200 , Type type@var201 = INTERNAL ) ;
38: const Token * token@var202 ;
39: std :: string errorMessage@var203 ;
40: Type type@var204 ;
41: std :: string id@var205 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var206 ) ;
117: static SeverityType fromString ( const std :: string & severity@var207 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var208 ) : id@var209 ( cweId@var208 ) { }
122: unsigned short id@var209 ;
123: } ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var210 ;
42: double mDoubleValue@var211 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var212 ;
44: bool mIsUnsigned@var213 ;
45:
46: void promote ( const value & v@var214 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var215 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var212 !=@expr1073743892 Type ::@expr1073743893 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var212 ==@expr1073743894 Type ::@expr1073743895 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073743896 ) ?@expr1073743897 mDoubleValue@var211 :@expr1073743898 (@expr1073743899 double ) mIntValue@var210 ;
60: }
61:
62: static value calc ( char op@var216 , const value & v1@var217 , const value & v2@var218 ) ;
63: int compare ( const value & v@var219 ) const ;
64: value add ( int v@var220 ) const ;
65: value shiftLeft ( const value & v@var221 ) const ;
66: value shiftRight ( const value & v@var222 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var223 ;
72:
73: static long long toLongNumber ( const std :: string & str@var224 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var225 ) ;
75:
76: template < class T > static std :: string toString ( T value@var226 ) {
77: std ::@expr1073743900 ostringstream result@var227 ;
78: result@var227 <<@expr1073743901 value@var226 ;
79: return result@var227 .@expr1073743902 str (@expr1073743903 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var228 ) ;
82:
83: static bool isInt ( const std :: string & str@var229 ) ;
84: static bool isFloat ( const std :: string & str@var230 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var231 ) ;
86: static bool isNegative ( const std :: string & str@var232 ) ;
87: static bool isPositive ( const std :: string & str@var233 ) ;
88: static bool isDec ( const std :: string & str@var234 ) ;
89: static bool isFloatHex ( const std :: string & str@var235 ) ;
90: static bool isIntHex ( const std :: string & str@var236 ) ;
91: static bool isOct ( const std :: string & str@var237 ) ;
92: static bool isBin ( const std :: string & str@var238 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var239 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var240 , bool supportMicrosoftExtensions@var241 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var242 , const std :: string & second@var243 ) ;
105: static std :: string subtract ( const std :: string & first@var244 , const std :: string & second@var245 ) ;
106: static std :: string multiply ( const std :: string & first@var246 , const std :: string & second@var247 ) ;
107: static std :: string divide ( const std :: string & first@var248 , const std :: string & second@var249 ) ;
108: static std :: string mod ( const std :: string & first@var250 , const std :: string & second@var251 ) ;
109: static std :: string incdec ( const std :: string & var@var252 , const std :: string & op@var253 ) ;
110: static std :: string calculate ( const std :: string & first@var254 , const std :: string & second@var255 , char action@var256 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var257 ) ;
113: static std :: string cos ( const std :: string & tok@var258 ) ;
114: static std :: string tan ( const std :: string & tok@var259 ) ;
115: static std :: string abs ( const std :: string & tok@var260 ) ;
116: static bool isEqual ( const std :: string & first@var261 , const std :: string & second@var262 ) ;
117: static bool isNotEqual ( const std :: string & first@var263 , const std :: string & second@var264 ) ;
118: static bool isGreater ( const std :: string & first@var265 , const std :: string & second@var266 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var267 , const std :: string & second@var268 ) ;
120: static bool isLess ( const std :: string & first@var269 , const std :: string & second@var270 ) ;
121: static bool isLessEqual ( const std :: string & first@var271 , const std :: string & second@var272 ) ;
122: static bool isNullValue ( const std :: string & str@var273 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var274 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var275 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var276 , std :: string :: size_type iPos@var277 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var278 , const MathLib :: value & v2@var279 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var280 , const MathLib :: value & v2@var281 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var282 , const MathLib :: value & v2@var283 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var284 , const MathLib :: value & v2@var285 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var286 , const MathLib :: value & v2@var287 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var288 , const MathLib :: value & v2@var289 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var290 , const MathLib :: value & v2@var291 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var292 , const MathLib :: value & v2@var293 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var294 , const MathLib :: value & v2@var295 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var296 , const MathLib :: value & v2@var297 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var298 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var299 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var300 ;
42:
43:
44: std :: string stdValue@var301 ;
45:
46:
47: Standards ( ) : c@var299 ( CLatest ) , cpp@var300 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var302 ) {
50: stdValue@var301 =@expr1073743904 str@var302 ;
51: if (@expr1073743905 str@var302 ==@expr1073743906 "c89" ||@expr1073743907 str@var302 ==@expr1073743908 "C89" ) {
52: c@var299 =@expr1073743909 C89 ;
53: return true ;
54: }
55: if (@expr1073743910 str@var302 ==@expr1073743911 "c99" ||@expr1073743912 str@var302 ==@expr1073743913 "C99" ) {
56: c@var299 =@expr1073743914 C99 ;
57: return true ;
58: }
59: if (@expr1073743915 str@var302 ==@expr1073743916 "c11" ||@expr1073743917 str@var302 ==@expr1073743918 "C11" ) {
60: c@var299 =@expr1073743919 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073743920 c@var299 ) {
67: case C89 :@expr2097 ;
68: return "c89" ;
69: case C99 :@expr2097 ;
70: return "c99" ;
71: case C11 :@expr2097 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var303 ) {
77: if (@expr1073743924 std@var303 ==@expr1073743925 "c89" ) {
78: return Standards ::@expr1073743926 C89 ;
79: }
80: if (@expr1073743927 std@var303 ==@expr1073743928 "c99" ) {
81: return Standards ::@expr1073743929 C99 ;
82: }
83: if (@expr1073743930 std@var303 ==@expr1073743931 "c11" ) {
84: return Standards ::@expr1073743932 C11 ;
85: }
86: return Standards ::@expr1073743933 CLatest ;
87: }
88: bool setCPP ( std :: string str@var304 ) {
89: stdValue@var301 =@expr1073743934 str@var304 ;
90: strTolower (@expr1073743935 str@var304 ) ;
91: cpp@var300 =@expr1073743936 getCPP (@expr1073743937 str@var304 ) ;
92: return !@expr1073743938 stdValue@var301 .@expr1073743939 empty (@expr1073743940 ) &&@expr1073743941 str@var304 ==@expr1073743942 getCPP (@expr1073743943 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073743944 cpp@var300 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var305 ) {
98: switch (@expr1073743945 std@var305 ) {
99: case CPP03 :@expr2122 ;
100: return "c++03" ;
101: case CPP11 :@expr2122 ;
102: return "c++11" ;
103: case CPP14 :@expr2122 ;
104: return "c++14" ;
105: case CPP17 :@expr2122 ;
106: return "c++17" ;
107: case CPP20 :@expr2122 ;
108: return "c++20" ;
109: case CPP23 :@expr2122 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var306 ) {
115: if (@expr1073743952 std@var306 ==@expr1073743953 "c++03" ) {
116: return Standards ::@expr1073743954 CPP03 ;
117: }
118: if (@expr1073743955 std@var306 ==@expr1073743956 "c++11" ) {
119: return Standards ::@expr1073743957 CPP11 ;
120: }
121: if (@expr1073743958 std@var306 ==@expr1073743959 "c++14" ) {
122: return Standards ::@expr1073743960 CPP14 ;
123: }
124: if (@expr1073743961 std@var306 ==@expr1073743962 "c++17" ) {
125: return Standards ::@expr1073743963 CPP17 ;
126: }
127: if (@expr1073743964 std@var306 ==@expr1073743965 "c++20" ) {
128: return Standards ::@expr1073743966 CPP20 ;
129: }
130: if (@expr1073743967 std@var306 ==@expr1073743968 "c++23" ) {
131: return Standards ::@expr1073743969 CPP23 ;
132: }
133: return Standards ::@expr1073743970 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var310 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var307 ) : errorcode@var310 ( e@var307 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var308 , T && r@var309 ) : errorcode@var310 ( e@var308 ) , reason@var311 ( r@var309 ) { }
66: ErrorCode errorcode@var310 ;
67: std :: string reason@var311 ;
68: } ;
69:
70: Error load ( const char exename@var312 [ ] , const char path@var313 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var314 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var315 [ ] , unsigned long len@var316 ) ;
75:
76: struct AllocFunc {
77: int groupId@var317 ;
78: int arg@var318 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var319 ;
81: int bufferSizeArg1@var320 ;
82: int bufferSizeArg2@var321 ;
83: int reallocArg@var322 ;
84: bool initData@var323 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var324 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var325 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var326 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var327 , int arg@var328 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var329 , int arg@var330 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var331 , int arg@var332 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var333 [ ] ) const {
107: return getAllocDealloc (@expr1073743971 mAlloc@var599 , name@var333 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var334 [ ] ) const {
112: return getAllocDealloc (@expr1073743972 mDealloc@var600 , name@var334 ) ;
113: }
114:
115:
116: int allocId ( const char name@var335 [ ] ) const {
117: const AllocFunc * af@var336 ; af@var336 =@expr1073743973 getAllocDealloc (@expr1073743974 mAlloc@var599 , name@var335 ) ;
118: return af@var336 ?@expr1073743975 af@var336 .@expr1073743976 groupId@var337 :@expr1073743977 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var338 [ ] ) const {
123: const AllocFunc * af@var339 ; af@var339 =@expr1073743978 getAllocDealloc (@expr1073743979 mDealloc@var600 , name@var338 ) ;
124: return af@var339 ?@expr1073743980 af@var339 .@expr1073743981 groupId@var340 :@expr1073743982 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var341 , int id@var342 , int arg@var343 ) {
129: mAlloc@var599 [@expr2159 functionname@var341 ] .@expr1073743984 groupId@var1901 =@expr1073743985 id@var342 ;
130: mAlloc@var599 [@expr2159 functionname@var341 ] .@expr1073743987 arg@var1902 =@expr1073743988 arg@var343 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var344 , int id@var345 , int arg@var346 ) {
134: mDealloc@var600 [@expr2165 functionname@var344 ] .@expr1073743990 groupId@var1903 =@expr1073743991 id@var345 ;
135: mDealloc@var600 [@expr2165 functionname@var344 ] .@expr1073743993 arg@var1904 =@expr1073743994 arg@var346 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var347 , int id@var348 , int arg@var349 , int reallocArg@var350 = 1 ) {
139: mRealloc@var601 [@expr2171 functionname@var347 ] .@expr1073743996 groupId@var1905 =@expr1073743997 id@var348 ;
140: mRealloc@var601 [@expr2171 functionname@var347 ] .@expr1073743999 arg@var1906 =@expr1073744000 arg@var349 ;
141: mRealloc@var601 [@expr2171 functionname@var347 ] .@expr1073744002 reallocArg@var1907 =@expr1073744003 reallocArg@var350 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var351 , bool noreturn@var352 ) {
146: mNoReturn@var602 [@expr1073744004 funcname@var351 ] =@expr1073744005 noreturn@var352 ?@expr1073744006 FalseTrueMaybe ::@expr1073744007 True :@expr1073744008 FalseTrueMaybe ::@expr1073744009 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var353 ) ;
150:
151:
152: static bool ismemory ( const int id@var354 ) {
153: return (@expr2186 (@expr2186 id@var354 >@expr1073744012 0 ) &&@expr1073744013 (@expr2186 (@expr2186 id@var354 &@expr1073744016 1 ) ==@expr1073744017 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var355 ) {
156: return (@expr2194 (@expr2194 func@var355 .@expr2196 groupId@var356 >@expr1073744021 0 ) &&@expr1073744022 (@expr2194 (@expr2194 func@var355 .@expr2196 groupId@var356 &@expr1073744026 1 ) ==@expr1073744027 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var357 ) {
161: return (@expr2204 (@expr2204 id@var357 >@expr1073744030 0 ) &&@expr1073744031 (@expr2204 (@expr2204 id@var357 &@expr1073744034 1 ) ==@expr1073744035 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var358 ) {
164: return (@expr2212 (@expr2212 func@var358 .@expr2214 groupId@var359 >@expr1073744039 0 ) &&@expr1073744040 (@expr2212 (@expr2212 func@var358 .@expr2214 groupId@var359 &@expr1073744044 1 ) ==@expr1073744045 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var360 ) const ;
168: int formatstr_argno ( const Token * ftok@var361 ) const ;
169: bool formatstr_scan ( const Token * ftok@var362 ) const ;
170: bool formatstr_secure ( const Token * ftok@var363 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var364 ;
174: int ptr2Arg@var365 ;
175: int sizeArg@var366 ;
176: int strlenArg@var367 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var368 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var369 ;
182: Standards standards@var370 ;
183: Severity :: SeverityType severity@var371 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var372 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var373 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var374 ) const ;
191: bool matchArguments ( const Token * ftok@var375 , const std :: string & functionName@var376 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var377 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var378 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var379 ) const ;
198: int returnValueContainer ( const Token * ftok@var380 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var381 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var382 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var383 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var384 , std :: string * unknownFunc@var385 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var395 ( -1 ) ,
210: size_templateArgNo@var397 ( -1 ) ,
211: arrayLike_indexOp@var398 ( false ) ,
212: stdStringLike@var399 ( false ) ,
213: stdAssociativeLike@var400 ( false ) ,
214: opLessAllowed@var401 ( true ) ,
215: hasInitializerListConstructor@var402 ( false ) ,
216: unstableErase@var403 ( false ) ,
217: unstableInsert@var404 ( false ) ,
218: view@var405 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var386 ;
248: Yield yield@var387 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var388 ;
252: int templateParameter@var389 ;
253: } ;
254: std :: string startPattern@var390 ; std :: string startPattern2@var391 ; std :: string endPattern@var392 ; std :: string itEndPattern@var393 ;
255: std :: map < std :: string , Function > functions@var394 ;
256: int type_templateArgNo@var395 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var396 ;
258: int size_templateArgNo@var397 ;
259: bool arrayLike_indexOp@var398 ;
260: bool stdStringLike@var399 ;
261: bool stdAssociativeLike@var400 ;
262: bool opLessAllowed@var401 ;
263: bool hasInitializerListConstructor@var402 ;
264: bool unstableErase@var403 ;
265: bool unstableInsert@var404 ;
266: bool view@var405 ;
267:
268: Action getAction ( const std :: string & function@var406 ) const {
269: const std ::@expr1073744046 map < std ::@expr1073744047 string , Function > ::@expr1073744048 const_iterator i@var407 =@expr1073744049 functions@var394 .@expr1073744050 find (@expr1073744051 function@var406 ) ;
270: if (@expr1073744052 i@var407 !=@expr1073744053 functions@var394 .@expr1073744054 end (@expr1073744055 ) ) {
271: return i@var407 .@expr1073744056 second@var408 .@expr1073744057 action@var409 ; }
272: return Action ::@expr1073744058 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var410 ) const {
276: const std ::@expr1073744059 map < std ::@expr1073744060 string , Function > ::@expr1073744061 const_iterator i@var411 =@expr1073744062 functions@var394 .@expr1073744063 find (@expr1073744064 function@var410 ) ;
277: if (@expr1073744065 i@var411 !=@expr1073744066 functions@var394 .@expr1073744067 end (@expr1073744068 ) ) {
278: return i@var411 .@expr1073744069 second@var412 .@expr1073744070 yield@var413 ; }
279: return Yield ::@expr1073744071 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var414 ) ;
283: static Action actionFrom ( const std :: string & actionName@var415 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var416 ;
286: const Container * detectContainer ( const Token * typeStart@var417 , bool iterator@var418 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var419 , bool * isIterator@var420 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var421 ( false ) ,
293: notnull@var422 ( false ) ,
294: notuninit@var423 ( -1 ) ,
295: formatstr@var424 ( false ) ,
296: strz@var425 ( false ) ,
297: optional@var426 ( false ) ,
298: variadic@var427 ( false ) ,
299: iteratorInfo@var433 ( ) ,
300: direction@var441 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var421 ;
303: bool notnull@var422 ;
304: int notuninit@var423 ;
305: bool formatstr@var424 ;
306: bool strz@var425 ;
307: bool optional@var426 ;
308: bool variadic@var427 ;
309: std :: string valid@var428 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var429 ( 0 ) , it@var430 ( false ) , first@var431 ( false ) , last@var432 ( false ) { }
314:
315: int container@var429 ;
316: bool it@var430 ;
317: bool first@var431 ;
318: bool last@var432 ;
319: } ;
320: IteratorInfo iteratorInfo@var433 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var434 , int a@var435 ) : type@var436 ( t@var434 ) , arg@var437 ( a@var435 ) , arg2@var438 ( 0 ) , value@var439 ( 0 ) { }
326: Type type@var436 ;
327: int arg@var437 ;
328: int arg2@var438 ;
329: long long value@var439 ;
330: } ;
331: std :: vector < MinSize > minsizes@var440 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var441 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var442 ;
344: bool use@var443 ;
345: bool leakignore@var444 ;
346: bool isconst@var445 ;
347: bool ispure@var446 ;
348: UseRetValType useretval@var447 ;
349: bool ignore@var448 ;
350: bool formatstr@var449 ;
351: bool formatstr_scan@var450 ;
352: bool formatstr_secure@var451 ;
353: Container :: Action containerAction@var452 ;
354: Container :: Yield containerYield@var453 ;
355: Function ( )
356: : use@var443 ( false ) ,
357: leakignore@var444 ( false ) ,
358: isconst@var445 ( false ) ,
359: ispure@var446 ( false ) ,
360: useretval@var447 ( UseRetValType :: NONE ) ,
361: ignore@var448 ( false ) ,
362: formatstr@var449 ( false ) ,
363: formatstr_scan@var450 ( false ) ,
364: formatstr_secure@var451 ( false ) ,
365: containerAction@var452 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var453 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var454 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var455 ;
372: bool isUse ( const std :: string & functionName@var456 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var457 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var458 , bool pure@var459 ) const ;
375: bool isFunctionConst ( const Token * ftok@var460 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var461 , int argnr@var462 ) const {
378: const ArgumentChecks * arg@var463 ; arg@var463 =@expr1073744072 getarg (@expr1073744073 ftok@var461 , argnr@var462 ) ;
379: return arg@var463 &&@expr1073744074 arg@var463 .@expr1073744075 notbool@var464 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var465 , int argnr@var466 ) const ;
383: bool isuninitargbad ( const Token * ftok@var467 , int argnr@var468 , int indirect@var469 = 0 , bool * hasIndirect@var470 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var471 , int argnr@var472 ) const {
386: const ArgumentChecks * arg@var473 ; arg@var473 =@expr1073744076 getarg (@expr1073744077 ftok@var471 , argnr@var472 ) ;
387: return arg@var473 &&@expr1073744078 arg@var473 .@expr1073744079 formatstr@var474 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var475 , int argnr@var476 ) const {
391: const ArgumentChecks * arg@var477 ; arg@var477 =@expr1073744080 getarg (@expr1073744081 ftok@var475 , argnr@var476 ) ;
392: return arg@var477 &&@expr1073744082 arg@var477 .@expr1073744083 strz@var478 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var479 , int argnr@var480 , const long long argvalue@var481 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var482 , int argnr@var483 , double argvalue@var484 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var485 , int argnr@var486 ) const {
399: const ArgumentChecks * arg@var487 ; arg@var487 =@expr1073744084 getarg (@expr1073744085 ftok@var485 , argnr@var486 ) ;
400: return arg@var487 ?@expr1073744086 arg@var487 .@expr1073744087 valid@var488 :@expr1073744088 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var489 ;
405: std :: string op1@var490 ;
406: std :: string op2@var491 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744089 isInt (@expr1073744090 op1@var490 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var492 , int argnr@var493 ) const {
413: const ArgumentChecks * arg@var494 ; arg@var494 =@expr1073744091 getarg (@expr1073744092 ftok@var492 , argnr@var493 ) ;
414: return arg@var494 &&@expr1073744093 arg@var494 .@expr2270 iteratorInfo@var495 .@expr1073744095 it@var496 ?@expr1073744096 &@expr1073744097 arg@var494 .@expr2270 iteratorInfo@var495 :@expr1073744099 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var497 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var498 , int argnr@var499 ) const {
420: const ArgumentChecks * arg@var500 ; arg@var500 =@expr1073744100 getarg (@expr1073744101 ftok@var498 , argnr@var499 ) ;
421: return arg@var500 ?@expr1073744102 &@expr1073744103 arg@var500 .@expr1073744104 minsizes@var501 :@expr1073744105 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var502 , int argnr@var503 ) const ;
425:
426: bool markupFile ( const std :: string & path@var504 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var505 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var609 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var506 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var507 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var508 , const std :: string & token@var509 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var510 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var511 ) const ;
443: const std :: string & blockend ( const std :: string & file@var512 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var513 , const std :: string & keyword@var514 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var515 ) const {
448: return mExporters@var612 .@expr1073744106 find (@expr1073744107 prefix@var515 ) !=@expr1073744108 mExporters@var612 .@expr1073744109 end (@expr1073744110 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var516 , const std :: string & token@var517 ) const {
452: const std ::@expr1073744111 map < std ::@expr1073744112 string , ExportedFunctions > ::@expr1073744113 const_iterator it@var518 =@expr1073744114 mExporters@var612 .@expr1073744115 find (@expr1073744116 prefix@var516 ) ;
453: return (@expr1073744117 it@var518 !=@expr1073744118 mExporters@var612 .@expr1073744119 end (@expr1073744120 ) &&@expr1073744121 it@var518 .@expr1073744122 second@var519 .@expr1073744123 isPrefix (@expr1073744124 token@var517 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var520 , const std :: string & token@var521 ) const {
457: const std ::@expr1073744125 map < std ::@expr1073744126 string , ExportedFunctions > ::@expr1073744127 const_iterator it@var522 =@expr1073744128 mExporters@var612 .@expr1073744129 find (@expr1073744130 prefix@var520 ) ;
458: return (@expr1073744131 it@var522 !=@expr1073744132 mExporters@var612 .@expr1073744133 end (@expr1073744134 ) &&@expr1073744135 it@var522 .@expr1073744136 second@var523 .@expr1073744137 isSuffix (@expr1073744138 token@var521 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var524 , const std :: string & importer@var525 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var526 , Container :: Yield yield@var527 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var528 , Container :: Action action@var529 ) const ;
465:
466: bool isreflection ( const std :: string & token@var530 ) const {
467: return mReflection@var614 .@expr1073744139 find (@expr1073744140 token@var530 ) !=@expr1073744141 mReflection@var614 .@expr1073744142 end (@expr1073744143 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var531 ) const {
471: const std ::@expr1073744144 map < std ::@expr1073744145 string , int > ::@expr1073744146 const_iterator it@var532 =@expr1073744147 mReflection@var614 .@expr1073744148 find (@expr1073744149 token@var531 ) ;
472: if (@expr1073744150 it@var532 !=@expr1073744151 mReflection@var614 .@expr1073744152 end (@expr1073744153 ) ) {
473: return it@var532 .@expr1073744154 second@var533 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var534 ;
478:
479: struct SmartPointer {
480: std :: string name@var535 ; name@var535 = "" ;
481: bool unique@var536 ; unique@var536 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var537 ;
485: bool isSmartPointer ( const Token * tok@var538 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var539 ) const ;
487:
488: struct PodType {
489: unsigned int size@var540 ;
490: char sign@var541 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var542 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var543 ) const {
494: const std ::@expr1073744155 unordered_map < std ::@expr1073744156 string , PodType > ::@expr1073744157 const_iterator it@var544 =@expr1073744158 mPodTypes@var615 .@expr1073744159 find (@expr1073744160 name@var543 ) ;
495: return (@expr2337 it@var544 !=@expr1073744162 mPodTypes@var615 .@expr1073744163 end (@expr1073744164 ) ) ?@expr1073744165 &@expr1073744166 (@expr2337 it@var544 .@expr1073744168 second@var545 ) :@expr1073744169 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var556 ( false )
501: , mUnsigned@var557 ( false )
502: , mLong@var558 ( false )
503: , mPointer@var559 ( false )
504: , mPtrPtr@var560 ( false )
505: , mConstPtr@var561 ( false ) { }
506: bool operator== ( const PlatformType & type@var546 ) const {
507: return (@expr1073744170 mSigned@var556 ==@expr1073744171 type@var546 .@expr1073744172 mSigned@var547 &&@expr1073744173
508: mUnsigned@var557 ==@expr1073744174 type@var546 .@expr1073744175 mUnsigned@var548 &&@expr1073744176
509: mLong@var558 ==@expr1073744177 type@var546 .@expr1073744178 mLong@var549 &&@expr1073744179
510: mPointer@var559 ==@expr1073744180 type@var546 .@expr1073744181 mPointer@var550 &&@expr1073744182
511: mPtrPtr@var560 ==@expr1073744183 type@var546 .@expr1073744184 mPtrPtr@var551 &&@expr1073744185
512: mConstPtr@var561 ==@expr1073744186 type@var546 .@expr1073744187 mConstPtr@var552 &&@expr1073744188
513: mType@var555 ==@expr1073744189 type@var546 .@expr1073744190 mType@var553 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var554 ) const {
516: return !@expr1073744191 (@expr1073744192 *@expr1073744193 this@expr1073744194 ==@expr1073744195 type@var554 ) ;
517: }
518: std :: string mType@var555 ;
519: bool mSigned@var556 ;
520: bool mUnsigned@var557 ;
521: bool mLong@var558 ;
522: bool mPointer@var559 ;
523: bool mPtrPtr@var560 ;
524: bool mConstPtr@var561 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var562 ) const {
529: const std ::@expr1073744196 map < std ::@expr1073744197 string , PlatformType > ::@expr1073744198 const_iterator it@var563 =@expr1073744199 mPlatformTypes@var565 .@expr1073744200 find (@expr1073744201 name@var562 ) ;
530: return (@expr2378 it@var563 !=@expr1073744203 mPlatformTypes@var565 .@expr1073744204 end (@expr1073744205 ) ) ?@expr1073744206 &@expr1073744207 (@expr2378 it@var563 .@expr1073744209 second@var564 ) :@expr1073744210 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var565 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var566 , const std :: string & platform@var567 ) const {
536: const std ::@expr1073744211 map < std ::@expr2388 string , Platform > ::@expr1073744213 const_iterator it@var568 =@expr1073744214 mPlatforms@var617 .@expr1073744215 find (@expr1073744216 platform@var567 ) ;
537: if (@expr1073744217 it@var568 !=@expr1073744218 mPlatforms@var617 .@expr1073744219 end (@expr1073744220 ) ) {
538: const PlatformType * const type@var569 ; type@var569 =@expr1073744221 it@var568 .@expr1073744222 second@var570 .@expr1073744223 platform_type (@expr1073744224 name@var566 ) ;
539: if (@expr1073744225 type@var569 ) {
540: return type@var569 ; }
541: }
542:
543: const std ::@expr1073744226 map < std ::@expr2388 string , PlatformType > ::@expr1073744228 const_iterator it2@var571 =@expr1073744229 mPlatformTypes@var616 .@expr1073744230 find (@expr1073744231 name@var566 ) ;
544: return (@expr2408 it2@var571 !=@expr1073744233 mPlatformTypes@var616 .@expr1073744234 end (@expr1073744235 ) ) ?@expr1073744236 &@expr1073744237 (@expr2408 it2@var571 .@expr1073744239 second@var572 ) :@expr1073744240 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var573 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var574 , Library :: Container :: Yield y@var575 , const std :: string & fallback@var576 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var577 , const std :: string & typeName@var578 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var579 , const std :: string & name@var580 , std :: set < std :: string > & unknown_elements@var581 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var582 ) {
565: mPrefixes@var586 .@expr1073744241 insert (@expr1073744242 prefix@var582 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var583 ) {
568: mSuffixes@var587 .@expr1073744243 insert (@expr1073744244 suffix@var583 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var584 ) const {
571: return (@expr1073744245 mPrefixes@var586 .@expr1073744246 find (@expr1073744247 prefix@var584 ) !=@expr1073744248 mPrefixes@var586 .@expr1073744249 end (@expr1073744250 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var585 ) const {
574: return (@expr1073744251 mSuffixes@var587 .@expr1073744252 find (@expr1073744253 suffix@var585 ) !=@expr1073744254 mSuffixes@var587 .@expr1073744255 end (@expr1073744256 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var586 ;
579: std :: set < std :: string > mSuffixes@var587 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var595 ( 0 ) { }
584:
585: void setStart ( const char * s@var588 ) {
586: mStart@var593 =@expr1073744257 s@var588 ;
587: }
588: void setEnd ( const char * e@var589 ) {
589: mEnd@var594 =@expr1073744258 e@var589 ;
590: }
591: void setOffset ( const int o@var590 ) {
592: mOffset@var595 =@expr1073744259 o@var590 ;
593: }
594: void addBlock ( const char * blockName@var591 ) {
595: mBlocks@var596 .@expr1073744260 insert (@expr1073744261 blockName@var591 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var593 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var594 ;
602: }
603: int offset ( ) const {
604: return mOffset@var595 ;
605: }
606: bool isBlock ( const std :: string & blockName@var592 ) const {
607: return mBlocks@var596 .@expr1073744262 find (@expr1073744263 blockName@var592 ) !=@expr1073744264 mBlocks@var596 .@expr1073744265 end (@expr1073744266 ) ;
608: }
609:
610: private:
611: std :: string mStart@var593 ;
612: std :: string mEnd@var594 ;
613: int mOffset@var595 ;
614: std :: set < std :: string > mBlocks@var596 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var597 ;
618: std :: set < std :: string > mFiles@var598 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var599 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var600 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var601 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var602 ;
623: std :: map < std :: string , std :: string > mReturnValue@var603 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var604 ;
625: std :: map < std :: string , int > mReturnValueContainer@var605 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var606 ;
627: std :: map < std :: string , bool > mReportErrors@var607 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var608 ;
629: std :: set < std :: string > mMarkupExtensions@var609 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var610 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var611 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var612 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var613 ;
634: std :: map < std :: string , int > mReflection@var614 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var615 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var616 ;
637: std :: map < std :: string , Platform > mPlatforms@var617 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var618 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var619 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var620 , int argnr@var621 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var622 , bool * error@var623 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var624 , const std :: string & name@var625 ) {
646: const std ::@expr1073744267 map < std ::@expr1073744268 string , AllocFunc > ::@expr1073744269 const_iterator it@var626 =@expr1073744270 data@var624 .@expr1073744271 find (@expr1073744272 name@var625 ) ;
647: return (@expr1073744273 it@var626 ==@expr1073744274 data@var624 .@expr1073744275 end (@expr1073744276 ) ) ?@expr1073744277 nullptr :@expr1073744278 &@expr1073744279 it@var626 .@expr1073744280 second@var627 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var628 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var629 ,
654: const Settings * settings@var630 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var631 = nullptr ) ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var632 ;
43: std :: string errorId@var633 ;
44: void setFileName ( const std :: string & s@var634 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var638 ;
47: }
48: int lineNumber@var635 ;
49: Certainty :: CertaintyLevel certainty@var636 ;
50: std :: string symbolNames@var637 ;
51: private:
52: std :: string mFileName@var638 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var672 ( NO_LINE ) , hash@var674 ( 0 ) , thisAndNextLine@var675 ( false ) , matched@var676 ( false ) , checked@var677 ( false ) { }
57: Suppression ( const Suppression & other@var639 ) {
58: *@expr1073744281 this@expr1073744282 =@expr1073744283 other@var639 ;
59: }
60: Suppression ( const std :: string & id@var640 , const std :: string & file@var641 , int line@var642 = NO_LINE ) : errorId@var670 ( id@var640 ) , fileName@var671 ( file@var641 ) , lineNumber@var672 ( line@var642 ) , hash@var674 ( 0 ) , thisAndNextLine@var675 ( false ) , matched@var676 ( false ) , checked@var677 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var643 ) {
63: errorId@var670 =@expr1073744284 other@var643 .@expr1073744285 errorId@var644 ;
64: fileName@var671 =@expr1073744286 other@var643 .@expr1073744287 fileName@var645 ;
65: lineNumber@var672 =@expr1073744288 other@var643 .@expr1073744289 lineNumber@var646 ;
66: symbolName@var673 =@expr1073744290 other@var643 .@expr1073744291 symbolName@var647 ;
67: hash@var674 =@expr1073744292 other@var643 .@expr1073744293 hash@var648 ;
68: thisAndNextLine@var675 =@expr1073744294 other@var643 .@expr1073744295 thisAndNextLine@var649 ;
69: matched@var676 =@expr1073744296 other@var643 .@expr1073744297 matched@var650 ;
70: checked@var677 =@expr1073744298 other@var643 .@expr1073744299 checked@var651 ;
71: return *@expr1073744300 this@expr1073744301 ;
72: }
73:
74: bool operator< ( const Suppression & other@var652 ) const {
75: if (@expr1073744302 errorId@var670 !=@expr1073744303 other@var652 .@expr2480 errorId@var653 ) {
76: return errorId@var670 <@expr1073744305 other@var652 .@expr2480 errorId@var653 ; }
77: if (@expr1073744307 lineNumber@var672 <@expr1073744308 other@var652 .@expr1073744309 lineNumber@var654 ) {
78: return true ; }
79: if (@expr1073744310 fileName@var671 !=@expr1073744311 other@var652 .@expr2488 fileName@var655 ) {
80: return fileName@var671 <@expr1073744313 other@var652 .@expr2488 fileName@var655 ; }
81: if (@expr1073744315 symbolName@var673 !=@expr1073744316 other@var652 .@expr2493 symbolName@var656 ) {
82: return symbolName@var673 <@expr1073744318 other@var652 .@expr2493 symbolName@var656 ; }
83: if (@expr1073744320 hash@var674 !=@expr1073744321 other@var652 .@expr2498 hash@var657 ) {
84: return hash@var674 <@expr1073744323 other@var652 .@expr2498 hash@var657 ; }
85: if (@expr1073744325 thisAndNextLine@var675 !=@expr1073744326 other@var652 .@expr1073744327 thisAndNextLine@var658 ) {
86: return thisAndNextLine@var675 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var659 , std :: string * errorMessage@var660 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var661 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var662 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073744329 fileName@var671 .@expr1073744330 empty (@expr1073744331 ) &&@expr1073744332 fileName@var671 .@expr1073744333 find_first_of (@expr1073744334 "?*" ) ==@expr1073744335 std ::@expr1073744336 string ::@expr1073744337 npos@expr1073744328 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var663 ) const {
109: return errorId@var670 ==@expr1073744338 other@var663 .@expr1073744339 errorId@var664 &&@expr1073744340
110: fileName@var671 ==@expr1073744341 other@var663 .@expr1073744342 fileName@var665 &&@expr1073744343
111: lineNumber@var672 ==@expr1073744344 other@var663 .@expr1073744345 lineNumber@var666 &&@expr1073744346
112: symbolName@var673 ==@expr1073744347 other@var663 .@expr1073744348 symbolName@var667 &&@expr1073744349
113: hash@var674 ==@expr1073744350 other@var663 .@expr1073744351 hash@var668 &&@expr1073744352
114: thisAndNextLine@var675 ==@expr1073744353 other@var663 .@expr1073744354 thisAndNextLine@var669 ;
115: }
116:
117: std :: string errorId@var670 ;
118: std :: string fileName@var671 ;
119: int lineNumber@var672 ;
120: std :: string symbolName@var673 ;
121: unsigned long hash@var674 ;
122: bool thisAndNextLine@var675 ;
123: bool matched@var676 ;
124: bool checked@var677 ;
125:
126: enum Anonymous1 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var678 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var679 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var680 , std :: string * errorMessage@var681 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var682 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var683 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var684 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var685 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var686 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var687 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var688 , const bool unusedFunctionChecking@var689 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var690 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var691 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var692 ;
219: } ;

##file cppcheck-2.8/lib/timer.h

1:
|
28:
29: enum class SHOWTIME_MODES {
30: SHOWTIME_NONE = 0 ,
31: SHOWTIME_FILE ,
32: SHOWTIME_SUMMARY ,
33: SHOWTIME_TOP5
34: } ;
35:
36: class TimerResultsIntf {
37: public:
38: virtual ~ TimerResultsIntf ( ) { }
39:
40: virtual void addResults ( const std :: string & str@var693 , std :: clock_t clocks@var694 ) = 0 ;
41: } ;
42:
43: struct TimerResultsData {
44: std :: clock_t mClocks@var695 ;
45: long mNumberOfResults@var696 ;
46:
47: TimerResultsData ( )
48: : mClocks@var695 ( 0 )
49: , mNumberOfResults@var696 ( 0 ) { }
50:
51: double seconds ( ) const {
52: const double ret@var697 =@expr1073744356 (@expr1073744357 double ) (@expr1073744358 (@expr1073744359 unsigned long ) mClocks@var695 ) /@expr1073744360 (@expr1073744361 double ) CLOCKS_PER_SEC@expr1073744355 ;
53: return ret@var697 ;
54: }
55: } ;
56:
57: class TimerResults : public TimerResultsIntf {
58: public:
59: TimerResults ( ) { }
60:
61: void showResults ( SHOWTIME_MODES mode@var698 ) const ;
62: void addResults ( const std :: string & str@var699 , std :: clock_t clocks@var700 ) override ;
63:
64: private:
65: std :: map < std :: string , TimerResultsData > mResults@var701 ;
66: } ;
67:
68: class Timer {
69: public:
70: Timer ( const std :: string & str@var702 , SHOWTIME_MODES showtimeMode@var703 , TimerResultsIntf * timerResults@var704 = nullptr ) ;
71: ~ Timer ( ) ;
72: void stop ( ) ;
73:
74: private:
75: Timer ( const Timer & other@var705 ) ;
76: Timer & operator= ( const Timer & ) ;
77:
78: const std :: string mStr@var706 ;
79: TimerResultsIntf * mTimerResults@var707 ;
80: std :: clock_t mStart@var708 ;
81: const SHOWTIME_MODES mShowTimeMode@var709 ;
82: bool mStopped@var710 ;
83: } ;

##file cppcheck-2.8/lib/settings.h

1:
|
40:
41: namespace ValueFlow {
42: class Value ;
43: }
44:
|
47:
48: class SimpleEnableGroup<Severity::SeverityType> ; class SimpleEnableGroup<Certainty::CertaintyLevel> ; class SimpleEnableGroup<Checks::CheckList> ;
49:
|
89:
90: class Settings : public cppcheck :: Platform {
91: private:
92:
93:
94: static std :: atomic < bool > mTerminated@var711 ;
95:
96: public:
97: Settings ( ) ;
98:
99: void loadCppcheckCfg ( ) ;
100:
101:
102: std :: list < std :: string > addons@var712 ;
103:
104:
105: std :: string addonPython@var713 ;
106:
107:
108: std :: vector < std :: string > basePaths@var714 ;
109:
110:
111: std :: string buildDir@var715 ;
112:
113:
114: bool checkAllConfigurations@var716 ;
115:
116:
117: bool checkConfiguration@var717 ;
118:
|
121:
122: bool checkHeaders@var718 ;
123:
124:
125: bool checkLibrary@var719 ;
126:
127:
128: std :: set < std :: string > checkUnknownFunctionReturn@var720 ;
129:
130:
131: bool checkUnusedTemplates@var721 ;
132:
133:
134: bool clang@var722 ;
135:
136:
137: std :: string clangExecutable@var723 ;
138:
139:
140: bool clangTidy@var724 ;
141:
142:
143: std :: set < std :: string > configExcludePaths@var725 ;
144:
145:
146: std :: string cppcheckCfgProductName@var726 ;
147:
148:
149: std :: string cppcheckCfgAbout@var727 ;
150:
151:
152: bool daca@var728 ;
153:
154:
155: bool debugnormal@var729 ;
156:
157:
158: bool debugSimplified@var730 ;
159:
160:
161: bool debugtemplate@var731 ;
162:
163:
164: bool debugwarnings@var732 ;
165:
166:
167: bool dump@var733 ;
168: std :: string dumpFile@var734 ;
169:
170: enum Language {
171: None , C , CPP
172: } ;
173:
174:
175: Language enforcedLang@var735 ;
176:
177:
178: bool exceptionHandling@var736 ;
179:
180:
181: std :: string exename@var737 ;
182:
183:
184:
185: int exitCode@var738 ;
186:
187:
188: std :: vector < std :: string > fileFilters@var739 ;
189:
190:
191: bool force@var740 ;
192:
193:
194:
195: std :: list < std :: string > includePaths@var741 ;
196:
197:
198: bool inlineSuppressions@var742 ;
199:
200:
201:
202: unsigned int jobs@var743 ;
203:
|
206:
207: bool jointSuppressionReport@var744 ;
208:
209:
210: std :: list < std :: string > libraries@var745 ;
211:
212:
213: Library library@var746 ;
214:
215:
216:
217: int loadAverage@var747 ;
218:
|
221:
222: int maxConfigs@var748 ;
223:
224:
225: int maxCtuDepth@var749 ;
226:
227:
228: int maxTemplateRecursion@var750 ;
229:
230:
231: Suppressions nofail@var751 ;
232:
233:
234: Suppressions nomsg@var752 ;
235:
236:
237: std :: string outputFile@var753 ;
238:
239:
240: std :: string plistOutput@var754 ;
241:
242:
243: bool preprocessOnly@var755 ;
244:
245: ImportProject project@var756 ;
246:
247:
248: bool quiet@var757 ;
249:
250:
251: bool relativePaths@var758 ;
252:
253:
254: bool reportProgress@var759 ;
255:
256:
257: class Rule {
258: public:
259: Rule ( )
260: : tokenlist@var760 ( "simple" )
261: , id@var762 ( "rule" )
262: , severity@var764 ( Severity :: style ) {
263: }
264:
265: std :: string tokenlist@var760 ;
266: std :: string pattern@var761 ;
267: std :: string id@var762 ;
268: std :: string summary@var763 ;
269: Severity :: SeverityType severity@var764 ;
270: } ;
271:
|
274:
275: std :: list < Rule > rules@var765 ;
276:
277:
278: class SafeChecks {
279: public:
280: SafeChecks ( ) : classes@var771 ( false ) , externalFunctions@var772 ( false ) , internalFunctions@var773 ( false ) , externalVariables@var774 ( false ) { }
281:
282: static const char XmlRootName@var766 [ ] ;
283: static const char XmlClasses@var767 [ ] ;
284: static const char XmlExternalFunctions@var768 [ ] ;
285: static const char XmlInternalFunctions@var769 [ ] ;
286: static const char XmlExternalVariables@var770 [ ] ;
287:
288: void clear ( ) {
289: classes@var771 =@expr1073744362 externalFunctions@var772 =@expr1073744363 internalFunctions@var773 =@expr1073744364 externalVariables@var774 =@expr1073744365 false ;
290: }
291:
|
297:
298: bool classes@var771 ;
299:
|
304:
305: bool externalFunctions@var772 ;
306:
|
310:
311: bool internalFunctions@var773 ;
312:
|
316:
317: bool externalVariables@var774 ;
318: } ;
319:
320: SafeChecks safeChecks@var775 ;
321:
322: SimpleEnableGroup<Severity::SeverityType> severity@var776 ;
323: SimpleEnableGroup<Certainty::CertaintyLevel> certainty@var777 ;
324: SimpleEnableGroup<Checks::CheckList> checks@var778 ;
325:
326:
327: SHOWTIME_MODES showtime@var779 ;
328:
329:
330: Standards standards@var780 ;
331:
332:
333:
334: std :: string templateFormat@var781 ;
335:
336:
337:
338: std :: string templateLocation@var782 ;
339:
340:
341: std :: string userDefines@var783 ;
342:
343:
344: std :: set < std :: string > userUndefs@var784 ;
345:
346:
347: std :: list < std :: string > userIncludes@var785 ;
348:
349:
350: bool verbose@var786 ;
351:
352:
353: bool xml@var787 ;
354:
355:
356: int xml_version@var788 ;
357:
|
361:
362: bool configurationExcluded ( const std :: string & file@var789 ) const {
363: for (@expr1073744366 const std ::@expr1073744367 string &@expr1073744368 configExcludePath@var790 :@expr1073744369 configExcludePaths@var725 ) {
364: if (@expr1073744370 file@var789 .@expr1073744371 length (@expr1073744372 ) >=@expr1073744373 configExcludePath@var790 .@expr2550 length (@expr2551 ) &&@expr1073744376 file@var789 .@expr1073744377 compare (@expr1073744378 0 , configExcludePath@var790 .@expr2550 length (@expr2551 ) , configExcludePath@var790 ) ==@expr1073744381 0 ) {
365: return true ;
366: }
367: }
368: return false ;
369: }
370:
|
376:
377: std :: string addEnabled ( const std :: string & str@var791 ) ;
378:
|
382:
383: bool isEnabled ( const ValueFlow :: Value * value@var792 , bool inconclusiveCheck@var793 = false ) const ;
384:
385:
386: bool posix ( ) const {
387: return std ::@expr1073744382 find (@expr1073744383 libraries@var745 .@expr1073744384 begin (@expr1073744385 ) , libraries@var745 .@expr2562 end (@expr2563 ) , "posix" ) !=@expr1073744388 libraries@var745 .@expr2562 end (@expr2563 ) ;
388: }
389:
390:
391: static void terminate ( bool t@var794 = true ) {
392: Settings ::@expr1073744391 mTerminated@var711 =@expr1073744392 t@var794 ;
393: }
394:
395:
396: static bool terminated ( ) {
397: return Settings ::@expr1073744393 mTerminated@var711 ;
398: }
399:
400: std :: set < std :: string > summaryReturn@var795 ;
401:
402: void loadSummaries ( ) ;
403: } ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var796 ) const {
54: x@var796 ++@expr1073744394 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var797 ) const {
60: x@var797 --@expr1073744395 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var798 , const U & y@var799 ) const {
67: return x@var798 <@expr1073744396 y@var799 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var800 , const U & y@var801 ) const {
74: return std ::@expr1073744397 abs (@expr1073744398 x@var800 -@expr1073744399 y@var801 ) ==@expr1073744400 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var802 , T x@var803 , U y@var804 ) const {
81: result@var802 =@expr1073744401 !@expr1073744402 (@expr1073744403 x@var803 >@expr1073744404 y@var804 ||@expr1073744405 x@var803 <@expr1073744406 y@var804 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var805 = 0 , Bound b@var806 = Bound :: Point )
91: : valueType@var846 ( ValueType :: INT ) ,
92: bound@var847 ( b@var806 ) ,
93: intvalue@var848 ( val@var805 ) ,
94: tokvalue@var849 ( nullptr ) ,
95: floatValue@var850 ( 0.0 ) ,
96: moveKind@var851 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var852 ( val@var805 ) ,
98: condition@var853 ( nullptr ) ,
99: varId@var855 ( 0U ) ,
100: safe@var856 ( false ) ,
101: conditional@var857 ( false ) ,
102: macro@var858 ( false ) ,
103: defaultArg@var859 ( false ) ,
104: indirect@var860 ( 0 ) ,
105: path@var861 ( 0 ) ,
106: wideintvalue@var862 ( val@var805 ) ,
107: subexpressions@var863 ( ) ,
108: capturetok@var864 ( nullptr ) ,
109: lifetimeKind@var865 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var866 ( LifetimeScope :: Local ) ,
111: valueKind@var871 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var807 , long long val@var808 , Bound b@var809 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var810 ) const {
118: if (@expr1073744407 valueType@var846 !=@expr1073744408 rhs@var810 .@expr1073744409 valueType@var811 ) {
119: return false ; }
120: switch (@expr1073744410 valueType@var846 ) {
121: case ValueType ::@expr1073744411 INT :@expr2588
122: case ValueType ::@expr1073744413 CONTAINER_SIZE :@expr2588
123: case ValueType ::@expr1073744415 BUFFER_SIZE :@expr2588
124: case ValueType ::@expr1073744417 ITERATOR_START :@expr2588
125: case ValueType ::@expr1073744419 ITERATOR_END :@expr2588 ;
126: if (@expr2597 intvalue@var848 !=@expr2598 rhs@var810 .@expr2599 intvalue@var812 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744424 TOK :@expr2588 ;
130: if (@expr2602 tokvalue@var849 !=@expr2603 rhs@var810 .@expr2604 tokvalue@var813 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744429 FLOAT :@expr2588 ;
134:
135: if (@expr1073744431 floatValue@var850 >@expr1073744432 rhs@var810 .@expr2609 floatValue@var814 ||@expr1073744434 floatValue@var850 <@expr1073744435 rhs@var810 .@expr2609 floatValue@var814 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744437 MOVED :@expr2588 ;
139: if (@expr1073744439 moveKind@var851 !=@expr1073744440 rhs@var810 .@expr1073744441 moveKind@var815 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744442 UNINIT :@expr2588 ;
143: break ;
144: case ValueType ::@expr1073744444 LIFETIME :@expr2588 ;
145: if (@expr2602 tokvalue@var849 !=@expr2603 rhs@var810 .@expr2604 tokvalue@var813 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744449 SYMBOLIC :@expr2588 ;
149: if (@expr1073744451 !@expr1073744452 sameToken (@expr1073744453 tokvalue@var849 , rhs@var810 .@expr2604 tokvalue@var813 ) ) {
150: return false ; }
151: if (@expr2597 intvalue@var848 !=@expr2598 rhs@var810 .@expr2599 intvalue@var812 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var816 , F f@var817 ) {
160: switch (@expr1073744458 self@var816 .@expr1073744459 valueType@var818 ) {
161: case ValueType ::@expr1073744460 INT :@expr2637
162: case ValueType ::@expr1073744462 SYMBOLIC :@expr2637
163: case ValueType ::@expr1073744464 BUFFER_SIZE :@expr2637
164: case ValueType ::@expr1073744466 CONTAINER_SIZE :@expr2637
165: case ValueType ::@expr1073744468 ITERATOR_START :@expr2637
166: case ValueType ::@expr1073744470 ITERATOR_END :@expr2637 ; {
167: f@var817 (@expr1073744472 self@var816 .@expr1073744473 intvalue@var819 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744474 FLOAT :@expr2637 ; {
171: f@var817 (@expr1073744476 self@var816 .@expr1073744477 floatValue@var820 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744478 UNINIT :@expr2637
175: case ValueType ::@expr1073744480 TOK :@expr2637
176: case ValueType ::@expr1073744482 LIFETIME :@expr2637
177: case ValueType ::@expr1073744484 MOVED :@expr2637 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var821 , Compare compare@var822 , T x@var823 , U y@var824 ) const {
186: result@var821 =@expr1073744486 compare@var822 (@expr1073744487 x@var823 , y@var824 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var825 , const Value & rhs@var826 , Compare compare@var827 , T x@var828 ) const {
191: visitValue (@expr1073744489 rhs@var826 ,
192: std ::@expr1073744490 bind (@expr1073744491 innerVisitor {@expr1073744492 } , std ::@expr1073744493 ref (@expr1073744494 result@var825 ) , std ::@expr1073744495 move (@expr1073744496 compare@var827 ) , x@var828 , std ::@expr1073744497 placeholders ::@expr1073744498 _1@expr1073744488 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var829 , Compare compare@var830 ) const {
198: assert (@expr1073744500 (@expr1073744501 !@expr1073744502 this@expr2679 .@expr1073744504 isSymbolicValue (@expr1073744505 ) &&@expr1073744506 !@expr1073744507 rhs@var829 .@expr1073744508 isSymbolicValue (@expr1073744509 ) ) ||@expr1073744510
199: (@expr1073744511 this@expr2679 .@expr1073744512 valueType@var846 ==@expr1073744513 rhs@var829 .@expr1073744514 valueType@var831 &&@expr1073744515 sameToken (@expr1073744516 this@expr2679 .@expr1073744517 tokvalue@var849 , rhs@var829 .@expr1073744518 tokvalue@var832 ) ) ) ;
200: bool result@var833 ; result@var833 =@expr1073744519 false ;
201: visitValue (@expr1073744520
202: *@expr1073744521 this@expr2679 ,
203: std ::@expr1073744522 bind (@expr1073744523 compareVisitor {@expr1073744524 } , std ::@expr2701 ref (@expr1073744526 result@var833 ) , std ::@expr2701 ref (@expr1073744528 rhs@var829 ) , std ::@expr1073744529 move (@expr1073744530 compare@var830 ) , std ::@expr1073744531 placeholders ::@expr1073744532 _1@expr1073744499 ) ) ;
204: return result@var833 ;
205: }
206:
207: bool operator== ( const Value & rhs@var834 ) const {
208: if (@expr1073744533 !@expr1073744534 equalValue (@expr1073744535 rhs@var834 ) ) {
209: return false ; }
210:
211: return varvalue@var852 ==@expr1073744536 rhs@var834 .@expr1073744537 varvalue@var835 &&@expr1073744538
212: condition@var853 ==@expr1073744539 rhs@var834 .@expr1073744540 condition@var836 &&@expr1073744541
213: varId@var855 ==@expr1073744542 rhs@var834 .@expr1073744543 varId@var837 &&@expr1073744544
214: conditional@var857 ==@expr1073744545 rhs@var834 .@expr1073744546 conditional@var838 &&@expr1073744547
215: defaultArg@var859 ==@expr1073744548 rhs@var834 .@expr1073744549 defaultArg@var839 &&@expr1073744550
216: indirect@var860 ==@expr1073744551 rhs@var834 .@expr1073744552 indirect@var840 &&@expr1073744553
217: valueKind@var871 ==@expr1073744554 rhs@var834 .@expr1073744555 valueKind@var841 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var842 ) const {
221: return !@expr1073744556 (@expr1073744557 *@expr1073744558 this@expr1073744559 ==@expr1073744560 rhs@var842 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var843 ) const {
226: bool result@var844 ; result@var844 =@expr1073744562 false ;
227: visitValue (@expr1073744563 *@expr1073744564 this@expr1073744565 , std ::@expr1073744566 bind (@expr1073744567 equalVisitor {@expr1073744568 } , std ::@expr1073744569 ref (@expr1073744570 result@var844 ) , x@var843 , std ::@expr1073744571 placeholders ::@expr1073744572 _1@expr1073744561 ) ) ;
228: return result@var844 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744573 bound@var847 ==@expr1073744574 Bound ::@expr1073744575 Lower ) {
233: visitValue (@expr1073744576 *@expr2753 this@expr2754 , increment {@expr1073744579 } ) ; }
234: else { if (@expr1073744580 bound@var847 ==@expr1073744581 Bound ::@expr1073744582 Upper ) {
235: visitValue (@expr1073744583 *@expr2753 this@expr2754 , decrement {@expr1073744585 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744586 bound@var847 ==@expr1073744587 Bound ::@expr2764 Lower ) {
240: bound@var847 =@expr1073744589 Bound ::@expr2766 Upper ; }
241: else { if (@expr1073744591 bound@var847 ==@expr1073744592 Bound ::@expr2766 Upper ) {
242: bound@var847 =@expr1073744594 Bound ::@expr2764 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744596 ) ;
247: decreaseRange (@expr1073744597 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var845 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var846 ;
267: bool isIntValue ( ) const {
268: return valueType@var846 ==@expr1073744599 ValueType ::@expr1073744600 INT@expr1073744598 ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var846 ==@expr1073744601 ValueType ::@expr1073744602 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var846 ==@expr1073744603 ValueType ::@expr1073744604 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var846 ==@expr1073744605 ValueType ::@expr1073744606 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var846 ==@expr1073744607 ValueType ::@expr1073744608 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var846 ==@expr1073744609 ValueType ::@expr1073744610 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var846 ==@expr1073744611 ValueType ::@expr1073744612 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var846 ==@expr1073744613 ValueType ::@expr1073744614 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var846 ==@expr1073744615 ValueType ::@expr1073744616 ITERATOR_START ||@expr1073744617 valueType@var846 ==@expr1073744618 ValueType ::@expr1073744619 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var846 ==@expr1073744620 ValueType ::@expr1073744621 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var846 ==@expr1073744622 ValueType ::@expr1073744623 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var846 ==@expr1073744624 ValueType ::@expr1073744625 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var846 ==@expr1073744627 ValueType ::@expr1073744628 LIFETIME &&@expr1073744629 lifetimeScope@var866 ==@expr1073744630 LifetimeScope ::@expr1073744631 Local@expr1073744626 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var846 ==@expr1073744632 ValueType ::@expr1073744633 LIFETIME &&@expr1073744634 lifetimeScope@var866 ==@expr1073744635 LifetimeScope ::@expr1073744636 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var846 ==@expr1073744637 ValueType ::@expr1073744638 LIFETIME &&@expr1073744639 lifetimeScope@var866 ==@expr1073744640 LifetimeScope ::@expr1073744641 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744642 ) ||@expr1073744643 isUninitValue (@expr1073744644 ) ||@expr1073744645 isLifetimeValue (@expr1073744646 ) ;
318: }
319:
320:
321: Bound bound@var847 ;
322:
323:
324: long long intvalue@var848 ;
325:
326:
327: const Token * tokvalue@var849 ;
328:
329:
330: double floatValue@var850 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var851 ;
334:
335:
336: long long varvalue@var852 ;
337:
338:
339: const Token * condition@var853 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var854 ;
342:
343:
344: int varId@var855 ;
345:
346:
347: bool safe@var856 ;
348:
349:
350: bool conditional@var857 ;
351:
352:
353: bool macro@var858 ;
354:
355:
356: bool defaultArg@var859 ;
357:
358: int indirect@var860 ;
359:
360:
361: long long path@var861 ;
362:
363:
364: long long wideintvalue@var862 ;
365:
366: std :: vector < std :: string > subexpressions@var863 ;
367:
368:
369: const Token * capturetok@var864 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var865 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var866 ;
385:
386: static const char * toString ( MoveKind moveKind@var867 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var868 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var869 ) ;
389: static const char * toString ( Bound bound@var870 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var871 ;
402:
403: void setKnown ( ) {
404: valueKind@var871 =@expr1073744647 ValueKind ::@expr1073744648 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var871 ==@expr1073744649 ValueKind ::@expr1073744650 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var871 =@expr1073744652 ValueKind ::@expr1073744653 Possible@expr1073744651 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var871 ==@expr1073744655 ValueKind ::@expr1073744656 Possible@expr1073744654 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var871 ==@expr1073744657 ValueKind ::@expr1073744658 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var871 =@expr1073744659 ValueKind ::@expr1073744660 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var872 = true ) {
428: if (@expr1073744661 inconclusive@var872 ) {
429: valueKind@var871 =@expr1073744662 ValueKind ::@expr1073744663 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var871 ==@expr1073744664 ValueKind ::@expr1073744665 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744667 isKnown (@expr1073744668 ) ) {
438: valueKind@var871 =@expr1073744669 ValueKind ::@expr1073744670 Possible@expr1073744666 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744671 condition@var853 &&@expr1073744672 !@expr1073744673 defaultArg@var859 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var873 , const Token * tok2@var874 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var875 , const Settings * settings@var876 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var877 , SymbolDatabase * symboldatabase@var878 , ErrorLogger * errorLogger@var879 , const Settings * settings@var880 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var881 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var882 , const Settings * settings@var883 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var884 ,
459: const Settings * settings@var885 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var886 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var887 , const Token * indexTok@var888 , bool possible@var889 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var890 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var891 , const Settings * settings@var892 = nullptr , int depth@var893 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var894 ;
471: bool addressOf@var895 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var896 ;
473: bool inconclusive@var897 ;
474:
475: LifetimeToken ( ) : token@var894 ( nullptr ) , addressOf@var895 ( false ) , errorPath@var896 ( ) , inconclusive@var897 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var898 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var899 )
478: : token@var894 ( token@var898 ) , addressOf@var895 ( false ) , errorPath@var896 ( std :: move ( errorPath@var899 ) ) , inconclusive@var897 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var900 , bool addressOf@var901 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var902 )
482: : token@var894 ( token@var900 ) , addressOf@var895 ( addressOf@var901 ) , errorPath@var896 ( std :: move ( errorPath@var902 ) ) , inconclusive@var897 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var903 , bool b@var904 ) {
486: for (@expr1073744674 LifetimeToken &@expr1073744675 x@var905 :@expr1073744676 v@var903 ) {
487: x@var905 .@expr1073744677 addressOf@var906 =@expr1073744678 b@var904 ; }
488: return v@var903 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var907 , bool b@var908 ) {
492: for (@expr1073744679 LifetimeToken &@expr1073744680 x@var909 :@expr1073744681 v@var907 ) {
493: x@var909 .@expr1073744682 inconclusive@var910 =@expr1073744683 b@var908 ; }
494: return v@var907 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var911 , ValueFlow :: Value & true_value@var912 , ValueFlow :: Value & false_value@var913 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var914 ) ;
499: const Token * parseCompareInt ( const Token * tok@var915 , ValueFlow :: Value & true_value@var916 , ValueFlow :: Value & false_value@var917 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var918 , long long val@var919 , const Token * varTok@var920 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var921 , const Token * varTok@var922 , long long val@var923 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var924 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var925 ,
508: ValueFlow :: Value & value@var926 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var927 ,
511: bool escape@var928 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var929 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var930 , const Token * lifetime@var931 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var932 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var933 , bool * addressOf@var934 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var935 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var936 , const Settings * settings@var937 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var938 , const ValueFlow :: Value * val@var939 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var940 , const ValueFlow :: Value * val@var941 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var942 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var943 , bool inconclusive@var944 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var945 ,
529: bool inconclusive@var946 = false ,
530: long long path@var947 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var948 , const Scope * defaultScope@var949 = nullptr , bool smallest@var950 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var951 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var952 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var953 ;
69: std :: string mScope@var954 ;
70: std :: string mName@var955 ;
71: std :: string mFullName@var956 ;
72: const Token * mNameToken@var957 ;
73: const Token * mParamEnd@var958 ;
74: unsigned int mFlags@var959 ;
75:
76: enum Anonymous2 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var960 ) {
90: setFlag (@expr1073744684 fIsClass , state@var960 ) ;
91: }
92: void isFunction ( bool state@var961 ) {
93: setFlag (@expr1073744685 fIsFunction , state@var961 ) ;
94: }
95: void isVariable ( bool state@var962 ) {
96: setFlag (@expr1073744686 fIsVariable , state@var962 ) ;
97: }
98: void isAlias ( bool state@var963 ) {
99: setFlag (@expr1073744687 fIsAlias , state@var963 ) ;
100: }
101: void isSpecialization ( bool state@var964 ) {
102: setFlag (@expr1073744688 fIsSpecialization , state@var964 ) ;
103: }
104: void isPartialSpecialization ( bool state@var965 ) {
105: setFlag (@expr1073744689 fIsPartialSpecialization , state@var965 ) ;
106: }
107: void isForwardDeclaration ( bool state@var966 ) {
108: setFlag (@expr1073744690 fIsForwardDeclaration , state@var966 ) ;
109: }
110: void isVariadic ( bool state@var967 ) {
111: setFlag (@expr1073744691 fIsVariadic , state@var967 ) ;
112: }
113: void isFriend ( bool state@var968 ) {
114: setFlag (@expr1073744692 fIsFriend , state@var968 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var969 ) const {
123: return (@expr2869 (@expr2869 mFlags@var959 &@expr1073744695 flag@var969 ) !=@expr1073744696 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var970 , bool state@var971 ) {
132: mFlags@var959 =@expr1073744697 state@var971 ?@expr1073744698 mFlags@var959 |@expr1073744699 flag@var970 :@expr1073744700 mFlags@var959 &@expr1073744701 ~@expr1073744702 flag@var970 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var972 , const std :: string & scope@var973 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var974 , const std :: string & scope@var975 , const Token * nameToken@var976 , const Token * paramEnd@var977 ) ;
150: TokenAndName ( const TokenAndName & other@var978 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var979 ) const {
154: return mToken@var953 ==@expr1073744703 rhs@var979 .@expr1073744704 mToken@var980 &&@expr1073744705 mScope@var954 ==@expr1073744706 rhs@var979 .@expr1073744707 mScope@var981 &&@expr1073744708 mName@var955 ==@expr1073744709 rhs@var979 .@expr1073744710 mName@var982 &&@expr1073744711 mFullName@var956 ==@expr1073744712 rhs@var979 .@expr1073744713 mFullName@var983 &&@expr1073744714
155: mNameToken@var957 ==@expr1073744715 rhs@var979 .@expr1073744716 mNameToken@var984 &&@expr1073744717 mParamEnd@var958 ==@expr1073744718 rhs@var979 .@expr1073744719 mParamEnd@var985 &&@expr1073744720 mFlags@var959 ==@expr1073744721 rhs@var979 .@expr1073744722 mFlags@var986 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var953 ;
160: }
161: void token ( Token * token@var987 ) {
162: mToken@var953 =@expr1073744723 token@var987 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var954 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var955 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var956 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var957 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var958 ;
178: }
179: void paramEnd ( const Token * end@var988 ) {
180: mParamEnd@var958 =@expr1073744724 end@var988 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744725 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744726 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744727 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744728 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744729 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744730 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744731 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744732 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744733 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var989 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var990 ) const {
243:
244:
245: return (@expr2910 (@expr2910 mFlags@var959 &@expr1073744736 fFamilyMask ) &@expr1073744737 (@expr2910 decl@var990 .@expr1073744739 mFlags@var991 &@expr1073744740 fFamilyMask ) ) !=@expr1073744741 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var992 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var993 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var994 , const unsigned long numberOfArguments@var995 , bool variadic@var996 , const char patternAfter@var997 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var998 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var999 , int & namepos@var1000 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var1001 , int & namepos@var1002 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var1003 , int & namepos@var1004 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var1005 ,
306: bool & codeWithTemplates@var1006 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var1007 , bool isTemplate@var1008 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var1009 = nullptr , Token * backToken@var1010 = nullptr , bool isTemplate@var1011 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var1012 , Token * end@var1013 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var1014 , const std :: string & scope@var1015 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var1016 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var1017 ,
393: const std :: list < const Token * > & specializations@var1018 ,
394: const std :: time_t maxtime@var1019 ,
395: std :: set < std :: string > & expandedtemplates@var1020 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var1021 , const Token * tok@var1022 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var1023 , const Token * tok@var1024 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var1025 ,
422: const TokenAndName & templateInstantiation@var1026 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var1027 ,
424: const std :: string & newName@var1028 ,
425: bool copy@var1029 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var1030 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1031 ,
435: const std :: string & newName@var1032 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var1033 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var1034 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var1035 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var1036 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var1037 ,
458: const Token * templateInstantiationNameToken@var1038 ,
459: const std :: list < const Token * > & specializations@var1039 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var1040 , const Token * end@var1041 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var1042 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var1043 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var1044 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var1045 ,
487: const std :: string & indent@var1046 = "    " ) const ;
488: void printOut ( const std :: string & text@var1047 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var1048 ;
491: TokenList & mTokenList@var1049 ;
492: const Settings * mSettings@var1050 ;
493: ErrorLogger * mErrorLogger@var1051 ;
494: bool mChanged@var1052 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var1053 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var1054 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var1055 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var1056 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var1057 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var1058 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var1059 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var1060 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var1061 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var1062 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var1063 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var1064 ;
57: Token * back@var1065 ;
58: const TokenList * list@var1066 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var1067 , const Token * bodyEnd_@var1068 , const std :: set < std :: string > & usingNamespaces_@var1069 = std :: set < std :: string > ( ) ) : name@var1070 ( name_@var1067 ) , bodyEnd@var1071 ( bodyEnd_@var1068 ) , usingNamespaces@var1072 ( usingNamespaces_@var1069 ) { }
63: std :: string name@var1070 ;
64: const Token * const bodyEnd@var1071 ;
65: std :: set < std :: string > usingNamespaces@var1072 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var1073 ;
70: int mFileIndex@var1074 ;
71: int mLineNumber@var1075 ;
72: int mColumn@var1076 ;
73: int mExprId@var1077 ;
74:
75:
76: Token * mAstOperand1@var1078 ;
77: Token * mAstOperand2@var1079 ;
78: Token * mAstParent@var1080 ;
79:
80:
81: const Scope * mScope@var1081 ;
82: union {
83: const Function * mFunction@var1082 ;
84: const Variable * mVariable@var1083 ;
85: const :: Type * mType@var1084 ;
86: const Enumerator * mEnumerator@var1085 ;
87: } ;
88:
|
92:
93: int mProgressValue@var1086 ;
94:
|
97:
98: int mIndex@var1087 ;
99:
100:
101: std :: string * mOriginalName@var1088 ;
102:
103:
104: ValueType * mValueType@var1089 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var1090 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var1091 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var1092 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var1093 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var1094 ;
119: long long value@var1095 ;
120: struct CppcheckAttributes * next@var1096 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var1097 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var1098 ;
126:
127:
128: unsigned char mBits@var1099 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var1100 , long long value@var1101 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var1102 , long long * value@var1103 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var1073 ( 0 )
135: , mFileIndex@var1074 ( 0 )
136: , mLineNumber@var1075 ( 0 )
137: , mColumn@var1076 ( 0 )
138: , mExprId@var1077 ( 0 )
139: , mAstOperand1@var1078 ( nullptr )
140: , mAstOperand2@var1079 ( nullptr )
141: , mAstParent@var1080 ( nullptr )
142: , mScope@var1081 ( nullptr )
143: , mFunction@var1082 ( nullptr )
144: , mProgressValue@var1086 ( 0 )
145: , mIndex@var1087 ( 0 )
146: , mOriginalName@var1088 ( nullptr )
147: , mValueType@var1089 ( nullptr )
148: , mValues@var1090 ( nullptr )
149: , mTemplateSimplifierPointers@var1092 ( nullptr )
150: , mScopeInfo@var1093 ( nullptr )
151: , mCppcheckAttributes@var1097 ( nullptr )
152: , mCpp11init@var1098 ( Cpp11init :: UNKNOWN )
153: , mBits@var1099 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var1104 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var1105 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var1106 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var1107 ) {
199: mStr@var1319 =@expr1073744742 s@var1107 ;
200: mImpl@var1325 .@expr1073744743 mVarId@var1356 =@expr1073744744 0 ;
201:
202: update_property_info (@expr1073744745 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var1108 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var1319 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var1109 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var1110 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var1111 ) const ;
236: Token * tokAt ( int index@var1112 ) {
237: return const_cast < Token *@expr2922 > (@expr1073744747 const_cast < const Token *@expr2922 > (@expr1073744749 this@expr1073744750 ) .@expr1073744751 tokAt (@expr1073744752 index@var1112 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var1113 ) const ;
245: Token * linkAt ( int index@var1114 ) {
246: return const_cast < Token *@expr2929 > (@expr1073744754 const_cast < const Token *@expr2929 > (@expr1073744756 this@expr1073744757 ) .@expr1073744758 linkAt (@expr1073744759 index@var1114 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var1115 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var1116 , const char ( & pattern@var1117 ) [ count ] ) {
276: return simpleMatch (@expr1073744761 tok@var1116 , pattern@var1117 , count@expr1073744760 -@expr1073744762 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var1118 , const char pattern@var1119 [ ] , unsigned long pattern_len@var1120 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var1121 , const char pattern@var1122 [ ] , int varid@var1123 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var1124 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var1125 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var1126 , const Settings * const settings@var1127 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var1128 , long long index@var1129 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1325 .@expr1073744763 mValueType@var1357 ;
366: }
367: void setValueType ( ValueType * vt@var1130 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var1131 ; top@var1131 =@expr1073744764 this@expr1073744765 ;
371: while (@expr1073744766 top@var1131 &&@expr1073744767 !@expr1073744768 Token ::@expr1073744769 Match (@expr1073744770 top@var1131 .@expr2947 astParent (@expr2948 ) , ",|(" ) ) {
372: top@var1131 =@expr1073744773 top@var1131 .@expr2947 astParent (@expr2948 ) ; }
373: return top@var1131 ?@expr1073744776 top@var1131 .@expr1073744777 mImpl@var1132 .@expr1073744778 mValueType@var1133 :@expr1073744779 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1323 ;
378: }
379: void tokType ( Token :: Type t@var1134 ) {
380: mTokType@var1323 =@expr1073744780 t@var1134 ;
381:
382: const bool memoizedIsName@var1135 =@expr1073744781 mTokType@var1323 ==@expr1073744782 eName ||@expr1073744783 mTokType@var1323 ==@expr1073744784 eType ||@expr1073744785 mTokType@var1323 ==@expr1073744786 eVariable ||@expr1073744787
383: mTokType@var1323 ==@expr1073744788 eFunction ||@expr1073744789 mTokType@var1323 ==@expr1073744790 eKeyword ||@expr1073744791 mTokType@var1323 ==@expr2968 eBoolean ||@expr1073744793
384: mTokType@var1323 ==@expr2970 eEnumerator ;
385: setFlag (@expr1073744795 fIsName , memoizedIsName@var1135 ) ;
386:
387: const bool memoizedIsLiteral@var1136 =@expr1073744796 mTokType@var1323 ==@expr1073744797 eNumber ||@expr1073744798 mTokType@var1323 ==@expr1073744799 eString ||@expr1073744800 mTokType@var1323 ==@expr1073744801 eChar ||@expr1073744802
388: mTokType@var1323 ==@expr2968 eBoolean ||@expr1073744804 mTokType@var1323 ==@expr1073744805 eLiteral ||@expr1073744806 mTokType@var1323 ==@expr2970 eEnumerator ;
389: setFlag (@expr1073744808 fIsLiteral , memoizedIsLiteral@var1136 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1323 ==@expr1073744809 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073744810 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1324 ==@expr1073744811 fIsName &&@expr1073744812 mTokType@var1323 ==@expr1073744813 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073744814 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1323 ==@expr1073744815 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1323 ==@expr1073744816 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073744817 isConstOp (@expr1073744818 ) ||@expr1073744819
412: isAssignmentOp (@expr1073744820 ) ||@expr1073744821
413: mTokType@var1323 ==@expr1073744822 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073744823 isArithmeticalOp (@expr1073744824 ) ||@expr1073744825
417: mTokType@var1323 ==@expr1073744826 eLogicalOp ||@expr1073744827
418: mTokType@var1323 ==@expr1073744828 eComparisonOp ||@expr1073744829
419: mTokType@var1323 ==@expr1073744830 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073744831 ) ||@expr1073744832
423: mTokType@var1323 ==@expr1073744833 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1323 ==@expr1073744834 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1323 ==@expr1073744835 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1323 ==@expr1073744836 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1323 ==@expr1073744837 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1323 ==@expr1073744838 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073744839 ) !=@expr1073744840 nullptr &&@expr1073744841 astOperand2 (@expr1073744842 ) !=@expr1073744843 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var1137 ) const {
444: return s@var1137 ==@expr1073744844 mStr@var1319 &&@expr1073744845 astOperand1 (@expr1073744846 ) !=@expr1073744847 nullptr &&@expr1073744848 astOperand2 (@expr1073744849 ) ==@expr1073744850 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1324 ;
450: }
451: void flags ( const unsigned int flags_@var1138 ) {
452: mFlags@var1324 =@expr1073744851 flags_@var1138 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073744852 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var1139 ) {
458: setFlag (@expr1073744853 fIsUnsigned , sign@var1139 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073744854 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var1140 ) {
464: setFlag (@expr1073744855 fIsSigned , sign@var1140 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073744856 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var1141 ) {
470: setFlag (@expr1073744857 fIsPointerCompare , b@var1141 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073744858 fIsLong ) ;
474: }
475: void isLong ( bool size@var1142 ) {
476: setFlag (@expr1073744859 fIsLong , size@var1142 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073744860 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var1143 ) {
482: setFlag (@expr1073744861 fIsStandardType , b@var1143 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073744862 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var1144 ) {
488: setFlag (@expr1073744863 fIsExpandedMacro , m@var1144 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073744864 fIsCast ) ;
492: }
493: void isCast ( bool c@var1145 ) {
494: setFlag (@expr1073744865 fIsCast , c@var1145 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073744866 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var1146 ) {
500: setFlag (@expr1073744867 fIsAttributeConstructor , ac@var1146 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073744868 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var1147 ) {
506: setFlag (@expr1073744869 fIsAttributeDestructor , value@var1147 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073744870 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var1148 ) {
512: setFlag (@expr1073744871 fIsAttributeUnused , unused@var1148 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073744872 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var1149 ) {
518: setFlag (@expr1073744873 fIsAttributeUsed , unused@var1149 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073744874 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var1150 ) {
524: setFlag (@expr1073744875 fIsAttributePure , value@var1150 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073744876 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var1151 ) {
530: setFlag (@expr1073744877 fIsAttributeConst , value@var1151 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073744878 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var1152 ) {
536: setFlag (@expr1073744879 fIsAttributeNoreturn , value@var1152 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073744880 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var1153 ) {
542: setFlag (@expr1073744881 fIsAttributeNothrow , value@var1153 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073744882 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var1154 ) {
548: setFlag (@expr1073744883 fIsAttributePacked , value@var1154 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073744884 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var1155 ) {
554: setFlag (@expr1073744885 fIsAttributeNodiscard , value@var1155 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073744886 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var1156 ) {
560: setFlag (@expr1073744887 fIsAttributeMaybeUnused , value@var1156 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1157 , long long value@var1158 ) {
563: mImpl@var1325 .@expr1073744888 setCppcheckAttribute (@expr1073744889 type@var1157 , value@var1158 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var1159 , long long * value@var1160 ) const {
566: return mImpl@var1325 .@expr1073744890 getCppcheckAttribute (@expr1073744891 type@var1159 , value@var1160 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073744892 mImpl@var1325 .@expr1073744893 mCppcheckAttributes@var1358 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073744894 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073744895 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var1161 ) {
578: setFlag (@expr1073744896 fIsOperatorKeyword , value@var1161 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073744897 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var1162 ) {
584: setFlag (@expr1073744898 fIsComplex , value@var1162 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073744899 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var1163 ) {
590: setFlag (@expr1073744900 fIsEnumType , value@var1163 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073744901 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var1164 ) {
596: setFlag (@expr1073744902 fAtAddress , b@var1164 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073744903 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var1165 ) {
602: setFlag (@expr1073744904 fIncompleteVar , b@var1165 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073744905 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var1166 ) {
609: setFlag (@expr1073744906 fIsIncompleteConstant , b@var1166 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073744907 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var1167 ) {
616: setFlag (@expr1073744908 fConstexpr , b@var1167 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073744909 fExternC ) ;
621: }
622: void isExternC ( bool b@var1168 ) {
623: setFlag (@expr1073744910 fExternC , b@var1168 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073744911 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var1169 ) {
630: setFlag (@expr1073744912 fIsSplitVarDeclComma , b@var1169 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073744913 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var1170 ) {
637: setFlag (@expr1073744914 fIsSplitVarDeclEq , b@var1170 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073744915 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var1171 ) {
644: setFlag (@expr1073744916 fIsImplicitInt , b@var1171 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073744917 fIsInline ) ;
649: }
650: void isInline ( bool b@var1172 ) {
651: setFlag (@expr1073744918 fIsInline , b@var1172 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073744919 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var1173 ) {
658: setFlag (@expr1073744920 fIsRemovedVoidParameter , b@var1173 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073744921 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var1174 ) {
665: setFlag (@expr1073744922 fIsTemplate , b@var1174 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073744923 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var1175 ) {
672: setFlag (@expr1073744924 fIsSimplifedScope , b@var1175 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1325 .@expr1073744925 mBits@var1359 >@expr1073744926 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1325 .@expr1073744927 mBits@var1359 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1325 .@expr1073744928 mTemplateSimplifierPointers@var1360 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var1176 ) {
685: if (@expr1073744929 !@expr1073744930 mImpl@var1325 .@expr3107 mTemplateSimplifierPointers@var1360 ) {
686: mImpl@var1325 .@expr3107 mTemplateSimplifierPointers@var1360 =@expr1073744933 new std ::@expr1073744934 set < TemplateSimplifier ::@expr1073744935 TokenAndName *@expr1073744936 > ; }
687: mImpl@var1325 .@expr3107 mTemplateSimplifierPointers@var1360 .@expr1073744938 insert (@expr1073744939 tokenAndName@var1176 ) ;
688: }
689: void setBits ( const unsigned char b@var1177 ) {
690: mImpl@var1325 .@expr1073744940 mBits@var1359 =@expr1073744941 b@var1177 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3118 (@expr3118 (@expr3118 mTokType@var1323 ==@expr1073744945 eString ) &&@expr1073744946 isPrefixStringCharLiteral (@expr1073744947 mStr@var1319 , '"' , "u8" ) ) ||@expr1073744948
695: (@expr3118 (@expr3118 mTokType@var1323 ==@expr1073744951 eChar ) &&@expr1073744952 isPrefixStringCharLiteral (@expr1073744953 mStr@var1319 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3130 (@expr3130 (@expr3130 mTokType@var1323 ==@expr1073744957 eString ) &&@expr1073744958 isPrefixStringCharLiteral (@expr1073744959 mStr@var1319 , '"' , "u" ) ) ||@expr1073744960
700: (@expr3130 (@expr3130 mTokType@var1323 ==@expr1073744963 eChar ) &&@expr1073744964 isPrefixStringCharLiteral (@expr1073744965 mStr@var1319 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3142 (@expr3142 (@expr3142 mTokType@var1323 ==@expr1073744969 eString ) &&@expr1073744970 isPrefixStringCharLiteral (@expr1073744971 mStr@var1319 , '"' , "U" ) ) ||@expr1073744972
705: (@expr3142 (@expr3142 mTokType@var1323 ==@expr1073744975 eChar ) &&@expr1073744976 isPrefixStringCharLiteral (@expr1073744977 mStr@var1319 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3154 (@expr3154 (@expr3154 mTokType@var1323 ==@expr1073744981 eString ) &&@expr1073744982 isPrefixStringCharLiteral (@expr1073744983 mStr@var1319 , '"' , "" ) ) ||@expr1073744984
710: (@expr3154 (@expr3154 mTokType@var1323 ==@expr1073744987 eChar ) &&@expr1073744988 isPrefixStringCharLiteral (@expr1073744989 mStr@var1319 , '\'' , "" ) &&@expr1073744990 mStr@var1319 .@expr1073744991 length (@expr1073744992 ) ==@expr1073744993 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3170 (@expr3170 (@expr3170 mTokType@var1323 ==@expr1073744997 eChar ) &&@expr1073744998 isPrefixStringCharLiteral (@expr1073744999 mStr@var1319 , '\'' , "" ) ) &&@expr1073745000
715: (@expr3170 mStr@var1319 .@expr1073745002 length (@expr1073745003 ) >@expr1073745004 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745005 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var1178 ) {
738: setFlag (@expr1073745006 fIsTemplateArg , value@var1178 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var1179 , const char ( & pattern@var1180 ) [ count ] ) {
743: return findsimplematch (@expr1073745008 startTok@var1179 , pattern@var1180 , count@expr1073745007 -@expr1073745009 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var1181 , const char pattern@var1182 [ ] , unsigned long pattern_len@var1183 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var1184 , const char ( & pattern@var1185 ) [ count ] , const Token * const end@var1186 ) {
749: return findsimplematch (@expr1073745011 startTok@var1184 , pattern@var1185 , count@expr1073745010 -@expr1073745012 1 , end@var1186 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var1187 , const char pattern@var1188 [ ] , unsigned long pattern_len@var1189 , const Token * const end@var1190 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var1191 , const char pattern@var1192 [ ] , const int varId@var1193 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var1194 , const char pattern@var1195 [ ] , const Token * const end@var1196 , const int varId@var1197 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var1198 , const char ( & pattern@var1199 ) [ count ] ) {
758: return findsimplematch (@expr1073745014 startTok@var1198 , pattern@var1199 , count@expr1073745013 -@expr1073745015 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var1200 , const char pattern@var1201 [ ] , unsigned long pattern_len@var1202 ) {
761: return const_cast < Token *@expr3192 > (@expr1073745017 findsimplematch (@expr1073745018 const_cast < const Token *@expr3192 > (@expr1073745020 startTok@var1200 ) , pattern@var1201 , pattern_len@var1202 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var1203 , const char ( & pattern@var1204 ) [ count ] , const Token * const end@var1205 ) {
765: return findsimplematch (@expr1073745022 startTok@var1203 , pattern@var1204 , count@expr1073745021 -@expr1073745023 1 , end@var1205 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var1206 , const char pattern@var1207 [ ] , unsigned long pattern_len@var1208 , const Token * const end@var1209 ) {
768: return const_cast < Token *@expr3200 > (@expr1073745025 findsimplematch (@expr1073745026 const_cast < const Token *@expr3200 > (@expr1073745028 startTok@var1206 ) , pattern@var1207 , pattern_len@var1208 , end@var1209 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var1210 , const char pattern@var1211 [ ] , const int varId@var1212 = 0 ) {
772: return const_cast < Token *@expr3205 > (@expr1073745030 findmatch (@expr1073745031 const_cast < const Token *@expr3205 > (@expr1073745033 startTok@var1210 ) , pattern@var1211 , varId@var1212 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var1213 , const char pattern@var1214 [ ] , const Token * const end@var1215 , const int varId@var1216 = 0 ) {
775: return const_cast < Token *@expr3210 > (@expr1073745035 findmatch (@expr1073745036 const_cast < const Token *@expr3210 > (@expr1073745038 startTok@var1213 ) , pattern@var1214 , end@var1215 , varId@var1216 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var1217 , const char * haystack@var1218 , int varid@var1219 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1325 .@expr1073745039 mFileIndex@var1361 ;
796: }
797: void fileIndex ( int indexOfFile@var1220 ) {
798: mImpl@var1325 .@expr1073745040 mFileIndex@var1361 =@expr1073745041 indexOfFile@var1220 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1325 .@expr1073745042 mLineNumber@var1362 ;
803: }
804: void linenr ( int lineNumber@var1221 ) {
805: mImpl@var1325 .@expr1073745043 mLineNumber@var1362 =@expr1073745044 lineNumber@var1221 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1325 .@expr1073745045 mColumn@var1363 ;
810: }
811: void column ( int c@var1222 ) {
812: mImpl@var1325 .@expr1073745046 mColumn@var1363 =@expr1073745047 c@var1222 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1320 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var1223 , const Token * end@var1224 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var1225 , const std :: string & originalNameStr@var1226 = emptyString@var1 , bool prepend@var1227 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var1228 , const std :: string & originalNameStr@var1229 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745048 tokenStr@var1228 , originalNameStr@var1229 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1321 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1325 .@expr1073745049 mVarId@var1356 ;
851: }
852: void varId ( int id@var1230 ) {
853: mImpl@var1325 .@expr1073745050 mVarId@var1356 =@expr1073745051 id@var1230 ;
854: if (@expr1073745052 id@var1230 !=@expr1073745053 0 ) {
855: tokType (@expr1073745054 eVariable ) ;
856: isStandardType (@expr1073745055 false ) ;
857: } else {
858: update_property_info (@expr1073745056 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745057 mImpl@var1325 .@expr3234 mExprId@var1364 ) {
864: return mImpl@var1325 .@expr3234 mExprId@var1364 ; }
865: return mImpl@var1325 .@expr1073745060 mVarId@var1356 ;
866: }
867: void exprId ( int id@var1231 ) {
868: mImpl@var1325 .@expr1073745061 mExprId@var1364 =@expr1073745062 id@var1231 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var1232 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var1233 , const std :: vector < std :: string > & fileNames@var1234 ) const ;
888:
|
891:
892: void printLines ( int lines@var1235 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var1236 , Token * start@var1237 , Token * end@var1238 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var1239 ; varid@var1239 = false ;
905: bool exprid@var1240 ; exprid@var1240 = false ;
906: bool idtype@var1241 ; idtype@var1241 = false ;
907: bool attributes@var1242 ; attributes@var1242 = false ;
908: bool macro@var1243 ; macro@var1243 = false ;
909: bool linenumbers@var1244 ; linenumbers@var1244 = false ;
910: bool linebreaks@var1245 ; linebreaks@var1245 = false ;
911: bool files@var1246 ; files@var1246 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var1247 ;
914: options@var1247 .@expr1073745063 attributes@var1248 =@expr1073745064 true ;
915: options@var1247 .@expr1073745065 macro@var1249 =@expr1073745066 true ;
916: options@var1247 .@expr1073745067 linenumbers@var1250 =@expr1073745068 true ;
917: options@var1247 .@expr1073745069 linebreaks@var1251 =@expr1073745070 true ;
918: options@var1247 .@expr1073745071 files@var1252 =@expr1073745072 true ;
919: return options@var1247 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var1253 ; options@var1253 =@expr1073745073 forDebug (@expr1073745074 ) ;
923: options@var1253 .@expr1073745075 varid@var1254 =@expr1073745076 true ;
924: return options@var1253 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var1255 ; options@var1255 =@expr1073745077 forDebug (@expr1073745078 ) ;
928: options@var1255 .@expr1073745079 exprid@var1256 =@expr1073745080 true ;
929: return options@var1255 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var1257 ; options@var1257 =@expr1073745081 forDebug (@expr1073745082 ) ;
933: options@var1257 .@expr1073745083 exprid@var1258 =@expr1073745084 true ;
934: options@var1257 .@expr1073745085 varid@var1259 =@expr1073745086 true ;
935: options@var1257 .@expr1073745087 idtype@var1260 =@expr1073745088 true ;
936: return options@var1257 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var1261 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var1262 , bool attributes@var1263 , bool macro@var1264 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var1265 , const std :: vector < std :: string > * fileNames@var1266 = nullptr , const Token * end@var1267 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var1268 , bool attributes@var1269 = true ) const ;
952: std :: string stringifyList ( bool varid@var1270 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var1271 , bool attributes@var1272 , bool linenumbers@var1273 , bool linebreaks@var1274 , bool files@var1275 , const std :: vector < std :: string > * fileNames@var1276 = nullptr , const Token * end@var1277 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var1278 ) {
983: mLink@var1322 =@expr1073745089 linkToToken@var1278 ;
984: if (@expr1073745090 mStr@var1319 ==@expr1073745091 "<" ||@expr1073745092 mStr@var1319 ==@expr1073745093 ">" ) {
985: update_property_info (@expr1073745094 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1322 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var1279 ) {
1006: mImpl@var1325 .@expr1073745095 mScope@var1365 =@expr1073745096 s@var1279 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1325 .@expr1073745097 mScope@var1365 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var1280 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1323 ==@expr1073745098 eFunction ||@expr1073745099 mTokType@var1323 ==@expr1073745100 eLambda ?@expr1073745101 mImpl@var1325 .@expr1073745102 mFunction@var1366 :@expr1073745103 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var1281 ) {
1034: mImpl@var1325 .@expr1073745104 mVariable@var1367 =@expr1073745105 v@var1281 ;
1035: if (@expr1073745106 v@var1281 ||@expr1073745107 mImpl@var1325 .@expr1073745108 mVarId@var1356 ) {
1036: tokType (@expr1073745109 eVariable ) ; }
1037: else { if (@expr1073745110 mTokType@var1323 ==@expr1073745111 eVariable ) {
1038: tokType (@expr1073745112 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1323 ==@expr1073745113 eVariable ?@expr1073745114 mImpl@var1325 .@expr1073745115 mVariable@var1367 :@expr1073745116 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var1282 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1323 ==@expr1073745117 eType ?@expr1073745118 mImpl@var1325 .@expr1073745119 mType@var1368 :@expr1073745120 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var1283 , const Token * * typeTok@var1284 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var1285 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var1286 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1323 ==@expr1073745121 eEnumerator ?@expr1073745122 mImpl@var1325 .@expr1073745123 mEnumerator@var1369 :@expr1073745124 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var1287 ) {
1079: mImpl@var1325 .@expr1073745125 mEnumerator@var1369 =@expr1073745126 e@var1287 ;
1080: if (@expr1073745127 e@var1287 ) {
1081: tokType (@expr1073745128 eEnumerator ) ; }
1082: else { if (@expr1073745129 mTokType@var1323 ==@expr1073745130 eEnumerator ) {
1083: tokType (@expr1073745131 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var1288 , Token * end@var1289 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var1290 , Token * srcEnd@var1291 , Token * newLocation@var1292 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1325 .@expr1073745132 mProgressValue@var1370 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var1293 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1325 .@expr3309 mOriginalName@var1371 ?@expr1073745134 *@expr1073745135 mImpl@var1325 .@expr3309 mOriginalName@var1371 :@expr1073745137 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1325 .@expr3314 mValues@var1344 ?@expr1073745139 *@expr1073745140 mImpl@var1325 .@expr3314 mValues@var1344 :@expr1073745142 TokenImpl ::@expr1073745143 mEmptyValueList@var1091 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var1294 ) {
1164: if (@expr1073745144 !@expr1073745145 mImpl@var1325 .@expr3322 mOriginalName@var1371 ) {
1165: mImpl@var1325 .@expr3322 mOriginalName@var1371 =@expr1073745148 new std ::@expr1073745149 string (@expr1073745150 name@var1294 ) ; }
1166: else {
1167: *@expr1073745151 mImpl@var1325 .@expr3322 mOriginalName@var1371 =@expr1073745153 name@var1294 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var1295 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var1296 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var1297 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1325 .@expr1073745155 mValues@var1344 .@expr1073745156 front (@expr1073745157 ) .@expr1073745158 intvalue@expr1073745154 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var1298 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var1299 , long long path@var1300 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var1301 , const Settings * settings@var1302 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var1303 , const Settings * settings@var1304 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var1305 , int argnr@var1306 , const Settings * settings@var1307 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var1308 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var1309 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var1310 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var1311 ) {
1200: if (@expr1073745159 mImpl@var1325 .@expr3336 mValues@var1344 ) {
1201: mImpl@var1325 .@expr3336 mValues@var1344 .@expr1073745162 remove_if (@expr1073745163 pred@var1311 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1325 .@expr1073745164 mIndex@var1372 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var1312 ) {
1213: mNext@var1320 =@expr1073745165 nextToken@var1312 ;
1214: }
1215: void previous ( Token * previousToken@var1313 ) {
1216: mPrevious@var1321 =@expr1073745166 previousToken@var1313 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var1314 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var1315 , const char * word@var1316 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var1317 , char c@var1318 ) ;
1235:
1236: std :: string mStr@var1319 ;
1237:
1238: Token * mNext@var1320 ;
1239: Token * mPrevious@var1321 ;
1240: Token * mLink@var1322 ;
1241:
1242: enum Anonymous3 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1323 ;
1283:
1284: uint64_t mFlags@var1324 ;
1285:
1286: TokenImpl * mImpl@var1325 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1326 ) const {
1294: return (@expr3343 (@expr3343 mFlags@var1324 &@expr1073745169 flag_@var1326 ) !=@expr1073745170 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1327 , bool state_@var1328 ) {
1303: mFlags@var1324 =@expr1073745171 state_@var1328 ?@expr1073745172 mFlags@var1324 |@expr1073745173 flag_@var1327 :@expr1073745174 mFlags@var1324 &@expr1073745175 ~@expr1073745176 flag_@var1327 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1329 , const int indent1@var1330 = 0 , const int indent2@var1331 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1332 ) ;
1321: void astOperand2 ( Token * tok@var1333 ) ;
1322: void astParent ( Token * tok@var1334 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1325 .@expr1073745177 mAstOperand1@var1335 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1325 .@expr1073745178 mAstOperand1@var1335 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1325 .@expr1073745179 mAstOperand2@var1336 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1325 .@expr1073745180 mAstOperand2@var1336 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1325 .@expr1073745181 mAstParent@var1337 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1325 .@expr1073745182 mAstParent@var1337 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745183 !@expr1073745184 astParent (@expr3361 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745186 this@expr3363 ==@expr1073745188 astParent (@expr3361 ) .@expr3366 astOperand1 (@expr3367 ) ) {
1346: return astParent (@expr3361 ) .@expr3369 astOperand2 (@expr3370 ) ; }
1347: else { if (@expr1073745195 this@expr3363 ==@expr1073745196 astParent (@expr3361 ) .@expr3369 astOperand2 (@expr3370 ) ) {
1348: return astParent (@expr3361 ) .@expr3366 astOperand1 (@expr3367 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745203 !@expr1073745204 astParent (@expr3381 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745206 this@expr3383 ==@expr1073745208 astParent (@expr3381 ) .@expr3386 astOperand1 (@expr3387 ) ) {
1356: return astParent (@expr3381 ) .@expr3389 astOperand2 (@expr3390 ) ; }
1357: else { if (@expr1073745215 this@expr3383 ==@expr1073745216 astParent (@expr3381 ) .@expr3389 astOperand2 (@expr3390 ) ) {
1358: return astParent (@expr3381 ) .@expr3386 astOperand1 (@expr3387 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1338 ; ret@var1338 =@expr1073745223 this@expr1073745224 ;
1364: while (@expr1073745225 ret@var1338 .@expr3402 mImpl@var1339 .@expr3403 mAstParent@var1340 ) {
1365: ret@var1338 =@expr1073745228 ret@var1338 .@expr3402 mImpl@var1339 .@expr3403 mAstParent@var1340 ; }
1366: return ret@var1338 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1341 ; ret@var1341 =@expr1073745231 this@expr1073745232 ;
1371: while (@expr1073745233 ret@var1341 .@expr3410 mImpl@var1342 .@expr3411 mAstParent@var1343 ) {
1372: ret@var1341 =@expr1073745236 ret@var1341 .@expr3410 mImpl@var1342 .@expr3411 mAstParent@var1343 ; }
1373: return ret@var1341 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1325 .@expr1073745239 mAstOperand1@var1335 =@expr1073745240 mImpl@var1325 .@expr1073745241 mAstOperand2@var1336 =@expr1073745242 mImpl@var1325 .@expr1073745243 mAstParent@var1337 =@expr1073745244 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1325 .@expr3421 mValues@var1344 ;
1393: mImpl@var1325 .@expr3421 mValues@var1344 =@expr1073745247 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1345 = "" ) const {
1397: std ::@expr1073745248 string ret@var1346 ;
1398: if (@expr1073745249 mImpl@var1325 .@expr3426 mAstOperand1@var1335 ) {
1399: ret@var1346 =@expr1073745251 mImpl@var1325 .@expr3426 mAstOperand1@var1335 .@expr1073745253 astString (@expr1073745254 sep@var1345 ) ; }
1400: if (@expr1073745255 mImpl@var1325 .@expr3432 mAstOperand2@var1336 ) {
1401: ret@var1346 +=@expr1073745257 mImpl@var1325 .@expr3432 mAstOperand2@var1336 .@expr1073745259 astString (@expr1073745260 sep@var1345 ) ; }
1402: return ret@var1346 +@expr1073745261 sep@var1345 +@expr1073745262 mStr@var1319 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1347 , bool xml@var1348 , const std :: vector < std :: string > & fileNames@var1349 , std :: ostream & out@var1350 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1351 , std :: ostream & out@var1352 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1353 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1354 ) const {
1419: mImpl@var1325 .@expr1073745263 mCpp11init@var1355 =@expr1073745264 cpp11init@var1354 ?@expr1073745265 TokenImpl ::@expr3442 Cpp11init ::@expr1073745267 CPP11INIT :@expr1073745268 TokenImpl ::@expr3442 Cpp11init ::@expr1073745270 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1325 .@expr1073745271 mCpp11init@var1355 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1373 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1374 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1375 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1376 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1377 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1378 ) {
47: mSettings@var1413 =@expr1073745272 settings@var1378 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1413 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1415 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1416 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1379 ) ;
72:
73: void addtoken ( const std :: string & str@var1380 , const int lineno@var1381 , const int column@var1382 , const int fileno@var1383 , bool split@var1384 = false ) ;
74: void addtoken ( const std :: string & str@var1385 , const Token * locationTok@var1386 ) ;
75:
76: void addtoken ( const Token * tok@var1387 , const int lineno@var1388 , const int column@var1389 , const int fileno@var1390 ) ;
77: void addtoken ( const Token * tok@var1391 , const Token * locationTok@var1392 ) ;
78: void addtoken ( const Token * tok@var1393 ) ;
79:
80: static void insertTokens ( Token * dest@var1394 , const Token * src@var1395 , int n@var1396 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1397 , const Token * first@var1398 , const Token * last@var1399 , bool one_line@var1400 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1401 , const std :: string & file0@var1402 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1403 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1404 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1410 .@expr1073745273 front@var1417 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1410 .@expr1073745274 front@var1417 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1410 .@expr1073745275 back@var1418 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1410 .@expr1073745276 back@var1418 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1411 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1405 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1406 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1407 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1408 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1409 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1410 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1411 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1412 ;
212:
213:
214: const Settings * mSettings@var1413 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1414 ;
217:
218:
219: bool mIsC@var1415 ;
220: bool mIsCpp@var1416 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var1419 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var1420 ;
67: mutable int mVarId@var1421 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var1422 ) ;
73: bool hasVariable ( const std :: string & varname@var1423 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var1424 ) const {
75: return mVariableId@var1419 .@expr1073745277 find (@expr1073745278 varname@var1424 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var1419 .@expr1073745279 end (@expr1073745280 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var1419 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073745281 mVarId@var1421 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var1425 , ErrorLogger * errorLogger@var1426 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var1427 ) {
95: mTimerResults@var1547 =@expr1073745282 tr@var1427 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var1525 .@expr1073745283 isC (@expr1073745284 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var1525 .@expr1073745285 isCPP (@expr1073745286 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var1428 , bool * unknown@var1429 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var1430 , const std :: string & FileName@var1431 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var1432 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var1433 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var1434 ,
142: const char FileName@var1435 [ ] ,
143: const std :: string & configuration@var1436 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var1437 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var1438 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var1439 , const Token * end@var1440 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var1441 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var1442 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var1443 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var1444 , const Token * const tokEnd@var1445 , const bool only_k_r_fpar@var1446 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var1447 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var1448 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var1449 , bool commandWithCondition@var1450 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var1451 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var1452 , Token * * _tok2@var1453 , Token * * _tok3@var1454 , std :: string & value@var1455 , int & valueVarId@var1456 , bool & valueIsPointer@var1457 , bool floatvar@var1458 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var1459 , Token * tok3@var1460 , int varid@var1461 , const std :: string & structname@var1462 , std :: string & value@var1463 , int valueVarId@var1464 , bool valueIsPointer@var1465 , const Token * const valueToken@var1466 , int indentlevel@var1467 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var1468 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var1469 , const std :: string & endsWith@var1470 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1471 , const std :: string & endsWith@var1472 , bool cpp@var1473 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1474 ) {
585: mPreprocessor@var1548 =@expr1073745287 preprocessor@var1474 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var1548 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1475 , const Token * end@var1476 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1477 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1478 , const std :: string & code@var1479 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1480 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1481 , const std :: string & what@var1482 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1483 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1484 , const std :: string & msg@var1485 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1486 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1487 , const std :: string & macroName@var1488 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1489 , const Token * end@var1490 , bool allowSemicolon@var1491 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1492 , const Severity :: SeverityType severity@var1493 , const std :: string & id@var1494 , const std :: string & msg@var1495 , bool inconclusive@var1496 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1497 , Severity :: SeverityType severity@var1498 , const std :: string & id@var1499 , const std :: string & msg@var1500 , bool inconclusive@var1501 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1502 , const Token * name@var1503 , const Token * typeDef@var1504 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1505 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1506 ,
821: const VariableMap & variableMap@var1507 ,
822: const int scopeStartVarId@var1508 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1509 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1510 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1511 ,
827: int * varId@var1512 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1513 ,
830: Token * const startToken@var1514 ,
831: const Token * const endToken@var1515 ,
832: const std :: map < std :: string , int > & varlist@var1516 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1517 ,
834: int * varId_@var1518 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1519 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1520 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var1546 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1521 ) {
861: mSettings@var1532 =@expr1073745288 settings@var1521 ;
862: list@var1525 .@expr1073745289 setSettings (@expr1073745290 settings@var1521 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var1534 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1522 ) const ;
877:
878: void dump ( std :: ostream & out@var1523 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var1524 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var1544 ;
888: }
889:
|
892:
893: TokenList list@var1525 ;
894:
895: const Token * tokens ( ) const {
896: return list@var1525 .@expr1073745291 front (@expr1073745292 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var1526 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var1527 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var1528 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var1529 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var1532 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var1530 , bool inOperator@var1531 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073745293 mVarId@var1544 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var1532 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var1533 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var1534 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var1535 ;
973:
974:
975:
976: std :: string mConfiguration@var1536 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var1537 ;
980:
981: struct TypedefInfo {
982: std :: string name@var1538 ;
983: std :: string filename@var1539 ;
984: int lineNumber@var1540 ;
985: int column@var1541 ;
986: bool used@var1542 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var1543 ;
989:
990:
991: int mVarId@var1544 ;
992:
993:
994: int mUnnamedCount@var1545 ;
995:
|
999:
1000: bool mCodeWithTemplates@var1546 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var1547 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var1548 ;
1013: } ;

##file cppcheck-2.8/lib/importproject.cpp

1:
|
44:
45: ImportProject :: ImportProject ( )
46: {
47: projectType@var94 =@expr1073745295 Type ::@expr1073745296 UNKNOWN@expr1073745294 ;
48: }
49:
50: void ImportProject :: ignorePaths ( const std :: vector < std :: string > & ipaths@var1549 )
51: {
52: for (@expr1073745297 std ::@expr3474 list < FileSettings > ::@expr3474 iterator it@var1550 =@expr1073745300 fileSettings@var93 .@expr1073745301 begin (@expr1073745302 ) ; it@var1550 !=@expr1073745303 fileSettings@var93 .@expr1073745304 end (@expr1073745305 ) ; ) {
53: bool ignore@var1551 ; ignore@var1551 =@expr1073745306 false ;
54: for (@expr1073745307 std ::@expr3474 string i@var1552 :@expr1073745309 ipaths@var1549 ) {
55: if (@expr3486 it@var1550 .@expr3487 filename@var1553 .@expr3488 size (@expr3489 ) >@expr3490 i@var1552 .@expr3491 size (@expr3492 ) &&@expr3493 it@var1550 .@expr3487 filename@var1553 .@expr3495 compare (@expr3496 0 , i@var1552 .@expr3491 size (@expr3492 ) , i@var1552 ) ==@expr3499 0 ) {
56: ignore@var1551 =@expr1073745324 true ;
57: break ;
58: }
59: if (@expr1073745325 isValidGlobPattern (@expr1073745326 i@var1552 ) &&@expr1073745327 matchglob (@expr1073745328 i@var1552 , it@var1550 .@expr3487 filename@var1553 ) ) {
60: ignore@var1551 =@expr1073745330 true ;
61: break ;
62: }
63: if (@expr1073745331 !@expr1073745332 Path ::@expr1073745333 isAbsolute (@expr1073745334 i@var1552 ) ) {
64: i@var1552 =@expr1073745335 mPath@var122 +@expr1073745336 i@var1552 ;
65: if (@expr3486 it@var1550 .@expr3487 filename@var1553 .@expr3488 size (@expr3489 ) >@expr3490 i@var1552 .@expr3491 size (@expr3492 ) &&@expr3493 it@var1550 .@expr3487 filename@var1553 .@expr3495 compare (@expr3496 0 , i@var1552 .@expr3491 size (@expr3492 ) , i@var1552 ) ==@expr3499 0 ) {
66: ignore@var1551 =@expr1073745351 true ;
67: break ;
68: }
69: }
70: }
71: if (@expr1073745352 ignore@var1551 ) {
72: fileSettings@var93 .@expr1073745353 erase (@expr1073745354 it@var1550 ++@expr1073745355 ) ; }
73: else {
74: ++@expr1073745356 it@var1550 ; }
75: }
76: }
77:
78: void ImportProject :: ignoreOtherConfigs ( const std :: string & cfg@var1554 )
79: {
80: for (@expr1073745357 std ::@expr3534 list < FileSettings > ::@expr3534 iterator it@var1555 =@expr1073745360 fileSettings@var93 .@expr1073745361 begin (@expr1073745362 ) ; it@var1555 !=@expr1073745363 fileSettings@var93 .@expr1073745364 end (@expr1073745365 ) ; ) {
81: if (@expr1073745366 it@var1555 .@expr1073745367 cfg@var1556 !=@expr1073745368 cfg@var1554 ) {
82: fileSettings@var93 .@expr1073745369 erase (@expr1073745370 it@var1555 ++@expr1073745371 ) ; }
83: else {
84: ++@expr1073745372 it@var1555 ; }
85: }
86: }
87:
88: void ImportProject :: FileSettings :: setDefines ( std :: string defs@var1557 )
89: {
90: while (@expr1073745374 defs@var1557 .@expr3551 find (@expr3552 ";%(" ) !=@expr1073745377 std ::@expr3554 string ::@expr3555 npos@expr3549 ) {
91: const std ::@expr3556 string ::@expr3556 size_type pos1@var1558 =@expr1073745382 defs@var1557 .@expr3551 find (@expr3552 ";%(" ) ;
92: const std ::@expr3556 string ::@expr3556 size_type pos2@var1559 =@expr1073745387 defs@var1557 .@expr3551 find (@expr1073745389 ';' , pos1@var1558 +@expr1073745390 1 ) ;
93: defs@var1557 .@expr3567 erase (@expr1073745392 pos1@var1558 , pos2@var1559 ==@expr1073745393 std ::@expr3554 string ::@expr3555 npos@expr3549 ?@expr1073745396 pos2@var1559 :@expr1073745397 (@expr1073745398 pos2@var1559 -@expr1073745399 pos1@var1558 ) ) ;
94: }
95: while (@expr1073745400 defs@var1557 .@expr3551 find (@expr3578 ";;" ) !=@expr1073745403 std ::@expr3554 string ::@expr3555 npos@expr3549 ) {
96: defs@var1557 .@expr3567 erase (@expr1073745407 defs@var1557 .@expr3551 find (@expr3578 ";;" ) , 1 ) ; }
97: while (@expr1073745410 !@expr3587 defs@var1557 .@expr3588 empty (@expr3589 ) &&@expr1073745414 defs@var1557 [@expr1073745415 0 ] ==@expr1073745416 ';' ) {
98: defs@var1557 .@expr3567 erase (@expr1073745418 0 , 1 ) ; }
99: while (@expr1073745419 !@expr3587 defs@var1557 .@expr3588 empty (@expr3589 ) &&@expr1073745423 endsWith (@expr1073745424 defs@var1557 , ';' ) ) {
100: defs@var1557 .@expr3567 erase (@expr1073745426 defs@var1557 .@expr3603 size (@expr3604 ) -@expr1073745429 1U ) ; }
101: bool eq@var1560 ; eq@var1560 =@expr1073745430 false ;
102: for (@expr1073745431 unsigned long pos@var1561 =@expr1073745432 0 ; pos@var1561 <@expr3609 defs@var1557 .@expr3603 size (@expr3604 ) ; ++@expr1073745436 pos@var1561 ) {
103: if (@expr1073745437 defs@var1557 [@expr3614 pos@var1561 ] ==@expr1073745439 '(' ||@expr1073745440 defs@var1557 [@expr3614 pos@var1561 ] ==@expr1073745442 '=' ) {
104: eq@var1560 =@expr1073745443 true ; }
105: else { if (@expr1073745444 defs@var1557 [@expr3614 pos@var1561 ] ==@expr1073745446 ';' ) {
106: if (@expr1073745447 !@expr3624 eq@var1560 ) {
107: defs@var1557 .@expr1073745449 insert (@expr1073745450 pos@var1561 , "=1" ) ;
108: pos@var1561 +=@expr1073745451 3 ;
109: }
110: if (@expr1073745452 pos@var1561 <@expr3609 defs@var1557 .@expr3603 size (@expr3604 ) ) {
111: eq@var1560 =@expr1073745456 false ; }
112: } }
113: }
114: if (@expr1073745457 !@expr3624 eq@var1560 &&@expr1073745459 !@expr3587 defs@var1557 .@expr3588 empty (@expr3589 ) ) {
115: defs@var1557 +=@expr1073745463 "=1" ; }
116: defines@var80 .@expr1073745464 swap (@expr1073745465 defs@var1557 ) ;
117: }
118:
119: static bool simplifyPathWithVariables ( std :: string & s@var1562 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1563 )
120: {
121: std ::@expr1073745467 set < std ::@expr3644 string , cppcheck ::@expr3644 stricmp > expanded@var1564 ;
122: std ::@expr3646 string ::@expr1073745471 size_type start@var1565 ; start@var1565 =@expr1073745472 0 ;
123: while (@expr1073745473 (@expr1073745474 start@var1565 =@expr1073745475 s@var1562 .@expr3652 find (@expr3653 "$(" ) ) !=@expr1073745478 std ::@expr3646 string ::@expr3656 npos@expr3642 ) {
124: const std ::@expr3644 string ::@expr3644 size_type end@var1566 =@expr1073745483 s@var1562 .@expr3652 find (@expr1073745485 ')' , start@var1565 ) ;
125: if (@expr1073745486 end@var1566 ==@expr1073745487 std ::@expr3646 string ::@expr3656 npos@expr3642 ) {
126: break ; }
127: const std ::@expr3644 string var@var1567 =@expr1073745491 s@var1562 .@expr3668 substr (@expr1073745493 start@var1565 +@expr1073745494 2 , end@var1566 -@expr1073745495 start@var1565 -@expr1073745496 2 ) ;
128: if (@expr1073745497 expanded@var1564 .@expr1073745498 find (@expr1073745499 var@var1567 ) !=@expr1073745500 expanded@var1564 .@expr1073745501 end (@expr1073745502 ) ) {
129: break ; }
130: expanded@var1564 .@expr1073745503 insert (@expr1073745504 var@var1567 ) ;
131: std ::@expr1073745505 map < std ::@expr3644 string , std ::@expr3644 string , cppcheck ::@expr3644 stricmp > ::@expr1073745509 const_iterator it1@var1568 ; it1@var1568 =@expr1073745510 variables@var1563 .@expr3687 find (@expr3688 var@var1567 ) ;
132:
133: if (@expr1073745513 it1@var1568 ==@expr1073745514 variables@var1563 .@expr1073745515 end (@expr1073745516 ) ) {
134: const char * envValue@var1569 ; envValue@var1569 =@expr1073745517 std ::@expr1073745518 getenv (@expr1073745519 var@var1567 .@expr1073745520 c_str (@expr1073745521 ) ) ;
135: if (@expr1073745522 !@expr1073745523 envValue@var1569 ) {
136:
137: break ;
138: }
139: variables@var1563 [@expr1073745524 var@var1567 ] =@expr1073745525 std ::@expr3646 string (@expr1073745527 envValue@var1569 ) ;
140: it1@var1568 =@expr1073745528 variables@var1563 .@expr3687 find (@expr3688 var@var1567 ) ;
141: }
142: s@var1562 =@expr1073745531 s@var1562 .@expr3668 substr (@expr1073745533 0 , start@var1565 ) +@expr1073745534 it1@var1568 .@expr1073745535 second@var1570 +@expr1073745536 s@var1562 .@expr3668 substr (@expr1073745538 end@var1566 +@expr1073745539 1 ) ;
143: }
144: if (@expr1073745540 s@var1562 .@expr3652 find (@expr3653 "$(" ) !=@expr1073745543 std ::@expr3646 string ::@expr3656 npos@expr3642 ) {
145: return false ; }
146: s@var1562 =@expr1073745546 Path ::@expr1073745547 simplifyPath (@expr1073745548 Path ::@expr1073745549 fromNativeSeparators (@expr1073745550 s@var1562 ) ) ;
147: return true ;
148: }
149:
150: void ImportProject :: FileSettings :: setIncludePaths ( const std :: string & basepath@var1571 , const std :: list < std :: string > & in@var1572 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1573 )
151: {
152: std ::@expr1073745552 set < std ::@expr3729 string > found@var1574 ;
153:
154: const std ::@expr1073745554 list < std ::@expr3729 string > copyIn@var1575 (@expr1073745556 in@var1572 ) ;
155: includePaths@var82 .@expr1073745557 clear (@expr1073745558 ) ;
156: for (@expr1073745559 const std ::@expr3729 string &@expr1073745561 ipath@var1576 :@expr1073745562 copyIn@var1575 ) {
157: if (@expr1073745563 ipath@var1576 .@expr1073745564 empty (@expr1073745565 ) ) {
158: continue ; }
159: if (@expr1073745566 ipath@var1576 .@expr1073745567 compare (@expr1073745568 0 , 2 , "%(" ) ==@expr1073745569 0 ) {
160: continue ; }
161: std ::@expr1073745570 string s@var1577 (@expr1073745571 Path ::@expr1073745572 fromNativeSeparators (@expr1073745573 ipath@var1576 ) ) ;
162: if (@expr1073745574 !@expr1073745575 found@var1574 .@expr1073745576 insert (@expr1073745577 s@var1577 ) .@expr1073745578 second@var1578 ) {
163: continue ; }
164: if (@expr1073745579 s@var1577 [@expr1073745580 0 ] ==@expr1073745581 '/' ||@expr1073745582 (@expr1073745583 s@var1577 .@expr3760 size (@expr3761 ) >@expr1073745586 1U &&@expr1073745587 s@var1577 .@expr1073745588 compare (@expr1073745589 1 , 2 , ":/" ) ==@expr1073745590 0 ) ) {
165: if (@expr1073745591 !@expr1073745592 endsWith (@expr3769 s@var1577 , '/' ) ) {
166: s@var1577 +=@expr1073745594 '/' ; }
167: includePaths@var82 .@expr3771 push_back (@expr1073745596 s@var1577 ) ;
168: continue ;
169: }
170:
171: if (@expr1073745597 endsWith (@expr3769 s@var1577 , '/' ) ) {
172: s@var1577 .@expr1073745599 erase (@expr1073745600 s@var1577 .@expr3760 size (@expr3761 ) -@expr1073745603 1U ) ; }
173:
174: if (@expr1073745604 s@var1577 .@expr1073745605 find (@expr1073745606 "$(" ) ==@expr1073745607 std ::@expr1073745608 string ::@expr1073745609 npos@expr1073745551 ) {
175: s@var1577 =@expr1073745610 Path ::@expr1073745611 simplifyPath (@expr1073745612 basepath@var1571 +@expr1073745613 s@var1577 ) ;
176: } else {
177: if (@expr1073745614 !@expr1073745615 simplifyPathWithVariables (@expr1073745616 s@var1577 , variables@var1573 ) ) {
178: continue ; }
179: }
180: if (@expr1073745617 s@var1577 .@expr1073745618 empty (@expr1073745619 ) ) {
181: continue ; }
182: includePaths@var82 .@expr3771 push_back (@expr1073745621 s@var1577 +@expr1073745622 '/' ) ;
183: }
184: }
185:
186: ImportProject :: Type ImportProject :: import ( const std :: string & filename@var1579 , Settings * settings@var1580 )
187: {
188: std ::@expr1073745624 ifstream fin@var1581 (@expr1073745625 filename@var1579 ) ;
189: if (@expr1073745626 !@expr1073745627 fin@var1581 .@expr1073745628 is_open (@expr1073745629 ) ) {
190: return ImportProject ::@expr3806 Type ::@expr1073745631 MISSING ; }
191:
192: mPath@var122 =@expr1073745632 Path ::@expr1073745633 getPathFromFilename (@expr1073745634 Path ::@expr1073745635 fromNativeSeparators (@expr1073745636 filename@var1579 ) ) ;
193: if (@expr1073745637 !@expr1073745638 mPath@var122 .@expr1073745639 empty (@expr1073745640 ) &&@expr1073745641 !@expr1073745642 endsWith (@expr1073745643 mPath@var122 , '/' ) ) {
194: mPath@var122 +=@expr1073745644 '/' ; }
195:
196: const std ::@expr1073745645 vector < std ::@expr3822 string > fileFilters@var1582 =@expr1073745647
197: settings@var1580 ?@expr1073745648 settings@var1580 .@expr1073745649 fileFilters@var1583 :@expr1073745650 std ::@expr1073745651 vector < std ::@expr3822 string > (@expr1073745653 ) ;
198:
199: if (@expr1073745654 endsWith (@expr1073745655 filename@var1579 , ".json" ) ) {
200: if (@expr1073745656 importCompileCommands (@expr1073745657 fin@var1581 ) ) {
201: setRelativePaths (@expr3834 filename@var1579 ) ;
202: return ImportProject ::@expr3806 Type ::@expr1073745660 COMPILE_DB ;
203: }
204: } else { if (@expr1073745661 endsWith (@expr1073745662 filename@var1579 , ".sln" ) ) {
205: if (@expr1073745663 importSln (@expr1073745664 fin@var1581 , mPath@var122 , fileFilters@var1582 ) ) {
206: setRelativePaths (@expr3834 filename@var1579 ) ;
207: return ImportProject ::@expr3806 Type ::@expr1073745667 VS_SLN ;
208: }
209: } else { if (@expr1073745668 endsWith (@expr1073745669 filename@var1579 , ".vcxproj" ) ) {
210: std ::@expr1073745670 map < std ::@expr3822 string , std ::@expr3822 string , cppcheck ::@expr3822 stricmp > variables@var1584 ;
211: if (@expr1073745674 importVcxproj (@expr1073745675 filename@var1579 , variables@var1584 , emptyString@var1 , fileFilters@var1582 ) ) {
212: setRelativePaths (@expr3834 filename@var1579 ) ;
213: return ImportProject ::@expr3806 Type ::@expr1073745678 VS_VCXPROJ ;
214: }
215: } else { if (@expr1073745679 endsWith (@expr1073745680 filename@var1579 , ".bpr" ) ) {
216: if (@expr1073745681 importBcb6Prj (@expr1073745682 filename@var1579 ) ) {
217: setRelativePaths (@expr3834 filename@var1579 ) ;
218: return ImportProject ::@expr3806 Type ::@expr1073745685 BORLAND ;
219: }
220: } else { if (@expr1073745686 settings@var1580 &&@expr1073745687 endsWith (@expr1073745688 filename@var1579 , ".cppcheck" ) ) {
221: if (@expr1073745689 importCppcheckGuiProject (@expr1073745690 fin@var1581 , settings@var1580 ) ) {
222: setRelativePaths (@expr3834 filename@var1579 ) ;
223: return ImportProject ::@expr3806 Type ::@expr1073745693 CPPCHECK_GUI ;
224: }
225: } else {
226: return ImportProject ::@expr3806 Type ::@expr1073745695 UNKNOWN@expr1073745623 ;
227: } } } } }
228: return ImportProject ::@expr3806 Type ::@expr1073745697 FAILURE ;
229: }
230:
231: static std :: string readUntil ( const std :: string & command@var1585 , std :: string :: size_type * pos@var1586 , const char until@var1587 [ ] )
232: {
233: std ::@expr1073745698 string ret@var1588 ;
234: bool escapedString@var1589 ; escapedString@var1589 =@expr1073745699 false ;
235: bool str@var1590 ; str@var1590 =@expr1073745700 false ;
236: bool escape@var1591 ; escape@var1591 =@expr1073745701 false ;
237: for (@expr1073745702 ; *@expr3879 pos@var1586 <@expr1073745704 command@var1585 .@expr1073745705 size (@expr1073745706 ) &&@expr1073745707 (@expr1073745708 str@var1590 ||@expr1073745709 !@expr1073745710 std ::@expr1073745711 strchr (@expr1073745712 until@var1587 , command@var1585 [@expr3889 *@expr3879 pos@var1586 ] ) ) ; (@expr3891 *@expr3879 pos@var1586 ) ++@expr1073745717 ) {
238: if (@expr1073745718 escape@var1591 ) {
239: escape@var1591 =@expr1073745719 false ; }
240: else { if (@expr1073745720 command@var1585 [@expr3889 *@expr3879 pos@var1586 ] ==@expr1073745723 '\\' ) {
241: if (@expr1073745724 str@var1590 ) {
242: escape@var1591 =@expr1073745725 true ; }
243: else { if (@expr1073745726 command@var1585 [@expr1073745727 *@expr3879 pos@var1586 +@expr1073745729 1 ] ==@expr1073745730 '"' ) {
244: if (@expr1073745731 escapedString@var1589 ) {
245: return ret@var1588 +@expr1073745732 "\\\"" ; }
246: escapedString@var1589 =@expr1073745733 true ;
247: ret@var1588 +=@expr1073745734 "\\\"" ;
248: (@expr3891 *@expr3879 pos@var1586 ) ++@expr1073745737 ;
249: continue ;
250: } }
251: } else { if (@expr1073745738 command@var1585 [@expr3889 *@expr3879 pos@var1586 ] ==@expr1073745741 '\"' ) {
252: str@var1590 =@expr1073745742 !@expr1073745743 str@var1590 ; } } }
253: ret@var1588 +=@expr1073745744 command@var1585 [@expr3889 *@expr3879 pos@var1586 ] ;
254: }
255: return ret@var1588 ;
256: }
257:
258: static std :: string unescape ( const std :: string & in@var1592 )
259: {
260: std ::@expr1073745747 string out@var1593 ;
261: bool escape@var1594 ; escape@var1594 =@expr1073745748 false ;
262: for (@expr1073745749 char c@var1595 :@expr1073745750 in@var1592 ) {
263: if (@expr1073745751 escape@var1594 ) {
264: escape@var1594 =@expr1073745752 false ;
265: if (@expr1073745753 !@expr1073745754 std ::@expr1073745755 strchr (@expr1073745756 "\\\"\'" , c@var1595 ) ) {
266: out@var1593 +=@expr1073745757 "\\" ; }
267: out@var1593 +=@expr1073745758 c@var1595 ;
268: } else { if (@expr1073745759 c@var1595 ==@expr1073745760 '\\' ) {
269: escape@var1594 =@expr1073745761 true ; }
270: else {
271: out@var1593 +=@expr1073745762 c@var1595 ; } }
272: }
273: return out@var1593 ;
274: }
275:
276: void ImportProject :: FileSettings :: parseCommand ( std :: string command@var1596 )
277: {
278: std ::@expr1073745764 string defs@var1597 ;
279:
280:
281: std ::@expr3941 string ::@expr1073745766 size_type pos@var1598 ; pos@var1598 =@expr1073745767 0 ;
282: while (@expr1073745768 std ::@expr3941 string ::@expr1073745770 npos@expr1073745763 !=@expr1073745771 (@expr1073745772 pos@var1598 =@expr1073745773 command@var1596 .@expr1073745774 find (@expr1073745775 ' ' , pos@var1598 ) ) ) {
283: while (@expr3952 pos@var1598 <@expr3953 command@var1596 .@expr3954 size (@expr3955 ) &&@expr3956 command@var1596 [@expr3957 pos@var1598 ] ==@expr3958 ' ' ) {
284: pos@var1598 ++@expr1073745783 ; }
285: if (@expr3960 pos@var1598 >=@expr3961 command@var1596 .@expr3954 size (@expr3955 ) ) {
286: break ; }
287: if (@expr1073745788 command@var1596 [@expr3957 pos@var1598 ] !=@expr1073745790 '/' &&@expr1073745791 command@var1596 [@expr3957 pos@var1598 ] !=@expr1073745793 '-' ) {
288: continue ; }
289: pos@var1598 ++@expr1073745794 ;
290: if (@expr3960 pos@var1598 >=@expr3961 command@var1596 .@expr3954 size (@expr3955 ) ) {
291: break ; }
292: const char F@var1599 =@expr1073745799 command@var1596 [@expr1073745800 pos@var1598 ++@expr1073745801 ] ;
293: if (@expr1073745802 std ::@expr1073745803 strchr (@expr1073745804 "DUI" , F@var1599 ) ) {
294: while (@expr3952 pos@var1598 <@expr3953 command@var1596 .@expr3954 size (@expr3955 ) &&@expr3956 command@var1596 [@expr3957 pos@var1598 ] ==@expr3958 ' ' ) {
295: ++@expr1073745812 pos@var1598 ; }
296: }
297: const std ::@expr3989 string fval@var1600 =@expr1073745814 readUntil (@expr1073745815 command@var1596 , &@expr3992 pos@var1598 , " =" ) ;
298: if (@expr1073745817 F@var1599 ==@expr1073745818 'D' ) {
299: std ::@expr1073745819 string defval@var1601 ; defval@var1601 =@expr1073745820 readUntil (@expr3997 command@var1596 , &@expr3992 pos@var1598 , " " ) ;
300: defs@var1597 +=@expr1073745823 fval@var1600 ;
301: if (@expr1073745824 defval@var1601 .@expr4001 size (@expr4002 ) >=@expr1073745827 3 &&@expr1073745828 defval@var1601 .@expr4005 compare (@expr1073745830 0 , 2 , "=\"" ) ==@expr1073745831 0 &&@expr1073745832 defval@var1601 .@expr1073745833 back (@expr1073745834 ) ==@expr1073745835 '\"' ) {
302: defval@var1601 =@expr1073745836 "=" +@expr1073745837 unescape (@expr1073745838 defval@var1601 .@expr4015 substr (@expr1073745840 2 , defval@var1601 .@expr4001 size (@expr4002 ) -@expr1073745843 3 ) ) ; }
303: else { if (@expr1073745844 defval@var1601 .@expr4001 size (@expr4002 ) >=@expr1073745847 5 &&@expr1073745848 defval@var1601 .@expr4005 compare (@expr1073745850 0 , 3 , "=\\\"" ) ==@expr1073745851 0 &&@expr1073745852 endsWith (@expr1073745853 defval@var1601 , "\\\"" ) ) {
304: defval@var1601 =@expr1073745854 "=\"" +@expr1073745855 unescape (@expr1073745856 defval@var1601 .@expr4015 substr (@expr1073745858 3 , defval@var1601 .@expr4001 size (@expr4002 ) -@expr1073745861 5 ) ) +@expr1073745862 "\"" ; } }
305: if (@expr1073745863 !@expr1073745864 defval@var1601 .@expr1073745865 empty (@expr1073745866 ) ) {
306: defs@var1597 +=@expr1073745867 defval@var1601 ; }
307: defs@var1597 +=@expr1073745868 ';' ;
308: } else { if (@expr1073745869 F@var1599 ==@expr1073745870 'U' ) {
309: undefs@var81 .@expr1073745871 insert (@expr1073745872 fval@var1600 ) ; }
310: else { if (@expr1073745873 F@var1599 ==@expr1073745874 'I' ) {
311: std ::@expr1073745875 string i@var1602 ; i@var1602 =@expr1073745876 fval@var1600 ;
312: if (@expr1073745877 i@var1602 .@expr4054 size (@expr4055 ) >@expr1073745880 1 &&@expr1073745881 i@var1602 [@expr1073745882 0 ] ==@expr1073745883 '\"' &&@expr1073745884 i@var1602 .@expr1073745885 back (@expr1073745886 ) ==@expr1073745887 '\"' ) {
313: i@var1602 =@expr1073745888 unescape (@expr1073745889 i@var1602 .@expr1073745890 substr (@expr1073745891 1 , i@var1602 .@expr4054 size (@expr4055 ) -@expr1073745894 2 ) ) ; }
314: if (@expr1073745895 std ::@expr1073745896 find (@expr1073745897 includePaths@var82 .@expr1073745898 begin (@expr1073745899 ) , includePaths@var82 .@expr4076 end (@expr4077 ) , i@var1602 ) ==@expr1073745902 includePaths@var82 .@expr4076 end (@expr4077 ) ) {
315: includePaths@var82 .@expr1073745905 push_back (@expr1073745906 i@var1602 ) ; }
316: } else { if (@expr1073745907 F@var1599 ==@expr1073745908 's' &&@expr1073745909 fval@var1600 .@expr1073745910 compare (@expr1073745911 0 , 2 , "td" ) ==@expr1073745912 0 ) {
317: ++@expr1073745913 pos@var1598 ;
318: const std ::@expr3989 string stdval@var1603 =@expr1073745915 readUntil (@expr3997 command@var1596 , &@expr3992 pos@var1598 , " " ) ;
319: standard@var84 =@expr1073745918 stdval@var1603 ;
320:
321: if (@expr1073745919 standard@var84 .@expr4096 compare (@expr1073745921 0 , 3 , "c++" ) ||@expr1073745922 standard@var84 .@expr4096 compare (@expr1073745924 0 , 5 , "gnu++" ) ) {
322: const std ::@expr3989 string stddef@var1604 =@expr1073745926 simplecpp ::@expr1073745927 getCppStdString (@expr1073745928 standard@var84 ) ;
323: if (@expr1073745929 stddef@var1604 .@expr1073745930 empty (@expr1073745931 ) ) {
324:
325: continue ;
326: }
327:
328: defs@var1597 +=@expr1073745932 "__cplusplus=" ;
329: defs@var1597 +=@expr1073745933 stddef@var1604 ;
330: defs@var1597 +=@expr1073745934 ";" ;
331: } else { if (@expr1073745935 standard@var84 .@expr4096 compare (@expr1073745937 0 , 1 , "c" ) ||@expr1073745938 standard@var84 .@expr4096 compare (@expr1073745940 0 , 3 , "gnu" ) ) {
332: const std ::@expr3989 string stddef@var1605 =@expr1073745942 simplecpp ::@expr1073745943 getCStdString (@expr1073745944 standard@var84 ) ;
333: if (@expr1073745945 stddef@var1605 .@expr1073745946 empty (@expr1073745947 ) ) {
334:
335: continue ;
336: }
337:
338: defs@var1597 +=@expr1073745948 "__STDC_VERSION__=" ;
339: defs@var1597 +=@expr1073745949 stddef@var1605 ;
340: defs@var1597 +=@expr1073745950 ";" ;
341: } }
342: } else { if (@expr1073745951 F@var1599 ==@expr1073745952 'i' &&@expr1073745953 fval@var1600 ==@expr1073745954 "system" ) {
343: ++@expr1073745955 pos@var1598 ;
344: const std ::@expr3989 string isystem@var1606 =@expr1073745957 readUntil (@expr3997 command@var1596 , &@expr3992 pos@var1598 , " " ) ;
345: systemIncludePaths@var83 .@expr1073745960 push_back (@expr1073745961 isystem@var1606 ) ;
346: } else { if (@expr1073745962 F@var1599 ==@expr1073745963 'm' ) {
347: if (@expr1073745964 fval@var1600 ==@expr1073745965 "unicode" ) {
348: defs@var1597 +=@expr1073745966 "UNICODE" ;
349: defs@var1597 +=@expr1073745967 ";" ;
350: }
351: } else { if (@expr1073745968 F@var1599 ==@expr1073745969 'f' ) {
352: if (@expr1073745970 fval@var1600 ==@expr1073745971 "pic" ) {
353: defs@var1597 +=@expr1073745972 "__pic__" ;
354: defs@var1597 +=@expr1073745973 ";" ;
355: } else { if (@expr1073745974 fval@var1600 ==@expr1073745975 "PIC" ) {
356: defs@var1597 +=@expr1073745976 "__PIC__" ;
357: defs@var1597 +=@expr1073745977 ";" ;
358: } else { if (@expr1073745978 fval@var1600 ==@expr1073745979 "pie" ) {
359: defs@var1597 +=@expr1073745980 "__pie__" ;
360: defs@var1597 +=@expr1073745981 ";" ;
361: } else { if (@expr1073745982 fval@var1600 ==@expr1073745983 "PIE" ) {
362: defs@var1597 +=@expr1073745984 "__PIE__" ;
363: defs@var1597 +=@expr1073745985 ";" ;
364: } } } }
365: } } } } } } }
366: }
367: setDefines (@expr1073745986 defs@var1597 ) ;
368: }
369:
370: bool ImportProject :: importCompileCommands ( std :: istream & istr@var1607 )
371: {
372: picojson ::@expr1073745988 value compileCommands@var1608 ;
373: istr@var1607 >>@expr1073745989 compileCommands@var1608 ;
374: if (@expr1073745990 !@expr1073745991 compileCommands@var1608 .@expr1073745992 is < picojson ::@expr4169 array > (@expr1073745994 ) ) {
375: printError (@expr1073745995 "compilation database is not a JSON array" ) ;
376: return false ;
377: }
378:
379: for (@expr1073745996 const picojson ::@expr4169 value &@expr4174 fileInfo@var1609 :@expr1073745999 compileCommands@var1608 .@expr1073746000 get < picojson ::@expr4169 array > (@expr1073746002 ) ) {
380: picojson ::@expr1073746003 object obj@var1610 ; obj@var1610 =@expr1073746004 fileInfo@var1609 .@expr1073746005 get < picojson ::@expr4169 object > (@expr1073746007 ) ;
381: std ::@expr1073746008 string dirpath@var1611 ; dirpath@var1611 =@expr1073746009 Path ::@expr4186 fromNativeSeparators (@expr1073746011 obj@var1610 [@expr1073746012 "directory" ] .@expr1073746013 get < std ::@expr4169 string > (@expr1073746015 ) ) ;
382:
383:
384:
385: if (@expr1073746016 !@expr1073746017 endsWith (@expr1073746018 dirpath@var1611 , '/' ) ) {
386: dirpath@var1611 +=@expr1073746019 '/' ; }
387:
388: const std ::@expr4169 string directory@var1612 =@expr1073746021 dirpath@var1611 ;
389:
390: std ::@expr1073746022 string command@var1613 ;
391: if (@expr1073746023 obj@var1610 .@expr4200 count (@expr1073746025 "arguments" ) ) {
392: if (@expr1073746026 obj@var1610 [@expr4203 "arguments" ] .@expr1073746028 is < picojson ::@expr4169 array > (@expr1073746030 ) ) {
393: for (@expr1073746031 const picojson ::@expr4169 value &@expr4174 arg@var1614 :@expr1073746034 obj@var1610 [@expr4203 "arguments" ] .@expr1073746036 get < picojson ::@expr4169 array > (@expr1073746038 ) ) {
394: if (@expr1073746039 arg@var1614 .@expr1073746040 is < std ::@expr4169 string > (@expr1073746042 ) ) {
395: std ::@expr1073746043 string str@var1615 ; str@var1615 =@expr1073746044 arg@var1614 .@expr1073746045 get < std ::@expr4169 string > (@expr1073746047 ) ;
396: if (@expr1073746048 str@var1615 .@expr1073746049 find (@expr1073746050 " " ) !=@expr1073746051 std ::@expr1073746052 string ::@expr1073746053 npos@expr1073745987 ) {
397: str@var1615 =@expr1073746054 "\"" +@expr1073746055 str@var1615 +@expr1073746056 "\"" ; }
398: command@var1613 +=@expr1073746057 str@var1615 +@expr1073746058 " " ;
399: }
400: }
401: } else {
402: printError (@expr1073746059 "'arguments' field in compilation database entry is not a JSON array" ) ;
403: return false ;
404: }
405: } else { if (@expr1073746060 obj@var1610 .@expr4200 count (@expr1073746062 "command" ) ) {
406: if (@expr1073746063 obj@var1610 [@expr4240 "command" ] .@expr1073746065 is < std ::@expr4169 string > (@expr1073746067 ) ) {
407: command@var1613 =@expr1073746068 obj@var1610 [@expr4240 "command" ] .@expr1073746070 get < std ::@expr4169 string > (@expr1073746072 ) ;
408: } else {
409: printError (@expr1073746073 "'command' field in compilation database entry is not a string" ) ;
410: return false ;
411: }
412: } else {
413: printError (@expr1073746074 "no 'arguments' or 'command' field found in compilation database entry" ) ;
414: return false ;
415: } }
416:
417: if (@expr1073746075 !@expr1073746076 obj@var1610 .@expr4200 count (@expr1073746078 "file" ) ||@expr1073746079 !@expr1073746080 obj@var1610 [@expr4257 "file" ] .@expr1073746082 is < std ::@expr4169 string > (@expr1073746084 ) ) {
418: printError (@expr1073746085 "skip compilation database entry because it does not have a proper 'file' field" ) ;
419: continue ;
420: }
421:
422: const std ::@expr4169 string file@var1616 =@expr1073746087 Path ::@expr4186 fromNativeSeparators (@expr1073746089 obj@var1610 [@expr4257 "file" ] .@expr1073746091 get < std ::@expr4169 string > (@expr1073746093 ) ) ;
423:
424:
425: if (@expr1073746094 !@expr1073746095 Path ::@expr1073746096 acceptFile (@expr1073746097 file@var1616 ) ) {
426: continue ; }
427:
428: struct FileSettings fs@var1617 ;
429: if (@expr1073746098 Path ::@expr1073746099 isAbsolute (@expr1073746100 file@var1616 ) ) {
430: fs@var1617 .@expr4277 filename@var1618 =@expr1073746102 Path ::@expr4279 simplifyPath (@expr1073746104 file@var1616 ) ; }
431:
|
437:
438: else {
439: fs@var1617 .@expr4277 filename@var1618 =@expr1073746106 Path ::@expr4279 simplifyPath (@expr1073746108 directory@var1612 +@expr1073746109 file@var1616 ) ; }
440: if (@expr1073746110 !@expr1073746111 sourceFileExists (@expr1073746112 fs@var1617 .@expr4277 filename@var1618 ) ) {
441: printError (@expr1073746114 "'" +@expr1073746115 fs@var1617 .@expr4277 filename@var1618 +@expr1073746117 "' from compilation database does not exist" ) ;
442: return false ;
443: }
444: fs@var1617 .@expr1073746118 parseCommand (@expr1073746119 command@var1613 ) ;
445: std ::@expr1073746120 map < std ::@expr4169 string , std ::@expr4169 string , cppcheck ::@expr4169 stricmp > variables@var1619 ;
446: fs@var1617 .@expr1073746124 setIncludePaths (@expr1073746125 directory@var1612 , fs@var1617 .@expr1073746126 includePaths@var1620 , variables@var1619 ) ;
447: fileSettings@var93 .@expr1073746127 push_back (@expr1073746128 fs@var1617 ) ;
448: }
449:
450: return true ;
451: }
452:
453: bool ImportProject :: importSln ( std :: istream & istr@var1621 , const std :: string & path@var1622 , const std :: vector < std :: string > & fileFilters@var1623 )
454: {
455: std ::@expr1073746130 string line@var1624 ;
456:
457: if (@expr1073746131 !@expr4308 std ::@expr4309 getline (@expr4310 istr@var1621 , line@var1624 ) ) {
458: printError (@expr1073746135 "Visual Studio solution file is empty" ) ;
459: return false ;
460: }
461:
462: if (@expr1073746136 line@var1624 .@expr4313 find (@expr4314 "Microsoft Visual Studio Solution File" ) !=@expr4315 0 ) {
463:
464: if (@expr1073746140 !@expr4308 std ::@expr4309 getline (@expr4310 istr@var1621 , line@var1624 ) ||@expr1073746144 line@var1624 .@expr4313 find (@expr4314 "Microsoft Visual Studio Solution File" ) !=@expr4315 0 ) {
465: printError (@expr1073746148 "Visual Studio solution file header not found" ) ;
466: return false ;
467: }
468: }
469:
470: std ::@expr1073746149 map < std ::@expr4326 string , std ::@expr4326 string , cppcheck ::@expr4326 stricmp > variables@var1625 ;
471: variables@var1625 [@expr1073746153 "SolutionDir" ] =@expr1073746154 path@var1622 ;
472:
473: bool found@var1626 ; found@var1626 =@expr1073746155 false ;
474:
475: while (@expr1073746156 std ::@expr4309 getline (@expr4310 istr@var1621 , line@var1624 ) ) {
476: if (@expr1073746159 line@var1624 .@expr1073746160 compare (@expr1073746161 0 , 8 , "Project(" ) !=@expr1073746162 0 ) {
477: continue ; }
478: const std ::@expr4326 string ::@expr4326 size_type pos@var1627 =@expr1073746165 line@var1624 .@expr4313 find (@expr1073746167 ".vcxproj" ) ;
479: if (@expr1073746168 pos@var1627 ==@expr1073746169 std ::@expr4346 string ::@expr4347 npos@expr4305 ) {
480: continue ; }
481: const std ::@expr4326 string ::@expr4326 size_type pos1@var1628 =@expr1073746174 line@var1624 .@expr1073746175 rfind (@expr1073746176 '\"' , pos@var1627 ) ;
482: if (@expr1073746177 pos1@var1628 ==@expr1073746178 std ::@expr4346 string ::@expr4347 npos@expr4305 ) {
483: continue ; }
484: std ::@expr1073746181 string vcxproj@var1629 (@expr1073746182 line@var1624 .@expr1073746183 substr (@expr1073746184 pos1@var1628 +@expr1073746185 1 , pos@var1627 -@expr1073746186 pos1@var1628 +@expr1073746187 7 ) ) ;
485: if (@expr1073746188 !@expr1073746189 Path ::@expr1073746190 isAbsolute (@expr1073746191 vcxproj@var1629 ) ) {
486: vcxproj@var1629 =@expr1073746192 path@var1622 +@expr1073746193 vcxproj@var1629 ; }
487: if (@expr1073746194 !@expr1073746195 importVcxproj (@expr1073746196 Path ::@expr1073746197 fromNativeSeparators (@expr1073746198 vcxproj@var1629 ) , variables@var1625 , emptyString@var1 , fileFilters@var1623 ) ) {
488: printError (@expr1073746199 "failed to load '" +@expr1073746200 vcxproj@var1629 +@expr1073746201 "' from Visual Studio solution" ) ;
489: return false ;
490: }
491: found@var1626 =@expr1073746202 true ;
492: }
493:
494: if (@expr1073746203 !@expr1073746204 found@var1626 ) {
495: printError (@expr1073746205 "no projects found in Visual Studio solution file" ) ;
496: return false ;
497: }
498:
499: return true ;
500: }
501:
502: namespace {
503: struct ProjectConfiguration {
504: explicit ProjectConfiguration ( const tinyxml2 :: XMLElement * cfg@var1630 ) : platform@var1635 ( Unknown ) {
505: const char * a@var1631 ; a@var1631 =@expr1073746206 cfg@var1630 .@expr1073746207 Attribute (@expr1073746208 "Include" ) ;
506: if (@expr1073746209 a@var1631 ) {
507: name@var1633 =@expr1073746210 a@var1631 ; }
508: for (@expr1073746211 const tinyxml2 ::@expr1073746212 XMLElement *@expr1073746213 e@var1632 =@expr1073746214 cfg@var1630 .@expr1073746215 FirstChildElement (@expr1073746216 ) ; e@var1632 ; e@var1632 =@expr1073746217 e@var1632 .@expr1073746218 NextSiblingElement (@expr1073746219 ) ) {
509: if (@expr1073746220 !@expr1073746221 e@var1632 .@expr4398 GetText (@expr4399 ) ) {
510: continue ; }
511: if (@expr1073746224 std ::@expr4401 strcmp (@expr1073746226 e@var1632 .@expr4403 Name (@expr4404 ) , "Configuration" ) ==@expr1073746229 0 ) {
512: configuration@var1634 =@expr1073746230 e@var1632 .@expr4398 GetText (@expr4399 ) ; }
513: else { if (@expr1073746233 std ::@expr4401 strcmp (@expr1073746235 e@var1632 .@expr4403 Name (@expr4404 ) , "Platform" ) ==@expr1073746238 0 ) {
514: platformStr@var1636 =@expr1073746239 e@var1632 .@expr4398 GetText (@expr4399 ) ;
515: if (@expr1073746242 platformStr@var1636 ==@expr1073746243 "Win32" ) {
516: platform@var1635 =@expr1073746244 Win32 ; }
517: else { if (@expr1073746245 platformStr@var1636 ==@expr1073746246 "x64" ) {
518: platform@var1635 =@expr1073746247 x64 ; }
519: else {
520: platform@var1635 =@expr1073746248 Unknown ; } }
521: } }
522: }
523: }
524: std :: string name@var1633 ;
525: std :: string configuration@var1634 ;
526: enum Anonymous4 { Win32 , x64 , Unknown } ; enum Anonymous4 platform@var1635 ;
527: std :: string platformStr@var1636 ;
528: } ;
529:
530: struct ItemDefinitionGroup {
531: explicit ItemDefinitionGroup ( const tinyxml2 :: XMLElement * idg@var1637 , const std :: string & includePaths@var1638 ) : additionalIncludePaths@var1657 ( includePaths@var1638 ) {
532: const char * condAttr@var1639 ; condAttr@var1639 =@expr1073746249 idg@var1637 .@expr1073746250 Attribute (@expr1073746251 "Condition" ) ;
533: if (@expr1073746252 condAttr@var1639 ) {
534: condition@var1654 =@expr1073746253 condAttr@var1639 ; }
535: for (@expr1073746254 const tinyxml2 ::@expr4431 XMLElement *@expr4432 e1@var1640 =@expr1073746257 idg@var1637 .@expr1073746258 FirstChildElement (@expr1073746259 ) ; e1@var1640 ; e1@var1640 =@expr1073746260 e1@var1640 .@expr1073746261 NextSiblingElement (@expr1073746262 ) ) {
536: if (@expr1073746263 std ::@expr4440 strcmp (@expr1073746265 e1@var1640 .@expr1073746266 Name (@expr1073746267 ) , "ClCompile" ) !=@expr1073746268 0 ) {
537: continue ; }
538: enhancedInstructionSet@var1655 =@expr1073746269 "StreamingSIMDExtensions2" ;
539: for (@expr1073746270 const tinyxml2 ::@expr4431 XMLElement *@expr4432 e@var1641 =@expr1073746273 e1@var1640 .@expr1073746274 FirstChildElement (@expr1073746275 ) ; e@var1641 ; e@var1641 =@expr1073746276 e@var1641 .@expr1073746277 NextSiblingElement (@expr1073746278 ) ) {
540: if (@expr1073746279 e@var1641 .@expr4456 GetText (@expr4457 ) ) {
541: if (@expr1073746282 std ::@expr4440 strcmp (@expr1073746284 e@var1641 .@expr4461 Name (@expr4462 ) , "PreprocessorDefinitions" ) ==@expr1073746287 0 ) {
542: preprocessorDefinitions@var1656 =@expr1073746288 e@var1641 .@expr4456 GetText (@expr4457 ) ; }
543: else { if (@expr1073746291 std ::@expr4440 strcmp (@expr1073746293 e@var1641 .@expr4461 Name (@expr4462 ) , "AdditionalIncludeDirectories" ) ==@expr1073746296 0 ) {
544: if (@expr1073746297 !@expr1073746298 additionalIncludePaths@var1657 .@expr1073746299 empty (@expr1073746300 ) ) {
545: additionalIncludePaths@var1657 +=@expr1073746301 ';' ; }
546: additionalIncludePaths@var1657 +=@expr1073746302 e@var1641 .@expr4456 GetText (@expr4457 ) ;
547: } else { if (@expr1073746305 std ::@expr4440 strcmp (@expr1073746307 e@var1641 .@expr4461 Name (@expr4462 ) , "LanguageStandard" ) ==@expr1073746310 0 ) {
548: if (@expr1073746311 std ::@expr4440 strcmp (@expr1073746313 e@var1641 .@expr4456 GetText (@expr4457 ) , "stdcpp14" ) ==@expr1073746316 0 ) {
549: cppstd@var1658 =@expr1073746317 Standards ::@expr1073746318 CPP14 ; }
550: else { if (@expr1073746319 std ::@expr4440 strcmp (@expr1073746321 e@var1641 .@expr4456 GetText (@expr4457 ) , "stdcpp17" ) ==@expr1073746324 0 ) {
551: cppstd@var1658 =@expr1073746325 Standards ::@expr1073746326 CPP17 ; }
552: else { if (@expr1073746327 std ::@expr4440 strcmp (@expr1073746329 e@var1641 .@expr4456 GetText (@expr4457 ) , "stdcpp20" ) ==@expr1073746332 0 ) {
553: cppstd@var1658 =@expr1073746333 Standards ::@expr1073746334 CPP20 ; }
554: else { if (@expr1073746335 std ::@expr4440 strcmp (@expr1073746337 e@var1641 .@expr4456 GetText (@expr4457 ) , "stdcpplatest" ) ==@expr1073746340 0 ) {
555: cppstd@var1658 =@expr1073746341 Standards ::@expr1073746342 CPPLatest ; } } } }
556: } else { if (@expr1073746343 std ::@expr4440 strcmp (@expr1073746345 e@var1641 .@expr4461 Name (@expr4462 ) , "EnableEnhancedInstructionSet" ) ==@expr1073746348 0 ) {
557: enhancedInstructionSet@var1655 =@expr1073746349 e@var1641 .@expr4456 GetText (@expr4457 ) ;
558: } } } }
559: }
560: }
561: }
562: }
563:
564: static void replaceAll ( std :: string & c@var1642 , const std :: string & from@var1643 , const std :: string & to@var1644 ) {
565: std ::@expr4529 string ::@expr1073746354 size_type pos@var1645 ;
566: while (@expr1073746355 (@expr1073746356 pos@var1645 =@expr1073746357 c@var1642 .@expr1073746358 find (@expr1073746359 from@var1643 ) ) !=@expr1073746360 std ::@expr4529 string ::@expr1073746362 npos@expr1073746352 ) {
567: c@var1642 .@expr1073746363 erase (@expr1073746364 pos@var1645 , from@var1643 .@expr1073746365 size (@expr1073746366 ) ) ;
568: c@var1642 .@expr1073746367 insert (@expr1073746368 pos@var1645 , to@var1644 ) ;
569: }
570: }
571:
572: bool conditionIsTrue ( const ProjectConfiguration & p@var1646 ) const {
573: if (@expr1073746369 condition@var1654 .@expr1073746370 empty (@expr1073746371 ) ) {
574: return true ; }
575: std ::@expr1073746372 string c@var1647 ; c@var1647 =@expr1073746373 '(' +@expr1073746374 condition@var1654 +@expr1073746375 ");" ;
576: replaceAll (@expr1073746376 c@var1647 , "$(Configuration)" , p@var1646 .@expr4553 configuration@var1648 ) ;
577: replaceAll (@expr1073746378 c@var1647 , "$(Platform)" , p@var1646 .@expr1073746379 platformStr@var1649 ) ;
578:
579:
580: Settings s@var1650 ;
581: std ::@expr1073746380 istringstream istr@var1651 (@expr1073746381 c@var1647 ) ;
582: Tokenizer tokenizer@var1652 (@expr1073746382 &@expr1073746383 s@var1650 , nullptr ) ;
583: tokenizer@var1652 .@expr1073746384 tokenize (@expr1073746385 istr@var1651 , "vcxproj" ) ;
584: for (@expr1073746386 const Token *@expr1073746387 tok@var1653 =@expr1073746388 tokenizer@var1652 .@expr1073746389 tokens (@expr1073746390 ) ; tok@var1653 ; tok@var1653 =@expr1073746391 tok@var1653 .@expr1073746392 next (@expr1073746393 ) ) {
585: if (@expr1073746394 tok@var1653 .@expr4571 str (@expr4572 ) ==@expr1073746397 "(" &&@expr1073746398 tok@var1653 .@expr4575 astOperand1 (@expr4576 ) &&@expr1073746401 tok@var1653 .@expr4578 astOperand2 (@expr4579 ) ) {
586: if (@expr1073746404 tok@var1653 .@expr4575 astOperand1 (@expr4576 ) .@expr1073746407 expressionString (@expr1073746408 ) ==@expr1073746409 "Configuration.Contains" ) {
587: return (@expr1073746410 '\'' +@expr1073746411 p@var1646 .@expr4553 configuration@var1648 +@expr1073746413 '\'' ) ==@expr1073746414 tok@var1653 .@expr4578 astOperand2 (@expr4579 ) .@expr4593 str (@expr4594 ) ; }
588: }
589: if (@expr1073746419 tok@var1653 .@expr4571 str (@expr4572 ) ==@expr1073746422 "==" &&@expr1073746423 tok@var1653 .@expr4575 astOperand1 (@expr4576 ) &&@expr1073746426 tok@var1653 .@expr4578 astOperand2 (@expr4579 ) &&@expr1073746429 tok@var1653 .@expr4575 astOperand1 (@expr4576 ) .@expr1073746432 str (@expr1073746433 ) ==@expr1073746434 tok@var1653 .@expr4578 astOperand2 (@expr4579 ) .@expr4593 str (@expr4594 ) ) {
590: return true ; }
591: }
592: return false ;
593: }
594: std :: string condition@var1654 ;
595: std :: string enhancedInstructionSet@var1655 ;
596: std :: string preprocessorDefinitions@var1656 ;
597: std :: string additionalIncludePaths@var1657 ;
598: Standards :: cppstd_t cppstd@var1658 ; cppstd@var1658 = Standards :: CPPLatest ;
599: } ;
600: }
601:
602: static std :: list < std :: string > toStringList ( const std :: string & s@var1659 )
603: {
604: std ::@expr1073746440 list < std ::@expr1073746441 string > ret@var1660 ;
605: std ::@expr4618 string ::@expr1073746443 size_type pos1@var1661 ; pos1@var1661 =@expr1073746444 0 ;
606: std ::@expr4618 string ::@expr1073746446 size_type pos2@var1662 ;
607: while (@expr1073746447 (@expr1073746448 pos2@var1662 =@expr1073746449 s@var1659 .@expr1073746450 find (@expr1073746451 ';' , pos1@var1661 ) ) !=@expr1073746452 std ::@expr4618 string ::@expr1073746454 npos@expr1073746439 ) {
608: ret@var1660 .@expr4631 push_back (@expr1073746456 s@var1659 .@expr4633 substr (@expr1073746458 pos1@var1661 , pos2@var1662 -@expr1073746459 pos1@var1661 ) ) ;
609: pos1@var1661 =@expr1073746460 pos2@var1662 +@expr1073746461 1 ;
610: if (@expr1073746462 pos1@var1661 >=@expr1073746463 s@var1659 .@expr4640 size (@expr4641 ) ) {
611: break ; }
612: }
613: if (@expr1073746466 pos1@var1661 <@expr1073746467 s@var1659 .@expr4640 size (@expr4641 ) ) {
614: ret@var1660 .@expr4631 push_back (@expr1073746471 s@var1659 .@expr4633 substr (@expr1073746473 pos1@var1661 ) ) ; }
615: return ret@var1660 ;
616: }
617:
618: static void importPropertyGroup ( const tinyxml2 :: XMLElement * node@var1663 , std :: map < std :: string , std :: string , cppcheck :: stricmp > * variables@var1664 , std :: string * includePath@var1665 , bool * useOfMfc@var1666 )
619: {
620: if (@expr1073746475 useOfMfc@var1666 ) {
621: for (@expr1073746476 const tinyxml2 ::@expr4653 XMLElement *@expr4654 e@var1667 =@expr1073746479 node@var1663 .@expr4656 FirstChildElement (@expr4657 ) ; e@var1667 ; e@var1667 =@expr1073746482 e@var1667 .@expr1073746483 NextSiblingElement (@expr1073746484 ) ) {
622: if (@expr1073746485 std ::@expr4662 strcmp (@expr1073746487 e@var1667 .@expr1073746488 Name (@expr1073746489 ) , "UseOfMfc" ) ==@expr1073746490 0 ) {
623: *@expr1073746491 useOfMfc@var1666 =@expr1073746492 true ;
624: break ;
625: }
626: }
627: }
628:
629: const char * labelAttribute@var1668 ; labelAttribute@var1668 =@expr1073746493 node@var1663 .@expr1073746494 Attribute (@expr1073746495 "Label" ) ;
630: if (@expr1073746496 labelAttribute@var1668 &&@expr1073746497 std ::@expr4662 strcmp (@expr1073746499 labelAttribute@var1668 , "UserMacros" ) ==@expr1073746500 0 ) {
631: for (@expr1073746501 const tinyxml2 ::@expr4653 XMLElement *@expr4654 propertyGroup@var1669 =@expr1073746504 node@var1663 .@expr4656 FirstChildElement (@expr4657 ) ; propertyGroup@var1669 ; propertyGroup@var1669 =@expr1073746507 propertyGroup@var1669 .@expr1073746508 NextSiblingElement (@expr1073746509 ) ) {
632: const std ::@expr1073746510 string name@var1670 (@expr1073746511 propertyGroup@var1669 .@expr1073746512 Name (@expr1073746513 ) ) ;
633: const char * text@var1671 ; text@var1671 =@expr1073746514 propertyGroup@var1669 .@expr1073746515 GetText (@expr1073746516 ) ;
634: (@expr1073746517 *@expr1073746518 variables@var1664 ) [@expr1073746519 name@var1670 ] =@expr1073746520 std ::@expr4697 string (@expr1073746522 text@var1671 ?@expr1073746523 text@var1671 :@expr1073746524 "" ) ;
635: }
636:
637: } else { if (@expr1073746525 !@expr1073746526 labelAttribute@var1668 ) {
638: for (@expr1073746527 const tinyxml2 ::@expr4653 XMLElement *@expr4654 propertyGroup@var1672 =@expr1073746530 node@var1663 .@expr4656 FirstChildElement (@expr4657 ) ; propertyGroup@var1672 ; propertyGroup@var1672 =@expr1073746533 propertyGroup@var1672 .@expr1073746534 NextSiblingElement (@expr1073746535 ) ) {
639: if (@expr1073746536 std ::@expr4662 strcmp (@expr1073746538 propertyGroup@var1672 .@expr1073746539 Name (@expr1073746540 ) , "IncludePath" ) !=@expr1073746541 0 ) {
640: continue ; }
641: const char * text@var1673 ; text@var1673 =@expr1073746542 propertyGroup@var1672 .@expr1073746543 GetText (@expr1073746544 ) ;
642: if (@expr1073746545 !@expr1073746546 text@var1673 ) {
643: continue ; }
644: std ::@expr1073746547 string path@var1674 (@expr1073746548 text@var1673 ) ;
645: const std ::@expr4653 string ::@expr4653 size_type pos@var1675 =@expr1073746551 path@var1674 .@expr1073746552 find (@expr1073746553 "$(IncludePath)" ) ;
646: if (@expr1073746554 pos@var1675 !=@expr1073746555 std ::@expr4697 string ::@expr1073746557 npos@expr1073746474 ) {
647: path@var1674 =@expr1073746558 path@var1674 .@expr4735 substr (@expr1073746560 0 , pos@var1675 ) +@expr1073746561 *@expr4738 includePath@var1665 +@expr1073746563 path@var1674 .@expr4735 substr (@expr1073746565 pos@var1675 +@expr1073746566 14U ) ; }
648: *@expr4738 includePath@var1665 =@expr1073746568 path@var1674 ;
649: }
650: } }
651: }
652:
653: static void loadVisualStudioProperties ( const std :: string & props@var1676 , std :: map < std :: string , std :: string , cppcheck :: stricmp > * variables@var1677 , std :: string * includePath@var1678 , const std :: string & additionalIncludeDirectories@var1679 , std :: list < ItemDefinitionGroup > & itemDefinitionGroupList@var1680 )
654: {
655: std ::@expr1073746572 string filename@var1681 (@expr1073746573 props@var1676 ) ;
656:
657: if (@expr1073746574 !@expr1073746575 simplifyPathWithVariables (@expr1073746576 filename@var1681 , *@expr1073746577 variables@var1677 ) ) {
658: return ; }
659:
660:
661: if (@expr1073746578 !@expr1073746579 Path ::@expr1073746580 isAbsolute (@expr1073746581 filename@var1681 ) &&@expr1073746582 variables@var1677 .@expr1073746583 count (@expr1073746584 "ProjectDir" ) >@expr1073746585 0 ) {
662: filename@var1681 =@expr1073746586 Path ::@expr1073746587 getAbsoluteFilePath (@expr1073746588 variables@var1677 .@expr1073746589 at (@expr1073746590 "ProjectDir" ) +@expr1073746591 filename@var1681 ) ; }
663:
664: tinyxml2 ::@expr1073746592 XMLDocument doc@var1682 ;
665: if (@expr1073746593 doc@var1682 .@expr1073746594 LoadFile (@expr1073746595 filename@var1681 .@expr1073746596 c_str (@expr1073746597 ) ) !=@expr1073746598 tinyxml2 ::@expr1073746599 XML_SUCCESS@expr1073746569 ) {
666: return ; }
667: const tinyxml2 ::@expr1073746600 XMLElement@expr1073746570 * const rootnode@var1683 ; rootnode@var1683 =@expr1073746601 doc@var1682 .@expr1073746602 FirstChildElement (@expr1073746603 ) ;
668: if (@expr1073746604 rootnode@var1683 ==@expr1073746605 nullptr ) {
669: return ; }
670: for (@expr1073746606 const tinyxml2 ::@expr4783 XMLElement *@expr4784 node@var1684 =@expr1073746609 rootnode@var1683 .@expr1073746610 FirstChildElement (@expr1073746611 ) ; node@var1684 ; node@var1684 =@expr1073746612 node@var1684 .@expr1073746613 NextSiblingElement (@expr1073746614 ) ) {
671: if (@expr1073746615 std ::@expr4792 strcmp (@expr1073746617 node@var1684 .@expr4794 Name (@expr4795 ) , "ImportGroup" ) ==@expr1073746620 0 ) {
672: const char * labelAttribute@var1685 ; labelAttribute@var1685 =@expr1073746621 node@var1684 .@expr1073746622 Attribute (@expr1073746623 "Label" ) ;
673: if (@expr1073746624 labelAttribute@var1685 ==@expr1073746625 nullptr ||@expr1073746626 std ::@expr4792 strcmp (@expr1073746628 labelAttribute@var1685 , "PropertySheets" ) !=@expr1073746629 0 ) {
674: continue ; }
675: for (@expr1073746630 const tinyxml2 ::@expr4783 XMLElement *@expr4784 importGroup@var1686 =@expr1073746633 node@var1684 .@expr1073746634 FirstChildElement (@expr1073746635 ) ; importGroup@var1686 ; importGroup@var1686 =@expr1073746636 importGroup@var1686 .@expr1073746637 NextSiblingElement (@expr1073746638 ) ) {
676: if (@expr1073746639 std ::@expr4792 strcmp (@expr1073746641 importGroup@var1686 .@expr1073746642 Name (@expr1073746643 ) , "Import" ) ==@expr1073746644 0 ) {
677: const char * projectAttribute@var1687 ; projectAttribute@var1687 =@expr1073746645 importGroup@var1686 .@expr1073746646 Attribute (@expr1073746647 "Project" ) ;
678: if (@expr1073746648 projectAttribute@var1687 ==@expr1073746649 nullptr ) {
679: continue ; }
680: std ::@expr1073746650 string loadprj@var1688 (@expr1073746651 projectAttribute@var1687 ) ;
681: if (@expr1073746652 loadprj@var1688 .@expr1073746653 find (@expr1073746654 '$' ) ==@expr1073746655 std ::@expr1073746656 string ::@expr1073746657 npos@expr1073746571 ) {
682: loadprj@var1688 =@expr1073746658 Path ::@expr1073746659 getPathFromFilename (@expr1073746660 filename@var1681 ) +@expr1073746661 loadprj@var1688 ;
683: }
684: loadVisualStudioProperties (@expr1073746662 loadprj@var1688 , variables@var1677 , includePath@var1678 , additionalIncludeDirectories@var1679 , itemDefinitionGroupList@var1680 ) ;
685: }
686: }
687: } else { if (@expr1073746663 std ::@expr4792 strcmp (@expr1073746665 node@var1684 .@expr4794 Name (@expr4795 ) , "PropertyGroup" ) ==@expr1073746668 0 ) {
688: importPropertyGroup (@expr1073746669 node@var1684 , variables@var1677 , includePath@var1678 , nullptr ) ;
689: } else { if (@expr1073746670 std ::@expr4792 strcmp (@expr1073746672 node@var1684 .@expr4794 Name (@expr4795 ) , "ItemDefinitionGroup" ) ==@expr1073746675 0 ) {
690: itemDefinitionGroupList@var1680 .@expr1073746676 emplace_back (@expr1073746677 node@var1684 , additionalIncludeDirectories@var1679 ) ;
691: } } }
692: }
693: }
694:
695: bool ImportProject :: importVcxproj ( const std :: string & filename@var1689 , std :: map < std :: string , std :: string , cppcheck :: stricmp > & variables@var1690 , const std :: string & additionalIncludeDirectories@var1691 , const std :: vector < std :: string > & fileFilters@var1692 )
696: {
697: variables@var1690 [@expr1073746680 "ProjectDir" ] =@expr1073746681 Path ::@expr4858 simplifyPath (@expr1073746683 Path ::@expr4860 getPathFromFilename (@expr4861 filename@var1689 ) ) ;
698:
699: std ::@expr1073746686 list < ProjectConfiguration > projectConfigurationList@var1693 ;
700: std ::@expr1073746687 list < std ::@expr4864 string > compileList@var1694 ;
701: std ::@expr1073746689 list < ItemDefinitionGroup > itemDefinitionGroupList@var1695 ;
702: std ::@expr1073746690 string includePath@var1696 ;
703:
704: bool useOfMfc@var1697 ; useOfMfc@var1697 =@expr1073746691 false ;
705:
706: tinyxml2 ::@expr1073746692 XMLDocument doc@var1698 ;
707: const tinyxml2 ::@expr4864 XMLError error@var1699 =@expr1073746694 doc@var1698 .@expr1073746695 LoadFile (@expr1073746696 filename@var1689 .@expr1073746697 c_str (@expr1073746698 ) ) ;
708: if (@expr1073746699 error@var1699 !=@expr1073746700 tinyxml2 ::@expr1073746701 XML_SUCCESS@expr1073746678 ) {
709: printError (@expr1073746702 std ::@expr1073746703 string (@expr1073746704 "Visual Studio project file is not a valid XML - " ) +@expr1073746705 tinyxml2 ::@expr1073746706 XMLDocument ::@expr1073746707 ErrorIDToName (@expr1073746708 error@var1699 ) ) ;
710: return false ;
711: }
712: const tinyxml2 ::@expr1073746709 XMLElement@expr1073746679 * const rootnode@var1700 ; rootnode@var1700 =@expr1073746710 doc@var1698 .@expr1073746711 FirstChildElement (@expr1073746712 ) ;
713: if (@expr1073746713 rootnode@var1700 ==@expr1073746714 nullptr ) {
714: printError (@expr1073746715 "Visual Studio project file has no XML root node" ) ;
715: return false ;
716: }
717: for (@expr1073746716 const tinyxml2 ::@expr4864 XMLElement *@expr4894 node@var1701 =@expr1073746719 rootnode@var1700 .@expr1073746720 FirstChildElement (@expr1073746721 ) ; node@var1701 ; node@var1701 =@expr1073746722 node@var1701 .@expr1073746723 NextSiblingElement (@expr1073746724 ) ) {
718: if (@expr1073746725 std ::@expr4902 strcmp (@expr1073746727 node@var1701 .@expr4904 Name (@expr4905 ) , "ItemGroup" ) ==@expr1073746730 0 ) {
719: const char * labelAttribute@var1702 ; labelAttribute@var1702 =@expr1073746731 node@var1701 .@expr4908 Attribute (@expr4909 "Label" ) ;
720: if (@expr1073746734 labelAttribute@var1702 &&@expr1073746735 std ::@expr4902 strcmp (@expr1073746737 labelAttribute@var1702 , "ProjectConfigurations" ) ==@expr1073746738 0 ) {
721: for (@expr1073746739 const tinyxml2 ::@expr4864 XMLElement *@expr4894 cfg@var1703 =@expr1073746742 node@var1701 .@expr4919 FirstChildElement (@expr4920 ) ; cfg@var1703 ; cfg@var1703 =@expr1073746745 cfg@var1703 .@expr1073746746 NextSiblingElement (@expr1073746747 ) ) {
722: if (@expr1073746748 std ::@expr4902 strcmp (@expr1073746750 cfg@var1703 .@expr1073746751 Name (@expr1073746752 ) , "ProjectConfiguration" ) ==@expr1073746753 0 ) {
723: const ProjectConfiguration p@var1704 (@expr1073746754 cfg@var1703 ) ;
724: if (@expr1073746755 p@var1704 .@expr1073746756 platform@var1705 !=@expr1073746757 ProjectConfiguration ::@expr1073746758 Unknown ) {
725: projectConfigurationList@var1693 .@expr1073746759 emplace_back (@expr1073746760 cfg@var1703 ) ;
726: mAllVSConfigs@var123 .@expr1073746761 insert (@expr1073746762 p@var1704 .@expr1073746763 configuration@var1706 ) ;
727: }
728: }
729: }
730: } else {
731: for (@expr1073746764 const tinyxml2 ::@expr4864 XMLElement *@expr4894 e@var1707 =@expr1073746767 node@var1701 .@expr4919 FirstChildElement (@expr4920 ) ; e@var1707 ; e@var1707 =@expr1073746770 e@var1707 .@expr1073746771 NextSiblingElement (@expr1073746772 ) ) {
732: if (@expr1073746773 std ::@expr4902 strcmp (@expr1073746775 e@var1707 .@expr1073746776 Name (@expr1073746777 ) , "ClCompile" ) ==@expr1073746778 0 ) {
733: const char * include@var1708 ; include@var1708 =@expr1073746779 e@var1707 .@expr1073746780 Attribute (@expr1073746781 "Include" ) ;
734: if (@expr1073746782 include@var1708 &&@expr1073746783 Path ::@expr1073746784 acceptFile (@expr1073746785 include@var1708 ) ) {
735: compileList@var1694 .@expr1073746786 emplace_back (@expr1073746787 include@var1708 ) ; }
736: }
737: }
738: }
739: } else { if (@expr1073746788 std ::@expr4902 strcmp (@expr1073746790 node@var1701 .@expr4904 Name (@expr4905 ) , "ItemDefinitionGroup" ) ==@expr1073746793 0 ) {
740: itemDefinitionGroupList@var1695 .@expr1073746794 emplace_back (@expr1073746795 node@var1701 , additionalIncludeDirectories@var1691 ) ;
741: } else { if (@expr1073746796 std ::@expr4902 strcmp (@expr1073746798 node@var1701 .@expr4904 Name (@expr4905 ) , "PropertyGroup" ) ==@expr1073746801 0 ) {
742: importPropertyGroup (@expr1073746802 node@var1701 , &@expr4979 variables@var1690 , &@expr4980 includePath@var1696 , &@expr1073746805 useOfMfc@var1697 ) ;
743: } else { if (@expr1073746806 std ::@expr4902 strcmp (@expr1073746808 node@var1701 .@expr4904 Name (@expr4905 ) , "ImportGroup" ) ==@expr1073746811 0 ) {
744: const char * labelAttribute@var1709 ; labelAttribute@var1709 =@expr1073746812 node@var1701 .@expr4908 Attribute (@expr4909 "Label" ) ;
745: if (@expr1073746815 labelAttribute@var1709 &&@expr1073746816 std ::@expr4902 strcmp (@expr1073746818 labelAttribute@var1709 , "PropertySheets" ) ==@expr1073746819 0 ) {
746: for (@expr1073746820 const tinyxml2 ::@expr4864 XMLElement *@expr4894 e@var1710 =@expr1073746823 node@var1701 .@expr4919 FirstChildElement (@expr4920 ) ; e@var1710 ; e@var1710 =@expr1073746826 e@var1710 .@expr1073746827 NextSiblingElement (@expr1073746828 ) ) {
747: if (@expr1073746829 std ::@expr4902 strcmp (@expr1073746831 e@var1710 .@expr1073746832 Name (@expr1073746833 ) , "Import" ) ==@expr1073746834 0 ) {
748: const char * projectAttribute@var1711 ; projectAttribute@var1711 =@expr1073746835 e@var1710 .@expr1073746836 Attribute (@expr1073746837 "Project" ) ;
749: if (@expr1073746838 projectAttribute@var1711 ) {
750: loadVisualStudioProperties (@expr1073746839 projectAttribute@var1711 , &@expr4979 variables@var1690 , &@expr4980 includePath@var1696 , additionalIncludeDirectories@var1691 , itemDefinitionGroupList@var1695 ) ; }
751: }
752: }
753: }
754: } } } }
755: }
756:
757: for (@expr1073746842 const std ::@expr4864 string &@expr5020 c@var1712 :@expr1073746845 compileList@var1694 ) {
758: const std ::@expr4864 string cfilename@var1713 =@expr1073746847 Path ::@expr4858 simplifyPath (@expr1073746849 Path ::@expr1073746850 isAbsolute (@expr1073746851 c@var1712 ) ?@expr1073746852 c@var1712 :@expr1073746853 Path ::@expr4860 getPathFromFilename (@expr4861 filename@var1689 ) +@expr1073746856 c@var1712 ) ;
759: if (@expr1073746857 !@expr1073746858 fileFilters@var1692 .@expr1073746859 empty (@expr1073746860 ) &&@expr1073746861 !@expr1073746862 matchglobs (@expr1073746863 fileFilters@var1692 , cfilename@var1713 ) ) {
760: continue ; }
761:
762: for (@expr1073746864 const ProjectConfiguration &@expr5020 p@var1714 :@expr1073746866 projectConfigurationList@var1693 ) {
763:
764: if (@expr1073746867 !@expr1073746868 guiProject@var103 .@expr5045 checkVsConfigs@var1894 .@expr1073746870 empty (@expr1073746871 ) ) {
765: bool doChecking@var1715 ; doChecking@var1715 =@expr1073746872 false ;
766: for (@expr1073746873 const std ::@expr4864 string &@expr5020 config@var1716 :@expr1073746876 guiProject@var103 .@expr5045 checkVsConfigs@var1894 ) {
767: if (@expr1073746878 config@var1716 ==@expr1073746879 p@var1714 .@expr1073746880 configuration@var1717 ) {
768: doChecking@var1715 =@expr1073746881 true ;
769: break ;
770: } }
771: if (@expr1073746882 !@expr1073746883 doChecking@var1715 ) {
772: continue ; }
773: }
774:
775: FileSettings fs@var1718 ;
776: fs@var1718 .@expr1073746884 filename@var1719 =@expr1073746885 cfilename@var1713 ;
777: fs@var1718 .@expr1073746886 cfg@var1720 =@expr1073746887 p@var1714 .@expr1073746888 name@var1721 ;
778: fs@var1718 .@expr1073746889 msc@var1722 =@expr1073746890 true ;
779: fs@var1718 .@expr1073746891 useMfc@var1723 =@expr1073746892 useOfMfc@var1697 ;
780: fs@var1718 .@expr5069 defines@var1724 =@expr1073746894 "_WIN32=1" ;
781: if (@expr1073746895 p@var1714 .@expr5072 platform@var1725 ==@expr1073746897 ProjectConfiguration ::@expr1073746898 Win32 ) {
782: fs@var1718 .@expr5075 platformType@var1726 =@expr1073746900 cppcheck ::@expr5077 Platform ::@expr1073746902 Win32W ; }
783: else { if (@expr1073746903 p@var1714 .@expr5072 platform@var1725 ==@expr1073746905 ProjectConfiguration ::@expr1073746906 x64 ) {
784: fs@var1718 .@expr5075 platformType@var1726 =@expr1073746908 cppcheck ::@expr5077 Platform ::@expr1073746910 Win64 ;
785: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746912 ";_WIN64=1" ;
786: } }
787: std ::@expr1073746913 string additionalIncludePaths@var1727 ;
788: for (@expr1073746914 const ItemDefinitionGroup &@expr5020 i@var1728 :@expr1073746916 itemDefinitionGroupList@var1695 ) {
789: if (@expr1073746917 !@expr1073746918 i@var1728 .@expr1073746919 conditionIsTrue (@expr1073746920 p@var1714 ) ) {
790: continue ; }
791: fs@var1718 .@expr1073746921 standard@var1729 =@expr1073746922 Standards ::@expr1073746923 getCPP (@expr1073746924 i@var1728 .@expr1073746925 cppstd@var1730 ) ;
792: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746927 ';' +@expr1073746928 i@var1728 .@expr1073746929 preprocessorDefinitions@var1731 ;
793: if (@expr1073746930 i@var1728 .@expr5107 enhancedInstructionSet@var1732 ==@expr1073746932 "StreamingSIMDExtensions" ) {
794: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746934 ";__SSE__" ; }
795: else { if (@expr1073746935 i@var1728 .@expr5107 enhancedInstructionSet@var1732 ==@expr1073746937 "StreamingSIMDExtensions2" ) {
796: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746939 ";__SSE2__" ; }
797: else { if (@expr1073746940 i@var1728 .@expr5107 enhancedInstructionSet@var1732 ==@expr1073746942 "AdvancedVectorExtensions" ) {
798: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746944 ";__AVX__" ; }
799: else { if (@expr1073746945 i@var1728 .@expr5107 enhancedInstructionSet@var1732 ==@expr1073746947 "AdvancedVectorExtensions2" ) {
800: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746949 ";__AVX2__" ; }
801: else { if (@expr1073746950 i@var1728 .@expr5107 enhancedInstructionSet@var1732 ==@expr1073746952 "AdvancedVectorExtensions512" ) {
802: fs@var1718 .@expr5069 defines@var1724 +=@expr1073746954 ";__AVX512__" ; } } } } }
803: additionalIncludePaths@var1727 +=@expr1073746955 ';' +@expr1073746956 i@var1728 .@expr1073746957 additionalIncludePaths@var1733 ;
804: }
805: fs@var1718 .@expr1073746958 setDefines (@expr1073746959 fs@var1718 .@expr5069 defines@var1724 ) ;
806: fs@var1718 .@expr1073746961 setIncludePaths (@expr1073746962 Path ::@expr4860 getPathFromFilename (@expr4861 filename@var1689 ) , toStringList (@expr1073746965 includePath@var1696 +@expr1073746966 ';' +@expr1073746967 additionalIncludePaths@var1727 ) , variables@var1690 ) ;
807: fileSettings@var93 .@expr1073746968 push_back (@expr1073746969 fs@var1718 ) ;
808: }
809: }
810:
811: return true ;
812: }
813:
814: bool ImportProject :: importBcb6Prj ( const std :: string & projectFilename@var1734 )
815: {
816: tinyxml2 ::@expr1073746972 XMLDocument doc@var1735 ;
817: const tinyxml2 ::@expr5149 XMLError error@var1736 =@expr1073746974 doc@var1735 .@expr1073746975 LoadFile (@expr1073746976 projectFilename@var1734 .@expr1073746977 c_str (@expr1073746978 ) ) ;
818: if (@expr1073746979 error@var1736 !=@expr1073746980 tinyxml2 ::@expr1073746981 XML_SUCCESS@expr1073746970 ) {
819: printError (@expr1073746982 std ::@expr1073746983 string (@expr1073746984 "Borland project file is not a valid XML - " ) +@expr1073746985 tinyxml2 ::@expr1073746986 XMLDocument ::@expr1073746987 ErrorIDToName (@expr1073746988 error@var1736 ) ) ;
820: return false ;
821: }
822: const tinyxml2 ::@expr1073746989 XMLElement@expr1073746971 * const rootnode@var1737 ; rootnode@var1737 =@expr1073746990 doc@var1735 .@expr1073746991 FirstChildElement (@expr1073746992 ) ;
823: if (@expr1073746993 rootnode@var1737 ==@expr1073746994 nullptr ) {
824: printError (@expr1073746995 "Borland project file has no XML root node" ) ;
825: return false ;
826: }
827:
828: const std ::@expr5149 string &@expr5173 projectDir@var1738 =@expr1073746998 Path ::@expr5175 simplifyPath (@expr1073747000 Path ::@expr1073747001 getPathFromFilename (@expr1073747002 projectFilename@var1734 ) ) ;
829:
830: std ::@expr1073747003 list < std ::@expr5149 string > compileList@var1739 ;
831: std ::@expr1073747005 string includePath@var1740 ;
832: std ::@expr1073747006 string userdefines@var1741 ;
833: std ::@expr1073747007 string sysdefines@var1742 ;
834: std ::@expr1073747008 string cflag1@var1743 ;
835:
836: for (@expr1073747009 const tinyxml2 ::@expr5149 XMLElement *@expr5187 node@var1744 =@expr1073747012 rootnode@var1737 .@expr1073747013 FirstChildElement (@expr1073747014 ) ; node@var1744 ; node@var1744 =@expr1073747015 node@var1744 .@expr1073747016 NextSiblingElement (@expr1073747017 ) ) {
837: if (@expr1073747018 std ::@expr5195 strcmp (@expr1073747020 node@var1744 .@expr5197 Name (@expr5198 ) , "FILELIST" ) ==@expr1073747023 0 ) {
838: for (@expr1073747024 const tinyxml2 ::@expr5149 XMLElement *@expr5187 f@var1745 =@expr1073747027 node@var1744 .@expr5204 FirstChildElement (@expr5205 ) ; f@var1745 ; f@var1745 =@expr1073747030 f@var1745 .@expr1073747031 NextSiblingElement (@expr1073747032 ) ) {
839: if (@expr1073747033 std ::@expr5195 strcmp (@expr1073747035 f@var1745 .@expr1073747036 Name (@expr1073747037 ) , "FILE" ) ==@expr1073747038 0 ) {
840: const char * filename@var1746 ; filename@var1746 =@expr1073747039 f@var1745 .@expr1073747040 Attribute (@expr1073747041 "FILENAME" ) ;
841: if (@expr1073747042 filename@var1746 &&@expr1073747043 Path ::@expr1073747044 acceptFile (@expr1073747045 filename@var1746 ) ) {
842: compileList@var1739 .@expr1073747046 emplace_back (@expr1073747047 filename@var1746 ) ; }
843: }
844: }
845: } else { if (@expr1073747048 std ::@expr5195 strcmp (@expr1073747050 node@var1744 .@expr5197 Name (@expr5198 ) , "MACROS" ) ==@expr1073747053 0 ) {
846: for (@expr1073747054 const tinyxml2 ::@expr5149 XMLElement *@expr5187 m@var1747 =@expr1073747057 node@var1744 .@expr5204 FirstChildElement (@expr5205 ) ; m@var1747 ; m@var1747 =@expr1073747060 m@var1747 .@expr1073747061 NextSiblingElement (@expr1073747062 ) ) {
847: if (@expr1073747063 std ::@expr5195 strcmp (@expr1073747065 m@var1747 .@expr5242 Name (@expr5243 ) , "INCLUDEPATH" ) ==@expr1073747068 0 ) {
848: const char * v@var1748 ; v@var1748 =@expr1073747069 m@var1747 .@expr5246 Attribute (@expr5247 "value" ) ;
849: if (@expr1073747072 v@var1748 ) {
850: includePath@var1740 =@expr1073747073 v@var1748 ; }
851: } else { if (@expr1073747074 std ::@expr5195 strcmp (@expr1073747076 m@var1747 .@expr5242 Name (@expr5243 ) , "USERDEFINES" ) ==@expr1073747079 0 ) {
852: const char * v@var1749 ; v@var1749 =@expr1073747080 m@var1747 .@expr5246 Attribute (@expr5247 "value" ) ;
853: if (@expr1073747083 v@var1749 ) {
854: userdefines@var1741 =@expr1073747084 v@var1749 ; }
855: } else { if (@expr1073747085 std ::@expr5195 strcmp (@expr1073747087 m@var1747 .@expr5242 Name (@expr5243 ) , "SYSDEFINES" ) ==@expr1073747090 0 ) {
856: const char * v@var1750 ; v@var1750 =@expr1073747091 m@var1747 .@expr5246 Attribute (@expr5247 "value" ) ;
857: if (@expr1073747094 v@var1750 ) {
858: sysdefines@var1742 =@expr1073747095 v@var1750 ; }
859: } } }
860: }
861: } else { if (@expr1073747096 std ::@expr5195 strcmp (@expr1073747098 node@var1744 .@expr5197 Name (@expr5198 ) , "OPTIONS" ) ==@expr1073747101 0 ) {
862: for (@expr1073747102 const tinyxml2 ::@expr5149 XMLElement *@expr5187 m@var1751 =@expr1073747105 node@var1744 .@expr5204 FirstChildElement (@expr5205 ) ; m@var1751 ; m@var1751 =@expr1073747108 m@var1751 .@expr1073747109 NextSiblingElement (@expr1073747110 ) ) {
863: if (@expr1073747111 std ::@expr5195 strcmp (@expr1073747113 m@var1751 .@expr1073747114 Name (@expr1073747115 ) , "CFLAG1" ) ==@expr1073747116 0 ) {
864: const char * v@var1752 ; v@var1752 =@expr1073747117 m@var1751 .@expr1073747118 Attribute (@expr1073747119 "value" ) ;
865: if (@expr1073747120 v@var1752 ) {
866: cflag1@var1743 =@expr1073747121 v@var1752 ; }
867: }
868: }
869: } } }
870: }
871:
872: std ::@expr1073747122 set < std ::@expr5149 string > cflags@var1753 ;
873:
874:
875: {
876: std ::@expr1073747124 string arg@var1754 ;
877:
878: for (@expr1073747125 char i@var1755 :@expr1073747126 cflag1@var1743 ) {
879: if (@expr1073747127 i@var1755 ==@expr1073747128 ' ' &&@expr1073747129 !@expr5306 arg@var1754 .@expr5307 empty (@expr5308 ) ) {
880: cflags@var1753 .@expr5309 insert (@expr5310 arg@var1754 ) ;
881: arg@var1754 .@expr1073747135 clear (@expr1073747136 ) ;
882: continue ;
883: }
884: arg@var1754 +=@expr1073747137 i@var1755 ;
885: }
886:
887: if (@expr1073747138 !@expr5306 arg@var1754 .@expr5307 empty (@expr5308 ) ) {
888: cflags@var1753 .@expr5309 insert (@expr5310 arg@var1754 ) ;
889: }
890:
|
893:
894: static const std ::@expr1073747144 map < std ::@expr5149 string , std ::@expr5149 string > synonyms@var1756 =@expr1073747147 {@expr1073747148
895: {@expr1073747149 "-tC" , "-WC" } ,
896: {@expr1073747150 "-tCDR" , "-WCDR" } ,
897: {@expr1073747151 "-tCDV" , "-WCDV" } ,
898: {@expr1073747152 "-tW" , "-W" } ,
899: {@expr1073747153 "-tWC" , "-WC" } ,
900: {@expr1073747154 "-tWCDR" , "-WCDR" } ,
901: {@expr1073747155 "-tWCDV" , "-WCDV" } ,
902: {@expr1073747156 "-tWD" , "-WD" } ,
903: {@expr1073747157 "-tWDR" , "-WDR" } ,
904: {@expr1073747158 "-tWDV" , "-WDV" } ,
905: {@expr1073747159 "-tWM" , "-WM" } ,
906: {@expr1073747160 "-tWP" , "-WP" } ,
907: {@expr1073747161 "-tWR" , "-WR" } ,
908: {@expr1073747162 "-tWU" , "-WU" } ,
909: {@expr1073747163 "-tWV" , "-WV" }
910: } ;
911:
912: for (@expr1073747164 std ::@expr5149 map < std ::@expr5149 string , std ::@expr5149 string > ::@expr5149 const_iterator i@var1757 =@expr1073747169 synonyms@var1756 .@expr1073747170 begin (@expr1073747171 ) ; i@var1757 !=@expr1073747172 synonyms@var1756 .@expr1073747173 end (@expr1073747174 ) ; ++@expr1073747175 i@var1757 ) {
913: if (@expr1073747176 cflags@var1753 .@expr1073747177 erase (@expr1073747178 i@var1757 .@expr1073747179 first@var1758 ) >@expr1073747180 0 ) {
914: cflags@var1753 .@expr5309 insert (@expr1073747182 i@var1757 .@expr1073747183 second@var1759 ) ;
915: }
916: }
917: }
918:
919: std ::@expr1073747184 string predefines@var1760 ;
920: std ::@expr1073747185 string cppPredefines@var1761 ;
921:
922:
923: {
924: cppPredefines@var1761 +=@expr1073747186
925:
926:
927:
928: ";__BCPLUSPLUS__=0x0560;__cplusplus=1;__TEMPLATES__=1;_WCHAR_T;_WCHAR_T_DEFINED;__BCOPT__=1;__BORLANDC__=0x0560;__TCPLUSPLUS__=0x0560;__TURBOC__=0x0560"
929:
|
949:
950: ;
951:
952:
953: const bool useCdecl@var1762 =@expr1073747187 cflags@var1753 .@expr5364 find (@expr5365 "-p" ) ==@expr1073747190 cflags@var1753 .@expr5367 end (@expr5368 )
954: &&@expr1073747193 cflags@var1753 .@expr5364 find (@expr1073747195 "-pm" ) ==@expr1073747196 cflags@var1753 .@expr5367 end (@expr5368 )
955: &&@expr1073747199 cflags@var1753 .@expr5364 find (@expr1073747201 "-pr" ) ==@expr1073747202 cflags@var1753 .@expr5367 end (@expr5368 )
956: &&@expr1073747205 cflags@var1753 .@expr5364 find (@expr1073747207 "-ps" ) ==@expr1073747208 cflags@var1753 .@expr5367 end (@expr5368 ) ;
957: if (@expr1073747211 useCdecl@var1762 ) {
958: predefines@var1760 +=@expr1073747212 ";__CDECL=1" ; }
959:
960:
961: const bool treatCharAsUnsignedChar@var1763 =@expr1073747213 cflags@var1753 .@expr5364 find (@expr1073747215 "-K" ) !=@expr1073747216 cflags@var1753 .@expr5367 end (@expr5368 ) ;
962: if (@expr1073747219 treatCharAsUnsignedChar@var1763 ) {
963: predefines@var1760 +=@expr1073747220 ";_CHAR_UNSIGNED=1" ; }
964:
965:
966: const bool codeguardUsed@var1764 =@expr1073747221 cflags@var1753 .@expr5364 find (@expr1073747223 "-vGd" ) !=@expr1073747224 cflags@var1753 .@expr5367 end (@expr5368 )
967: ||@expr1073747227 cflags@var1753 .@expr5364 find (@expr1073747229 "-vGt" ) !=@expr1073747230 cflags@var1753 .@expr5367 end (@expr5368 )
968: ||@expr1073747233 cflags@var1753 .@expr5364 find (@expr1073747235 "-vGc" ) !=@expr1073747236 cflags@var1753 .@expr5367 end (@expr5368 ) ;
969: if (@expr1073747239 codeguardUsed@var1764 ) {
970: predefines@var1760 +=@expr1073747240 ";__CODEGUARD__" ; }
971:
972:
973: const bool isConsoleApp@var1765 =@expr1073747241 cflags@var1753 .@expr5364 find (@expr5419 "-WC" ) !=@expr5420 cflags@var1753 .@expr5367 end (@expr5368 ) ;
974: if (@expr1073747247 isConsoleApp@var1765 ) {
975: predefines@var1760 +=@expr1073747248 ";__CONSOLE__=1" ; }
976:
977:
978: const bool enableStackUnwinding@var1766 =@expr1073747249 cflags@var1753 .@expr5364 find (@expr1073747251 "-xd-" ) ==@expr1073747252 cflags@var1753 .@expr5367 end (@expr5368 ) ;
979: if (@expr1073747255 enableStackUnwinding@var1766 ) {
980: predefines@var1760 +=@expr1073747256 ";_CPPUNWIND=1" ; }
981:
982:
983: const bool isDLL@var1767 =@expr1073747257 cflags@var1753 .@expr5364 find (@expr5435 "-WD" ) !=@expr5436 cflags@var1753 .@expr5367 end (@expr5368 ) ;
984: if (@expr1073747263 isDLL@var1767 ) {
985: predefines@var1760 +=@expr1073747264 ";__DLL__=1" ; }
986:
987:
988:
989: predefines@var1760 +=@expr1073747265 ";__FLAT__=1" ;
990:
991:
992: if (@expr1073747266 cflags@var1753 .@expr5364 find (@expr1073747268 "-6" ) !=@expr1073747269 cflags@var1753 .@expr5367 end (@expr5368 ) ) {
993: predefines@var1760 +=@expr1073747272 ";_M_IX86=600" ; }
994: else { if (@expr1073747273 cflags@var1753 .@expr5364 find (@expr1073747275 "-5" ) !=@expr1073747276 cflags@var1753 .@expr5367 end (@expr5368 ) ) {
995: predefines@var1760 +=@expr1073747279 ";_M_IX86=500" ; }
996: else { if (@expr1073747280 cflags@var1753 .@expr5364 find (@expr1073747282 "-4" ) !=@expr1073747283 cflags@var1753 .@expr5367 end (@expr5368 ) ) {
997: predefines@var1760 +=@expr1073747286 ";_M_IX86=400" ; }
998: else {
999: predefines@var1760 +=@expr1073747287 ";_M_IX86=300" ; } } }
1000:
1001:
1002: const bool linkMtLib@var1768 =@expr1073747288 cflags@var1753 .@expr5364 find (@expr5466 "-WM" ) !=@expr5467 cflags@var1753 .@expr5367 end (@expr5368 ) ;
1003: if (@expr1073747294 linkMtLib@var1768 ) {
1004: predefines@var1760 +=@expr1073747295 ";__MT__=1" ; }
1005:
1006:
1007: const bool usePascalCallingConvention@var1769 =@expr1073747296 cflags@var1753 .@expr5364 find (@expr5365 "-p" ) !=@expr1073747299 cflags@var1753 .@expr5367 end (@expr5368 ) ;
1008: if (@expr1073747302 usePascalCallingConvention@var1769 ) {
1009: predefines@var1760 +=@expr1073747303 ";__PASCAL__=1" ; }
1010:
1011:
1012: const bool useAnsiKeywordExtensions@var1770 =@expr1073747304 cflags@var1753 .@expr5364 find (@expr1073747306 "-A" ) !=@expr1073747307 cflags@var1753 .@expr5367 end (@expr5368 ) ;
1013: if (@expr1073747310 useAnsiKeywordExtensions@var1770 ) {
1014: predefines@var1760 +=@expr1073747311 ";__STDC__=1" ; }
1015:
1016:
1017: predefines@var1760 +=@expr1073747312 ";__TLC__=1" ;
1018:
1019:
1020: const bool isWindowsTarget@var1771 =@expr1073747313 cflags@var1753 .@expr5364 find (@expr5419 "-WC" ) !=@expr5420 cflags@var1753 .@expr5367 end (@expr5368 )
1021: ||@expr1073747319 cflags@var1753 .@expr5364 find (@expr1073747321 "-WCDR" ) !=@expr1073747322 cflags@var1753 .@expr5367 end (@expr5368 )
1022: ||@expr1073747325 cflags@var1753 .@expr5364 find (@expr1073747327 "-WCDV" ) !=@expr1073747328 cflags@var1753 .@expr5367 end (@expr5368 )
1023: ||@expr1073747331 cflags@var1753 .@expr5364 find (@expr5435 "-WD" ) !=@expr5436 cflags@var1753 .@expr5367 end (@expr5368 )
1024: ||@expr1073747337 cflags@var1753 .@expr5364 find (@expr1073747339 "-WDR" ) !=@expr1073747340 cflags@var1753 .@expr5367 end (@expr5368 )
1025: ||@expr1073747343 cflags@var1753 .@expr5364 find (@expr1073747345 "-WDV" ) !=@expr1073747346 cflags@var1753 .@expr5367 end (@expr5368 )
1026: ||@expr1073747349 cflags@var1753 .@expr5364 find (@expr5466 "-WM" ) !=@expr5467 cflags@var1753 .@expr5367 end (@expr5368 )
1027: ||@expr1073747355 cflags@var1753 .@expr5364 find (@expr1073747357 "-WP" ) !=@expr1073747358 cflags@var1753 .@expr5367 end (@expr5368 )
1028: ||@expr1073747361 cflags@var1753 .@expr5364 find (@expr1073747363 "-WR" ) !=@expr1073747364 cflags@var1753 .@expr5367 end (@expr5368 )
1029: ||@expr1073747367 cflags@var1753 .@expr5364 find (@expr1073747369 "-WU" ) !=@expr1073747370 cflags@var1753 .@expr5367 end (@expr5368 )
1030: ||@expr1073747373 cflags@var1753 .@expr5364 find (@expr1073747375 "-WV" ) !=@expr1073747376 cflags@var1753 .@expr5367 end (@expr5368 ) ;
1031: if (@expr1073747379 isWindowsTarget@var1771 ) {
1032: predefines@var1760 +=@expr1073747380 ";_Windows" ; }
1033:
|
1040:
1041: const bool isConsoleOrGuiApp@var1772 =@expr1073747381 isWindowsTarget@var1771 ;
1042: if (@expr1073747382 isConsoleOrGuiApp@var1772 ) {
1043: predefines@var1760 +=@expr1073747383 ";__WIN32__=1" ; }
1044: }
1045:
|
1053:
1054: std ::@expr1073747384 map < std ::@expr5149 string , std ::@expr5149 string , cppcheck ::@expr5149 stricmp > variables@var1773 ;
1055: const std ::@expr5149 string defines@var1774 =@expr1073747389 predefines@var1760 +@expr1073747390 ";" +@expr1073747391 sysdefines@var1742 +@expr1073747392 ";" +@expr1073747393 userdefines@var1741 ;
1056: const std ::@expr5149 string cppDefines@var1775 =@expr1073747395 cppPredefines@var1761 +@expr1073747396 ";" +@expr1073747397 defines@var1774 ;
1057: const bool forceCppMode@var1776 =@expr1073747398 cflags@var1753 .@expr5364 find (@expr1073747400 "-P" ) !=@expr1073747401 cflags@var1753 .@expr5367 end (@expr5368 ) ;
1058:
1059: for (@expr1073747404 const std ::@expr5149 string &@expr5173 c@var1777 :@expr1073747407 compileList@var1739 ) {
1060:
|
1068:
1069: const bool cppMode@var1778 =@expr1073747408 forceCppMode@var1776 ||@expr1073747409 Path ::@expr1073747410 getFilenameExtensionInLowerCase (@expr1073747411 c@var1777 ) ==@expr1073747412 ".cpp" ;
1070: FileSettings fs@var1779 ;
1071: fs@var1779 .@expr1073747413 setIncludePaths (@expr1073747414 projectDir@var1738 , toStringList (@expr1073747415 includePath@var1740 ) , variables@var1773 ) ;
1072: fs@var1779 .@expr1073747416 setDefines (@expr1073747417 cppMode@var1778 ?@expr1073747418 cppDefines@var1775 :@expr1073747419 defines@var1774 ) ;
1073: fs@var1779 .@expr1073747420 filename@var1780 =@expr1073747421 Path ::@expr5175 simplifyPath (@expr1073747423 Path ::@expr1073747424 isAbsolute (@expr1073747425 c@var1777 ) ?@expr1073747426 c@var1777 :@expr1073747427 projectDir@var1738 +@expr1073747428 c@var1777 ) ;
1074: fileSettings@var93 .@expr1073747429 push_back (@expr1073747430 fs@var1779 ) ;
1075: }
1076:
1077: return true ;
1078: }
1079:
1080: static std :: string joinRelativePath ( const std :: string & path1@var1781 , const std :: string & path2@var1782 )
1081: {
1082: if (@expr1073747431 !@expr1073747432 path1@var1781 .@expr1073747433 empty (@expr1073747434 ) &&@expr1073747435 !@expr1073747436 Path ::@expr1073747437 isAbsolute (@expr1073747438 path2@var1782 ) ) {
1083: return path1@var1781 +@expr1073747439 path2@var1782 ; }
1084: return path2@var1782 ;
1085: }
1086:
1087: static std :: list < std :: string > readXmlStringList ( const tinyxml2 :: XMLElement * node@var1783 , const std :: string & path@var1784 , const char name@var1785 [ ] , const char attribute@var1786 [ ] )
1088: {
1089: std ::@expr1073747440 list < std ::@expr5617 string > ret@var1787 ;
1090: for (@expr1073747442 const tinyxml2 ::@expr5617 XMLElement *@expr1073747444 child@var1788 =@expr1073747445 node@var1783 .@expr1073747446 FirstChildElement (@expr1073747447 ) ; child@var1788 ; child@var1788 =@expr1073747448 child@var1788 .@expr1073747449 NextSiblingElement (@expr1073747450 ) ) {
1091: if (@expr1073747451 strcmp (@expr1073747452 child@var1788 .@expr1073747453 Name (@expr1073747454 ) , name@var1785 ) !=@expr1073747455 0 ) {
1092: continue ; }
1093: const char * attr@var1789 ; attr@var1789 =@expr1073747456 attribute@var1786 ?@expr1073747457 child@var1788 .@expr1073747458 Attribute (@expr1073747459 attribute@var1786 ) :@expr1073747460 child@var1788 .@expr1073747461 GetText (@expr1073747462 ) ;
1094: if (@expr1073747463 attr@var1789 ) {
1095: ret@var1787 .@expr1073747464 push_back (@expr1073747465 joinRelativePath (@expr1073747466 path@var1784 , attr@var1789 ) ) ; }
1096: }
1097: return ret@var1787 ;
1098: }
1099:
1100: static std :: string join ( const std :: list < std :: string > & strlist@var1790 , const char * sep@var1791 )
1101: {
1102: std ::@expr1073747467 string ret@var1792 ;
1103: for (@expr1073747468 const std ::@expr1073747469 string &@expr1073747470 s@var1793 :@expr1073747471 strlist@var1790 ) {
1104: ret@var1792 +=@expr1073747472 (@expr1073747473 ret@var1792 .@expr1073747474 empty (@expr1073747475 ) ?@expr1073747476 "" :@expr1073747477 sep@var1791 ) +@expr1073747478 s@var1793 ;
1105: }
1106: return ret@var1792 ;
1107: }
1108:
1109: static std :: string istream_to_string ( std :: istream & istr@var1794 )
1110: {
1111: std ::@expr1073747479 istreambuf_iterator < char > eos@var1795 ;
1112: return std ::@expr1073747480 string (@expr1073747481 std ::@expr1073747482 istreambuf_iterator < char > (@expr1073747483 istr@var1794 ) , eos@var1795 ) ;
1113: }
1114:
1115:
1116: bool ImportProject :: importCppcheckGuiProject ( std :: istream & istr@var1796 , Settings * settings@var1797 )
1117: {
1118: tinyxml2 ::@expr1073747486 XMLDocument doc@var1798 ;
1119: const std ::@expr5663 string xmldata@var1799 =@expr1073747488 istream_to_string (@expr1073747489 istr@var1796 ) ;
1120: const tinyxml2 ::@expr5663 XMLError error@var1800 =@expr1073747491 doc@var1798 .@expr1073747492 Parse (@expr1073747493 xmldata@var1799 .@expr1073747494 data (@expr1073747495 ) , xmldata@var1799 .@expr1073747496 size (@expr1073747497 ) ) ;
1121: if (@expr1073747498 error@var1800 !=@expr1073747499 tinyxml2 ::@expr1073747500 XML_SUCCESS@expr1073747484 ) {
1122: printError (@expr1073747501 std ::@expr5678 string (@expr1073747503 "Cppcheck GUI project file is not a valid XML - " ) +@expr1073747504 tinyxml2 ::@expr1073747505 XMLDocument ::@expr1073747506 ErrorIDToName (@expr1073747507 error@var1800 ) ) ;
1123: return false ;
1124: }
1125: const tinyxml2 ::@expr1073747508 XMLElement@expr1073747485 * const rootnode@var1801 ; rootnode@var1801 =@expr1073747509 doc@var1798 .@expr1073747510 FirstChildElement (@expr1073747511 ) ;
1126: if (@expr1073747512 rootnode@var1801 ==@expr1073747513 nullptr ||@expr1073747514 strcmp (@expr1073747515 rootnode@var1801 .@expr1073747516 Name (@expr1073747517 ) , CppcheckXml ::@expr1073747518 ProjectElementName@var124 ) !=@expr1073747519 0 ) {
1127: printError (@expr1073747520 "Cppcheck GUI project file has no XML root node" ) ;
1128: return false ;
1129: }
1130:
1131: const std ::@expr5663 string &@expr5698 path@var1802 =@expr1073747523 mPath@var122 ;
1132:
1133: std ::@expr1073747524 list < std ::@expr5663 string > paths@var1803 ;
1134: std ::@expr1073747526 list < Suppressions ::@expr5663 Suppression > suppressions@var1804 ;
1135: Settings temp@var1805 ;
1136:
1137: guiProject@var103 .@expr5704 analyzeAllVsConfigs@var1895 .@expr1073747529 clear (@expr1073747530 ) ;
1138:
1139: for (@expr1073747531 const tinyxml2 ::@expr5663 XMLElement *@expr5709 node@var1806 =@expr1073747534 rootnode@var1801 .@expr1073747535 FirstChildElement (@expr1073747536 ) ; node@var1806 ; node@var1806 =@expr1073747537 node@var1806 .@expr1073747538 NextSiblingElement (@expr1073747539 ) ) {
1140: if (@expr1073747540 strcmp (@expr1073747541 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747544 RootPathName@var143 ) ==@expr1073747545 0 &&@expr1073747546 node@var1806 .@expr5723 Attribute (@expr5724 CppcheckXml ::@expr5725 RootPathNameAttrib@var144 ) ) {
1141: temp@var1805 .@expr5726 basePaths@var1807 .@expr1073747551 push_back (@expr1073747552 joinRelativePath (@expr1073747553 path@var1802 , node@var1806 .@expr5723 Attribute (@expr5724 CppcheckXml ::@expr5725 RootPathNameAttrib@var144 ) ) ) ;
1142: temp@var1805 .@expr5733 relativePaths@var1808 =@expr1073747558 true ;
1143: } else { if (@expr1073747559 strcmp (@expr1073747560 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747563 BugHunting@var131 ) ==@expr1073747564 0 ) {
1144: ; }
1145: else { if (@expr1073747565 strcmp (@expr1073747566 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747569 BuildDirElementName@var127 ) ==@expr1073747570 0 ) {
1146: temp@var1805 .@expr5747 buildDir@var1809 =@expr1073747572 joinRelativePath (@expr1073747573 path@var1802 , node@var1806 .@expr5750 GetText (@expr5751 ) ?@expr5752 node@var1806 .@expr5750 GetText (@expr5751 ) :@expr5755 "" ) ; }
1147: else { if (@expr1073747580 strcmp (@expr1073747581 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747584 IncludeDirElementName@var132 ) ==@expr1073747585 0 ) {
1148: temp@var1805 .@expr5762 includePaths@var1810 =@expr1073747587 readXmlStringList (@expr1073747588 node@var1806 , path@var1802 , CppcheckXml ::@expr1073747589 DirElementName@var133 , CppcheckXml ::@expr1073747590 DirNameAttrib@var134 ) ; }
1149: else { if (@expr1073747591 strcmp (@expr1073747592 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747595 DefinesElementName@var135 ) ==@expr1073747596 0 ) {
1150: temp@var1805 .@expr5773 userDefines@var1811 =@expr1073747598 join (@expr1073747599 readXmlStringList (@expr1073747600 node@var1806 , "" , CppcheckXml ::@expr1073747601 DefineName@var136 , CppcheckXml ::@expr1073747602 DefineNameAttrib@var137 ) , ";" ) ; }
1151: else { if (@expr1073747603 strcmp (@expr1073747604 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747607 UndefinesElementName@var138 ) ==@expr1073747608 0 ) {
1152: for (@expr1073747609 const std ::@expr5663 string &@expr5698 u@var1812 :@expr1073747612 readXmlStringList (@expr1073747613 node@var1806 , "" , CppcheckXml ::@expr1073747614 UndefineName@var139 , nullptr ) ) {
1153: temp@var1805 .@expr5791 userUndefs@var1813 .@expr1073747616 insert (@expr1073747617 u@var1812 ) ; }
1154: } else { if (@expr1073747618 strcmp (@expr1073747619 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747622 ImportProjectElementName@var128 ) ==@expr1073747623 0 ) {
1155: guiProject@var103 .@expr1073747624 projectFile@var1896 =@expr1073747625 path@var1802 +@expr1073747626 (@expr1073747627 node@var1806 .@expr5750 GetText (@expr5751 ) ?@expr5752 node@var1806 .@expr5750 GetText (@expr5751 ) :@expr5755 "" ) ; }
1156: else { if (@expr1073747634 strcmp (@expr1073747635 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747638 PathsElementName@var140 ) ==@expr1073747639 0 ) {
1157: paths@var1803 =@expr1073747640 readXmlStringList (@expr1073747641 node@var1806 , path@var1802 , CppcheckXml ::@expr1073747642 PathName@var141 , CppcheckXml ::@expr1073747643 PathNameAttrib@var142 ) ; }
1158: else { if (@expr1073747644 strcmp (@expr1073747645 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747648 ExcludeElementName@var148 ) ==@expr1073747649 0 ) {
1159: guiProject@var103 .@expr5826 excludedPaths@var1897 =@expr1073747651 readXmlStringList (@expr1073747652 node@var1806 , "" , CppcheckXml ::@expr1073747653 ExcludePathName@var149 , CppcheckXml ::@expr1073747654 ExcludePathNameAttrib@var150 ) ; }
1160: else { if (@expr1073747655 strcmp (@expr1073747656 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747659 FunctionContracts@var151 ) ==@expr1073747660 0 ) {
1161: ; }
1162: else { if (@expr1073747661 strcmp (@expr1073747662 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747665 VariableContractsElementName@var152 ) ==@expr1073747666 0 ) {
1163: ; }
1164: else { if (@expr1073747667 strcmp (@expr1073747668 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747671 IgnoreElementName@var145 ) ==@expr1073747672 0 ) {
1165: guiProject@var103 .@expr5826 excludedPaths@var1897 =@expr1073747674 readXmlStringList (@expr1073747675 node@var1806 , "" , CppcheckXml ::@expr1073747676 IgnorePathName@var146 , CppcheckXml ::@expr1073747677 IgnorePathNameAttrib@var147 ) ; }
1166: else { if (@expr1073747678 strcmp (@expr1073747679 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747682 LibrariesElementName@var153 ) ==@expr1073747683 0 ) {
1167: guiProject@var103 .@expr1073747684 libraries@var1898 =@expr1073747685 readXmlStringList (@expr1073747686 node@var1806 , "" , CppcheckXml ::@expr1073747687 LibraryElementName@var154 , nullptr ) ; }
1168: else { if (@expr1073747688 strcmp (@expr1073747689 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747692 SuppressionsElementName@var156 ) ==@expr1073747693 0 ) {
1169: for (@expr1073747694 const tinyxml2 ::@expr5663 XMLElement *@expr5709 child@var1814 =@expr1073747697 node@var1806 .@expr5874 FirstChildElement (@expr5875 ) ; child@var1814 ; child@var1814 =@expr1073747700 child@var1814 .@expr1073747701 NextSiblingElement (@expr1073747702 ) ) {
1170: if (@expr1073747703 strcmp (@expr1073747704 child@var1814 .@expr1073747705 Name (@expr1073747706 ) , CppcheckXml ::@expr1073747707 SuppressionElementName@var157 ) !=@expr1073747708 0 ) {
1171: continue ; }
1172: auto read@var1815 ; read@var1815 =@expr1073747709 [@expr1073747710 ] (@expr1073747711 const char *@expr5709 s@var1816 , const char *@expr5709 def@var1817 ) {
1173: return s@var1816 ?@expr1073747714 s@var1816 :@expr1073747715 def@var1817 ;
1174: } ;
1175: Suppressions ::@expr1073747716 Suppression s@var1818 ;
1176: s@var1818 .@expr1073747717 errorId@var1819 =@expr1073747718 read@var1815 (@expr1073747719 child@var1814 .@expr1073747720 GetText (@expr1073747721 ) , "" ) ;
1177: s@var1818 .@expr5898 fileName@var1820 =@expr1073747723 read@var1815 (@expr1073747724 child@var1814 .@expr5901 Attribute (@expr1073747726 "fileName" ) , "" ) ;
1178: if (@expr1073747727 !@expr1073747728 s@var1818 .@expr5898 fileName@var1820 .@expr1073747730 empty (@expr1073747731 ) ) {
1179: s@var1818 .@expr5898 fileName@var1820 =@expr1073747733 joinRelativePath (@expr1073747734 path@var1802 , s@var1818 .@expr5898 fileName@var1820 ) ; }
1180: s@var1818 .@expr1073747736 lineNumber@var1821 =@expr1073747737 child@var1814 .@expr1073747738 IntAttribute (@expr1073747739 "lineNumber" , Suppressions ::@expr1073747740 Suppression ::@expr1073747741 NO_LINE ) ;
1181: s@var1818 .@expr1073747742 symbolName@var1822 =@expr1073747743 read@var1815 (@expr1073747744 child@var1814 .@expr5901 Attribute (@expr1073747746 "symbolName" ) , "" ) ;
1182: std ::@expr1073747747 istringstream (@expr1073747748 read@var1815 (@expr1073747749 child@var1814 .@expr5901 Attribute (@expr1073747751 "hash" ) , "0" ) ) >>@expr1073747752 s@var1818 .@expr1073747753 hash@var1823 ;
1183: suppressions@var1804 .@expr1073747754 push_back (@expr1073747755 s@var1818 ) ;
1184: }
1185: } else { if (@expr1073747756 strcmp (@expr1073747757 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747760 VSConfigurationElementName@var175 ) ==@expr1073747761 0 ) {
1186: guiProject@var103 .@expr1073747762 checkVsConfigs@var1894 =@expr1073747763 readXmlStringList (@expr1073747764 node@var1806 , "" , CppcheckXml ::@expr1073747765 VSConfigurationName@var176 , nullptr ) ; }
1187: else { if (@expr1073747766 strcmp (@expr1073747767 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747770 PlatformElementName@var155 ) ==@expr1073747771 0 ) {
1188: guiProject@var103 .@expr1073747772 platform@var1899 =@expr1073747773 node@var1806 .@expr5750 GetText (@expr5751 ) ; }
1189: else { if (@expr1073747776 strcmp (@expr1073747777 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747780 AnalyzeAllVsConfigsElementName@var129 ) ==@expr1073747781 0 ) {
1190: guiProject@var103 .@expr5704 analyzeAllVsConfigs@var1895 =@expr1073747783 node@var1806 .@expr5750 GetText (@expr5751 ) ; }
1191: else { if (@expr1073747786 strcmp (@expr1073747787 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747790 Parser@var130 ) ==@expr1073747791 0 ) {
1192: temp@var1805 .@expr5968 clang@var1824 =@expr1073747793 true ; }
1193: else { if (@expr1073747794 strcmp (@expr1073747795 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747798 AddonsElementName@var159 ) ==@expr1073747799 0 ) {
1194: temp@var1805 .@expr5976 addons@var1825 =@expr1073747801 readXmlStringList (@expr1073747802 node@var1806 , "" , CppcheckXml ::@expr1073747803 AddonElementName@var158 , nullptr ) ; }
1195: else { if (@expr1073747804 strcmp (@expr1073747805 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747808 TagsElementName@var162 ) ==@expr1073747809 0 ) {
1196: node@var1806 .@expr5723 Attribute (@expr1073747811 CppcheckXml ::@expr1073747812 TagElementName@var163 ) ; }
1197: else { if (@expr1073747813 strcmp (@expr1073747814 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747817 ToolsElementName@var161 ) ==@expr1073747818 0 ) {
1198: const std ::@expr1073747819 list < std ::@expr5663 string > toolList@var1826 =@expr1073747821 readXmlStringList (@expr1073747822 node@var1806 , "" , CppcheckXml ::@expr1073747823 ToolElementName@var160 , nullptr ) ;
1199: for (@expr1073747824 const std ::@expr5663 string &@expr5698 toolName@var1827 :@expr1073747827 toolList@var1826 ) {
1200: if (@expr1073747828 toolName@var1827 ==@expr1073747829 std ::@expr5678 string (@expr1073747831 CppcheckXml ::@expr1073747832 ClangTidy@var173 ) ) {
1201: temp@var1805 .@expr6009 clangTidy@var1828 =@expr1073747834 true ; }
1202: }
1203: } else { if (@expr1073747835 strcmp (@expr1073747836 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747839 CheckHeadersElementName@var168 ) ==@expr1073747840 0 ) {
1204: temp@var1805 .@expr6017 checkHeaders@var1829 =@expr1073747842 strcmp (@expr6019 node@var1806 .@expr5750 GetText (@expr5751 ) , "true" ) ==@expr6022 0 ; }
1205: else { if (@expr1073747847 strcmp (@expr1073747848 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747851 CheckUnusedTemplatesElementName@var169 ) ==@expr1073747852 0 ) {
1206: temp@var1805 .@expr6029 checkUnusedTemplates@var1830 =@expr1073747854 strcmp (@expr6019 node@var1806 .@expr5750 GetText (@expr5751 ) , "true" ) ==@expr6022 0 ; }
1207: else { if (@expr1073747859 strcmp (@expr1073747860 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747863 MaxCtuDepthElementName@var170 ) ==@expr1073747864 0 ) {
1208: temp@var1805 .@expr6041 maxCtuDepth@var1831 =@expr1073747866 std ::@expr6043 atoi (@expr6044 node@var1806 .@expr5750 GetText (@expr5751 ) ) ; }
1209: else { if (@expr1073747871 strcmp (@expr1073747872 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747875 MaxTemplateRecursionElementName@var171 ) ==@expr1073747876 0 ) {
1210: temp@var1805 .@expr6053 maxTemplateRecursion@var1832 =@expr1073747878 std ::@expr6043 atoi (@expr6044 node@var1806 .@expr5750 GetText (@expr5751 ) ) ; }
1211: else { if (@expr1073747883 strcmp (@expr1073747884 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747887 CheckUnknownFunctionReturn@var172 ) ==@expr1073747888 0 ) {
1212: ; }
1213: else { if (@expr1073747889 strcmp (@expr1073747890 node@var1806 .@expr5718 Name (@expr5719 ) , Settings ::@expr6069 SafeChecks ::@expr1073747894 XmlRootName@var766 ) ==@expr1073747895 0 ) {
1214: for (@expr1073747896 const tinyxml2 ::@expr5663 XMLElement *@expr5709 child@var1833 =@expr1073747899 node@var1806 .@expr5874 FirstChildElement (@expr5875 ) ; child@var1833 ; child@var1833 =@expr1073747902 child@var1833 .@expr1073747903 NextSiblingElement (@expr1073747904 ) ) {
1215: if (@expr1073747905 strcmp (@expr1073747906 child@var1833 .@expr6083 Name (@expr6084 ) , Settings ::@expr6069 SafeChecks ::@expr1073747910 XmlClasses@var767 ) ==@expr1073747911 0 ) {
1216: temp@var1805 .@expr6088 safeChecks@var1834 .@expr1073747913 classes@var1835 =@expr1073747914 true ; }
1217: else { if (@expr1073747915 strcmp (@expr1073747916 child@var1833 .@expr6083 Name (@expr6084 ) , Settings ::@expr6069 SafeChecks ::@expr1073747920 XmlExternalFunctions@var768 ) ==@expr1073747921 0 ) {
1218: temp@var1805 .@expr6088 safeChecks@var1834 .@expr1073747923 externalFunctions@var1836 =@expr1073747924 true ; }
1219: else { if (@expr1073747925 strcmp (@expr1073747926 child@var1833 .@expr6083 Name (@expr6084 ) , Settings ::@expr6069 SafeChecks ::@expr1073747930 XmlInternalFunctions@var769 ) ==@expr1073747931 0 ) {
1220: temp@var1805 .@expr6088 safeChecks@var1834 .@expr1073747933 internalFunctions@var1837 =@expr1073747934 true ; }
1221: else { if (@expr1073747935 strcmp (@expr1073747936 child@var1833 .@expr6083 Name (@expr6084 ) , Settings ::@expr6069 SafeChecks ::@expr1073747940 XmlExternalVariables@var770 ) ==@expr1073747941 0 ) {
1222: temp@var1805 .@expr6088 safeChecks@var1834 .@expr1073747943 externalVariables@var1838 =@expr1073747944 true ; }
1223: else {
1224: return false ; } } } }
1225: }
1226: } else { if (@expr1073747945 strcmp (@expr1073747946 node@var1806 .@expr5718 Name (@expr5719 ) , CppcheckXml ::@expr1073747949 TagWarningsElementName@var164 ) ==@expr1073747950 0 ) {
1227: ; }
1228: else {
1229: return false ; } } } } } } } } } } } } } } } } } } } } } } } } } } } }
1230: }
1231: settings@var1797 .@expr1073747951 basePaths@var1839 =@expr1073747952 temp@var1805 .@expr5726 basePaths@var1807 ;
1232: settings@var1797 .@expr1073747954 relativePaths@var1840 |=@expr1073747955 temp@var1805 .@expr5733 relativePaths@var1808 ;
1233: settings@var1797 .@expr1073747957 buildDir@var1841 =@expr1073747958 temp@var1805 .@expr5747 buildDir@var1809 ;
1234: settings@var1797 .@expr1073747960 includePaths@var1842 =@expr1073747961 temp@var1805 .@expr5762 includePaths@var1810 ;
1235: settings@var1797 .@expr1073747963 userDefines@var1843 =@expr1073747964 temp@var1805 .@expr5773 userDefines@var1811 ;
1236: settings@var1797 .@expr1073747966 userUndefs@var1844 =@expr1073747967 temp@var1805 .@expr5791 userUndefs@var1813 ;
1237: settings@var1797 .@expr1073747969 addons@var1845 =@expr1073747970 temp@var1805 .@expr5976 addons@var1825 ;
1238: settings@var1797 .@expr1073747972 clang@var1846 =@expr1073747973 temp@var1805 .@expr5968 clang@var1824 ;
1239: settings@var1797 .@expr1073747975 clangTidy@var1847 =@expr1073747976 temp@var1805 .@expr6009 clangTidy@var1828 ;
1240:
1241: for (@expr1073747978 const std ::@expr5663 string &@expr5698 p@var1848 :@expr1073747981 paths@var1803 ) {
1242: guiProject@var103 .@expr1073747982 pathNames@var1900 .@expr1073747983 push_back (@expr1073747984 p@var1848 ) ; }
1243: for (@expr1073747985 const Suppressions ::@expr5663 Suppression &@expr5698 supp@var1849 :@expr1073747988 suppressions@var1804 ) {
1244: settings@var1797 .@expr1073747989 nomsg@var1850 .@expr1073747990 addSuppression (@expr1073747991 supp@var1849 ) ; }
1245: settings@var1797 .@expr1073747992 checkHeaders@var1851 =@expr1073747993 temp@var1805 .@expr6017 checkHeaders@var1829 ;
1246: settings@var1797 .@expr1073747995 checkUnusedTemplates@var1852 =@expr1073747996 temp@var1805 .@expr6029 checkUnusedTemplates@var1830 ;
1247: settings@var1797 .@expr1073747998 maxCtuDepth@var1853 =@expr1073747999 temp@var1805 .@expr6041 maxCtuDepth@var1831 ;
1248: settings@var1797 .@expr1073748001 maxTemplateRecursion@var1854 =@expr1073748002 temp@var1805 .@expr6053 maxTemplateRecursion@var1832 ;
1249: settings@var1797 .@expr1073748004 safeChecks@var1855 =@expr1073748005 temp@var1805 .@expr6088 safeChecks@var1834 ;
1250:
1251: return true ;
1252: }
1253:
1254: void ImportProject :: selectOneVsConfig ( Settings :: PlatformType platform@var1856 )
1255: {
1256: std ::@expr1073748010 set < std ::@expr6187 string > filenames@var1857 ;
1257: for (@expr1073748012 std ::@expr6187 list < ImportProject ::@expr6187 FileSettings > ::@expr6187 iterator it@var1858 =@expr1073748016 fileSettings@var93 .@expr1073748017 begin (@expr1073748018 ) ; it@var1858 !=@expr1073748019 fileSettings@var93 .@expr1073748020 end (@expr1073748021 ) ; ) {
1258: if (@expr1073748022 it@var1858 .@expr1073748023 cfg@var1859 .@expr1073748024 empty (@expr1073748025 ) ) {
1259: ++@expr1073748026 it@var1858 ;
1260: continue ;
1261: }
1262: const ImportProject ::@expr6187 FileSettings &@expr1073748028 fs@var1860 =@expr1073748029 *@expr1073748030 it@var1858 ;
1263: bool remove@var1861 ; remove@var1861 =@expr1073748031 false ;
1264: if (@expr1073748032 fs@var1860 .@expr1073748033 cfg@var1862 .@expr1073748034 compare (@expr1073748035 0 , 5 , "Debug" ) !=@expr1073748036 0 ) {
1265: remove@var1861 =@expr1073748037 true ; }
1266: if (@expr1073748038 platform@var1856 ==@expr6215 Settings ::@expr6216 Win64 &&@expr1073748041 fs@var1860 .@expr6218 platformType@var1863 !=@expr1073748043 platform@var1856 ) {
1267: remove@var1861 =@expr1073748044 true ; }
1268: else { if (@expr1073748045 (@expr1073748046 platform@var1856 ==@expr1073748047 Settings ::@expr1073748048 Win32A@expr1073748007 ||@expr1073748049 platform@var1856 ==@expr1073748050 Settings ::@expr1073748051 Win32W@expr1073748008 ) &&@expr1073748052 fs@var1860 .@expr6218 platformType@var1863 ==@expr1073748054 Settings ::@expr6216 Win64@expr6185 ) {
1269: remove@var1861 =@expr1073748056 true ; }
1270: else { if (@expr1073748057 fs@var1860 .@expr6218 platformType@var1863 !=@expr1073748059 Settings ::@expr6216 Win64 &&@expr1073748061 platform@var1856 ==@expr6215 Settings ::@expr6216 Win64@expr6185 ) {
1271: remove@var1861 =@expr1073748064 true ; }
1272: else { if (@expr1073748065 filenames@var1857 .@expr1073748066 find (@expr1073748067 fs@var1860 .@expr6244 filename@var1864 ) !=@expr1073748069 filenames@var1857 .@expr1073748070 end (@expr1073748071 ) ) {
1273: remove@var1861 =@expr1073748072 true ; } } } }
1274: if (@expr1073748073 remove@var1861 ) {
1275: it@var1858 =@expr1073748074 fileSettings@var93 .@expr1073748075 erase (@expr1073748076 it@var1858 ) ;
1276: } else {
1277: filenames@var1857 .@expr1073748077 insert (@expr1073748078 fs@var1860 .@expr6244 filename@var1864 ) ;
1278: ++@expr1073748080 it@var1858 ;
1279: }
1280: }
1281: }
1282:
1283: std :: list < std :: string > ImportProject :: getVSConfigs ( )
1284: {
1285: return std ::@expr1073748081 list < std ::@expr1073748082 string > (@expr1073748083 mAllVSConfigs@var123 .@expr1073748084 begin (@expr1073748085 ) , mAllVSConfigs@var123 .@expr1073748086 end (@expr1073748087 ) ) ;
1286: }
1287:
1288: void ImportProject :: setRelativePaths ( const std :: string & filename@var1865 )
1289: {
1290: if (@expr1073748088 Path ::@expr1073748089 isAbsolute (@expr1073748090 filename@var1865 ) ) {
1291: return ; }
1292: const std ::@expr6267 vector < std ::@expr6267 string > basePaths@var1866 {@expr1073748093 Path ::@expr1073748094 fromNativeSeparators (@expr1073748095 Path ::@expr1073748096 getCurrentPath (@expr1073748097 ) ) } ;
1293: for (@expr1073748098 auto &@expr6275 fs@var1867 :@expr1073748100 fileSettings@var93 ) {
1294: fs@var1867 .@expr6277 filename@var1868 =@expr1073748102 Path ::@expr6279 getRelativePath (@expr1073748104 fs@var1867 .@expr6277 filename@var1868 , basePaths@var1866 ) ;
1295: for (@expr1073748106 auto &@expr6275 includePath@var1869 :@expr1073748108 fs@var1867 .@expr1073748109 includePaths@var1870 ) {
1296: includePath@var1869 =@expr1073748110 Path ::@expr6279 getRelativePath (@expr1073748112 includePath@var1869 , basePaths@var1866 ) ; }
1297: }
1298: }
1299:
1300: void ImportProject :: printError ( const std :: string & message@var1871 )
1301: {
1302: std ::@expr1073748115 cout@expr1073748113 <<@expr1073748116 "cppcheck: error: " <<@expr1073748117 message@var1871 <<@expr1073748118 std ::@expr1073748119 endl@expr1073748114 ;
1303: }
1304:
1305: bool ImportProject :: sourceFileExists ( const std :: string & file@var1872 )
1306: {
1307: return Path ::@expr1073748120 fileExists (@expr1073748121 file@var1872 ) ;
1308: }

##file cppcheck-2.8/lib/settings.h

14:
|
48:
49: class SimpleEnableGroup<Severity::SeverityType> {
50: uint32_t mFlags@var1873 ; mFlags@var1873 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1873 ;
54: }
55: void clear ( ) {
56: mFlags@var1873 =@expr1073748122 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1873 =@expr1073748123 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1874 ) {
62: if (@expr1073748124 enabled@var1874 ) {
63: fill (@expr1073748125 ) ; }
64: else {
65: clear (@expr1073748126 ) ; }
66: }
67: bool isEnabled ( Severity :: SeverityType flag@var1875 ) const {
68: return (@expr6303 mFlags@var1873 &@expr1073748128 (@expr6303 1U <<@expr1073748130 (@expr1073748131 uint32_t ) flag@var1875 ) ) !=@expr1073748132 0 ;
69: }
70: void enable ( Severity :: SeverityType flag@var1876 ) {
71: mFlags@var1873 |=@expr1073748133 (@expr1073748134 1U <<@expr1073748135 (@expr1073748136 uint32_t ) flag@var1876 ) ;
72: }
73: void disable ( Severity :: SeverityType flag@var1877 ) {
74: mFlags@var1873 &=@expr1073748137 ~@expr1073748138 (@expr1073748139 1U <<@expr1073748140 (@expr1073748141 uint32_t ) flag@var1877 ) ;
75: }
76: void setEnabled ( Severity :: SeverityType flag@var1878 , bool enabled@var1879 ) {
77: if (@expr1073748142 enabled@var1879 ) {
78: enable (@expr1073748143 flag@var1878 ) ; }
79: else {
80: disable (@expr1073748144 flag@var1878 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Certainty::CertaintyLevel> {
50: uint32_t mFlags@var1880 ; mFlags@var1880 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1880 ;
54: }
55: void clear ( ) {
56: mFlags@var1880 =@expr1073748145 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1880 =@expr1073748146 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1881 ) {
62: if (@expr1073748147 enabled@var1881 ) {
63: fill (@expr1073748148 ) ; }
64: else {
65: clear (@expr1073748149 ) ; }
66: }
67: bool isEnabled ( Certainty :: CertaintyLevel flag@var1882 ) const {
68: return (@expr6326 mFlags@var1880 &@expr1073748151 (@expr6326 1U <<@expr1073748153 (@expr1073748154 uint32_t ) flag@var1882 ) ) !=@expr1073748155 0 ;
69: }
70: void enable ( Certainty :: CertaintyLevel flag@var1883 ) {
71: mFlags@var1880 |=@expr1073748156 (@expr1073748157 1U <<@expr1073748158 (@expr1073748159 uint32_t ) flag@var1883 ) ;
72: }
73: void disable ( Certainty :: CertaintyLevel flag@var1884 ) {
74: mFlags@var1880 &=@expr1073748160 ~@expr1073748161 (@expr1073748162 1U <<@expr1073748163 (@expr1073748164 uint32_t ) flag@var1884 ) ;
75: }
76: void setEnabled ( Certainty :: CertaintyLevel flag@var1885 , bool enabled@var1886 ) {
77: if (@expr1073748165 enabled@var1886 ) {
78: enable (@expr1073748166 flag@var1885 ) ; }
79: else {
80: disable (@expr1073748167 flag@var1885 ) ; }
81: }
82: } ;
49: class SimpleEnableGroup<Checks::CheckList> {
50: uint32_t mFlags@var1887 ; mFlags@var1887 = 0 ;
51: public:
52: uint32_t intValue ( ) const {
53: return mFlags@var1887 ;
54: }
55: void clear ( ) {
56: mFlags@var1887 =@expr1073748168 0 ;
57: }
58: void fill ( ) {
59: mFlags@var1887 =@expr1073748169 0xFFFFFFFF ;
60: }
61: void setEnabledAll ( bool enabled@var1888 ) {
62: if (@expr1073748170 enabled@var1888 ) {
63: fill (@expr1073748171 ) ; }
64: else {
65: clear (@expr1073748172 ) ; }
66: }
67: bool isEnabled ( Checks :: CheckList flag@var1889 ) const {
68: return (@expr6349 mFlags@var1887 &@expr1073748174 (@expr6349 1U <<@expr1073748176 (@expr1073748177 uint32_t ) flag@var1889 ) ) !=@expr1073748178 0 ;
69: }
70: void enable ( Checks :: CheckList flag@var1890 ) {
71: mFlags@var1887 |=@expr1073748179 (@expr1073748180 1U <<@expr1073748181 (@expr1073748182 uint32_t ) flag@var1890 ) ;
72: }
73: void disable ( Checks :: CheckList flag@var1891 ) {
74: mFlags@var1887 &=@expr1073748183 ~@expr1073748184 (@expr1073748185 1U <<@expr1073748186 (@expr1073748187 uint32_t ) flag@var1891 ) ;
75: }
76: void setEnabled ( Checks :: CheckList flag@var1892 , bool enabled@var1893 ) {
77: if (@expr1073748188 enabled@var1893 ) {
78: enable (@expr1073748189 flag@var1892 ) ; }
79: else {
80: disable (@expr1073748190 flag@var1892 ) ; }
81: }
82: } ;



##Value flow
Line 44
  >= always {!<=-1,!>=2}
  64 always 64
Line 46
  - possible >=-4611686018427387904
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
Line 50
  >= always {!<=-1,!>=2}
  64 always 64
Line 51
  ~ always !<=-1
  0ULL always 0
  >> always !<=-1
  1 always 1
Line 52
  1LL always 1
  << possible <=4611686018427387904
  bit {!>=64,<=63}
  - {!>=63,<=62}
  1 always 1
  - {<=4611686018427387903,!>=4611686018427387904}
  1LL always 1
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 62
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 63
  intMax always !<=-1
  intMax always !<=-1
  = always !<=-1
Line 64
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  intMax always !<=-1
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 72
  longMax always !<=-1
  longMax always !<=-1
  = always !<=-1
Line 73
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longMax always !<=-1
Line 76
  ( always {!<=-1,!>=2}
  value always !<=-1
Line 77
  longLongMax always !<=-1
  longLongMax always !<=-1
  = always !<=-1
Line 78
  return always {!<=-1,!>=2}
  value always !<=-1
  <= always {!<=-1,!>=2}
  longLongMax always !<=-1
Line 103
  Unspecified always 0
Line 104
  Native always 1
Line 105
  Win32A always 2
Line 106
  Win32W always 3
Line 107
  Win64 always 4
Line 108
  Unix32 always 5
Line 109
  Unix64 always 6
Line 110
  PlatformFile always 7
Line 117
  ( always {!<=-1,!>=2}
Line 125
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 135
  return always {!<=-1,!>=2}
  platformType possible {3,4}
  == {!<=-1,!>=2,0}
  Win32A always 2
  || always {!<=-1,!>=2}
Line 136
  platformType {4,!2}
  == {!<=-1,!>=2,0}
  Win32W always 3
  || always {!<=-1,!>=2}
Line 137
  platformType always {!2,!3}
  == always {!<=-1,!>=2}
  Win64 always 4
Line 146
  Unspecified always 0
Line 147
  "Unspecified" always "Unspecified"
Line 148
  Native always 1
Line 149
  "Native" always "Native"
Line 150
  Win32A always 2
Line 151
  "win32A" always "win32A"
Line 152
  Win32W always 3
Line 153
  "win32W" always "win32W"
Line 154
  Win64 always 4
Line 155
  "win64" always "win64"
Line 156
  Unix32 always 5
Line 157
  "unix32" always "unix32"
Line 158
  Unix64 always 6
Line 159
  "unix64" always "unix64"
Line 160
  PlatformFile always 7
Line 161
  "platformFile" always "platformFile"
Line 163
  "unknown" always "unknown"
Line 168
  1 always 1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {47@73,59@111,39@37659,34@37915}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  end possible {"\\\""@22044,".json"@23836,".sln"@24604,".vcxproj"@25372}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  end possible {"\\\""@86,".json"@93,".sln"@96,".vcxproj"@99,".bpr"@102,".cppcheck"@105}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@147,34@148}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@147,""@148,""@149,"U"@150,"U"@151,"u"@152,"u"@153,"u8"@154,"u8"@155}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@24,34@25}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@21,34@23}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 40
  ( always {!<=-1,!>=2}
Line 41
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 54
  UNKNOWN always 0
Line 55
  MISSING always 1
Line 56
  FAILURE always 2
Line 57
  COMPILE_DB always 3
Line 58
  VS_SLN always 4
Line 59
  VS_VCXPROJ always 5
Line 60
  BORLAND always 6
Line 61
  CPPCHECK_GUI always 7
Line 66
  :: always 0
  Unspecified always 0
  msc always {!<=-1,!>=2}
  false always 0
  useMfc always {!<=-1,!>=2}
  false always 0
Line 71
  msc always {!<=-1,!>=2}
  ? possible {";_MSC_VER=1900",""}
  ";_MSC_VER=1900" always ";_MSC_VER=1900"
  : always ""
  "" always ""
  useMfc always {!<=-1,!>=2}
  ? possible {";__AFXWIN_H__=1",""}
  ";__AFXWIN_H__=1" always ";__AFXWIN_H__=1"
  : always ""
  "" always ""
Line 78
  msc always {!<=-1,!>=2}
Line 79
  useMfc always {!<=-1,!>=2}
Line 108
  , always 0
  = always 0
  nullptr always 0
Line 110
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 112
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 128
  8 always 8
  = always "project"
  "project" always "project"
Line 129
  8 always 8
  = always "version"
  "version" always "version"
Line 130
  2 always 2
  = always "1"
  "1" always "1"
Line 131
  9 always 9
  = always "builddir"
  "builddir" always "builddir"
Line 132
  14 always 14
  = always "importproject"
  "importproject" always "importproject"
Line 133
  23 always 23
  = always "analyze-all-vs-configs"
  "analyze-all-vs-configs" always "analyze-all-vs-configs"
Line 134
  7 always 7
  = always "parser"
  "parser" always "parser"
Line 135
  12 always 12
  = always "bug-hunting"
  "bug-hunting" always "bug-hunting"
Line 136
  11 always 11
  = always "includedir"
  "includedir" always "includedir"
Line 137
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 138
  5 always 5
  = always "name"
  "name" always "name"
Line 139
  8 always 8
  = always "defines"
  "defines" always "defines"
Line 140
  7 always 7
  = always "define"
  "define" always "define"
Line 141
  5 always 5
  = always "name"
  "name" always "name"
Line 142
  10 always 10
  = always "undefines"
  "undefines" always "undefines"
Line 143
  9 always 9
  = always "undefine"
  "undefine" always "undefine"
Line 144
  6 always 6
  = always "paths"
  "paths" always "paths"
Line 145
  4 always 4
  = always "dir"
  "dir" always "dir"
Line 146
  5 always 5
  = always "name"
  "name" always "name"
Line 147
  5 always 5
  = always "root"
  "root" always "root"
Line 148
  5 always 5
  = always "name"
  "name" always "name"
Line 149
  7 always 7
  = always "ignore"
  "ignore" always "ignore"
Line 150
  5 always 5
  = always "path"
  "path" always "path"
Line 151
  5 always 5
  = always "name"
  "name" always "name"
Line 152
  8 always 8
  = always "exclude"
  "exclude" always "exclude"
Line 153
  5 always 5
  = always "path"
  "path" always "path"
Line 154
  5 always 5
  = always "name"
  "name" always "name"
Line 155
  19 always 19
  = always "function-contracts"
  "function-contracts" always "function-contracts"
Line 156
  19 always 19
  = always "variable-contracts"
  "variable-contracts" always "variable-contracts"
Line 157
  10 always 10
  = always "libraries"
  "libraries" always "libraries"
Line 158
  8 always 8
  = always "library"
  "library" always "library"
Line 159
  9 always 9
  = always "platform"
  "platform" always "platform"
Line 160
  13 always 13
  = always "suppressions"
  "suppressions" always "suppressions"
Line 161
  12 always 12
  = always "suppression"
  "suppression" always "suppression"
Line 162
  6 always 6
  = always "addon"
  "addon" always "addon"
Line 163
  7 always 7
  = always "addons"
  "addons" always "addons"
Line 164
  5 always 5
  = always "tool"
  "tool" always "tool"
Line 165
  6 always 6
  = always "tools"
  "tools" always "tools"
Line 166
  5 always 5
  = always "tags"
  "tags" always "tags"
Line 167
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 168
  13 always 13
  = always "tag-warnings"
  "tag-warnings" always "tag-warnings"
Line 169
  4 always 4
  = always "tag"
  "tag" always "tag"
Line 170
  8 always 8
  = always "warning"
  "warning" always "warning"
Line 171
  5 always 5
  = always "hash"
  "hash" always "hash"
Line 172
  14 always 14
  = always "check-headers"
  "check-headers" always "check-headers"
Line 173
  23 always 23
  = always "check-unused-templates"
  "check-unused-templates" always "check-unused-templates"
Line 174
  14 always 14
  = always "max-ctu-depth"
  "max-ctu-depth" always "max-ctu-depth"
Line 175
  23 always 23
  = always "max-template-recursion"
  "max-template-recursion" always "max-template-recursion"
Line 176
  37 always 37
  = always "check-unknown-function-return-values"
  "check-unknown-function-return-values" always "check-unknown-function-return-values"
Line 177
  11 always 11
  = always "clang-tidy"
  "clang-tidy" always "clang-tidy"
Line 178
  5 always 5
  = always "name"
  "name" always "name"
Line 179
  18 always 18
  = always "vs-configurations"
  "vs-configurations" always "vs-configurations"
Line 180
  7 always 7
  = always "config"
  "config" always "config"
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  iterator always {!<=-1,!>=2}
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 197
  unusedFunctionChecking always {!<=-1,!>=2}
Line 203
  unusedFunctionChecking always {!<=-1,!>=2}
Line 30
  SHOWTIME_NONE always 0
  = always 0
  0 always 0
  , always 1
Line 31
  SHOWTIME_FILE always 1
  , always 2
Line 32
  SHOWTIME_SUMMARY always 2
  , always 3
Line 33
  SHOWTIME_TOP5 always 3
Line 40
  = always 0
  0 always 0
Line 48
  0 always 0
Line 49
  0 always 0
Line 52
  ( always !<=-1
  ( always !<=-1
Line 70
  , always 0
  = always 0
  nullptr always 0
Line 82
  mStopped always {!<=-1,!>=2}
Line 114
  checkAllConfigurations always {!<=-1,!>=2}
Line 117
  checkConfiguration always {!<=-1,!>=2}
Line 122
  checkHeaders always {!<=-1,!>=2}
Line 125
  checkLibrary always {!<=-1,!>=2}
Line 131
  checkUnusedTemplates always {!<=-1,!>=2}
Line 134
  clang always {!<=-1,!>=2}
Line 140
  clangTidy always {!<=-1,!>=2}
Line 152
  daca always {!<=-1,!>=2}
Line 155
  debugnormal always {!<=-1,!>=2}
Line 158
  debugSimplified always {!<=-1,!>=2}
Line 161
  debugtemplate always {!<=-1,!>=2}
Line 164
  debugwarnings always {!<=-1,!>=2}
Line 167
  dump always {!<=-1,!>=2}
Line 171
  None always 0
  C always 1
  CPP always 2
Line 178
  exceptionHandling always {!<=-1,!>=2}
Line 191
  force always {!<=-1,!>=2}
Line 198
  inlineSuppressions always {!<=-1,!>=2}
Line 202
  jobs always !<=-1
Line 207
  jointSuppressionReport always {!<=-1,!>=2}
Line 243
  preprocessOnly always {!<=-1,!>=2}
Line 248
  quiet always {!<=-1,!>=2}
Line 251
  relativePaths always {!<=-1,!>=2}
Line 254
  reportProgress always {!<=-1,!>=2}
Line 260
  "simple" always "simple"
Line 261
  "rule" always "rule"
Line 262
  :: always 3
  style always 3
Line 280
  classes always {!<=-1,!>=2}
  false always 0
  externalFunctions always {!<=-1,!>=2}
  false always 0
  internalFunctions always {!<=-1,!>=2}
  false always 0
  externalVariables always {!<=-1,!>=2}
  false always 0
Line 289
  classes always {!<=-1,!>=2}
  = always 0
  externalFunctions always {!<=-1,!>=2}
  = always 0
  internalFunctions always {!<=-1,!>=2}
  = always 0
  externalVariables always {!<=-1,!>=2}
  = always 0
  false always 0
Line 298
  classes always {!<=-1,!>=2}
Line 305
  externalFunctions always {!<=-1,!>=2}
Line 311
  internalFunctions always {!<=-1,!>=2}
Line 317
  externalVariables always {!<=-1,!>=2}
Line 350
  verbose always {!<=-1,!>=2}
Line 353
  xml always {!<=-1,!>=2}
Line 362
  ( always {!<=-1,!>=2}
Line 364
  ( always !<=-1
  >= always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(file.length()),!>=symbolic=(file.length()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 365
  return always {!<=-1,!>=2}
  true always 1
Line 368
  return always {!<=-1,!>=2}
  false always 0
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  inconclusiveCheck always {!<=-1,!>=2}
  = always 0
  false always 0
Line 386
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(libraries)
  ( {lifetime[Iterator]=(libraries),start=0}
  ( {lifetime[Iterator]=(libraries),end=0}
  "posix" always "posix"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(libraries),end=0}
Line 391
  t always {!<=-1,!>=2}
  = always 1
  true always 1
Line 392
  = always {!<=-1,!>=2}
  t always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 397
  return always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@237,128@238,64@239,32@240,16@241,8@242,4@243,2@244,1@245}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@246,128@247,64@248,32@249,16@250,8@251,4@252,2@253,1@254}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@246,4294967167@247,4294967231@248,4294967263@249,4294967279@250,4294967287@251,4294967291@252,4294967293@253,4294967294@254}
  flag {!<=-1,256@246,128@247,64@248,32@249,16@250,8@251,4@252,2@253,1@254}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@136,4@137,0@138}
  t possible {10@136,4@137,0@138}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@136,4@137,0@138}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@136,0@138}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@136,0@138}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@136}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@136}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@136}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@136}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@136}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@144}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@146,17179869184@157,8589934592@159,34359738368@161,4294967296@163,2147483648@165,1073741824@167,536870912@169,268435456@171}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@233,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@234}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@145,17179869184@156,8589934592@158,34359738368@160,4294967296@162,2147483648@164,1073741824@166,536870912@168,268435456@170}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@145,17179869184@156,8589934592@158,34359738368@160,4294967296@162,2147483648@164,1073741824@166,536870912@168,268435456@170}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 52
  = {lifetime[Iterator]=(fileSettings),start=0}
  ( {lifetime[Iterator]=(fileSettings),start=0}
  it {lifetime[Iterator]=(fileSettings),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(fileSettings),end=0}
Line 53
  ignore always {!<=-1,!>=2}
  ignore always {!<=-1,!>=2}
  = always 0
  false always 0
Line 55
  it {lifetime[Iterator]=(fileSettings),start=0}
  ( always !<=-1
  > always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  it possible lifetime[Iterator]=(fileSettings)
  0 always 0
  ( {!<=-1,<=symbolic=(it->filename.size()-1),!>=symbolic=(it->filename.size())}
  == always {!<=-1,!>=2}
  0 always 0
Line 56
  ignore always {!<=-1,!>=2}
  = always 1
  true always 1
Line 59
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 60
  ignore always {!<=-1,!>=2}
  = always 1
  true always 1
Line 63
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 65
  ( always !<=-1
  > always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( {!<=-1,<=symbolic=(it->filename.size()-1),!>=symbolic=(it->filename.size())}
  == always {!<=-1,!>=2}
  0 always 0
Line 66
  ignore always {!<=-1,!>=2}
  = always 1
  true always 1
Line 71
  ignore {!<=-1,!>=2,1}
Line 80
  = {lifetime[Iterator]=(fileSettings),start=0}
  ( {lifetime[Iterator]=(fileSettings),start=0}
  it {lifetime[Iterator]=(fileSettings),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(fileSettings),end=0}
Line 81
  it {lifetime[Iterator]=(fileSettings),start=0}
  != always {!<=-1,!>=2}
Line 82
  it possible lifetime[Iterator]=(fileSettings)
Line 84
  it possible lifetime[Iterator]=(fileSettings)
Line 90
  defs possible {symbolic=(predefines+";"+sysdefines+";"+userdefines)@36,symbolic=(cppPredefines+";"+defines)@36,size=0@91}
  ( always !<=-1
  ";%(" always ";%("
  != always {!<=-1,!>=2}
Line 91
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  ";%(" always ";%("
Line 92
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  ';' always 59
  pos1 always !<=-1
  + always !<=0
  1 always 1
Line 93
  pos1 always !<=-1
  pos2 always !<=-1
  == always {!<=-1,!>=2}
  ? always !<=-1
  pos2 always !<=-1
  : always !<=-1
  pos2 always !<=-1
  - always !<=-1
  pos1 always !<=-1
Line 95
  ( always !<=-1
  ";;" always ";;"
  != always {!<=-1,!>=2}
Line 96
  ( always !<=-1
  ";;" always ";;"
  1 always 1
Line 97
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  defs always !size=0
  0 always 0
  == always {!<=-1,!>=2}
  ';' always 59
Line 98
  defs always !size=0
  0 always 0
  1 always 1
Line 99
  ! {!<=-1,!>=2,0}
  defs possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  defs always !size=0
  ';' always 59
Line 100
  defs always !size=0
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 101
  eq always {!<=-1,!>=2}
  eq always {!<=-1,!>=2}
  = always 0
  false always 0
Line 102
  pos always !<=-1
  = always 0
  0 always 0
  pos {!<=-1,<=symbolic=(defs.size()),>=symbolic=(defs.size()+1),0}
  < {!<=-1,!>=2,0}
  defs possible size=0
  ( {!<=-1,0}
  ++ {!<=0,<=symbolic=(defs.size()),>=symbolic=(defs.size()+1)}
  pos {!<=-1,<=symbolic=(defs.size()-1),>=symbolic=(defs.size())}
Line 103
  [ possible {61,59}
  pos always !<=-1
  == {!<=-1,!>=2,0}
  '(' always 40
  || {!<=-1,!>=2,0}
  [ possible 59
  pos always !<=-1
  == {!<=-1,!>=2,0}
  '=' always 61
Line 104
  eq always {!<=-1,!>=2}
  = always 1
  true always 1
Line 105
  [ always {!40,!61}
  pos always !<=-1
  == always {!<=-1,!>=2}
  ';' always 59
Line 106
  ! always {!<=-1,!>=2}
  eq always {!<=-1,!>=2}
Line 107
  ( possible lifetime[Iterator]=(defs)
  pos always !<=-1
  "=1" always "=1"
Line 108
  pos always !<=-1
  += always !<=-1
  3 always 3
Line 110
  pos always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 111
  eq always {!<=-1,!>=2}
  = always 0
  false always 0
Line 114
  ! {!<=-1,!>=2,1}
  eq {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 115
  defs always !size=0
  "=1" always "=1"
Line 119
  ( always {!<=-1,!>=2}
Line 122
  :: always !<=-1
  start always !<=-1
  start always !<=-1
  = always 0
  0 always 0
Line 123
  start always !<=-1
  = always !<=-1
  ( always !<=-1
  "$(" always "$("
  != always {!<=-1,!>=2}
Line 124
  end always !<=-1
  = always !<=-1
  ( always !<=-1
  ')' always 41
  start always !<=-1
Line 125
  end always !<=-1
  == always {!<=-1,!>=2}
Line 127
  start always !<=-1
  + always !<=1
  2 always 2
  end always !<=-1
  - always !<=-1
  start always !<=-1
  - always !<=-1
  2 always 2
Line 128
  ( possible lifetime[Iterator]=(expanded)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(expanded),end=0}
Line 131
  = possible lifetime[Iterator]=(variables)
  ( possible lifetime[Iterator]=(variables)
Line 133
  it1 {lifetime[Iterator]=(variables),symbolic=(variables.find(var))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(variables),end=0}
Line 134
  ( {lifetime[Object]=(var),!0}
Line 135
  ! always {!<=-1,!>=2}
Line 139
  envValue always !0
Line 140
  = possible lifetime[Iterator]=(variables)
  ( possible lifetime[Iterator]=(variables)
Line 142
  0 always 0
  start always !<=-1
  it1 possible {lifetime[Iterator]=(variables),lifetime[Iterator]=(variables),symbolic=(variables.find(var))}
  end always !<=-1
  + always !<=0
  1 always 1
Line 144
  ( always !<=-1
  "$(" always "$("
  != always {!<=-1,!>=2}
Line 145
  return always {!<=-1,!>=2}
  false always 0
Line 147
  return always {!<=-1,!>=2}
  true always 1
Line 157
  ( always {!<=-1,!>=2}
Line 159
  ipath always !size=0
  0 always 0
  2 always 2
  "%(" always "%("
  == always {!<=-1,!>=2}
  0 always 0
Line 162
  ! always {!<=-1,!>=2}
Line 164
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
  || always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  1U always 1
  && always {!<=-1,!>=2}
  s {>=size=2,!<=size=1}
  1 always 1
  2 always 2
  ":/" always ":/"
  == always {!<=-1,!>=2}
  0 always 0
Line 165
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '/' always 47
Line 166
  '/' always 47
Line 171
  ( always {!<=-1,!>=2}
  '/' always 47
Line 172
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 174
  ( always !<=-1
  "$(" always "$("
  == always {!<=-1,!>=2}
Line 177
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 182
  s always !size=0
  '/' always 47
Line 189
  ! always {!<=-1,!>=2}
Line 190
  :: always 1
  MISSING always 1
Line 193
  ! {!<=-1,!>=2,0}
  mPath possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  mPath always !size=0
  '/' always 47
Line 194
  '/' always 47
Line 197
  settings possible 0
  settings always !0
  ( always size=0
Line 199
  ( always {!<=-1,!>=2}
  ".json" always ".json"
Line 200
  ( always {!<=-1,!>=2}
Line 202
  :: always 3
  COMPILE_DB always 3
Line 204
  ( always {!<=-1,!>=2}
  ".sln" always ".sln"
Line 205
  ( always {!<=-1,!>=2}
Line 207
  :: always 4
  VS_SLN always 4
Line 209
  ( always {!<=-1,!>=2}
  ".vcxproj" always ".vcxproj"
Line 211
  ( always {!<=-1,!>=2}
  variables always size=0
Line 213
  :: always 5
  VS_VCXPROJ always 5
Line 215
  ( always {!<=-1,!>=2}
  ".bpr" always ".bpr"
Line 216
  ( always {!<=-1,!>=2}
Line 218
  :: always 6
  BORLAND always 6
Line 220
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ".cppcheck" always ".cppcheck"
Line 221
  ( always {!<=-1,!>=2}
  settings always !0
Line 223
  :: always 7
  CPPCHECK_GUI always 7
Line 228
  :: always 2
  FAILURE always 2
Line 234
  escapedString always {!<=-1,!>=2}
  escapedString always {!<=-1,!>=2}
  = always 0
  false always 0
Line 235
  str always {!<=-1,!>=2}
  str always {!<=-1,!>=2}
  = always 0
  false always 0
Line 236
  escape always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 237
  * always !<=-1
  pos possible {lifetime[Address]=(pos)@83,lifetime[Address]=(pos)@84,lifetime[Address]=(pos)@89,lifetime[Address]=(pos)@90}
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  str always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  until possible {" ="@83," "@84," "@89," "@90}
  * {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
  pos possible {lifetime[Address]=(pos)@83,lifetime[Address]=(pos)@84,lifetime[Address]=(pos)@89,lifetime[Address]=(pos)@90}
  * always !<=-1
  pos possible {lifetime[Address]=(pos)@83,lifetime[Address]=(pos)@84,lifetime[Address]=(pos)@89,lifetime[Address]=(pos)@90}
  ++ always !<=-1
Line 238
  escape always {!<=-1,!>=2}
Line 239
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 240
  [ possible 34
  * always !<=-1
  pos possible {lifetime[Address]=(pos)@83,lifetime[Address]=(pos)@84,lifetime[Address]=(pos)@89,lifetime[Address]=(pos)@90}
  == {!<=-1,!>=2,0}
  '\\' always 92
Line 241
  str always {!<=-1,!>=2}
Line 242
  escape always {!<=-1,!>=2}
  = always 1
  true always 1
Line 243
  * always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  '"' always 34
Line 244
  escapedString always {!<=-1,!>=2}
Line 245
  "\\\"" always "\\\""
Line 246
  escapedString always {!<=-1,!>=2}
  = always 1
  true always 1
Line 247
  "\\\"" always "\\\""
Line 248
  * always !<=-1
  ++ always !<=-1
Line 251
  [ always !92
  * always !<=-1
  == always {!<=-1,!>=2}
  '\"' always 34
Line 252
  str always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  str always {!<=-1,!>=2}
Line 253
  [ possible 34
  * always !<=-1
  pos possible {lifetime[Address]=(pos)@83,lifetime[Address]=(pos)@84,lifetime[Address]=(pos)@89,lifetime[Address]=(pos)@90}
Line 261
  escape always {!<=-1,!>=2}
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 263
  escape {!<=-1,!>=2,0,1}
Line 264
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 265
  ! always {!<=-1,!>=2}
  "\\\"\'" always "\\\"\'"
Line 266
  "\\" always "\\"
Line 268
  == always {!<=-1,!>=2}
  '\\' always 92
Line 269
  escape always {!<=-1,!>=2}
  = always 1
  true always 1
Line 271
  c always !92
Line 281
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always 0
  0 always 0
Line 282
  != always {!<=-1,!>=2}
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  ' ' always 32
  pos {!<=-1,0}
Line 283
  pos {!<=-1,>=symbolic=(command.size()),<=symbolic=(command.size()-1)}
  < always {!<=-1,!>=2}
  ( {!<=-1,<=symbolic=(pos),>=symbolic=(pos+1)}
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
  == always {!<=-1,!>=2}
  ' ' always 32
Line 284
  pos {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
  ++ {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
Line 285
  pos {!<=-1,>=symbolic=(command.size()-1),<=symbolic=(command.size()-2)}
  >= {!<=-1,!>=2,1}
  ( {!<=-1,<=symbolic=(pos)}
Line 287
  [ possible 45
  pos {!<=-1,>=symbolic=(command.size()-1),<=symbolic=(command.size()-2),!>=symbolic=(command.size())}
  != {!<=-1,!>=2,1}
  '/' always 47
  && always {!<=-1,!>=2}
  pos always {!<=-1,!>=symbolic=(command.size())}
  != always {!<=-1,!>=2}
  '-' always 45
Line 289
  pos {!<=-1,>=symbolic=(command.size()-1),<=symbolic=(command.size()-2),!>=symbolic=(command.size())}
  ++ {!<=-1,>=symbolic=(command.size()-1),<=symbolic=(command.size()-2),!>=symbolic=(command.size())}
Line 290
  pos always {!<=-1,!>=symbolic=(command.size()+1)}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 292
  pos {!<=-1,!>=symbolic=(command.size()),<=symbolic=(command.size()-1)}
  ++ {!<=-1,!>=symbolic=(command.size()),<=symbolic=(command.size()-1)}
Line 293
  "DUI" always "DUI"
  F possible {68,85,73,115,105,109,102}
Line 294
  pos always !<=-1
  < always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  pos {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
  == always {!<=-1,!>=2}
  ' ' always 32
Line 295
  ++ {!<=0,<=symbolic=(command.size()),!>=symbolic=(command.size()+1)}
  pos {!<=-1,<=symbolic=(command.size()-1),!>=symbolic=(command.size())}
Line 297
  & {lifetime[Address]=(pos),!0}
  pos {!<=-1,>=symbolic=(command.size())}
  " =" always " ="
Line 298
  F possible {85,73,115,105,109,102}
  == {!<=-1,!>=2,0}
  'D' always 68
Line 299
  & {lifetime[Address]=(pos),!0}
  pos always !<=-1
  " " always " "
Line 301
  defval possible {>=size=5,<=size=4}
  ( {!<=-1,>=5,<=4}
  >= {!<=-1,!>=2,>=1}
  3 always 3
  && always {!<=-1,!>=2}
  defval {>=size=5,<=size=4,>=size=3,!<=size=2}
  0 always 0
  2 always 2
  "=\"" always "=\""
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '\"' always 34
Line 302
  "=" always "="
  2 always 2
  ( {>=3,!<=2}
  - {!<=-1,>=0}
  3 always 3
Line 303
  ( {!<=-1,<=2}
  >= {!<=-1,!>=2,<=0}
  5 always 5
  && always {!<=-1,!>=2}
  defval {>=size=5,!<=size=4}
  0 always 0
  3 always 3
  "=\\\"" always "=\\\""
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "\\\"" always "\\\""
Line 304
  "=\"" always "=\""
  3 always 3
  ( {>=5,!<=4}
  - {!<=-1,>=0}
  5 always 5
  "\"" always "\""
Line 305
  ! {!<=-1,!>=2,0}
  defval possible size=0
  ( {!<=-1,!>=2,1}
Line 306
  defval always !size=0
Line 307
  ';' always 59
Line 308
  F {73,115,105,109,102,!68}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 310
  F {115,105,109,102,!68,!85}
  == {!<=-1,!>=2,0}
  'I' always 73
Line 312
  i always symbolic=(fval)
  ( always !<=-1
  > always {!<=-1,!>=2}
  1 always 1
  && always {!<=-1,!>=2}
  i {symbolic=(fval),>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '\"' always 34
  && always {!<=-1,!>=2}
  i {symbolic=(fval),>=size=2,!<=size=1}
  == always {!<=-1,!>=2}
  '\"' always 34
Line 313
  i {symbolic=(fval),>=size=2,!<=size=1}
  1 always 1
  i {symbolic=(fval),>=size=2,!<=size=1}
  ( {>=2,!<=1}
  - {!<=-1,>=0}
  2 always 2
Line 314
  ( possible lifetime[Iterator]=(includePaths)
  ( {lifetime[Iterator]=(includePaths),start=0}
  ( {lifetime[Iterator]=(includePaths),end=0}
  i possible symbolic=(fval)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(includePaths),end=0}
Line 316
  F {105,109,102,!68,!85,!73}
  == {!<=-1,!>=2,0}
  's' always 115
  && always {!<=-1,!>=2}
  0 always 0
  2 always 2
  "td" always "td"
  == always {!<=-1,!>=2}
  0 always 0
Line 317
  ++ always !<=0
  pos always !<=-1
Line 318
  & {lifetime[Address]=(pos),!0}
  pos always !<=-1
  " " always " "
Line 321
  0 always 0
  3 always 3
  "c++" always "c++"
  || always {!<=-1,!>=2}
  0 always 0
  5 always 5
  "gnu++" always "gnu++"
Line 323
  ( always {!<=-1,!>=2}
Line 328
  "__cplusplus=" always "__cplusplus="
Line 329
  stddef always !size=0
Line 330
  ";" always ";"
Line 331
  0 always 0
  1 always 1
  "c" always "c"
  || always {!<=-1,!>=2}
  0 always 0
  3 always 3
  "gnu" always "gnu"
Line 333
  ( always {!<=-1,!>=2}
Line 338
  "__STDC_VERSION__=" always "__STDC_VERSION__="
Line 339
  stddef always !size=0
Line 340
  ";" always ";"
Line 342
  F {109,102,!68,!85,!73}
  == {!<=-1,!>=2,0}
  'i' always 105
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "system" always "system"
Line 343
  ++ always !<=0
  pos always !<=-1
Line 344
  & {lifetime[Address]=(pos),!0}
  pos always !<=-1
  " " always " "
Line 346
  F {102,!68,!85,!73}
  == {!<=-1,!>=2,0}
  'm' always 109
Line 347
  == always {!<=-1,!>=2}
  "unicode" always "unicode"
Line 348
  "UNICODE" always "UNICODE"
Line 349
  defs always !<=size=6
  ";" always ";"
Line 351
  F always {!68,!85,!73,!109}
  == always {!<=-1,!>=2}
  'f' always 102
Line 352
  fval possible size=3
  == always {!<=-1,!>=2}
  "pic" always "pic"
Line 353
  "__pic__" always "__pic__"
Line 354
  defs always !<=size=6
  ";" always ";"
Line 355
  fval possible size=3
  == always {!<=-1,!>=2}
  "PIC" always "PIC"
Line 356
  "__PIC__" always "__PIC__"
Line 357
  defs always !<=size=6
  ";" always ";"
Line 358
  fval possible size=3
  == always {!<=-1,!>=2}
  "pie" always "pie"
Line 359
  "__pie__" always "__pie__"
Line 360
  defs always !<=size=6
  ";" always ";"
Line 361
  == always {!<=-1,!>=2}
  "PIE" always "PIE"
Line 362
  "__PIE__" always "__PIE__"
Line 363
  defs always !<=size=6
  ";" always ";"
Line 367
  defs possible size=0
Line 370
  ( always {!<=-1,!>=2}
Line 374
  ! always {!<=-1,!>=2}
Line 375
  "compilation database is not a JSON array" always "compilation database is not a JSON array"
Line 376
  return always {!<=-1,!>=2}
  false always 0
Line 381
  obj always symbolic=(fileInfo.get<picojson::object>())
  "directory" always "directory"
Line 385
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '/' always 47
Line 386
  '/' always 47
Line 391
  "arguments" always "arguments"
Line 392
  "arguments" always "arguments"
Line 393
  "arguments" always "arguments"
Line 396
  str always symbolic=(arg.get<std::string>())
  ( always !<=-1
  " " always " "
  != always {!<=-1,!>=2}
Line 397
  "\"" always "\""
  str always symbolic=(arg.get<std::string>())
  "\"" always "\""
Line 398
  str possible symbolic=(arg.get<std::string>())
  " " always " "
Line 402
  "'arguments' field in compilation database entry is not a JSON array" always "'arguments' field in compilation database entry is not a JSON array"
Line 403
  return always {!<=-1,!>=2}
  false always 0
Line 405
  "command" always "command"
Line 406
  "command" always "command"
Line 407
  "command" always "command"
Line 409
  "'command' field in compilation database entry is not a string" always "'command' field in compilation database entry is not a string"
Line 410
  return always {!<=-1,!>=2}
  false always 0
Line 413
  "no 'arguments' or 'command' field found in compilation database entry" always "no 'arguments' or 'command' field found in compilation database entry"
Line 414
  return always {!<=-1,!>=2}
  false always 0
Line 417
  ! always {!<=-1,!>=2}
  "file" always "file"
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  "file" always "file"
Line 418
  "skip compilation database entry because it does not have a proper 'file' field" always "skip compilation database entry because it does not have a proper 'file' field"
Line 422
  "file" always "file"
Line 425
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 429
  ( always {!<=-1,!>=2}
Line 440
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 441
  "'" always "'"
  "' from compilation database does not exist" always "' from compilation database does not exist"
Line 442
  return always {!<=-1,!>=2}
  false always 0
Line 446
  variables always size=0
Line 450
  return always {!<=-1,!>=2}
  true always 1
Line 453
  ( always {!<=-1,!>=2}
Line 457
  ! always {!<=-1,!>=2}
  line always size=0
Line 458
  "Visual Studio solution file is empty" always "Visual Studio solution file is empty"
Line 459
  return always {!<=-1,!>=2}
  false always 0
Line 462
  ( always !<=-1
  "Microsoft Visual Studio Solution File" always "Microsoft Visual Studio Solution File"
  != always {!<=-1,!>=2}
  0 always 0
Line 464
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !<=-1
  "Microsoft Visual Studio Solution File" always "Microsoft Visual Studio Solution File"
  != always {!<=-1,!>=2}
  0 always 0
Line 465
  "Visual Studio solution file header not found" always "Visual Studio solution file header not found"
Line 466
  return always {!<=-1,!>=2}
  false always 0
Line 471
  variables always size=0
  "SolutionDir" always "SolutionDir"
Line 473
  found always {!<=-1,!>=2}
  found always {!<=-1,!>=2}
  = always 0
  false always 0
Line 476
  0 always 0
  8 always 8
  "Project(" always "Project("
  != always {!<=-1,!>=2}
  0 always 0
Line 478
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  ".vcxproj" always ".vcxproj"
Line 479
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 481
  pos1 always !<=-1
  = always !<=-1
  ( always !<=-1
  '\"' always 34
  pos always !<=-1
Line 482
  pos1 always !<=-1
  == always {!<=-1,!>=2}
Line 484
  pos1 always !<=-1
  + always !<=0
  1 always 1
  pos always !<=-1
  - always !<=-1
  pos1 always !<=-1
  + always !<=6
  7 always 7
Line 485
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 487
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 488
  "failed to load '" always "failed to load '"
  "' from Visual Studio solution" always "' from Visual Studio solution"
Line 489
  return always {!<=-1,!>=2}
  false always 0
Line 491
  found always {!<=-1,!>=2}
  = always 1
  true always 1
Line 494
  ! {!<=-1,!>=2,1}
  found {!<=-1,!>=2,0}
Line 495
  "no projects found in Visual Studio solution file" always "no projects found in Visual Studio solution file"
Line 496
  return always {!<=-1,!>=2}
  false always 0
Line 499
  return always {!<=-1,!>=2}
  true always 1
Line 504
  Unknown always 2
Line 505
  "Include" always "Include"
Line 507
  = always !0
  a always !0
Line 509
  ! always {!<=-1,!>=2}
Line 511
  "Configuration" always "Configuration"
  == always {!<=-1,!>=2}
  0 always 0
Line 513
  "Platform" always "Platform"
  == always {!<=-1,!>=2}
  0 always 0
Line 515
  platformStr possible size=3
  == {!<=-1,!>=2,0}
  "Win32" always "Win32"
Line 516
  = always 0
  Win32 always 0
Line 517
  == always {!<=-1,!>=2}
  "x64" always "x64"
Line 518
  = always 1
  x64 always 1
Line 520
  = always 2
  Unknown always 2
Line 526
  Win32 always 0
  x64 always 1
  Unknown always 2
Line 532
  "Condition" always "Condition"
Line 534
  = always !0
  condAttr always !0
Line 536
  "ClCompile" always "ClCompile"
  != always {!<=-1,!>=2}
  0 always 0
Line 538
  = always "StreamingSIMDExtensions2"
  "StreamingSIMDExtensions2" always "StreamingSIMDExtensions2"
Line 541
  "PreprocessorDefinitions" always "PreprocessorDefinitions"
  == always {!<=-1,!>=2}
  0 always 0
Line 543
  "AdditionalIncludeDirectories" always "AdditionalIncludeDirectories"
  == always {!<=-1,!>=2}
  0 always 0
Line 544
  ! {!<=-1,!>=2,0}
  additionalIncludePaths possible size=0
  ( {!<=-1,!>=2,1}
Line 545
  ';' always 59
Line 547
  "LanguageStandard" always "LanguageStandard"
  == always {!<=-1,!>=2}
  0 always 0
Line 548
  "stdcpp14" always "stdcpp14"
  == always {!<=-1,!>=2}
  0 always 0
Line 549
  = always 2
  :: always 2
  CPP14 always 2
Line 550
  "stdcpp17" always "stdcpp17"
  == always {!<=-1,!>=2}
  0 always 0
Line 551
  = always 3
  :: always 3
  CPP17 always 3
Line 552
  "stdcpp20" always "stdcpp20"
  == always {!<=-1,!>=2}
  0 always 0
Line 553
  = always 4
  :: always 4
  CPP20 always 4
Line 554
  "stdcpplatest" always "stdcpplatest"
  == always {!<=-1,!>=2}
  0 always 0
Line 555
  = always 5
  :: always 5
  CPPLatest always 5
Line 556
  "EnableEnhancedInstructionSet" always "EnableEnhancedInstructionSet"
  == always {!<=-1,!>=2}
  0 always 0
Line 565
  :: always !<=-1
  pos always !<=-1
Line 566
  pos always !<=-1
  = always !<=-1
  c {lifetime[Object]=(to),symbolic=('('+condition+");")@50}
  ( always !<=-1
  from inconclusive {"$(Configuration)"@50,"$(Platform)"@51}
  != always {!<=-1,!>=2}
Line 567
  c possible lifetime[Object]=(to)
  pos always !<=-1
  from inconclusive "$(Platform)"@51
  ( always !<=-1
Line 568
  c possible lifetime[Object]=(to)
  ( possible lifetime[Iterator]=(c)
  pos always !<=-1
Line 572
  ( always {!<=-1,!>=2}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  true always 1
Line 575
  '(' always 40
  condition always !size=0
  ");" always ");"
Line 576
  c always symbolic=('('+condition+");")
  "$(Configuration)" always "$(Configuration)"
Line 577
  "$(Platform)" always "$(Platform)"
Line 582
  & {lifetime[Address]=(s),!0}
  nullptr always 0
Line 583
  ( always {!<=-1,!>=2}
  "vcxproj" always "vcxproj"
Line 585
  ( possible size=2
  == {!<=-1,!>=2,0}
  "(" always "("
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 586
  ( always !0
  == always {!<=-1,!>=2}
  "Configuration.Contains" always "Configuration.Contains"
Line 587
  return always {!<=-1,!>=2}
  '\'' always 39
  '\'' always 39
  == always {!<=-1,!>=2}
  ( always !0
Line 589
  ( possible size=1
  == {!<=-1,!>=2,0}
  "==" always "=="
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  ( always !0
Line 590
  return always {!<=-1,!>=2}
  true always 1
Line 592
  return always {!<=-1,!>=2}
  false always 0
Line 598
  = always 5
  :: always 5
  CPPLatest always 5
Line 605
  :: always !<=-1
  pos1 always !<=-1
  pos1 always !<=-1
  = always 0
  0 always 0
Line 606
  :: always !<=-1
  pos2 always !<=-1
Line 607
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  ';' always 59
  pos1 {symbolic=(pos2+1),!<=-1,<=symbolic=(s.size()-1),0}
  != always {!<=-1,!>=2}
Line 608
  pos1 always !<=-1
  pos2 {!<=-1,>=symbolic=(s.size()-1),<=symbolic=(s.size()-2)}
  - always !<=-1
  pos1 always !<=-1
Line 609
  pos1 always !<=-1
  = always !<=0
  pos2 always !<=-1
  + always !<=0
  1 always 1
Line 610
  pos1 {symbolic=(pos2+1),!<=0}
  >= always {!<=-1,!>=2}
  ( always !<=-1
Line 613
  pos1 {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 614
  pos1 {!<=-1,<=symbolic=(s.size()-1),!>=symbolic=(s.size())}
Line 620
  useOfMfc possible {lifetime[Address]=(useOfMfc)@40,0@49}
Line 622
  "UseOfMfc" always "UseOfMfc"
  == always {!<=-1,!>=2}
  0 always 0
Line 623
  * always {!<=-1,!>=2}
  useOfMfc {!0,lifetime[Address]=(useOfMfc)@40}
  = always 1
  true always 1
Line 629
  "Label" always "Label"
Line 630
  labelAttribute possible 0
  && always {!<=-1,!>=2}
  labelAttribute always !0
  "UserMacros" always "UserMacros"
  == always {!<=-1,!>=2}
  0 always 0
Line 634
  variables possible lifetime[Address]=(variables)@40
  ? possible {"",1}
  text always !0
  : always {1,""}
  "" always ""
Line 637
  ! {!<=-1,!>=2,1}
  labelAttribute possible 0
Line 639
  "IncludePath" always "IncludePath"
  != always {!<=-1,!>=2}
  0 always 0
Line 642
  ! always {!<=-1,!>=2}
Line 644
  text always !0
Line 645
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "$(IncludePath)" always "$(IncludePath)"
Line 646
  pos always !<=-1
  != always {!<=-1,!>=2}
Line 647
  0 always 0
  pos always !<=-1
  pos always !<=-1
  + always !<=13
  14U always 14
Line 657
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  variables possible lifetime[Address]=(variables)@41
Line 661
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  "ProjectDir" always "ProjectDir"
  > always {!<=-1,!>=2}
  0 always 0
Line 662
  "ProjectDir" always "ProjectDir"
Line 665
  ( {lifetime[Object]=(filename),!0}
  != always {!<=-1,!>=2}
Line 668
  == always {!<=-1,!>=2}
  nullptr always 0
Line 670
  rootnode always !0
Line 671
  "ImportGroup" always "ImportGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 672
  "Label" always "Label"
Line 673
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  labelAttribute always !0
  "PropertySheets" always "PropertySheets"
  != always {!<=-1,!>=2}
  0 always 0
Line 676
  "Import" always "Import"
  == always {!<=-1,!>=2}
  0 always 0
Line 677
  "Project" always "Project"
Line 678
  == always {!<=-1,!>=2}
  nullptr always 0
Line 680
  projectAttribute always !0
Line 681
  ( always !<=-1
  '$' always 36
  == always {!<=-1,!>=2}
Line 687
  "PropertyGroup" always "PropertyGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 688
  nullptr always 0
Line 689
  "ItemDefinitionGroup" always "ItemDefinitionGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 695
  ( always {!<=-1,!>=2}
Line 697
  variables possible size=0@100
  "ProjectDir" always "ProjectDir"
Line 704
  useOfMfc always {!<=-1,!>=2}
  useOfMfc always {!<=-1,!>=2}
  = always 0
  false always 0
Line 707
  ( {lifetime[Object]=(filename),!0}
Line 708
  != always {!<=-1,!>=2}
Line 709
  "Visual Studio project file is not a valid XML - " always "Visual Studio project file is not a valid XML - "
Line 710
  return always {!<=-1,!>=2}
  false always 0
Line 713
  == always {!<=-1,!>=2}
  nullptr always 0
Line 714
  "Visual Studio project file has no XML root node" always "Visual Studio project file has no XML root node"
Line 715
  return always {!<=-1,!>=2}
  false always 0
Line 717
  rootnode always !0
Line 718
  "ItemGroup" always "ItemGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 719
  "Label" always "Label"
Line 720
  && always {!<=-1,!>=2}
  labelAttribute always !0
  "ProjectConfigurations" always "ProjectConfigurations"
  == always {!<=-1,!>=2}
  0 always 0
Line 722
  "ProjectConfiguration" always "ProjectConfiguration"
  == always {!<=-1,!>=2}
  0 always 0
Line 724
  != always {!<=-1,!>=2}
  :: always 2
  Unknown always 2
Line 732
  "ClCompile" always "ClCompile"
  == always {!<=-1,!>=2}
  0 always 0
Line 733
  "Include" always "Include"
Line 734
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  include always !0
Line 735
  include always !0
Line 739
  "ItemDefinitionGroup" always "ItemDefinitionGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 741
  "PropertyGroup" always "PropertyGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 742
  & {lifetime[Address]=(variables),!0}
  & {lifetime[Address]=(includePath),!0}
  & {lifetime[Address]=(useOfMfc),!0}
  useOfMfc always {!<=-1,!>=2}
Line 743
  "ImportGroup" always "ImportGroup"
  == always {!<=-1,!>=2}
  0 always 0
Line 744
  "Label" always "Label"
Line 745
  && always {!<=-1,!>=2}
  labelAttribute always !0
  "PropertySheets" always "PropertySheets"
  == always {!<=-1,!>=2}
  0 always 0
Line 747
  "Import" always "Import"
  == always {!<=-1,!>=2}
  0 always 0
Line 748
  "Project" always "Project"
Line 750
  projectAttribute always !0
  & {lifetime[Address]=(variables),!0}
  & {lifetime[Address]=(includePath),!0}
Line 758
  ( always {!<=-1,!>=2}
Line 759
  ! {!<=-1,!>=2,0}
  fileFilters possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fileFilters always !size=0
Line 764
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 765
  doChecking always {!<=-1,!>=2}
  doChecking always {!<=-1,!>=2}
  = always 0
  false always 0
Line 766
  config possible symbolic=(p.configuration)
  : possible symbolic=(p.configuration)
  . always !size=0
Line 767
  == always {!<=-1,!>=2}
Line 768
  doChecking always {!<=-1,!>=2}
  = always 1
  true always 1
Line 771
  ! {!<=-1,!>=2,0}
  doChecking {!<=-1,!>=2,1}
Line 778
  . always {!<=-1,!>=2}
  msc always {!<=-1,!>=2}
  = always 1
  true always 1
Line 779
  . always {!<=-1,!>=2}
  useMfc always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  useOfMfc always {!<=-1,!>=2}
Line 780
  = always "_WIN32=1"
  "_WIN32=1" always "_WIN32=1"
Line 781
  . possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  Win32 always 0
Line 782
  = always 3
  :: always 3
  Win32W always 3
Line 783
  . always !0
  == always {!<=-1,!>=2}
  :: always 1
  x64 always 1
Line 784
  = always 4
  :: always 4
  Win64 always 4
Line 785
  ";_WIN64=1" always ";_WIN64=1"
Line 789
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 792
  ';' always 59
Line 793
  . possible {size=24,size=25,size=27}
  == {!<=-1,!>=2,0}
  "StreamingSIMDExtensions" always "StreamingSIMDExtensions"
Line 794
  ";__SSE__" always ";__SSE__"
Line 795
  . possible {size=24,size=25,size=27}
  == {!<=-1,!>=2,0}
  "StreamingSIMDExtensions2" always "StreamingSIMDExtensions2"
Line 796
  ";__SSE2__" always ";__SSE2__"
Line 797
  . possible {size=25,size=27}
  == {!<=-1,!>=2,0}
  "AdvancedVectorExtensions" always "AdvancedVectorExtensions"
Line 798
  ";__AVX__" always ";__AVX__"
Line 799
  . possible size=27
  == {!<=-1,!>=2,0}
  "AdvancedVectorExtensions2" always "AdvancedVectorExtensions2"
Line 800
  ";__AVX2__" always ";__AVX2__"
Line 801
  == always {!<=-1,!>=2}
  "AdvancedVectorExtensions512" always "AdvancedVectorExtensions512"
Line 802
  ";__AVX512__" always ";__AVX512__"
Line 803
  ';' always 59
Line 806
  ';' always 59
Line 811
  return always {!<=-1,!>=2}
  true always 1
Line 814
  ( always {!<=-1,!>=2}
Line 817
  ( {lifetime[Object]=(projectFilename),!0}
Line 818
  != always {!<=-1,!>=2}
Line 819
  "Borland project file is not a valid XML - " always "Borland project file is not a valid XML - "
Line 820
  return always {!<=-1,!>=2}
  false always 0
Line 823
  == always {!<=-1,!>=2}
  nullptr always 0
Line 824
  "Borland project file has no XML root node" always "Borland project file has no XML root node"
Line 825
  return always {!<=-1,!>=2}
  false always 0
Line 836
  rootnode always !0
Line 837
  "FILELIST" always "FILELIST"
  == always {!<=-1,!>=2}
  0 always 0
Line 839
  "FILE" always "FILE"
  == always {!<=-1,!>=2}
  0 always 0
Line 840
  "FILENAME" always "FILENAME"
Line 841
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  filename always !0
Line 842
  filename always !0
Line 845
  "MACROS" always "MACROS"
  == always {!<=-1,!>=2}
  0 always 0
Line 847
  "INCLUDEPATH" always "INCLUDEPATH"
  == always {!<=-1,!>=2}
  0 always 0
Line 848
  "value" always "value"
Line 850
  = always !0
  v always !0
Line 851
  "USERDEFINES" always "USERDEFINES"
  == always {!<=-1,!>=2}
  0 always 0
Line 852
  "value" always "value"
Line 854
  = always !0
  v always !0
Line 855
  "SYSDEFINES" always "SYSDEFINES"
  == always {!<=-1,!>=2}
  0 always 0
Line 856
  "value" always "value"
Line 858
  = always !0
  v always !0
Line 861
  "OPTIONS" always "OPTIONS"
  == always {!<=-1,!>=2}
  0 always 0
Line 863
  "CFLAG1" always "CFLAG1"
  == always {!<=-1,!>=2}
  0 always 0
Line 864
  "value" always "value"
Line 866
  = always !0
  v always !0
Line 878
  cflag1 possible size=0
Line 879
  == always {!<=-1,!>=2}
  ' ' always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 880
  arg always !size=0
Line 881
  arg always NonMovedVariable
Line 887
  ! {!<=-1,!>=2,0}
  arg possible size=0
  ( {!<=-1,!>=2,1}
Line 888
  arg always !size=0
Line 895
  "-tC" always "-tC"
  "-WC" always "-WC"
Line 896
  "-tCDR" always "-tCDR"
  "-WCDR" always "-WCDR"
Line 897
  "-tCDV" always "-tCDV"
  "-WCDV" always "-WCDV"
Line 898
  "-tW" always "-tW"
  "-W" always "-W"
Line 899
  "-tWC" always "-tWC"
  "-WC" always "-WC"
Line 900
  "-tWCDR" always "-tWCDR"
  "-WCDR" always "-WCDR"
Line 901
  "-tWCDV" always "-tWCDV"
  "-WCDV" always "-WCDV"
Line 902
  "-tWD" always "-tWD"
  "-WD" always "-WD"
Line 903
  "-tWDR" always "-tWDR"
  "-WDR" always "-WDR"
Line 904
  "-tWDV" always "-tWDV"
  "-WDV" always "-WDV"
Line 905
  "-tWM" always "-tWM"
  "-WM" always "-WM"
Line 906
  "-tWP" always "-tWP"
  "-WP" always "-WP"
Line 907
  "-tWR" always "-tWR"
  "-WR" always "-WR"
Line 908
  "-tWU" always "-tWU"
  "-WU" always "-WU"
Line 909
  "-tWV" always "-tWV"
  "-WV" always "-WV"
Line 912
  = {lifetime[Iterator]=(synonyms),start=0,size=15}
  synonyms always {{,size=15}
  ( {lifetime[Iterator]=(synonyms),start=0,size=15}
  i {lifetime[Iterator]=(synonyms),start=0,size=15}
  != always {!<=-1,!>=2}
  synonyms always {{,size=15}
  ( {lifetime[Iterator]=(synonyms),end=0,size=15}
Line 913
  i {lifetime[Iterator]=(synonyms),size=15}
  > always {!<=-1,!>=2}
  0 always 0
Line 924
  cppPredefines always size=0
Line 928
  ";__BCPLUSPLUS__=0x0560;__cplusplus=1;__TEMPLATES__=1;_WCHAR_T;_WCHAR_T_DEFINED;__BCOPT__=1;__BORLANDC__=0x0560;__TCPLUSPLUS__=0x0560;__TURBOC__=0x0560" always ";__BCPLUSPLUS__=0x0560;__cplusplus=1;__TEMPLATES__=1;_WCHAR_T;_WCHAR_T_DEFINED;__BCOPT__=1;__BORLANDC__=0x0560;__TCPLUSPLUS__=0x0560;__TURBOC__=0x0560"
Line 953
  useCdecl always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-p" always "-p"
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 954
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-pm" always "-pm"
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-p")),end=0}
Line 955
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-pr" always "-pr"
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-p")),symbolic=(cflags.find("-pm")),end=0}
Line 956
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-ps" always "-ps"
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-pm")),symbolic=(cflags.find("-pr")),end=0}
Line 957
  useCdecl {symbolic=(cflags.find("-p")==cflags.end()&&cflags.find("-pm")==cflags.end()&&cflags.find("-pr")==cflags.end()&&cflags.find("-ps")==cflags.end()),!<=-1,!>=2}
Line 958
  predefines always size=0
  ";__CDECL=1" always ";__CDECL=1"
Line 961
  treatCharAsUnsignedChar always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-K" always "-K"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 962
  treatCharAsUnsignedChar {symbolic=(cflags.find("-K")!=cflags.end()),!<=-1,!>=2}
Line 963
  ";_CHAR_UNSIGNED=1" always ";_CHAR_UNSIGNED=1"
Line 966
  codeguardUsed always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-vGd" always "-vGd"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 967
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-vGt" always "-vGt"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-vGd")),end=0}
Line 968
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-vGc" always "-vGc"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-vGd")),symbolic=(cflags.find("-vGt")),end=0}
Line 969
  codeguardUsed {symbolic=(cflags.find("-vGd")!=cflags.end()||cflags.find("-vGt")!=cflags.end()||cflags.find("-vGc")!=cflags.end()),!<=-1,!>=2}
Line 970
  ";__CODEGUARD__" always ";__CODEGUARD__"
Line 973
  isConsoleApp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WC" always "-WC"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 974
  isConsoleApp {symbolic=(cflags.find("-WC")!=cflags.end()),!<=-1,!>=2,0}
Line 975
  ";__CONSOLE__=1" always ";__CONSOLE__=1"
Line 978
  enableStackUnwinding always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-xd-" always "-xd-"
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 979
  enableStackUnwinding {symbolic=(cflags.find("-xd-")==cflags.end()),!<=-1,!>=2}
Line 980
  ";_CPPUNWIND=1" always ";_CPPUNWIND=1"
Line 983
  isDLL always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WD" always "-WD"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 984
  isDLL {symbolic=(cflags.find("-WD")!=cflags.end()),!<=-1,!>=2,0}
Line 985
  ";__DLL__=1" always ";__DLL__=1"
Line 989
  ";__FLAT__=1" always ";__FLAT__=1"
Line 992
  ( possible lifetime[Iterator]=(cflags)
  "-6" always "-6"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 993
  predefines always !<=size=10
  ";_M_IX86=600" always ";_M_IX86=600"
Line 994
  ( possible lifetime[Iterator]=(cflags)
  "-5" always "-5"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-4")),symbolic=(cflags.find("-6")),end=0}
Line 995
  predefines always !<=size=10
  ";_M_IX86=500" always ";_M_IX86=500"
Line 996
  ( possible lifetime[Iterator]=(cflags)
  "-4" always "-4"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),end=0}
Line 997
  predefines always !<=size=10
  ";_M_IX86=400" always ";_M_IX86=400"
Line 999
  predefines always !<=size=10
  ";_M_IX86=300" always ";_M_IX86=300"
Line 1002
  linkMtLib always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WM" always "-WM"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-6")),symbolic=(cflags.find("-5")),symbolic=(cflags.find("-4")),end=0}
Line 1003
  linkMtLib {symbolic=(cflags.find("-WM")!=cflags.end()),!<=-1,!>=2,0}
Line 1004
  ";__MT__=1" always ";__MT__=1"
Line 1007
  usePascalCallingConvention always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-p" always "-p"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),end=0}
Line 1008
  usePascalCallingConvention {symbolic=(cflags.find("-p")!=cflags.end()),!<=-1,!>=2}
Line 1009
  ";__PASCAL__=1" always ";__PASCAL__=1"
Line 1012
  useAnsiKeywordExtensions always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-A" always "-A"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),end=0}
Line 1013
  useAnsiKeywordExtensions {symbolic=(cflags.find("-A")!=cflags.end()),!<=-1,!>=2}
Line 1014
  ";__STDC__=1" always ";__STDC__=1"
Line 1017
  ";__TLC__=1" always ";__TLC__=1"
Line 1020
  isWindowsTarget always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WC" always "-WC"
  != {symbolic=(isConsoleApp),!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),end=0}
Line 1021
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WCDR" always "-WCDR"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WC")),end=0}
Line 1022
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WCDV" always "-WCDV"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WC")),symbolic=(cflags.find("-WCDR")),end=0}
Line 1023
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WD" always "-WD"
  != {symbolic=(isDLL),!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-WCDR")),symbolic=(cflags.find("-WCDV")),end=0}
Line 1024
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WDR" always "-WDR"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WCDV")),symbolic=(cflags.find("-WD")),end=0}
Line 1025
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WDV" always "-WDV"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WD")),symbolic=(cflags.find("-WDR")),end=0}
Line 1026
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WM" always "-WM"
  != {symbolic=(linkMtLib),!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-WDR")),symbolic=(cflags.find("-WDV")),end=0}
Line 1027
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WP" always "-WP"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WDV")),symbolic=(cflags.find("-WM")),end=0}
Line 1028
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WR" always "-WR"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.end()),symbolic=(cflags.find("-WM")),symbolic=(cflags.find("-WP")),end=0}
Line 1029
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WU" always "-WU"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-WP")),symbolic=(cflags.find("-WR")),end=0}
Line 1030
  || always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-WV" always "-WV"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),symbolic=(cflags.find("-WR")),symbolic=(cflags.find("-WU")),end=0}
Line 1031
  isWindowsTarget {symbolic=(cflags.find("-WC")!=cflags.end()||cflags.find("-WCDR")!=cflags.end()||cflags.find("-WCDV")!=cflags.end()||cflags.find("-WD")!=cflags.end()||cflags.find("-WDR")!=cflags.end()||cflags.find("-WDV")!=cflags.end()||cflags.find("-WM")!=cflags.end()||cflags.find("-WP")!=cflags.end()||cflags.find("-WR")!=cflags.end()||cflags.find("-WU")!=cflags.end()||cflags.find("-WV")!=cflags.end()),!<=-1,!>=2,0}
Line 1032
  predefines always !<=size=9
  ";_Windows" always ";_Windows"
Line 1041
  isConsoleOrGuiApp always {!<=-1,!>=2}
  = {symbolic=(cflags.find("-WC")!=cflags.end()||cflags.find("-WCDR")!=cflags.end()||cflags.find("-WCDV")!=cflags.end()||cflags.find("-WD")!=cflags.end()||cflags.find("-WDR")!=cflags.end()||cflags.find("-WDV")!=cflags.end()||cflags.find("-WM")!=cflags.end()||cflags.find("-WP")!=cflags.end()||cflags.find("-WR")!=cflags.end()||cflags.find("-WU")!=cflags.end()||cflags.find("-WV")!=cflags.end()),!<=-1,!>=2,1,0}
  isWindowsTarget {symbolic=(cflags.find("-WC")!=cflags.end()||cflags.find("-WCDR")!=cflags.end()||cflags.find("-WCDV")!=cflags.end()||cflags.find("-WD")!=cflags.end()||cflags.find("-WDR")!=cflags.end()||cflags.find("-WDV")!=cflags.end()||cflags.find("-WM")!=cflags.end()||cflags.find("-WP")!=cflags.end()||cflags.find("-WR")!=cflags.end()||cflags.find("-WU")!=cflags.end()||cflags.find("-WV")!=cflags.end()),!<=-1,!>=2,1,0}
Line 1042
  isConsoleOrGuiApp {symbolic=(isWindowsTarget),!<=-1,!>=2,1,0,symbolic=(cflags.find("-WC")!=cflags.end()||cflags.find("-WCDR")!=cflags.end()||cflags.find("-WCDV")!=cflags.end()||cflags.find("-WD")!=cflags.end()||cflags.find("-WDR")!=cflags.end()||cflags.find("-WDV")!=cflags.end()||cflags.find("-WM")!=cflags.end()||cflags.find("-WP")!=cflags.end()||cflags.find("-WR")!=cflags.end()||cflags.find("-WU")!=cflags.end()||cflags.find("-WV")!=cflags.end())}
Line 1043
  ";__WIN32__=1" always ";__WIN32__=1"
Line 1055
  ";" always ";"
  ";" always ";"
Line 1056
  cppPredefines always !<=size=149
  ";" always ";"
  defines always symbolic=(predefines+";"+sysdefines+";"+userdefines)
Line 1057
  forceCppMode always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(cflags)
  "-P" always "-P"
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(cflags),end=0}
Line 1069
  cppMode always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  forceCppMode {symbolic=(cflags.find("-P")!=cflags.end()),!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ".cpp" always ".cpp"
Line 1072
  cppMode always {!<=-1,!>=2}
  ? possible {symbolic=(predefines+";"+sysdefines+";"+userdefines),symbolic=(cppPredefines+";"+defines)}
  cppDefines always symbolic=(cppPredefines+";"+defines)
  : always {symbolic=(predefines+";"+sysdefines+";"+userdefines),symbolic=(cppPredefines+";"+defines)}
  defines always symbolic=(predefines+";"+sysdefines+";"+userdefines)
Line 1073
  ( always {!<=-1,!>=2}
Line 1077
  return always {!<=-1,!>=2}
  true always 1
Line 1082
  ! {!<=-1,!>=2,0}
  path1 possible {symbolic=(mPath)@16,symbolic=(path)@16,size=0}
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1083
  path1 always !size=0
Line 1091
  name inconclusive {"dir"@18,"define"@20,"undefine"@21,"dir"@22,"path"@23,"path"@24,"library"@25,"config"@27,"addon"@28,"tool"@29}
  != always {!<=-1,!>=2}
  0 always 0
Line 1093
  attribute inconclusive {"name"@18,"name"@20,0@21,"name"@22,"name"@23,"name"@24}
  attribute always !0
Line 1095
  attr always !0
Line 1104
  ret possible size=0
  ( {!<=-1,!>=2,1}
  "" always ""
  : always ""
Line 1116
  ( always {!<=-1,!>=2}
Line 1120
  ( {lifetime[Object]=(xmldata),!0}
  ( always !<=-1
Line 1121
  != always {!<=-1,!>=2}
Line 1122
  "Cppcheck GUI project file is not a valid XML - " always "Cppcheck GUI project file is not a valid XML - "
Line 1123
  return always {!<=-1,!>=2}
  false always 0
Line 1126
  == always {!<=-1,!>=2}
  nullptr always 0
  || always {!<=-1,!>=2}
  rootnode always !0
  :: always "project"
  ProjectElementName {"project",lifetime[Object]=(ProjectElementName)}
  != always {!<=-1,!>=2}
  0 always 0
Line 1127
  "Cppcheck GUI project file has no XML root node" always "Cppcheck GUI project file has no XML root node"
Line 1128
  return always {!<=-1,!>=2}
  false always 0
Line 1139
  rootnode always !0
Line 1140
  :: always "root"
  RootPathName {"root",lifetime[Object]=(RootPathName)}
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  :: always "name"
  RootPathNameAttrib {"name",lifetime[Object]=(RootPathNameAttrib)}
Line 1141
  path always {symbolic=(mPath),symbolic=(path)}
  :: always "name"
  RootPathNameAttrib {"name",lifetime[Object]=(RootPathNameAttrib)}
Line 1142
  . always {!<=-1,!>=2}
  relativePaths always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1143
  :: always "bug-hunting"
  BugHunting {"bug-hunting",lifetime[Object]=(BugHunting)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1145
  :: always "builddir"
  BuildDirElementName {"builddir",lifetime[Object]=(BuildDirElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1146
  path always {symbolic=(mPath),symbolic=(path)}
  : always ""
  "" always ""
Line 1147
  :: always "includedir"
  IncludeDirElementName {"includedir",lifetime[Object]=(IncludeDirElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1148
  path always {symbolic=(mPath),symbolic=(path)}
  :: always "dir"
  DirElementName {"dir",lifetime[Object]=(DirElementName)}
  :: always "name"
  DirNameAttrib {"name",lifetime[Object]=(DirNameAttrib)}
Line 1149
  :: always "defines"
  DefinesElementName {"defines",lifetime[Object]=(DefinesElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1150
  "" always ""
  :: always "define"
  DefineName {"define",lifetime[Object]=(DefineName)}
  :: always "name"
  DefineNameAttrib {"name",lifetime[Object]=(DefineNameAttrib)}
  ";" always ";"
Line 1151
  :: always "undefines"
  UndefinesElementName {"undefines",lifetime[Object]=(UndefinesElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1152
  "" always ""
  :: always "undefine"
  UndefineName {"undefine",lifetime[Object]=(UndefineName)}
  nullptr always 0
Line 1154
  :: always "importproject"
  ImportProjectElementName {"importproject",lifetime[Object]=(ImportProjectElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1155
  path always {symbolic=(mPath),symbolic=(path)}
  : always ""
  "" always ""
Line 1156
  :: always "paths"
  PathsElementName {"paths",lifetime[Object]=(PathsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1157
  path always {symbolic=(mPath),symbolic=(path)}
  :: always "dir"
  PathName {"dir",lifetime[Object]=(PathName)}
  :: always "name"
  PathNameAttrib {"name",lifetime[Object]=(PathNameAttrib)}
Line 1158
  :: always "exclude"
  ExcludeElementName {"exclude",lifetime[Object]=(ExcludeElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1159
  "" always ""
  :: always "path"
  ExcludePathName {"path",lifetime[Object]=(ExcludePathName)}
  :: always "name"
  ExcludePathNameAttrib {"name",lifetime[Object]=(ExcludePathNameAttrib)}
Line 1160
  :: always "function-contracts"
  FunctionContracts {"function-contracts",lifetime[Object]=(FunctionContracts)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1162
  :: always "variable-contracts"
  VariableContractsElementName {"variable-contracts",lifetime[Object]=(VariableContractsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1164
  :: always "ignore"
  IgnoreElementName {"ignore",lifetime[Object]=(IgnoreElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1165
  "" always ""
  :: always "path"
  IgnorePathName {"path",lifetime[Object]=(IgnorePathName)}
  :: always "name"
  IgnorePathNameAttrib {"name",lifetime[Object]=(IgnorePathNameAttrib)}
Line 1166
  :: always "libraries"
  LibrariesElementName {"libraries",lifetime[Object]=(LibrariesElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1167
  "" always ""
  :: always "library"
  LibraryElementName {"library",lifetime[Object]=(LibraryElementName)}
  nullptr always 0
Line 1168
  :: always "suppressions"
  SuppressionsElementName {"suppressions",lifetime[Object]=(SuppressionsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1170
  :: always "suppression"
  SuppressionElementName {"suppression",lifetime[Object]=(SuppressionElementName)}
  != always {!<=-1,!>=2}
  0 always 0
Line 1173
  ? possible 1
  s always !0
  : always 1
Line 1176
  "" always ""
Line 1177
  "fileName" always "fileName"
  "" always ""
Line 1178
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 1179
  path always {symbolic=(mPath),symbolic=(path)}
  . always !size=0
Line 1180
  "lineNumber" always "lineNumber"
  :: always -1
  NO_LINE always -1
Line 1181
  "symbolName" always "symbolName"
  "" always ""
Line 1182
  "hash" always "hash"
  "0" always "0"
  . always !<=-1
  hash always !<=-1
Line 1185
  :: always "vs-configurations"
  VSConfigurationElementName {"vs-configurations",lifetime[Object]=(VSConfigurationElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1186
  "" always ""
  :: always "config"
  VSConfigurationName {"config",lifetime[Object]=(VSConfigurationName)}
  nullptr always 0
Line 1187
  :: always "platform"
  PlatformElementName {"platform",lifetime[Object]=(PlatformElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1189
  :: always "analyze-all-vs-configs"
  AnalyzeAllVsConfigsElementName {"analyze-all-vs-configs",lifetime[Object]=(AnalyzeAllVsConfigsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1191
  :: always "parser"
  Parser {"parser",lifetime[Object]=(Parser)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1192
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1193
  :: always "addons"
  AddonsElementName {"addons",lifetime[Object]=(AddonsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1194
  "" always ""
  :: always "addon"
  AddonElementName {"addon",lifetime[Object]=(AddonElementName)}
  nullptr always 0
Line 1195
  :: always "tags"
  TagsElementName {"tags",lifetime[Object]=(TagsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1196
  :: always "tag"
  TagElementName {"tag",lifetime[Object]=(TagElementName)}
Line 1197
  :: always "tools"
  ToolsElementName {"tools",lifetime[Object]=(ToolsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1198
  "" always ""
  :: always "tool"
  ToolElementName {"tool",lifetime[Object]=(ToolElementName)}
  nullptr always 0
Line 1200
  == always {!<=-1,!>=2}
  :: always "clang-tidy"
  ClangTidy {"clang-tidy",lifetime[Object]=(ClangTidy)}
Line 1201
  . always {!<=-1,!>=2}
  clangTidy always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1203
  :: always "check-headers"
  CheckHeadersElementName {"check-headers",lifetime[Object]=(CheckHeadersElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1204
  . always {!<=-1,!>=2}
  checkHeaders always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "true" always "true"
  == always {!<=-1,!>=2}
  0 always 0
Line 1205
  :: always "check-unused-templates"
  CheckUnusedTemplatesElementName {"check-unused-templates",lifetime[Object]=(CheckUnusedTemplatesElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1206
  . always {!<=-1,!>=2}
  checkUnusedTemplates always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "true" always "true"
  == always {!<=-1,!>=2}
  0 always 0
Line 1207
  :: always "max-ctu-depth"
  MaxCtuDepthElementName {"max-ctu-depth",lifetime[Object]=(MaxCtuDepthElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1209
  :: always "max-template-recursion"
  MaxTemplateRecursionElementName {"max-template-recursion",lifetime[Object]=(MaxTemplateRecursionElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1211
  :: always "check-unknown-function-return-values"
  CheckUnknownFunctionReturn {"check-unknown-function-return-values",lifetime[Object]=(CheckUnknownFunctionReturn)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1213
  XmlRootName possible lifetime[Object]=(XmlRootName)
  == always {!<=-1,!>=2}
  0 always 0
Line 1215
  XmlClasses possible lifetime[Object]=(XmlClasses)
  == always {!<=-1,!>=2}
  0 always 0
Line 1216
  . always {!<=-1,!>=2}
  classes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1217
  XmlExternalFunctions possible lifetime[Object]=(XmlExternalFunctions)
  == always {!<=-1,!>=2}
  0 always 0
Line 1218
  . always {!<=-1,!>=2}
  externalFunctions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1219
  XmlInternalFunctions possible lifetime[Object]=(XmlInternalFunctions)
  == always {!<=-1,!>=2}
  0 always 0
Line 1220
  . always {!<=-1,!>=2}
  internalFunctions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1221
  XmlExternalVariables possible lifetime[Object]=(XmlExternalVariables)
  == always {!<=-1,!>=2}
  0 always 0
Line 1222
  . always {!<=-1,!>=2}
  externalVariables always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1224
  return always {!<=-1,!>=2}
  false always 0
Line 1226
  :: always "tag-warnings"
  TagWarningsElementName {"tag-warnings",lifetime[Object]=(TagWarningsElementName)}
  == always {!<=-1,!>=2}
  0 always 0
Line 1229
  return always {!<=-1,!>=2}
  false always 0
Line 1232
  . always {!<=-1,!>=2}
  relativePaths always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  relativePaths always {!<=-1,!>=2}
Line 1238
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  clang always {!<=-1,!>=2}
Line 1239
  . always {!<=-1,!>=2}
  clangTidy always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  clangTidy always {!<=-1,!>=2}
Line 1241
  paths possible size=0
Line 1245
  . always {!<=-1,!>=2}
  checkHeaders always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkHeaders always {!<=-1,!>=2}
Line 1246
  . always {!<=-1,!>=2}
  checkUnusedTemplates always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checkUnusedTemplates always {!<=-1,!>=2}
Line 1251
  return always {!<=-1,!>=2}
  true always 1
Line 1257
  = {lifetime[Iterator]=(fileSettings),start=0}
  ( {lifetime[Iterator]=(fileSettings),start=0}
  it possible {lifetime[Iterator]=(fileSettings),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(fileSettings),end=0}
Line 1258
  it possible lifetime[Iterator]=(fileSettings)
Line 1259
  it possible lifetime[Iterator]=(fileSettings)
Line 1263
  remove {!<=-1,!>=2,0}
  remove always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1264
  fs always symbolic=(*it)
  0 always 0
  5 always 5
  "Debug" always "Debug"
  != always {!<=-1,!>=2}
  0 always 0
Line 1265
  remove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1266
  platform possible symbolic=(fs.platformType)
  == always {!<=-1,!>=2}
  :: possible symbolic=(fs.platformType)
  && always {!<=-1,!>=2}
  fs always symbolic=(*it)
  != always {!<=-1,!>=2}
  platform always symbolic=(Settings::Win64)
Line 1267
  remove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1268
  platform possible symbolic=(fs.platformType)
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  fs always symbolic=(*it)
  == always {!<=-1,!>=2}
Line 1269
  remove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1270
  fs always symbolic=(*it)
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always !symbolic=(fs.platformType)
Line 1271
  remove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1272
  ( possible lifetime[Iterator]=(filenames)
  fs always symbolic=(*it)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(filenames),end=0}
Line 1273
  remove always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1274
  remove {!<=-1,!>=2,1}
Line 1277
  fs always symbolic=(*it)
Line 1285
  ( {lifetime[Iterator]=(mAllVSConfigs),start=0}
  ( {lifetime[Iterator]=(mAllVSConfigs),end=0}
Line 1290
  ( always {!<=-1,!>=2}
Line 1294
  basePaths always {{,size=1}
Line 1296
  basePaths always {{,size=1}
Line 1302
  "cppcheck: error: " always "cppcheck: error: "
  message possible {"Cppcheck GUI project file has no XML root node"@15,"Borland project file has no XML root node"@32,"Visual Studio project file has no XML root node"@38,"Visual Studio solution file is empty"@67,"Visual Studio solution file header not found"@68,"no projects found in Visual Studio solution file"@71,"compilation database is not a JSON array"@72,"'arguments' field in compilation database entry is not a JSON array"@74,"'command' field in compilation database entry is not a string"@75,"no 'arguments' or 'command' field found in compilation database entry"@76}
Line 1305
  ( always {!<=-1,!>=2}
Line 1307
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
Line 50
  mFlags always !<=-1
  mFlags always !<=-1
  = always 0
  0 always 0
Line 52
  ( always !<=-1
Line 53
  return always !<=-1
  mFlags always !<=-1
Line 56
  mFlags always !<=-1
  = always 0
  0 always 0
Line 59
  mFlags always !<=-1
  = always 4294967295
  0xFFFFFFFF always 4294967295
Line 61
  enabled always {!<=-1,!>=2}
Line 62
  enabled always {!<=-1,!>=2}
Line 67
  ( always {!<=-1,!>=2}
Line 68
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
  != always {!<=-1,!>=2}
  0 always 0
Line 71
  mFlags always !<=-1
  |= always !<=-1
  1U always 1
  << always !<=0
  ( always !<=-1
Line 74
  mFlags always !<=-1
  &= always !<=-1
  ~ always !<=4294967295
  1U always 1
  << always !<=0
  ( always !<=-1
Line 76
  , always {!<=-1,!>=2}
  enabled always {!<=-1,!>=2}
Line 77
  enabled always {!<=-1,!>=2}
