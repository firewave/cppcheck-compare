

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073744112 Type ::@expr1073744113 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073744114 Type ::@expr1073744115 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073744116 ) ?@expr1073744117 mDoubleValue@var3 :@expr1073744118 (@expr1073744119 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
76: template < class T > static std :: string toString ( T value@var18 ) {
77: std ::@expr1073744120 ostringstream result@var19 ;
78: result@var19 <<@expr1073744121 value@var18 ;
79: return result@var19 .@expr1073744122 str (@expr1073744123 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var20 ) ;
82:
83: static bool isInt ( const std :: string & str@var21 ) ;
84: static bool isFloat ( const std :: string & str@var22 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var23 ) ;
86: static bool isNegative ( const std :: string & str@var24 ) ;
87: static bool isPositive ( const std :: string & str@var25 ) ;
88: static bool isDec ( const std :: string & str@var26 ) ;
89: static bool isFloatHex ( const std :: string & str@var27 ) ;
90: static bool isIntHex ( const std :: string & str@var28 ) ;
91: static bool isOct ( const std :: string & str@var29 ) ;
92: static bool isBin ( const std :: string & str@var30 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var31 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var32 , bool supportMicrosoftExtensions@var33 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var34 , const std :: string & second@var35 ) ;
105: static std :: string subtract ( const std :: string & first@var36 , const std :: string & second@var37 ) ;
106: static std :: string multiply ( const std :: string & first@var38 , const std :: string & second@var39 ) ;
107: static std :: string divide ( const std :: string & first@var40 , const std :: string & second@var41 ) ;
108: static std :: string mod ( const std :: string & first@var42 , const std :: string & second@var43 ) ;
109: static std :: string incdec ( const std :: string & var@var44 , const std :: string & op@var45 ) ;
110: static std :: string calculate ( const std :: string & first@var46 , const std :: string & second@var47 , char action@var48 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var49 ) ;
113: static std :: string cos ( const std :: string & tok@var50 ) ;
114: static std :: string tan ( const std :: string & tok@var51 ) ;
115: static std :: string abs ( const std :: string & tok@var52 ) ;
116: static bool isEqual ( const std :: string & first@var53 , const std :: string & second@var54 ) ;
117: static bool isNotEqual ( const std :: string & first@var55 , const std :: string & second@var56 ) ;
118: static bool isGreater ( const std :: string & first@var57 , const std :: string & second@var58 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var59 , const std :: string & second@var60 ) ;
120: static bool isLess ( const std :: string & first@var61 , const std :: string & second@var62 ) ;
121: static bool isLessEqual ( const std :: string & first@var63 , const std :: string & second@var64 ) ;
122: static bool isNullValue ( const std :: string & str@var65 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var66 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var67 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var68 , std :: string :: size_type iPos@var69 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var70 , const MathLib :: value & v2@var71 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var72 , const MathLib :: value & v2@var73 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var74 , const MathLib :: value & v2@var75 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var76 , const MathLib :: value & v2@var77 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var78 , const MathLib :: value & v2@var79 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var80 , const MathLib :: value & v2@var81 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var82 , const MathLib :: value & v2@var83 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var84 , const MathLib :: value & v2@var85 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var86 , const MathLib :: value & v2@var87 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var88 , const MathLib :: value & v2@var89 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var90 ) ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var91 , const std :: string & errorMsg@var92 , Type type@var93 = INTERNAL ) ;
38: const Token * token@var94 ;
39: std :: string errorMessage@var95 ;
40: Type type@var96 ;
41: std :: string id@var97 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var98 ) ;
117: static SeverityType fromString ( const std :: string & severity@var99 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var100 ) : id@var101 ( cweId@var100 ) { }
122: unsigned short id@var101 ;
123: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var102 ) const {
35: return p@var102 .@expr1073744124 first@var103 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var104 ) const {
42: return p@var104 .@expr1073744125 second@var105 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var106 , const T & x@var107 )
48: {
49: return std ::@expr1073744126 find (@expr1073744127 r@var106 .@expr1073744128 begin (@expr1073744129 ) , r@var106 .@expr2306 end (@expr2307 ) , x@var107 ) !=@expr1073744132 r@var106 .@expr2306 end (@expr2307 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var108 , const T & x@var109 )
54: {
55: return std ::@expr1073744135 find (@expr1073744136 r@var108 .@expr1073744137 begin (@expr1073744138 ) , r@var108 .@expr2315 end (@expr2316 ) , x@var109 ) !=@expr1073744141 r@var108 .@expr2315 end (@expr2316 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var110 , const U & x@var111 )
60: {
61: return std ::@expr1073744144 find (@expr1073744145 r@var110 .@expr1073744146 begin (@expr1073744147 ) , r@var110 .@expr2324 end (@expr2325 ) , x@var111 ) !=@expr1073744150 r@var110 .@expr2324 end (@expr2325 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var112 ) const
68: {
69: return static_cast < unsigned long > (@expr1073744153 t@var112 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var113 , char c@var114 )
74: {
75: return !@expr1073744154 str@var113 .@expr1073744155 empty (@expr1073744156 ) &&@expr1073744157 str@var113 .@expr1073744158 back (@expr1073744159 ) ==@expr1073744160 c@var114 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var115 , const char end@var116 [ ] , unsigned long endlen@var117 )
79: {
80: return (@expr2337 str@var115 .@expr2338 size (@expr2339 ) >=@expr1073744164 endlen@var117 ) &&@expr1073744165 (@expr2337 str@var115 .@expr1073744167 compare (@expr1073744168 str@var115 .@expr2338 size (@expr2339 ) -@expr1073744171 endlen@var117 , endlen@var117 , end@var116 ) ==@expr1073744172 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var118 , const char ( & end@var119 ) [ N ] )
85: {
86: return endsWith (@expr1073744174 str@var118 , end@var119 , N@expr1073744173 -@expr1073744175 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var120 , char q@var121 , const std :: string & p@var122 )
90: {
91: if (@expr1073744176 !@expr1073744177 endsWith (@expr1073744178 str@var120 , q@var121 ) ) {
92: return false ; }
93: if (@expr1073744179 (@expr1073744180 str@var120 .@expr1073744181 length (@expr1073744182 ) +@expr1073744183 1 ) >@expr1073744184 p@var122 .@expr1073744185 length (@expr1073744186 ) &&@expr1073744187 (@expr1073744188 str@var120 .@expr1073744189 compare (@expr1073744190 0 , p@var122 .@expr1073744191 size (@expr1073744192 ) +@expr1073744193 1 , p@var122 +@expr1073744194 q@var121 ) ==@expr1073744195 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var123 , char q@var124 )
99: {
100: static const std ::@expr2372 vector < std ::@expr2372 string > suffixes@var125 {@expr1073744198 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073744199 const std ::@expr2372 string &@expr1073744201 p@var126 :@expr1073744202 suffixes@var125 ) {
102: if (@expr1073744203 isPrefixStringCharLiteral (@expr1073744204 str@var123 , q@var124 , p@var126 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var127 )
109: {
110: return isStringCharLiteral (@expr1073744205 str@var127 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var128 )
114: {
115: return isStringCharLiteral (@expr1073744206 str@var128 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var129 , char q@var130 )
119: {
120: const unsigned long quotePos@var131 =@expr1073744207 str@var129 .@expr1073744208 find (@expr1073744209 q@var130 ) ;
121: return str@var129 .@expr1073744210 substr (@expr1073744211 quotePos@var131 +@expr1073744212 1U , str@var129 .@expr1073744213 size (@expr1073744214 ) -@expr1073744215 quotePos@var131 -@expr1073744216 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var132 )
125: {
126: if (@expr1073744217 isStringLiteral (@expr1073744218 str@var132 ) ) {
127: return getStringCharLiteral (@expr1073744219 str@var132 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var133 )
132: {
133: if (@expr1073744220 isCharLiteral (@expr1073744221 str@var133 ) ) {
134: return getStringCharLiteral (@expr1073744222 str@var133 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var134 )
139: {
140: if (@expr1073744223 i@var134 ==@expr1073744224 1 ) {
141: return "st" ; }
142: if (@expr1073744225 i@var134 ==@expr1073744226 2 ) {
143: return "nd" ; }
144: if (@expr1073744227 i@var134 ==@expr1073744228 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var135 , const std :: string & rhs@var136 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var137 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var138 , const std :: string & name@var139 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var140 , const std :: string & name@var141 ) ;
156:
157: void strTolower ( std :: string & str@var142 ) ;

##file cppcheck-2.8/lib/standards.h

1:
|
35:
36: struct Standards {
37:
38: enum cstd_t { C89 , C99 , C11 , CLatest = C11 } ; enum cstd_t c@var143 ;
39:
40:
41: enum cppstd_t { CPP03 , CPP11 , CPP14 , CPP17 , CPP20 , CPP23 , CPPLatest = CPP23 } ; enum cppstd_t cpp@var144 ;
42:
43:
44: std :: string stdValue@var145 ;
45:
46:
47: Standards ( ) : c@var143 ( CLatest ) , cpp@var144 ( CPPLatest ) { }
48:
49: bool setC ( const std :: string & str@var146 ) {
50: stdValue@var145 =@expr1073744229 str@var146 ;
51: if (@expr1073744230 str@var146 ==@expr1073744231 "c89" ||@expr1073744232 str@var146 ==@expr1073744233 "C89" ) {
52: c@var143 =@expr1073744234 C89 ;
53: return true ;
54: }
55: if (@expr1073744235 str@var146 ==@expr1073744236 "c99" ||@expr1073744237 str@var146 ==@expr1073744238 "C99" ) {
56: c@var143 =@expr1073744239 C99 ;
57: return true ;
58: }
59: if (@expr1073744240 str@var146 ==@expr1073744241 "c11" ||@expr1073744242 str@var146 ==@expr1073744243 "C11" ) {
60: c@var143 =@expr1073744244 C11 ;
61: return true ;
62: }
63: return false ;
64: }
65: const std :: string getC ( ) const {
66: switch (@expr1073744245 c@var143 ) {
67: case C89 :@expr2422 ;
68: return "c89" ;
69: case C99 :@expr2422 ;
70: return "c99" ;
71: case C11 :@expr2422 ;
72: return "c11" ;
73: }
74: return "" ;
75: }
76: static cstd_t getC ( const std :: string & std@var147 ) {
77: if (@expr1073744249 std@var147 ==@expr1073744250 "c89" ) {
78: return Standards ::@expr1073744251 C89 ;
79: }
80: if (@expr1073744252 std@var147 ==@expr1073744253 "c99" ) {
81: return Standards ::@expr1073744254 C99 ;
82: }
83: if (@expr1073744255 std@var147 ==@expr1073744256 "c11" ) {
84: return Standards ::@expr1073744257 C11 ;
85: }
86: return Standards ::@expr1073744258 CLatest ;
87: }
88: bool setCPP ( std :: string str@var148 ) {
89: stdValue@var145 =@expr1073744259 str@var148 ;
90: strTolower (@expr1073744260 str@var148 ) ;
91: cpp@var144 =@expr1073744261 getCPP (@expr1073744262 str@var148 ) ;
92: return !@expr1073744263 stdValue@var145 .@expr1073744264 empty (@expr1073744265 ) &&@expr1073744266 str@var148 ==@expr1073744267 getCPP (@expr1073744268 ) ;
93: }
94: std :: string getCPP ( ) const {
95: return getCPP (@expr1073744269 cpp@var144 ) ;
96: }
97: static std :: string getCPP ( cppstd_t std@var149 ) {
98: switch (@expr1073744270 std@var149 ) {
99: case CPP03 :@expr2447 ;
100: return "c++03" ;
101: case CPP11 :@expr2447 ;
102: return "c++11" ;
103: case CPP14 :@expr2447 ;
104: return "c++14" ;
105: case CPP17 :@expr2447 ;
106: return "c++17" ;
107: case CPP20 :@expr2447 ;
108: return "c++20" ;
109: case CPP23 :@expr2447 ;
110: return "c++23" ;
111: }
112: return "" ;
113: }
114: static cppstd_t getCPP ( const std :: string & std@var150 ) {
115: if (@expr1073744277 std@var150 ==@expr1073744278 "c++03" ) {
116: return Standards ::@expr1073744279 CPP03 ;
117: }
118: if (@expr1073744280 std@var150 ==@expr1073744281 "c++11" ) {
119: return Standards ::@expr1073744282 CPP11 ;
120: }
121: if (@expr1073744283 std@var150 ==@expr1073744284 "c++14" ) {
122: return Standards ::@expr1073744285 CPP14 ;
123: }
124: if (@expr1073744286 std@var150 ==@expr1073744287 "c++17" ) {
125: return Standards ::@expr1073744288 CPP17 ;
126: }
127: if (@expr1073744289 std@var150 ==@expr1073744290 "c++20" ) {
128: return Standards ::@expr1073744291 CPP20 ;
129: }
130: if (@expr1073744292 std@var150 ==@expr1073744293 "c++23" ) {
131: return Standards ::@expr1073744294 CPP23 ;
132: }
133: return Standards ::@expr1073744295 CPPLatest ;
134: }
135: } ;

##file cppcheck-2.8/lib/library.h

1:
|
37:
38: class Token ;
39: class Settings ;
40:
41: namespace tinyxml2 {
42: class XMLDocument ;
43: class XMLElement ;
44: }
45:
|
51:
52: class Library {
53: friend class TestSymbolDatabase ;
54:
55: public:
56: Library ( ) ;
57:
58: enum class ErrorCode { OK , FILE_NOT_FOUND , BAD_XML , UNKNOWN_ELEMENT , MISSING_ATTRIBUTE , BAD_ATTRIBUTE_VALUE , UNSUPPORTED_FORMAT , DUPLICATE_PLATFORM_TYPE , PLATFORM_TYPE_REDEFINED } ;
59:
60: class Error {
61: public:
62: Error ( ) : errorcode@var154 ( ErrorCode :: OK ) { }
63: explicit Error ( ErrorCode e@var151 ) : errorcode@var154 ( e@var151 ) { }
64: template < typename T >
65: Error ( ErrorCode e@var152 , T && r@var153 ) : errorcode@var154 ( e@var152 ) , reason@var155 ( r@var153 ) { }
66: ErrorCode errorcode@var154 ;
67: std :: string reason@var155 ;
68: } ;
69:
70: Error load ( const char exename@var156 [ ] , const char path@var157 [ ] ) ;
71: Error load ( const tinyxml2 :: XMLDocument & doc@var158 ) ;
72:
73:
74: bool loadxmldata ( const char xmldata@var159 [ ] , unsigned long len@var160 ) ;
75:
76: struct AllocFunc {
77: int groupId@var161 ;
78: int arg@var162 ;
79: enum class BufferSize { none , malloc , calloc , strdup } ;
80: BufferSize bufferSize@var163 ;
81: int bufferSizeArg1@var164 ;
82: int bufferSizeArg2@var165 ;
83: int reallocArg@var166 ;
84: bool initData@var167 ;
85: } ;
86:
87:
88: const AllocFunc * getAllocFuncInfo ( const Token * tok@var168 ) const ;
89:
90:
91: const AllocFunc * getDeallocFuncInfo ( const Token * tok@var169 ) const ;
92:
93:
94: const AllocFunc * getReallocFuncInfo ( const Token * tok@var170 ) const ;
95:
96:
97: int getAllocId ( const Token * tok@var171 , int arg@var172 ) const ;
98:
99:
100: int getDeallocId ( const Token * tok@var173 , int arg@var174 ) const ;
101:
102:
103: int getReallocId ( const Token * tok@var175 , int arg@var176 ) const ;
104:
105:
106: const AllocFunc * getAllocFuncInfo ( const char name@var177 [ ] ) const {
107: return getAllocDealloc (@expr1073744296 mAlloc@var443 , name@var177 ) ;
108: }
109:
110:
111: const AllocFunc * getDeallocFuncInfo ( const char name@var178 [ ] ) const {
112: return getAllocDealloc (@expr1073744297 mDealloc@var444 , name@var178 ) ;
113: }
114:
115:
116: int allocId ( const char name@var179 [ ] ) const {
117: const AllocFunc * af@var180 ; af@var180 =@expr1073744298 getAllocDealloc (@expr1073744299 mAlloc@var443 , name@var179 ) ;
118: return af@var180 ?@expr1073744300 af@var180 .@expr1073744301 groupId@var181 :@expr1073744302 0 ;
119: }
120:
121:
122: int deallocId ( const char name@var182 [ ] ) const {
123: const AllocFunc * af@var183 ; af@var183 =@expr1073744303 getAllocDealloc (@expr1073744304 mDealloc@var444 , name@var182 ) ;
124: return af@var183 ?@expr1073744305 af@var183 .@expr1073744306 groupId@var184 :@expr1073744307 0 ;
125: }
126:
127:
128: void setalloc ( const std :: string & functionname@var185 , int id@var186 , int arg@var187 ) {
129: mAlloc@var443 [@expr2484 functionname@var185 ] .@expr1073744309 groupId@var2288 =@expr1073744310 id@var186 ;
130: mAlloc@var443 [@expr2484 functionname@var185 ] .@expr1073744312 arg@var2289 =@expr1073744313 arg@var187 ;
131: }
132:
133: void setdealloc ( const std :: string & functionname@var188 , int id@var189 , int arg@var190 ) {
134: mDealloc@var444 [@expr2490 functionname@var188 ] .@expr1073744315 groupId@var2290 =@expr1073744316 id@var189 ;
135: mDealloc@var444 [@expr2490 functionname@var188 ] .@expr1073744318 arg@var2291 =@expr1073744319 arg@var190 ;
136: }
137:
138: void setrealloc ( const std :: string & functionname@var191 , int id@var192 , int arg@var193 , int reallocArg@var194 = 1 ) {
139: mRealloc@var445 [@expr2496 functionname@var191 ] .@expr1073744321 groupId@var2292 =@expr1073744322 id@var192 ;
140: mRealloc@var445 [@expr2496 functionname@var191 ] .@expr1073744324 arg@var2293 =@expr1073744325 arg@var193 ;
141: mRealloc@var445 [@expr2496 functionname@var191 ] .@expr1073744327 reallocArg@var2294 =@expr1073744328 reallocArg@var194 ;
142: }
143:
144:
145: void setnoreturn ( const std :: string & funcname@var195 , bool noreturn@var196 ) {
146: mNoReturn@var446 [@expr1073744329 funcname@var195 ] =@expr1073744330 noreturn@var196 ?@expr1073744331 FalseTrueMaybe ::@expr1073744332 True :@expr1073744333 FalseTrueMaybe ::@expr1073744334 False ;
147: }
148:
149: static bool isCompliantValidationExpression ( const char * p@var197 ) ;
150:
151:
152: static bool ismemory ( const int id@var198 ) {
153: return (@expr2511 (@expr2511 id@var198 >@expr1073744337 0 ) &&@expr1073744338 (@expr2511 (@expr2511 id@var198 &@expr1073744341 1 ) ==@expr1073744342 0 ) ) ;
154: }
155: static bool ismemory ( const AllocFunc * const func@var199 ) {
156: return (@expr2519 (@expr2519 func@var199 .@expr2521 groupId@var200 >@expr1073744346 0 ) &&@expr1073744347 (@expr2519 (@expr2519 func@var199 .@expr2521 groupId@var200 &@expr1073744351 1 ) ==@expr1073744352 0 ) ) ;
157: }
158:
159:
160: static bool isresource ( const int id@var201 ) {
161: return (@expr2529 (@expr2529 id@var201 >@expr1073744355 0 ) &&@expr1073744356 (@expr2529 (@expr2529 id@var201 &@expr1073744359 1 ) ==@expr1073744360 1 ) ) ;
162: }
163: static bool isresource ( const AllocFunc * const func@var202 ) {
164: return (@expr2537 (@expr2537 func@var202 .@expr2539 groupId@var203 >@expr1073744364 0 ) &&@expr1073744365 (@expr2537 (@expr2537 func@var202 .@expr2539 groupId@var203 &@expr1073744369 1 ) ==@expr1073744370 1 ) ) ;
165: }
166:
167: bool formatstr_function ( const Token * ftok@var204 ) const ;
168: int formatstr_argno ( const Token * ftok@var205 ) const ;
169: bool formatstr_scan ( const Token * ftok@var206 ) const ;
170: bool formatstr_secure ( const Token * ftok@var207 ) const ;
171:
172: struct NonOverlappingData {
173: int ptr1Arg@var208 ;
174: int ptr2Arg@var209 ;
175: int sizeArg@var210 ;
176: int strlenArg@var211 ;
177: } ;
178: const NonOverlappingData * getNonOverlappingData ( const Token * ftok@var212 ) const ;
179:
180: struct WarnInfo {
181: std :: string message@var213 ;
182: Standards standards@var214 ;
183: Severity :: SeverityType severity@var215 ;
184: } ;
185: std :: map < std :: string , WarnInfo > functionwarn@var216 ;
186:
187: const WarnInfo * getWarnInfo ( const Token * ftok@var217 ) const ;
188:
189:
190: bool isNotLibraryFunction ( const Token * ftok@var218 ) const ;
191: bool matchArguments ( const Token * ftok@var219 , const std :: string & functionName@var220 ) const ;
192:
193: enum class UseRetValType { NONE , DEFAULT , ERROR_CODE } ;
194: UseRetValType getUseRetValType ( const Token * ftok@var221 ) const ;
195:
196: const std :: string & returnValue ( const Token * ftok@var222 ) const ;
197: const std :: string & returnValueType ( const Token * ftok@var223 ) const ;
198: int returnValueContainer ( const Token * ftok@var224 ) const ;
199: std :: vector < long long > unknownReturnValues ( const Token * ftok@var225 ) const ;
200:
201: bool isnoreturn ( const Token * ftok@var226 ) const ;
202: bool isnotnoreturn ( const Token * ftok@var227 ) const ;
203:
204: bool isScopeNoReturn ( const Token * end@var228 , std :: string * unknownFunc@var229 ) const ;
205:
206: class Container {
207: public:
208: Container ( )
209: : type_templateArgNo@var239 ( -1 ) ,
210: size_templateArgNo@var241 ( -1 ) ,
211: arrayLike_indexOp@var242 ( false ) ,
212: stdStringLike@var243 ( false ) ,
213: stdAssociativeLike@var244 ( false ) ,
214: opLessAllowed@var245 ( true ) ,
215: hasInitializerListConstructor@var246 ( false ) ,
216: unstableErase@var247 ( false ) ,
217: unstableInsert@var248 ( false ) ,
218: view@var249 ( false )
219: { }
220:
221: enum class Action {
222: RESIZE ,
223: CLEAR ,
224: PUSH ,
225: POP ,
226: FIND ,
227: INSERT ,
228: ERASE ,
229: CHANGE_CONTENT ,
230: CHANGE ,
231: CHANGE_INTERNAL ,
232: NO_ACTION
233: } ;
234: enum class Yield {
235: AT_INDEX ,
236: ITEM ,
237: BUFFER ,
238: BUFFER_NT ,
239: START_ITERATOR ,
240: END_ITERATOR ,
241: ITERATOR ,
242: SIZE ,
243: EMPTY ,
244: NO_YIELD
245: } ;
246: struct Function {
247: Action action@var230 ;
248: Yield yield@var231 ;
249: } ;
250: struct RangeItemRecordTypeItem {
251: std :: string name@var232 ;
252: int templateParameter@var233 ;
253: } ;
254: std :: string startPattern@var234 ; std :: string startPattern2@var235 ; std :: string endPattern@var236 ; std :: string itEndPattern@var237 ;
255: std :: map < std :: string , Function > functions@var238 ;
256: int type_templateArgNo@var239 ;
257: std :: vector < RangeItemRecordTypeItem > rangeItemRecordType@var240 ;
258: int size_templateArgNo@var241 ;
259: bool arrayLike_indexOp@var242 ;
260: bool stdStringLike@var243 ;
261: bool stdAssociativeLike@var244 ;
262: bool opLessAllowed@var245 ;
263: bool hasInitializerListConstructor@var246 ;
264: bool unstableErase@var247 ;
265: bool unstableInsert@var248 ;
266: bool view@var249 ;
267:
268: Action getAction ( const std :: string & function@var250 ) const {
269: const std ::@expr1073744371 map < std ::@expr1073744372 string , Function > ::@expr1073744373 const_iterator i@var251 =@expr1073744374 functions@var238 .@expr1073744375 find (@expr1073744376 function@var250 ) ;
270: if (@expr1073744377 i@var251 !=@expr1073744378 functions@var238 .@expr1073744379 end (@expr1073744380 ) ) {
271: return i@var251 .@expr1073744381 second@var252 .@expr1073744382 action@var253 ; }
272: return Action ::@expr1073744383 NO_ACTION ;
273: }
274:
275: Yield getYield ( const std :: string & function@var254 ) const {
276: const std ::@expr1073744384 map < std ::@expr1073744385 string , Function > ::@expr1073744386 const_iterator i@var255 =@expr1073744387 functions@var238 .@expr1073744388 find (@expr1073744389 function@var254 ) ;
277: if (@expr1073744390 i@var255 !=@expr1073744391 functions@var238 .@expr1073744392 end (@expr1073744393 ) ) {
278: return i@var255 .@expr1073744394 second@var256 .@expr1073744395 yield@var257 ; }
279: return Yield ::@expr1073744396 NO_YIELD ;
280: }
281:
282: static Yield yieldFrom ( const std :: string & yieldName@var258 ) ;
283: static Action actionFrom ( const std :: string & actionName@var259 ) ;
284: } ;
285: std :: map < std :: string , Container > containers@var260 ;
286: const Container * detectContainer ( const Token * typeStart@var261 , bool iterator@var262 = false ) const ;
287: const Container * detectContainerOrIterator ( const Token * typeStart@var263 , bool * isIterator@var264 = nullptr ) const ;
288:
289: class ArgumentChecks {
290: public:
291: ArgumentChecks ( ) :
292: notbool@var265 ( false ) ,
293: notnull@var266 ( false ) ,
294: notuninit@var267 ( -1 ) ,
295: formatstr@var268 ( false ) ,
296: strz@var269 ( false ) ,
297: optional@var270 ( false ) ,
298: variadic@var271 ( false ) ,
299: iteratorInfo@var277 ( ) ,
300: direction@var285 ( Direction :: DIR_UNKNOWN ) { }
301:
302: bool notbool@var265 ;
303: bool notnull@var266 ;
304: int notuninit@var267 ;
305: bool formatstr@var268 ;
306: bool strz@var269 ;
307: bool optional@var270 ;
308: bool variadic@var271 ;
309: std :: string valid@var272 ;
310:
311: class IteratorInfo {
312: public:
313: IteratorInfo ( ) : container@var273 ( 0 ) , it@var274 ( false ) , first@var275 ( false ) , last@var276 ( false ) { }
314:
315: int container@var273 ;
316: bool it@var274 ;
317: bool first@var275 ;
318: bool last@var276 ;
319: } ;
320: IteratorInfo iteratorInfo@var277 ;
321:
322: class MinSize {
323: public:
324: enum class Type { NONE , STRLEN , ARGVALUE , SIZEOF , MUL , VALUE } ;
325: MinSize ( Type t@var278 , int a@var279 ) : type@var280 ( t@var278 ) , arg@var281 ( a@var279 ) , arg2@var282 ( 0 ) , value@var283 ( 0 ) { }
326: Type type@var280 ;
327: int arg@var281 ;
328: int arg2@var282 ;
329: long long value@var283 ;
330: } ;
331: std :: vector < MinSize > minsizes@var284 ;
332:
333: enum class Direction {
334: DIR_IN ,
335: DIR_OUT ,
336: DIR_INOUT ,
337: DIR_UNKNOWN
338: } ;
339: Direction direction@var285 ;
340: } ;
341:
342: struct Function {
343: std :: map < int , ArgumentChecks > argumentChecks@var286 ;
344: bool use@var287 ;
345: bool leakignore@var288 ;
346: bool isconst@var289 ;
347: bool ispure@var290 ;
348: UseRetValType useretval@var291 ;
349: bool ignore@var292 ;
350: bool formatstr@var293 ;
351: bool formatstr_scan@var294 ;
352: bool formatstr_secure@var295 ;
353: Container :: Action containerAction@var296 ;
354: Container :: Yield containerYield@var297 ;
355: Function ( )
356: : use@var287 ( false ) ,
357: leakignore@var288 ( false ) ,
358: isconst@var289 ( false ) ,
359: ispure@var290 ( false ) ,
360: useretval@var291 ( UseRetValType :: NONE ) ,
361: ignore@var292 ( false ) ,
362: formatstr@var293 ( false ) ,
363: formatstr_scan@var294 ( false ) ,
364: formatstr_secure@var295 ( false ) ,
365: containerAction@var296 ( Container :: Action :: NO_ACTION ) ,
366: containerYield@var297 ( Container :: Yield :: NO_YIELD )
367: { }
368: } ;
369:
370: const Function * getFunction ( const Token * ftok@var298 ) const ;
371: std :: unordered_map < std :: string , Function > functions@var299 ;
372: bool isUse ( const std :: string & functionName@var300 ) const ;
373: bool isLeakIgnore ( const std :: string & functionName@var301 ) const ;
374: bool isFunctionConst ( const std :: string & functionName@var302 , bool pure@var303 ) const ;
375: bool isFunctionConst ( const Token * ftok@var304 ) const ;
376:
377: bool isboolargbad ( const Token * ftok@var305 , int argnr@var306 ) const {
378: const ArgumentChecks * arg@var307 ; arg@var307 =@expr1073744397 getarg (@expr1073744398 ftok@var305 , argnr@var306 ) ;
379: return arg@var307 &&@expr1073744399 arg@var307 .@expr1073744400 notbool@var308 ;
380: }
381:
382: bool isnullargbad ( const Token * ftok@var309 , int argnr@var310 ) const ;
383: bool isuninitargbad ( const Token * ftok@var311 , int argnr@var312 , int indirect@var313 = 0 , bool * hasIndirect@var314 = nullptr ) const ;
384:
385: bool isargformatstr ( const Token * ftok@var315 , int argnr@var316 ) const {
386: const ArgumentChecks * arg@var317 ; arg@var317 =@expr1073744401 getarg (@expr1073744402 ftok@var315 , argnr@var316 ) ;
387: return arg@var317 &&@expr1073744403 arg@var317 .@expr1073744404 formatstr@var318 ;
388: }
389:
390: bool isargstrz ( const Token * ftok@var319 , int argnr@var320 ) const {
391: const ArgumentChecks * arg@var321 ; arg@var321 =@expr1073744405 getarg (@expr1073744406 ftok@var319 , argnr@var320 ) ;
392: return arg@var321 &&@expr1073744407 arg@var321 .@expr1073744408 strz@var322 ;
393: }
394:
395: bool isIntArgValid ( const Token * ftok@var323 , int argnr@var324 , const long long argvalue@var325 ) const ;
396: bool isFloatArgValid ( const Token * ftok@var326 , int argnr@var327 , double argvalue@var328 ) const ;
397:
398: const std :: string & validarg ( const Token * ftok@var329 , int argnr@var330 ) const {
399: const ArgumentChecks * arg@var331 ; arg@var331 =@expr1073744409 getarg (@expr1073744410 ftok@var329 , argnr@var330 ) ;
400: return arg@var331 ?@expr1073744411 arg@var331 .@expr1073744412 valid@var332 :@expr1073744413 emptyString@var1 ;
401: }
402:
403: struct InvalidArgValue {
404: enum class Type { le , lt , eq , ge , gt , range } ; enum Type type@var333 ;
405: std :: string op1@var334 ;
406: std :: string op2@var335 ;
407: bool isInt ( ) const {
408: return MathLib ::@expr1073744414 isInt (@expr1073744415 op1@var334 ) ;
409: }
410: } ;
411:
412: const ArgumentChecks :: IteratorInfo * getArgIteratorInfo ( const Token * ftok@var336 , int argnr@var337 ) const {
413: const ArgumentChecks * arg@var338 ; arg@var338 =@expr1073744416 getarg (@expr1073744417 ftok@var336 , argnr@var337 ) ;
414: return arg@var338 &&@expr1073744418 arg@var338 .@expr2595 iteratorInfo@var339 .@expr1073744420 it@var340 ?@expr1073744421 &@expr1073744422 arg@var338 .@expr2595 iteratorInfo@var339 :@expr1073744424 nullptr ;
415: }
416:
417: bool hasminsize ( const Token * ftok@var341 ) const ;
418:
419: const std :: vector < ArgumentChecks :: MinSize > * argminsizes ( const Token * ftok@var342 , int argnr@var343 ) const {
420: const ArgumentChecks * arg@var344 ; arg@var344 =@expr1073744425 getarg (@expr1073744426 ftok@var342 , argnr@var343 ) ;
421: return arg@var344 ?@expr1073744427 &@expr1073744428 arg@var344 .@expr1073744429 minsizes@var345 :@expr1073744430 nullptr ;
422: }
423:
424: ArgumentChecks :: Direction getArgDirection ( const Token * ftok@var346 , int argnr@var347 ) const ;
425:
426: bool markupFile ( const std :: string & path@var348 ) const ;
427:
428: bool processMarkupAfterCode ( const std :: string & path@var349 ) const ;
429:
430: const std :: set < std :: string > & markupExtensions ( ) const {
431: return mMarkupExtensions@var453 ;
432: }
433:
434: bool reportErrors ( const std :: string & path@var350 ) const ;
435:
436: bool ignorefunction ( const std :: string & functionName@var351 ) const ;
437:
438: bool isexecutableblock ( const std :: string & file@var352 , const std :: string & token@var353 ) const ;
439:
440: int blockstartoffset ( const std :: string & file@var354 ) const ;
441:
442: const std :: string & blockstart ( const std :: string & file@var355 ) const ;
443: const std :: string & blockend ( const std :: string & file@var356 ) const ;
444:
445: bool iskeyword ( const std :: string & file@var357 , const std :: string & keyword@var358 ) const ;
446:
447: bool isexporter ( const std :: string & prefix@var359 ) const {
448: return mExporters@var456 .@expr1073744431 find (@expr1073744432 prefix@var359 ) !=@expr1073744433 mExporters@var456 .@expr1073744434 end (@expr1073744435 ) ;
449: }
450:
451: bool isexportedprefix ( const std :: string & prefix@var360 , const std :: string & token@var361 ) const {
452: const std ::@expr1073744436 map < std ::@expr1073744437 string , ExportedFunctions > ::@expr1073744438 const_iterator it@var362 =@expr1073744439 mExporters@var456 .@expr1073744440 find (@expr1073744441 prefix@var360 ) ;
453: return (@expr1073744442 it@var362 !=@expr1073744443 mExporters@var456 .@expr1073744444 end (@expr1073744445 ) &&@expr1073744446 it@var362 .@expr1073744447 second@var363 .@expr1073744448 isPrefix (@expr1073744449 token@var361 ) ) ;
454: }
455:
456: bool isexportedsuffix ( const std :: string & prefix@var364 , const std :: string & token@var365 ) const {
457: const std ::@expr1073744450 map < std ::@expr1073744451 string , ExportedFunctions > ::@expr1073744452 const_iterator it@var366 =@expr1073744453 mExporters@var456 .@expr1073744454 find (@expr1073744455 prefix@var364 ) ;
458: return (@expr1073744456 it@var366 !=@expr1073744457 mExporters@var456 .@expr1073744458 end (@expr1073744459 ) &&@expr1073744460 it@var366 .@expr1073744461 second@var367 .@expr1073744462 isSuffix (@expr1073744463 token@var365 ) ) ;
459: }
460:
461: bool isimporter ( const std :: string & file@var368 , const std :: string & importer@var369 ) const ;
462:
463: const Token * getContainerFromYield ( const Token * tok@var370 , Container :: Yield yield@var371 ) const ;
464: const Token * getContainerFromAction ( const Token * tok@var372 , Container :: Action action@var373 ) const ;
465:
466: bool isreflection ( const std :: string & token@var374 ) const {
467: return mReflection@var458 .@expr1073744464 find (@expr1073744465 token@var374 ) !=@expr1073744466 mReflection@var458 .@expr1073744467 end (@expr1073744468 ) ;
468: }
469:
470: int reflectionArgument ( const std :: string & token@var375 ) const {
471: const std ::@expr1073744469 map < std ::@expr1073744470 string , int > ::@expr1073744471 const_iterator it@var376 =@expr1073744472 mReflection@var458 .@expr1073744473 find (@expr1073744474 token@var375 ) ;
472: if (@expr1073744475 it@var376 !=@expr1073744476 mReflection@var458 .@expr1073744477 end (@expr1073744478 ) ) {
473: return it@var376 .@expr1073744479 second@var377 ; }
474: return -1 ;
475: }
476:
477: std :: vector < std :: string > defines@var378 ;
478:
479: struct SmartPointer {
480: std :: string name@var379 ; name@var379 = "" ;
481: bool unique@var380 ; unique@var380 = false ;
482: } ;
483:
484: std :: map < std :: string , SmartPointer > smartPointers@var381 ;
485: bool isSmartPointer ( const Token * tok@var382 ) const ;
486: const SmartPointer * detectSmartPointer ( const Token * tok@var383 ) const ;
487:
488: struct PodType {
489: unsigned int size@var384 ;
490: char sign@var385 ;
491: enum class Type { NO , BOOL , CHAR , SHORT , INT , LONG , LONGLONG } ; enum Type stdtype@var386 ;
492: } ;
493: const struct PodType * podtype ( const std :: string & name@var387 ) const {
494: const std ::@expr1073744480 unordered_map < std ::@expr1073744481 string , PodType > ::@expr1073744482 const_iterator it@var388 =@expr1073744483 mPodTypes@var459 .@expr1073744484 find (@expr1073744485 name@var387 ) ;
495: return (@expr2662 it@var388 !=@expr1073744487 mPodTypes@var459 .@expr1073744488 end (@expr1073744489 ) ) ?@expr1073744490 &@expr1073744491 (@expr2662 it@var388 .@expr1073744493 second@var389 ) :@expr1073744494 nullptr ;
496: }
497:
498: struct PlatformType {
499: PlatformType ( )
500: : mSigned@var400 ( false )
501: , mUnsigned@var401 ( false )
502: , mLong@var402 ( false )
503: , mPointer@var403 ( false )
504: , mPtrPtr@var404 ( false )
505: , mConstPtr@var405 ( false ) { }
506: bool operator== ( const PlatformType & type@var390 ) const {
507: return (@expr1073744495 mSigned@var400 ==@expr1073744496 type@var390 .@expr1073744497 mSigned@var391 &&@expr1073744498
508: mUnsigned@var401 ==@expr1073744499 type@var390 .@expr1073744500 mUnsigned@var392 &&@expr1073744501
509: mLong@var402 ==@expr1073744502 type@var390 .@expr1073744503 mLong@var393 &&@expr1073744504
510: mPointer@var403 ==@expr1073744505 type@var390 .@expr1073744506 mPointer@var394 &&@expr1073744507
511: mPtrPtr@var404 ==@expr1073744508 type@var390 .@expr1073744509 mPtrPtr@var395 &&@expr1073744510
512: mConstPtr@var405 ==@expr1073744511 type@var390 .@expr1073744512 mConstPtr@var396 &&@expr1073744513
513: mType@var399 ==@expr1073744514 type@var390 .@expr1073744515 mType@var397 ) ;
514: }
515: bool operator!= ( const PlatformType & type@var398 ) const {
516: return !@expr1073744516 (@expr1073744517 *@expr1073744518 this@expr1073744519 ==@expr1073744520 type@var398 ) ;
517: }
518: std :: string mType@var399 ;
519: bool mSigned@var400 ;
520: bool mUnsigned@var401 ;
521: bool mLong@var402 ;
522: bool mPointer@var403 ;
523: bool mPtrPtr@var404 ;
524: bool mConstPtr@var405 ;
525: } ;
526:
527: struct Platform {
528: const PlatformType * platform_type ( const std :: string & name@var406 ) const {
529: const std ::@expr1073744521 map < std ::@expr1073744522 string , PlatformType > ::@expr1073744523 const_iterator it@var407 =@expr1073744524 mPlatformTypes@var409 .@expr1073744525 find (@expr1073744526 name@var406 ) ;
530: return (@expr2703 it@var407 !=@expr1073744528 mPlatformTypes@var409 .@expr1073744529 end (@expr1073744530 ) ) ?@expr1073744531 &@expr1073744532 (@expr2703 it@var407 .@expr1073744534 second@var408 ) :@expr1073744535 nullptr ;
531: }
532: std :: map < std :: string , PlatformType > mPlatformTypes@var409 ;
533: } ;
534:
535: const PlatformType * platform_type ( const std :: string & name@var410 , const std :: string & platform@var411 ) const {
536: const std ::@expr1073744536 map < std ::@expr2713 string , Platform > ::@expr1073744538 const_iterator it@var412 =@expr1073744539 mPlatforms@var461 .@expr1073744540 find (@expr1073744541 platform@var411 ) ;
537: if (@expr1073744542 it@var412 !=@expr1073744543 mPlatforms@var461 .@expr1073744544 end (@expr1073744545 ) ) {
538: const PlatformType * const type@var413 ; type@var413 =@expr1073744546 it@var412 .@expr1073744547 second@var414 .@expr1073744548 platform_type (@expr1073744549 name@var410 ) ;
539: if (@expr1073744550 type@var413 ) {
540: return type@var413 ; }
541: }
542:
543: const std ::@expr1073744551 map < std ::@expr2713 string , PlatformType > ::@expr1073744553 const_iterator it2@var415 =@expr1073744554 mPlatformTypes@var460 .@expr1073744555 find (@expr1073744556 name@var410 ) ;
544: return (@expr2733 it2@var415 !=@expr1073744558 mPlatformTypes@var460 .@expr1073744559 end (@expr1073744560 ) ) ?@expr1073744561 &@expr1073744562 (@expr2733 it2@var415 .@expr1073744564 second@var416 ) :@expr1073744565 nullptr ;
545: }
546:
|
549:
550: std :: string getFunctionName ( const Token * ftok@var417 ) const ;
551:
552: static bool isContainerYield ( const Token * const cond@var418 , Library :: Container :: Yield y@var419 , const std :: string & fallback@var420 = "" ) ;
553:
554:
555: enum class TypeCheck { def , check , suppress } ;
556: TypeCheck getTypeCheck ( const std :: string & check@var421 , const std :: string & typeName@var422 ) const ;
557:
558: private:
559:
560: Error loadFunction ( const tinyxml2 :: XMLElement * const node@var423 , const std :: string & name@var424 , std :: set < std :: string > & unknown_elements@var425 ) ;
561:
562: class ExportedFunctions {
563: public:
564: void addPrefix ( const std :: string & prefix@var426 ) {
565: mPrefixes@var430 .@expr1073744566 insert (@expr1073744567 prefix@var426 ) ;
566: }
567: void addSuffix ( const std :: string & suffix@var427 ) {
568: mSuffixes@var431 .@expr1073744568 insert (@expr1073744569 suffix@var427 ) ;
569: }
570: bool isPrefix ( const std :: string & prefix@var428 ) const {
571: return (@expr1073744570 mPrefixes@var430 .@expr1073744571 find (@expr1073744572 prefix@var428 ) !=@expr1073744573 mPrefixes@var430 .@expr1073744574 end (@expr1073744575 ) ) ;
572: }
573: bool isSuffix ( const std :: string & suffix@var429 ) const {
574: return (@expr1073744576 mSuffixes@var431 .@expr1073744577 find (@expr1073744578 suffix@var429 ) !=@expr1073744579 mSuffixes@var431 .@expr1073744580 end (@expr1073744581 ) ) ;
575: }
576:
577: private:
578: std :: set < std :: string > mPrefixes@var430 ;
579: std :: set < std :: string > mSuffixes@var431 ;
580: } ;
581: class CodeBlock {
582: public:
583: CodeBlock ( ) : mOffset@var439 ( 0 ) { }
584:
585: void setStart ( const char * s@var432 ) {
586: mStart@var437 =@expr1073744582 s@var432 ;
587: }
588: void setEnd ( const char * e@var433 ) {
589: mEnd@var438 =@expr1073744583 e@var433 ;
590: }
591: void setOffset ( const int o@var434 ) {
592: mOffset@var439 =@expr1073744584 o@var434 ;
593: }
594: void addBlock ( const char * blockName@var435 ) {
595: mBlocks@var440 .@expr1073744585 insert (@expr1073744586 blockName@var435 ) ;
596: }
597: const std :: string & start ( ) const {
598: return mStart@var437 ;
599: }
600: const std :: string & end ( ) const {
601: return mEnd@var438 ;
602: }
603: int offset ( ) const {
604: return mOffset@var439 ;
605: }
606: bool isBlock ( const std :: string & blockName@var436 ) const {
607: return mBlocks@var440 .@expr1073744587 find (@expr1073744588 blockName@var436 ) !=@expr1073744589 mBlocks@var440 .@expr1073744590 end (@expr1073744591 ) ;
608: }
609:
610: private:
611: std :: string mStart@var437 ;
612: std :: string mEnd@var438 ;
613: int mOffset@var439 ;
614: std :: set < std :: string > mBlocks@var440 ;
615: } ;
616: enum class FalseTrueMaybe { False , True , Maybe } ;
617: int mAllocId@var441 ;
618: std :: set < std :: string > mFiles@var442 ;
619: std :: map < std :: string , AllocFunc > mAlloc@var443 ;
620: std :: map < std :: string , AllocFunc > mDealloc@var444 ;
621: std :: map < std :: string , AllocFunc > mRealloc@var445 ;
622: std :: unordered_map < std :: string , FalseTrueMaybe > mNoReturn@var446 ;
623: std :: map < std :: string , std :: string > mReturnValue@var447 ;
624: std :: map < std :: string , std :: string > mReturnValueType@var448 ;
625: std :: map < std :: string , int > mReturnValueContainer@var449 ;
626: std :: map < std :: string , std :: vector < long long > > mUnknownReturnValues@var450 ;
627: std :: map < std :: string , bool > mReportErrors@var451 ;
628: std :: map < std :: string , bool > mProcessAfterCode@var452 ;
629: std :: set < std :: string > mMarkupExtensions@var453 ;
630: std :: map < std :: string , std :: set < std :: string > > mKeywords@var454 ;
631: std :: map < std :: string , CodeBlock > mExecutableBlocks@var455 ;
632: std :: map < std :: string , ExportedFunctions > mExporters@var456 ;
633: std :: map < std :: string , std :: set < std :: string > > mImporters@var457 ;
634: std :: map < std :: string , int > mReflection@var458 ;
635: std :: unordered_map < std :: string , PodType > mPodTypes@var459 ;
636: std :: map < std :: string , PlatformType > mPlatformTypes@var460 ;
637: std :: map < std :: string , Platform > mPlatforms@var461 ;
638: std :: map < std :: pair < std :: string , std :: string > , TypeCheck > mTypeChecks@var462 ;
639: std :: unordered_map < std :: string , NonOverlappingData > mNonOverlappingData@var463 ;
640:
641: const ArgumentChecks * getarg ( const Token * ftok@var464 , int argnr@var465 ) const ;
642:
643: std :: string getFunctionName ( const Token * ftok@var466 , bool * error@var467 ) const ;
644:
645: static const AllocFunc * getAllocDealloc ( const std :: map < std :: string , AllocFunc > & data@var468 , const std :: string & name@var469 ) {
646: const std ::@expr1073744592 map < std ::@expr1073744593 string , AllocFunc > ::@expr1073744594 const_iterator it@var470 =@expr1073744595 data@var468 .@expr1073744596 find (@expr1073744597 name@var469 ) ;
647: return (@expr1073744598 it@var470 ==@expr1073744599 data@var468 .@expr1073744600 end (@expr1073744601 ) ) ?@expr1073744602 nullptr :@expr1073744603 &@expr1073744604 it@var470 .@expr1073744605 second@var471 ;
648: }
649: } ;
650:
651: const Library :: Container * getLibraryContainer ( const Token * tok@var472 ) ;
652:
653: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var473 ,
654: const Settings * settings@var474 ,
655: std :: unordered_map < int , const Token * > * lookupVarId@var475 = nullptr ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var476 ) const {
54: x@var476 ++@expr1073744606 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var477 ) const {
60: x@var477 --@expr1073744607 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var478 , const U & y@var479 ) const {
67: return x@var478 <@expr1073744608 y@var479 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var480 , const U & y@var481 ) const {
74: return std ::@expr1073744609 abs (@expr1073744610 x@var480 -@expr1073744611 y@var481 ) ==@expr1073744612 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var482 , T x@var483 , U y@var484 ) const {
81: result@var482 =@expr1073744613 !@expr1073744614 (@expr1073744615 x@var483 >@expr1073744616 y@var484 ||@expr1073744617 x@var483 <@expr1073744618 y@var484 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var485 = 0 , Bound b@var486 = Bound :: Point )
91: : valueType@var526 ( ValueType :: INT ) ,
92: bound@var527 ( b@var486 ) ,
93: intvalue@var528 ( val@var485 ) ,
94: tokvalue@var529 ( nullptr ) ,
95: floatValue@var530 ( 0.0 ) ,
96: moveKind@var531 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var532 ( val@var485 ) ,
98: condition@var533 ( nullptr ) ,
99: varId@var535 ( 0U ) ,
100: safe@var536 ( false ) ,
101: conditional@var537 ( false ) ,
102: macro@var538 ( false ) ,
103: defaultArg@var539 ( false ) ,
104: indirect@var540 ( 0 ) ,
105: path@var541 ( 0 ) ,
106: wideintvalue@var542 ( val@var485 ) ,
107: subexpressions@var543 ( ) ,
108: capturetok@var544 ( nullptr ) ,
109: lifetimeKind@var545 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var546 ( LifetimeScope :: Local ) ,
111: valueKind@var551 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var487 , long long val@var488 , Bound b@var489 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var490 ) const {
118: if (@expr1073744619 valueType@var526 !=@expr1073744620 rhs@var490 .@expr1073744621 valueType@var491 ) {
119: return false ; }
120: switch (@expr1073744622 valueType@var526 ) {
121: case ValueType ::@expr1073744623 INT :@expr2800
122: case ValueType ::@expr1073744625 CONTAINER_SIZE :@expr2800
123: case ValueType ::@expr1073744627 BUFFER_SIZE :@expr2800
124: case ValueType ::@expr1073744629 ITERATOR_START :@expr2800
125: case ValueType ::@expr1073744631 ITERATOR_END :@expr2800 ;
126: if (@expr2809 intvalue@var528 !=@expr2810 rhs@var490 .@expr2811 intvalue@var492 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073744636 TOK :@expr2800 ;
130: if (@expr2814 tokvalue@var529 !=@expr2815 rhs@var490 .@expr2816 tokvalue@var493 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073744641 FLOAT :@expr2800 ;
134:
135: if (@expr1073744643 floatValue@var530 >@expr1073744644 rhs@var490 .@expr2821 floatValue@var494 ||@expr1073744646 floatValue@var530 <@expr1073744647 rhs@var490 .@expr2821 floatValue@var494 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073744649 MOVED :@expr2800 ;
139: if (@expr1073744651 moveKind@var531 !=@expr1073744652 rhs@var490 .@expr1073744653 moveKind@var495 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073744654 UNINIT :@expr2800 ;
143: break ;
144: case ValueType ::@expr1073744656 LIFETIME :@expr2800 ;
145: if (@expr2814 tokvalue@var529 !=@expr2815 rhs@var490 .@expr2816 tokvalue@var493 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073744661 SYMBOLIC :@expr2800 ;
149: if (@expr1073744663 !@expr1073744664 sameToken (@expr1073744665 tokvalue@var529 , rhs@var490 .@expr2816 tokvalue@var493 ) ) {
150: return false ; }
151: if (@expr2809 intvalue@var528 !=@expr2810 rhs@var490 .@expr2811 intvalue@var492 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var496 , F f@var497 ) {
160: switch (@expr1073744670 self@var496 .@expr1073744671 valueType@var498 ) {
161: case ValueType ::@expr1073744672 INT :@expr2849
162: case ValueType ::@expr1073744674 SYMBOLIC :@expr2849
163: case ValueType ::@expr1073744676 BUFFER_SIZE :@expr2849
164: case ValueType ::@expr1073744678 CONTAINER_SIZE :@expr2849
165: case ValueType ::@expr1073744680 ITERATOR_START :@expr2849
166: case ValueType ::@expr1073744682 ITERATOR_END :@expr2849 ; {
167: f@var497 (@expr1073744684 self@var496 .@expr1073744685 intvalue@var499 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073744686 FLOAT :@expr2849 ; {
171: f@var497 (@expr1073744688 self@var496 .@expr1073744689 floatValue@var500 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073744690 UNINIT :@expr2849
175: case ValueType ::@expr1073744692 TOK :@expr2849
176: case ValueType ::@expr1073744694 LIFETIME :@expr2849
177: case ValueType ::@expr1073744696 MOVED :@expr2849 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var501 , Compare compare@var502 , T x@var503 , U y@var504 ) const {
186: result@var501 =@expr1073744698 compare@var502 (@expr1073744699 x@var503 , y@var504 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var505 , const Value & rhs@var506 , Compare compare@var507 , T x@var508 ) const {
191: visitValue (@expr1073744701 rhs@var506 ,
192: std ::@expr1073744702 bind (@expr1073744703 innerVisitor {@expr1073744704 } , std ::@expr1073744705 ref (@expr1073744706 result@var505 ) , std ::@expr1073744707 move (@expr1073744708 compare@var507 ) , x@var508 , std ::@expr1073744709 placeholders ::@expr1073744710 _1@expr1073744700 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var509 , Compare compare@var510 ) const {
198: assert (@expr1073744712 (@expr1073744713 !@expr1073744714 this@expr2891 .@expr1073744716 isSymbolicValue (@expr1073744717 ) &&@expr1073744718 !@expr1073744719 rhs@var509 .@expr1073744720 isSymbolicValue (@expr1073744721 ) ) ||@expr1073744722
199: (@expr1073744723 this@expr2891 .@expr1073744724 valueType@var526 ==@expr1073744725 rhs@var509 .@expr1073744726 valueType@var511 &&@expr1073744727 sameToken (@expr1073744728 this@expr2891 .@expr1073744729 tokvalue@var529 , rhs@var509 .@expr1073744730 tokvalue@var512 ) ) ) ;
200: bool result@var513 ; result@var513 =@expr1073744731 false ;
201: visitValue (@expr1073744732
202: *@expr1073744733 this@expr2891 ,
203: std ::@expr1073744734 bind (@expr1073744735 compareVisitor {@expr1073744736 } , std ::@expr2913 ref (@expr1073744738 result@var513 ) , std ::@expr2913 ref (@expr1073744740 rhs@var509 ) , std ::@expr1073744741 move (@expr1073744742 compare@var510 ) , std ::@expr1073744743 placeholders ::@expr1073744744 _1@expr1073744711 ) ) ;
204: return result@var513 ;
205: }
206:
207: bool operator== ( const Value & rhs@var514 ) const {
208: if (@expr1073744745 !@expr1073744746 equalValue (@expr1073744747 rhs@var514 ) ) {
209: return false ; }
210:
211: return varvalue@var532 ==@expr1073744748 rhs@var514 .@expr1073744749 varvalue@var515 &&@expr1073744750
212: condition@var533 ==@expr1073744751 rhs@var514 .@expr1073744752 condition@var516 &&@expr1073744753
213: varId@var535 ==@expr1073744754 rhs@var514 .@expr1073744755 varId@var517 &&@expr1073744756
214: conditional@var537 ==@expr1073744757 rhs@var514 .@expr1073744758 conditional@var518 &&@expr1073744759
215: defaultArg@var539 ==@expr1073744760 rhs@var514 .@expr1073744761 defaultArg@var519 &&@expr1073744762
216: indirect@var540 ==@expr1073744763 rhs@var514 .@expr1073744764 indirect@var520 &&@expr1073744765
217: valueKind@var551 ==@expr1073744766 rhs@var514 .@expr1073744767 valueKind@var521 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var522 ) const {
221: return !@expr1073744768 (@expr1073744769 *@expr1073744770 this@expr1073744771 ==@expr1073744772 rhs@var522 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var523 ) const {
226: bool result@var524 ; result@var524 =@expr1073744774 false ;
227: visitValue (@expr1073744775 *@expr1073744776 this@expr1073744777 , std ::@expr1073744778 bind (@expr1073744779 equalVisitor {@expr1073744780 } , std ::@expr1073744781 ref (@expr1073744782 result@var524 ) , x@var523 , std ::@expr1073744783 placeholders ::@expr1073744784 _1@expr1073744773 ) ) ;
228: return result@var524 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073744785 bound@var527 ==@expr1073744786 Bound ::@expr1073744787 Lower ) {
233: visitValue (@expr1073744788 *@expr2965 this@expr2966 , increment {@expr1073744791 } ) ; }
234: else { if (@expr1073744792 bound@var527 ==@expr1073744793 Bound ::@expr1073744794 Upper ) {
235: visitValue (@expr1073744795 *@expr2965 this@expr2966 , decrement {@expr1073744797 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073744798 bound@var527 ==@expr1073744799 Bound ::@expr2976 Lower ) {
240: bound@var527 =@expr1073744801 Bound ::@expr2978 Upper ; }
241: else { if (@expr1073744803 bound@var527 ==@expr1073744804 Bound ::@expr2978 Upper ) {
242: bound@var527 =@expr1073744806 Bound ::@expr2976 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073744808 ) ;
247: decreaseRange (@expr1073744809 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var525 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var526 ;
267: bool isIntValue ( ) const {
268: return valueType@var526 ==@expr1073744810 ValueType ::@expr1073744811 INT ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var526 ==@expr1073744812 ValueType ::@expr1073744813 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var526 ==@expr1073744814 ValueType ::@expr1073744815 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var526 ==@expr1073744816 ValueType ::@expr1073744817 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var526 ==@expr1073744818 ValueType ::@expr1073744819 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var526 ==@expr1073744820 ValueType ::@expr1073744821 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var526 ==@expr1073744822 ValueType ::@expr1073744823 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var526 ==@expr1073744824 ValueType ::@expr1073744825 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var526 ==@expr1073744826 ValueType ::@expr1073744827 ITERATOR_START ||@expr1073744828 valueType@var526 ==@expr1073744829 ValueType ::@expr1073744830 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var526 ==@expr1073744831 ValueType ::@expr1073744832 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var526 ==@expr1073744833 ValueType ::@expr1073744834 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var526 ==@expr1073744835 ValueType ::@expr1073744836 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var526 ==@expr1073744838 ValueType ::@expr1073744839 LIFETIME &&@expr1073744840 lifetimeScope@var546 ==@expr1073744841 LifetimeScope ::@expr1073744842 Local@expr1073744837 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var526 ==@expr1073744843 ValueType ::@expr1073744844 LIFETIME &&@expr1073744845 lifetimeScope@var546 ==@expr1073744846 LifetimeScope ::@expr1073744847 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var526 ==@expr1073744848 ValueType ::@expr1073744849 LIFETIME &&@expr1073744850 lifetimeScope@var546 ==@expr1073744851 LifetimeScope ::@expr1073744852 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073744853 ) ||@expr1073744854 isUninitValue (@expr1073744855 ) ||@expr1073744856 isLifetimeValue (@expr1073744857 ) ;
318: }
319:
320:
321: Bound bound@var527 ;
322:
323:
324: long long intvalue@var528 ;
325:
326:
327: const Token * tokvalue@var529 ;
328:
329:
330: double floatValue@var530 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var531 ;
334:
335:
336: long long varvalue@var532 ;
337:
338:
339: const Token * condition@var533 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var534 ;
342:
343:
344: int varId@var535 ;
345:
346:
347: bool safe@var536 ;
348:
349:
350: bool conditional@var537 ;
351:
352:
353: bool macro@var538 ;
354:
355:
356: bool defaultArg@var539 ;
357:
358: int indirect@var540 ;
359:
360:
361: long long path@var541 ;
362:
363:
364: long long wideintvalue@var542 ;
365:
366: std :: vector < std :: string > subexpressions@var543 ;
367:
368:
369: const Token * capturetok@var544 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var545 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var546 ;
385:
386: static const char * toString ( MoveKind moveKind@var547 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var548 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var549 ) ;
389: static const char * toString ( Bound bound@var550 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var551 ;
402:
403: void setKnown ( ) {
404: valueKind@var551 =@expr1073744858 ValueKind ::@expr1073744859 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var551 ==@expr1073744860 ValueKind ::@expr1073744861 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var551 =@expr1073744863 ValueKind ::@expr1073744864 Possible@expr1073744862 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var551 ==@expr1073744866 ValueKind ::@expr1073744867 Possible@expr1073744865 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var551 ==@expr1073744868 ValueKind ::@expr1073744869 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var551 =@expr1073744870 ValueKind ::@expr1073744871 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var552 = true ) {
428: if (@expr1073744872 inconclusive@var552 ) {
429: valueKind@var551 =@expr1073744873 ValueKind ::@expr1073744874 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var551 ==@expr1073744875 ValueKind ::@expr1073744876 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073744878 isKnown (@expr1073744879 ) ) {
438: valueKind@var551 =@expr1073744880 ValueKind ::@expr1073744881 Possible@expr1073744877 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073744882 condition@var533 &&@expr1073744883 !@expr1073744884 defaultArg@var539 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var553 , const Token * tok2@var554 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var555 , const Settings * settings@var556 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var557 , SymbolDatabase * symboldatabase@var558 , ErrorLogger * errorLogger@var559 , const Settings * settings@var560 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var561 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var562 , const Settings * settings@var563 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var564 ,
459: const Settings * settings@var565 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var566 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var567 , const Token * indexTok@var568 , bool possible@var569 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var570 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var571 , const Settings * settings@var572 = nullptr , int depth@var573 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var574 ;
471: bool addressOf@var575 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var576 ;
473: bool inconclusive@var577 ;
474:
475: LifetimeToken ( ) : token@var574 ( nullptr ) , addressOf@var575 ( false ) , errorPath@var576 ( ) , inconclusive@var577 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var578 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var579 )
478: : token@var574 ( token@var578 ) , addressOf@var575 ( false ) , errorPath@var576 ( std :: move ( errorPath@var579 ) ) , inconclusive@var577 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var580 , bool addressOf@var581 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var582 )
482: : token@var574 ( token@var580 ) , addressOf@var575 ( addressOf@var581 ) , errorPath@var576 ( std :: move ( errorPath@var582 ) ) , inconclusive@var577 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var583 , bool b@var584 ) {
486: for (@expr1073744885 LifetimeToken &@expr1073744886 x@var585 :@expr1073744887 v@var583 ) {
487: x@var585 .@expr1073744888 addressOf@var586 =@expr1073744889 b@var584 ; }
488: return v@var583 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var587 , bool b@var588 ) {
492: for (@expr1073744890 LifetimeToken &@expr1073744891 x@var589 :@expr1073744892 v@var587 ) {
493: x@var589 .@expr1073744893 inconclusive@var590 =@expr1073744894 b@var588 ; }
494: return v@var587 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var591 , ValueFlow :: Value & true_value@var592 , ValueFlow :: Value & false_value@var593 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var594 ) ;
499: const Token * parseCompareInt ( const Token * tok@var595 , ValueFlow :: Value & true_value@var596 , ValueFlow :: Value & false_value@var597 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var598 , long long val@var599 , const Token * varTok@var600 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var601 , const Token * varTok@var602 , long long val@var603 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var604 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var605 ,
508: ValueFlow :: Value & value@var606 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var607 ,
511: bool escape@var608 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var609 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var610 , const Token * lifetime@var611 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var612 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var613 , bool * addressOf@var614 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var615 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var616 , const Settings * settings@var617 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var618 , const ValueFlow :: Value * val@var619 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var620 , const ValueFlow :: Value * val@var621 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var622 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var623 , bool inconclusive@var624 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var625 ,
529: bool inconclusive@var626 = false ,
530: long long path@var627 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var628 , const Scope * defaultScope@var629 = nullptr , bool smallest@var630 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var631 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var632 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var633 ;
69: std :: string mScope@var634 ;
70: std :: string mName@var635 ;
71: std :: string mFullName@var636 ;
72: const Token * mNameToken@var637 ;
73: const Token * mParamEnd@var638 ;
74: unsigned int mFlags@var639 ;
75:
76: enum Anonymous0 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var640 ) {
90: setFlag (@expr1073744895 fIsClass , state@var640 ) ;
91: }
92: void isFunction ( bool state@var641 ) {
93: setFlag (@expr1073744896 fIsFunction , state@var641 ) ;
94: }
95: void isVariable ( bool state@var642 ) {
96: setFlag (@expr1073744897 fIsVariable , state@var642 ) ;
97: }
98: void isAlias ( bool state@var643 ) {
99: setFlag (@expr1073744898 fIsAlias , state@var643 ) ;
100: }
101: void isSpecialization ( bool state@var644 ) {
102: setFlag (@expr1073744899 fIsSpecialization , state@var644 ) ;
103: }
104: void isPartialSpecialization ( bool state@var645 ) {
105: setFlag (@expr1073744900 fIsPartialSpecialization , state@var645 ) ;
106: }
107: void isForwardDeclaration ( bool state@var646 ) {
108: setFlag (@expr1073744901 fIsForwardDeclaration , state@var646 ) ;
109: }
110: void isVariadic ( bool state@var647 ) {
111: setFlag (@expr1073744902 fIsVariadic , state@var647 ) ;
112: }
113: void isFriend ( bool state@var648 ) {
114: setFlag (@expr1073744903 fIsFriend , state@var648 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var649 ) const {
123: return (@expr3080 (@expr3080 mFlags@var639 &@expr1073744906 flag@var649 ) !=@expr1073744907 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var650 , bool state@var651 ) {
132: mFlags@var639 =@expr1073744908 state@var651 ?@expr1073744909 mFlags@var639 |@expr1073744910 flag@var650 :@expr1073744911 mFlags@var639 &@expr1073744912 ~@expr1073744913 flag@var650 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var652 , const std :: string & scope@var653 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var654 , const std :: string & scope@var655 , const Token * nameToken@var656 , const Token * paramEnd@var657 ) ;
150: TokenAndName ( const TokenAndName & other@var658 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var659 ) const {
154: return mToken@var633 ==@expr1073744914 rhs@var659 .@expr1073744915 mToken@var660 &&@expr1073744916 mScope@var634 ==@expr1073744917 rhs@var659 .@expr1073744918 mScope@var661 &&@expr1073744919 mName@var635 ==@expr1073744920 rhs@var659 .@expr1073744921 mName@var662 &&@expr1073744922 mFullName@var636 ==@expr1073744923 rhs@var659 .@expr1073744924 mFullName@var663 &&@expr1073744925
155: mNameToken@var637 ==@expr1073744926 rhs@var659 .@expr1073744927 mNameToken@var664 &&@expr1073744928 mParamEnd@var638 ==@expr1073744929 rhs@var659 .@expr1073744930 mParamEnd@var665 &&@expr1073744931 mFlags@var639 ==@expr1073744932 rhs@var659 .@expr1073744933 mFlags@var666 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var633 ;
160: }
161: void token ( Token * token@var667 ) {
162: mToken@var633 =@expr1073744934 token@var667 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var634 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var635 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var636 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var637 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var638 ;
178: }
179: void paramEnd ( const Token * end@var668 ) {
180: mParamEnd@var638 =@expr1073744935 end@var668 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073744936 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073744937 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073744938 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073744939 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073744940 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073744941 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073744942 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073744943 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073744944 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var669 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var670 ) const {
243:
244:
245: return (@expr3121 (@expr3121 mFlags@var639 &@expr1073744947 fFamilyMask ) &@expr1073744948 (@expr3121 decl@var670 .@expr1073744950 mFlags@var671 &@expr1073744951 fFamilyMask ) ) !=@expr1073744952 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var672 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var673 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var674 , const unsigned long numberOfArguments@var675 , bool variadic@var676 , const char patternAfter@var677 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var678 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var679 , int & namepos@var680 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var681 , int & namepos@var682 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var683 , int & namepos@var684 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var685 ,
306: bool & codeWithTemplates@var686 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var687 , bool isTemplate@var688 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var689 = nullptr , Token * backToken@var690 = nullptr , bool isTemplate@var691 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var692 , Token * end@var693 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var694 , const std :: string & scope@var695 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var696 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var697 ,
393: const std :: list < const Token * > & specializations@var698 ,
394: const std :: time_t maxtime@var699 ,
395: std :: set < std :: string > & expandedtemplates@var700 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var701 , const Token * tok@var702 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var703 , const Token * tok@var704 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var705 ,
422: const TokenAndName & templateInstantiation@var706 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var707 ,
424: const std :: string & newName@var708 ,
425: bool copy@var709 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var710 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var711 ,
435: const std :: string & newName@var712 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var713 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var714 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var715 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var716 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var717 ,
458: const Token * templateInstantiationNameToken@var718 ,
459: const std :: list < const Token * > & specializations@var719 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var720 , const Token * end@var721 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var722 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var723 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var724 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var725 ,
487: const std :: string & indent@var726 = "    " ) const ;
488: void printOut ( const std :: string & text@var727 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var728 ;
491: TokenList & mTokenList@var729 ;
492: const Settings * mSettings@var730 ;
493: ErrorLogger * mErrorLogger@var731 ;
494: bool mChanged@var732 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var733 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var734 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var735 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var736 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var737 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var738 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var739 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var740 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var741 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var742 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var743 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var744 ;
57: Token * back@var745 ;
58: const TokenList * list@var746 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var747 , const Token * bodyEnd_@var748 , const std :: set < std :: string > & usingNamespaces_@var749 = std :: set < std :: string > ( ) ) : name@var750 ( name_@var747 ) , bodyEnd@var751 ( bodyEnd_@var748 ) , usingNamespaces@var752 ( usingNamespaces_@var749 ) { }
63: std :: string name@var750 ;
64: const Token * const bodyEnd@var751 ;
65: std :: set < std :: string > usingNamespaces@var752 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var753 ;
70: int mFileIndex@var754 ;
71: int mLineNumber@var755 ;
72: int mColumn@var756 ;
73: int mExprId@var757 ;
74:
75:
76: Token * mAstOperand1@var758 ;
77: Token * mAstOperand2@var759 ;
78: Token * mAstParent@var760 ;
79:
80:
81: const Scope * mScope@var761 ;
82: union {
83: const Function * mFunction@var762 ;
84: const Variable * mVariable@var763 ;
85: const :: Type * mType@var764 ;
86: const Enumerator * mEnumerator@var765 ;
87: } ;
88:
|
92:
93: int mProgressValue@var766 ;
94:
|
97:
98: int mIndex@var767 ;
99:
100:
101: std :: string * mOriginalName@var768 ;
102:
103:
104: ValueType * mValueType@var769 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var770 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var771 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var772 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var773 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var774 ;
119: long long value@var775 ;
120: struct CppcheckAttributes * next@var776 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var777 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var778 ;
126:
127:
128: unsigned char mBits@var779 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var780 , long long value@var781 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var782 , long long * value@var783 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var753 ( 0 )
135: , mFileIndex@var754 ( 0 )
136: , mLineNumber@var755 ( 0 )
137: , mColumn@var756 ( 0 )
138: , mExprId@var757 ( 0 )
139: , mAstOperand1@var758 ( nullptr )
140: , mAstOperand2@var759 ( nullptr )
141: , mAstParent@var760 ( nullptr )
142: , mScope@var761 ( nullptr )
143: , mFunction@var762 ( nullptr )
144: , mProgressValue@var766 ( 0 )
145: , mIndex@var767 ( 0 )
146: , mOriginalName@var768 ( nullptr )
147: , mValueType@var769 ( nullptr )
148: , mValues@var770 ( nullptr )
149: , mTemplateSimplifierPointers@var772 ( nullptr )
150: , mScopeInfo@var773 ( nullptr )
151: , mCppcheckAttributes@var777 ( nullptr )
152: , mCpp11init@var778 ( Cpp11init :: UNKNOWN )
153: , mBits@var779 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var784 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var785 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var786 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var787 ) {
199: mStr@var999 =@expr1073744953 s@var787 ;
200: mImpl@var1005 .@expr1073744954 mVarId@var1036 =@expr1073744955 0 ;
201:
202: update_property_info (@expr1073744956 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var788 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var999 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var789 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var790 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var791 ) const ;
236: Token * tokAt ( int index@var792 ) {
237: return const_cast < Token *@expr3133 > (@expr1073744958 const_cast < const Token *@expr3133 > (@expr1073744960 this@expr1073744961 ) .@expr1073744962 tokAt (@expr1073744963 index@var792 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var793 ) const ;
245: Token * linkAt ( int index@var794 ) {
246: return const_cast < Token *@expr3140 > (@expr1073744965 const_cast < const Token *@expr3140 > (@expr1073744967 this@expr1073744968 ) .@expr1073744969 linkAt (@expr1073744970 index@var794 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var795 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var796 , const char ( & pattern@var797 ) [ count ] ) {
276: return simpleMatch (@expr1073744972 tok@var796 , pattern@var797 , count@expr1073744971 -@expr1073744973 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var798 , const char pattern@var799 [ ] , unsigned long pattern_len@var800 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var801 , const char pattern@var802 [ ] , int varid@var803 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var804 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var805 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var806 , const Settings * const settings@var807 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var808 , long long index@var809 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var1005 .@expr1073744974 mValueType@var1037 ;
366: }
367: void setValueType ( ValueType * vt@var810 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var811 ; top@var811 =@expr1073744975 this@expr1073744976 ;
371: while (@expr1073744977 top@var811 &&@expr1073744978 !@expr1073744979 Token ::@expr1073744980 Match (@expr1073744981 top@var811 .@expr3158 astParent (@expr3159 ) , ",|(" ) ) {
372: top@var811 =@expr1073744984 top@var811 .@expr3158 astParent (@expr3159 ) ; }
373: return top@var811 ?@expr1073744987 top@var811 .@expr1073744988 mImpl@var812 .@expr1073744989 mValueType@var813 :@expr1073744990 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var1003 ;
378: }
379: void tokType ( Token :: Type t@var814 ) {
380: mTokType@var1003 =@expr1073744991 t@var814 ;
381:
382: const bool memoizedIsName@var815 =@expr1073744992 mTokType@var1003 ==@expr1073744993 eName ||@expr1073744994 mTokType@var1003 ==@expr1073744995 eType ||@expr1073744996 mTokType@var1003 ==@expr1073744997 eVariable ||@expr1073744998
383: mTokType@var1003 ==@expr1073744999 eFunction ||@expr1073745000 mTokType@var1003 ==@expr1073745001 eKeyword ||@expr1073745002 mTokType@var1003 ==@expr3179 eBoolean ||@expr1073745004
384: mTokType@var1003 ==@expr3181 eEnumerator ;
385: setFlag (@expr1073745006 fIsName , memoizedIsName@var815 ) ;
386:
387: const bool memoizedIsLiteral@var816 =@expr1073745007 mTokType@var1003 ==@expr1073745008 eNumber ||@expr1073745009 mTokType@var1003 ==@expr1073745010 eString ||@expr1073745011 mTokType@var1003 ==@expr1073745012 eChar ||@expr1073745013
388: mTokType@var1003 ==@expr3179 eBoolean ||@expr1073745015 mTokType@var1003 ==@expr1073745016 eLiteral ||@expr1073745017 mTokType@var1003 ==@expr3181 eEnumerator ;
389: setFlag (@expr1073745019 fIsLiteral , memoizedIsLiteral@var816 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var1003 ==@expr1073745020 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073745021 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var1004 ==@expr1073745022 fIsName &&@expr1073745023 mTokType@var1003 ==@expr1073745024 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073745025 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var1003 ==@expr1073745026 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var1003 ==@expr1073745027 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073745028 isConstOp (@expr1073745029 ) ||@expr1073745030
412: isAssignmentOp (@expr1073745031 ) ||@expr1073745032
413: mTokType@var1003 ==@expr1073745033 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073745034 isArithmeticalOp (@expr1073745035 ) ||@expr1073745036
417: mTokType@var1003 ==@expr1073745037 eLogicalOp ||@expr1073745038
418: mTokType@var1003 ==@expr1073745039 eComparisonOp ||@expr1073745040
419: mTokType@var1003 ==@expr1073745041 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073745042 ) ||@expr1073745043
423: mTokType@var1003 ==@expr1073745044 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var1003 ==@expr1073745045 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var1003 ==@expr1073745046 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var1003 ==@expr1073745047 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var1003 ==@expr1073745048 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var1003 ==@expr1073745049 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073745050 ) !=@expr1073745051 nullptr &&@expr1073745052 astOperand2 (@expr1073745053 ) !=@expr1073745054 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var817 ) const {
444: return s@var817 ==@expr1073745055 mStr@var999 &&@expr1073745056 astOperand1 (@expr1073745057 ) !=@expr1073745058 nullptr &&@expr1073745059 astOperand2 (@expr1073745060 ) ==@expr1073745061 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var1004 ;
450: }
451: void flags ( const unsigned int flags_@var818 ) {
452: mFlags@var1004 =@expr1073745062 flags_@var818 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073745063 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var819 ) {
458: setFlag (@expr1073745064 fIsUnsigned , sign@var819 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073745065 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var820 ) {
464: setFlag (@expr1073745066 fIsSigned , sign@var820 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073745067 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var821 ) {
470: setFlag (@expr1073745068 fIsPointerCompare , b@var821 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073745069 fIsLong ) ;
474: }
475: void isLong ( bool size@var822 ) {
476: setFlag (@expr1073745070 fIsLong , size@var822 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073745071 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var823 ) {
482: setFlag (@expr1073745072 fIsStandardType , b@var823 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073745073 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var824 ) {
488: setFlag (@expr1073745074 fIsExpandedMacro , m@var824 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073745075 fIsCast ) ;
492: }
493: void isCast ( bool c@var825 ) {
494: setFlag (@expr1073745076 fIsCast , c@var825 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073745077 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var826 ) {
500: setFlag (@expr1073745078 fIsAttributeConstructor , ac@var826 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073745079 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var827 ) {
506: setFlag (@expr1073745080 fIsAttributeDestructor , value@var827 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073745081 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var828 ) {
512: setFlag (@expr1073745082 fIsAttributeUnused , unused@var828 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073745083 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var829 ) {
518: setFlag (@expr1073745084 fIsAttributeUsed , unused@var829 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073745085 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var830 ) {
524: setFlag (@expr1073745086 fIsAttributePure , value@var830 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073745087 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var831 ) {
530: setFlag (@expr1073745088 fIsAttributeConst , value@var831 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073745089 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var832 ) {
536: setFlag (@expr1073745090 fIsAttributeNoreturn , value@var832 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073745091 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var833 ) {
542: setFlag (@expr1073745092 fIsAttributeNothrow , value@var833 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073745093 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var834 ) {
548: setFlag (@expr1073745094 fIsAttributePacked , value@var834 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073745095 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var835 ) {
554: setFlag (@expr1073745096 fIsAttributeNodiscard , value@var835 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073745097 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var836 ) {
560: setFlag (@expr1073745098 fIsAttributeMaybeUnused , value@var836 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var837 , long long value@var838 ) {
563: mImpl@var1005 .@expr1073745099 setCppcheckAttribute (@expr1073745100 type@var837 , value@var838 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var839 , long long * value@var840 ) const {
566: return mImpl@var1005 .@expr1073745101 getCppcheckAttribute (@expr1073745102 type@var839 , value@var840 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073745103 mImpl@var1005 .@expr1073745104 mCppcheckAttributes@var1038 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073745105 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073745106 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var841 ) {
578: setFlag (@expr1073745107 fIsOperatorKeyword , value@var841 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073745108 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var842 ) {
584: setFlag (@expr1073745109 fIsComplex , value@var842 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073745110 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var843 ) {
590: setFlag (@expr1073745111 fIsEnumType , value@var843 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073745112 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var844 ) {
596: setFlag (@expr1073745113 fAtAddress , b@var844 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073745114 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var845 ) {
602: setFlag (@expr1073745115 fIncompleteVar , b@var845 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073745116 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var846 ) {
609: setFlag (@expr1073745117 fIsIncompleteConstant , b@var846 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073745118 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var847 ) {
616: setFlag (@expr1073745119 fConstexpr , b@var847 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073745120 fExternC ) ;
621: }
622: void isExternC ( bool b@var848 ) {
623: setFlag (@expr1073745121 fExternC , b@var848 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073745122 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var849 ) {
630: setFlag (@expr1073745123 fIsSplitVarDeclComma , b@var849 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073745124 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var850 ) {
637: setFlag (@expr1073745125 fIsSplitVarDeclEq , b@var850 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073745126 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var851 ) {
644: setFlag (@expr1073745127 fIsImplicitInt , b@var851 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073745128 fIsInline ) ;
649: }
650: void isInline ( bool b@var852 ) {
651: setFlag (@expr1073745129 fIsInline , b@var852 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073745130 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var853 ) {
658: setFlag (@expr1073745131 fIsRemovedVoidParameter , b@var853 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073745132 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var854 ) {
665: setFlag (@expr1073745133 fIsTemplate , b@var854 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073745134 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var855 ) {
672: setFlag (@expr1073745135 fIsSimplifedScope , b@var855 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var1005 .@expr1073745136 mBits@var1039 >@expr1073745137 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var1005 .@expr1073745138 mBits@var1039 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var1005 .@expr1073745139 mTemplateSimplifierPointers@var1040 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var856 ) {
685: if (@expr1073745140 !@expr1073745141 mImpl@var1005 .@expr3318 mTemplateSimplifierPointers@var1040 ) {
686: mImpl@var1005 .@expr3318 mTemplateSimplifierPointers@var1040 =@expr1073745144 new std ::@expr1073745145 set < TemplateSimplifier ::@expr1073745146 TokenAndName *@expr1073745147 > ; }
687: mImpl@var1005 .@expr3318 mTemplateSimplifierPointers@var1040 .@expr1073745149 insert (@expr1073745150 tokenAndName@var856 ) ;
688: }
689: void setBits ( const unsigned char b@var857 ) {
690: mImpl@var1005 .@expr1073745151 mBits@var1039 =@expr1073745152 b@var857 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr3329 (@expr3329 (@expr3329 mTokType@var1003 ==@expr1073745156 eString ) &&@expr1073745157 isPrefixStringCharLiteral (@expr1073745158 mStr@var999 , '"' , "u8" ) ) ||@expr1073745159
695: (@expr3329 (@expr3329 mTokType@var1003 ==@expr1073745162 eChar ) &&@expr1073745163 isPrefixStringCharLiteral (@expr1073745164 mStr@var999 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr3341 (@expr3341 (@expr3341 mTokType@var1003 ==@expr1073745168 eString ) &&@expr1073745169 isPrefixStringCharLiteral (@expr1073745170 mStr@var999 , '"' , "u" ) ) ||@expr1073745171
700: (@expr3341 (@expr3341 mTokType@var1003 ==@expr1073745174 eChar ) &&@expr1073745175 isPrefixStringCharLiteral (@expr1073745176 mStr@var999 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr3353 (@expr3353 (@expr3353 mTokType@var1003 ==@expr1073745180 eString ) &&@expr1073745181 isPrefixStringCharLiteral (@expr1073745182 mStr@var999 , '"' , "U" ) ) ||@expr1073745183
705: (@expr3353 (@expr3353 mTokType@var1003 ==@expr1073745186 eChar ) &&@expr1073745187 isPrefixStringCharLiteral (@expr1073745188 mStr@var999 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr3365 (@expr3365 (@expr3365 mTokType@var1003 ==@expr1073745192 eString ) &&@expr1073745193 isPrefixStringCharLiteral (@expr1073745194 mStr@var999 , '"' , "" ) ) ||@expr1073745195
710: (@expr3365 (@expr3365 mTokType@var1003 ==@expr1073745198 eChar ) &&@expr1073745199 isPrefixStringCharLiteral (@expr1073745200 mStr@var999 , '\'' , "" ) &&@expr1073745201 mStr@var999 .@expr1073745202 length (@expr1073745203 ) ==@expr1073745204 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr3381 (@expr3381 (@expr3381 mTokType@var1003 ==@expr1073745208 eChar ) &&@expr1073745209 isPrefixStringCharLiteral (@expr1073745210 mStr@var999 , '\'' , "" ) ) &&@expr1073745211
715: (@expr3381 mStr@var999 .@expr1073745213 length (@expr1073745214 ) >@expr1073745215 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073745216 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var858 ) {
738: setFlag (@expr1073745217 fIsTemplateArg , value@var858 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var859 , const char ( & pattern@var860 ) [ count ] ) {
743: return findsimplematch (@expr1073745219 startTok@var859 , pattern@var860 , count@expr1073745218 -@expr1073745220 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var861 , const char pattern@var862 [ ] , unsigned long pattern_len@var863 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var864 , const char ( & pattern@var865 ) [ count ] , const Token * const end@var866 ) {
749: return findsimplematch (@expr1073745222 startTok@var864 , pattern@var865 , count@expr1073745221 -@expr1073745223 1 , end@var866 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var867 , const char pattern@var868 [ ] , unsigned long pattern_len@var869 , const Token * const end@var870 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var871 , const char pattern@var872 [ ] , const int varId@var873 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var874 , const char pattern@var875 [ ] , const Token * const end@var876 , const int varId@var877 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var878 , const char ( & pattern@var879 ) [ count ] ) {
758: return findsimplematch (@expr1073745225 startTok@var878 , pattern@var879 , count@expr1073745224 -@expr1073745226 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var880 , const char pattern@var881 [ ] , unsigned long pattern_len@var882 ) {
761: return const_cast < Token *@expr3403 > (@expr1073745228 findsimplematch (@expr1073745229 const_cast < const Token *@expr3403 > (@expr1073745231 startTok@var880 ) , pattern@var881 , pattern_len@var882 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var883 , const char ( & pattern@var884 ) [ count ] , const Token * const end@var885 ) {
765: return findsimplematch (@expr1073745233 startTok@var883 , pattern@var884 , count@expr1073745232 -@expr1073745234 1 , end@var885 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var886 , const char pattern@var887 [ ] , unsigned long pattern_len@var888 , const Token * const end@var889 ) {
768: return const_cast < Token *@expr3411 > (@expr1073745236 findsimplematch (@expr1073745237 const_cast < const Token *@expr3411 > (@expr1073745239 startTok@var886 ) , pattern@var887 , pattern_len@var888 , end@var889 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var890 , const char pattern@var891 [ ] , const int varId@var892 = 0 ) {
772: return const_cast < Token *@expr3416 > (@expr1073745241 findmatch (@expr1073745242 const_cast < const Token *@expr3416 > (@expr1073745244 startTok@var890 ) , pattern@var891 , varId@var892 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var893 , const char pattern@var894 [ ] , const Token * const end@var895 , const int varId@var896 = 0 ) {
775: return const_cast < Token *@expr3421 > (@expr1073745246 findmatch (@expr1073745247 const_cast < const Token *@expr3421 > (@expr1073745249 startTok@var893 ) , pattern@var894 , end@var895 , varId@var896 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var897 , const char * haystack@var898 , int varid@var899 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var1005 .@expr1073745250 mFileIndex@var1041 ;
796: }
797: void fileIndex ( int indexOfFile@var900 ) {
798: mImpl@var1005 .@expr1073745251 mFileIndex@var1041 =@expr1073745252 indexOfFile@var900 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var1005 .@expr1073745253 mLineNumber@var1042 ;
803: }
804: void linenr ( int lineNumber@var901 ) {
805: mImpl@var1005 .@expr1073745254 mLineNumber@var1042 =@expr1073745255 lineNumber@var901 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var1005 .@expr1073745256 mColumn@var1043 ;
810: }
811: void column ( int c@var902 ) {
812: mImpl@var1005 .@expr1073745257 mColumn@var1043 =@expr1073745258 c@var902 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var1000 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var903 , const Token * end@var904 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var905 , const std :: string & originalNameStr@var906 = emptyString@var1 , bool prepend@var907 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var908 , const std :: string & originalNameStr@var909 = emptyString@var1 )
840: {
841: return insertToken (@expr1073745259 tokenStr@var908 , originalNameStr@var909 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var1001 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var1005 .@expr1073745260 mVarId@var1036 ;
851: }
852: void varId ( int id@var910 ) {
853: mImpl@var1005 .@expr1073745261 mVarId@var1036 =@expr1073745262 id@var910 ;
854: if (@expr1073745263 id@var910 !=@expr1073745264 0 ) {
855: tokType (@expr1073745265 eVariable ) ;
856: isStandardType (@expr1073745266 false ) ;
857: } else {
858: update_property_info (@expr1073745267 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073745268 mImpl@var1005 .@expr3445 mExprId@var1044 ) {
864: return mImpl@var1005 .@expr3445 mExprId@var1044 ; }
865: return mImpl@var1005 .@expr1073745271 mVarId@var1036 ;
866: }
867: void exprId ( int id@var911 ) {
868: mImpl@var1005 .@expr1073745272 mExprId@var1044 =@expr1073745273 id@var911 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var912 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var913 , const std :: vector < std :: string > & fileNames@var914 ) const ;
888:
|
891:
892: void printLines ( int lines@var915 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var916 , Token * start@var917 , Token * end@var918 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var919 ; varid@var919 = false ;
905: bool exprid@var920 ; exprid@var920 = false ;
906: bool idtype@var921 ; idtype@var921 = false ;
907: bool attributes@var922 ; attributes@var922 = false ;
908: bool macro@var923 ; macro@var923 = false ;
909: bool linenumbers@var924 ; linenumbers@var924 = false ;
910: bool linebreaks@var925 ; linebreaks@var925 = false ;
911: bool files@var926 ; files@var926 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var927 ;
914: options@var927 .@expr1073745274 attributes@var928 =@expr1073745275 true ;
915: options@var927 .@expr1073745276 macro@var929 =@expr1073745277 true ;
916: options@var927 .@expr1073745278 linenumbers@var930 =@expr1073745279 true ;
917: options@var927 .@expr1073745280 linebreaks@var931 =@expr1073745281 true ;
918: options@var927 .@expr1073745282 files@var932 =@expr1073745283 true ;
919: return options@var927 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var933 ; options@var933 =@expr1073745284 forDebug (@expr1073745285 ) ;
923: options@var933 .@expr1073745286 varid@var934 =@expr1073745287 true ;
924: return options@var933 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var935 ; options@var935 =@expr1073745288 forDebug (@expr1073745289 ) ;
928: options@var935 .@expr1073745290 exprid@var936 =@expr1073745291 true ;
929: return options@var935 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var937 ; options@var937 =@expr1073745292 forDebug (@expr1073745293 ) ;
933: options@var937 .@expr1073745294 exprid@var938 =@expr1073745295 true ;
934: options@var937 .@expr1073745296 varid@var939 =@expr1073745297 true ;
935: options@var937 .@expr1073745298 idtype@var940 =@expr1073745299 true ;
936: return options@var937 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var941 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var942 , bool attributes@var943 , bool macro@var944 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var945 , const std :: vector < std :: string > * fileNames@var946 = nullptr , const Token * end@var947 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var948 , bool attributes@var949 = true ) const ;
952: std :: string stringifyList ( bool varid@var950 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var951 , bool attributes@var952 , bool linenumbers@var953 , bool linebreaks@var954 , bool files@var955 , const std :: vector < std :: string > * fileNames@var956 = nullptr , const Token * end@var957 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var958 ) {
983: mLink@var1002 =@expr1073745300 linkToToken@var958 ;
984: if (@expr1073745301 mStr@var999 ==@expr1073745302 "<" ||@expr1073745303 mStr@var999 ==@expr1073745304 ">" ) {
985: update_property_info (@expr1073745305 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var1002 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var959 ) {
1006: mImpl@var1005 .@expr1073745306 mScope@var1045 =@expr1073745307 s@var959 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var1005 .@expr1073745308 mScope@var1045 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var960 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var1003 ==@expr1073745309 eFunction ||@expr1073745310 mTokType@var1003 ==@expr1073745311 eLambda ?@expr1073745312 mImpl@var1005 .@expr1073745313 mFunction@var1046 :@expr1073745314 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var961 ) {
1034: mImpl@var1005 .@expr1073745315 mVariable@var1047 =@expr1073745316 v@var961 ;
1035: if (@expr1073745317 v@var961 ||@expr1073745318 mImpl@var1005 .@expr1073745319 mVarId@var1036 ) {
1036: tokType (@expr1073745320 eVariable ) ; }
1037: else { if (@expr1073745321 mTokType@var1003 ==@expr1073745322 eVariable ) {
1038: tokType (@expr1073745323 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var1003 ==@expr1073745324 eVariable ?@expr1073745325 mImpl@var1005 .@expr1073745326 mVariable@var1047 :@expr1073745327 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var962 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var1003 ==@expr1073745328 eType ?@expr1073745329 mImpl@var1005 .@expr1073745330 mType@var1048 :@expr1073745331 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var963 , const Token * * typeTok@var964 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var965 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var966 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var1003 ==@expr1073745332 eEnumerator ?@expr1073745333 mImpl@var1005 .@expr1073745334 mEnumerator@var1049 :@expr1073745335 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var967 ) {
1079: mImpl@var1005 .@expr1073745336 mEnumerator@var1049 =@expr1073745337 e@var967 ;
1080: if (@expr1073745338 e@var967 ) {
1081: tokType (@expr1073745339 eEnumerator ) ; }
1082: else { if (@expr1073745340 mTokType@var1003 ==@expr1073745341 eEnumerator ) {
1083: tokType (@expr1073745342 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var968 , Token * end@var969 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var970 , Token * srcEnd@var971 , Token * newLocation@var972 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var1005 .@expr1073745343 mProgressValue@var1050 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var973 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var1005 .@expr3520 mOriginalName@var1051 ?@expr1073745345 *@expr1073745346 mImpl@var1005 .@expr3520 mOriginalName@var1051 :@expr1073745348 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var1005 .@expr3525 mValues@var1024 ?@expr1073745350 *@expr1073745351 mImpl@var1005 .@expr3525 mValues@var1024 :@expr1073745353 TokenImpl ::@expr1073745354 mEmptyValueList@var771 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var974 ) {
1164: if (@expr1073745355 !@expr1073745356 mImpl@var1005 .@expr3533 mOriginalName@var1051 ) {
1165: mImpl@var1005 .@expr3533 mOriginalName@var1051 =@expr1073745359 new std ::@expr1073745360 string (@expr1073745361 name@var974 ) ; }
1166: else {
1167: *@expr1073745362 mImpl@var1005 .@expr3533 mOriginalName@var1051 =@expr1073745364 name@var974 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var975 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var976 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var977 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var1005 .@expr1073745366 mValues@var1024 .@expr1073745367 front (@expr1073745368 ) .@expr1073745369 intvalue@expr1073745365 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var978 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var979 , long long path@var980 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var981 , const Settings * settings@var982 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var983 , const Settings * settings@var984 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var985 , int argnr@var986 , const Settings * settings@var987 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var988 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var989 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var990 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var991 ) {
1200: if (@expr1073745370 mImpl@var1005 .@expr3547 mValues@var1024 ) {
1201: mImpl@var1005 .@expr3547 mValues@var1024 .@expr1073745373 remove_if (@expr1073745374 pred@var991 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var1005 .@expr1073745375 mIndex@var1052 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var992 ) {
1213: mNext@var1000 =@expr1073745376 nextToken@var992 ;
1214: }
1215: void previous ( Token * previousToken@var993 ) {
1216: mPrevious@var1001 =@expr1073745377 previousToken@var993 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var994 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var995 , const char * word@var996 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var997 , char c@var998 ) ;
1235:
1236: std :: string mStr@var999 ;
1237:
1238: Token * mNext@var1000 ;
1239: Token * mPrevious@var1001 ;
1240: Token * mLink@var1002 ;
1241:
1242: enum Anonymous1 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var1003 ;
1283:
1284: uint64_t mFlags@var1004 ;
1285:
1286: TokenImpl * mImpl@var1005 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var1006 ) const {
1294: return (@expr3554 (@expr3554 mFlags@var1004 &@expr1073745380 flag_@var1006 ) !=@expr1073745381 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var1007 , bool state_@var1008 ) {
1303: mFlags@var1004 =@expr1073745382 state_@var1008 ?@expr1073745383 mFlags@var1004 |@expr1073745384 flag_@var1007 :@expr1073745385 mFlags@var1004 &@expr1073745386 ~@expr1073745387 flag_@var1007 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var1009 , const int indent1@var1010 = 0 , const int indent2@var1011 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var1012 ) ;
1321: void astOperand2 ( Token * tok@var1013 ) ;
1322: void astParent ( Token * tok@var1014 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var1005 .@expr1073745388 mAstOperand1@var1015 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var1005 .@expr1073745389 mAstOperand1@var1015 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var1005 .@expr1073745390 mAstOperand2@var1016 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var1005 .@expr1073745391 mAstOperand2@var1016 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var1005 .@expr1073745392 mAstParent@var1017 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var1005 .@expr1073745393 mAstParent@var1017 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073745394 !@expr1073745395 astParent (@expr3572 ) ) {
1344: return nullptr ; }
1345: if (@expr1073745397 this@expr3574 ==@expr1073745399 astParent (@expr3572 ) .@expr3577 astOperand1 (@expr3578 ) ) {
1346: return astParent (@expr3572 ) .@expr3580 astOperand2 (@expr3581 ) ; }
1347: else { if (@expr1073745406 this@expr3574 ==@expr1073745407 astParent (@expr3572 ) .@expr3580 astOperand2 (@expr3581 ) ) {
1348: return astParent (@expr3572 ) .@expr3577 astOperand1 (@expr3578 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073745414 !@expr1073745415 astParent (@expr3592 ) ) {
1354: return nullptr ; }
1355: if (@expr1073745417 this@expr3594 ==@expr1073745419 astParent (@expr3592 ) .@expr3597 astOperand1 (@expr3598 ) ) {
1356: return astParent (@expr3592 ) .@expr3600 astOperand2 (@expr3601 ) ; }
1357: else { if (@expr1073745426 this@expr3594 ==@expr1073745427 astParent (@expr3592 ) .@expr3600 astOperand2 (@expr3601 ) ) {
1358: return astParent (@expr3592 ) .@expr3597 astOperand1 (@expr3598 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var1018 ; ret@var1018 =@expr1073745434 this@expr1073745435 ;
1364: while (@expr1073745436 ret@var1018 .@expr3613 mImpl@var1019 .@expr3614 mAstParent@var1020 ) {
1365: ret@var1018 =@expr1073745439 ret@var1018 .@expr3613 mImpl@var1019 .@expr3614 mAstParent@var1020 ; }
1366: return ret@var1018 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var1021 ; ret@var1021 =@expr1073745442 this@expr1073745443 ;
1371: while (@expr1073745444 ret@var1021 .@expr3621 mImpl@var1022 .@expr3622 mAstParent@var1023 ) {
1372: ret@var1021 =@expr1073745447 ret@var1021 .@expr3621 mImpl@var1022 .@expr3622 mAstParent@var1023 ; }
1373: return ret@var1021 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var1005 .@expr1073745450 mAstOperand1@var1015 =@expr1073745451 mImpl@var1005 .@expr1073745452 mAstOperand2@var1016 =@expr1073745453 mImpl@var1005 .@expr1073745454 mAstParent@var1017 =@expr1073745455 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var1005 .@expr3632 mValues@var1024 ;
1393: mImpl@var1005 .@expr3632 mValues@var1024 =@expr1073745458 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var1025 = "" ) const {
1397: std ::@expr1073745459 string ret@var1026 ;
1398: if (@expr1073745460 mImpl@var1005 .@expr3637 mAstOperand1@var1015 ) {
1399: ret@var1026 =@expr1073745462 mImpl@var1005 .@expr3637 mAstOperand1@var1015 .@expr1073745464 astString (@expr1073745465 sep@var1025 ) ; }
1400: if (@expr1073745466 mImpl@var1005 .@expr3643 mAstOperand2@var1016 ) {
1401: ret@var1026 +=@expr1073745468 mImpl@var1005 .@expr3643 mAstOperand2@var1016 .@expr1073745470 astString (@expr1073745471 sep@var1025 ) ; }
1402: return ret@var1026 +@expr1073745472 sep@var1025 +@expr1073745473 mStr@var999 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var1027 , bool xml@var1028 , const std :: vector < std :: string > & fileNames@var1029 , std :: ostream & out@var1030 ) const ;
1412:
1413: void printValueFlow ( bool xml@var1031 , std :: ostream & out@var1032 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var1033 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var1034 ) const {
1419: mImpl@var1005 .@expr1073745474 mCpp11init@var1035 =@expr1073745475 cpp11init@var1034 ?@expr1073745476 TokenImpl ::@expr3653 Cpp11init ::@expr1073745478 CPP11INIT :@expr1073745479 TokenImpl ::@expr3653 Cpp11init ::@expr1073745481 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var1005 .@expr1073745482 mCpp11init@var1035 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var1053 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var1054 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var1055 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var1056 ) ;

##file cppcheck-2.8/lib/symboldatabase.h

1:
|
39:
40: namespace cppcheck {
41: class Platform ;
42: }
43:
44: class ErrorLogger ;
45: class Function ;
46: class Scope ;
47: class Settings ;
48: class SymbolDatabase ;
49: class Tokenizer ;
50: class ValueType ;
51:
|
54:
55: enum class AccessControl { Public , Protected , Private , Global , Namespace , Argument , Local , Throw } ;
56:
|
59:
60: struct Dimension {
61: Dimension ( ) : tok@var1057 ( nullptr ) , num@var1058 ( 0 ) , known@var1059 ( true ) { }
62:
63: const Token * tok@var1057 ;
64: long long num@var1058 ;
65: bool known@var1059 ;
66: } ;
67:
68:
69: class Type {
70: public:
71: const Token * classDef@var1060 ;
72: const Scope * classScope@var1061 ;
73: const Scope * enclosingScope@var1062 ;
74: enum class NeedInitialization {
75: Unknown , True , False
76: } ; enum NeedInitialization needInitialization@var1063 ;
77:
78: class BaseInfo {
79: public:
80: BaseInfo ( ) :
81: type@var1065 ( nullptr ) , nameTok@var1066 ( nullptr ) , access@var1067 ( AccessControl :: Public ) , isVirtual@var1068 ( false ) { }
82:
83: std :: string name@var1064 ;
84: const Type * type@var1065 ;
85: const Token * nameTok@var1066 ;
86: AccessControl access@var1067 ;
87: bool isVirtual@var1068 ;
88:
89: bool operator< ( const BaseInfo & rhs@var1069 ) const {
90: return this@expr1073745483 .@expr1073745484 type@var1065 <@expr1073745485 rhs@var1069 .@expr1073745486 type@var1070 ;
91: }
92: } ;
93:
94: struct FriendInfo {
95: FriendInfo ( ) :
96: nameStart@var1071 ( nullptr ) , nameEnd@var1072 ( nullptr ) , type@var1073 ( nullptr ) { }
97:
98: const Token * nameStart@var1071 ;
99: const Token * nameEnd@var1072 ;
100: const Type * type@var1073 ;
101: } ;
102:
103: std :: vector < BaseInfo > derivedFrom@var1074 ;
104: std :: vector < FriendInfo > friendList@var1075 ;
105:
106: const Token * typeStart@var1076 ;
107: const Token * typeEnd@var1077 ;
108: long long sizeOf@var1078 ;
109:
110: Type ( const Token * classDef_@var1079 = nullptr , const Scope * classScope_@var1080 = nullptr , const Scope * enclosingScope_@var1081 = nullptr ) :
111: classDef@var1060 ( classDef_@var1079 ) ,
112: classScope@var1061 ( classScope_@var1080 ) ,
113: enclosingScope@var1062 ( enclosingScope_@var1081 ) ,
114: needInitialization@var1063 ( NeedInitialization :: Unknown ) ,
115: typeStart@var1076 ( nullptr ) ,
116: typeEnd@var1077 ( nullptr ) ,
117: sizeOf@var1078 ( 0 ) {
118: if (@expr1073745487 classDef_@var1079 &&@expr1073745488 classDef_@var1079 .@expr3665 str (@expr3666 ) ==@expr1073745491 "enum" ) {
119: needInitialization@var1063 =@expr1073745492 NeedInitialization ::@expr1073745493 True ; }
120: else { if (@expr1073745494 classDef_@var1079 &&@expr1073745495 classDef_@var1079 .@expr3665 str (@expr3666 ) ==@expr1073745498 "using" ) {
121: typeStart@var1076 =@expr1073745499 classDef@var1060 .@expr1073745500 tokAt (@expr1073745501 3 ) ;
122: typeEnd@var1077 =@expr1073745502 typeStart@var1076 ;
123: while (@expr1073745503 typeEnd@var1077 .@expr3680 next (@expr3681 ) &&@expr1073745506 typeEnd@var1077 .@expr3680 next (@expr3681 ) .@expr1073745509 str (@expr1073745510 ) !=@expr1073745511 ";" ) {
124: typeEnd@var1077 =@expr1073745512 typeEnd@var1077 .@expr3680 next (@expr3681 ) ; }
125: } }
126: }
127:
128: const std :: string & name ( ) const ;
129:
130: const std :: string & type ( ) const {
131: return classDef@var1060 ?@expr1073745515 classDef@var1060 .@expr1073745516 str (@expr1073745517 ) :@expr1073745518 emptyString@var1 ;
132: }
133:
134: bool isClassType ( ) const ;
135: bool isEnumType ( ) const ;
136: bool isStructType ( ) const ;
137: bool isUnionType ( ) const ;
138:
139: bool isTypeAlias ( ) const {
140: return classDef@var1060 &&@expr1073745519 classDef@var1060 .@expr1073745520 str (@expr1073745521 ) ==@expr1073745522 "using" ;
141: }
142:
143: const Token * initBaseInfo ( const Token * tok@var1082 , const Token * tok1@var1083 ) ;
144:
145: const Function * getFunction ( const std :: string & funcName@var1084 ) const ;
146:
|
151:
152: bool hasCircularDependencies ( std :: set < BaseInfo > * ancestors@var1085 = nullptr ) const ;
153:
|
158:
159: bool findDependency ( const Type * ancestor@var1086 ) const ;
160:
161: bool isDerivedFrom ( const std :: string & ancestor@var1087 ) const ;
162: } ;
163:
164: class Enumerator {
165: public:
166: explicit Enumerator ( const Scope * scope_@var1088 ) : scope@var1089 ( scope_@var1088 ) , name@var1090 ( nullptr ) , value@var1091 ( 0 ) , start@var1092 ( nullptr ) , end@var1093 ( nullptr ) , value_known@var1094 ( false ) { }
167: const Scope * scope@var1089 ;
168: const Token * name@var1090 ;
169: long long value@var1091 ;
170: const Token * start@var1092 ;
171: const Token * end@var1093 ;
172: bool value_known@var1094 ;
173: } ;
174:
175:
176: class Variable {
177:
178: enum Anonymous2 {
179: fIsMutable = ( 1 << 0 ) ,
180: fIsStatic = ( 1 << 1 ) ,
181: fIsConst = ( 1 << 2 ) ,
182: fIsExtern = ( 1 << 3 ) ,
183: fIsClass = ( 1 << 4 ) ,
184: fIsArray = ( 1 << 5 ) ,
185: fIsPointer = ( 1 << 6 ) ,
186: fIsReference = ( 1 << 7 ) ,
187: fIsRValueRef = ( 1 << 8 ) ,
188: fHasDefault = ( 1 << 9 ) ,
189: fIsStlType = ( 1 << 10 ) ,
190: fIsStlString = ( 1 << 11 ) ,
191: fIsFloatType = ( 1 << 12 ) ,
192: fIsVolatile = ( 1 << 13 ) ,
193: fIsSmartPointer = ( 1 << 14 ) ,
194: fIsMaybeUnused = ( 1 << 15 ) ,
195: fIsInit = ( 1 << 16 ) ,
196: } ;
197:
|
202:
203: bool getFlag ( unsigned int flag_@var1095 ) const {
204: return (@expr3699 (@expr3699 mFlags@var1131 &@expr1073745525 flag_@var1095 ) !=@expr1073745526 0 ) ;
205: }
206:
|
211:
212: void setFlag ( unsigned int flag_@var1096 , bool state_@var1097 ) {
213: mFlags@var1131 =@expr1073745527 state_@var1097 ?@expr1073745528 mFlags@var1131 |@expr1073745529 flag_@var1096 :@expr1073745530 mFlags@var1131 &@expr1073745531 ~@expr1073745532 flag_@var1096 ;
214: }
215:
|
221:
222: bool arrayDimensions ( const Settings * settings@var1098 , bool * isContainer@var1099 ) ;
223:
224: public:
225: Variable ( const Token * name_@var1100 , const Token * start_@var1101 , const Token * end_@var1102 ,
226: int index_@var1103 , AccessControl access_@var1104 , const Type * type_@var1105 ,
227: const Scope * scope_@var1106 , const Settings * settings@var1107 )
228: : mNameToken@var1126 ( name_@var1100 ) ,
229: mTypeStartToken@var1127 ( start_@var1101 ) ,
230: mTypeEndToken@var1128 ( end_@var1102 ) ,
231: mIndex@var1129 ( index_@var1103 ) ,
232: mAccess@var1130 ( access_@var1104 ) ,
233: mFlags@var1131 ( 0 ) ,
234: mType@var1132 ( type_@var1105 ) ,
235: mScope@var1133 ( scope_@var1106 ) ,
236: mValueType@var1134 ( nullptr ) {
237: evaluate (@expr1073745533 settings@var1107 ) ;
238: }
239:
240: Variable ( const Token * name_@var1108 , const std :: string & clangType@var1109 , const Token * typeStart@var1110 ,
241: const Token * typeEnd@var1111 , int index_@var1112 , AccessControl access_@var1113 ,
242: const Type * type_@var1114 , const Scope * scope_@var1115 ) ;
243:
244: Variable ( const Variable & var@var1116 , const Scope * scope@var1117 ) ;
245:
246: Variable ( const Variable & var@var1118 ) ;
247:
248: ~ Variable ( ) ;
249:
250: Variable & operator= ( const Variable & var@var1119 ) ;
251:
|
255:
256: const Token * nameToken ( ) const {
257: return mNameToken@var1126 ;
258: }
259:
|
267:
268: const Token * typeStartToken ( ) const {
269: return mTypeStartToken@var1127 ;
270: }
271:
|
279:
280: const Token * typeEndToken ( ) const {
281: return mTypeEndToken@var1128 ;
282: }
283:
|
290:
291: const Token * declEndToken ( ) const ;
292:
|
296:
297: const std :: string & name ( ) const {
298:
299: if (@expr1073745534 mNameToken@var1126 ) {
300: return mNameToken@var1126 .@expr1073745535 str (@expr1073745536 ) ; }
301:
302: return emptyString@var1 ;
303: }
304:
|
308:
309: int declarationId ( ) const {
310:
311: if (@expr1073745537 mNameToken@var1126 ) {
312: return mNameToken@var1126 .@expr1073745538 varId (@expr1073745539 ) ; }
313:
314: return 0 ;
315: }
316:
|
320:
321: int index ( ) const {
322: return mIndex@var1129 ;
323: }
324:
|
328:
329: bool isPublic ( ) const {
330: return mAccess@var1130 ==@expr1073745540 AccessControl ::@expr1073745541 Public ;
331: }
332:
|
336:
337: bool isProtected ( ) const {
338: return mAccess@var1130 ==@expr1073745542 AccessControl ::@expr1073745543 Protected ;
339: }
340:
|
344:
345: bool isPrivate ( ) const {
346: return mAccess@var1130 ==@expr1073745544 AccessControl ::@expr1073745545 Private ;
347: }
348:
|
352:
353: bool isGlobal ( ) const {
354: return mAccess@var1130 ==@expr1073745546 AccessControl ::@expr1073745547 Global ;
355: }
356:
|
360:
361: bool isNamespace ( ) const {
362: return mAccess@var1130 ==@expr1073745548 AccessControl ::@expr1073745549 Namespace ;
363: }
364:
|
368:
369: bool isArgument ( ) const {
370: return mAccess@var1130 ==@expr1073745550 AccessControl ::@expr1073745551 Argument ;
371: }
372:
|
376:
377: bool isLocal ( ) const {
378: return (@expr1073745553 mAccess@var1130 ==@expr1073745554 AccessControl ::@expr1073745555 Local@expr1073745552 ) &&@expr1073745556 !@expr1073745557 isExtern (@expr1073745558 ) ;
379: }
380:
|
384:
385: bool isMutable ( ) const {
386: return getFlag (@expr1073745559 fIsMutable ) ;
387: }
388:
|
392:
393: bool isVolatile ( ) const {
394: return getFlag (@expr1073745560 fIsVolatile ) ;
395: }
396:
|
400:
401: bool isStatic ( ) const {
402: return getFlag (@expr1073745561 fIsStatic ) ;
403: }
404:
|
408:
409: bool isExtern ( ) const {
410: return getFlag (@expr1073745562 fIsExtern ) ;
411: }
412:
|
416:
417: bool isConst ( ) const {
418: return getFlag (@expr1073745563 fIsConst ) ;
419: }
420:
|
424:
425: bool isThrow ( ) const {
426: return mAccess@var1130 ==@expr1073745564 AccessControl ::@expr1073745565 Throw ;
427: }
428:
|
432:
433: bool isClass ( ) const {
434: return getFlag (@expr1073745566 fIsClass ) ;
435: }
436:
|
440:
441: bool isArray ( ) const {
442: return getFlag (@expr1073745567 fIsArray ) &&@expr1073745568 !@expr1073745569 getFlag (@expr1073745570 fIsPointer ) ;
443: }
444:
|
448:
449: bool isPointer ( ) const {
450: return getFlag (@expr1073745571 fIsPointer ) ;
451: }
452:
|
456:
457: bool isPointerToArray ( ) const {
458: return isPointer (@expr1073745572 ) &&@expr1073745573 getFlag (@expr1073745574 fIsArray ) ;
459: }
460:
|
464:
465: bool isPointerArray ( ) const ;
466:
|
470:
471: bool isArrayOrPointer ( ) const {
472: return getFlag (@expr1073745575 fIsArray ) ||@expr1073745576 getFlag (@expr1073745577 fIsPointer ) ;
473: }
474:
|
478:
479: bool isReference ( ) const {
480: return getFlag (@expr1073745578 fIsReference ) ;
481: }
482:
|
486:
487: bool isRValueReference ( ) const {
488: return getFlag (@expr1073745579 fIsRValueRef ) ;
489: }
490:
|
494:
495: bool isUnsigned ( ) const ;
496:
|
500:
501: bool hasDefault ( ) const {
502: return getFlag (@expr1073745580 fHasDefault ) ;
503: }
504:
|
508:
509: bool isInit ( ) const {
510: return getFlag (@expr1073745581 fIsInit ) ;
511: }
512:
|
516:
517: const Type * type ( ) const {
518: return mType@var1132 ;
519: }
520:
|
524:
525: const Scope * typeScope ( ) const {
526: return mType@var1132 ?@expr1073745582 mType@var1132 .@expr1073745583 classScope@var1137 :@expr1073745584 nullptr ;
527: }
528:
|
532:
533: const Scope * scope ( ) const {
534: return mScope@var1133 ;
535: }
536:
|
540:
541: const std :: vector < Dimension > & dimensions ( ) const {
542: return mDimensions@var1135 ;
543: }
544:
|
548:
549: long long dimension ( int index_@var1120 ) const {
550: return mDimensions@var1135 [@expr1073745585 index_@var1120 ] .@expr1073745586 num@var2295 ;
551: }
552:
|
556:
557: bool dimensionKnown ( int index_@var1121 ) const {
558: return mDimensions@var1135 [@expr1073745587 index_@var1121 ] .@expr1073745588 known@var2296 ;
559: }
560:
|
568:
569: bool isStlType ( ) const {
570: return getFlag (@expr1073745589 fIsStlType ) ;
571: }
572:
|
580:
581: bool isStlStringType ( ) const {
582: return getFlag (@expr1073745590 fIsStlString ) ;
583: }
584:
585: bool isSmartPointer ( ) const {
586: return getFlag (@expr1073745591 fIsSmartPointer ) ;
587: }
588:
589: const Type * smartPointerType ( ) const ;
590:
|
600:
601: bool isStlType ( const std :: string & stlType@var1122 ) const {
602: return isStlType (@expr1073745592 ) &&@expr1073745593 stlType@var1122 ==@expr1073745594 mTypeStartToken@var1127 .@expr1073745595 strAt (@expr1073745596 2 ) ;
603: }
604:
|
614:
615: bool isStlType ( const std :: set < std :: string > & stlTypes@var1123 ) const {
616: return isStlType (@expr1073745597 ) &&@expr1073745598 stlTypes@var1123 .@expr1073745599 find (@expr1073745600 mTypeStartToken@var1127 .@expr1073745601 strAt (@expr1073745602 2 ) ) !=@expr1073745603 stlTypes@var1123 .@expr1073745604 end (@expr1073745605 ) ;
617: }
618:
|
622:
623: bool isFloatingType ( ) const {
624: return getFlag (@expr1073745606 fIsFloatType ) ;
625: }
626:
|
630:
631: bool isEnumType ( ) const {
632: return type (@expr3783 ) &&@expr1073745608 type (@expr3783 ) .@expr1073745610 isEnumType (@expr1073745611 ) ;
633: }
634:
635: bool isMaybeUnused ( ) const {
636: return getFlag (@expr1073745612 fIsMaybeUnused ) ;
637: }
638:
639: const ValueType * valueType ( ) const {
640: return mValueType@var1134 ;
641: }
642:
643: void setValueType ( const ValueType & valueType@var1124 ) ;
644:
645: AccessControl accessControl ( ) const {
646: return mAccess@var1130 ;
647: }
648:
649: std :: string getTypeName ( ) const ;
650:
651: private:
652:
653: friend class SymbolDatabase ;
654:
|
658:
659: void type ( const Type * t@var1125 ) {
660: mType@var1132 =@expr1073745613 t@var1125 ;
661: }
662:
663:
664: const Token * mNameToken@var1126 ;
665:
666:
667: const Token * mTypeStartToken@var1127 ;
668:
669:
670: const Token * mTypeEndToken@var1128 ;
671:
672:
673: int mIndex@var1129 ;
674:
675:
676: AccessControl mAccess@var1130 ;
677:
678:
679: unsigned int mFlags@var1131 ;
680:
681:
682: const Type * mType@var1132 ;
683:
684:
685: const Scope * mScope@var1133 ;
686:
687: ValueType * mValueType@var1134 ;
688:
689:
690: std :: vector < Dimension > mDimensions@var1135 ;
691:
692:
693: void evaluate ( const Settings * settings@var1136 ) ;
694: } ;
695:
696: class Function {
697:
698: friend class SymbolDatabase ;
699:
700:
701: enum Anonymous3 {
702: fHasBody = ( 1 << 0 ) ,
703: fIsInline = ( 1 << 1 ) ,
704: fIsConst = ( 1 << 2 ) ,
705: fHasVirtualSpecifier = ( 1 << 3 ) ,
706: fIsPure = ( 1 << 4 ) ,
707: fIsStatic = ( 1 << 5 ) ,
708: fIsStaticLocal = ( 1 << 6 ) ,
709: fIsExtern = ( 1 << 7 ) ,
710: fIsFriend = ( 1 << 8 ) ,
711: fIsExplicit = ( 1 << 9 ) ,
712: fIsDefault = ( 1 << 10 ) ,
713: fIsDelete = ( 1 << 11 ) ,
714: fHasOverrideSpecifier = ( 1 << 12 ) ,
715: fHasFinalSpecifier = ( 1 << 13 ) ,
716: fIsNoExcept = ( 1 << 14 ) ,
717: fIsThrow = ( 1 << 15 ) ,
718: fIsOperator = ( 1 << 16 ) ,
719: fHasLvalRefQual = ( 1 << 17 ) ,
720: fHasRvalRefQual = ( 1 << 18 ) ,
721: fIsVariadic = ( 1 << 19 ) ,
722: fIsVolatile = ( 1 << 20 ) ,
723: fHasTrailingReturnType = ( 1 << 21 ) ,
724: fIsEscapeFunction = ( 1 << 22 ) ,
725: fIsInlineKeyword = ( 1 << 23 ) ,
726: fIsConstexpr = ( 1 << 24 ) ,
727: } ;
728:
|
733:
734: bool getFlag ( unsigned int flag@var1138 ) const {
735: return (@expr3790 (@expr3790 mFlags@var1187 &@expr1073745616 flag@var1138 ) !=@expr1073745617 0 ) ;
736: }
737:
|
742:
743: void setFlag ( unsigned int flag@var1139 , bool state@var1140 ) {
744: mFlags@var1187 =@expr1073745618 state@var1140 ?@expr1073745619 mFlags@var1187 |@expr1073745620 flag@var1139 :@expr1073745621 mFlags@var1187 &@expr1073745622 ~@expr1073745623 flag@var1139 ;
745: }
746:
747: public:
748: enum Type { eConstructor , eCopyConstructor , eMoveConstructor , eOperatorEqual , eDestructor , eFunction , eLambda } ;
749:
750: Function ( const Tokenizer * mTokenizer@var1141 , const Token * tok@var1142 , const Scope * scope@var1143 , const Token * tokDef@var1144 , const Token * tokArgDef@var1145 ) ;
751: Function ( const Token * tokenDef@var1146 , const std :: string & clangType@var1147 ) ;
752:
753: const std :: string & name ( ) const {
754: return tokenDef@var1157 .@expr1073745624 str (@expr1073745625 ) ;
755: }
756:
757: std :: string fullName ( ) const ;
758:
759: int argCount ( ) const {
760: return argumentList@var1165 .@expr1073745626 size (@expr1073745627 ) ;
761: }
762: int minArgCount ( ) const {
763: return argumentList@var1165 .@expr1073745628 size (@expr1073745629 ) -@expr1073745630 initArgCount@var1166 ;
764: }
765: const Variable * getArgumentVar ( int num@var1148 ) const ;
766: int initializedArgCount ( ) const {
767: return initArgCount@var1166 ;
768: }
769: void addArguments ( const SymbolDatabase * symbolDatabase@var1149 , const Scope * scope@var1150 ) ;
770:
771:
772: bool isImplicitlyVirtual ( bool defaultVal@var1151 = false ) const ;
773:
774: std :: vector < const Function * > getOverloadedFunctions ( ) const ;
775:
776:
777: const Function * getOverriddenFunction ( bool * foundAllBaseClasses@var1152 = nullptr ) const ;
778:
779: bool isLambda ( ) const {
780: return type@var1167 ==@expr1073745631 eLambda ;
781: }
782:
783: bool isConstructor ( ) const {
784: return type@var1167 ==@expr1073745632 eConstructor ||@expr1073745633
785: type@var1167 ==@expr1073745634 eCopyConstructor ||@expr1073745635
786: type@var1167 ==@expr1073745636 eMoveConstructor ;
787: }
788:
789: bool isDestructor ( ) const {
790: return type@var1167 ==@expr1073745637 eDestructor ;
791: }
792: bool isAttributeConstructor ( ) const {
793: return tokenDef@var1157 .@expr1073745638 isAttributeConstructor (@expr1073745639 ) ;
794: }
795: bool isAttributeDestructor ( ) const {
796: return tokenDef@var1157 .@expr1073745640 isAttributeDestructor (@expr1073745641 ) ;
797: }
798: bool isAttributePure ( ) const {
799: return tokenDef@var1157 .@expr1073745642 isAttributePure (@expr1073745643 ) ;
800: }
801: bool isAttributeConst ( ) const {
802: return tokenDef@var1157 .@expr1073745644 isAttributeConst (@expr1073745645 ) ;
803: }
804: bool isAttributeNoreturn ( ) const {
805: return tokenDef@var1157 .@expr1073745646 isAttributeNoreturn (@expr1073745647 ) ;
806: }
807: bool isAttributeNothrow ( ) const {
808: return tokenDef@var1157 .@expr1073745648 isAttributeNothrow (@expr1073745649 ) ;
809: }
810: bool isAttributeNodiscard ( ) const {
811: return tokenDef@var1157 .@expr1073745650 isAttributeNodiscard (@expr1073745651 ) ;
812: }
813:
814: bool hasBody ( ) const {
815: return getFlag (@expr1073745652 fHasBody ) ;
816: }
817: bool isInline ( ) const {
818: return getFlag (@expr1073745653 fIsInline ) ;
819: }
820: bool isConst ( ) const {
821: return getFlag (@expr1073745654 fIsConst ) ;
822: }
823: bool hasVirtualSpecifier ( ) const {
824: return getFlag (@expr1073745655 fHasVirtualSpecifier ) ;
825: }
826: bool isPure ( ) const {
827: return getFlag (@expr1073745656 fIsPure ) ;
828: }
829: bool isStatic ( ) const {
830: return getFlag (@expr1073745657 fIsStatic ) ;
831: }
832: bool isStaticLocal ( ) const {
833: return getFlag (@expr1073745658 fIsStaticLocal ) ;
834: }
835: bool isExtern ( ) const {
836: return getFlag (@expr1073745659 fIsExtern ) ;
837: }
838: bool isFriend ( ) const {
839: return getFlag (@expr1073745660 fIsFriend ) ;
840: }
841: bool isExplicit ( ) const {
842: return getFlag (@expr1073745661 fIsExplicit ) ;
843: }
844: bool isDefault ( ) const {
845: return getFlag (@expr1073745662 fIsDefault ) ;
846: }
847: bool isDelete ( ) const {
848: return getFlag (@expr1073745663 fIsDelete ) ;
849: }
850: bool isNoExcept ( ) const {
851: return getFlag (@expr1073745664 fIsNoExcept ) ;
852: }
853: bool isThrow ( ) const {
854: return getFlag (@expr1073745665 fIsThrow ) ;
855: }
856: bool hasOverrideSpecifier ( ) const {
857: return getFlag (@expr1073745666 fHasOverrideSpecifier ) ;
858: }
859: bool hasFinalSpecifier ( ) const {
860: return getFlag (@expr1073745667 fHasFinalSpecifier ) ;
861: }
862: bool isOperator ( ) const {
863: return getFlag (@expr1073745668 fIsOperator ) ;
864: }
865: bool hasLvalRefQualifier ( ) const {
866: return getFlag (@expr1073745669 fHasLvalRefQual ) ;
867: }
868: bool hasRvalRefQualifier ( ) const {
869: return getFlag (@expr1073745670 fHasRvalRefQual ) ;
870: }
871: bool isVariadic ( ) const {
872: return getFlag (@expr1073745671 fIsVariadic ) ;
873: }
874: bool isVolatile ( ) const {
875: return getFlag (@expr1073745672 fIsVolatile ) ;
876: }
877: bool hasTrailingReturnType ( ) const {
878: return getFlag (@expr1073745673 fHasTrailingReturnType ) ;
879: }
880: void hasBody ( bool state@var1153 ) {
881: setFlag (@expr1073745674 fHasBody , state@var1153 ) ;
882: }
883: bool isInlineKeyword ( ) const {
884: return getFlag (@expr1073745675 fIsInlineKeyword ) ;
885: }
886:
887: bool isEscapeFunction ( ) const {
888: return getFlag (@expr1073745676 fIsEscapeFunction ) ;
889: }
890: void isEscapeFunction ( bool state@var1154 ) {
891: setFlag (@expr1073745677 fIsEscapeFunction , state@var1154 ) ;
892: }
893:
894: bool isConstexpr ( ) const {
895: return getFlag (@expr1073745678 fIsConstexpr ) ;
896: }
897: void isConstexpr ( bool state@var1155 ) {
898: setFlag (@expr1073745679 fIsConstexpr , state@var1155 ) ;
899: }
900: bool isSafe ( const Settings * settings@var1156 ) const ;
901:
902: const Token * tokenDef@var1157 ;
903: const Token * argDef@var1158 ;
904: const Token * token@var1159 ;
905: const Token * arg@var1160 ;
906: const Token * retDef@var1161 ;
907: const :: Type * retType@var1162 ;
908: const Scope * functionScope@var1163 ;
909: const Scope * nestedIn@var1164 ;
910: std :: list < Variable > argumentList@var1165 ;
911: int initArgCount@var1166 ;
912: Type type@var1167 ;
913: AccessControl access@var1168 ;
914: const Token * noexceptArg@var1169 ;
915: const Token * throwArg@var1170 ;
916: const Token * templateDef@var1171 ;
917: const Token * functionPointerUsage@var1172 ;
918:
919: bool argsMatch ( const Scope * scope@var1173 , const Token * first@var1174 , const Token * second@var1175 , const std :: string & path@var1176 , int path_length@var1177 ) const ;
920:
921: static bool returnsConst ( const Function * function@var1178 , bool unknown@var1179 = false ) ;
922:
923: static bool returnsReference ( const Function * function@var1180 , bool unknown@var1181 = false ) ;
924:
925: static bool returnsVoid ( const Function * function@var1182 , bool unknown@var1183 = false ) ;
926:
927: static std :: vector < const Token * > findReturns ( const Function * f@var1184 ) ;
928:
929: const Token * returnDefEnd ( ) const {
930: if (@expr1073745680 this@expr1073745681 .@expr1073745682 hasTrailingReturnType (@expr1073745683 ) ) {
931: return Token ::@expr1073745684 findmatch (@expr1073745685 retDef@var1161 , "{|;" ) ;
932: } else {
933: return tokenDef@var1157 ;
934: }
935: }
936:
|
940:
941: const Token * constructorMemberInitialization ( ) const ;
942:
943: private:
944:
945: const Function * getOverriddenFunctionRecursive ( const :: Type * baseType@var1185 , bool * foundAllBaseClasses@var1186 ) const ;
946:
947: unsigned int mFlags@var1187 ;
948:
949: void isInline ( bool state@var1188 ) {
950: setFlag (@expr1073745686 fIsInline , state@var1188 ) ;
951: }
952: void isConst ( bool state@var1189 ) {
953: setFlag (@expr1073745687 fIsConst , state@var1189 ) ;
954: }
955: void hasVirtualSpecifier ( bool state@var1190 ) {
956: setFlag (@expr1073745688 fHasVirtualSpecifier , state@var1190 ) ;
957: }
958: void isPure ( bool state@var1191 ) {
959: setFlag (@expr1073745689 fIsPure , state@var1191 ) ;
960: }
961: void isStatic ( bool state@var1192 ) {
962: setFlag (@expr1073745690 fIsStatic , state@var1192 ) ;
963: }
964: void isStaticLocal ( bool state@var1193 ) {
965: setFlag (@expr1073745691 fIsStaticLocal , state@var1193 ) ;
966: }
967: void isExtern ( bool state@var1194 ) {
968: setFlag (@expr1073745692 fIsExtern , state@var1194 ) ;
969: }
970: void isFriend ( bool state@var1195 ) {
971: setFlag (@expr1073745693 fIsFriend , state@var1195 ) ;
972: }
973: void isExplicit ( bool state@var1196 ) {
974: setFlag (@expr1073745694 fIsExplicit , state@var1196 ) ;
975: }
976: void isDefault ( bool state@var1197 ) {
977: setFlag (@expr1073745695 fIsDefault , state@var1197 ) ;
978: }
979: void isDelete ( bool state@var1198 ) {
980: setFlag (@expr1073745696 fIsDelete , state@var1198 ) ;
981: }
982: void isNoExcept ( bool state@var1199 ) {
983: setFlag (@expr1073745697 fIsNoExcept , state@var1199 ) ;
984: }
985: void isThrow ( bool state@var1200 ) {
986: setFlag (@expr1073745698 fIsThrow , state@var1200 ) ;
987: }
988: void isOperator ( bool state@var1201 ) {
989: setFlag (@expr1073745699 fIsOperator , state@var1201 ) ;
990: }
991: void hasLvalRefQualifier ( bool state@var1202 ) {
992: setFlag (@expr1073745700 fHasLvalRefQual , state@var1202 ) ;
993: }
994: void hasRvalRefQualifier ( bool state@var1203 ) {
995: setFlag (@expr1073745701 fHasRvalRefQual , state@var1203 ) ;
996: }
997: void isVariadic ( bool state@var1204 ) {
998: setFlag (@expr1073745702 fIsVariadic , state@var1204 ) ;
999: }
1000: void isVolatile ( bool state@var1205 ) {
1001: setFlag (@expr1073745703 fIsVolatile , state@var1205 ) ;
1002: }
1003: void hasTrailingReturnType ( bool state@var1206 ) {
1004: return setFlag (@expr1073745704 fHasTrailingReturnType , state@var1206 ) ;
1005: }
1006: void isInlineKeyword ( bool state@var1207 ) {
1007: setFlag (@expr1073745705 fIsInlineKeyword , state@var1207 ) ;
1008: }
1009: const Token * setFlags ( const Token * tok1@var1208 , const Scope * scope@var1209 ) ;
1010: } ;
1011:
1012: class Scope {
1013:
1014: friend class TestSymbolDatabase ;
1015:
1016: public:
1017: struct UsingInfo {
1018: const Token * start@var1210 ;
1019: const Scope * scope@var1211 ;
1020: } ;
1021:
1022: enum ScopeType { eGlobal , eClass , eStruct , eUnion , eNamespace , eFunction , eIf , eElse , eFor , eWhile , eDo , eSwitch , eUnconditional , eTry , eCatch , eLambda , eEnum } ;
1023:
1024: Scope ( const SymbolDatabase * check_@var1212 , const Token * classDef_@var1213 , const Scope * nestedIn_@var1214 ) ;
1025: Scope ( const SymbolDatabase * check_@var1215 , const Token * classDef_@var1216 , const Scope * nestedIn_@var1217 , ScopeType type_@var1218 , const Token * start_@var1219 ) ;
1026:
1027: const SymbolDatabase * check@var1220 ;
1028: std :: string className@var1221 ;
1029: const Token * classDef@var1222 ;
1030: const Token * bodyStart@var1223 ;
1031: const Token * bodyEnd@var1224 ;
1032: std :: list < Function > functionList@var1225 ;
1033: std :: multimap < std :: string , const Function * > functionMap@var1226 ;
1034: std :: list < Variable > varlist@var1227 ;
1035: const Scope * nestedIn@var1228 ;
1036: std :: list < Scope * > nestedList@var1229 ;
1037: int numConstructors@var1230 ;
1038: int numCopyOrMoveConstructors@var1231 ;
1039: std :: list < UsingInfo > usingList@var1232 ;
1040: ScopeType type@var1233 ;
1041: Type * definedType@var1234 ;
1042: std :: map < std :: string , Type * > definedTypesMap@var1235 ;
1043: std :: vector < const Token * > bodyStartList@var1236 ;
1044:
1045:
1046: const Scope * functionOf@var1237 ;
1047: Function * function@var1238 ;
1048:
1049:
1050: const Token * enumType@var1239 ;
1051: bool enumClass@var1240 ;
1052:
1053: std :: vector < Enumerator > enumeratorList@var1241 ;
1054:
1055: void setBodyStartEnd ( const Token * start@var1242 ) {
1056: bodyStart@var1223 =@expr1073745706 start@var1242 ;
1057: bodyEnd@var1224 =@expr1073745707 start@var1242 ?@expr1073745708 start@var1242 .@expr1073745709 link (@expr1073745710 ) :@expr1073745711 nullptr ;
1058: if (@expr1073745712 start@var1242 ) {
1059: bodyStartList@var1236 .@expr1073745713 push_back (@expr1073745714 start@var1242 ) ; }
1060: }
1061:
1062: bool isAnonymous ( ) const {
1063:
1064: return className@var1221 .@expr1073745715 size (@expr1073745716 ) >@expr1073745717 9 &&@expr1073745718 className@var1221 .@expr1073745719 compare (@expr1073745720 0 , 9 , "Anonymous" ) ==@expr1073745721 0 &&@expr1073745722 std ::@expr1073745723 isdigit (@expr1073745724 className@var1221 [@expr1073745725 9 ] ) ;
1065: }
1066:
1067: const Enumerator * findEnumerator ( const std :: string & name@var1243 ) const {
1068: for (@expr1073745726 const Enumerator &@expr1073745727 i@var1244 :@expr1073745728 enumeratorList@var1241 ) {
1069: if (@expr1073745729 i@var1244 .@expr1073745730 name@var1245 .@expr1073745731 str (@expr1073745732 ) ==@expr1073745733 name@var1243 ) {
1070: return &@expr1073745734 i@var1244 ; }
1071: }
1072: return nullptr ;
1073: }
1074:
1075: bool isNestedIn ( const Scope * outer@var1246 ) const {
1076: if (@expr1073745735 !@expr1073745736 outer@var1246 ) {
1077: return false ; }
1078: if (@expr1073745737 outer@var1246 ==@expr1073745738 this@expr1073745739 ) {
1079: return true ; }
1080: const Scope * parent@var1247 ; parent@var1247 =@expr1073745740 nestedIn@var1228 ;
1081: while (@expr1073745741 outer@var1246 !=@expr1073745742 parent@var1247 &&@expr1073745743 parent@var1247 ) {
1082: parent@var1247 =@expr1073745744 parent@var1247 .@expr1073745745 nestedIn@var1248 ; }
1083: if (@expr1073745746 parent@var1247 &&@expr1073745747 parent@var1247 ==@expr1073745748 outer@var1246 ) {
1084: return true ; }
1085: return false ;
1086: }
1087:
1088: static Function * nestedInFunction ( const Scope * scope@var1249 ) {
1089: while (@expr1073745749 scope@var1249 ) {
1090: if (@expr1073745750 scope@var1249 .@expr1073745751 type@var1250 ==@expr1073745752 Scope ::@expr1073745753 eFunction ) {
1091: break ; }
1092: scope@var1249 =@expr1073745754 scope@var1249 .@expr1073745755 nestedIn@var1251 ;
1093: }
1094: if (@expr1073745756 !@expr1073745757 scope@var1249 ) {
1095: return nullptr ; }
1096: return scope@var1249 .@expr1073745758 function@var1252 ;
1097: }
1098:
1099: bool isClassOrStruct ( ) const {
1100: return (@expr1073745759 type@var1233 ==@expr1073745760 eClass ||@expr1073745761 type@var1233 ==@expr1073745762 eStruct ) ;
1101: }
1102:
1103: bool isClassOrStructOrUnion ( ) const {
1104: return (@expr1073745763 type@var1233 ==@expr1073745764 eClass ||@expr1073745765 type@var1233 ==@expr1073745766 eStruct ||@expr1073745767 type@var1233 ==@expr1073745768 eUnion ) ;
1105: }
1106:
1107: bool isExecutable ( ) const {
1108: return type@var1233 !=@expr1073745769 eClass &&@expr1073745770 type@var1233 !=@expr1073745771 eStruct &&@expr1073745772 type@var1233 !=@expr1073745773 eUnion &&@expr1073745774 type@var1233 !=@expr1073745775 eGlobal &&@expr1073745776 type@var1233 !=@expr1073745777 eNamespace &&@expr1073745778 type@var1233 !=@expr1073745779 eEnum ;
1109: }
1110:
1111: bool isLoopScope ( ) const {
1112: return type@var1233 ==@expr1073745780 Scope ::@expr3957 ScopeType ::@expr1073745782 eFor ||@expr1073745783 type@var1233 ==@expr1073745784 Scope ::@expr3957 ScopeType ::@expr1073745786 eWhile ||@expr1073745787 type@var1233 ==@expr1073745788 Scope ::@expr3957 ScopeType ::@expr1073745790 eDo ;
1113: }
1114:
1115: bool isLocal ( ) const {
1116: return (@expr1073745791 type@var1233 ==@expr1073745792 eIf ||@expr1073745793 type@var1233 ==@expr1073745794 eElse ||@expr1073745795
1117: type@var1233 ==@expr1073745796 eFor ||@expr1073745797 type@var1233 ==@expr1073745798 eWhile ||@expr1073745799 type@var1233 ==@expr1073745800 eDo ||@expr1073745801
1118: type@var1233 ==@expr1073745802 eSwitch ||@expr1073745803 type@var1233 ==@expr1073745804 eUnconditional ||@expr1073745805
1119: type@var1233 ==@expr1073745806 eTry ||@expr1073745807 type@var1233 ==@expr1073745808 eCatch ) ;
1120: }
1121:
1122:
1123: bool hasInlineOrLambdaFunction ( ) const ;
1124:
|
1130:
1131: const Function * findFunction ( const Token * tok@var1253 , bool requireConst@var1254 = false ) const ;
1132:
1133: const Scope * findRecordInNestedList ( const std :: string & name@var1255 , bool isC@var1256 = false ) const ;
1134: Scope * findRecordInNestedList ( const std :: string & name@var1257 ) {
1135: return const_cast < Scope *@expr3985 > (@expr1073745810 const_cast < const Scope *@expr3985 > (@expr1073745812 this@expr1073745813 ) .@expr1073745814 findRecordInNestedList (@expr1073745815 name@var1257 ) ) ;
1136: }
1137:
1138: const Type * findType ( const std :: string & name@var1258 ) const ;
1139: Type * findType ( const std :: string & name@var1259 ) {
1140: return const_cast < Type *@expr3992 > (@expr1073745817 const_cast < const Scope *@expr3992 > (@expr1073745819 this@expr1073745820 ) .@expr1073745821 findType (@expr1073745822 name@var1259 ) ) ;
1141: }
1142:
|
1146:
1147: Scope * findInNestedListRecursive ( const std :: string & name@var1260 ) ;
1148:
1149: void addVariable ( const Token * token_@var1261 , const Token * start_@var1262 ,
1150: const Token * end_@var1263 , AccessControl access_@var1264 , const Type * type_@var1265 ,
1151: const Scope * scope_@var1266 , const Settings * settings@var1267 ) ;
1152:
1153:
1154: void getVariableList ( const Settings * settings@var1268 ) ;
1155:
1156: const Function * getDestructor ( ) const ;
1157:
1158: void addFunction ( const Function & func@var1269 ) {
1159: functionList@var1225 .@expr1073745823 push_back (@expr1073745824 func@var1269 ) ;
1160:
1161: const Function * back@var1270 ; back@var1270 =@expr1073745825 &@expr1073745826 functionList@var1225 .@expr1073745827 back (@expr1073745828 ) ;
1162:
1163: functionMap@var1226 .@expr1073745829 insert (@expr1073745830 make_pair (@expr1073745831 back@var1270 .@expr1073745832 tokenDef@var1271 .@expr1073745833 str (@expr1073745834 ) , back@var1270 ) ) ;
1164: }
1165:
1166: bool hasDefaultConstructor ( ) const ;
1167:
1168: AccessControl defaultAccess ( ) const ;
1169:
|
1176:
1177: const Token * checkVariable ( const Token * tok@var1272 , AccessControl varaccess@var1273 , const Settings * settings@var1274 ) ;
1178:
|
1183:
1184: const Variable * getVariable ( const std :: string & varname@var1275 ) const ;
1185:
1186: const Token * addEnum ( const Token * tok@var1276 , bool isCpp@var1277 ) ;
1187:
1188: const Scope * findRecordInBase ( const std :: string & name@var1278 ) const ;
1189:
1190: std :: vector < const Scope * > findAssociatedScopes ( ) const ;
1191:
1192: private:
1193:
|
1199:
1200: bool isVariableDeclaration ( const Token * const tok@var1279 , const Token * & vartok@var1280 , const Token * & typetok@var1281 ) const ;
1201:
1202: void findFunctionInBase ( const std :: string & name@var1282 , int args@var1283 , std :: vector < const Function * > & matches@var1284 ) const ;
1203:
1204:
1205: void getVariableList ( const Settings * settings@var1285 , const Token * start@var1286 , const Token * end@var1287 ) ;
1206: } ;
1207:
1208: enum class Reference {
1209: None ,
1210: LValue ,
1211: RValue
1212: } ;
1213:
1214:
1215: class ValueType {
1216:
1217: enum Sign { UNKNOWN_SIGN , SIGNED , UNSIGNED } ; public: enum Sign sign@var1288 ;
1218: enum Type {
1219: UNKNOWN_TYPE ,
1220: POD ,
1221: NONSTD ,
1222: RECORD ,
1223: SMART_POINTER ,
1224: CONTAINER ,
1225: ITERATOR ,
1226: VOID ,
1227: BOOL ,
1228: CHAR ,
1229: SHORT ,
1230: WCHAR_T ,
1231: INT ,
1232: LONG ,
1233: LONGLONG ,
1234: UNKNOWN_INT ,
1235: FLOAT ,
1236: DOUBLE ,
1237: LONGDOUBLE
1238: } ; enum Type type@var1289 ;
1239: int bits@var1290 ;
1240: int pointer@var1291 ;
1241: int constness@var1292 ;
1242: Reference reference@var1293 ; reference@var1293 = Reference :: None ;
1243:
1244: const Scope * typeScope@var1294 ;
1245: const :: Type * smartPointerType@var1295 ;
1246: const Token * smartPointerTypeToken@var1296 ;
1247: const Library :: SmartPointer * smartPointer@var1297 ;
1248: const Library :: Container * container@var1298 ;
1249:
1250: const Token * containerTypeToken@var1299 ;
1251:
1252: std :: string originalTypeName@var1300 ;
1253:
1254:
1255: ValueType ( )
1256: : sign@var1288 ( UNKNOWN_SIGN ) ,
1257: type@var1289 ( UNKNOWN_TYPE ) ,
1258: bits@var1290 ( 0 ) ,
1259: pointer@var1291 ( 0U ) ,
1260: constness@var1292 ( 0U ) ,
1261: typeScope@var1294 ( nullptr ) ,
1262: smartPointerType@var1295 ( nullptr ) ,
1263: smartPointerTypeToken@var1296 ( nullptr ) ,
1264: smartPointer@var1297 ( nullptr ) ,
1265: container@var1298 ( nullptr ) ,
1266: containerTypeToken@var1299 ( nullptr )
1267: { }
1268: ValueType ( enum Sign s@var1301 , enum Type t@var1302 , int p@var1303 )
1269: : sign@var1288 ( s@var1301 ) ,
1270: type@var1289 ( t@var1302 ) ,
1271: bits@var1290 ( 0 ) ,
1272: pointer@var1291 ( p@var1303 ) ,
1273: constness@var1292 ( 0U ) ,
1274: typeScope@var1294 ( nullptr ) ,
1275: smartPointerType@var1295 ( nullptr ) ,
1276: smartPointerTypeToken@var1296 ( nullptr ) ,
1277: smartPointer@var1297 ( nullptr ) ,
1278: container@var1298 ( nullptr ) ,
1279: containerTypeToken@var1299 ( nullptr )
1280: { }
1281: ValueType ( enum Sign s@var1304 , enum Type t@var1305 , int p@var1306 , int c@var1307 )
1282: : sign@var1288 ( s@var1304 ) ,
1283: type@var1289 ( t@var1305 ) ,
1284: bits@var1290 ( 0 ) ,
1285: pointer@var1291 ( p@var1306 ) ,
1286: constness@var1292 ( c@var1307 ) ,
1287: typeScope@var1294 ( nullptr ) ,
1288: smartPointerType@var1295 ( nullptr ) ,
1289: smartPointerTypeToken@var1296 ( nullptr ) ,
1290: smartPointer@var1297 ( nullptr ) ,
1291: container@var1298 ( nullptr ) ,
1292: containerTypeToken@var1299 ( nullptr )
1293: { }
1294: ValueType ( enum Sign s@var1308 , enum Type t@var1309 , int p@var1310 , int c@var1311 , const std :: string & otn@var1312 )
1295: : sign@var1288 ( s@var1308 ) ,
1296: type@var1289 ( t@var1309 ) ,
1297: bits@var1290 ( 0 ) ,
1298: pointer@var1291 ( p@var1310 ) ,
1299: constness@var1292 ( c@var1311 ) ,
1300: typeScope@var1294 ( nullptr ) ,
1301: smartPointerType@var1295 ( nullptr ) ,
1302: smartPointerTypeToken@var1296 ( nullptr ) ,
1303: smartPointer@var1297 ( nullptr ) ,
1304: container@var1298 ( nullptr ) ,
1305: containerTypeToken@var1299 ( nullptr ) ,
1306: originalTypeName@var1300 ( otn@var1312 )
1307: { }
1308:
1309: static ValueType parseDecl ( const Token * type@var1313 , const Settings * settings@var1314 ) ;
1310:
1311: static Type typeFromString ( const std :: string & typestr@var1315 , bool longType@var1316 ) ;
1312:
1313: enum class MatchResult { UNKNOWN , SAME , FALLBACK1 , FALLBACK2 , NOMATCH } ;
1314: static MatchResult matchParameter ( const ValueType * call@var1317 , const ValueType * func@var1318 ) ;
1315: static MatchResult matchParameter ( const ValueType * call@var1319 , const Variable * callVar@var1320 , const Variable * funcVar@var1321 ) ;
1316:
1317: bool isPrimitive ( ) const {
1318: return (@expr1073745835 type@var1289 >=@expr1073745836 ValueType ::@expr1073745837 Type ::@expr1073745838 BOOL ) ;
1319: }
1320:
1321: bool isIntegral ( ) const {
1322: return (@expr1073745839 type@var1289 >=@expr1073745840 ValueType ::@expr4017 Type ::@expr1073745842 BOOL &&@expr1073745843 type@var1289 <=@expr1073745844 ValueType ::@expr4017 Type ::@expr1073745846 UNKNOWN_INT ) ;
1323: }
1324:
1325: bool isFloat ( ) const {
1326: return (@expr1073745847 type@var1289 >=@expr1073745848 ValueType ::@expr4025 Type ::@expr1073745850 FLOAT &&@expr1073745851 type@var1289 <=@expr1073745852 ValueType ::@expr4025 Type ::@expr1073745854 LONGDOUBLE ) ;
1327: }
1328:
1329: bool fromLibraryType ( const std :: string & typestr@var1322 , const Settings * settings@var1323 ) ;
1330:
1331: bool isEnum ( ) const {
1332: return typeScope@var1294 &&@expr1073745855 typeScope@var1294 .@expr1073745856 type@var1324 ==@expr1073745857 Scope ::@expr1073745858 eEnum ;
1333: }
1334:
1335: long long typeSize ( const cppcheck :: Platform & platform@var1325 , bool p@var1326 = false ) const ;
1336:
1337:
1338: bool isTypeEqual ( const ValueType * that@var1327 ) const ;
1339:
1340: std :: string str ( ) const ;
1341: std :: string dump ( ) const ;
1342: } ;
1343:
1344:
1345: class SymbolDatabase {
1346: friend class TestSymbolDatabase ;
1347: public:
1348: SymbolDatabase ( const Tokenizer * tokenizer@var1328 , const Settings * settings@var1329 , ErrorLogger * errorLogger@var1330 ) ;
1349: ~ SymbolDatabase ( ) ;
1350:
1351:
1352: std :: list < Scope > scopeList@var1331 ;
1353:
1354:
1355: std :: vector < const Scope * > functionScopes@var1332 ;
1356:
1357:
1358: std :: vector < const Scope * > classAndStructScopes@var1333 ;
1359:
1360:
1361: std :: list < Type > typeList@var1334 ;
1362:
|
1368:
1369: const Type * findVariableType ( const Scope * start@var1335 , const Token * typeTok@var1336 ) const ;
1370:
|
1375:
1376: const Function * findFunction ( const Token * tok@var1337 ) const ;
1377:
1378:
1379: const Scope * findScopeByName ( const std :: string & name@var1338 ) const ;
1380:
1381: const Type * findType ( const Token * startTok@var1339 , const Scope * startScope@var1340 , bool lookOutside@var1341 = false ) const ;
1382: Type * findType ( const Token * startTok@var1342 , Scope * startScope@var1343 , bool lookOutside@var1344 = false ) const {
1383: return const_cast < Type *@expr4035 > (@expr1073745860 this@expr1073745861 .@expr1073745862 findType (@expr1073745863 startTok@var1342 , const_cast < const Scope *@expr4035 > (@expr1073745865 startScope@var1343 ) , lookOutside@var1344 ) ) ;
1384: }
1385:
1386: const Scope * findScope ( const Token * tok@var1345 , const Scope * startScope@var1346 ) const ;
1387: Scope * findScope ( const Token * tok@var1347 , Scope * startScope@var1348 ) const {
1388: return const_cast < Scope *@expr4042 > (@expr1073745867 this@expr1073745868 .@expr1073745869 findScope (@expr1073745870 tok@var1347 , const_cast < const Scope *@expr4042 > (@expr1073745872 startScope@var1348 ) ) ) ;
1389: }
1390:
1391: bool isVarId ( int varid@var1349 ) const {
1392: return varid@var1349 <@expr1073745873 mVariableList@var1406 .@expr1073745874 size (@expr1073745875 ) ;
1393: }
1394:
1395: const Variable * getVariableFromVarId ( int varId@var1350 ) const {
1396: return mVariableList@var1406 .@expr1073745876 at (@expr1073745877 varId@var1350 ) ;
1397: }
1398:
1399: const std :: vector < const Variable * > & variableList ( ) const {
1400: return mVariableList@var1406 ;
1401: }
1402:
|
1405:
1406: void debugMessage ( const Token * tok@var1351 , const std :: string & type@var1352 , const std :: string & msg@var1353 ) const ;
1407:
1408: void printOut ( const char * title@var1354 = nullptr ) const ;
1409: void printVariable ( const Variable * var@var1355 , const char * indent@var1356 ) const ;
1410: void printXml ( std :: ostream & out@var1357 ) const ;
1411:
1412: bool isCPP ( ) const ;
1413:
|
1416:
1417: void validate ( ) const ;
1418:
1419: void validateExecutableScopes ( ) const ;
1420:
1421:
1422:
1423: void validateVariables ( ) const ;
1424:
1425:
1426: void setValueTypeInTokenList ( bool reportDebugWarnings@var1358 , Token * tokens@var1359 = nullptr ) ;
1427:
|
1432:
1433: int sizeOfType ( const Token * type@var1360 ) const ;
1434:
1435:
1436: void setArrayDimensionsUsingValueFlow ( ) ;
1437:
1438: void clangSetVariables ( const std :: vector < const Variable * > & variableList@var1361 ) ;
1439: void createSymbolDatabaseExprIds ( ) ;
1440:
1441: private:
1442: friend class Scope ;
1443: friend class Function ;
1444:
1445:
1446: void createSymbolDatabaseFindAllScopes ( ) ;
1447: void createSymbolDatabaseClassInfo ( ) ;
1448: void createSymbolDatabaseVariableInfo ( ) ;
1449: void createSymbolDatabaseCopyAndMoveConstructors ( ) ;
1450: void createSymbolDatabaseFunctionScopes ( ) ;
1451: void createSymbolDatabaseClassAndStructScopes ( ) ;
1452: void createSymbolDatabaseFunctionReturnTypes ( ) ;
1453: void createSymbolDatabaseNeedInitialization ( ) ;
1454: void createSymbolDatabaseVariableSymbolTable ( ) ;
1455: void createSymbolDatabaseSetScopePointers ( ) ;
1456: void createSymbolDatabaseSetFunctionPointers ( bool firstPass@var1362 ) ;
1457: void createSymbolDatabaseSetVariablePointers ( ) ;
1458:
1459: void createSymbolDatabaseSetTypePointers ( ) ;
1460: void createSymbolDatabaseSetSmartPointerType ( ) ;
1461: void createSymbolDatabaseEnums ( ) ;
1462: void createSymbolDatabaseEscapeFunctions ( ) ;
1463:
1464: void createSymbolDatabaseIncompleteVars ( ) ;
1465:
1466: void addClassFunction ( Scope * * scope@var1363 , const Token * * tok@var1364 , const Token * argStart@var1365 ) ;
1467: Function * addGlobalFunctionDecl ( Scope * & scope@var1366 , const Token * tok@var1367 , const Token * argStart@var1368 , const Token * funcStart@var1369 ) ;
1468: Function * addGlobalFunction ( Scope * & scope@var1370 , const Token * & tok@var1371 , const Token * argStart@var1372 , const Token * funcStart@var1373 ) ;
1469: void addNewFunction ( Scope * * scope@var1374 , const Token * * tok@var1375 ) ;
1470: bool isFunction ( const Token * tok@var1376 , const Scope * outerScope@var1377 , const Token * * funcStart@var1378 , const Token * * argStart@var1379 , const Token * * declEnd@var1380 ) const ;
1471: const Type * findTypeInNested ( const Token * startTok@var1381 , const Scope * startScope@var1382 ) const ;
1472: const Scope * findNamespace ( const Token * tok@var1383 , const Scope * scope@var1384 ) const ;
1473: Function * findFunctionInScope ( const Token * func@var1385 , const Scope * ns@var1386 , const std :: string & path@var1387 , int path_length@var1388 ) ;
1474: const Type * findVariableTypeInBase ( const Scope * scope@var1389 , const Token * typeTok@var1390 ) const ;
1475:
|
1478:
1479: void fixVarId ( std :: map < unsigned int , std :: map < unsigned int , unsigned int > > & varIds@var1391 , const Token * vartok@var1392 , Token * membertok@var1393 , const Variable * membervar@var1394 ) ;
1480:
1481:
1482: bool isReservedName ( const std :: string & iName@var1395 ) const ;
1483:
1484: const Enumerator * findEnumerator ( const Token * tok@var1396 ) const ;
1485:
1486: void setValueType ( Token * tok@var1397 , const ValueType & valuetype@var1398 ) ;
1487: void setValueType ( Token * tok@var1399 , const Variable & var@var1400 ) ;
1488: void setValueType ( Token * tok@var1401 , const Enumerator & enumerator@var1402 ) ;
1489:
1490: const Tokenizer * mTokenizer@var1403 ;
1491: const Settings * mSettings@var1404 ;
1492: ErrorLogger * mErrorLogger@var1405 ;
1493:
1494:
1495: std :: vector < const Variable * > mVariableList@var1406 ;
1496:
1497:
1498: std :: list < Type > mBlankTypes@var1407 ;
1499:
1500: bool mIsCpp@var1408 ;
1501: ValueType :: Sign mDefaultSignedness@var1409 ;
1502:
1503:
1504: mutable std :: set < std :: string > mTokensThatAreNotEnumeratorValues@var1410 ;
1505: } ;

##file cppcheck-2.8/lib/astutils.h

1:
|
34:
35: class Library ;
36: class Settings ;
37: class Token ;
38:
39: enum class ChildrenToVisit {
40: none ,
41: op1 ,
42: op2 ,
43: op1_and_op2 ,
44: done
45: } ;
46:
|
49:
50: template < class T , class TFunc , $class $= $typename $std $:: $enable_if $< std :: is_convertible < T * , const Token * > $:: $value $> $:: $type >
51: void visitAstNodes ( T * ast@var1411 , const TFunc & visitor@var1412 )
52: {
53: if (@expr1073745878 !@expr1073745879 ast@var1411 ) {
54: return ; }
55:
56: std ::@expr1073745880 stack < T *@expr4057 , std ::@expr1073745882 vector < T *@expr4057 > > tokens@var1413 ;
57: T * tok@var1414 ; tok@var1414 =@expr1073745884 ast@var1411 ;
58: do {
59: ChildrenToVisit c@var1415 ; c@var1415 =@expr1073745885 visitor@var1412 (@expr1073745886 tok@var1414 ) ;
60:
61: if (@expr1073745887 c@var1415 ==@expr1073745888 ChildrenToVisit ::@expr1073745889 done ) {
62: break ; }
63: if (@expr1073745890 c@var1415 ==@expr1073745891 ChildrenToVisit ::@expr1073745892 op2 ||@expr1073745893 c@var1415 ==@expr4070 ChildrenToVisit ::@expr4071 op1_and_op2 ) {
64: T * t2@var1416 ; t2@var1416 =@expr1073745896 tok@var1414 .@expr1073745897 astOperand2 (@expr1073745898 ) ;
65: if (@expr1073745899 t2@var1416 ) {
66: tokens@var1413 .@expr4076 push (@expr1073745901 t2@var1416 ) ; }
67: }
68: if (@expr1073745902 c@var1415 ==@expr1073745903 ChildrenToVisit ::@expr1073745904 op1 ||@expr1073745905 c@var1415 ==@expr4070 ChildrenToVisit ::@expr4071 op1_and_op2 ) {
69: T * t1@var1417 ; t1@var1417 =@expr1073745908 tok@var1414 .@expr1073745909 astOperand1 (@expr1073745910 ) ;
70: if (@expr1073745911 t1@var1417 ) {
71: tokens@var1413 .@expr4076 push (@expr1073745913 t1@var1417 ) ; }
72: }
73:
74: if (@expr1073745914 tokens@var1413 .@expr1073745915 empty (@expr1073745916 ) ) {
75: break ; }
76:
77: tok@var1414 =@expr1073745917 tokens@var1413 .@expr1073745918 top (@expr1073745919 ) ;
78: tokens@var1413 .@expr1073745920 pop (@expr1073745921 ) ;
79: } while (@expr1073745922 true ) ;
80: }
81:
82: const Token * findAstNode ( const Token * ast@var1418 , const std :: function < bool ( const Token * ) > & pred@var1419 ) ;
83: const Token * findExpression ( const int exprid@var1420 ,
84: const Token * start@var1421 ,
85: const Token * end@var1422 ,
86: const std :: function < bool ( const Token * ) > & pred@var1423 ) ;
87: const Token * findExpression ( const Token * start@var1424 , const int exprid@var1425 ) ;
88:
89: std :: vector < const Token * > astFlatten ( const Token * tok@var1426 , const char * op@var1427 ) ;
90: std :: vector < Token * > astFlatten ( Token * tok@var1428 , const char * op@var1429 ) ;
91:
92: int astCount ( const Token * tok@var1430 , const char * op@var1431 , int depth@var1432 = 100 ) ;
93:
94: bool astHasToken ( const Token * root@var1433 , const Token * tok@var1434 ) ;
95:
96: bool astHasVar ( const Token * tok@var1435 , int varid@var1436 ) ;
97:
98: bool astIsPrimitive ( const Token * tok@var1437 ) ;
99:
100: bool astIsSignedChar ( const Token * tok@var1438 ) ;
101:
102: bool astIsUnknownSignChar ( const Token * tok@var1439 ) ;
103:
104: bool astIsGenericChar ( const Token * tok@var1440 ) ;
105:
106: bool astIsIntegral ( const Token * tok@var1441 , bool unknown@var1442 ) ;
107: bool astIsUnsigned ( const Token * tok@var1443 ) ;
108:
109: bool astIsFloat ( const Token * tok@var1444 , bool unknown@var1445 ) ;
110:
111: bool astIsBool ( const Token * tok@var1446 ) ;
112:
113: bool astIsPointer ( const Token * tok@var1447 ) ;
114:
115: bool astIsSmartPointer ( const Token * tok@var1448 ) ;
116: bool astIsUniqueSmartPointer ( const Token * tok@var1449 ) ;
117:
118: bool astIsIterator ( const Token * tok@var1450 ) ;
119:
120: bool astIsContainer ( const Token * tok@var1451 ) ;
121:
122: bool astIsContainerView ( const Token * tok@var1452 ) ;
123: bool astIsContainerOwned ( const Token * tok@var1453 ) ;
124:
|
133:
134: std :: string astCanonicalType ( const Token * expr@var1454 ) ;
135:
136:
137: const Token * astIsVariableComparison ( const Token * tok@var1455 , const std :: string & comp@var1456 , const std :: string & rhs@var1457 , const Token * * vartok@var1458 = nullptr ) ;
138:
139: bool isVariableDecl ( const Token * tok@var1459 ) ;
140:
141: bool isTemporary ( bool cpp@var1460 , const Token * tok@var1461 , const Library * library@var1462 , bool unknown@var1463 = false ) ;
142:
143: const Token * previousBeforeAstLeftmostLeaf ( const Token * tok@var1464 ) ;
144: Token * previousBeforeAstLeftmostLeaf ( Token * tok@var1465 ) ;
145:
146: const Token * nextAfterAstRightmostLeaf ( const Token * tok@var1466 ) ;
147: Token * nextAfterAstRightmostLeaf ( Token * tok@var1467 ) ;
148:
149: Token * astParentSkipParens ( Token * tok@var1468 ) ;
150: const Token * astParentSkipParens ( const Token * tok@var1469 ) ;
151:
152: const Token * getParentMember ( const Token * tok@var1470 ) ;
153:
154: const Token * getParentLifetime ( const Token * tok@var1471 ) ;
155: const Token * getParentLifetime ( bool cpp@var1472 , const Token * tok@var1473 , const Library * library@var1474 ) ;
156:
157: bool astIsLHS ( const Token * tok@var1475 ) ;
158: bool astIsRHS ( const Token * tok@var1476 ) ;
159:
160: Token * getCondTok ( Token * tok@var1477 ) ;
161: const Token * getCondTok ( const Token * tok@var1478 ) ;
162:
163: Token * getInitTok ( Token * tok@var1479 ) ;
164: const Token * getInitTok ( const Token * tok@var1480 ) ;
165:
166: Token * getStepTok ( Token * tok@var1481 ) ;
167: const Token * getStepTok ( const Token * tok@var1482 ) ;
168:
169: Token * getCondTokFromEnd ( Token * endBlock@var1483 ) ;
170: const Token * getCondTokFromEnd ( const Token * endBlock@var1484 ) ;
171:
172:
173:
174: const Token * findNextTokenFromBreak ( const Token * breakToken@var1485 ) ;
175:
|
178:
179: bool extractForLoopValues ( const Token * forToken@var1486 ,
180: int * const varid@var1487 ,
181: bool * const knownInitValue@var1488 ,
182: long long * const initValue@var1489 ,
183: bool * const partialCond@var1490 ,
184: long long * const stepValue@var1491 ,
185: long long * const lastValue@var1492 ) ;
186:
187: bool precedes ( const Token * tok1@var1493 , const Token * tok2@var1494 ) ;
188: bool succeeds ( const Token * tok1@var1495 , const Token * tok2@var1496 ) ;
189:
190: bool exprDependsOnThis ( const Token * expr@var1497 , bool onVar@var1498 = true , int depth@var1499 = 0 ) ;
191:
192: struct ReferenceToken {
193: const Token * token@var1500 ;
194: std :: list < std :: pair < const Token * , std :: string > > errors@var1501 ;
195: } ;
196:
197: std :: vector < ReferenceToken > followAllReferences ( const Token * tok@var1502 ,
198: bool temporary@var1503 = true ,
199: bool inconclusive@var1504 = true ,
200: std :: list < std :: pair < const Token * , std :: string > > errors@var1505 = std :: list < std :: pair < const Token * , std :: string > > { } ,
201: int depth@var1506 = 20 ) ;
202: const Token * followReferences ( const Token * tok@var1507 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1508 = nullptr ) ;
203:
204: bool isSameExpression ( bool cpp@var1509 , bool macro@var1510 , const Token * tok1@var1511 , const Token * tok2@var1512 , const Library & library@var1513 , bool pure@var1514 , bool followVar@var1515 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1516 = nullptr ) ;
205:
206: bool isEqualKnownValue ( const Token * const tok1@var1517 , const Token * const tok2@var1518 ) ;
207:
|
210:
211: bool isUsedAsBool ( const Token * const tok@var1519 ) ;
212:
|
221:
222: bool isOppositeCond ( bool isNot@var1520 , bool cpp@var1521 , const Token * const cond1@var1522 , const Token * const cond2@var1523 , const Library & library@var1524 , bool pure@var1525 , bool followVar@var1526 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1527 = nullptr ) ;
223:
224: bool isOppositeExpression ( bool cpp@var1528 , const Token * const tok1@var1529 , const Token * const tok2@var1530 , const Library & library@var1531 , bool pure@var1532 , bool followVar@var1533 , std :: list < std :: pair < const Token * , std :: string > > * errors@var1534 = nullptr ) ;
225:
226: bool isConstFunctionCall ( const Token * ftok@var1535 , const Library & library@var1536 ) ;
227:
228: bool isConstExpression ( const Token * tok@var1537 , const Library & library@var1538 , bool pure@var1539 , bool cpp@var1540 ) ;
229:
230: bool isWithoutSideEffects ( bool cpp@var1541 , const Token * tok@var1542 , bool checkArrayAccess@var1543 = false , bool checkReference@var1544 = true ) ;
231:
232: bool isUniqueExpression ( const Token * tok@var1545 ) ;
233:
234: bool isEscapeFunction ( const Token * ftok@var1546 , const Library * library@var1547 ) ;
235:
236:
237: bool isReturnScope ( const Token * const endToken@var1548 ,
238: const Library * library@var1549 = nullptr ,
239: const Token * * unknownFunc@var1550 = nullptr ,
240: bool functionScope@var1551 = false ) ;
241:
242:
243: bool isWithinScope ( const Token * tok@var1552 ,
244: const Variable * var@var1553 ,
245: Scope :: ScopeType type@var1554 ) ;
246:
247:
248: const Token * getTokenArgumentFunction ( const Token * tok@var1555 , int & argn@var1556 ) ;
249: Token * getTokenArgumentFunction ( Token * tok@var1557 , int & argn@var1558 ) ;
250:
251: std :: vector < const Variable * > getArgumentVars ( const Token * tok@var1559 , int argnr@var1560 ) ;
252:
|
261:
262: bool isVariableChangedByFunctionCall ( const Token * tok@var1561 , int indirect@var1562 , int varid@var1563 , const Settings * settings@var1564 , bool * inconclusive@var1565 ) ;
263:
|
271:
272: bool isVariableChangedByFunctionCall ( const Token * tok@var1566 , int indirect@var1567 , const Settings * settings@var1568 , bool * inconclusive@var1569 ) ;
273:
274:
275: bool isVariableChanged ( const Token * start@var1570 , const Token * end@var1571 , const int exprid@var1572 , bool globalvar@var1573 , const Settings * settings@var1574 , bool cpp@var1575 , int depth@var1576 = 20 ) ;
276: bool isVariableChanged ( const Token * start@var1577 , const Token * end@var1578 , int indirect@var1579 , const int exprid@var1580 , bool globalvar@var1581 , const Settings * settings@var1582 , bool cpp@var1583 , int depth@var1584 = 20 ) ;
277:
278: bool isVariableChanged ( const Token * tok@var1585 , int indirect@var1586 , const Settings * settings@var1587 , bool cpp@var1588 , int depth@var1589 = 20 ) ;
279:
280: bool isVariableChanged ( const Variable * var@var1590 , const Settings * settings@var1591 , bool cpp@var1592 , int depth@var1593 = 20 ) ;
281:
282: bool isVariablesChanged ( const Token * start@var1594 ,
283: const Token * end@var1595 ,
284: int indirect@var1596 ,
285: std :: vector < const Variable * > vars@var1597 ,
286: const Settings * settings@var1598 ,
287: bool cpp@var1599 ) ;
288:
289: bool isThisChanged ( const Token * tok@var1600 , int indirect@var1601 , const Settings * settings@var1602 , bool cpp@var1603 ) ;
290: bool isThisChanged ( const Token * start@var1604 , const Token * end@var1605 , int indirect@var1606 , const Settings * settings@var1607 , bool cpp@var1608 ) ;
291:
292: const Token * findVariableChanged ( const Token * start@var1609 , const Token * end@var1610 , int indirect@var1611 , const int exprid@var1612 , bool globalvar@var1613 , const Settings * settings@var1614 , bool cpp@var1615 , int depth@var1616 = 20 ) ;
293: Token * findVariableChanged ( Token * start@var1617 , const Token * end@var1618 , int indirect@var1619 , const int exprid@var1620 , bool globalvar@var1621 , const Settings * settings@var1622 , bool cpp@var1623 , int depth@var1624 = 20 ) ;
294:
295: bool isExpressionChanged ( const Token * expr@var1625 ,
296: const Token * start@var1626 ,
297: const Token * end@var1627 ,
298: const Settings * settings@var1628 ,
299: bool cpp@var1629 ,
300: int depth@var1630 = 20 ) ;
301:
302: bool isExpressionChangedAt ( const Token * expr@var1631 ,
303: const Token * tok@var1632 ,
304: int indirect@var1633 ,
305: bool globalvar@var1634 ,
306: const Settings * settings@var1635 ,
307: bool cpp@var1636 ,
308: int depth@var1637 = 20 ) ;
309:
310:
311: bool isAliasOf ( const Token * tok@var1638 , int varid@var1639 , bool * inconclusive@var1640 = nullptr ) ;
312:
313: bool isAliased ( const Variable * var@var1641 ) ;
314:
315: const Token * getArgumentStart ( const Token * ftok@var1642 ) ;
316:
|
320:
321: int numberOfArguments ( const Token * ftok@var1643 ) ;
322:
323:
324: int numberOfArgumentsWithoutAst ( const Token * start@var1644 ) ;
325:
|
328:
329: std :: vector < const Token * > getArguments ( const Token * ftok@var1645 ) ;
330:
331: int getArgumentPos ( const Variable * var@var1646 , const Function * f@var1647 ) ;
332:
|
335:
336: bool isIteratorPair ( std :: vector < const Token * > args@var1648 ) ;
337:
338: const Token * findLambdaStartToken ( const Token * last@var1649 ) ;
339:
|
344:
345: const Token * findLambdaEndToken ( const Token * first@var1650 ) ;
346: Token * findLambdaEndToken ( Token * first@var1651 ) ;
347:
348: bool isLikelyStream ( bool cpp@var1652 , const Token * stream@var1653 ) ;
349:
|
354:
355: bool isLikelyStreamRead ( bool cpp@var1654 , const Token * op@var1655 ) ;
356:
357: bool isCPPCast ( const Token * tok@var1656 ) ;
358:
359: bool isConstVarExpression ( const Token * tok@var1657 , const char * skipMatch@var1658 = nullptr ) ;
360:
361: const Variable * getLHSVariable ( const Token * tok@var1659 ) ;
362:
363: const Token * getLHSVariableToken ( const Token * tok@var1660 ) ;
364:
365: std :: vector < const Variable * > getLHSVariables ( const Token * tok@var1661 ) ;
366:
367:
368: const Token * findAllocFuncCallToken ( const Token * expr@var1662 , const Library & library@var1663 ) ;
369:
370: bool isScopeBracket ( const Token * tok@var1664 ) ;
371:
372: bool isNullOperand ( const Token * expr@var1665 ) ;
373:
374: bool isGlobalData ( const Token * expr@var1666 , bool cpp@var1667 ) ;
375:
|
380:
381: class FwdAnalysis {
382: public:
383: FwdAnalysis ( bool cpp@var1668 , const Library & library@var1669 ) : mCpp@var1702 ( cpp@var1668 ) , mLibrary@var1703 ( library@var1669 ) , mWhat@var1704 ( What :: Reassign ) , mValueFlowKnown@var1706 ( true ) { }
384:
385: bool hasOperand ( const Token * tok@var1670 , const Token * lhs@var1671 ) const ;
386:
|
393:
394: const Token * reassign ( const Token * expr@var1672 , const Token * startToken@var1673 , const Token * endToken@var1674 ) ;
395:
|
402:
403: bool unusedValue ( const Token * expr@var1675 , const Token * startToken@var1676 , const Token * endToken@var1677 ) ;
404:
405: struct KnownAndToken {
406: bool known@var1678 ;
407: const Token * token@var1679 ;
408: } ;
409:
410:
411: bool possiblyAliased ( const Token * expr@var1680 , const Token * startToken@var1681 ) const ;
412:
413: std :: set < int > getExprVarIds ( const Token * expr@var1682 , bool * localOut@var1683 = nullptr , bool * unknownVarIdOut@var1684 = nullptr ) const ;
414: private:
415: static bool isEscapedAlias ( const Token * expr@var1685 ) ;
416:
417:
418: struct Result {
419: enum class Type { NONE , READ , WRITE , BREAK , RETURN , BAILOUT } ; enum Type type@var1686 ;
420: explicit Result ( Type type@var1687 ) : type@var1686 ( type@var1687 ) , token@var1690 ( nullptr ) { }
421: Result ( Type type@var1688 , const Token * token@var1689 ) : type@var1686 ( type@var1688 ) , token@var1690 ( token@var1689 ) { }
422: const Token * token@var1690 ;
423: } ;
424:
425: struct Result check ( const Token * expr@var1691 , const Token * startToken@var1692 , const Token * endToken@var1693 ) ;
426: struct Result checkRecursive ( const Token * expr@var1694 , const Token * startToken@var1695 , const Token * endToken@var1696 , const std :: set < int > & exprVarIds@var1697 , bool local@var1698 , bool inInnerClass@var1699 , int depth@var1700 = 0 ) ;
427:
428:
429: bool isGlobalData ( const Token * expr@var1701 ) const ;
430:
431: const bool mCpp@var1702 ;
432: const Library & mLibrary@var1703 ;
433: enum class What { Reassign , UnusedValue , ValueFlow } ; enum What mWhat@var1704 ;
434: std :: vector < KnownAndToken > mValueFlow@var1705 ;
435: bool mValueFlowKnown@var1706 ;
436: } ;
437:
438: bool isSizeOfEtc ( const Token * tok@var1707 ) ;

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var1708 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var1709 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var1710 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var1711 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var1712 , const std :: string & fname2@var1713 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var1714 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var1715 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var1716 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var1717 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var1718 , const std :: vector < std :: string > & basePaths@var1719 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var1720 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var1721 ) {
135: const std ::@expr1073745923 set < std ::@expr1073745924 string > extra@var1722 ;
136: return acceptFile (@expr1073745925 filename@var1721 , extra@var1722 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var1723 , const std :: set < std :: string > & extra@var1724 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var1725 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var1726 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var1727 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var1728 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var1729 ) ;
182: } ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var1730 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var1731 ) {
47: mSettings@var1766 =@expr1073745926 settings@var1731 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var1766 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var1768 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var1769 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var1732 ) ;
72:
73: void addtoken ( const std :: string & str@var1733 , const int lineno@var1734 , const int column@var1735 , const int fileno@var1736 , bool split@var1737 = false ) ;
74: void addtoken ( const std :: string & str@var1738 , const Token * locationTok@var1739 ) ;
75:
76: void addtoken ( const Token * tok@var1740 , const int lineno@var1741 , const int column@var1742 , const int fileno@var1743 ) ;
77: void addtoken ( const Token * tok@var1744 , const Token * locationTok@var1745 ) ;
78: void addtoken ( const Token * tok@var1746 ) ;
79:
80: static void insertTokens ( Token * dest@var1747 , const Token * src@var1748 , int n@var1749 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var1750 , const Token * first@var1751 , const Token * last@var1752 , bool one_line@var1753 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var1754 , const std :: string & file0@var1755 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var1756 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var1757 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var1763 .@expr1073745927 front@var1770 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var1763 .@expr1073745928 front@var1770 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var1763 .@expr1073745929 back@var1771 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var1763 .@expr1073745930 back@var1771 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var1764 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var1758 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var1759 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var1760 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var1761 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var1762 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var1763 ;
206:
207:
208: std :: vector < std :: string > mFiles@var1764 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var1765 ;
212:
213:
214: const Settings * mSettings@var1766 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var1767 ;
217:
218:
219: bool mIsC@var1768 ;
220: bool mIsCpp@var1769 ;
221: } ;

##file cppcheck-2.8/lib/library.cpp

1:
|
41:
42: static std :: vector < std :: string > getnames ( const char * names@var1772 )
43: {
44: std ::@expr1073745931 vector < std ::@expr1073745932 string > ret@var1773 ;
45: while (@expr1073745933 const char *@expr1073745934 p@var1774 =@expr1073745935 std ::@expr1073745936 strchr (@expr1073745937 names@var1772 , ',' ) ) {
46: ret@var1773 .@expr4114 emplace_back (@expr1073745939 names@var1772 , p@var1774 -@expr1073745940 names@var1772 ) ;
47: names@var1772 =@expr1073745941 p@var1774 +@expr1073745942 1 ;
48: }
49: ret@var1773 .@expr4114 emplace_back (@expr1073745944 names@var1772 ) ;
50: return ret@var1773 ;
51: }
52:
53: static void gettokenlistfromvalid ( const std :: string & valid@var1775 , TokenList & tokenList@var1776 )
54: {
55: std ::@expr1073745945 istringstream istr@var1777 (@expr1073745946 valid@var1775 +@expr1073745947 ',' ) ;
56: tokenList@var1776 .@expr1073745948 createTokens (@expr1073745949 istr@var1777 ) ;
57: for (@expr1073745950 Token *@expr1073745951 tok@var1778 =@expr1073745952 tokenList@var1776 .@expr1073745953 front (@expr1073745954 ) ; tok@var1778 ; tok@var1778 =@expr1073745955 tok@var1778 .@expr1073745956 next (@expr1073745957 ) ) {
58: if (@expr1073745958 Token ::@expr1073745959 Match (@expr1073745960 tok@var1778 , "- %num%" ) ) {
59: tok@var1778 .@expr1073745961 str (@expr1073745962 "-" +@expr1073745963 tok@var1778 .@expr1073745964 strAt (@expr1073745965 1 ) ) ;
60: tok@var1778 .@expr1073745966 deleteNext (@expr1073745967 ) ;
61: }
62: }
63: }
64:
65: Library :: Library ( ) : mAllocId@var441 ( 0 )
66: { }
67:
68: Library :: Error Library :: load ( const char exename@var1779 [ ] , const char path@var1780 [ ] )
69: {
70: if (@expr1073745975 std ::@expr1073745976 strchr (@expr1073745977 path@var1780 , ',' ) !=@expr1073745978 nullptr ) {
71: std ::@expr1073745979 string p@var1781 (@expr1073745980 path@var1780 ) ;
72: for (@expr1073745981 ; ; ) {
73: const std ::@expr4158 string ::@expr4158 size_type pos@var1782 =@expr1073745984 p@var1781 .@expr1073745985 find (@expr1073745986 ',' ) ;
74: if (@expr1073745987 pos@var1782 ==@expr1073745988 std ::@expr1073745989 string ::@expr1073745990 npos@expr1073745968 ) {
75: break ; }
76: const Error &@expr1073745991 e@var1783 =@expr1073745992 load (@expr1073745993 exename@var1779 , p@var1781 .@expr4170 substr (@expr1073745995 0 , pos@var1782 ) .@expr1073745996 c_str (@expr1073745997 ) ) ;
77: if (@expr1073745998 e@var1783 .@expr1073745999 errorcode@var1784 !=@expr1073746000 ErrorCode ::@expr4177 OK@expr4145 ) {
78: return e@var1783 ; }
79: p@var1781 =@expr1073746002 p@var1781 .@expr4170 substr (@expr1073746004 pos@var1782 +@expr1073746005 1 ) ;
80: }
81: if (@expr1073746006 !@expr1073746007 p@var1781 .@expr1073746008 empty (@expr1073746009 ) ) {
82: return load (@expr1073746010 exename@var1779 , p@var1781 .@expr1073746011 c_str (@expr1073746012 ) ) ; }
83: return Error (@expr1073746013 ) ;
84: }
85:
86: std ::@expr1073746014 string absolute_path@var1785 ;
87:
88: tinyxml2 ::@expr1073746015 XMLDocument doc@var1786 ;
89: tinyxml2 ::@expr1073746016 XMLError error@var1787 ; error@var1787 =@expr1073746017 doc@var1786 .@expr4194 LoadFile (@expr1073746019 path@var1780 ) ;
90: if (@expr1073746020 error@var1787 ==@expr1073746021 tinyxml2 ::@expr1073746022 XML_ERROR_FILE_READ_ERROR@expr1073745970 &&@expr1073746023 Path ::@expr4200 getFilenameExtension (@expr1073746025 path@var1780 ) .@expr1073746026 empty (@expr1073746027 ) ) {
91:
92: error@var1787 =@expr1073746028 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 ; }
93: if (@expr4206 error@var1787 ==@expr4207 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 ) {
94:
95: std ::@expr1073746033 string fullfilename@var1788 (@expr1073746034 path@var1780 ) ;
96: if (@expr1073746035 Path ::@expr4200 getFilenameExtension (@expr1073746037 fullfilename@var1788 ) .@expr1073746038 empty (@expr1073746039 ) ) {
97: fullfilename@var1788 +=@expr1073746040 ".cfg" ;
98: error@var1787 =@expr1073746041 doc@var1786 .@expr4194 LoadFile (@expr1073746043 fullfilename@var1788 .@expr1073746044 c_str (@expr1073746045 ) ) ;
99: if (@expr4222 error@var1787 !=@expr4223 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 ) {
100: absolute_path@var1785 =@expr1073746049 Path ::@expr4226 getAbsoluteFilePath (@expr1073746051 fullfilename@var1788 ) ; }
101: }
102:
103: std ::@expr1073746052 list < std ::@expr4158 string > cfgfolders@var1789 ;
104:
105:
106:
107: if (@expr1073746054 exename@var1779 ) {
108: const std ::@expr1073746055 string exepath@var1790 (@expr1073746056 Path ::@expr1073746057 fromNativeSeparators (@expr1073746058 Path ::@expr1073746059 getPathFromFilename (@expr1073746060 exename@var1779 ) ) ) ;
109: cfgfolders@var1789 .@expr4237 push_back (@expr1073746062 exepath@var1790 +@expr1073746063 "cfg" ) ;
110: cfgfolders@var1789 .@expr4237 push_back (@expr1073746065 exepath@var1790 ) ;
111: }
112:
113: while (@expr1073746066 error@var1787 ==@expr4207 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 &&@expr1073746069 !@expr1073746070 cfgfolders@var1789 .@expr1073746071 empty (@expr1073746072 ) ) {
114: const std ::@expr1073746073 string cfgfolder@var1791 (@expr1073746074 cfgfolders@var1789 .@expr1073746075 back (@expr1073746076 ) ) ;
115: cfgfolders@var1789 .@expr1073746077 pop_back (@expr1073746078 ) ;
116: const char * sep@var1792 ; sep@var1792 =@expr1073746079 !@expr1073746080 cfgfolder@var1791 .@expr1073746081 empty (@expr1073746082 ) &&@expr1073746083 endsWith (@expr1073746084 cfgfolder@var1791 , '/' ) ?@expr1073746085 "" :@expr1073746086 "/" ;
117: const std ::@expr1073746087 string filename@var1793 (@expr1073746088 cfgfolder@var1791 +@expr1073746089 sep@var1792 +@expr1073746090 fullfilename@var1788 ) ;
118: error@var1787 =@expr1073746091 doc@var1786 .@expr4194 LoadFile (@expr1073746093 filename@var1793 .@expr1073746094 c_str (@expr1073746095 ) ) ;
119: if (@expr4222 error@var1787 !=@expr4223 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 ) {
120: absolute_path@var1785 =@expr1073746099 Path ::@expr4226 getAbsoluteFilePath (@expr1073746101 filename@var1793 ) ; }
121: }
122: } else {
123: absolute_path@var1785 =@expr1073746102 Path ::@expr4226 getAbsoluteFilePath (@expr1073746104 path@var1780 ) ; }
124:
125: if (@expr1073746105 error@var1787 ==@expr1073746106 tinyxml2 ::@expr1073746107 XML_SUCCESS@expr1073745972 ) {
126: if (@expr1073746108 mFiles@var442 .@expr1073746109 find (@expr1073746110 absolute_path@var1785 ) ==@expr1073746111 mFiles@var442 .@expr1073746112 end (@expr1073746113 ) ) {
127: Error err@var1794 ; err@var1794 =@expr1073746114 load (@expr1073746115 doc@var1786 ) ;
128: if (@expr1073746116 err@var1794 .@expr1073746117 errorcode@var1795 ==@expr1073746118 ErrorCode ::@expr4177 OK@expr4145 ) {
129: mFiles@var442 .@expr1073746120 insert (@expr1073746121 absolute_path@var1785 ) ; }
130: return err@var1794 ;
131: }
132:
133: return Error (@expr1073746122 ErrorCode ::@expr4177 OK@expr4145 ) ;
134: }
135:
136: if (@expr4206 error@var1787 ==@expr4207 tinyxml2 ::@expr4205 XML_ERROR_FILE_NOT_FOUND@expr4147 ) {
137: return Error (@expr1073746127 ErrorCode ::@expr1073746128 FILE_NOT_FOUND@expr1073745973 ) ; }
138: else {
139: doc@var1786 .@expr1073746129 PrintError (@expr1073746130 ) ;
140: return Error (@expr1073746131 ErrorCode ::@expr1073746132 BAD_XML@expr1073745974 ) ;
141: }
142: }
143:
144: Library :: Container :: Yield Library :: Container :: yieldFrom ( const std :: string & yieldName@var1796 )
145: {
146: if (@expr1073746143 yieldName@var1796 ==@expr1073746144 "at_index" ) {
147: return Container ::@expr4321 Yield ::@expr1073746146 AT_INDEX@expr1073746133 ; }
148: else { if (@expr1073746147 yieldName@var1796 ==@expr1073746148 "item" ) {
149: return Container ::@expr4321 Yield ::@expr1073746150 ITEM@expr1073746134 ; }
150: else { if (@expr1073746151 yieldName@var1796 ==@expr1073746152 "buffer" ) {
151: return Container ::@expr4321 Yield ::@expr1073746154 BUFFER@expr1073746135 ; }
152: else { if (@expr1073746155 yieldName@var1796 ==@expr1073746156 "buffer-nt" ) {
153: return Container ::@expr4321 Yield ::@expr1073746158 BUFFER_NT@expr1073746136 ; }
154: else { if (@expr1073746159 yieldName@var1796 ==@expr1073746160 "start-iterator" ) {
155: return Container ::@expr4321 Yield ::@expr1073746162 START_ITERATOR@expr1073746137 ; }
156: else { if (@expr1073746163 yieldName@var1796 ==@expr1073746164 "end-iterator" ) {
157: return Container ::@expr4321 Yield ::@expr1073746166 END_ITERATOR@expr1073746138 ; }
158: else { if (@expr1073746167 yieldName@var1796 ==@expr1073746168 "iterator" ) {
159: return Container ::@expr4321 Yield ::@expr1073746170 ITERATOR@expr1073746139 ; }
160: else { if (@expr1073746171 yieldName@var1796 ==@expr1073746172 "size" ) {
161: return Container ::@expr4321 Yield ::@expr1073746174 SIZE@expr1073746140 ; }
162: else { if (@expr1073746175 yieldName@var1796 ==@expr1073746176 "empty" ) {
163: return Container ::@expr4321 Yield ::@expr1073746178 EMPTY@expr1073746141 ; }
164: else {
165: return Container ::@expr4321 Yield ::@expr1073746180 NO_YIELD@expr1073746142 ; } } } } } } } } }
166: }
167: Library :: Container :: Action Library :: Container :: actionFrom ( const std :: string & actionName@var1797 )
168: {
169: if (@expr1073746192 actionName@var1797 ==@expr1073746193 "resize" ) {
170: return Container ::@expr4370 Action ::@expr1073746195 RESIZE@expr1073746181 ; }
171: else { if (@expr1073746196 actionName@var1797 ==@expr1073746197 "clear" ) {
172: return Container ::@expr4370 Action ::@expr1073746199 CLEAR@expr1073746182 ; }
173: else { if (@expr1073746200 actionName@var1797 ==@expr1073746201 "push" ) {
174: return Container ::@expr4370 Action ::@expr1073746203 PUSH@expr1073746183 ; }
175: else { if (@expr1073746204 actionName@var1797 ==@expr1073746205 "pop" ) {
176: return Container ::@expr4370 Action ::@expr1073746207 POP@expr1073746184 ; }
177: else { if (@expr1073746208 actionName@var1797 ==@expr1073746209 "find" ) {
178: return Container ::@expr4370 Action ::@expr1073746211 FIND@expr1073746185 ; }
179: else { if (@expr1073746212 actionName@var1797 ==@expr1073746213 "insert" ) {
180: return Container ::@expr4370 Action ::@expr1073746215 INSERT@expr1073746186 ; }
181: else { if (@expr1073746216 actionName@var1797 ==@expr1073746217 "erase" ) {
182: return Container ::@expr4370 Action ::@expr1073746219 ERASE@expr1073746187 ; }
183: else { if (@expr1073746220 actionName@var1797 ==@expr1073746221 "change-content" ) {
184: return Container ::@expr4370 Action ::@expr1073746223 CHANGE_CONTENT@expr1073746188 ; }
185: else { if (@expr1073746224 actionName@var1797 ==@expr1073746225 "change-internal" ) {
186: return Container ::@expr4370 Action ::@expr1073746227 CHANGE_INTERNAL@expr1073746189 ; }
187: else { if (@expr1073746228 actionName@var1797 ==@expr1073746229 "change" ) {
188: return Container ::@expr4370 Action ::@expr1073746231 CHANGE@expr1073746190 ; }
189: else {
190: return Container ::@expr4370 Action ::@expr1073746233 NO_ACTION@expr1073746191 ; } } } } } } } } } }
191: }
192:
193:
194: bool Library :: loadxmldata ( const char xmldata@var1798 [ ] , unsigned long len@var1799 )
195: {
196: tinyxml2 ::@expr1073746236 XMLDocument doc@var1800 ;
197: return (@expr4413 tinyxml2 ::@expr1073746238 XML_SUCCESS@expr1073746234 ==@expr1073746239 doc@var1800 .@expr1073746240 Parse (@expr1073746241 xmldata@var1798 , len@var1799 ) ) &&@expr1073746242 (@expr4413 load (@expr1073746244 doc@var1800 ) .@expr1073746245 errorcode@var1801 ==@expr1073746246 ErrorCode ::@expr1073746247 OK@expr1073746235 ) ;
198: }
199:
200: Library :: Error Library :: load ( const tinyxml2 :: XMLDocument & doc@var1802 )
201: {
202: const tinyxml2 ::@expr1073746277 XMLElement@expr1073746248 * const rootnode@var1803 ; rootnode@var1803 =@expr1073746278 doc@var1802 .@expr1073746279 FirstChildElement (@expr1073746280 ) ;
203:
204: if (@expr1073746281 rootnode@var1803 ==@expr1073746282 nullptr ) {
205: doc@var1802 .@expr1073746283 PrintError (@expr1073746284 ) ;
206: return Error (@expr1073746285 ErrorCode ::@expr1073746286 BAD_XML@expr1073746249 ) ;
207: }
208:
209: if (@expr1073746287 strcmp (@expr1073746288 rootnode@var1803 .@expr4465 Name (@expr4466 ) , "def" ) !=@expr1073746291 0 ) {
210: return Error (@expr1073746292 ErrorCode ::@expr4469 UNSUPPORTED_FORMAT@expr4426 , rootnode@var1803 .@expr4465 Name (@expr4466 ) ) ; }
211:
212: int format@var1804 ; format@var1804 =@expr1073746296 rootnode@var1803 .@expr1073746297 IntAttribute (@expr1073746298 "format" , 1 ) ;
213:
214: if (@expr1073746299 format@var1804 >@expr1073746300 2 ||@expr1073746301 format@var1804 <=@expr1073746302 0 ) {
215: return Error (@expr1073746303 ErrorCode ::@expr4469 UNSUPPORTED_FORMAT@expr4426 ) ; }
216:
217: std ::@expr1073746305 set < std ::@expr4482 string > unknown_elements@var1805 ;
218:
219: for (@expr1073746307 const tinyxml2 ::@expr4482 XMLElement *@expr4485 node@var1806 =@expr1073746310 rootnode@var1803 .@expr1073746311 FirstChildElement (@expr1073746312 ) ; node@var1806 ; node@var1806 =@expr1073746313 node@var1806 .@expr1073746314 NextSiblingElement (@expr1073746315 ) ) {
220: const std ::@expr4482 string nodename@var1807 =@expr1073746317 node@var1806 .@expr1073746318 Name (@expr1073746319 ) ;
221: if (@expr1073746320 nodename@var1807 ==@expr4497 "memory" ||@expr1073746322 nodename@var1807 ==@expr1073746323 "resource" ) {
222:
223: int allocationId@var1808 ; allocationId@var1808 =@expr1073746324 0 ;
224: for (@expr1073746325 const tinyxml2 ::@expr4482 XMLElement *@expr4485 memorynode@var1809 =@expr1073746328 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; memorynode@var1809 ; memorynode@var1809 =@expr1073746331 memorynode@var1809 .@expr1073746332 NextSiblingElement (@expr1073746333 ) ) {
225: if (@expr1073746334 strcmp (@expr1073746335 memorynode@var1809 .@expr1073746336 Name (@expr1073746337 ) , "dealloc" ) ==@expr1073746338 0 ) {
226: const std ::@expr1073746339 map < std ::@expr4482 string , AllocFunc > ::@expr1073746341 const_iterator it@var1810 =@expr1073746342 mDealloc@var444 .@expr1073746343 find (@expr1073746344 memorynode@var1809 .@expr1073746345 GetText (@expr1073746346 ) ) ;
227: if (@expr1073746347 it@var1810 !=@expr1073746348 mDealloc@var444 .@expr1073746349 end (@expr1073746350 ) ) {
228: allocationId@var1808 =@expr1073746351 it@var1810 .@expr1073746352 second@var1811 .@expr1073746353 groupId@var1812 ;
229: break ;
230: }
231: }
232: }
233: if (@expr1073746354 allocationId@var1808 ==@expr1073746355 0 ) {
234: if (@expr1073746356 nodename@var1807 ==@expr4497 "memory" ) {
235: while (@expr1073746358 !@expr1073746359 ismemory (@expr1073746360 ++@expr1073746361 mAllocId@var441 ) ) { ; } }
236: else {
237: while (@expr1073746362 !@expr1073746363 isresource (@expr1073746364 ++@expr1073746365 mAllocId@var441 ) ) { ; } }
238: allocationId@var1808 =@expr1073746366 mAllocId@var441 ;
239: }
240:
241:
242: for (@expr1073746367 const tinyxml2 ::@expr4482 XMLElement *@expr4485 memorynode@var1813 =@expr1073746370 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; memorynode@var1813 ; memorynode@var1813 =@expr1073746373 memorynode@var1813 .@expr1073746374 NextSiblingElement (@expr1073746375 ) ) {
243: const std ::@expr4482 string memorynodename@var1814 =@expr1073746377 memorynode@var1813 .@expr1073746378 Name (@expr1073746379 ) ;
244: if (@expr1073746380 memorynodename@var1814 ==@expr1073746381 "alloc" ||@expr1073746382 memorynodename@var1814 ==@expr4559 "realloc" ) {
245: AllocFunc temp@var1815 ; temp@var1815 =@expr1073746384 {@expr1073746385 0 } ;
246: temp@var1815 .@expr1073746386 groupId@var1816 =@expr1073746387 allocationId@var1808 ;
247:
248: temp@var1815 .@expr1073746388 initData@var1817 =@expr1073746389 memorynode@var1813 .@expr1073746390 BoolAttribute (@expr1073746391 "init" , true ) ;
249: temp@var1815 .@expr1073746392 arg@var1818 =@expr1073746393 memorynode@var1813 .@expr4570 IntAttribute (@expr1073746395 "arg" , -1 ) ;
250:
251: const char * bufferSize@var1819 ; bufferSize@var1819 =@expr1073746396 memorynode@var1813 .@expr1073746397 Attribute (@expr1073746398 "buffer-size" ) ;
252: if (@expr1073746399 !@expr1073746400 bufferSize@var1819 ) {
253: temp@var1815 .@expr4577 bufferSize@var1820 =@expr1073746402 AllocFunc ::@expr4579 BufferSize ::@expr1073746404 none@expr1073746251 ; }
254: else {
255: if (@expr1073746405 std ::@expr4582 strncmp (@expr1073746407 bufferSize@var1819 , "malloc" , 6 ) ==@expr1073746408 0 ) {
256: temp@var1815 .@expr4577 bufferSize@var1820 =@expr1073746410 AllocFunc ::@expr4579 BufferSize ::@expr1073746412 malloc@expr1073746252 ; }
257: else { if (@expr1073746413 std ::@expr4582 strncmp (@expr1073746415 bufferSize@var1819 , "calloc" , 6 ) ==@expr1073746416 0 ) {
258: temp@var1815 .@expr4577 bufferSize@var1820 =@expr1073746418 AllocFunc ::@expr4579 BufferSize ::@expr1073746420 calloc@expr1073746253 ; }
259: else { if (@expr1073746421 std ::@expr4582 strncmp (@expr1073746423 bufferSize@var1819 , "strdup" , 6 ) ==@expr1073746424 0 ) {
260: temp@var1815 .@expr4577 bufferSize@var1820 =@expr1073746426 AllocFunc ::@expr4579 BufferSize ::@expr1073746428 strdup@expr1073746254 ; }
261: else {
262: return Error (@expr4605 ErrorCode ::@expr4606 BAD_ATTRIBUTE_VALUE@expr4431 , bufferSize@var1819 ) ; } } }
263: temp@var1815 .@expr4607 bufferSizeArg1@var1821 =@expr1073746432 1 ;
264: temp@var1815 .@expr4609 bufferSizeArg2@var1822 =@expr1073746434 2 ;
265: if (@expr1073746435 bufferSize@var1819 [@expr4612 6 ] ==@expr1073746437 0 ) {
266:
267: } else { if (@expr1073746438 bufferSize@var1819 [@expr4612 6 ] ==@expr1073746440 ':' &&@expr1073746441 bufferSize@var1819 [@expr4618 7 ] >=@expr1073746443 '1' &&@expr1073746444 bufferSize@var1819 [@expr4618 7 ] <=@expr1073746446 '5' ) {
268: temp@var1815 .@expr4607 bufferSizeArg1@var1821 =@expr1073746448 bufferSize@var1819 [@expr4618 7 ] -@expr1073746450 '0' ;
269: if (@expr1073746451 bufferSize@var1819 [@expr1073746452 8 ] ==@expr1073746453 ',' &&@expr1073746454 bufferSize@var1819 [@expr4631 9 ] >=@expr1073746456 '1' &&@expr1073746457 bufferSize@var1819 [@expr4631 9 ] <=@expr1073746459 '5' ) {
270: temp@var1815 .@expr4609 bufferSizeArg2@var1822 =@expr1073746461 bufferSize@var1819 [@expr4631 9 ] -@expr1073746463 '0' ; }
271: } else {
272: return Error (@expr4605 ErrorCode ::@expr4606 BAD_ATTRIBUTE_VALUE@expr4431 , bufferSize@var1819 ) ; } }
273: }
274:
275: if (@expr1073746466 memorynodename@var1814 ==@expr4559 "realloc" ) {
276: temp@var1815 .@expr1073746468 reallocArg@var1823 =@expr1073746469 memorynode@var1813 .@expr4570 IntAttribute (@expr1073746471 "realloc-arg" , 1 ) ; }
277:
278: if (@expr1073746472 memorynodename@var1814 !=@expr1073746473 "realloc" ) {
279: mAlloc@var443 [@expr1073746474 memorynode@var1813 .@expr4651 GetText (@expr4652 ) ] =@expr1073746477 temp@var1815 ; }
280: else {
281: mRealloc@var445 [@expr1073746478 memorynode@var1813 .@expr4651 GetText (@expr4652 ) ] =@expr1073746481 temp@var1815 ; }
282: } else { if (@expr1073746482 memorynodename@var1814 ==@expr1073746483 "dealloc" ) {
283: AllocFunc temp@var1824 ; temp@var1824 =@expr1073746484 {@expr1073746485 0 } ;
284: temp@var1824 .@expr1073746486 groupId@var1825 =@expr1073746487 allocationId@var1808 ;
285: temp@var1824 .@expr1073746488 arg@var1826 =@expr1073746489 memorynode@var1813 .@expr4570 IntAttribute (@expr1073746491 "arg" , 1 ) ;
286: mDealloc@var444 [@expr1073746492 memorynode@var1813 .@expr4651 GetText (@expr4652 ) ] =@expr1073746495 temp@var1824 ;
287: } else { if (@expr1073746496 memorynodename@var1814 ==@expr1073746497 "use" ) {
288: functions@var299 [@expr1073746498 memorynode@var1813 .@expr4651 GetText (@expr4652 ) ] .@expr1073746501 use@expr1073746256 =@expr1073746502 true ; }
289: else {
290: unknown_elements@var1805 .@expr4679 insert (@expr1073746504 memorynodename@var1814 ) ; } } }
291: }
292: }
293:
294: else { if (@expr1073746505 nodename@var1807 ==@expr1073746506 "define" ) {
295: const char * name@var1827 ; name@var1827 =@expr1073746507 node@var1806 .@expr4684 Attribute (@expr4685 "name" ) ;
296: if (@expr1073746510 name@var1827 ==@expr1073746511 nullptr ) {
297: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
298: const char * value@var1828 ; value@var1828 =@expr1073746514 node@var1806 .@expr4684 Attribute (@expr4692 "value" ) ;
299: if (@expr1073746517 value@var1828 ==@expr1073746518 nullptr ) {
300: return Error (@expr4695 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "value" ) ; }
301: defines@var378 .@expr1073746521 push_back (@expr1073746522 std ::@expr4699 string (@expr1073746524 name@var1827 ) +@expr1073746525
302: " " +@expr1073746526
303: value@var1828 ) ;
304: }
305:
306: else { if (@expr1073746527 nodename@var1807 ==@expr1073746528 "function" ) {
307: const char * name@var1829 ; name@var1829 =@expr1073746529 node@var1806 .@expr4684 Attribute (@expr4685 "name" ) ;
308: if (@expr1073746532 name@var1829 ==@expr1073746533 nullptr ) {
309: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
310: for (@expr1073746536 const std ::@expr4482 string &@expr4714 s@var1830 :@expr1073746539 getnames (@expr1073746540 name@var1829 ) ) {
311: const Error &@expr4714 err@var1831 =@expr1073746542 loadFunction (@expr1073746543 node@var1806 , s@var1830 , unknown_elements@var1805 ) ;
312: if (@expr1073746544 err@var1831 .@expr1073746545 errorcode@var1832 !=@expr1073746546 ErrorCode ::@expr4723 OK@expr4434 ) {
313: return err@var1831 ; }
314: }
315: }
316:
317: else { if (@expr1073746548 nodename@var1807 ==@expr1073746549 "reflection" ) {
318: for (@expr1073746550 const tinyxml2 ::@expr4482 XMLElement *@expr4485 reflectionnode@var1833 =@expr1073746553 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; reflectionnode@var1833 ; reflectionnode@var1833 =@expr1073746556 reflectionnode@var1833 .@expr1073746557 NextSiblingElement (@expr1073746558 ) ) {
319: if (@expr1073746559 strcmp (@expr1073746560 reflectionnode@var1833 .@expr4737 Name (@expr4738 ) , "call" ) !=@expr1073746563 0 ) {
320: unknown_elements@var1805 .@expr4679 insert (@expr1073746565 reflectionnode@var1833 .@expr4737 Name (@expr4738 ) ) ;
321: continue ;
322: }
323:
324: const char * const argString@var1834 ; argString@var1834 =@expr1073746568 reflectionnode@var1833 .@expr1073746569 Attribute (@expr1073746570 "arg" ) ;
325: if (@expr1073746571 !@expr1073746572 argString@var1834 ) {
326: return Error (@expr1073746573 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "arg" ) ; }
327:
328: mReflection@var458 [@expr1073746575 reflectionnode@var1833 .@expr1073746576 GetText (@expr1073746577 ) ] =@expr1073746578 atoi (@expr1073746579 argString@var1834 ) ;
329: }
330: }
331:
332: else { if (@expr1073746580 nodename@var1807 ==@expr1073746581 "markup" ) {
333: const char * const extension@var1835 ; extension@var1835 =@expr1073746582 node@var1806 .@expr4684 Attribute (@expr1073746584 "ext" ) ;
334: if (@expr1073746585 !@expr1073746586 extension@var1835 ) {
335: return Error (@expr1073746587 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "ext" ) ; }
336: mMarkupExtensions@var453 .@expr1073746589 insert (@expr1073746590 extension@var1835 ) ;
337:
338: mReportErrors@var451 [@expr1073746591 extension@var1835 ] =@expr1073746592 node@var1806 .@expr4684 Attribute (@expr1073746594 "reporterrors" , "true" ) !=@expr1073746595 nullptr ;
339: mProcessAfterCode@var452 [@expr1073746596 extension@var1835 ] =@expr1073746597 node@var1806 .@expr4684 Attribute (@expr1073746599 "aftercode" , "true" ) !=@expr1073746600 nullptr ;
340:
341: for (@expr1073746601 const tinyxml2 ::@expr4482 XMLElement *@expr4485 markupnode@var1836 =@expr1073746604 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; markupnode@var1836 ; markupnode@var1836 =@expr1073746607 markupnode@var1836 .@expr1073746608 NextSiblingElement (@expr1073746609 ) ) {
342: const std ::@expr4482 string markupnodename@var1837 =@expr1073746611 markupnode@var1836 .@expr1073746612 Name (@expr1073746613 ) ;
343: if (@expr1073746614 markupnodename@var1837 ==@expr1073746615 "keywords" ) {
344: for (@expr1073746616 const tinyxml2 ::@expr4482 XMLElement *@expr4485 librarynode@var1838 =@expr1073746619 markupnode@var1836 .@expr4796 FirstChildElement (@expr4797 ) ; librarynode@var1838 ; librarynode@var1838 =@expr1073746622 librarynode@var1838 .@expr1073746623 NextSiblingElement (@expr1073746624 ) ) {
345: if (@expr1073746625 strcmp (@expr1073746626 librarynode@var1838 .@expr4803 Name (@expr4804 ) , "keyword" ) ==@expr1073746629 0 ) {
346: const char * nodeName@var1839 ; nodeName@var1839 =@expr1073746630 librarynode@var1838 .@expr1073746631 Attribute (@expr1073746632 "name" ) ;
347: if (@expr1073746633 nodeName@var1839 ==@expr1073746634 nullptr ) {
348: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
349: mKeywords@var454 [@expr1073746637 extension@var1835 ] .@expr1073746638 insert (@expr1073746639 nodeName@var1839 ) ;
350: } else {
351: unknown_elements@var1805 .@expr4679 insert (@expr1073746641 librarynode@var1838 .@expr4803 Name (@expr4804 ) ) ; }
352: }
353: }
354:
355: else { if (@expr1073746644 markupnodename@var1837 ==@expr1073746645 "exported" ) {
356: for (@expr1073746646 const tinyxml2 ::@expr4482 XMLElement *@expr4485 exporter@var1840 =@expr1073746649 markupnode@var1836 .@expr4796 FirstChildElement (@expr4797 ) ; exporter@var1840 ; exporter@var1840 =@expr1073746652 exporter@var1840 .@expr1073746653 NextSiblingElement (@expr1073746654 ) ) {
357: if (@expr1073746655 strcmp (@expr1073746656 exporter@var1840 .@expr4833 Name (@expr4834 ) , "exporter" ) !=@expr1073746659 0 ) {
358: unknown_elements@var1805 .@expr4679 insert (@expr1073746661 exporter@var1840 .@expr4833 Name (@expr4834 ) ) ;
359: continue ;
360: }
361:
362: const char * const prefix@var1841 ; prefix@var1841 =@expr1073746664 exporter@var1840 .@expr1073746665 Attribute (@expr1073746666 "prefix" ) ;
363: if (@expr1073746667 !@expr1073746668 prefix@var1841 ) {
364: return Error (@expr1073746669 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "prefix" ) ; }
365:
366: for (@expr1073746671 const tinyxml2 ::@expr4482 XMLElement *@expr4485 e@var1842 =@expr1073746674 exporter@var1840 .@expr1073746675 FirstChildElement (@expr1073746676 ) ; e@var1842 ; e@var1842 =@expr1073746677 e@var1842 .@expr1073746678 NextSiblingElement (@expr1073746679 ) ) {
367: const std ::@expr4482 string ename@var1843 =@expr1073746681 e@var1842 .@expr1073746682 Name (@expr1073746683 ) ;
368: if (@expr1073746684 ename@var1843 ==@expr1073746685 "prefix" ) {
369: mExporters@var456 [@expr4862 prefix@var1841 ] .@expr1073746687 addPrefix (@expr1073746688 e@var1842 .@expr4865 GetText (@expr4866 ) ) ; }
370: else { if (@expr1073746691 ename@var1843 ==@expr1073746692 "suffix" ) {
371: mExporters@var456 [@expr4862 prefix@var1841 ] .@expr1073746694 addSuffix (@expr1073746695 e@var1842 .@expr4865 GetText (@expr4866 ) ) ; }
372: else {
373: unknown_elements@var1805 .@expr4679 insert (@expr1073746699 ename@var1843 ) ; } }
374: }
375: }
376: }
377:
378: else { if (@expr1073746700 markupnodename@var1837 ==@expr1073746701 "imported" ) {
379: for (@expr1073746702 const tinyxml2 ::@expr4482 XMLElement *@expr4485 librarynode@var1844 =@expr1073746705 markupnode@var1836 .@expr4796 FirstChildElement (@expr4797 ) ; librarynode@var1844 ; librarynode@var1844 =@expr1073746708 librarynode@var1844 .@expr1073746709 NextSiblingElement (@expr1073746710 ) ) {
380: if (@expr1073746711 strcmp (@expr1073746712 librarynode@var1844 .@expr4889 Name (@expr4890 ) , "importer" ) ==@expr1073746715 0 ) {
381: mImporters@var457 [@expr1073746716 extension@var1835 ] .@expr1073746717 insert (@expr1073746718 librarynode@var1844 .@expr1073746719 GetText (@expr1073746720 ) ) ; }
382: else {
383: unknown_elements@var1805 .@expr4679 insert (@expr1073746722 librarynode@var1844 .@expr4889 Name (@expr4890 ) ) ; }
384: }
385: }
386:
387: else { if (@expr1073746725 markupnodename@var1837 ==@expr1073746726 "codeblocks" ) {
388: for (@expr1073746727 const tinyxml2 ::@expr4482 XMLElement *@expr4485 blocknode@var1845 =@expr1073746730 markupnode@var1836 .@expr4796 FirstChildElement (@expr4797 ) ; blocknode@var1845 ; blocknode@var1845 =@expr1073746733 blocknode@var1845 .@expr1073746734 NextSiblingElement (@expr1073746735 ) ) {
389: const std ::@expr4482 string blocknodename@var1846 =@expr1073746737 blocknode@var1845 .@expr1073746738 Name (@expr1073746739 ) ;
390: if (@expr1073746740 blocknodename@var1846 ==@expr1073746741 "block" ) {
391: const char * blockName@var1847 ; blockName@var1847 =@expr1073746742 blocknode@var1845 .@expr4919 Attribute (@expr1073746744 "name" ) ;
392: if (@expr1073746745 blockName@var1847 ) {
393: mExecutableBlocks@var455 [@expr4922 extension@var1835 ] .@expr1073746747 addBlock (@expr1073746748 blockName@var1847 ) ; }
394: } else { if (@expr1073746749 blocknodename@var1846 ==@expr1073746750 "structure" ) {
395: const char * start@var1848 ; start@var1848 =@expr1073746751 blocknode@var1845 .@expr4919 Attribute (@expr1073746753 "start" ) ;
396: if (@expr1073746754 start@var1848 ) {
397: mExecutableBlocks@var455 [@expr4922 extension@var1835 ] .@expr1073746756 setStart (@expr1073746757 start@var1848 ) ; }
398: const char * end@var1849 ; end@var1849 =@expr1073746758 blocknode@var1845 .@expr4919 Attribute (@expr1073746760 "end" ) ;
399: if (@expr1073746761 end@var1849 ) {
400: mExecutableBlocks@var455 [@expr4922 extension@var1835 ] .@expr1073746763 setEnd (@expr1073746764 end@var1849 ) ; }
401: const char * offset@var1850 ; offset@var1850 =@expr1073746765 blocknode@var1845 .@expr4919 Attribute (@expr1073746767 "offset" ) ;
402: if (@expr1073746768 offset@var1850 ) {
403: mExecutableBlocks@var455 [@expr4922 extension@var1835 ] .@expr1073746770 setOffset (@expr1073746771 atoi (@expr1073746772 offset@var1850 ) ) ; }
404: }
405:
406: else {
407: unknown_elements@var1805 .@expr4679 insert (@expr1073746774 blocknodename@var1846 ) ; } }
408: }
409: }
410:
411: else {
412: unknown_elements@var1805 .@expr4679 insert (@expr1073746776 markupnodename@var1837 ) ; } } } }
413: }
414: }
415:
416: else { if (@expr1073746777 nodename@var1807 ==@expr1073746778 "container" ) {
417: const char * const id@var1851 ; id@var1851 =@expr1073746779 node@var1806 .@expr4684 Attribute (@expr1073746781 "id" ) ;
418: if (@expr1073746782 !@expr1073746783 id@var1851 ) {
419: return Error (@expr1073746784 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "id" ) ; }
420:
421: Container &@expr4714 container@var1852 =@expr1073746787 containers@var260 [@expr1073746788 id@var1851 ] ;
422:
423: const char * const inherits@var1853 ; inherits@var1853 =@expr1073746789 node@var1806 .@expr4684 Attribute (@expr1073746791 "inherits" ) ;
424: if (@expr1073746792 inherits@var1853 ) {
425: const std ::@expr1073746793 map < std ::@expr4482 string , Container > ::@expr1073746795 const_iterator i@var1854 =@expr1073746796 containers@var260 .@expr1073746797 find (@expr1073746798 inherits@var1853 ) ;
426: if (@expr1073746799 i@var1854 !=@expr1073746800 containers@var260 .@expr1073746801 end (@expr1073746802 ) ) {
427: container@var1852 =@expr1073746803 i@var1854 .@expr1073746804 second@var1855 ; }
428: else {
429: return Error (@expr1073746805 ErrorCode ::@expr4606 BAD_ATTRIBUTE_VALUE@expr4431 , inherits@var1853 ) ; }
430: }
431:
432: const char * const startPattern@var1856 ; startPattern@var1856 =@expr1073746807 node@var1806 .@expr4684 Attribute (@expr1073746809 "startPattern" ) ;
433: if (@expr1073746810 startPattern@var1856 ) {
434: container@var1852 .@expr4987 startPattern@var1857 =@expr1073746812 startPattern@var1856 ;
435: container@var1852 .@expr1073746813 startPattern2@var1858 =@expr1073746814 container@var1852 .@expr4987 startPattern@var1857 +@expr1073746816 " !!::" ;
436: }
437: const char * const endPattern@var1859 ; endPattern@var1859 =@expr1073746817 node@var1806 .@expr4684 Attribute (@expr1073746819 "endPattern" ) ;
438: if (@expr1073746820 endPattern@var1859 ) {
439: container@var1852 .@expr1073746821 endPattern@var1860 =@expr1073746822 endPattern@var1859 ; }
440: const char * const itEndPattern@var1861 ; itEndPattern@var1861 =@expr1073746823 node@var1806 .@expr4684 Attribute (@expr1073746825 "itEndPattern" ) ;
441: if (@expr1073746826 itEndPattern@var1861 ) {
442: container@var1852 .@expr1073746827 itEndPattern@var1862 =@expr1073746828 itEndPattern@var1861 ; }
443: const char * const opLessAllowed@var1863 ; opLessAllowed@var1863 =@expr1073746829 node@var1806 .@expr4684 Attribute (@expr1073746831 "opLessAllowed" ) ;
444: if (@expr1073746832 opLessAllowed@var1863 ) {
445: container@var1852 .@expr1073746833 opLessAllowed@var1864 =@expr1073746834 std ::@expr4699 string (@expr1073746836 opLessAllowed@var1863 ) ==@expr1073746837 "true" ; }
446: const char * const hasInitializerListConstructor@var1865 ; hasInitializerListConstructor@var1865 =@expr1073746838 node@var1806 .@expr4684 Attribute (@expr1073746840 "hasInitializerListConstructor" ) ;
447: if (@expr1073746841 hasInitializerListConstructor@var1865 ) {
448: container@var1852 .@expr1073746842 hasInitializerListConstructor@var1866 =@expr1073746843 std ::@expr4699 string (@expr1073746845 hasInitializerListConstructor@var1865 ) ==@expr1073746846 "true" ; }
449: const char * const view@var1867 ; view@var1867 =@expr1073746847 node@var1806 .@expr4684 Attribute (@expr1073746849 "view" ) ;
450: if (@expr1073746850 view@var1867 ) {
451: container@var1852 .@expr1073746851 view@var1868 =@expr1073746852 std ::@expr4699 string (@expr1073746854 view@var1867 ) ==@expr1073746855 "true" ; }
452:
453: for (@expr1073746856 const tinyxml2 ::@expr4482 XMLElement *@expr4485 containerNode@var1869 =@expr1073746859 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; containerNode@var1869 ; containerNode@var1869 =@expr1073746862 containerNode@var1869 .@expr1073746863 NextSiblingElement (@expr1073746864 ) ) {
454: const std ::@expr4482 string containerNodeName@var1870 =@expr1073746866 containerNode@var1869 .@expr1073746867 Name (@expr1073746868 ) ;
455: if (@expr1073746869 containerNodeName@var1870 ==@expr5046 "size" ||@expr1073746871 containerNodeName@var1870 ==@expr5048 "access" ||@expr1073746873 containerNodeName@var1870 ==@expr1073746874 "other" ) {
456: for (@expr1073746875 const tinyxml2 ::@expr4482 XMLElement *@expr4485 functionNode@var1871 =@expr1073746878 containerNode@var1869 .@expr1073746879 FirstChildElement (@expr1073746880 ) ; functionNode@var1871 ; functionNode@var1871 =@expr1073746881 functionNode@var1871 .@expr1073746882 NextSiblingElement (@expr1073746883 ) ) {
457: if (@expr1073746884 std ::@expr4699 string (@expr1073746886 functionNode@var1871 .@expr5063 Name (@expr5064 ) ) !=@expr1073746889 "function" ) {
458: unknown_elements@var1805 .@expr4679 insert (@expr1073746891 functionNode@var1871 .@expr5063 Name (@expr5064 ) ) ;
459: continue ;
460: }
461:
462: const char * const functionName@var1872 ; functionName@var1872 =@expr1073746894 functionNode@var1871 .@expr5071 Attribute (@expr1073746896 "name" ) ;
463: if (@expr1073746897 !@expr1073746898 functionName@var1872 ) {
464: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
465:
466: const char * const action_ptr@var1873 ; action_ptr@var1873 =@expr1073746901 functionNode@var1871 .@expr5071 Attribute (@expr1073746903 "action" ) ;
467: Container ::@expr1073746904 Action action@var1874 ; action@var1874 =@expr1073746905 Container ::@expr5082 Action ::@expr5083 NO_ACTION@expr4435 ;
468: if (@expr1073746908 action_ptr@var1873 ) {
469: std ::@expr1073746909 string actionName@var1875 ; actionName@var1875 =@expr1073746910 action_ptr@var1873 ;
470: action@var1874 =@expr1073746911 Container ::@expr1073746912 actionFrom (@expr1073746913 actionName@var1875 ) ;
471: if (@expr1073746914 action@var1874 ==@expr1073746915 Container ::@expr5082 Action ::@expr5083 NO_ACTION@expr4435 ) {
472: return Error (@expr1073746918 ErrorCode ::@expr4606 BAD_ATTRIBUTE_VALUE@expr4431 , actionName@var1875 ) ; }
473: }
474:
475: const char * const yield_ptr@var1876 ; yield_ptr@var1876 =@expr1073746920 functionNode@var1871 .@expr5071 Attribute (@expr1073746922 "yields" ) ;
476: Container ::@expr1073746923 Yield yield@var1877 ; yield@var1877 =@expr1073746924 Container ::@expr5101 Yield ::@expr5102 NO_YIELD@expr4436 ;
477: if (@expr1073746927 yield_ptr@var1876 ) {
478: std ::@expr1073746928 string yieldName@var1878 ; yieldName@var1878 =@expr1073746929 yield_ptr@var1876 ;
479: yield@var1877 =@expr1073746930 Container ::@expr1073746931 yieldFrom (@expr1073746932 yieldName@var1878 ) ;
480: if (@expr1073746933 yield@var1877 ==@expr1073746934 Container ::@expr5101 Yield ::@expr5102 NO_YIELD@expr4436 ) {
481: return Error (@expr1073746937 ErrorCode ::@expr4606 BAD_ATTRIBUTE_VALUE@expr4431 , yieldName@var1878 ) ; }
482: }
483:
484: container@var1852 .@expr5115 functions@var1879 [@expr5116 functionName@var1872 ] .@expr1073746941 action@expr1073746261 =@expr1073746942 action@var1874 ;
485: container@var1852 .@expr5115 functions@var1879 [@expr5116 functionName@var1872 ] .@expr1073746945 yield@expr1073746262 =@expr1073746946 yield@var1877 ;
486: }
487:
488: if (@expr1073746947 containerNodeName@var1870 ==@expr5046 "size" ) {
489: const char * const templateArg@var1880 ; templateArg@var1880 =@expr1073746949 containerNode@var1869 .@expr5126 Attribute (@expr5127 "templateParameter" ) ;
490: if (@expr1073746952 templateArg@var1880 ) {
491: container@var1852 .@expr1073746953 size_templateArgNo@var1881 =@expr1073746954 atoi (@expr1073746955 templateArg@var1880 ) ; }
492: } else { if (@expr1073746956 containerNodeName@var1870 ==@expr5048 "access" ) {
493: const char * const indexArg@var1882 ; indexArg@var1882 =@expr1073746958 containerNode@var1869 .@expr5126 Attribute (@expr1073746960 "indexOperator" ) ;
494: if (@expr1073746961 indexArg@var1882 ) {
495: container@var1852 .@expr1073746962 arrayLike_indexOp@var1883 =@expr1073746963 std ::@expr4699 string (@expr1073746965 indexArg@var1882 ) ==@expr1073746966 "array-like" ; }
496: } }
497: } else { if (@expr1073746967 containerNodeName@var1870 ==@expr1073746968 "type" ) {
498: const char * const templateArg@var1884 ; templateArg@var1884 =@expr1073746969 containerNode@var1869 .@expr5126 Attribute (@expr5127 "templateParameter" ) ;
499: if (@expr1073746972 templateArg@var1884 ) {
500: container@var1852 .@expr1073746973 type_templateArgNo@var1885 =@expr1073746974 atoi (@expr1073746975 templateArg@var1884 ) ; }
501:
502: const char * const string@var1886 ; string@var1886 =@expr1073746976 containerNode@var1869 .@expr5126 Attribute (@expr1073746978 "string" ) ;
503: if (@expr1073746979 string@var1886 ) {
504: container@var1852 .@expr1073746980 stdStringLike@var1887 =@expr1073746981 std ::@expr4699 string (@expr1073746983 string@var1886 ) ==@expr1073746984 "std-like" ; }
505: const char * const associative@var1888 ; associative@var1888 =@expr1073746985 containerNode@var1869 .@expr5126 Attribute (@expr1073746987 "associative" ) ;
506: if (@expr1073746988 associative@var1888 ) {
507: container@var1852 .@expr1073746989 stdAssociativeLike@var1889 =@expr1073746990 std ::@expr4699 string (@expr1073746992 associative@var1888 ) ==@expr1073746993 "std-like" ; }
508: const char * const unstable@var1890 ; unstable@var1890 =@expr1073746994 containerNode@var1869 .@expr5126 Attribute (@expr1073746996 "unstable" ) ;
509: if (@expr1073746997 unstable@var1890 ) {
510: std ::@expr1073746998 string unstableType@var1891 ; unstableType@var1891 =@expr1073746999 unstable@var1890 ;
511: if (@expr1073747000 unstableType@var1891 .@expr5177 find (@expr1073747002 "erase" ) !=@expr1073747003 std ::@expr4699 string ::@expr5181 npos@expr4439 ) {
512: container@var1852 .@expr1073747006 unstableErase@var1892 =@expr1073747007 true ; }
513: if (@expr1073747008 unstableType@var1891 .@expr5177 find (@expr1073747010 "insert" ) !=@expr1073747011 std ::@expr4699 string ::@expr5181 npos@expr4439 ) {
514: container@var1852 .@expr1073747014 unstableInsert@var1893 =@expr1073747015 true ; }
515: }
516: } else { if (@expr1073747016 containerNodeName@var1870 ==@expr1073747017 "rangeItemRecordType" ) {
517: for (@expr1073747018 const tinyxml2 ::@expr4482 XMLElement *@expr4485 memberNode@var1894 =@expr1073747021 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; memberNode@var1894 ; memberNode@var1894 =@expr1073747024 memberNode@var1894 .@expr1073747025 NextSiblingElement (@expr1073747026 ) ) {
518: const char * memberName@var1895 ; memberName@var1895 =@expr1073747027 memberNode@var1894 .@expr5204 Attribute (@expr1073747029 "name" ) ;
519: const char * memberTemplateParameter@var1896 ; memberTemplateParameter@var1896 =@expr1073747030 memberNode@var1894 .@expr5204 Attribute (@expr1073747032 "templateParameter" ) ;
520: struct Container ::@expr1073747033 RangeItemRecordTypeItem member@var1897 ;
521: member@var1897 .@expr1073747034 name@var1898 =@expr1073747035 memberName@var1895 ?@expr1073747036 memberName@var1895 :@expr1073747037 "" ;
522: member@var1897 .@expr1073747038 templateParameter@var1899 =@expr1073747039 memberTemplateParameter@var1896 ?@expr1073747040 std ::@expr1073747041 atoi (@expr1073747042 memberTemplateParameter@var1896 ) :@expr1073747043 -1 ;
523: container@var1852 .@expr1073747044 rangeItemRecordType@var1900 .@expr1073747045 emplace_back (@expr1073747046 member@var1897 ) ;
524: }
525: } else {
526: unknown_elements@var1805 .@expr4679 insert (@expr1073747048 containerNodeName@var1870 ) ; } } }
527: }
528: }
529:
530: else { if (@expr1073747049 nodename@var1807 ==@expr1073747050 "smart-pointer" ) {
531: const char * className@var1901 ; className@var1901 =@expr1073747051 node@var1806 .@expr4684 Attribute (@expr1073747053 "class-name" ) ;
532: if (@expr1073747054 !@expr1073747055 className@var1901 ) {
533: return Error (@expr1073747056 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "class-name" ) ; }
534: SmartPointer &@expr4714 smartPointer@var1902 =@expr1073747059 smartPointers@var381 [@expr1073747060 className@var1901 ] ;
535: smartPointer@var1902 .@expr1073747061 name@var1903 =@expr1073747062 className@var1901 ;
536: for (@expr1073747063 const tinyxml2 ::@expr4482 XMLElement *@expr4485 smartPointerNode@var1904 =@expr1073747066 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; smartPointerNode@var1904 ;
537: smartPointerNode@var1904 =@expr1073747069 smartPointerNode@var1904 .@expr1073747070 NextSiblingElement (@expr1073747071 ) ) {
538: const std ::@expr4482 string smartPointerNodeName@var1905 =@expr1073747073 smartPointerNode@var1904 .@expr1073747074 Name (@expr1073747075 ) ;
539: if (@expr1073747076 smartPointerNodeName@var1905 ==@expr1073747077 "unique" ) {
540: smartPointer@var1902 .@expr1073747078 unique@var1906 =@expr1073747079 true ; }
541: }
542: }
543:
544: else { if (@expr1073747080 nodename@var1807 ==@expr1073747081 "type-checks" ) {
545: for (@expr1073747082 const tinyxml2 ::@expr4482 XMLElement *@expr4485 checkNode@var1907 =@expr1073747085 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; checkNode@var1907 ; checkNode@var1907 =@expr1073747088 checkNode@var1907 .@expr1073747089 NextSiblingElement (@expr1073747090 ) ) {
546: const std ::@expr4482 string &@expr4714 checkName@var1908 =@expr1073747093 checkNode@var1907 .@expr1073747094 Name (@expr1073747095 ) ;
547: for (@expr1073747096 const tinyxml2 ::@expr4482 XMLElement *@expr4485 checkTypeNode@var1909 =@expr1073747099 checkNode@var1907 .@expr1073747100 FirstChildElement (@expr1073747101 ) ; checkTypeNode@var1909 ; checkTypeNode@var1909 =@expr1073747102 checkTypeNode@var1909 .@expr1073747103 NextSiblingElement (@expr1073747104 ) ) {
548: const std ::@expr4482 string checkTypeName@var1910 =@expr1073747106 checkTypeNode@var1909 .@expr1073747107 Name (@expr1073747108 ) ;
549: const char * typeName@var1911 ; typeName@var1911 =@expr1073747109 checkTypeNode@var1909 .@expr1073747110 GetText (@expr1073747111 ) ;
550: if (@expr1073747112 !@expr1073747113 typeName@var1911 ) {
551: continue ; }
552: if (@expr1073747114 checkTypeName@var1910 ==@expr1073747115 "check" ) {
553: mTypeChecks@var462 [@expr5292 std ::@expr5293 pair < std ::@expr4482 string , std ::@expr4482 string > (@expr5296 checkName@var1908 , typeName@var1911 ) ] =@expr1073747121 TypeCheck ::@expr1073747122 check@expr1073746264 ; }
554: else { if (@expr1073747123 checkTypeName@var1910 ==@expr1073747124 "suppress" ) {
555: mTypeChecks@var462 [@expr5292 std ::@expr5293 pair < std ::@expr4482 string , std ::@expr4482 string > (@expr5296 checkName@var1908 , typeName@var1911 ) ] =@expr1073747130 TypeCheck ::@expr1073747131 suppress@expr1073746265 ; } }
556: }
557: }
558: }
559:
560: else { if (@expr1073747132 nodename@var1807 ==@expr1073747133 "podtype" ) {
561: const char * const name@var1912 ; name@var1912 =@expr1073747134 node@var1806 .@expr4684 Attribute (@expr4685 "name" ) ;
562: if (@expr1073747137 !@expr1073747138 name@var1912 ) {
563: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
564: PodType podType@var1913 ; podType@var1913 =@expr1073747141 {@expr1073747142 0 } ;
565: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747144 PodType ::@expr5321 Type ::@expr1073747146 NO@expr1073746266 ;
566: const char * const stdtype@var1915 ; stdtype@var1915 =@expr1073747147 node@var1806 .@expr4684 Attribute (@expr1073747149 "stdtype" ) ;
567: if (@expr1073747150 stdtype@var1915 ) {
568: if (@expr1073747151 std ::@expr5328 strcmp (@expr1073747153 stdtype@var1915 , "bool" ) ==@expr1073747154 0 ) {
569: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747156 PodType ::@expr5321 Type ::@expr1073747158 BOOL@expr1073746267 ; }
570: else { if (@expr1073747159 std ::@expr5328 strcmp (@expr1073747161 stdtype@var1915 , "char" ) ==@expr1073747162 0 ) {
571: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747164 PodType ::@expr5321 Type ::@expr1073747166 CHAR@expr1073746268 ; }
572: else { if (@expr1073747167 std ::@expr5328 strcmp (@expr1073747169 stdtype@var1915 , "short" ) ==@expr1073747170 0 ) {
573: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747172 PodType ::@expr5321 Type ::@expr1073747174 SHORT@expr1073746269 ; }
574: else { if (@expr1073747175 std ::@expr5328 strcmp (@expr1073747177 stdtype@var1915 , "int" ) ==@expr1073747178 0 ) {
575: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747180 PodType ::@expr5321 Type ::@expr1073747182 INT@expr1073746270 ; }
576: else { if (@expr1073747183 std ::@expr5328 strcmp (@expr1073747185 stdtype@var1915 , "long" ) ==@expr1073747186 0 ) {
577: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747188 PodType ::@expr5321 Type ::@expr1073747190 LONG@expr1073746271 ; }
578: else { if (@expr1073747191 std ::@expr5328 strcmp (@expr1073747193 stdtype@var1915 , "long long" ) ==@expr1073747194 0 ) {
579: podType@var1913 .@expr5319 stdtype@var1914 =@expr1073747196 PodType ::@expr5321 Type ::@expr1073747198 LONGLONG@expr1073746272 ; } } } } } }
580: }
581: const char * const size@var1916 ; size@var1916 =@expr1073747199 node@var1806 .@expr4684 Attribute (@expr1073747201 "size" ) ;
582: if (@expr1073747202 size@var1916 ) {
583: podType@var1913 .@expr1073747203 size@var1917 =@expr1073747204 atoi (@expr1073747205 size@var1916 ) ; }
584: const char * const sign@var1918 ; sign@var1918 =@expr1073747206 node@var1806 .@expr4684 Attribute (@expr1073747208 "sign" ) ;
585: if (@expr1073747209 sign@var1918 ) {
586: podType@var1913 .@expr1073747210 sign@var1919 =@expr1073747211 *@expr1073747212 sign@var1918 ; }
587: for (@expr1073747213 const std ::@expr4482 string &@expr4714 s@var1920 :@expr1073747216 getnames (@expr1073747217 name@var1912 ) ) {
588: mPodTypes@var459 [@expr1073747218 s@var1920 ] =@expr1073747219 podType@var1913 ; }
589: }
590:
591: else { if (@expr1073747220 nodename@var1807 ==@expr1073747221 "platformtype" ) {
592: const char * const type_name@var1921 ; type_name@var1921 =@expr1073747222 node@var1806 .@expr4684 Attribute (@expr4685 "name" ) ;
593: if (@expr1073747225 type_name@var1921 ==@expr1073747226 nullptr ) {
594: return Error (@expr4688 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "name" ) ; }
595: const char * value@var1922 ; value@var1922 =@expr1073747229 node@var1806 .@expr4684 Attribute (@expr4692 "value" ) ;
596: if (@expr1073747232 value@var1922 ==@expr1073747233 nullptr ) {
597: return Error (@expr4695 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "value" ) ; }
598: PlatformType type@var1923 ;
599: type@var1923 .@expr1073747236 mType@var1924 =@expr1073747237 value@var1922 ;
600: std ::@expr1073747238 set < std ::@expr4482 string > platform@var1925 ;
601: for (@expr1073747240 const tinyxml2 ::@expr4482 XMLElement *@expr4485 typenode@var1926 =@expr1073747243 node@var1806 .@expr4505 FirstChildElement (@expr4506 ) ; typenode@var1926 ; typenode@var1926 =@expr1073747246 typenode@var1926 .@expr1073747247 NextSiblingElement (@expr1073747248 ) ) {
602: const std ::@expr4482 string typenodename@var1927 =@expr1073747250 typenode@var1926 .@expr1073747251 Name (@expr1073747252 ) ;
603: if (@expr1073747253 typenodename@var1927 ==@expr1073747254 "platform" ) {
604: const char * const type_attribute@var1928 ; type_attribute@var1928 =@expr1073747255 typenode@var1926 .@expr1073747256 Attribute (@expr1073747257 "type" ) ;
605: if (@expr1073747258 type_attribute@var1928 ==@expr1073747259 nullptr ) {
606: return Error (@expr1073747260 ErrorCode ::@expr4689 MISSING_ATTRIBUTE@expr4433 , "type" ) ; }
607: platform@var1925 .@expr1073747262 insert (@expr1073747263 type_attribute@var1928 ) ;
608: } else { if (@expr1073747264 typenodename@var1927 ==@expr1073747265 "signed" ) {
609: type@var1923 .@expr1073747266 mSigned@var1929 =@expr1073747267 true ; }
610: else { if (@expr1073747268 typenodename@var1927 ==@expr1073747269 "unsigned" ) {
611: type@var1923 .@expr1073747270 mUnsigned@var1930 =@expr1073747271 true ; }
612: else { if (@expr1073747272 typenodename@var1927 ==@expr1073747273 "long" ) {
613: type@var1923 .@expr1073747274 mLong@var1931 =@expr1073747275 true ; }
614: else { if (@expr1073747276 typenodename@var1927 ==@expr1073747277 "pointer" ) {
615: type@var1923 .@expr1073747278 mPointer@var1932 =@expr1073747279 true ; }
616: else { if (@expr1073747280 typenodename@var1927 ==@expr1073747281 "ptr_ptr" ) {
617: type@var1923 .@expr1073747282 mPtrPtr@var1933 =@expr1073747283 true ; }
618: else { if (@expr1073747284 typenodename@var1927 ==@expr1073747285 "const_ptr" ) {
619: type@var1923 .@expr1073747286 mConstPtr@var1934 =@expr1073747287 true ; }
620: else {
621: unknown_elements@var1805 .@expr4679 insert (@expr1073747289 typenodename@var1927 ) ; } } } } } } }
622: }
623: if (@expr1073747290 platform@var1925 .@expr1073747291 empty (@expr1073747292 ) ) {
624: const PlatformType * const type_ptr@var1935 ; type_ptr@var1935 =@expr1073747293 platform_type (@expr1073747294 type_name@var1921 , emptyString@var1 ) ;
625: if (@expr1073747295 type_ptr@var1935 ) {
626: if (@expr1073747296 *@expr1073747297 type_ptr@var1935 ==@expr1073747298 type@var1923 ) {
627: return Error (@expr5475 ErrorCode ::@expr5476 DUPLICATE_PLATFORM_TYPE@expr4449 , type_name@var1921 ) ; }
628: return Error (@expr5477 ErrorCode ::@expr5478 PLATFORM_TYPE_REDEFINED@expr4450 , type_name@var1921 ) ;
629: }
630: mPlatformTypes@var460 [@expr1073747303 type_name@var1921 ] =@expr1073747304 type@var1923 ;
631: } else {
632: for (@expr1073747305 const std ::@expr4482 string &@expr4714 p@var1936 :@expr1073747308 platform@var1925 ) {
633: const PlatformType * const type_ptr@var1937 ; type_ptr@var1937 =@expr1073747309 platform_type (@expr1073747310 type_name@var1921 , p@var1936 ) ;
634: if (@expr1073747311 type_ptr@var1937 ) {
635: if (@expr1073747312 *@expr1073747313 type_ptr@var1937 ==@expr1073747314 type@var1923 ) {
636: return Error (@expr5475 ErrorCode ::@expr5476 DUPLICATE_PLATFORM_TYPE@expr4449 , type_name@var1921 ) ; }
637: return Error (@expr5477 ErrorCode ::@expr5478 PLATFORM_TYPE_REDEFINED@expr4450 , type_name@var1921 ) ;
638: }
639: mPlatforms@var461 [@expr1073747319 p@var1936 ] .@expr1073747320 mPlatformTypes@expr1073746275 [@expr1073747321 type_name@var1921 ] =@expr1073747322 type@var1923 ;
640: }
641: }
642: }
643:
644: else {
645: unknown_elements@var1805 .@expr4679 insert (@expr1073747324 nodename@var1807 ) ; } } } } } } } } } }
646: }
647: if (@expr1073747325 !@expr1073747326 unknown_elements@var1805 .@expr1073747327 empty (@expr1073747328 ) ) {
648: std ::@expr1073747329 string str@var1938 ;
649: for (@expr1073747330 std ::@expr4482 set < std ::@expr4482 string > ::@expr4482 const_iterator i@var1939 =@expr1073747334 unknown_elements@var1805 .@expr1073747335 begin (@expr1073747336 ) ; i@var1939 !=@expr1073747337 unknown_elements@var1805 .@expr5514 end (@expr5515 ) ; ) {
650: str@var1938 +=@expr1073747340 *@expr1073747341 i@var1939 ;
651: if (@expr1073747342 ++@expr1073747343 i@var1939 !=@expr1073747344 unknown_elements@var1805 .@expr5514 end (@expr5515 ) ) {
652: str@var1938 +=@expr1073747347 ", " ; }
653: }
654: return Error (@expr1073747348 ErrorCode ::@expr1073747349 UNKNOWN_ELEMENT@expr1073746276 , str@var1938 ) ;
655: }
656: return Error (@expr1073747350 ErrorCode ::@expr4723 OK@expr4434 ) ;
657: }
658:
659: Library :: Error Library :: loadFunction ( const tinyxml2 :: XMLElement * const node@var1940 , const std :: string & name@var1941 , std :: set < std :: string > & unknown_elements@var1942 )
660: {
661: if (@expr1073747368 name@var1941 .@expr1073747369 empty (@expr1073747370 ) ) {
662: return Error (@expr5547 ErrorCode ::@expr5548 OK@expr5528 ) ; }
663:
664: Function &@expr5549 func@var1943 =@expr1073747374 functions@var299 [@expr1073747375 name@var1941 ] ;
665:
666: for (@expr1073747376 const tinyxml2 ::@expr5553 XMLElement *@expr5554 functionnode@var1944 =@expr1073747379 node@var1940 .@expr1073747380 FirstChildElement (@expr1073747381 ) ; functionnode@var1944 ; functionnode@var1944 =@expr1073747382 functionnode@var1944 .@expr1073747383 NextSiblingElement (@expr1073747384 ) ) {
667: const std ::@expr5553 string functionnodename@var1945 =@expr1073747386 functionnode@var1944 .@expr1073747387 Name (@expr1073747388 ) ;
668: if (@expr1073747389 functionnodename@var1945 ==@expr1073747390 "noreturn" ) {
669: if (@expr1073747391 strcmp (@expr1073747392 functionnode@var1944 .@expr5569 GetText (@expr5570 ) , "false" ) ==@expr1073747395 0 ) {
670: mNoReturn@var446 [@expr5572 name@var1941 ] =@expr1073747397 FalseTrueMaybe ::@expr1073747398 False@expr1073747353 ; }
671: else { if (@expr1073747399 strcmp (@expr1073747400 functionnode@var1944 .@expr5569 GetText (@expr5570 ) , "maybe" ) ==@expr1073747403 0 ) {
672: mNoReturn@var446 [@expr5572 name@var1941 ] =@expr1073747405 FalseTrueMaybe ::@expr1073747406 Maybe@expr1073747354 ; }
673: else {
674: mNoReturn@var446 [@expr5572 name@var1941 ] =@expr1073747408 FalseTrueMaybe ::@expr1073747409 True@expr1073747355 ; } }
675: } else { if (@expr1073747410 functionnodename@var1945 ==@expr1073747411 "pure" ) {
676: func@var1943 .@expr5588 ispure@var1946 =@expr1073747413 true ; }
677: else { if (@expr1073747414 functionnodename@var1945 ==@expr1073747415 "const" ) {
678: func@var1943 .@expr5588 ispure@var1946 =@expr1073747417 true ;
679: func@var1943 .@expr1073747418 isconst@var1947 =@expr1073747419 true ;
680: } else { if (@expr1073747420 functionnodename@var1945 ==@expr1073747421 "leak-ignore" ) {
681: func@var1943 .@expr1073747422 leakignore@var1948 =@expr1073747423 true ; }
682: else { if (@expr1073747424 functionnodename@var1945 ==@expr1073747425 "not-overlapping-data" ) {
683: NonOverlappingData nonOverlappingData@var1949 ;
684: nonOverlappingData@var1949 .@expr1073747426 ptr1Arg@var1950 =@expr1073747427 functionnode@var1944 .@expr5604 IntAttribute (@expr1073747429 "ptr1-arg" , -1 ) ;
685: nonOverlappingData@var1949 .@expr1073747430 ptr2Arg@var1951 =@expr1073747431 functionnode@var1944 .@expr5604 IntAttribute (@expr1073747433 "ptr2-arg" , -1 ) ;
686: nonOverlappingData@var1949 .@expr1073747434 sizeArg@var1952 =@expr1073747435 functionnode@var1944 .@expr5604 IntAttribute (@expr1073747437 "size-arg" , -1 ) ;
687: nonOverlappingData@var1949 .@expr1073747438 strlenArg@var1953 =@expr1073747439 functionnode@var1944 .@expr5604 IntAttribute (@expr1073747441 "strlen-arg" , -1 ) ;
688: mNonOverlappingData@var463 [@expr1073747442 name@var1941 ] =@expr1073747443 nonOverlappingData@var1949 ;
689: } else { if (@expr1073747444 functionnodename@var1945 ==@expr1073747445 "use-retval" ) {
690: func@var1943 .@expr5622 useretval@var1954 =@expr1073747447 Library ::@expr5624 UseRetValType ::@expr1073747449 DEFAULT ;
691: if (@expr1073747450 const char *@expr5554 type@var1955 =@expr1073747452 functionnode@var1944 .@expr5629 Attribute (@expr5630 "type" ) ) {
692: if (@expr1073747455 std ::@expr5632 strcmp (@expr1073747457 type@var1955 , "error-code" ) ==@expr1073747458 0 ) {
693: func@var1943 .@expr5622 useretval@var1954 =@expr1073747460 Library ::@expr5624 UseRetValType ::@expr1073747462 ERROR_CODE ; } }
694: } else { if (@expr1073747463 functionnodename@var1945 ==@expr1073747464 "returnValue" ) {
695: if (@expr1073747465 const char *@expr5554 expr@var1956 =@expr1073747467 functionnode@var1944 .@expr5569 GetText (@expr5570 ) ) {
696: mReturnValue@var447 [@expr1073747470 name@var1941 ] =@expr1073747471 expr@var1956 ; }
697: if (@expr1073747472 const char *@expr5554 type@var1957 =@expr1073747474 functionnode@var1944 .@expr5629 Attribute (@expr5630 "type" ) ) {
698: mReturnValueType@var448 [@expr1073747477 name@var1941 ] =@expr1073747478 type@var1957 ; }
699: if (@expr1073747479 const char *@expr5554 container@var1958 =@expr1073747481 functionnode@var1944 .@expr5629 Attribute (@expr1073747483 "container" ) ) {
700: mReturnValueContainer@var449 [@expr1073747484 name@var1941 ] =@expr1073747485 std ::@expr5662 atoi (@expr1073747487 container@var1958 ) ; }
701: if (@expr1073747488 const char *@expr5554 unknownReturnValues@var1959 =@expr1073747490 functionnode@var1944 .@expr5629 Attribute (@expr1073747492 "unknownValues" ) ) {
702: if (@expr1073747493 std ::@expr5632 strcmp (@expr1073747495 unknownReturnValues@var1959 , "all" ) ==@expr1073747496 0 ) {
703: std ::@expr5553 vector < long long > values@var1960 {@expr1073747498 LLONG_MIN , LLONG_MAX } ;
704: mUnknownReturnValues@var450 [@expr1073747499 name@var1941 ] =@expr1073747500 values@var1960 ;
705: }
706: }
707: } else { if (@expr1073747501 functionnodename@var1945 ==@expr1073747502 "arg" ) {
708: const char * argNrString@var1961 ; argNrString@var1961 =@expr1073747503 functionnode@var1944 .@expr5629 Attribute (@expr1073747505 "nr" ) ;
709: if (@expr1073747506 !@expr1073747507 argNrString@var1961 ) {
710: return Error (@expr1073747508 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "nr" ) ; }
711: const bool bAnyArg@var1962 =@expr1073747510 strcmp (@expr1073747511 argNrString@var1961 , "any" ) ==@expr1073747512 0 ;
712: const bool bVariadicArg@var1963 =@expr1073747513 strcmp (@expr1073747514 argNrString@var1961 , "variadic" ) ==@expr1073747515 0 ;
713: const int nr@var1964 =@expr1073747516 (@expr1073747517 bAnyArg@var1962 ||@expr1073747518 bVariadicArg@var1963 ) ?@expr1073747519 -1 :@expr1073747520 std ::@expr5662 atoi (@expr1073747522 argNrString@var1961 ) ;
714: ArgumentChecks &@expr5549 ac@var1965 =@expr1073747524 func@var1943 .@expr1073747525 argumentChecks@var1966 [@expr1073747526 nr@var1964 ] ;
715: ac@var1965 .@expr1073747527 optional@var1967 =@expr1073747528 functionnode@var1944 .@expr5629 Attribute (@expr1073747530 "default" ) !=@expr1073747531 nullptr ;
716: ac@var1965 .@expr1073747532 variadic@var1968 =@expr1073747533 bVariadicArg@var1963 ;
717: const char * const argDirection@var1969 ; argDirection@var1969 =@expr1073747534 functionnode@var1944 .@expr5629 Attribute (@expr1073747536 "direction" ) ;
718: if (@expr1073747537 argDirection@var1969 ) {
719: const unsigned long argDirLen@var1970 =@expr1073747538 strlen (@expr1073747539 argDirection@var1969 ) ;
720: if (@expr1073747540 !@expr1073747541 strncmp (@expr1073747542 argDirection@var1969 , "in" , argDirLen@var1970 ) ) {
721: ac@var1965 .@expr5719 direction@var1971 =@expr1073747544 ArgumentChecks ::@expr5721 Direction ::@expr1073747546 DIR_IN@expr1073747357 ;
722: } else { if (@expr1073747547 !@expr1073747548 strncmp (@expr1073747549 argDirection@var1969 , "out" , argDirLen@var1970 ) ) {
723: ac@var1965 .@expr5719 direction@var1971 =@expr1073747551 ArgumentChecks ::@expr5721 Direction ::@expr1073747553 DIR_OUT@expr1073747358 ;
724: } else { if (@expr1073747554 !@expr1073747555 strncmp (@expr1073747556 argDirection@var1969 , "inout" , argDirLen@var1970 ) ) {
725: ac@var1965 .@expr5719 direction@var1971 =@expr1073747558 ArgumentChecks ::@expr5721 Direction ::@expr1073747560 DIR_INOUT@expr1073747359 ;
726: } } }
727: }
728: for (@expr1073747561 const tinyxml2 ::@expr5553 XMLElement *@expr5554 argnode@var1972 =@expr1073747564 functionnode@var1944 .@expr1073747565 FirstChildElement (@expr1073747566 ) ; argnode@var1972 ; argnode@var1972 =@expr1073747567 argnode@var1972 .@expr1073747568 NextSiblingElement (@expr1073747569 ) ) {
729: const std ::@expr5553 string argnodename@var1973 =@expr1073747571 argnode@var1972 .@expr1073747572 Name (@expr1073747573 ) ;
730: int indirect@var1974 ; indirect@var1974 =@expr1073747574 0 ;
731: const char * const indirectStr@var1975 ; indirectStr@var1975 =@expr1073747575 argnode@var1972 .@expr5752 Attribute (@expr1073747577 "indirect" ) ;
732: if (@expr1073747578 indirectStr@var1975 ) {
733: indirect@var1974 =@expr1073747579 atoi (@expr1073747580 indirectStr@var1975 ) ; }
734: if (@expr1073747581 argnodename@var1973 ==@expr1073747582 "not-bool" ) {
735: ac@var1965 .@expr1073747583 notbool@var1976 =@expr1073747584 true ; }
736: else { if (@expr1073747585 argnodename@var1973 ==@expr1073747586 "not-null" ) {
737: ac@var1965 .@expr5763 notnull@var1977 =@expr1073747588 true ; }
738: else { if (@expr1073747589 argnodename@var1973 ==@expr1073747590 "not-uninit" ) {
739: ac@var1965 .@expr5767 notuninit@var1978 =@expr1073747592 indirect@var1974 ; }
740: else { if (@expr1073747593 argnodename@var1973 ==@expr1073747594 "formatstr" ) {
741: ac@var1965 .@expr1073747595 formatstr@var1979 =@expr1073747596 true ; }
742: else { if (@expr1073747597 argnodename@var1973 ==@expr1073747598 "strz" ) {
743: ac@var1965 .@expr1073747599 strz@var1980 =@expr1073747600 true ; }
744: else { if (@expr1073747601 argnodename@var1973 ==@expr1073747602 "valid" ) {
745:
746: const char * p@var1981 ; p@var1981 =@expr1073747603 argnode@var1972 .@expr5780 GetText (@expr5781 ) ;
747: if (@expr1073747606 !@expr1073747607 isCompliantValidationExpression (@expr1073747608 p@var1981 ) ) {
748: return Error (@expr1073747609 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , !@expr1073747611 p@var1981 ?@expr1073747612 "\"\"" :@expr1073747613 argnode@var1972 .@expr5780 GetText (@expr5781 ) ) ; }
749:
750: ac@var1965 .@expr1073747616 valid@var1982 =@expr1073747617 argnode@var1972 .@expr5780 GetText (@expr5781 ) ;
751: }
752: else { if (@expr1073747620 argnodename@var1973 ==@expr1073747621 "minsize" ) {
753: const char * typeattr@var1983 ; typeattr@var1983 =@expr1073747622 argnode@var1972 .@expr5752 Attribute (@expr5800 "type" ) ;
754: if (@expr1073747625 !@expr1073747626 typeattr@var1983 ) {
755: return Error (@expr1073747627 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "type" ) ; }
756:
757: ArgumentChecks ::@expr5805 MinSize ::@expr1073747630 Type type@var1984 ;
758: if (@expr1073747631 strcmp (@expr1073747632 typeattr@var1983 , "strlen" ) ==@expr1073747633 0 ) {
759: type@var1984 =@expr1073747634 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr1073747637 STRLEN@expr1073747361 ; }
760: else { if (@expr1073747638 strcmp (@expr1073747639 typeattr@var1983 , "argvalue" ) ==@expr1073747640 0 ) {
761: type@var1984 =@expr1073747641 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr1073747644 ARGVALUE@expr1073747362 ; }
762: else { if (@expr1073747645 strcmp (@expr1073747646 typeattr@var1983 , "sizeof" ) ==@expr1073747647 0 ) {
763: type@var1984 =@expr1073747648 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr1073747651 SIZEOF@expr1073747363 ; }
764: else { if (@expr1073747652 strcmp (@expr1073747653 typeattr@var1983 , "mul" ) ==@expr1073747654 0 ) {
765: type@var1984 =@expr1073747655 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr5834 MUL@expr5540 ; }
766: else { if (@expr1073747659 strcmp (@expr1073747660 typeattr@var1983 , "value" ) ==@expr1073747661 0 ) {
767: type@var1984 =@expr1073747662 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr5841 VALUE@expr5541 ; }
768: else {
769: return Error (@expr1073747666 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , typeattr@var1983 ) ; } } } } }
770:
771: if (@expr1073747668 type@var1984 ==@expr1073747669 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr5841 VALUE@expr5541 ) {
772: const char * valueattr@var1985 ; valueattr@var1985 =@expr1073747673 argnode@var1972 .@expr5752 Attribute (@expr1073747675 "value" ) ;
773: if (@expr1073747676 !@expr1073747677 valueattr@var1985 ) {
774: return Error (@expr1073747678 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "value" ) ; }
775: long long minsizevalue@var1986 ; minsizevalue@var1986 =@expr1073747680 0 ;
776: try {
777: minsizevalue@var1986 =@expr1073747681 MathLib ::@expr1073747682 toLongNumber (@expr1073747683 valueattr@var1985 ) ;
778: } catch (@expr1073747684 const InternalError &@expr5549 ) {
779: return Error (@expr5862 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , valueattr@var1985 ) ;
780: }
781: if (@expr1073747688 minsizevalue@var1986 <=@expr1073747689 0 ) {
782: return Error (@expr5862 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , valueattr@var1985 ) ; }
783: ac@var1965 .@expr5868 minsizes@var1987 .@expr5869 emplace_back (@expr1073747694 type@var1984 , 0 ) ;
784: ac@var1965 .@expr5868 minsizes@var1987 .@expr5872 back (@expr5873 ) .@expr1073747698 value@var2297 =@expr1073747699 minsizevalue@var1986 ;
785: } else {
786: const char * argattr@var1988 ; argattr@var1988 =@expr1073747700 argnode@var1972 .@expr5752 Attribute (@expr1073747702 "arg" ) ;
787: if (@expr1073747703 !@expr1073747704 argattr@var1988 ) {
788: return Error (@expr1073747705 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "arg" ) ; }
789: if (@expr1073747707 strlen (@expr1073747708 argattr@var1988 ) !=@expr1073747709 1 ||@expr1073747710 argattr@var1988 [@expr5887 0 ] <@expr1073747712 '0' ||@expr1073747713 argattr@var1988 [@expr5887 0 ] >@expr1073747715 '9' ) {
790: return Error (@expr1073747716 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , argattr@var1988 ) ; }
791:
792: ac@var1965 .@expr5868 minsizes@var1987 .@expr1073747719 reserve (@expr1073747720 type@var1984 ==@expr5897 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr5834 MUL@expr5540 ?@expr1073747725 2 :@expr1073747726 1 ) ;
793: ac@var1965 .@expr5868 minsizes@var1987 .@expr5869 emplace_back (@expr1073747729 type@var1984 , argattr@var1988 [@expr5887 0 ] -@expr1073747731 '0' ) ;
794: if (@expr1073747732 type@var1984 ==@expr5897 ArgumentChecks ::@expr5805 MinSize ::@expr5812 Type ::@expr5834 MUL@expr5540 ) {
795: const char * arg2attr@var1989 ; arg2attr@var1989 =@expr1073747737 argnode@var1972 .@expr5752 Attribute (@expr1073747739 "arg2" ) ;
796: if (@expr1073747740 !@expr1073747741 arg2attr@var1989 ) {
797: return Error (@expr1073747742 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "arg2" ) ; }
798: if (@expr1073747744 strlen (@expr1073747745 arg2attr@var1989 ) !=@expr1073747746 1 ||@expr1073747747 arg2attr@var1989 [@expr5924 0 ] <@expr1073747749 '0' ||@expr1073747750 arg2attr@var1989 [@expr5924 0 ] >@expr1073747752 '9' ) {
799: return Error (@expr1073747753 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , arg2attr@var1989 ) ; }
800: ac@var1965 .@expr5868 minsizes@var1987 .@expr5872 back (@expr5873 ) .@expr1073747758 arg2@var2298 =@expr1073747759 arg2attr@var1989 [@expr5924 0 ] -@expr1073747761 '0' ;
801: }
802: }
803: }
804:
805: else { if (@expr1073747762 argnodename@var1973 ==@expr1073747763 "iterator" ) {
806: ac@var1965 .@expr5940 iteratorInfo@var1990 .@expr1073747765 it@var1991 =@expr1073747766 true ;
807: const char * str@var1992 ; str@var1992 =@expr1073747767 argnode@var1972 .@expr5752 Attribute (@expr5800 "type" ) ;
808: ac@var1965 .@expr5940 iteratorInfo@var1990 .@expr1073747771 first@var1993 =@expr1073747772 str@var1992 &&@expr1073747773 std ::@expr5632 strcmp (@expr1073747775 str@var1992 , "first" ) ==@expr1073747776 0 ;
809: ac@var1965 .@expr5940 iteratorInfo@var1990 .@expr1073747778 last@var1994 =@expr1073747779 str@var1992 &&@expr1073747780 std ::@expr5632 strcmp (@expr1073747782 str@var1992 , "last" ) ==@expr1073747783 0 ;
810: ac@var1965 .@expr5940 iteratorInfo@var1990 .@expr1073747785 container@var1995 =@expr1073747786 argnode@var1972 .@expr1073747787 IntAttribute (@expr1073747788 "container" , 0 ) ;
811: }
812:
813: else {
814: unknown_elements@var1942 .@expr5965 insert (@expr1073747790 argnodename@var1973 ) ; } } } } } } } }
815: }
816: if (@expr1073747791 ac@var1965 .@expr5767 notuninit@var1978 ==@expr1073747793 0 ) {
817: ac@var1965 .@expr5767 notuninit@var1978 =@expr1073747795 ac@var1965 .@expr5763 notnull@var1977 ?@expr1073747797 1 :@expr1073747798 0 ; }
818: } else { if (@expr1073747799 functionnodename@var1945 ==@expr1073747800 "ignorefunction" ) {
819: func@var1943 .@expr1073747801 ignore@var1996 =@expr1073747802 true ;
820: } else { if (@expr1073747803 functionnodename@var1945 ==@expr1073747804 "formatstr" ) {
821: func@var1943 .@expr1073747805 formatstr@var1997 =@expr1073747806 true ;
822: const tinyxml2 ::@expr5983 XMLAttribute * scan@var1998 ; scan@var1998 =@expr1073747808 functionnode@var1944 .@expr5985 FindAttribute (@expr1073747810 "scan" ) ;
823: const tinyxml2 ::@expr5983 XMLAttribute * secure@var1999 ; secure@var1999 =@expr1073747812 functionnode@var1944 .@expr5985 FindAttribute (@expr1073747814 "secure" ) ;
824: func@var1943 .@expr1073747815 formatstr_scan@var2000 =@expr1073747816 scan@var1998 &&@expr1073747817 scan@var1998 .@expr1073747818 BoolValue (@expr1073747819 ) ;
825: func@var1943 .@expr1073747820 formatstr_secure@var2001 =@expr1073747821 secure@var1999 &&@expr1073747822 secure@var1999 .@expr1073747823 BoolValue (@expr1073747824 ) ;
826: } else { if (@expr1073747825 functionnodename@var1945 ==@expr1073747826 "warn" ) {
827: WarnInfo wi@var2002 ;
828: const char * const severity@var2003 ; severity@var2003 =@expr1073747827 functionnode@var1944 .@expr5629 Attribute (@expr1073747829 "severity" ) ;
829: if (@expr1073747830 severity@var2003 ==@expr1073747831 nullptr ) {
830: return Error (@expr1073747832 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "severity" ) ; }
831: wi@var2002 .@expr1073747834 severity@var2004 =@expr1073747835 Severity ::@expr1073747836 fromString (@expr1073747837 severity@var2003 ) ;
832:
833: const char * const cstd@var2005 ; cstd@var2005 =@expr1073747838 functionnode@var1944 .@expr5629 Attribute (@expr1073747840 "cstd" ) ;
834: if (@expr1073747841 cstd@var2005 ) {
835: if (@expr1073747842 !@expr1073747843 wi@var2002 .@expr6020 standards@var2006 .@expr1073747845 setC (@expr1073747846 cstd@var2005 ) ) {
836: return Error (@expr1073747847 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , cstd@var2005 ) ; }
837: } else {
838: wi@var2002 .@expr6020 standards@var2006 .@expr1073747850 c@var2007 =@expr1073747851 Standards ::@expr1073747852 C89 ; }
839:
840: const char * const cppstd@var2008 ; cppstd@var2008 =@expr1073747853 functionnode@var1944 .@expr5629 Attribute (@expr1073747855 "cppstd" ) ;
841: if (@expr1073747856 cppstd@var2008 ) {
842: if (@expr1073747857 !@expr1073747858 wi@var2002 .@expr6020 standards@var2006 .@expr1073747860 setCPP (@expr1073747861 cppstd@var2008 ) ) {
843: return Error (@expr1073747862 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , cppstd@var2008 ) ; }
844: } else {
845: wi@var2002 .@expr6020 standards@var2006 .@expr1073747865 cpp@var2009 =@expr1073747866 Standards ::@expr1073747867 CPP03 ; }
846:
847: const char * const reason@var2010 ; reason@var2010 =@expr1073747868 functionnode@var1944 .@expr5629 Attribute (@expr1073747870 "reason" ) ;
848: const char * const alternatives@var2011 ; alternatives@var2011 =@expr1073747871 functionnode@var1944 .@expr5629 Attribute (@expr1073747873 "alternatives" ) ;
849: if (@expr1073747874 reason@var2010 &&@expr1073747875 alternatives@var2011 ) {
850:
851: wi@var2002 .@expr6052 message@var2012 =@expr1073747877 std ::@expr1073747878 string (@expr1073747879 reason@var2010 ) +@expr1073747880 " function '" +@expr1073747881 name@var1941 +@expr1073747882 "' called. It is recommended to use " ;
852: std ::@expr1073747883 vector < std ::@expr5553 string > alt@var2013 ; alt@var2013 =@expr1073747885 getnames (@expr1073747886 alternatives@var2011 ) ;
853: for (@expr1073747887 unsigned long i@var2014 =@expr1073747888 0 ; i@var2014 <@expr1073747889 alt@var2013 .@expr6066 size (@expr6067 ) ; ++@expr1073747892 i@var2014 ) {
854: wi@var2002 .@expr6052 message@var2012 +=@expr1073747894 "'" +@expr1073747895 alt@var2013 [@expr1073747896 i@var2014 ] +@expr1073747897 "'" ;
855: if (@expr1073747898 i@var2014 ==@expr1073747899 alt@var2013 .@expr6066 size (@expr6067 ) -@expr1073747902 1 ) {
856: wi@var2002 .@expr6052 message@var2012 +=@expr1073747904 " instead." ; }
857: else { if (@expr1073747905 i@var2014 ==@expr1073747906 alt@var2013 .@expr6066 size (@expr6067 ) -@expr1073747909 2 ) {
858: wi@var2002 .@expr6052 message@var2012 +=@expr1073747911 " or " ; }
859: else {
860: wi@var2002 .@expr6052 message@var2012 +=@expr1073747913 ", " ; } }
861: }
862: } else {
863: const char * const message@var2015 ; message@var2015 =@expr1073747914 functionnode@var1944 .@expr5569 GetText (@expr5570 ) ;
864: if (@expr1073747917 !@expr1073747918 message@var2015 ) {
865: return Error (@expr1073747919 ErrorCode ::@expr5685 MISSING_ATTRIBUTE@expr5532 , "\"reason\" and \"alternatives\" or some text." ) ;
866: } else {
867: wi@var2002 .@expr6052 message@var2012 =@expr1073747922 message@var2015 ; }
868: }
869:
870: functionwarn@var216 [@expr1073747923 name@var1941 ] =@expr1073747924 wi@var2002 ;
871: } else { if (@expr1073747925 functionnodename@var1945 ==@expr1073747926 "container" ) {
872: const char * const action_ptr@var2016 ; action_ptr@var2016 =@expr1073747927 functionnode@var1944 .@expr5629 Attribute (@expr1073747929 "action" ) ;
873: Container ::@expr1073747930 Action action@var2017 ; action@var2017 =@expr1073747931 Container ::@expr6108 Action ::@expr6109 NO_ACTION@expr5542 ;
874: if (@expr1073747934 action_ptr@var2016 ) {
875: std ::@expr1073747935 string actionName@var2018 ; actionName@var2018 =@expr1073747936 action_ptr@var2016 ;
876: action@var2017 =@expr1073747937 Container ::@expr1073747938 actionFrom (@expr1073747939 actionName@var2018 ) ;
877: if (@expr1073747940 action@var2017 ==@expr1073747941 Container ::@expr6108 Action ::@expr6109 NO_ACTION@expr5542 ) {
878: return Error (@expr1073747944 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , actionName@var2018 ) ; }
879: }
880: func@var1943 .@expr1073747946 containerAction@var2019 =@expr1073747947 action@var2017 ;
881:
882: const char * const yield_ptr@var2020 ; yield_ptr@var2020 =@expr1073747948 functionnode@var1944 .@expr5629 Attribute (@expr1073747950 "yields" ) ;
883: Container ::@expr1073747951 Yield yield@var2021 ; yield@var2021 =@expr1073747952 Container ::@expr6129 Yield ::@expr6130 NO_YIELD@expr5543 ;
884: if (@expr1073747955 yield_ptr@var2020 ) {
885: std ::@expr1073747956 string yieldName@var2022 ; yieldName@var2022 =@expr1073747957 yield_ptr@var2020 ;
886: yield@var2021 =@expr1073747958 Container ::@expr1073747959 yieldFrom (@expr1073747960 yieldName@var2022 ) ;
887: if (@expr1073747961 yield@var2021 ==@expr1073747962 Container ::@expr6129 Yield ::@expr6130 NO_YIELD@expr5543 ) {
888: return Error (@expr1073747965 ErrorCode ::@expr5786 BAD_ATTRIBUTE_VALUE@expr5536 , yieldName@var2022 ) ; }
889: }
890: func@var1943 .@expr1073747967 containerYield@var2023 =@expr1073747968 yield@var2021 ;
891: } else {
892: unknown_elements@var1942 .@expr5965 insert (@expr1073747970 functionnodename@var1945 ) ; } } } } } } } } } } } }
893: }
894: return Error (@expr5547 ErrorCode ::@expr5548 OK@expr5528 ) ;
895: }
896:
897: bool Library :: isIntArgValid ( const Token * ftok@var2024 , int argnr@var2025 , const long long argvalue@var2026 ) const
898: {
899: const ArgumentChecks * ac@var2027 ; ac@var2027 =@expr1073747974 getarg (@expr1073747975 ftok@var2024 , argnr@var2025 ) ;
900: if (@expr1073747976 !@expr1073747977 ac@var2027 ||@expr1073747978 ac@var2027 .@expr6155 valid@var2028 .@expr1073747980 empty (@expr1073747981 ) ) {
901: return true ; }
902: else { if (@expr1073747982 ac@var2027 .@expr6155 valid@var2028 .@expr1073747984 find (@expr1073747985 '.' ) !=@expr1073747986 std ::@expr1073747987 string ::@expr1073747988 npos@expr1073747973 ) {
903: return isFloatArgValid (@expr1073747989 ftok@var2024 , argnr@var2025 , argvalue@var2026 ) ; } }
904: TokenList tokenList@var2029 (@expr1073747990 nullptr ) ;
905: gettokenlistfromvalid (@expr1073747991 ac@var2027 .@expr6155 valid@var2028 , tokenList@var2029 ) ;
906: for (@expr1073747993 const Token *@expr1073747994 tok@var2030 =@expr1073747995 tokenList@var2029 .@expr1073747996 front (@expr1073747997 ) ; tok@var2030 ; tok@var2030 =@expr1073747998 tok@var2030 .@expr1073747999 next (@expr1073748000 ) ) {
907: if (@expr1073748001 tok@var2030 .@expr1073748002 isNumber (@expr1073748003 ) &&@expr1073748004 argvalue@var2026 ==@expr1073748005 MathLib ::@expr6182 toLongNumber (@expr6183 tok@var2030 .@expr6184 str (@expr6185 ) ) ) {
908: return true ; }
909: if (@expr1073748010 Token ::@expr6187 Match (@expr1073748012 tok@var2030 , "%num% : %num%" ) &&@expr1073748013 argvalue@var2026 >=@expr6190 MathLib ::@expr6182 toLongNumber (@expr6183 tok@var2030 .@expr6184 str (@expr6185 ) ) &&@expr1073748019 argvalue@var2026 <=@expr1073748020 MathLib ::@expr6182 toLongNumber (@expr1073748022 tok@var2030 .@expr6199 strAt (@expr1073748024 2 ) ) ) {
910: return true ; }
911: if (@expr1073748025 Token ::@expr6187 Match (@expr1073748027 tok@var2030 , "%num% : ," ) &&@expr1073748028 argvalue@var2026 >=@expr6190 MathLib ::@expr6182 toLongNumber (@expr6183 tok@var2030 .@expr6184 str (@expr6185 ) ) ) {
912: return true ; }
913: if (@expr1073748034 (@expr1073748035 !@expr1073748036 tok@var2030 .@expr6213 previous (@expr6214 ) ||@expr1073748039 tok@var2030 .@expr6213 previous (@expr6214 ) .@expr1073748042 str (@expr1073748043 ) ==@expr1073748044 "," ) &&@expr1073748045 Token ::@expr6187 Match (@expr1073748047 tok@var2030 , ": %num%" ) &&@expr1073748048 argvalue@var2026 <=@expr1073748049 MathLib ::@expr6182 toLongNumber (@expr1073748051 tok@var2030 .@expr6199 strAt (@expr1073748053 1 ) ) ) {
914: return true ; }
915: }
916: return false ;
917: }
918:
919: bool Library :: isFloatArgValid ( const Token * ftok@var2031 , int argnr@var2032 , double argvalue@var2033 ) const
920: {
921: const ArgumentChecks * ac@var2034 ; ac@var2034 =@expr1073748054 getarg (@expr1073748055 ftok@var2031 , argnr@var2032 ) ;
922: if (@expr1073748056 !@expr1073748057 ac@var2034 ||@expr1073748058 ac@var2034 .@expr6235 valid@var2035 .@expr1073748060 empty (@expr1073748061 ) ) {
923: return true ; }
924: TokenList tokenList@var2036 (@expr1073748062 nullptr ) ;
925: gettokenlistfromvalid (@expr1073748063 ac@var2034 .@expr6235 valid@var2035 , tokenList@var2036 ) ;
926: for (@expr1073748065 const Token *@expr1073748066 tok@var2037 =@expr1073748067 tokenList@var2036 .@expr1073748068 front (@expr1073748069 ) ; tok@var2037 ; tok@var2037 =@expr1073748070 tok@var2037 .@expr6247 next (@expr6248 ) ) {
927: if (@expr1073748073 Token ::@expr6250 Match (@expr1073748075 tok@var2037 , "%num% : %num%" ) &&@expr1073748076 argvalue@var2033 >=@expr6253 MathLib ::@expr6254 toDoubleNumber (@expr6255 tok@var2037 .@expr6256 str (@expr6257 ) ) &&@expr1073748082 argvalue@var2033 <=@expr1073748083 MathLib ::@expr6254 toDoubleNumber (@expr1073748085 tok@var2037 .@expr6262 strAt (@expr1073748087 2 ) ) ) {
928: return true ; }
929: if (@expr1073748088 Token ::@expr6250 Match (@expr1073748090 tok@var2037 , "%num% : ," ) &&@expr1073748091 argvalue@var2033 >=@expr6253 MathLib ::@expr6254 toDoubleNumber (@expr6255 tok@var2037 .@expr6256 str (@expr6257 ) ) ) {
930: return true ; }
931: if (@expr1073748097 (@expr1073748098 !@expr1073748099 tok@var2037 .@expr6276 previous (@expr6277 ) ||@expr1073748102 tok@var2037 .@expr6276 previous (@expr6277 ) .@expr1073748105 str (@expr1073748106 ) ==@expr1073748107 "," ) &&@expr1073748108 Token ::@expr6250 Match (@expr1073748110 tok@var2037 , ": %num%" ) &&@expr1073748111 argvalue@var2033 <=@expr1073748112 MathLib ::@expr6254 toDoubleNumber (@expr1073748114 tok@var2037 .@expr6262 strAt (@expr1073748116 1 ) ) ) {
932: return true ; }
933: if (@expr1073748117 Token ::@expr6250 Match (@expr1073748119 tok@var2037 , "%num%" ) &&@expr1073748120 MathLib ::@expr6297 isFloat (@expr1073748122 tok@var2037 .@expr6256 str (@expr6257 ) ) &&@expr1073748125 MathLib ::@expr1073748126 isEqual (@expr1073748127 tok@var2037 .@expr6256 str (@expr6257 ) , MathLib ::@expr6306 toString (@expr6307 argvalue@var2033 ) ) ) {
934: return true ; }
935: if (@expr1073748132 Token ::@expr6250 Match (@expr1073748134 tok@var2037 , "! %num%" ) &&@expr1073748135 MathLib ::@expr6297 isFloat (@expr1073748137 tok@var2037 .@expr6247 next (@expr6248 ) .@expr6316 str (@expr6317 ) ) ) {
936: return MathLib ::@expr1073748142 isNotEqual (@expr1073748143 tok@var2037 .@expr6247 next (@expr6248 ) .@expr6316 str (@expr6317 ) , MathLib ::@expr6306 toString (@expr6307 argvalue@var2033 ) ) ; }
937: }
938: return false ;
939: }
940:
941: std :: string Library :: getFunctionName ( const Token * ftok@var2038 , bool * error@var2039 ) const
942: {
943: if (@expr1073748150 !@expr1073748151 ftok@var2038 ) {
944: *@expr6328 error@var2039 =@expr1073748153 true ;
945: return "" ;
946: }
947: if (@expr1073748154 ftok@var2038 .@expr1073748155 isName (@expr1073748156 ) ) {
948: for (@expr1073748157 const Scope *@expr1073748158 scope@var2040 =@expr1073748159 ftok@var2038 .@expr1073748160 scope (@expr1073748161 ) ; scope@var2040 ; scope@var2040 =@expr1073748162 scope@var2040 .@expr1073748163 nestedIn@var2041 ) {
949: if (@expr1073748164 !@expr1073748165 scope@var2040 .@expr1073748166 isClassOrStruct (@expr1073748167 ) ) {
950: continue ; }
951: const std ::@expr1073748168 vector < Type ::@expr6345 BaseInfo > & derivedFrom@var2042 =@expr1073748170 scope@var2040 .@expr1073748171 definedType@var2043 .@expr1073748172 derivedFrom@var2044 ;
952: for (@expr1073748173 const Type ::@expr6345 BaseInfo &@expr1073748175 baseInfo@var2045 :@expr1073748176 derivedFrom@var2042 ) {
953: const std ::@expr1073748177 string name@var2046 (@expr1073748178 baseInfo@var2045 .@expr1073748179 name@var2047 +@expr1073748180 "::" +@expr1073748181 ftok@var2038 .@expr6358 str (@expr6359 ) ) ;
954: if (@expr1073748184 functions@var299 .@expr1073748185 find (@expr1073748186 name@var2046 ) !=@expr1073748187 functions@var299 .@expr1073748188 end (@expr1073748189 ) &&@expr1073748190 matchArguments (@expr1073748191 ftok@var2038 , name@var2046 ) ) {
955: return name@var2046 ; }
956: }
957: }
958: return ftok@var2038 .@expr6358 str (@expr6359 ) ;
959: }
960: if (@expr1073748194 ftok@var2038 .@expr6358 str (@expr6359 ) ==@expr1073748197 "::" ) {
961: if (@expr1073748198 !@expr1073748199 ftok@var2038 .@expr6376 astOperand2 (@expr6377 ) ) {
962: return getFunctionName (@expr6378 ftok@var2038 .@expr6379 astOperand1 (@expr6380 ) , error@var2039 ) ; }
963: return getFunctionName (@expr6378 ftok@var2038 .@expr6379 astOperand1 (@expr6380 ) , error@var2039 ) +@expr1073748208 "::" +@expr1073748209 getFunctionName (@expr6386 ftok@var2038 .@expr6376 astOperand2 (@expr6377 ) , error@var2039 ) ;
964: }
965: if (@expr1073748213 ftok@var2038 .@expr6358 str (@expr6359 ) ==@expr1073748216 "." &&@expr1073748217 ftok@var2038 .@expr6379 astOperand1 (@expr6380 ) ) {
966: const std ::@expr6345 string type@var2048 =@expr1073748221 astCanonicalType (@expr1073748222 ftok@var2038 .@expr6379 astOperand1 (@expr6380 ) ) ;
967: if (@expr1073748225 type@var2048 .@expr1073748226 empty (@expr1073748227 ) ) {
968: *@expr6328 error@var2039 =@expr1073748229 true ;
969: return "" ;
970: }
971:
972: return type@var2048 +@expr1073748230 "::" +@expr1073748231 getFunctionName (@expr6386 ftok@var2038 .@expr6376 astOperand2 (@expr6377 ) , error@var2039 ) ;
973: }
974: *@expr6328 error@var2039 =@expr1073748236 true ;
975: return "" ;
976: }
977:
978: std :: string Library :: getFunctionName ( const Token * ftok@var2049 ) const
979: {
980: if (@expr1073748237 !@expr1073748238 Token ::@expr6415 Match (@expr1073748240 ftok@var2049 , "%name% (" ) &&@expr1073748241 (@expr1073748242 ftok@var2049 .@expr1073748243 strAt (@expr1073748244 -1 ) !=@expr1073748245 "&" ||@expr1073748246 ftok@var2049 .@expr6423 previous (@expr6424 ) .@expr1073748249 astOperand2 (@expr1073748250 ) ) ) {
981: return "" ; }
982:
983:
984: if (@expr1073748251 ftok@var2049 .@expr6428 astParent (@expr6429 ) ) {
985: bool error@var2050 ; error@var2050 =@expr1073748254 false ;
986: const Token * tok@var2051 ; tok@var2051 =@expr1073748255 ftok@var2049 .@expr6428 astParent (@expr6429 ) .@expr1073748258 isUnaryOp (@expr1073748259 "&" ) ?@expr1073748260 ftok@var2049 .@expr6428 astParent (@expr6429 ) .@expr1073748263 astOperand1 (@expr1073748264 ) :@expr1073748265 ftok@var2049 .@expr1073748266 next (@expr1073748267 ) .@expr1073748268 astOperand1 (@expr1073748269 ) ;
987: const std ::@expr1073748270 string ret@var2052 =@expr1073748271 getFunctionName (@expr1073748272 tok@var2051 , &@expr1073748273 error@var2050 ) ;
988: return error@var2050 ?@expr1073748274 std ::@expr1073748275 string (@expr1073748276 ) :@expr1073748277 ret@var2052 ;
989: }
990:
991:
992: if (@expr1073748278 Token ::@expr1073748279 simpleMatch (@expr1073748280 ftok@var2049 .@expr6423 previous (@expr6424 ) , "." ) ) {
993: return "" ; }
994: if (@expr1073748283 !@expr1073748284 Token ::@expr6415 Match (@expr1073748286 ftok@var2049 .@expr6463 tokAt (@expr6464 -2 ) , "%name% ::" ) ) {
995: return ftok@var2049 .@expr6465 str (@expr6466 ) ; }
996: std ::@expr1073748291 string ret@var2053 (@expr1073748292 ftok@var2049 .@expr6465 str (@expr6466 ) ) ;
997: ftok@var2049 =@expr1073748295 ftok@var2049 .@expr6463 tokAt (@expr6464 -2 ) ;
998: while (@expr1073748298 Token ::@expr6415 Match (@expr1073748300 ftok@var2049 , "%name% ::" ) ) {
999: ret@var2053 =@expr1073748301 ftok@var2049 .@expr6465 str (@expr6466 ) +@expr1073748304 "::" +@expr1073748305 ret@var2053 ;
1000: ftok@var2049 =@expr1073748306 ftok@var2049 .@expr6463 tokAt (@expr6464 -2 ) ;
1001: }
1002: return ret@var2053 ;
1003: }
1004:
1005: bool Library :: isnullargbad ( const Token * ftok@var2054 , int argnr@var2055 ) const
1006: {
1007: const ArgumentChecks * arg@var2056 ; arg@var2056 =@expr1073748309 getarg (@expr1073748310 ftok@var2054 , argnr@var2055 ) ;
1008: if (@expr1073748311 !@expr1073748312 arg@var2056 ) {
1009:
1010: const std ::@expr6489 string funcname@var2057 =@expr1073748314 getFunctionName (@expr1073748315 ftok@var2054 ) ;
1011: const std ::@expr1073748316 unordered_map < std ::@expr6489 string , Function > ::@expr1073748318 const_iterator it@var2058 =@expr1073748319 functions@var299 .@expr1073748320 find (@expr1073748321 funcname@var2057 ) ;
1012: if (@expr1073748322 it@var2058 !=@expr1073748323 functions@var299 .@expr1073748324 cend (@expr1073748325 ) &&@expr1073748326 it@var2058 .@expr6503 second@var2059 .@expr1073748328 formatstr@var2060 &&@expr1073748329 it@var2058 .@expr6503 second@var2059 .@expr1073748331 formatstr_scan@var2061 ) {
1013: return true ; }
1014: }
1015: return arg@var2056 &&@expr1073748332 arg@var2056 .@expr1073748333 notnull@var2062 ;
1016: }
1017:
1018: bool Library :: isuninitargbad ( const Token * ftok@var2063 , int argnr@var2064 , int indirect@var2065 , bool * hasIndirect@var2066 ) const
1019: {
1020: const ArgumentChecks * arg@var2067 ; arg@var2067 =@expr1073748334 getarg (@expr1073748335 ftok@var2063 , argnr@var2064 ) ;
1021: if (@expr1073748336 !@expr1073748337 arg@var2067 ) {
1022:
1023: const std ::@expr6514 string funcname@var2068 =@expr1073748339 getFunctionName (@expr1073748340 ftok@var2063 ) ;
1024: const std ::@expr1073748341 unordered_map < std ::@expr6514 string , Function > ::@expr1073748343 const_iterator it@var2069 =@expr1073748344 functions@var299 .@expr1073748345 find (@expr1073748346 funcname@var2068 ) ;
1025: if (@expr1073748347 it@var2069 !=@expr1073748348 functions@var299 .@expr1073748349 cend (@expr1073748350 ) &&@expr1073748351 it@var2069 .@expr6528 second@var2070 .@expr1073748353 formatstr@var2071 &&@expr1073748354 !@expr1073748355 it@var2069 .@expr6528 second@var2070 .@expr1073748357 formatstr_scan@var2072 ) {
1026: return true ; }
1027: }
1028: if (@expr1073748358 hasIndirect@var2066 &&@expr1073748359 arg@var2067 &&@expr1073748360 arg@var2067 .@expr6537 notuninit@var2073 >=@expr1073748362 1 ) {
1029: *@expr1073748363 hasIndirect@var2066 =@expr1073748364 true ; }
1030: return arg@var2067 &&@expr1073748365 arg@var2067 .@expr6537 notuninit@var2073 >=@expr1073748367 indirect@var2065 ;
1031: }
1032:
1033:
1034:
1035: const Library :: AllocFunc * Library :: getAllocFuncInfo ( const Token * tok@var2074 ) const
1036: {
1037: const std ::@expr1073748368 string funcname@var2075 =@expr1073748369 getFunctionName (@expr1073748370 tok@var2074 ) ;
1038: return isNotLibraryFunction (@expr1073748371 tok@var2074 ) &&@expr1073748372 functions@var299 .@expr1073748373 find (@expr1073748374 funcname@var2075 ) !=@expr1073748375 functions@var299 .@expr1073748376 end (@expr1073748377 ) ?@expr1073748378 nullptr :@expr1073748379 getAllocDealloc (@expr1073748380 mAlloc@var443 , funcname@var2075 ) ;
1039: }
1040:
1041:
1042: const Library :: AllocFunc * Library :: getDeallocFuncInfo ( const Token * tok@var2076 ) const
1043: {
1044: const std ::@expr1073748381 string funcname@var2077 =@expr1073748382 getFunctionName (@expr1073748383 tok@var2076 ) ;
1045: return isNotLibraryFunction (@expr1073748384 tok@var2076 ) &&@expr1073748385 functions@var299 .@expr1073748386 find (@expr1073748387 funcname@var2077 ) !=@expr1073748388 functions@var299 .@expr1073748389 end (@expr1073748390 ) ?@expr1073748391 nullptr :@expr1073748392 getAllocDealloc (@expr1073748393 mDealloc@var444 , funcname@var2077 ) ;
1046: }
1047:
1048:
1049: const Library :: AllocFunc * Library :: getReallocFuncInfo ( const Token * tok@var2078 ) const
1050: {
1051: const std ::@expr1073748394 string funcname@var2079 =@expr1073748395 getFunctionName (@expr1073748396 tok@var2078 ) ;
1052: return isNotLibraryFunction (@expr1073748397 tok@var2078 ) &&@expr1073748398 functions@var299 .@expr1073748399 find (@expr1073748400 funcname@var2079 ) !=@expr1073748401 functions@var299 .@expr1073748402 end (@expr1073748403 ) ?@expr1073748404 nullptr :@expr1073748405 getAllocDealloc (@expr1073748406 mRealloc@var445 , funcname@var2079 ) ;
1053: }
1054:
1055:
1056: int Library :: getAllocId ( const Token * tok@var2080 , int arg@var2081 ) const
1057: {
1058: const Library ::@expr1073748407 AllocFunc * af@var2082 ; af@var2082 =@expr1073748408 getAllocFuncInfo (@expr1073748409 tok@var2080 ) ;
1059: return (@expr1073748410 af@var2082 &&@expr1073748411 af@var2082 .@expr1073748412 arg@var2083 ==@expr1073748413 arg@var2081 ) ?@expr1073748414 af@var2082 .@expr1073748415 groupId@var2084 :@expr1073748416 0 ;
1060: }
1061:
1062:
1063: int Library :: getDeallocId ( const Token * tok@var2085 , int arg@var2086 ) const
1064: {
1065: const Library ::@expr1073748417 AllocFunc * af@var2087 ; af@var2087 =@expr1073748418 getDeallocFuncInfo (@expr1073748419 tok@var2085 ) ;
1066: return (@expr1073748420 af@var2087 &&@expr1073748421 af@var2087 .@expr1073748422 arg@var2088 ==@expr1073748423 arg@var2086 ) ?@expr1073748424 af@var2087 .@expr1073748425 groupId@var2089 :@expr1073748426 0 ;
1067: }
1068:
1069:
1070: int Library :: getReallocId ( const Token * tok@var2090 , int arg@var2091 ) const
1071: {
1072: const Library ::@expr1073748427 AllocFunc * af@var2092 ; af@var2092 =@expr1073748428 getReallocFuncInfo (@expr1073748429 tok@var2090 ) ;
1073: return (@expr1073748430 af@var2092 &&@expr1073748431 af@var2092 .@expr1073748432 arg@var2093 ==@expr1073748433 arg@var2091 ) ?@expr1073748434 af@var2092 .@expr1073748435 groupId@var2094 :@expr1073748436 0 ;
1074: }
1075:
1076:
1077: const Library :: ArgumentChecks * Library :: getarg ( const Token * ftok@var2095 , int argnr@var2096 ) const
1078: {
1079: if (@expr1073748437 isNotLibraryFunction (@expr1073748438 ftok@var2095 ) ) {
1080: return nullptr ; }
1081: const std ::@expr1073748439 unordered_map < std ::@expr1073748440 string , Function > ::@expr1073748441 const_iterator it1@var2097 =@expr1073748442 functions@var299 .@expr1073748443 find (@expr1073748444 getFunctionName (@expr1073748445 ftok@var2095 ) ) ;
1082: if (@expr1073748446 it1@var2097 ==@expr1073748447 functions@var299 .@expr1073748448 cend (@expr1073748449 ) ) {
1083: return nullptr ; }
1084: const std ::@expr6626 map < int , ArgumentChecks > ::@expr1073748451 const_iterator it2@var2098 =@expr1073748452 it1@var2097 .@expr6629 second@var2099 .@expr6630 argumentChecks@var2100 .@expr6631 find (@expr1073748456 argnr@var2096 ) ;
1085: if (@expr1073748457 it2@var2098 !=@expr1073748458 it1@var2097 .@expr6629 second@var2099 .@expr6630 argumentChecks@var2100 .@expr6637 cend (@expr6638 ) ) {
1086: return &@expr1073748463 it2@var2098 .@expr1073748464 second@var2101 ; }
1087: const std ::@expr6626 map < int , ArgumentChecks > ::@expr1073748466 const_iterator it3@var2102 =@expr1073748467 it1@var2097 .@expr6629 second@var2099 .@expr6630 argumentChecks@var2100 .@expr6631 find (@expr1073748471 -1 ) ;
1088: if (@expr1073748472 it3@var2102 !=@expr1073748473 it1@var2097 .@expr6629 second@var2099 .@expr6630 argumentChecks@var2100 .@expr6637 cend (@expr6638 ) ) {
1089: return &@expr1073748478 it3@var2102 .@expr1073748479 second@var2103 ; }
1090: return nullptr ;
1091: }
1092:
1093: bool Library :: isScopeNoReturn ( const Token * end@var2104 , std :: string * unknownFunc@var2105 ) const
1094: {
1095: if (@expr1073748480 unknownFunc@var2105 ) {
1096: unknownFunc@var2105 .@expr1073748481 clear (@expr1073748482 ) ; }
1097:
1098: if (@expr1073748483 Token ::@expr6660 Match (@expr1073748485 end@var2104 .@expr6662 tokAt (@expr6663 -2 ) , "!!{ ; }" ) ) {
1099: const Token * lastTop@var2106 ; lastTop@var2106 =@expr1073748488 end@var2104 .@expr6662 tokAt (@expr6663 -2 ) .@expr1073748491 astTop (@expr1073748492 ) ;
1100: if (@expr1073748493 Token ::@expr6670 simpleMatch (@expr1073748495 lastTop@var2106 , "<<" ) &&@expr1073748496
1101: Token ::@expr6670 simpleMatch (@expr1073748498 lastTop@var2106 .@expr6675 astOperand1 (@expr6676 ) , "(" ) &&@expr1073748501
1102: Token ::@expr6660 Match (@expr1073748503 lastTop@var2106 .@expr6675 astOperand1 (@expr6676 ) .@expr6682 previous (@expr6683 ) , "%name% (" ) ) {
1103: return isnoreturn (@expr1073748508 lastTop@var2106 .@expr6675 astOperand1 (@expr6676 ) .@expr6682 previous (@expr6683 ) ) ; }
1104: }
1105:
1106: if (@expr1073748513 !@expr1073748514 Token ::@expr6670 simpleMatch (@expr1073748516 end@var2104 .@expr6662 tokAt (@expr6663 -2 ) , ") ; }" ) ) {
1107: return false ; }
1108:
1109: const Token * funcname@var2107 ; funcname@var2107 =@expr1073748519 end@var2104 .@expr1073748520 linkAt (@expr1073748521 -2 ) .@expr1073748522 previous (@expr1073748523 ) ;
1110: const Token * start@var2108 ; start@var2108 =@expr1073748524 funcname@var2107 ;
1111: if (@expr1073748525 Token ::@expr6660 Match (@expr1073748527 funcname@var2107 .@expr6704 tokAt (@expr6705 -3 ) , "( * %name% )" ) ) {
1112: funcname@var2107 =@expr1073748530 funcname@var2107 .@expr1073748531 previous (@expr1073748532 ) ;
1113: start@var2108 =@expr1073748533 funcname@var2107 .@expr6704 tokAt (@expr6705 -3 ) ;
1114: } else { if (@expr1073748536 funcname@var2107 .@expr1073748537 isName (@expr1073748538 ) ) {
1115: while (@expr1073748539 Token ::@expr6660 Match (@expr1073748541 start@var2108 , "%name%|.|::" ) ) {
1116: start@var2108 =@expr1073748542 start@var2108 .@expr1073748543 previous (@expr1073748544 ) ; }
1117: } else {
1118: return false ;
1119: } }
1120: if (@expr1073748545 Token ::@expr6660 Match (@expr1073748547 start@var2108 , "[;{}]" ) &&@expr1073748548 Token ::@expr6660 Match (@expr1073748550 funcname@var2107 , "%name% )| (" ) ) {
1121: if (@expr1073748551 funcname@var2107 .@expr6728 str (@expr6729 ) ==@expr1073748554 "exit" ) {
1122: return true ; }
1123: if (@expr1073748555 !@expr1073748556 isnotnoreturn (@expr1073748557 funcname@var2107 ) ) {
1124: if (@expr1073748558 unknownFunc@var2105 &&@expr1073748559 !@expr1073748560 isnoreturn (@expr1073748561 funcname@var2107 ) ) {
1125: *@expr1073748562 unknownFunc@var2105 =@expr1073748563 funcname@var2107 .@expr6728 str (@expr6729 ) ; }
1126: return true ;
1127: }
1128: }
1129: return false ;
1130: }
1131:
1132: const Library :: Container * Library :: detectContainer ( const Token * typeStart@var2109 , bool iterator@var2110 ) const
1133: {
1134: for (@expr1073748566 std ::@expr6743 map < std ::@expr6743 string , Container > ::@expr6743 const_iterator i@var2111 =@expr1073748570 containers@var260 .@expr1073748571 begin (@expr1073748572 ) ; i@var2111 !=@expr1073748573 containers@var260 .@expr1073748574 end (@expr1073748575 ) ; ++@expr1073748576 i@var2111 ) {
1135: const Container &@expr6753 container@var2112 =@expr1073748578 i@var2111 .@expr1073748579 second@var2113 ;
1136: if (@expr1073748580 container@var2112 .@expr1073748581 startPattern@var2114 .@expr1073748582 empty (@expr1073748583 ) ) {
1137: continue ; }
1138:
1139: if (@expr1073748584 !@expr1073748585 Token ::@expr6762 Match (@expr1073748587 typeStart@var2109 , container@var2112 .@expr1073748588 startPattern2@var2115 .@expr1073748589 c_str (@expr1073748590 ) ) ) {
1140: continue ; }
1141:
1142: if (@expr1073748591 !@expr1073748592 iterator@var2110 &&@expr1073748593 container@var2112 .@expr6770 endPattern@var2116 .@expr1073748595 empty (@expr1073748596 ) ) {
1143: return &@expr6773 container@var2112 ; }
1144:
1145: for (@expr1073748598 const Token *@expr1073748599 tok@var2117 =@expr1073748600 typeStart@var2109 ; tok@var2117 &&@expr1073748601 !@expr1073748602 tok@var2117 .@expr1073748603 varId (@expr1073748604 ) ; tok@var2117 =@expr1073748605 tok@var2117 .@expr1073748606 next (@expr1073748607 ) ) {
1146: if (@expr1073748608 tok@var2117 .@expr6785 link (@expr6786 ) ) {
1147: const std ::@expr6743 string &@expr6753 endPattern@var2118 =@expr1073748613 iterator@var2110 ?@expr1073748614 container@var2112 .@expr1073748615 itEndPattern@var2119 :@expr1073748616 container@var2112 .@expr6770 endPattern@var2116 ;
1148: if (@expr1073748618 Token ::@expr6762 Match (@expr1073748620 tok@var2117 .@expr6785 link (@expr6786 ) , endPattern@var2118 .@expr1073748623 c_str (@expr1073748624 ) ) ) {
1149: return &@expr6773 container@var2112 ; }
1150: break ;
1151: }
1152: }
1153: }
1154: return nullptr ;
1155: }
1156:
1157: const Library :: Container * Library :: detectContainerOrIterator ( const Token * typeStart@var2120 , bool * isIterator@var2121 ) const
1158: {
1159: const Library ::@expr1073748626 Container * c@var2122 ; c@var2122 =@expr1073748627 detectContainer (@expr1073748628 typeStart@var2120 ) ;
1160: if (@expr1073748629 c@var2122 ) {
1161: if (@expr1073748630 isIterator@var2121 ) {
1162: *@expr6807 isIterator@var2121 =@expr1073748632 false ; }
1163: return c@var2122 ;
1164: }
1165: c@var2122 =@expr1073748633 detectContainer (@expr1073748634 typeStart@var2120 , true ) ;
1166: if (@expr1073748635 c@var2122 &&@expr1073748636 isIterator@var2121 ) {
1167: *@expr6807 isIterator@var2121 =@expr1073748638 true ; }
1168: return c@var2122 ;
1169: }
1170:
1171: bool Library :: isContainerYield ( const Token * const cond@var2123 , Library :: Container :: Yield y@var2124 , const std :: string & fallback@var2125 )
1172: {
1173: if (@expr1073748639 !@expr1073748640 cond@var2123 ) {
1174: return false ; }
1175: if (@expr1073748641 cond@var2123 .@expr1073748642 str (@expr1073748643 ) ==@expr1073748644 "(" ) {
1176: const Token * tok@var2126 ; tok@var2126 =@expr1073748645 cond@var2123 .@expr1073748646 astOperand1 (@expr1073748647 ) ;
1177: if (@expr1073748648 tok@var2126 &&@expr1073748649 tok@var2126 .@expr1073748650 str (@expr1073748651 ) ==@expr1073748652 "." ) {
1178: if (@expr1073748653 tok@var2126 .@expr6830 astOperand1 (@expr6831 ) &&@expr1073748656 tok@var2126 .@expr6830 astOperand1 (@expr6831 ) .@expr6835 valueType (@expr6836 ) ) {
1179: if (@expr1073748661 const Library ::@expr1073748662 Container *@expr1073748663 container@var2127 =@expr1073748664 tok@var2126 .@expr6830 astOperand1 (@expr6831 ) .@expr6835 valueType (@expr6836 ) .@expr1073748669 container@var2305 ) {
1180: return tok@var2126 .@expr6846 astOperand2 (@expr6847 ) &&@expr1073748672 y@var2124 ==@expr1073748673 container@var2127 .@expr1073748674 getYield (@expr1073748675 tok@var2126 .@expr6846 astOperand2 (@expr6847 ) .@expr1073748678 str (@expr1073748679 ) ) ;
1181: }
1182: } else { if (@expr1073748680 !@expr1073748681 fallback@var2125 .@expr1073748682 empty (@expr1073748683 ) ) {
1183: return Token ::@expr1073748684 simpleMatch (@expr1073748685 cond@var2123 , "( )" ) &&@expr1073748686 cond@var2123 .@expr1073748687 previous (@expr1073748688 ) .@expr1073748689 str (@expr1073748690 ) ==@expr1073748691 fallback@var2125 ;
1184: } }
1185: }
1186: }
1187: return false ;
1188: }
1189:
1190:
1191: bool Library :: isNotLibraryFunction ( const Token * ftok@var2128 ) const
1192: {
1193: if (@expr1073748692 ftok@var2128 .@expr6869 function (@expr6870 ) &&@expr1073748695 ftok@var2128 .@expr6869 function (@expr6870 ) .@expr6874 nestedIn@var2299 &&@expr1073748699 ftok@var2128 .@expr6869 function (@expr6870 ) .@expr6874 nestedIn@var2299 .@expr1073748703 type@var2300 !=@expr1073748704 Scope ::@expr1073748705 eGlobal ) {
1194: return true ; }
1195:
1196:
1197: if (@expr1073748706 ftok@var2128 .@expr1073748707 varId (@expr1073748708 ) ) {
1198: return true ; }
1199:
1200: return !@expr1073748709 matchArguments (@expr1073748710 ftok@var2128 , getFunctionName (@expr1073748711 ftok@var2128 ) ) ;
1201: }
1202:
1203: bool Library :: matchArguments ( const Token * ftok@var2129 , const std :: string & functionName@var2130 ) const
1204: {
1205: const int callargs@var2131 =@expr1073748712 numberOfArgumentsWithoutAst (@expr1073748713 ftok@var2129 ) ;
1206: const std ::@expr1073748714 unordered_map < std ::@expr6891 string , Function > ::@expr1073748716 const_iterator it@var2132 =@expr1073748717 functions@var299 .@expr1073748718 find (@expr1073748719 functionName@var2130 ) ;
1207: if (@expr1073748720 it@var2132 ==@expr1073748721 functions@var299 .@expr1073748722 cend (@expr1073748723 ) ) {
1208: return (@expr6900 callargs@var2131 ==@expr1073748725 0 ) ; }
1209: int args@var2133 ; args@var2133 =@expr1073748726 0 ;
1210: int firstOptionalArg@var2134 ; firstOptionalArg@var2134 =@expr1073748727 -1 ;
1211: for (@expr1073748728 std ::@expr6891 map < int , ArgumentChecks > ::@expr6891 const_iterator it2@var2135 =@expr1073748731 it@var2132 .@expr6908 second@var2136 .@expr6909 argumentChecks@var2137 .@expr1073748734 cbegin (@expr1073748735 ) ; it2@var2135 !=@expr1073748736 it@var2132 .@expr6908 second@var2136 .@expr6909 argumentChecks@var2137 .@expr1073748739 cend (@expr1073748740 ) ; ++@expr1073748741 it2@var2135 ) {
1212: if (@expr1073748742 it2@var2135 .@expr6919 first@var2138 >@expr1073748744 args@var2133 ) {
1213: args@var2133 =@expr1073748745 it2@var2135 .@expr6919 first@var2138 ; }
1214: if (@expr1073748747 it2@var2135 .@expr6924 second@var2139 .@expr1073748749 optional@var2140 &&@expr1073748750 (@expr6900 firstOptionalArg@var2134 ==@expr1073748752 -1 ||@expr1073748753 firstOptionalArg@var2134 >@expr1073748754 it2@var2135 .@expr6919 first@var2138 ) ) {
1215: firstOptionalArg@var2134 =@expr1073748756 it2@var2135 .@expr6919 first@var2138 ; }
1216:
1217: if (@expr1073748758 it2@var2135 .@expr6924 second@var2139 .@expr1073748760 formatstr@var2141 ||@expr1073748761 it2@var2135 .@expr6924 second@var2139 .@expr1073748763 variadic@var2142 ) {
1218: return args@var2133 <=@expr1073748764 callargs@var2131 ; }
1219: }
1220: return (@expr6900 firstOptionalArg@var2134 <@expr1073748766 0 ) ?@expr1073748767 args@var2133 ==@expr1073748768 callargs@var2131 :@expr1073748769 (@expr6900 callargs@var2131 >=@expr1073748771 firstOptionalArg@var2134 -@expr1073748772 1 &&@expr1073748773 callargs@var2131 <=@expr1073748774 args@var2133 ) ;
1221: }
1222:
1223: const Library :: WarnInfo * Library :: getWarnInfo ( const Token * ftok@var2143 ) const
1224: {
1225: if (@expr1073748775 isNotLibraryFunction (@expr1073748776 ftok@var2143 ) ) {
1226: return nullptr ; }
1227: std ::@expr1073748777 map < std ::@expr1073748778 string , WarnInfo > ::@expr1073748779 const_iterator i@var2144 ; i@var2144 =@expr1073748780 functionwarn@var216 .@expr1073748781 find (@expr1073748782 getFunctionName (@expr1073748783 ftok@var2143 ) ) ;
1228: if (@expr1073748784 i@var2144 ==@expr1073748785 functionwarn@var216 .@expr1073748786 cend (@expr1073748787 ) ) {
1229: return nullptr ; }
1230: return &@expr1073748788 i@var2144 .@expr1073748789 second@var2145 ;
1231: }
1232:
1233: bool Library :: isCompliantValidationExpression ( const char * p@var2146 )
1234: {
1235: if (@expr1073748790 !@expr1073748791 p@var2146 ||@expr1073748792 !@expr1073748793 *@expr6970 p@var2146 ) {
1236: return false ; }
1237:
1238: bool error@var2147 ; error@var2147 =@expr1073748795 false ;
1239: bool range@var2148 ; range@var2148 =@expr1073748796 false ;
1240: bool has_dot@var2149 ; has_dot@var2149 =@expr1073748797 false ;
1241: bool has_E@var2150 ; has_E@var2150 =@expr1073748798 false ;
1242:
1243: error@var2147 =@expr1073748799 *@expr6970 p@var2146 ==@expr6977 '.' ;
1244: for (@expr1073748802 ; *@expr6970 p@var2146 ; p@var2146 ++@expr1073748804 ) {
1245: if (@expr1073748805 std ::@expr6982 isdigit (@expr1073748807 *@expr6970 p@var2146 ) ) {
1246: error@var2147 |=@expr1073748809 (@expr1073748810 *@expr6987 (@expr1073748812 p@var2146 +@expr6989 1 ) ==@expr6990 '-' ) ;
1247: }
1248: else { if (@expr1073748815 *@expr6970 p@var2146 ==@expr1073748817 ':' ) {
1249: error@var2147 |=@expr1073748818 range@var2148 |@expr1073748819 (@expr1073748820 *@expr6987 (@expr1073748822 p@var2146 +@expr6989 1 ) ==@expr7000 '.' ) ;
1250: range@var2148 =@expr1073748825 true ;
1251: has_dot@var2149 =@expr1073748826 false ;
1252: has_E@var2150 =@expr1073748827 false ;
1253: }
1254: else { if (@expr1073748828 (@expr1073748829 *@expr6970 p@var2146 ==@expr1073748831 '-' ) ||@expr1073748832 (@expr1073748833 *@expr6970 p@var2146 ==@expr1073748835 '+' ) ) {
1255: error@var2147 |=@expr1073748836 (@expr1073748837 !@expr7014 std ::@expr6982 isdigit (@expr7016 *@expr6987 (@expr1073748842 p@var2146 +@expr6989 1 ) ) ) ;
1256: }
1257: else { if (@expr1073748844 *@expr6970 p@var2146 ==@expr1073748846 ',' ) {
1258: range@var2148 =@expr1073748847 false ;
1259: error@var2147 |=@expr1073748848 *@expr6987 (@expr1073748850 p@var2146 +@expr6989 1 ) ==@expr7000 '.' ;
1260: has_dot@var2149 =@expr1073748853 false ;
1261: has_E@var2150 =@expr1073748854 false ;
1262: } else { if (@expr1073748855 *@expr6970 p@var2146 ==@expr6977 '.' ) {
1263: error@var2147 |=@expr1073748858 has_dot@var2149 |@expr1073748859 (@expr1073748860 !@expr7014 std ::@expr6982 isdigit (@expr7016 *@expr6987 (@expr1073748865 p@var2146 +@expr6989 1 ) ) ) ;
1264: has_dot@var2149 =@expr1073748867 true ;
1265: } else { if (@expr1073748868 *@expr6970 p@var2146 ==@expr1073748870 'E' ||@expr1073748871 *@expr6970 p@var2146 ==@expr1073748873 'e' ) {
1266: error@var2147 |=@expr1073748874 has_E@var2150 ;
1267: has_E@var2150 =@expr1073748875 true ;
1268: } else { if (@expr1073748876 *@expr6970 p@var2146 ==@expr1073748878 '!' ) {
1269: error@var2147 |=@expr1073748879 !@expr1073748880 (@expr1073748881 (@expr1073748882 *@expr6987 (@expr1073748884 p@var2146 +@expr6989 1 ) ==@expr6990 '-' ) ||@expr1073748887 (@expr1073748888 *@expr6987 (@expr1073748890 p@var2146 +@expr6989 1 ) ==@expr1073748892 '+' ) ||@expr1073748893 (@expr1073748894 std ::@expr6982 isdigit (@expr7016 *@expr6987 (@expr1073748898 p@var2146 +@expr6989 1 ) ) ) ) ;
1270: } else {
1271: return false ; } } } } } } }
1272: }
1273: return !@expr1073748900 error@var2147 ;
1274: }
1275:
1276: bool Library :: formatstr_function ( const Token * ftok@var2151 ) const
1277: {
1278: if (@expr1073748901 isNotLibraryFunction (@expr1073748902 ftok@var2151 ) ) {
1279: return false ; }
1280:
1281: const std ::@expr1073748903 unordered_map < std ::@expr1073748904 string , Function > ::@expr1073748905 const_iterator it@var2152 =@expr1073748906 functions@var299 .@expr1073748907 find (@expr1073748908 getFunctionName (@expr1073748909 ftok@var2151 ) ) ;
1282: if (@expr1073748910 it@var2152 !=@expr1073748911 functions@var299 .@expr1073748912 cend (@expr1073748913 ) ) {
1283: return it@var2152 .@expr1073748914 second@var2153 .@expr1073748915 formatstr@var2154 ; }
1284: return false ;
1285: }
1286:
1287: int Library :: formatstr_argno ( const Token * ftok@var2155 ) const
1288: {
1289: const std ::@expr1073748916 map < int , Library ::@expr7093 ArgumentChecks > & argumentChecksFunc@var2156 =@expr1073748918 functions@var299 .@expr1073748919 at (@expr1073748920 getFunctionName (@expr1073748921 ftok@var2155 ) ) .@expr1073748922 argumentChecks@var2301 ;
1290: for (@expr1073748923 std ::@expr7093 map < int , Library ::@expr7093 ArgumentChecks > ::@expr7093 const_iterator i@var2157 =@expr1073748927 argumentChecksFunc@var2156 .@expr1073748928 cbegin (@expr1073748929 ) ; i@var2157 !=@expr1073748930 argumentChecksFunc@var2156 .@expr1073748931 cend (@expr1073748932 ) ; ++@expr1073748933 i@var2157 ) {
1291: if (@expr1073748934 i@var2157 .@expr1073748935 second@var2158 .@expr1073748936 formatstr@var2159 ) {
1292: return i@var2157 .@expr1073748937 first@var2160 -@expr1073748938 1 ;
1293: }
1294: }
1295: return -1 ;
1296: }
1297:
1298: bool Library :: formatstr_scan ( const Token * ftok@var2161 ) const
1299: {
1300: return functions@var299 .@expr1073748939 at (@expr1073748940 getFunctionName (@expr1073748941 ftok@var2161 ) ) .@expr1073748942 formatstr_scan@var2302 ;
1301: }
1302:
1303: bool Library :: formatstr_secure ( const Token * ftok@var2162 ) const
1304: {
1305: return functions@var299 .@expr1073748943 at (@expr1073748944 getFunctionName (@expr1073748945 ftok@var2162 ) ) .@expr1073748946 formatstr_secure@var2303 ;
1306: }
1307:
1308: const Library :: NonOverlappingData * Library :: getNonOverlappingData ( const Token * ftok@var2163 ) const
1309: {
1310: if (@expr1073748947 isNotLibraryFunction (@expr1073748948 ftok@var2163 ) ) {
1311: return nullptr ; }
1312: const std ::@expr1073748949 unordered_map < std ::@expr1073748950 string , NonOverlappingData > ::@expr1073748951 const_iterator it@var2164 =@expr1073748952 mNonOverlappingData@var463 .@expr1073748953 find (@expr1073748954 getFunctionName (@expr1073748955 ftok@var2163 ) ) ;
1313: return (@expr1073748956 it@var2164 !=@expr1073748957 mNonOverlappingData@var463 .@expr1073748958 cend (@expr1073748959 ) ) ?@expr1073748960 &@expr1073748961 it@var2164 .@expr1073748962 second@var2165 :@expr1073748963 nullptr ;
1314: }
1315:
1316: Library :: UseRetValType Library :: getUseRetValType ( const Token * ftok@var2166 ) const
1317: {
1318: if (@expr1073748964 isNotLibraryFunction (@expr1073748965 ftok@var2166 ) ) {
1319: return Library ::@expr7142 UseRetValType ::@expr7143 NONE ; }
1320: const std ::@expr1073748968 unordered_map < std ::@expr1073748969 string , Function > ::@expr1073748970 const_iterator it@var2167 =@expr1073748971 functions@var299 .@expr1073748972 find (@expr1073748973 getFunctionName (@expr1073748974 ftok@var2166 ) ) ;
1321: if (@expr1073748975 it@var2167 !=@expr1073748976 functions@var299 .@expr1073748977 cend (@expr1073748978 ) ) {
1322: return it@var2167 .@expr1073748979 second@var2168 .@expr1073748980 useretval@var2169 ; }
1323: return Library ::@expr7142 UseRetValType ::@expr7143 NONE ;
1324: }
1325:
1326: const std :: string & Library :: returnValue ( const Token * ftok@var2170 ) const
1327: {
1328: if (@expr1073748983 isNotLibraryFunction (@expr1073748984 ftok@var2170 ) ) {
1329: return emptyString@var1 ; }
1330: const std ::@expr1073748985 map < std ::@expr7162 string , std ::@expr7162 string > ::@expr1073748988 const_iterator it@var2171 =@expr1073748989 mReturnValue@var447 .@expr1073748990 find (@expr1073748991 getFunctionName (@expr1073748992 ftok@var2170 ) ) ;
1331: return it@var2171 !=@expr1073748993 mReturnValue@var447 .@expr1073748994 end (@expr1073748995 ) ?@expr1073748996 it@var2171 .@expr1073748997 second@var2172 :@expr1073748998 emptyString@var1 ;
1332: }
1333:
1334: const std :: string & Library :: returnValueType ( const Token * ftok@var2173 ) const
1335: {
1336: if (@expr1073748999 isNotLibraryFunction (@expr1073749000 ftok@var2173 ) ) {
1337: return emptyString@var1 ; }
1338: const std ::@expr1073749001 map < std ::@expr7178 string , std ::@expr7178 string > ::@expr1073749004 const_iterator it@var2174 =@expr1073749005 mReturnValueType@var448 .@expr1073749006 find (@expr1073749007 getFunctionName (@expr1073749008 ftok@var2173 ) ) ;
1339: return it@var2174 !=@expr1073749009 mReturnValueType@var448 .@expr1073749010 end (@expr1073749011 ) ?@expr1073749012 it@var2174 .@expr1073749013 second@var2175 :@expr1073749014 emptyString@var1 ;
1340: }
1341:
1342: int Library :: returnValueContainer ( const Token * ftok@var2176 ) const
1343: {
1344: if (@expr1073749015 isNotLibraryFunction (@expr1073749016 ftok@var2176 ) ) {
1345: return -1 ; }
1346: const std ::@expr1073749017 map < std ::@expr1073749018 string , int > ::@expr1073749019 const_iterator it@var2177 =@expr1073749020 mReturnValueContainer@var449 .@expr1073749021 find (@expr1073749022 getFunctionName (@expr1073749023 ftok@var2176 ) ) ;
1347: return it@var2177 !=@expr1073749024 mReturnValueContainer@var449 .@expr1073749025 end (@expr1073749026 ) ?@expr1073749027 it@var2177 .@expr1073749028 second@var2178 :@expr1073749029 -1 ;
1348: }
1349:
1350: std :: vector < long long > Library :: unknownReturnValues ( const Token * ftok@var2179 ) const
1351: {
1352: if (@expr1073749030 isNotLibraryFunction (@expr1073749031 ftok@var2179 ) ) {
1353: return std ::@expr7208 vector < long long > (@expr7209 ) ; }
1354: const std ::@expr1073749034 map < std ::@expr7211 string , std ::@expr7211 vector < long long > > ::@expr1073749037 const_iterator it@var2180 =@expr1073749038 mUnknownReturnValues@var450 .@expr1073749039 find (@expr1073749040 getFunctionName (@expr1073749041 ftok@var2179 ) ) ;
1355: return (@expr7218 it@var2180 ==@expr1073749043 mUnknownReturnValues@var450 .@expr1073749044 end (@expr1073749045 ) ) ?@expr1073749046 (@expr7218 std ::@expr7208 vector < long long > (@expr7209 ) ) :@expr1073749050 it@var2180 .@expr1073749051 second@var2181 ;
1356: }
1357:
1358: const Library :: Function * Library :: getFunction ( const Token * ftok@var2182 ) const
1359: {
1360: if (@expr1073749052 isNotLibraryFunction (@expr1073749053 ftok@var2182 ) ) {
1361: return nullptr ; }
1362: const std ::@expr1073749054 unordered_map < std ::@expr1073749055 string , Function > ::@expr1073749056 const_iterator it1@var2183 =@expr1073749057 functions@var299 .@expr1073749058 find (@expr1073749059 getFunctionName (@expr1073749060 ftok@var2182 ) ) ;
1363: if (@expr1073749061 it1@var2183 ==@expr1073749062 functions@var299 .@expr1073749063 cend (@expr1073749064 ) ) {
1364: return nullptr ; }
1365: return &@expr1073749065 it1@var2183 .@expr1073749066 second@var2184 ;
1366: }
1367:
1368:
1369: bool Library :: hasminsize ( const Token * ftok@var2185 ) const
1370: {
1371: if (@expr1073749067 isNotLibraryFunction (@expr1073749068 ftok@var2185 ) ) {
1372: return false ; }
1373: const std ::@expr1073749069 unordered_map < std ::@expr7246 string , Function > ::@expr1073749071 const_iterator it1@var2186 =@expr1073749072 functions@var299 .@expr1073749073 find (@expr1073749074 getFunctionName (@expr1073749075 ftok@var2185 ) ) ;
1374: if (@expr1073749076 it1@var2186 ==@expr1073749077 functions@var299 .@expr1073749078 cend (@expr1073749079 ) ) {
1375: return false ; }
1376: for (@expr1073749080 std ::@expr7246 map < int , ArgumentChecks > ::@expr7246 const_iterator it2@var2187 =@expr1073749083 it1@var2186 .@expr7260 second@var2188 .@expr7261 argumentChecks@var2189 .@expr1073749086 cbegin (@expr1073749087 ) ; it2@var2187 !=@expr1073749088 it1@var2186 .@expr7260 second@var2188 .@expr7261 argumentChecks@var2189 .@expr1073749091 cend (@expr1073749092 ) ; ++@expr1073749093 it2@var2187 ) {
1377: if (@expr1073749094 !@expr1073749095 it2@var2187 .@expr1073749096 second@var2190 .@expr1073749097 minsizes@var2191 .@expr1073749098 empty (@expr1073749099 ) ) {
1378: return true ; }
1379: }
1380: return false ;
1381: }
1382:
1383: Library :: ArgumentChecks :: Direction Library :: getArgDirection ( const Token * ftok@var2192 , int argnr@var2193 ) const
1384: {
1385: const ArgumentChecks * arg@var2194 ; arg@var2194 =@expr1073749103 getarg (@expr1073749104 ftok@var2192 , argnr@var2193 ) ;
1386: if (@expr1073749105 arg@var2194 ) {
1387: return arg@var2194 .@expr1073749106 direction@var2195 ; }
1388: if (@expr1073749107 formatstr_function (@expr1073749108 ftok@var2192 ) ) {
1389: const int fs_argno@var2196 =@expr1073749109 formatstr_argno (@expr1073749110 ftok@var2192 ) ;
1390: if (@expr1073749111 fs_argno@var2196 >=@expr1073749112 0 &&@expr1073749113 argnr@var2193 >=@expr1073749114 fs_argno@var2196 ) {
1391: if (@expr1073749115 formatstr_scan (@expr1073749116 ftok@var2192 ) ) {
1392: return ArgumentChecks ::@expr7293 Direction ::@expr1073749118 DIR_OUT@expr1073749100 ; }
1393: else {
1394: return ArgumentChecks ::@expr7293 Direction ::@expr1073749120 DIR_IN@expr1073749101 ; }
1395: }
1396: }
1397: return ArgumentChecks ::@expr7293 Direction ::@expr1073749122 DIR_UNKNOWN@expr1073749102 ;
1398: }
1399:
1400: bool Library :: ignorefunction ( const std :: string & functionName@var2197 ) const
1401: {
1402: const std ::@expr1073749123 unordered_map < std ::@expr1073749124 string , Function > ::@expr1073749125 const_iterator it@var2198 =@expr1073749126 functions@var299 .@expr1073749127 find (@expr1073749128 functionName@var2197 ) ;
1403: if (@expr1073749129 it@var2198 !=@expr1073749130 functions@var299 .@expr1073749131 cend (@expr1073749132 ) ) {
1404: return it@var2198 .@expr1073749133 second@var2199 .@expr1073749134 ignore@var2200 ; }
1405: return false ;
1406: }
1407: bool Library :: isUse ( const std :: string & functionName@var2201 ) const
1408: {
1409: const std ::@expr1073749135 unordered_map < std ::@expr1073749136 string , Function > ::@expr1073749137 const_iterator it@var2202 =@expr1073749138 functions@var299 .@expr1073749139 find (@expr1073749140 functionName@var2201 ) ;
1410: if (@expr1073749141 it@var2202 !=@expr1073749142 functions@var299 .@expr1073749143 cend (@expr1073749144 ) ) {
1411: return it@var2202 .@expr1073749145 second@var2203 .@expr1073749146 use@var2204 ; }
1412: return false ;
1413: }
1414: bool Library :: isLeakIgnore ( const std :: string & functionName@var2205 ) const
1415: {
1416: const std ::@expr1073749147 unordered_map < std ::@expr1073749148 string , Function > ::@expr1073749149 const_iterator it@var2206 =@expr1073749150 functions@var299 .@expr1073749151 find (@expr1073749152 functionName@var2205 ) ;
1417: if (@expr1073749153 it@var2206 !=@expr1073749154 functions@var299 .@expr1073749155 cend (@expr1073749156 ) ) {
1418: return it@var2206 .@expr1073749157 second@var2207 .@expr1073749158 leakignore@var2208 ; }
1419: return false ;
1420: }
1421: bool Library :: isFunctionConst ( const std :: string & functionName@var2209 , bool pure@var2210 ) const
1422: {
1423: const std ::@expr1073749159 unordered_map < std ::@expr1073749160 string , Function > ::@expr1073749161 const_iterator it@var2211 =@expr1073749162 functions@var299 .@expr1073749163 find (@expr1073749164 functionName@var2209 ) ;
1424: if (@expr1073749165 it@var2211 !=@expr1073749166 functions@var299 .@expr1073749167 cend (@expr1073749168 ) ) {
1425: return pure@var2210 ?@expr1073749169 it@var2211 .@expr7346 second@var2212 .@expr1073749171 ispure@var2213 :@expr1073749172 it@var2211 .@expr7346 second@var2212 .@expr1073749174 isconst@var2214 ; }
1426: return false ;
1427: }
1428: bool Library :: isFunctionConst ( const Token * ftok@var2215 ) const
1429: {
1430: if (@expr1073749175 ftok@var2215 .@expr7352 function (@expr7353 ) &&@expr1073749178 ftok@var2215 .@expr7352 function (@expr7353 ) .@expr1073749181 isConst (@expr1073749182 ) ) {
1431: return true ; }
1432: if (@expr1073749183 isNotLibraryFunction (@expr1073749184 ftok@var2215 ) ) {
1433: return false ; }
1434: const std ::@expr1073749185 unordered_map < std ::@expr1073749186 string , Function > ::@expr1073749187 const_iterator it@var2216 =@expr1073749188 functions@var299 .@expr1073749189 find (@expr1073749190 getFunctionName (@expr1073749191 ftok@var2215 ) ) ;
1435: return (@expr1073749192 it@var2216 !=@expr1073749193 functions@var299 .@expr1073749194 end (@expr1073749195 ) &&@expr1073749196 it@var2216 .@expr1073749197 second@var2217 .@expr1073749198 isconst@var2218 ) ;
1436: }
1437:
1438: bool Library :: isnoreturn ( const Token * ftok@var2219 ) const
1439: {
1440: if (@expr1073749201 ftok@var2219 .@expr7378 function (@expr7379 ) &&@expr1073749204 ftok@var2219 .@expr7378 function (@expr7379 ) .@expr1073749207 isAttributeNoreturn (@expr1073749208 ) ) {
1441: return true ; }
1442: if (@expr1073749209 isNotLibraryFunction (@expr1073749210 ftok@var2219 ) ) {
1443: return false ; }
1444: const std ::@expr1073749211 unordered_map < std ::@expr1073749212 string , FalseTrueMaybe > ::@expr1073749213 const_iterator it@var2220 =@expr1073749214 mNoReturn@var446 .@expr1073749215 find (@expr1073749216 getFunctionName (@expr1073749217 ftok@var2219 ) ) ;
1445: if (@expr1073749218 it@var2220 ==@expr1073749219 mNoReturn@var446 .@expr1073749220 end (@expr1073749221 ) ) {
1446: return false ; }
1447: if (@expr1073749222 it@var2220 .@expr7399 second@var2221 ==@expr1073749224 FalseTrueMaybe ::@expr1073749225 Maybe@expr1073749199 ) {
1448: return true ; }
1449: return it@var2220 .@expr7399 second@var2221 ==@expr1073749227 FalseTrueMaybe ::@expr1073749228 True@expr1073749200 ;
1450: }
1451:
1452: bool Library :: isnotnoreturn ( const Token * ftok@var2222 ) const
1453: {
1454: if (@expr1073749231 ftok@var2222 .@expr7408 function (@expr7409 ) &&@expr1073749234 ftok@var2222 .@expr7408 function (@expr7409 ) .@expr1073749237 isAttributeNoreturn (@expr1073749238 ) ) {
1455: return false ; }
1456: if (@expr1073749239 isNotLibraryFunction (@expr1073749240 ftok@var2222 ) ) {
1457: return false ; }
1458: const std ::@expr1073749241 unordered_map < std ::@expr1073749242 string , FalseTrueMaybe > ::@expr1073749243 const_iterator it@var2223 =@expr1073749244 mNoReturn@var446 .@expr1073749245 find (@expr1073749246 getFunctionName (@expr1073749247 ftok@var2222 ) ) ;
1459: if (@expr1073749248 it@var2223 ==@expr1073749249 mNoReturn@var446 .@expr1073749250 end (@expr1073749251 ) ) {
1460: return false ; }
1461: if (@expr1073749252 it@var2223 .@expr7429 second@var2224 ==@expr1073749254 FalseTrueMaybe ::@expr1073749255 Maybe@expr1073749229 ) {
1462: return false ; }
1463: return it@var2223 .@expr7429 second@var2224 ==@expr1073749257 FalseTrueMaybe ::@expr1073749258 False@expr1073749230 ;
1464: }
1465:
1466: bool Library :: markupFile ( const std :: string & path@var2225 ) const
1467: {
1468: return mMarkupExtensions@var453 .@expr1073749259 find (@expr1073749260 Path ::@expr1073749261 getFilenameExtensionInLowerCase (@expr1073749262 path@var2225 ) ) !=@expr1073749263 mMarkupExtensions@var453 .@expr1073749264 end (@expr1073749265 ) ;
1469: }
1470:
1471: bool Library :: processMarkupAfterCode ( const std :: string & path@var2226 ) const
1472: {
1473: const std ::@expr1073749266 map < std ::@expr1073749267 string , bool > ::@expr1073749268 const_iterator it@var2227 =@expr1073749269 mProcessAfterCode@var452 .@expr1073749270 find (@expr1073749271 Path ::@expr1073749272 getFilenameExtensionInLowerCase (@expr1073749273 path@var2226 ) ) ;
1474: return (@expr1073749274 it@var2227 ==@expr1073749275 mProcessAfterCode@var452 .@expr1073749276 end (@expr1073749277 ) ||@expr1073749278 it@var2227 .@expr1073749279 second@var2228 ) ;
1475: }
1476:
1477: bool Library :: reportErrors ( const std :: string & path@var2229 ) const
1478: {
1479: const std ::@expr1073749280 map < std ::@expr1073749281 string , bool > ::@expr1073749282 const_iterator it@var2230 =@expr1073749283 mReportErrors@var451 .@expr1073749284 find (@expr1073749285 Path ::@expr1073749286 getFilenameExtensionInLowerCase (@expr1073749287 path@var2229 ) ) ;
1480: return (@expr1073749288 it@var2230 ==@expr1073749289 mReportErrors@var451 .@expr1073749290 end (@expr1073749291 ) ||@expr1073749292 it@var2230 .@expr1073749293 second@var2231 ) ;
1481: }
1482:
1483: bool Library :: isexecutableblock ( const std :: string & file@var2232 , const std :: string & token@var2233 ) const
1484: {
1485: const std ::@expr1073749294 map < std ::@expr1073749295 string , CodeBlock > ::@expr1073749296 const_iterator it@var2234 =@expr1073749297 mExecutableBlocks@var455 .@expr1073749298 find (@expr1073749299 Path ::@expr1073749300 getFilenameExtensionInLowerCase (@expr1073749301 file@var2232 ) ) ;
1486: return (@expr1073749302 it@var2234 !=@expr1073749303 mExecutableBlocks@var455 .@expr1073749304 end (@expr1073749305 ) &&@expr1073749306 it@var2234 .@expr1073749307 second@var2235 .@expr1073749308 isBlock (@expr1073749309 token@var2233 ) ) ;
1487: }
1488:
1489: int Library :: blockstartoffset ( const std :: string & file@var2236 ) const
1490: {
1491: int offset@var2237 ; offset@var2237 =@expr1073749310 -1 ;
1492: const std ::@expr1073749311 map < std ::@expr1073749312 string , CodeBlock > ::@expr1073749313 const_iterator map_it@var2238
1493: =@expr1073749314 mExecutableBlocks@var455 .@expr1073749315 find (@expr1073749316 Path ::@expr1073749317 getFilenameExtensionInLowerCase (@expr1073749318 file@var2236 ) ) ;
1494:
1495: if (@expr1073749319 map_it@var2238 !=@expr1073749320 mExecutableBlocks@var455 .@expr1073749321 end (@expr1073749322 ) ) {
1496: offset@var2237 =@expr1073749323 map_it@var2238 .@expr1073749324 second@var2239 .@expr1073749325 offset (@expr1073749326 ) ;
1497: }
1498: return offset@var2237 ;
1499: }
1500:
1501: const std :: string & Library :: blockstart ( const std :: string & file@var2240 ) const
1502: {
1503: const std ::@expr1073749327 map < std ::@expr1073749328 string , CodeBlock > ::@expr1073749329 const_iterator map_it@var2241
1504: =@expr1073749330 mExecutableBlocks@var455 .@expr1073749331 find (@expr1073749332 Path ::@expr1073749333 getFilenameExtensionInLowerCase (@expr1073749334 file@var2240 ) ) ;
1505:
1506: if (@expr1073749335 map_it@var2241 !=@expr1073749336 mExecutableBlocks@var455 .@expr1073749337 end (@expr1073749338 ) ) {
1507: return map_it@var2241 .@expr1073749339 second@var2242 .@expr1073749340 start (@expr1073749341 ) ;
1508: }
1509: return emptyString@var1 ;
1510: }
1511:
1512: const std :: string & Library :: blockend ( const std :: string & file@var2243 ) const
1513: {
1514: const std ::@expr1073749342 map < std ::@expr1073749343 string , CodeBlock > ::@expr1073749344 const_iterator map_it@var2244
1515: =@expr1073749345 mExecutableBlocks@var455 .@expr1073749346 find (@expr1073749347 Path ::@expr1073749348 getFilenameExtensionInLowerCase (@expr1073749349 file@var2243 ) ) ;
1516:
1517: if (@expr1073749350 map_it@var2244 !=@expr1073749351 mExecutableBlocks@var455 .@expr1073749352 end (@expr1073749353 ) ) {
1518: return map_it@var2244 .@expr1073749354 second@var2245 .@expr1073749355 end (@expr1073749356 ) ;
1519: }
1520: return emptyString@var1 ;
1521: }
1522:
1523: bool Library :: iskeyword ( const std :: string & file@var2246 , const std :: string & keyword@var2247 ) const
1524: {
1525: const std ::@expr1073749357 map < std ::@expr7534 string , std ::@expr7534 set < std ::@expr7534 string > > ::@expr1073749361 const_iterator it@var2248 =@expr1073749362
1526: mKeywords@var454 .@expr1073749363 find (@expr1073749364 Path ::@expr1073749365 getFilenameExtensionInLowerCase (@expr1073749366 file@var2246 ) ) ;
1527: return (@expr1073749367 it@var2248 !=@expr1073749368 mKeywords@var454 .@expr1073749369 end (@expr1073749370 ) &&@expr1073749371 it@var2248 .@expr1073749372 second@var2249 .@expr1073749373 count (@expr1073749374 keyword@var2247 ) ) ;
1528: }
1529:
1530: bool Library :: isimporter ( const std :: string & file@var2250 , const std :: string & importer@var2251 ) const
1531: {
1532: const std ::@expr1073749375 map < std ::@expr7552 string , std ::@expr7552 set < std ::@expr7552 string > > ::@expr1073749379 const_iterator it@var2252 =@expr1073749380
1533: mImporters@var457 .@expr1073749381 find (@expr1073749382 Path ::@expr1073749383 getFilenameExtensionInLowerCase (@expr1073749384 file@var2250 ) ) ;
1534: return (@expr1073749385 it@var2252 !=@expr1073749386 mImporters@var457 .@expr1073749387 end (@expr1073749388 ) &&@expr1073749389 it@var2252 .@expr1073749390 second@var2253 .@expr1073749391 count (@expr1073749392 importer@var2251 ) >@expr1073749393 0 ) ;
1535: }
1536:
1537: const Token * Library :: getContainerFromYield ( const Token * tok@var2254 , Library :: Container :: Yield yield@var2255 ) const
1538: {
1539: if (@expr1073749396 !@expr1073749397 tok@var2254 ) {
1540: return nullptr ; }
1541: if (@expr1073749398 Token ::@expr7575 Match (@expr1073749400 tok@var2254 .@expr7577 tokAt (@expr7578 -2 ) , ". %name% (" ) ) {
1542: const Token * containerTok@var2256 ; containerTok@var2256 =@expr1073749403 tok@var2254 .@expr7577 tokAt (@expr7578 -2 ) .@expr1073749406 astOperand1 (@expr1073749407 ) ;
1543: if (@expr1073749408 !@expr1073749409 astIsContainer (@expr1073749410 containerTok@var2256 ) ) {
1544: return nullptr ; }
1545: if (@expr1073749411 containerTok@var2256 .@expr7588 valueType (@expr7589 ) .@expr7590 container@var2304 &&@expr1073749415
1546: containerTok@var2256 .@expr7588 valueType (@expr7589 ) .@expr7590 container@var2304 .@expr1073749419 getYield (@expr1073749420 tok@var2254 .@expr1073749421 strAt (@expr1073749422 -1 ) ) ==@expr1073749423 yield@var2255 ) {
1547: return containerTok@var2256 ; }
1548: if (@expr1073749424 yield@var2255 ==@expr1073749425 Library ::@expr7602 Container ::@expr7603 Yield ::@expr1073749428 EMPTY@expr1073749394 &&@expr1073749429 Token ::@expr1073749430 simpleMatch (@expr1073749431 tok@var2254 .@expr7577 tokAt (@expr7609 -1 ) , "empty ( )" ) ) {
1549: return containerTok@var2256 ; }
1550: if (@expr1073749434 yield@var2255 ==@expr1073749435 Library ::@expr7602 Container ::@expr7603 Yield ::@expr1073749438 SIZE@expr1073749395 &&@expr1073749439 Token ::@expr7575 Match (@expr1073749441 tok@var2254 .@expr7577 tokAt (@expr7609 -1 ) , "size|length ( )" ) ) {
1551: return containerTok@var2256 ; }
1552: } else { if (@expr1073749444 Token ::@expr7575 Match (@expr1073749446 tok@var2254 .@expr7623 previous (@expr7624 ) , "%name% (" ) ) {
1553: if (@expr1073749449 const Library ::@expr1073749450 Function *@expr1073749451 f@var2257 =@expr1073749452 this@expr1073749453 .@expr1073749454 getFunction (@expr1073749455 tok@var2254 .@expr7623 previous (@expr7624 ) ) ) {
1554: if (@expr1073749458 f@var2257 .@expr1073749459 containerYield@var2258 ==@expr1073749460 yield@var2255 ) {
1555: return tok@var2254 .@expr1073749461 astOperand2 (@expr1073749462 ) ;
1556: }
1557: }
1558: } }
1559: return nullptr ;
1560: }
1561:
1562:
1563: const Token * Library :: getContainerFromAction ( const Token * tok@var2259 , Library :: Container :: Action action@var2260 ) const
1564: {
1565: if (@expr1073749463 !@expr1073749464 tok@var2259 ) {
1566: return nullptr ; }
1567: if (@expr1073749465 Token ::@expr7642 Match (@expr1073749467 tok@var2259 .@expr7644 tokAt (@expr7645 -2 ) , ". %name% (" ) ) {
1568: const Token * containerTok@var2261 ; containerTok@var2261 =@expr1073749470 tok@var2259 .@expr7644 tokAt (@expr7645 -2 ) .@expr1073749473 astOperand1 (@expr1073749474 ) ;
1569: if (@expr1073749475 !@expr1073749476 astIsContainer (@expr1073749477 containerTok@var2261 ) ) {
1570: return nullptr ; }
1571: if (@expr1073749478 containerTok@var2261 .@expr7655 valueType (@expr7656 ) .@expr7657 container@var2304 &&@expr1073749482
1572: containerTok@var2261 .@expr7655 valueType (@expr7656 ) .@expr7657 container@var2304 .@expr1073749486 getAction (@expr1073749487 tok@var2259 .@expr1073749488 strAt (@expr1073749489 -1 ) ) ==@expr1073749490 action@var2260 ) {
1573: return containerTok@var2261 ; }
1574: if (@expr1073749491 Token ::@expr1073749492 simpleMatch (@expr1073749493 tok@var2259 .@expr7644 tokAt (@expr1073749495 -1 ) , "empty ( )" ) ) {
1575: return containerTok@var2261 ; }
1576: } else { if (@expr1073749496 Token ::@expr7642 Match (@expr1073749498 tok@var2259 .@expr7675 previous (@expr7676 ) , "%name% (" ) ) {
1577: if (@expr1073749501 const Library ::@expr1073749502 Function *@expr1073749503 f@var2262 =@expr1073749504 this@expr1073749505 .@expr1073749506 getFunction (@expr1073749507 tok@var2259 .@expr7675 previous (@expr7676 ) ) ) {
1578: if (@expr1073749510 f@var2262 .@expr1073749511 containerAction@var2263 ==@expr1073749512 action@var2260 ) {
1579: return tok@var2259 .@expr1073749513 astOperand2 (@expr1073749514 ) ;
1580: }
1581: }
1582: } }
1583: return nullptr ;
1584: }
1585:
1586: bool Library :: isSmartPointer ( const Token * tok@var2264 ) const
1587: {
1588: return detectSmartPointer (@expr1073749515 tok@var2264 ) ;
1589: }
1590:
1591: const Library :: SmartPointer * Library :: detectSmartPointer ( const Token * tok@var2265 ) const
1592: {
1593: std ::@expr1073749516 string typestr@var2266 ;
1594: while (@expr1073749517 Token ::@expr1073749518 Match (@expr1073749519 tok@var2265 , "%name%|::" ) ) {
1595: typestr@var2266 +=@expr1073749520 tok@var2265 .@expr1073749521 str (@expr1073749522 ) ;
1596: tok@var2265 =@expr1073749523 tok@var2265 .@expr1073749524 next (@expr1073749525 ) ;
1597: }
1598: auto it@var2267 ; it@var2267 =@expr1073749526 smartPointers@var381 .@expr1073749527 find (@expr1073749528 typestr@var2266 ) ;
1599: if (@expr1073749529 it@var2267 ==@expr1073749530 smartPointers@var381 .@expr1073749531 end (@expr1073749532 ) ) {
1600: return nullptr ; }
1601: return &@expr1073749533 it@var2267 .@expr1073749534 second@var2268 ;
1602: }
1603:
1604: const Library :: Container * getLibraryContainer ( const Token * tok@var2269 )
1605: {
1606: if (@expr1073749535 !@expr1073749536 tok@var2269 ) {
1607: return nullptr ; }
1608:
1609:
1610: if (@expr1073749537 tok@var2269 .@expr1073749538 isUnaryOp (@expr1073749539 "*" ) &&@expr1073749540 astIsPointer (@expr1073749541 tok@var2269 .@expr7718 astOperand1 (@expr7719 ) ) ) {
1611: for (@expr1073749544 const ValueFlow ::@expr1073749545 Value &@expr1073749546 v@var2270 :@expr1073749547 tok@var2269 .@expr7718 astOperand1 (@expr7719 ) .@expr1073749550 values (@expr1073749551 ) ) {
1612: if (@expr1073749552 !@expr1073749553 v@var2270 .@expr1073749554 isLocalLifetimeValue (@expr1073749555 ) ) {
1613: continue ; }
1614: if (@expr1073749556 v@var2270 .@expr1073749557 lifetimeKind@var2271 !=@expr1073749558 ValueFlow ::@expr1073749559 Value ::@expr1073749560 LifetimeKind ::@expr1073749561 Address ) {
1615: continue ; }
1616: return getLibraryContainer (@expr1073749562 v@var2270 .@expr1073749563 tokvalue@var2272 ) ;
1617: }
1618: }
1619: if (@expr1073749564 !@expr1073749565 tok@var2269 .@expr7742 valueType (@expr7743 ) ) {
1620: return nullptr ; }
1621: return tok@var2269 .@expr7742 valueType (@expr7743 ) .@expr1073749570 container@var2304 ;
1622: }
1623:
1624: Library :: TypeCheck Library :: getTypeCheck ( const std :: string & check@var2273 , const std :: string & typeName@var2274 ) const
1625: {
1626: auto it@var2275 ; it@var2275 =@expr1073749571 mTypeChecks@var462 .@expr1073749572 find (@expr1073749573 std ::@expr1073749574 pair < std ::@expr7751 string , std ::@expr7751 string > (@expr1073749577 check@var2273 , typeName@var2274 ) ) ;
1627: return it@var2275 ==@expr1073749578 mTypeChecks@var462 .@expr1073749579 end (@expr1073749580 ) ?@expr1073749581 TypeCheck ::@expr1073749582 def :@expr1073749583 it@var2275 .@expr1073749584 second@var2276 ;
1628: }
1629:
1630: std :: shared_ptr < Token > createTokenFromExpression ( const std :: string & returnValue@var2277 ,
1631: const Settings * settings@var2278 ,
1632: std :: unordered_map < int , const Token * > * lookupVarId@var2279 )
1633: {
1634: std ::@expr1073749585 shared_ptr < TokenList > tokenList@var2280 ; tokenList@var2280 =@expr1073749586 std ::@expr1073749587 make_shared < TokenList > (@expr1073749588 settings@var2278 ) ;
1635: {
1636: const std ::@expr1073749589 string code@var2281 =@expr1073749590 "return " +@expr1073749591 returnValue@var2277 +@expr1073749592 ";" ;
1637: std ::@expr1073749593 istringstream istr@var2282 (@expr1073749594 code@var2281 ) ;
1638: if (@expr1073749595 !@expr1073749596 tokenList@var2280 .@expr1073749597 createTokens (@expr1073749598 istr@var2282 ) ) {
1639: return nullptr ; }
1640: }
1641:
1642:
1643: std ::@expr1073749599 stack < Token *@expr7776 > lpar@var2283 ;
1644: for (@expr1073749601 Token *@expr7776 tok2@var2284 =@expr1073749603 tokenList@var2280 .@expr7780 front (@expr7781 ) ; tok2@var2284 ; tok2@var2284 =@expr1073749606 tok2@var2284 .@expr1073749607 next (@expr1073749608 ) ) {
1645: if (@expr1073749609 Token ::@expr1073749610 Match (@expr1073749611 tok2@var2284 , "[!<>=] =" ) ) {
1646: tok2@var2284 .@expr7788 str (@expr1073749613 tok2@var2284 .@expr7788 str (@expr7791 ) +@expr1073749616 "=" ) ;
1647: tok2@var2284 .@expr1073749617 deleteNext (@expr1073749618 ) ;
1648: } else { if (@expr1073749619 tok2@var2284 .@expr7788 str (@expr7791 ) ==@expr1073749622 "(" ) {
1649: lpar@var2283 .@expr1073749623 push (@expr1073749624 tok2@var2284 ) ; }
1650: else { if (@expr1073749625 tok2@var2284 .@expr7788 str (@expr7791 ) ==@expr1073749628 ")" ) {
1651: if (@expr1073749629 lpar@var2283 .@expr7806 empty (@expr7807 ) ) {
1652: return nullptr ; }
1653: Token ::@expr1073749632 createMutualLinks (@expr1073749633 lpar@var2283 .@expr1073749634 top (@expr1073749635 ) , tok2@var2284 ) ;
1654: lpar@var2283 .@expr1073749636 pop (@expr1073749637 ) ;
1655: } } }
1656: }
1657: if (@expr1073749638 !@expr1073749639 lpar@var2283 .@expr7806 empty (@expr7807 ) ) {
1658: return nullptr ; }
1659:
1660:
1661: for (@expr1073749642 Token *@expr7776 tok2@var2285 =@expr1073749644 tokenList@var2280 .@expr7780 front (@expr7781 ) ; tok2@var2285 ; tok2@var2285 =@expr1073749647 tok2@var2285 .@expr1073749648 next (@expr1073749649 ) ) {
1662: if (@expr1073749650 tok2@var2285 .@expr7827 str (@expr7828 ) .@expr1073749653 compare (@expr1073749654 0 , 3 , "arg" ) !=@expr1073749655 0 ) {
1663: continue ; }
1664: int id@var2286 ; id@var2286 =@expr1073749656 std ::@expr1073749657 atoi (@expr1073749658 tok2@var2285 .@expr7827 str (@expr7828 ) .@expr1073749661 c_str (@expr1073749662 ) +@expr1073749663 3 ) ;
1665: tok2@var2285 .@expr1073749664 varId (@expr1073749665 id@var2286 ) ;
1666: if (@expr1073749666 lookupVarId@var2279 ) {
1667: (@expr1073749667 *@expr1073749668 lookupVarId@var2279 ) [@expr1073749669 id@var2286 ] =@expr1073749670 tok2@var2285 ; }
1668: }
1669:
1670:
1671: tokenList@var2280 .@expr1073749671 createAst (@expr1073749672 ) ;
1672: Token * expr@var2287 ; expr@var2287 =@expr1073749673 tokenList@var2280 .@expr7780 front (@expr7781 ) .@expr1073749676 astOperand1 (@expr1073749677 ) ;
1673: ValueFlow ::@expr1073749678 valueFlowConstantFoldAST (@expr1073749679 expr@var2287 , settings@var2278 ) ;
1674: return {@expr1073749680 tokenList@var2280 , expr@var2287 } ;
1675: }



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {47@6,39@36379,34@36635}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@142,34@143}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@142,""@143,""@144,"U"@145,"U"@146,"u"@147,"u"@148,"u8"@149,"u8"@150}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@24,34@25}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@21,34@23}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 38
  C89 always 0
  C99 always 1
  C11 always 2
  CLatest always 2
  = always 2
  C11 always 2
Line 41
  CPP03 always 0
  CPP11 always 1
  CPP14 always 2
  CPP17 always 3
  CPP20 always 4
  CPP23 always 5
  CPPLatest always 5
  = always 5
  CPP23 always 5
Line 47
  CLatest always 2
  CPPLatest always 5
Line 49
  ( always {!<=-1,!>=2}
Line 50
  = possible size=3
  str possible size=3
Line 51
  str possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C89" always "C89"
Line 52
  = always 0
  C89 always 0
Line 53
  return always {!<=-1,!>=2}
  true always 1
Line 55
  str possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C99" always "C99"
Line 56
  = always 1
  C99 always 1
Line 57
  return always {!<=-1,!>=2}
  true always 1
Line 59
  str possible size=3
  == always {!<=-1,!>=2}
  "c11" always "c11"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "C11" always "C11"
Line 60
  = always 2
  C11 always 2
Line 61
  return always {!<=-1,!>=2}
  true always 1
Line 63
  return always {!<=-1,!>=2}
  false always 0
Line 67
  C89 always 0
Line 68
  "c89" always "c89"
Line 69
  C99 always 1
Line 70
  "c99" always "c99"
Line 71
  C11 always 2
Line 72
  "c11" always "c11"
Line 74
  "" always ""
Line 77
  std possible size=3
  == always {!<=-1,!>=2}
  "c89" always "c89"
Line 78
  :: always 0
  C89 always 0
Line 80
  std possible size=3
  == always {!<=-1,!>=2}
  "c99" always "c99"
Line 81
  :: always 1
  C99 always 1
Line 83
  == always {!<=-1,!>=2}
  "c11" always "c11"
Line 84
  :: always 2
  C11 always 2
Line 86
  :: always 2
  CLatest always 2
Line 88
  ( always {!<=-1,!>=2}
Line 92
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  stdValue possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 99
  CPP03 always 0
Line 100
  "c++03" always "c++03"
Line 101
  CPP11 always 1
Line 102
  "c++11" always "c++11"
Line 103
  CPP14 always 2
Line 104
  "c++14" always "c++14"
Line 105
  CPP17 always 3
Line 106
  "c++17" always "c++17"
Line 107
  CPP20 always 4
Line 108
  "c++20" always "c++20"
Line 109
  CPP23 always 5
Line 110
  "c++23" always "c++23"
Line 112
  "" always ""
Line 115
  std possible size=5
  == always {!<=-1,!>=2}
  "c++03" always "c++03"
Line 116
  :: always 0
  CPP03 always 0
Line 118
  std possible size=5
  == always {!<=-1,!>=2}
  "c++11" always "c++11"
Line 119
  :: always 1
  CPP11 always 1
Line 121
  std possible size=5
  == always {!<=-1,!>=2}
  "c++14" always "c++14"
Line 122
  :: always 2
  CPP14 always 2
Line 124
  std possible size=5
  == always {!<=-1,!>=2}
  "c++17" always "c++17"
Line 125
  :: always 3
  CPP17 always 3
Line 127
  std possible size=5
  == always {!<=-1,!>=2}
  "c++20" always "c++20"
Line 128
  :: always 4
  CPP20 always 4
Line 130
  == always {!<=-1,!>=2}
  "c++23" always "c++23"
Line 131
  :: always 5
  CPP23 always 5
Line 133
  :: always 5
  CPPLatest always 5
Line 58
  OK always 0
  FILE_NOT_FOUND always 1
  BAD_XML always 2
  UNKNOWN_ELEMENT always 3
  MISSING_ATTRIBUTE always 4
  BAD_ATTRIBUTE_VALUE always 5
  UNSUPPORTED_FORMAT always 6
  DUPLICATE_PLATFORM_TYPE always 7
  PLATFORM_TYPE_REDEFINED always 8
Line 62
  :: always 0
  OK always 0
Line 63
  ( possible lifetime[SubObject]=(e)
Line 65
  ( possible lifetime[SubObject]=(e)
  && always {!<=-1,!>=2}
Line 74
  ( always {!<=-1,!>=2}
Line 79
  none always 0
  malloc always 1
  calloc always 2
  strdup always 3
Line 84
  initData always {!<=-1,!>=2}
Line 118
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 124
  ? possible 0
  af always !0
  : always 0
  0 always 0
Line 138
  , always 1
  = always 1
  1 always 1
Line 141
  = possible 1
  reallocArg possible 1
Line 145
  , always {!<=-1,!>=2}
  noreturn always {!<=-1,!>=2}
Line 146
  = possible {1,0}
  noreturn always {!<=-1,!>=2}
  ? possible {1,0}
  :: always 1
  True always 1
  : always 0
  :: always 0
  False always 0
Line 149
  ( always {!<=-1,!>=2}
Line 152
  ( always {!<=-1,!>=2}
Line 153
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 155
  ( always {!<=-1,!>=2}
Line 156
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {1,0,!<=-1,!>=2}
  0 always 0
Line 160
  ( always {!<=-1,!>=2}
Line 161
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  id {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 163
  ( always {!<=-1,!>=2}
Line 164
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  . {>=1,!<=0}
  & possible {0,1}
  1 always 1
  == {0,1,!<=-1,!>=2}
  1 always 1
Line 167
  ( always {!<=-1,!>=2}
Line 169
  ( always {!<=-1,!>=2}
Line 170
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
Line 191
  ( always {!<=-1,!>=2}
Line 193
  NONE always 0
  DEFAULT always 1
  ERROR_CODE always 2
Line 201
  ( always {!<=-1,!>=2}
Line 202
  ( always {!<=-1,!>=2}
Line 204
  ( always {!<=-1,!>=2}
Line 209
  -1 always -1
Line 210
  -1 always -1
Line 211
  arrayLike_indexOp always {!<=-1,!>=2}
  false always 0
Line 212
  stdStringLike always {!<=-1,!>=2}
  false always 0
Line 213
  stdAssociativeLike always {!<=-1,!>=2}
  false always 0
Line 214
  opLessAllowed always {!<=-1,!>=2}
  true always 1
Line 215
  hasInitializerListConstructor always {!<=-1,!>=2}
  false always 0
Line 216
  unstableErase always {!<=-1,!>=2}
  false always 0
Line 217
  unstableInsert always {!<=-1,!>=2}
  false always 0
Line 218
  view always {!<=-1,!>=2}
  false always 0
Line 222
  RESIZE always 0
Line 223
  CLEAR always 1
Line 224
  PUSH always 2
Line 225
  POP always 3
Line 226
  FIND always 4
Line 227
  INSERT always 5
Line 228
  ERASE always 6
Line 229
  CHANGE_CONTENT always 7
Line 230
  CHANGE always 8
Line 231
  CHANGE_INTERNAL always 9
Line 232
  NO_ACTION always 10
Line 235
  AT_INDEX always 0
Line 236
  ITEM always 1
Line 237
  BUFFER always 2
Line 238
  BUFFER_NT always 3
Line 239
  START_ITERATOR always 4
Line 240
  END_ITERATOR always 5
Line 241
  ITERATOR always 6
Line 242
  SIZE always 7
Line 243
  EMPTY always 8
Line 244
  NO_YIELD always 9
Line 259
  arrayLike_indexOp always {!<=-1,!>=2}
Line 260
  stdStringLike always {!<=-1,!>=2}
Line 261
  stdAssociativeLike always {!<=-1,!>=2}
Line 262
  opLessAllowed always {!<=-1,!>=2}
Line 263
  hasInitializerListConstructor always {!<=-1,!>=2}
Line 264
  unstableErase always {!<=-1,!>=2}
Line 265
  unstableInsert always {!<=-1,!>=2}
Line 266
  view always {!<=-1,!>=2}
Line 269
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 270
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 271
  i always {!symbolic=(functions.end()),!end=0}
Line 272
  :: always 10
  NO_ACTION always 10
Line 276
  :: possible {symbolic=(functions.end()),end=0}
  i possible {symbolic=(functions.end()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 277
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 278
  i always {!symbolic=(functions.end()),!end=0}
Line 279
  :: always 9
  NO_YIELD always 9
Line 286
  , always 0
  = always 0
  false always 0
Line 287
  , always 0
  = always 0
  nullptr always 0
Line 292
  notbool always {!<=-1,!>=2}
  false always 0
Line 293
  notnull always {!<=-1,!>=2}
  false always 0
Line 294
  -1 always -1
Line 295
  formatstr always {!<=-1,!>=2}
  false always 0
Line 296
  strz always {!<=-1,!>=2}
  false always 0
Line 297
  optional always {!<=-1,!>=2}
  false always 0
Line 298
  variadic always {!<=-1,!>=2}
  false always 0
Line 302
  notbool always {!<=-1,!>=2}
Line 303
  notnull always {!<=-1,!>=2}
Line 305
  formatstr always {!<=-1,!>=2}
Line 306
  strz always {!<=-1,!>=2}
Line 307
  optional always {!<=-1,!>=2}
Line 308
  variadic always {!<=-1,!>=2}
Line 313
  0 always 0
  it always {!<=-1,!>=2}
  false always 0
  first always {!<=-1,!>=2}
  false always 0
  last always {!<=-1,!>=2}
  false always 0
Line 316
  it always {!<=-1,!>=2}
Line 317
  first always {!<=-1,!>=2}
Line 318
  last always {!<=-1,!>=2}
Line 324
  NONE always 0
  STRLEN always 1
  ARGVALUE always 2
  SIZEOF always 3
  MUL always 4
  VALUE always 5
Line 325
  ( possible lifetime[SubObject]=(t)
  0 always 0
  0 always 0
Line 334
  DIR_IN always 0
Line 335
  DIR_OUT always 1
Line 336
  DIR_INOUT always 2
Line 337
  DIR_UNKNOWN always 3
Line 344
  use always {!<=-1,!>=2}
Line 345
  leakignore always {!<=-1,!>=2}
Line 346
  isconst always {!<=-1,!>=2}
Line 347
  ispure always {!<=-1,!>=2}
Line 349
  ignore always {!<=-1,!>=2}
Line 350
  formatstr always {!<=-1,!>=2}
Line 351
  formatstr_scan always {!<=-1,!>=2}
Line 352
  formatstr_secure always {!<=-1,!>=2}
Line 356
  use always {!<=-1,!>=2}
  false always 0
Line 357
  leakignore always {!<=-1,!>=2}
  false always 0
Line 358
  isconst always {!<=-1,!>=2}
  false always 0
Line 359
  ispure always {!<=-1,!>=2}
  false always 0
Line 360
  :: always 0
  NONE always 0
Line 361
  ignore always {!<=-1,!>=2}
  false always 0
Line 362
  formatstr always {!<=-1,!>=2}
  false always 0
Line 363
  formatstr_scan always {!<=-1,!>=2}
  false always 0
Line 364
  formatstr_secure always {!<=-1,!>=2}
  false always 0
Line 365
  :: always 10
  NO_ACTION always 10
Line 366
  :: always 9
  NO_YIELD always 9
Line 372
  ( always {!<=-1,!>=2}
Line 373
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
Line 375
  ( always {!<=-1,!>=2}
Line 377
  ( always {!<=-1,!>=2}
Line 379
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
Line 382
  ( always {!<=-1,!>=2}
Line 383
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  nullptr always 0
Line 385
  ( always {!<=-1,!>=2}
Line 387
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
Line 390
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
Line 395
  ( always {!<=-1,!>=2}
Line 396
  ( always {!<=-1,!>=2}
Line 400
  arg always !0
Line 404
  le always 0
  lt always 1
  eq always 2
  ge always 3
  gt always 4
  range always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 414
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  & {lifetime[Address]=(arg->iteratorInfo),!0}
  arg always !0
  nullptr always 0
Line 417
  ( always {!<=-1,!>=2}
Line 421
  ? possible 0
  & {lifetime[Address]=(arg->minsizes),!0}
  arg always !0
  nullptr always 0
Line 426
  ( always {!<=-1,!>=2}
Line 428
  ( always {!<=-1,!>=2}
Line 434
  ( always {!<=-1,!>=2}
Line 436
  ( always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 447
  ( always {!<=-1,!>=2}
Line 448
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mExporters)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
Line 451
  ( always {!<=-1,!>=2}
Line 452
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 453
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 456
  ( always {!<=-1,!>=2}
Line 457
  = possible lifetime[Iterator]=(mExporters)
  ( possible lifetime[Iterator]=(mExporters)
Line 458
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExporters.end()),!end=0}
Line 461
  ( always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mReflection)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 471
  :: possible {symbolic=(mReflection.end()),end=0}
  it possible {symbolic=(mReflection.end()),end=0}
  = possible lifetime[Iterator]=(mReflection)
  ( possible lifetime[Iterator]=(mReflection)
Line 472
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReflection),end=0}
Line 473
  it always {!symbolic=(mReflection.end()),!end=0}
Line 474
  -1 always -1
Line 480
  = always ""
  "" always ""
Line 481
  unique always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 0
  false always 0
Line 485
  ( always {!<=-1,!>=2}
Line 489
  size always !<=-1
Line 491
  NO always 0
  BOOL always 1
  CHAR always 2
  SHORT always 3
  INT always 4
  LONG always 5
  LONGLONG always 6
Line 494
  = possible lifetime[Iterator]=(mPodTypes)
  ( possible lifetime[Iterator]=(mPodTypes)
Line 495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPodTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPodTypes.end()),!end=0}
  nullptr always 0
Line 500
  mSigned always {!<=-1,!>=2}
  false always 0
Line 501
  mUnsigned always {!<=-1,!>=2}
  false always 0
Line 502
  mLong always {!<=-1,!>=2}
  false always 0
Line 503
  mPointer always {!<=-1,!>=2}
  false always 0
Line 504
  mPtrPtr always {!<=-1,!>=2}
  false always 0
Line 505
  mConstPtr always {!<=-1,!>=2}
  false always 0
Line 506
  ( always {!<=-1,!>=2}
Line 507
  return always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 508
  mUnsigned always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 509
  mLong always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 510
  mPointer always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 511
  mPtrPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 512
  mConstPtr always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 513
  == always {!<=-1,!>=2}
Line 515
  ( always {!<=-1,!>=2}
Line 516
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 519
  mSigned always {!<=-1,!>=2}
Line 520
  mUnsigned always {!<=-1,!>=2}
Line 521
  mLong always {!<=-1,!>=2}
Line 522
  mPointer always {!<=-1,!>=2}
Line 523
  mPtrPtr always {!<=-1,!>=2}
Line 524
  mConstPtr always {!<=-1,!>=2}
Line 529
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 530
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 536
  :: possible {symbolic=(mPlatforms.end()),end=0}
  it possible {symbolic=(mPlatforms.end()),end=0}
  = possible lifetime[Iterator]=(mPlatforms)
  ( possible lifetime[Iterator]=(mPlatforms)
Line 537
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatforms),end=0}
Line 538
  it always {!symbolic=(mPlatforms.end()),!end=0}
Line 540
  type always !0
Line 543
  = possible lifetime[Iterator]=(mPlatformTypes)
  ( possible lifetime[Iterator]=(mPlatformTypes)
Line 544
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPlatformTypes),end=0}
  & {lifetime[Address]=(it2->second),!0}
  it2 always {!symbolic=(mPlatformTypes.end()),!end=0}
  nullptr always 0
Line 552
  ( always {!<=-1,!>=2}
  , always ""
  = always ""
  "" always ""
Line 555
  def always 0
  check always 1
  suppress always 2
Line 570
  ( always {!<=-1,!>=2}
Line 571
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mPrefixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mPrefixes),end=0}
Line 573
  ( always {!<=-1,!>=2}
Line 574
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mSuffixes)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuffixes),end=0}
Line 583
  0 always 0
Line 606
  ( always {!<=-1,!>=2}
Line 607
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mBlocks)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mBlocks),end=0}
Line 616
  False always 0
  True always 1
  Maybe always 2
Line 646
  = possible lifetime[Iterator]=(data)
  ( possible lifetime[Iterator]=(data)
Line 647
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(data),end=0}
  nullptr always 0
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(data.end()),!end=0}
Line 655
  = always 0
  nullptr always 0
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 91
  :: always 12
  INT always 12
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 121
  :: always 0
  INT always 0
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 161
  :: always 0
  INT always 0
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  INT always 0
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@232,128@233,64@234,32@235,16@236,8@237,4@238,2@239,1@240}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@241,128@242,64@243,32@244,16@245,8@246,4@247,2@248,1@249}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@241,4294967167@242,4294967231@243,4294967263@244,4294967279@245,4294967287@246,4294967291@247,4294967293@248,4294967294@249}
  flag {!<=-1,256@241,128@242,64@243,32@244,16@245,8@246,4@247,2@248,1@249}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  pattern possible {"empty ( )"@29,"empty ( )"@38,"( )"@103,"<<"@113,"("@114,") ; }"@121,"."@158}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@131,4@132,0@133}
  t possible {10@131,4@132,0@133}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@131,4@132,0@133}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@131,0@133}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@131,0@133}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@131}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@131}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@131}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@131}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@131}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  s possible {"*"@14,"&"@152}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@139}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@141,17179869184@152,8589934592@154,34359738368@156,4294967296@158,2147483648@160,1073741824@162,536870912@164,268435456@166}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@228,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@229}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@140,17179869184@151,8589934592@153,34359738368@155,4294967296@157,2147483648@159,1073741824@161,536870912@163,268435456@165}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@140,17179869184@151,8589934592@153,34359738368@155,4294967296@157,2147483648@159,1073741824@161,536870912@163,268435456@165}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 55
  Public always 0
  Protected always 1
  Private always 2
  Global always 3
  Namespace always 4
  Argument always 5
  Local always 6
  Throw always 7
Line 61
  nullptr always 0
  0 always 0
  known always {!<=-1,!>=2}
  true always 1
Line 65
  known always {!<=-1,!>=2}
Line 75
  Unknown always 0
  True always 1
  False always 2
Line 81
  nullptr always 0
  nullptr always 0
  :: always 0
  Public always 0
  isVirtual always {!<=-1,!>=2}
  false always 0
Line 87
  isVirtual always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  return always {!<=-1,!>=2}
  this always !0
  < always {!<=-1,!>=2}
Line 96
  nullptr always 0
  nullptr always 0
  nullptr always 0
Line 110
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 111
  classDef_ inconclusive 0
Line 115
  nullptr always 0
Line 116
  nullptr always 0
Line 117
  0 always 0
Line 118
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "enum" always "enum"
Line 119
  = always 1
  :: always 1
  True always 1
Line 120
  classDef_ possible 0
  && always {!<=-1,!>=2}
  classDef_ always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 121
  3 always 3
Line 123
  && always {!<=-1,!>=2}
  ( always !0
  != always {!<=-1,!>=2}
  ";" always ";"
Line 124
  = always !0
  ( always !0
Line 131
  classDef always !0
Line 134
  ( always {!<=-1,!>=2}
Line 135
  ( always {!<=-1,!>=2}
Line 136
  ( always {!<=-1,!>=2}
Line 137
  ( always {!<=-1,!>=2}
Line 139
  ( always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  classDef always !0
  == always {!<=-1,!>=2}
  "using" always "using"
Line 152
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 159
  ( always {!<=-1,!>=2}
Line 161
  ( always {!<=-1,!>=2}
Line 166
  nullptr always 0
  0 always 0
  nullptr always 0
  nullptr always 0
  value_known always {!<=-1,!>=2}
  false always 0
Line 172
  value_known always {!<=-1,!>=2}
Line 179
  fIsMutable always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 180
  fIsStatic always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 181
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 182
  fIsExtern always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 183
  fIsClass always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 184
  fIsArray always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 185
  fIsPointer always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 186
  fIsReference always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 187
  fIsRValueRef always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 188
  fHasDefault always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 189
  fIsStlType always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 190
  fIsStlString always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 191
  fIsFloatType always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 192
  fIsVolatile always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 193
  fIsSmartPointer always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 194
  fIsMaybeUnused always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 195
  fIsInit always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
Line 203
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 204
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,32768@74,4096@77,16384@80,2048@81,1024@82,65536@83,512@84,256@85,128@86}
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 213
  mFlags always !<=-1
  = always !<=-1
  state_ always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ always !<=-1
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ always !<=-1
Line 222
  ( always {!<=-1,!>=2}
Line 233
  mFlags always !<=-1
  0 always 0
  , possible lifetime[SubObject]=(type_)
Line 234
  ( possible lifetime[SubObject]=(type_)
Line 236
  nullptr always 0
Line 300
  mNameToken always !0
Line 312
  mNameToken always !0
Line 314
  0 always 0
Line 329
  ( always {!<=-1,!>=2}
Line 330
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 0
  Public always 0
Line 337
  ( always {!<=-1,!>=2}
Line 338
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Protected always 1
Line 345
  ( always {!<=-1,!>=2}
Line 346
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Private always 2
Line 353
  ( always {!<=-1,!>=2}
Line 354
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Global always 3
Line 361
  ( always {!<=-1,!>=2}
Line 362
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  Namespace always 4
Line 369
  ( always {!<=-1,!>=2}
Line 370
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  Argument always 5
Line 377
  ( always {!<=-1,!>=2}
Line 378
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 385
  ( always {!<=-1,!>=2}
Line 386
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMutable always 1
Line 393
  ( always {!<=-1,!>=2}
Line 394
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 8192
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 2
Line 409
  ( always {!<=-1,!>=2}
Line 410
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 8
Line 417
  ( always {!<=-1,!>=2}
Line 418
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  Throw always 7
Line 433
  ( always {!<=-1,!>=2}
Line 434
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 16
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 449
  ( always {!<=-1,!>=2}
Line 450
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 457
  ( always {!<=-1,!>=2}
Line 458
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
Line 465
  ( always {!<=-1,!>=2}
Line 471
  ( always {!<=-1,!>=2}
Line 472
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsArray always 32
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointer always 64
Line 479
  ( always {!<=-1,!>=2}
Line 480
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsReference always 128
Line 487
  ( always {!<=-1,!>=2}
Line 488
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRValueRef always 256
Line 495
  ( always {!<=-1,!>=2}
Line 501
  ( always {!<=-1,!>=2}
Line 502
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasDefault always 512
Line 509
  ( always {!<=-1,!>=2}
Line 510
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInit always 65536
Line 526
  ? possible 0
  mType always !0
  : always 0
  nullptr always 0
Line 557
  ( always {!<=-1,!>=2}
Line 558
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  known always {!<=-1,!>=2}
Line 569
  ( always {!<=-1,!>=2}
Line 570
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlType always 1024
Line 581
  ( always {!<=-1,!>=2}
Line 582
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStlString always 2048
Line 585
  ( always {!<=-1,!>=2}
Line 586
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSmartPointer always 16384
Line 601
  ( always {!<=-1,!>=2}
Line 602
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  2 always 2
Line 615
  ( always {!<=-1,!>=2}
Line 616
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(stlTypes)
  2 always 2
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(stlTypes),end=0}
Line 623
  ( always {!<=-1,!>=2}
Line 624
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFloatType always 4096
Line 631
  ( always {!<=-1,!>=2}
Line 632
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 635
  ( always {!<=-1,!>=2}
Line 636
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsMaybeUnused always 32768
Line 679
  mFlags always !<=-1
Line 702
  fHasBody always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 703
  fIsInline always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 704
  fIsConst always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 705
  fHasVirtualSpecifier always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 706
  fIsPure always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 707
  fIsStatic always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 708
  fIsStaticLocal always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 709
  fIsExtern always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 710
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 711
  fIsExplicit always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 712
  fIsDefault always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 713
  fIsDelete always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 714
  fHasOverrideSpecifier always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 715
  fHasFinalSpecifier always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 716
  fIsNoExcept always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 717
  fIsThrow always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 718
  fIsOperator always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 719
  fHasLvalRefQual always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 720
  fHasRvalRefQual always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 721
  fIsVariadic always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 722
  fIsVolatile always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 723
  fHasTrailingReturnType always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 724
  fIsEscapeFunction always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 725
  fIsInlineKeyword always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 726
  fIsConstexpr always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
Line 734
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 735
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,16777216@39,4194304@41,8388608@42,2097152@44,1048576@45,524288@46,262144@47,131072@48,65536@49}
  != always {!<=-1,!>=2}
  0 always 0
Line 743
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 744
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4286578687@17,4292870143@18,4293918719@19,4294443007@20,4294705151@21,4294836223@22,4294901759@23,4294934527@24,4294950911@25}
  flag {!<=-1,8388608@17,2097152@18,1048576@19,524288@20,262144@21,131072@22,65536@23,32768@24,16384@25}
Line 748
  eConstructor always 0
  eCopyConstructor always 1
  eMoveConstructor always 2
  eOperatorEqual always 3
  eDestructor always 4
  eFunction always 5
  eLambda always 6
Line 760
  ( always !<=-1
Line 763
  ( always !<=-1
  - always !<=-1
Line 772
  ( always {!<=-1,!>=2}
  defaultVal always {!<=-1,!>=2}
  = always 0
  false always 0
Line 777
  = always 0
  nullptr always 0
Line 779
  ( always {!<=-1,!>=2}
Line 780
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eLambda always 6
Line 783
  ( always {!<=-1,!>=2}
Line 784
  return always {!<=-1,!>=2}
  type possible {1,2}
  == {!<=-1,!>=2,0}
  eConstructor always 0
  || always {!<=-1,!>=2}
Line 785
  type {2,!0}
  == {!<=-1,!>=2,0}
  eCopyConstructor always 1
  || always {!<=-1,!>=2}
Line 786
  type always {!0,!1}
  == always {!<=-1,!>=2}
  eMoveConstructor always 2
Line 789
  ( always {!<=-1,!>=2}
Line 790
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eDestructor always 4
Line 792
  ( always {!<=-1,!>=2}
Line 793
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 795
  ( always {!<=-1,!>=2}
Line 796
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 798
  ( always {!<=-1,!>=2}
Line 799
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 801
  ( always {!<=-1,!>=2}
Line 802
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 804
  ( always {!<=-1,!>=2}
Line 805
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 807
  ( always {!<=-1,!>=2}
Line 808
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 810
  ( always {!<=-1,!>=2}
Line 811
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 814
  ( always {!<=-1,!>=2}
Line 815
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasBody always 1
Line 817
  ( always {!<=-1,!>=2}
Line 818
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 2
Line 820
  ( always {!<=-1,!>=2}
Line 821
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConst always 4
Line 823
  ( always {!<=-1,!>=2}
Line 824
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasVirtualSpecifier always 8
Line 826
  ( always {!<=-1,!>=2}
Line 827
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPure always 16
Line 829
  ( always {!<=-1,!>=2}
Line 830
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStatic always 32
Line 832
  ( always {!<=-1,!>=2}
Line 833
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStaticLocal always 64
Line 835
  ( always {!<=-1,!>=2}
Line 836
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExtern always 128
Line 838
  ( always {!<=-1,!>=2}
Line 839
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 841
  ( always {!<=-1,!>=2}
Line 842
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExplicit always 512
Line 844
  ( always {!<=-1,!>=2}
Line 845
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDefault always 1024
Line 847
  ( always {!<=-1,!>=2}
Line 848
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsDelete always 2048
Line 850
  ( always {!<=-1,!>=2}
Line 851
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsNoExcept always 16384
Line 853
  ( always {!<=-1,!>=2}
Line 854
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsThrow always 32768
Line 856
  ( always {!<=-1,!>=2}
Line 857
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasOverrideSpecifier always 4096
Line 859
  ( always {!<=-1,!>=2}
Line 860
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasFinalSpecifier always 8192
Line 862
  ( always {!<=-1,!>=2}
Line 863
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperator always 65536
Line 865
  ( always {!<=-1,!>=2}
Line 866
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasLvalRefQual always 131072
Line 868
  ( always {!<=-1,!>=2}
Line 869
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasRvalRefQual always 262144
Line 871
  ( always {!<=-1,!>=2}
Line 872
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 524288
Line 874
  ( always {!<=-1,!>=2}
Line 875
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVolatile always 1048576
Line 877
  ( always {!<=-1,!>=2}
Line 878
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fHasTrailingReturnType always 2097152
Line 880
  state always {!<=-1,!>=2}
Line 881
  fHasBody always 1
  state always {!<=-1,!>=2}
Line 883
  ( always {!<=-1,!>=2}
Line 884
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInlineKeyword always 8388608
Line 887
  ( always {!<=-1,!>=2}
Line 888
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEscapeFunction always 4194304
Line 890
  state always {!<=-1,!>=2}
Line 891
  fIsEscapeFunction always 4194304
  state always {!<=-1,!>=2}
Line 894
  ( always {!<=-1,!>=2}
Line 895
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsConstexpr always 16777216
Line 897
  state always {!<=-1,!>=2}
Line 898
  fIsConstexpr always 16777216
  state always {!<=-1,!>=2}
Line 900
  ( always {!<=-1,!>=2}
Line 919
  ( always {!<=-1,!>=2}
Line 921
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 923
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 925
  ( always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 930
  this always !0
  ( always {!<=-1,!>=2}
Line 931
  "{|;" always "{|;"
Line 947
  mFlags always !<=-1
Line 949
  state always {!<=-1,!>=2}
Line 950
  fIsInline always 2
  state always {!<=-1,!>=2}
Line 952
  state always {!<=-1,!>=2}
Line 953
  fIsConst always 4
  state always {!<=-1,!>=2}
Line 955
  state always {!<=-1,!>=2}
Line 956
  fHasVirtualSpecifier always 8
  state always {!<=-1,!>=2}
Line 958
  state always {!<=-1,!>=2}
Line 959
  fIsPure always 16
  state always {!<=-1,!>=2}
Line 961
  state always {!<=-1,!>=2}
Line 962
  fIsStatic always 32
  state always {!<=-1,!>=2}
Line 964
  state always {!<=-1,!>=2}
Line 965
  fIsStaticLocal always 64
  state always {!<=-1,!>=2}
Line 967
  state always {!<=-1,!>=2}
Line 968
  fIsExtern always 128
  state always {!<=-1,!>=2}
Line 970
  state always {!<=-1,!>=2}
Line 971
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 973
  state always {!<=-1,!>=2}
Line 974
  fIsExplicit always 512
  state always {!<=-1,!>=2}
Line 976
  state always {!<=-1,!>=2}
Line 977
  fIsDefault always 1024
  state always {!<=-1,!>=2}
Line 979
  state always {!<=-1,!>=2}
Line 980
  fIsDelete always 2048
  state always {!<=-1,!>=2}
Line 982
  state always {!<=-1,!>=2}
Line 983
  fIsNoExcept always 16384
  state always {!<=-1,!>=2}
Line 985
  state always {!<=-1,!>=2}
Line 986
  fIsThrow always 32768
  state always {!<=-1,!>=2}
Line 988
  state always {!<=-1,!>=2}
Line 989
  fIsOperator always 65536
  state always {!<=-1,!>=2}
Line 991
  state always {!<=-1,!>=2}
Line 992
  fHasLvalRefQual always 131072
  state always {!<=-1,!>=2}
Line 994
  state always {!<=-1,!>=2}
Line 995
  fHasRvalRefQual always 262144
  state always {!<=-1,!>=2}
Line 997
  state always {!<=-1,!>=2}
Line 998
  fIsVariadic always 524288
  state always {!<=-1,!>=2}
Line 1000
  state always {!<=-1,!>=2}
Line 1001
  fIsVolatile always 1048576
  state always {!<=-1,!>=2}
Line 1003
  state always {!<=-1,!>=2}
Line 1004
  fHasTrailingReturnType always 2097152
  state always {!<=-1,!>=2}
Line 1006
  state always {!<=-1,!>=2}
Line 1007
  fIsInlineKeyword always 8388608
  state always {!<=-1,!>=2}
Line 1022
  eGlobal always 0
  eClass always 1
  eStruct always 2
  eUnion always 3
  eNamespace always 4
  eFunction always 5
  eIf always 6
  eElse always 7
  eFor always 8
  eWhile always 9
  eDo always 10
  eSwitch always 11
  eUnconditional always 12
  eTry always 13
  eCatch always 14
  eLambda always 15
  eEnum always 16
Line 1051
  enumClass always {!<=-1,!>=2}
Line 1056
  = possible 0
  start possible 0
Line 1057
  = possible 0
  start possible 0
  ? possible 0
  start always !0
  : always 0
  nullptr always 0
Line 1059
  bodyStartList possible lifetime[Object]=(start)
  start always !0
Line 1062
  ( always {!<=-1,!>=2}
Line 1064
  return always {!<=-1,!>=2}
  ( always !<=-1
  > always {!<=-1,!>=2}
  9 always 9
  && always {!<=-1,!>=2}
  className {>=size=10,!<=size=9}
  0 always 0
  9 always 9
  "Anonymous" always "Anonymous"
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  9 always 9
Line 1069
  == always {!<=-1,!>=2}
Line 1070
  & {lifetime[Address]=(enumeratorList),!0}
Line 1072
  nullptr always 0
Line 1075
  ( always {!<=-1,!>=2}
Line 1076
  ! always {!<=-1,!>=2}
  outer possible symbolic=(this)
Line 1077
  return always {!<=-1,!>=2}
  false always 0
Line 1078
  outer always !0
  == always {!<=-1,!>=2}
  this always !0
Line 1079
  return always {!<=-1,!>=2}
  true always 1
Line 1081
  outer {symbolic=(parent),!symbolic=(this),!0}
  != {!<=-1,!>=2,0,1}
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && {!<=-1,!>=2,0}
  parent {symbolic=(nestedIn),!symbolic=(outer),0}
Line 1082
  parent {symbolic=(nestedIn),!symbolic=(outer),!0}
Line 1083
  parent possible {symbolic=(nestedIn),symbolic=(outer),0}
  && always {!<=-1,!>=2}
  parent always !0
  == always {!<=-1,!>=2}
  outer always {!symbolic=(this),!0}
Line 1084
  return always {!<=-1,!>=2}
  true always 1
Line 1085
  return always {!<=-1,!>=2}
  false always 0
Line 1090
  scope always !0
  == always {!<=-1,!>=2}
  :: always 5
  eFunction always 5
Line 1092
  scope always !0
Line 1094
  ! {!<=-1,!>=2,1}
  scope possible 0
Line 1095
  nullptr always 0
Line 1096
  scope always !0
Line 1099
  ( always {!<=-1,!>=2}
Line 1100
  return always {!<=-1,!>=2}
  type possible 2
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type always !1
  == always {!<=-1,!>=2}
  eStruct always 2
Line 1103
  ( always {!<=-1,!>=2}
Line 1104
  return always {!<=-1,!>=2}
  type possible {2,3}
  == {!<=-1,!>=2,0}
  eClass always 1
  || always {!<=-1,!>=2}
  type {3,!1}
  == {!<=-1,!>=2,0}
  eStruct always 2
  || always {!<=-1,!>=2}
  type always {!1,!2}
  == always {!<=-1,!>=2}
  eUnion always 3
Line 1107
  ( always {!<=-1,!>=2}
Line 1108
  return always {!<=-1,!>=2}
  type possible {2,3,0,4,16}
  != {!<=-1,!>=2,1}
  eClass always 1
  && always {!<=-1,!>=2}
  type {3,0,4,16,!1}
  != {!<=-1,!>=2,1}
  eStruct always 2
  && always {!<=-1,!>=2}
  type {0,4,16,!1,!2}
  != {!<=-1,!>=2,1}
  eUnion always 3
  && always {!<=-1,!>=2}
  type {4,16,!2,!3}
  != {!<=-1,!>=2,1}
  eGlobal always 0
  && always {!<=-1,!>=2}
  type {16,!3,!0}
  != {!<=-1,!>=2,1}
  eNamespace always 4
  && always {!<=-1,!>=2}
  type always {!0,!4}
  != always {!<=-1,!>=2}
  eEnum always 16
Line 1111
  ( always {!<=-1,!>=2}
Line 1112
  return always {!<=-1,!>=2}
  type possible {9,10}
  == {!<=-1,!>=2,0}
  :: always 8
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,!8}
  == {!<=-1,!>=2,0}
  :: always 9
  eWhile always 9
  || always {!<=-1,!>=2}
  type always {!8,!9}
  == always {!<=-1,!>=2}
  :: always 10
  eDo always 10
Line 1115
  ( always {!<=-1,!>=2}
Line 1116
  return always {!<=-1,!>=2}
  type possible {7,8,9,10,11,12,13,14}
  == {!<=-1,!>=2,0}
  eIf always 6
  || always {!<=-1,!>=2}
  type {8,9,10,11,12,13,14,!6}
  == {!<=-1,!>=2,0}
  eElse always 7
  || always {!<=-1,!>=2}
Line 1117
  type {9,10,11,12,13,14,!6,!7}
  == {!<=-1,!>=2,0}
  eFor always 8
  || always {!<=-1,!>=2}
  type {10,11,12,13,14,!7,!8}
  == {!<=-1,!>=2,0}
  eWhile always 9
  || always {!<=-1,!>=2}
  type {11,12,13,14,!8,!9}
  == {!<=-1,!>=2,0}
  eDo always 10
  || always {!<=-1,!>=2}
Line 1118
  type {12,13,14,!9,!10}
  == {!<=-1,!>=2,0}
  eSwitch always 11
  || always {!<=-1,!>=2}
  type {13,14,!10,!11}
  == {!<=-1,!>=2,0}
  eUnconditional always 12
  || always {!<=-1,!>=2}
Line 1119
  type {14,!11,!12}
  == {!<=-1,!>=2,0}
  eTry always 13
  || always {!<=-1,!>=2}
  type always {!12,!13}
  == always {!<=-1,!>=2}
  eCatch always 14
Line 1123
  ( always {!<=-1,!>=2}
Line 1131
  , always 0
  requireConst always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1133
  , always 0
  isC always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1135
  ( always !0
  this always !0
Line 1140
  ( always !0
  this always !0
Line 1159
  functionList possible lifetime[Object]=(func)
Line 1161
  = {lifetime[Object]=(functionList),!0}
  & {lifetime[Object]=(functionList),!0}
  functionList {lifetime[Object]=(func),!size=0}
Line 1163
  ( possible lifetime[Iterator]=(functionMap)
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
  back {lifetime[Object]=(functionList),symbolic=(&functionList.back()),!0}
Line 1166
  ( always {!<=-1,!>=2}
Line 1186
  , always {!<=-1,!>=2}
  isCpp always {!<=-1,!>=2}
Line 1200
  ( always {!<=-1,!>=2}
  & {lifetime[Address]=(vartok),!0}
  & {lifetime[Address]=(typetok),!0}
Line 1209
  None always 0
Line 1210
  LValue always 1
Line 1211
  RValue always 2
Line 1217
  UNKNOWN_SIGN always 0
  SIGNED always 1
  UNSIGNED always 2
Line 1219
  UNKNOWN_TYPE always 0
Line 1220
  POD always 1
Line 1221
  NONSTD always 2
Line 1222
  RECORD always 3
Line 1223
  SMART_POINTER always 4
Line 1224
  CONTAINER always 5
Line 1225
  ITERATOR always 6
Line 1226
  VOID always 7
Line 1227
  BOOL always 8
Line 1228
  CHAR always 9
Line 1229
  SHORT always 10
Line 1230
  WCHAR_T always 11
Line 1231
  INT always 12
Line 1232
  LONG always 13
Line 1233
  LONGLONG always 14
Line 1234
  UNKNOWN_INT always 15
Line 1235
  FLOAT always 16
Line 1236
  DOUBLE always 17
Line 1237
  LONGDOUBLE always 18
Line 1242
  = always 0
  :: always 0
  None always 0
Line 1256
  UNKNOWN_SIGN always 0
Line 1257
  UNKNOWN_TYPE always 0
Line 1258
  0 always 0
Line 1259
  0U always 0
Line 1260
  0U always 0
Line 1261
  nullptr always 0
Line 1262
  nullptr always 0
Line 1263
  nullptr always 0
Line 1264
  nullptr always 0
Line 1265
  nullptr always 0
Line 1266
  nullptr always 0
Line 1268
  ( possible lifetime[SubObject]=(s)
Line 1271
  0 always 0
Line 1273
  0U always 0
Line 1274
  nullptr always 0
Line 1275
  nullptr always 0
Line 1276
  nullptr always 0
Line 1277
  nullptr always 0
Line 1278
  nullptr always 0
Line 1279
  nullptr always 0
Line 1281
  ( possible lifetime[SubObject]=(s)
Line 1284
  0 always 0
Line 1287
  nullptr always 0
Line 1288
  nullptr always 0
Line 1289
  nullptr always 0
Line 1290
  nullptr always 0
Line 1291
  nullptr always 0
Line 1292
  nullptr always 0
Line 1294
  ( possible lifetime[SubObject]=(s)
Line 1297
  0 always 0
Line 1300
  nullptr always 0
Line 1301
  nullptr always 0
Line 1302
  nullptr always 0
Line 1303
  nullptr always 0
Line 1304
  nullptr always 0
Line 1305
  nullptr always 0
Line 1311
  , always {!<=-1,!>=2}
  longType always {!<=-1,!>=2}
Line 1313
  UNKNOWN always 0
  SAME always 1
  FALLBACK1 always 2
  FALLBACK2 always 3
  NOMATCH always 4
Line 1317
  ( always {!<=-1,!>=2}
Line 1318
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  :: always 8
  BOOL always 8
Line 1321
  ( always {!<=-1,!>=2}
Line 1322
  return always {!<=-1,!>=2}
  type possible {<=15,>=16}
  >= {!<=-1,!>=2,<=1}
  :: always 8
  BOOL always 8
  && always {!<=-1,!>=2}
  type {>=8,!<=7}
  <= {!<=-1,!>=2,>=1}
  :: always 15
  UNKNOWN_INT always 15
Line 1325
  ( always {!<=-1,!>=2}
Line 1326
  return always {!<=-1,!>=2}
  type possible {<=18,>=19}
  >= {!<=-1,!>=2,<=1}
  :: always 16
  FLOAT always 16
  && always {!<=-1,!>=2}
  type {>=16,!<=15}
  <= {!<=-1,!>=2,>=1}
  :: always 18
  LONGDOUBLE always 18
Line 1329
  ( always {!<=-1,!>=2}
Line 1331
  ( always {!<=-1,!>=2}
Line 1332
  return always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  typeScope always !0
  == always {!<=-1,!>=2}
  :: always 16
  eEnum always 16
Line 1335
  , always 0
  p always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1338
  ( always {!<=-1,!>=2}
Line 1381
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1382
  , always 0
  lookOutside always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1383
  this always !0
  lookOutside always {!<=-1,!>=2}
Line 1388
  this always !0
Line 1391
  ( always {!<=-1,!>=2}
Line 1392
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 1408
  = always 0
  nullptr always 0
Line 1412
  ( always {!<=-1,!>=2}
Line 1426
  reportDebugWarnings always {!<=-1,!>=2}
  = always 0
  nullptr always 0
Line 1456
  firstPass always {!<=-1,!>=2}
Line 1467
  & {lifetime[Address]=(scope),!0}
Line 1468
  & {lifetime[Address]=(scope),!0}
  & {lifetime[Address]=(tok),!0}
Line 1470
  ( always {!<=-1,!>=2}
Line 1482
  ( always {!<=-1,!>=2}
Line 1500
  mIsCpp always {!<=-1,!>=2}
Line 40
  none always 0
Line 41
  op1 always 1
Line 42
  op2 always 2
Line 43
  op1_and_op2 always 3
Line 44
  done always 4
Line 53
  ! always {!<=-1,!>=2}
Line 57
  = always !0
  ast always !0
Line 59
  tok inconclusive symbolic=(ast)
Line 61
  c possible {2,3,1}
  == {!<=-1,!>=2,0}
  :: always 4
  done always 4
Line 63
  c {3,1,!4}
  == {!<=-1,!>=2,0}
  :: always 2
  op2 always 2
  || {!<=-1,!>=2,1}
  c {1,3,!4,!2}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 66
  t2 always !0
Line 68
  c {3,!4,2}
  == {!<=-1,!>=2,0}
  :: always 1
  op1 always 1
  || {!<=-1,!>=2,1}
  c {!4,2,3,!1}
  == {!<=-1,!>=2,0,1}
  :: always 3
  op1_and_op2 always 3
Line 71
  t1 always !0
Line 74
  ( always {!<=-1,!>=2}
Line 77
  tokens always !size=0
Line 78
  tokens always !size=0
Line 79
  true always 1
Line 82
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 92
  , always 100
  = always 100
  100 always 100
Line 94
  ( always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 106
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 107
  ( always {!<=-1,!>=2}
Line 109
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  unknown always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 113
  ( always {!<=-1,!>=2}
Line 115
  ( always {!<=-1,!>=2}
Line 116
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 123
  ( always {!<=-1,!>=2}
Line 137
  , always 0
  = always 0
  nullptr always 0
Line 139
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  unknown always {!<=-1,!>=2}
  = always 0
  false always 0
Line 155
  cpp always {!<=-1,!>=2}
Line 157
  ( always {!<=-1,!>=2}
Line 158
  ( always {!<=-1,!>=2}
Line 179
  ( always {!<=-1,!>=2}
Line 187
  ( always {!<=-1,!>=2}
Line 188
  ( always {!<=-1,!>=2}
Line 190
  ( always {!<=-1,!>=2}
  , always 1
  onVar always {!<=-1,!>=2}
  = always 1
  true always 1
  , always 0
  = always 0
  0 always 0
Line 198
  temporary always {!<=-1,!>=2}
  = always 1
  true always 1
Line 199
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 201
  = always 20
  20 always 20
Line 202
  , always 0
  = always 0
  nullptr always 0
Line 204
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 206
  ( always {!<=-1,!>=2}
Line 211
  ( always {!<=-1,!>=2}
Line 222
  ( always {!<=-1,!>=2}
  isNot always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 224
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  followVar always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 226
  ( always {!<=-1,!>=2}
Line 228
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 230
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 0
  checkArrayAccess always {!<=-1,!>=2}
  = always 0
  false always 0
  , always 1
  checkReference always {!<=-1,!>=2}
  = always 1
  true always 1
Line 232
  ( always {!<=-1,!>=2}
Line 234
  ( always {!<=-1,!>=2}
Line 237
  ( always {!<=-1,!>=2}
  , always 0
Line 238
  = always 0
  nullptr always 0
  , always 0
Line 239
  = always 0
  nullptr always 0
  , always 0
Line 240
  functionScope always {!<=-1,!>=2}
  = always 0
  false always 0
Line 243
  ( always {!<=-1,!>=2}
Line 262
  ( always {!<=-1,!>=2}
Line 272
  ( always {!<=-1,!>=2}
Line 275
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 276
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 278
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 280
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 282
  ( always {!<=-1,!>=2}
Line 286
  , always {!<=-1,!>=2}
Line 287
  cpp always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 290
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 292
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 293
  , always {!<=-1,!>=2}
  globalvar always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  , always 20
  = always 20
  20 always 20
Line 295
  ( always {!<=-1,!>=2}
Line 298
  , always {!<=-1,!>=2}
Line 299
  cpp always {!<=-1,!>=2}
  , always 20
Line 300
  = always 20
  20 always 20
Line 302
  ( always {!<=-1,!>=2}
Line 304
  , always {!<=-1,!>=2}
Line 305
  globalvar always {!<=-1,!>=2}
Line 306
  , always {!<=-1,!>=2}
Line 307
  cpp always {!<=-1,!>=2}
  , always 20
Line 308
  = always 20
  20 always 20
Line 311
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 313
  ( always {!<=-1,!>=2}
Line 336
  ( always {!<=-1,!>=2}
Line 348
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 355
  ( always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 357
  ( always {!<=-1,!>=2}
Line 359
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 370
  ( always {!<=-1,!>=2}
Line 372
  ( always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 383
  ( possible lifetime[SubObject]=(cpp)
  cpp always {!<=-1,!>=2}
  mCpp always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
  mValueFlowKnown always {!<=-1,!>=2}
  true always 1
Line 385
  ( always {!<=-1,!>=2}
Line 403
  ( always {!<=-1,!>=2}
Line 406
  known always {!<=-1,!>=2}
Line 411
  ( always {!<=-1,!>=2}
Line 413
  = always 0
  nullptr always 0
  = always 0
  nullptr always 0
Line 415
  ( always {!<=-1,!>=2}
Line 419
  NONE always 0
  READ always 1
  WRITE always 2
  BREAK always 3
  RETURN always 4
  BAILOUT always 5
Line 420
  ( possible lifetime[SubObject]=(type)
  nullptr always 0
Line 421
  ( possible lifetime[SubObject]=(type)
Line 426
  , always {!<=-1,!>=2}
  local always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  inInnerClass always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 429
  ( always {!<=-1,!>=2}
Line 431
  mCpp always {!<=-1,!>=2}
Line 433
  Reassign always 0
  UnusedValue always 1
  ValueFlow always 2
Line 435
  mValueFlowKnown always {!<=-1,!>=2}
Line 438
  ( always {!<=-1,!>=2}
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 45
  names inconclusive symbolic=(p+1)
  ',' always 44
Line 46
  p always !0
Line 47
  = always !1
  p always !0
  + always !1
  1 always 1
Line 49
  ret possible size=0
Line 50
  ret {size=1,!size=0}
Line 55
  ',' always 44
Line 56
  ( always {!<=-1,!>=2}
Line 58
  ( always {!<=-1,!>=2}
  "- %num%" always "- %num%"
Line 59
  "-" always "-"
  1 always 1
Line 65
  0 always 0
Line 70
  path possible {lifetime[Object]=(p.substr(0,pos))@3,lifetime[Object]=(p)@4}
  ',' always 44
  != always {!<=-1,!>=2}
  nullptr always 0
Line 71
  path possible {lifetime[Object]=(p.substr(0,pos))@3,lifetime[Object]=(p)@4}
Line 73
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  ',' always 44
Line 74
  pos always !<=-1
  == always {!<=-1,!>=2}
Line 76
  0 always 0
  pos always !<=-1
  ( {lifetime[Object]=(p.substr(0,pos)),!0}
Line 77
  != always {!<=-1,!>=2}
Line 79
  pos always !<=-1
  + always !<=0
  1 always 1
Line 81
  ! {!<=-1,!>=2,0}
  p possible size=0
  ( {!<=-1,!>=2,1}
Line 82
  p always !size=0
  ( {lifetime[Object]=(p),!0}
Line 89
  path possible {lifetime[Object]=(p.substr(0,pos))@3,lifetime[Object]=(p)@4}
Line 90
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 93
  == always {!<=-1,!>=2}
Line 96
  ( always {!<=-1,!>=2}
Line 97
  ".cfg" always ".cfg"
Line 98
  fullfilename always !<=size=3
  ( {lifetime[Object]=(fullfilename),!0}
Line 99
  != always {!<=-1,!>=2}
Line 100
  fullfilename always !<=size=3
Line 108
  exename always !0
Line 109
  cfgfolders always size=0
  "cfg" always "cfg"
Line 110
  cfgfolders always size=1
Line 113
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  cfgfolders always !size=0
Line 115
  cfgfolders always !size=0
Line 116
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cfgfolder always !size=0
  '/' always 47
  "" always ""
  : always "/"
  "/" always "/"
Line 118
  ( {lifetime[Object]=(filename),!0}
Line 119
  != always {!<=-1,!>=2}
Line 125
  == always {!<=-1,!>=2}
Line 126
  ( possible lifetime[Iterator]=(mFiles)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mFiles),end=0}
Line 128
  == always {!<=-1,!>=2}
Line 136
  == always {!<=-1,!>=2}
Line 146
  yieldName possible {size=4,size=6,size=9,size=14,size=12,size=8,size=5}
  == {!<=-1,!>=2,0}
  "at_index" always "at_index"
Line 148
  yieldName possible {size=6,size=9,size=14,size=12,size=8,size=4,size=5}
  == {!<=-1,!>=2,0}
  "item" always "item"
Line 150
  yieldName possible {size=9,size=14,size=12,size=8,size=4,size=5}
  == {!<=-1,!>=2,0}
  "buffer" always "buffer"
Line 152
  yieldName possible {size=14,size=12,size=8,size=4,size=5}
  == {!<=-1,!>=2,0}
  "buffer-nt" always "buffer-nt"
Line 154
  yieldName possible {size=12,size=8,size=4,size=5}
  == {!<=-1,!>=2,0}
  "start-iterator" always "start-iterator"
Line 156
  yieldName possible {size=8,size=4,size=5}
  == {!<=-1,!>=2,0}
  "end-iterator" always "end-iterator"
Line 158
  yieldName possible {size=4,size=5}
  == {!<=-1,!>=2,0}
  "iterator" always "iterator"
Line 160
  yieldName possible size=5
  == {!<=-1,!>=2,0}
  "size" always "size"
Line 162
  == always {!<=-1,!>=2}
  "empty" always "empty"
Line 169
  actionName possible {size=5,size=4,size=3,size=6,size=14,size=15}
  == {!<=-1,!>=2,0}
  "resize" always "resize"
Line 171
  actionName possible {size=4,size=3,size=6,size=5,size=14,size=15}
  == {!<=-1,!>=2,0}
  "clear" always "clear"
Line 173
  actionName possible {size=3,size=4,size=6,size=5,size=14,size=15}
  == {!<=-1,!>=2,0}
  "push" always "push"
Line 175
  actionName possible {size=4,size=6,size=5,size=14,size=15}
  == {!<=-1,!>=2,0}
  "pop" always "pop"
Line 177
  actionName possible {size=6,size=5,size=14,size=15}
  == {!<=-1,!>=2,0}
  "find" always "find"
Line 179
  actionName possible {size=5,size=14,size=15,size=6}
  == {!<=-1,!>=2,0}
  "insert" always "insert"
Line 181
  actionName possible {size=14,size=15,size=6}
  == {!<=-1,!>=2,0}
  "erase" always "erase"
Line 183
  actionName possible {size=15,size=6}
  == {!<=-1,!>=2,0}
  "change-content" always "change-content"
Line 185
  actionName possible size=6
  == {!<=-1,!>=2,0}
  "change-internal" always "change-internal"
Line 187
  == always {!<=-1,!>=2}
  "change" always "change"
Line 194
  ( always {!<=-1,!>=2}
  , always !<=-1
  len always !<=-1
Line 197
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  len always !<=-1
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 204
  == always {!<=-1,!>=2}
  nullptr always 0
Line 209
  "def" always "def"
  != always {!<=-1,!>=2}
  0 always 0
Line 212
  "format" always "format"
  1 always 1
Line 214
  > always {!<=-1,!>=2}
  2 always 2
  || always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  0 always 0
Line 221
  == always {!<=-1,!>=2}
  "memory" always "memory"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "resource" always "resource"
Line 223
  = always 0
  0 always 0
Line 225
  "dealloc" always "dealloc"
  == always {!<=-1,!>=2}
  0 always 0
Line 226
  = possible lifetime[Iterator]=(mDealloc)
  ( possible lifetime[Iterator]=(mDealloc)
Line 227
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mDealloc),end=0}
Line 233
  allocationId possible symbolic=(it->second.groupId)
  == always {!<=-1,!>=2}
  0 always 0
Line 234
  == always {!<=-1,!>=2}
  "memory" always "memory"
Line 235
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 237
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 244
  == always {!<=-1,!>=2}
  "alloc" always "alloc"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "realloc" always "realloc"
Line 245
  0 always 0
Line 248
  . always {!<=-1,!>=2}
  initData always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "init" always "init"
  true always 1
Line 249
  "arg" always "arg"
  -1 always -1
Line 251
  "buffer-size" always "buffer-size"
Line 252
  ! always {!<=-1,!>=2}
Line 255
  "malloc" always "malloc"
  6 always 6
  == always {!<=-1,!>=2}
  0 always 0
Line 257
  "calloc" always "calloc"
  6 always 6
  == always {!<=-1,!>=2}
  0 always 0
Line 259
  "strdup" always "strdup"
  6 always 6
  == always {!<=-1,!>=2}
  0 always 0
Line 263
  = always 1
  1 always 1
Line 264
  = always 2
  2 always 2
Line 265
  6 always 6
  == always {!<=-1,!>=2}
  0 always 0
Line 267
  6 always 6
  == always {!<=-1,!>=2}
  ':' always 58
  && always {!<=-1,!>=2}
  7 always 7
  >= always {!<=-1,!>=2}
  '1' always 49
  && always {!<=-1,!>=2}
  7 always 7
  <= always {!<=-1,!>=2}
  '5' always 53
Line 268
  7 always 7
  '0' always 48
Line 269
  8 always 8
  == always {!<=-1,!>=2}
  ',' always 44
  && always {!<=-1,!>=2}
  9 always 9
  >= always {!<=-1,!>=2}
  '1' always 49
  && always {!<=-1,!>=2}
  9 always 9
  <= always {!<=-1,!>=2}
  '5' always 53
Line 270
  9 always 9
  '0' always 48
Line 275
  == always {!<=-1,!>=2}
  "realloc" always "realloc"
Line 276
  "realloc-arg" always "realloc-arg"
  1 always 1
Line 278
  != always {!<=-1,!>=2}
  "realloc" always "realloc"
Line 282
  == always {!<=-1,!>=2}
  "dealloc" always "dealloc"
Line 283
  0 always 0
Line 285
  "arg" always "arg"
  1 always 1
Line 287
  == always {!<=-1,!>=2}
  "use" always "use"
Line 288
  . always {!<=-1,!>=2}
  = always 1
  true always 1
Line 294
  == always {!<=-1,!>=2}
  "define" always "define"
Line 295
  "name" always "name"
Line 296
  == always {!<=-1,!>=2}
  nullptr always 0
Line 297
  "name" always "name"
Line 298
  "value" always "value"
Line 299
  == always {!<=-1,!>=2}
  nullptr always 0
Line 300
  "value" always "value"
Line 302
  " " always " "
Line 306
  == always {!<=-1,!>=2}
  "function" always "function"
Line 307
  "name" always "name"
Line 308
  == always {!<=-1,!>=2}
  nullptr always 0
Line 309
  "name" always "name"
Line 312
  != always {!<=-1,!>=2}
Line 317
  == always {!<=-1,!>=2}
  "reflection" always "reflection"
Line 319
  "call" always "call"
  != always {!<=-1,!>=2}
  0 always 0
Line 324
  "arg" always "arg"
Line 325
  ! always {!<=-1,!>=2}
Line 326
  "arg" always "arg"
Line 332
  == always {!<=-1,!>=2}
  "markup" always "markup"
Line 333
  "ext" always "ext"
Line 334
  ! always {!<=-1,!>=2}
Line 335
  "ext" always "ext"
Line 338
  [ always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "reporterrors" always "reporterrors"
  "true" always "true"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 339
  [ always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "aftercode" always "aftercode"
  "true" always "true"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 343
  == always {!<=-1,!>=2}
  "keywords" always "keywords"
Line 345
  "keyword" always "keyword"
  == always {!<=-1,!>=2}
  0 always 0
Line 346
  "name" always "name"
Line 347
  == always {!<=-1,!>=2}
  nullptr always 0
Line 348
  "name" always "name"
Line 355
  == always {!<=-1,!>=2}
  "exported" always "exported"
Line 357
  "exporter" always "exporter"
  != always {!<=-1,!>=2}
  0 always 0
Line 362
  "prefix" always "prefix"
Line 363
  ! always {!<=-1,!>=2}
Line 364
  "prefix" always "prefix"
Line 368
  == always {!<=-1,!>=2}
  "prefix" always "prefix"
Line 370
  == always {!<=-1,!>=2}
  "suffix" always "suffix"
Line 378
  == always {!<=-1,!>=2}
  "imported" always "imported"
Line 380
  "importer" always "importer"
  == always {!<=-1,!>=2}
  0 always 0
Line 387
  == always {!<=-1,!>=2}
  "codeblocks" always "codeblocks"
Line 390
  == always {!<=-1,!>=2}
  "block" always "block"
Line 391
  "name" always "name"
Line 394
  == always {!<=-1,!>=2}
  "structure" always "structure"
Line 395
  "start" always "start"
Line 398
  "end" always "end"
Line 401
  "offset" always "offset"
Line 416
  == always {!<=-1,!>=2}
  "container" always "container"
Line 417
  "id" always "id"
Line 418
  ! always {!<=-1,!>=2}
Line 419
  "id" always "id"
Line 423
  "inherits" always "inherits"
Line 425
  = possible lifetime[Iterator]=(containers)
  ( possible lifetime[Iterator]=(containers)
Line 426
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(containers),end=0}
Line 432
  "startPattern" always "startPattern"
Line 435
  " !!::" always " !!::"
Line 437
  "endPattern" always "endPattern"
Line 440
  "itEndPattern" always "itEndPattern"
Line 443
  "opLessAllowed" always "opLessAllowed"
Line 445
  . always {!<=-1,!>=2}
  opLessAllowed always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "true" always "true"
Line 446
  "hasInitializerListConstructor" always "hasInitializerListConstructor"
Line 448
  . always {!<=-1,!>=2}
  hasInitializerListConstructor always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "true" always "true"
Line 449
  "view" always "view"
Line 451
  . always {!<=-1,!>=2}
  view always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "true" always "true"
Line 455
  == always {!<=-1,!>=2}
  "size" always "size"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "access" always "access"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "other" always "other"
Line 457
  != always {!<=-1,!>=2}
  "function" always "function"
Line 462
  "name" always "name"
Line 463
  ! always {!<=-1,!>=2}
Line 464
  "name" always "name"
Line 466
  "action" always "action"
Line 471
  action always symbolic=(Container::actionFrom(actionName))
  == always {!<=-1,!>=2}
Line 475
  "yields" always "yields"
Line 480
  yield always symbolic=(Container::yieldFrom(yieldName))
  == always {!<=-1,!>=2}
Line 485
  = possible symbolic=(Container::yieldFrom(yieldName))
  yield possible symbolic=(Container::yieldFrom(yieldName))
Line 488
  == always {!<=-1,!>=2}
  "size" always "size"
Line 489
  "templateParameter" always "templateParameter"
Line 492
  == always {!<=-1,!>=2}
  "access" always "access"
Line 493
  "indexOperator" always "indexOperator"
Line 495
  . always {!<=-1,!>=2}
  arrayLike_indexOp always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "array-like" always "array-like"
Line 497
  == always {!<=-1,!>=2}
  "type" always "type"
Line 498
  "templateParameter" always "templateParameter"
Line 502
  "string" always "string"
Line 504
  . always {!<=-1,!>=2}
  stdStringLike always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "std-like" always "std-like"
Line 505
  "associative" always "associative"
Line 507
  . always {!<=-1,!>=2}
  stdAssociativeLike always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "std-like" always "std-like"
Line 508
  "unstable" always "unstable"
Line 511
  ( always !<=-1
  "erase" always "erase"
  != always {!<=-1,!>=2}
Line 512
  . always {!<=-1,!>=2}
  unstableErase always {!<=-1,!>=2}
  = always 1
  true always 1
Line 513
  ( always !<=-1
  "insert" always "insert"
  != always {!<=-1,!>=2}
Line 514
  . always {!<=-1,!>=2}
  unstableInsert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 516
  == always {!<=-1,!>=2}
  "rangeItemRecordType" always "rangeItemRecordType"
Line 518
  "name" always "name"
Line 519
  "templateParameter" always "templateParameter"
Line 521
  = possible ""
  ? possible ""
  : always ""
  "" always ""
Line 522
  = possible -1
  ? possible -1
  : always -1
  -1 always -1
Line 530
  == always {!<=-1,!>=2}
  "smart-pointer" always "smart-pointer"
Line 531
  "class-name" always "class-name"
Line 532
  ! always {!<=-1,!>=2}
Line 533
  "class-name" always "class-name"
Line 535
  smartPointer always {symbolic=(smartPointers[className]),symbolic=(smartPointer)}
Line 539
  == always {!<=-1,!>=2}
  "unique" always "unique"
Line 540
  . always {!<=-1,!>=2}
  unique always {!<=-1,!>=2}
  = always 1
  true always 1
Line 544
  == always {!<=-1,!>=2}
  "type-checks" always "type-checks"
Line 550
  ! always {!<=-1,!>=2}
Line 552
  == always {!<=-1,!>=2}
  "check" always "check"
Line 554
  == always {!<=-1,!>=2}
  "suppress" always "suppress"
Line 560
  == always {!<=-1,!>=2}
  "podtype" always "podtype"
Line 561
  "name" always "name"
Line 562
  ! always {!<=-1,!>=2}
Line 563
  "name" always "name"
Line 564
  0 always 0
Line 566
  "stdtype" always "stdtype"
Line 568
  "bool" always "bool"
  == always {!<=-1,!>=2}
  0 always 0
Line 570
  "char" always "char"
  == always {!<=-1,!>=2}
  0 always 0
Line 572
  "short" always "short"
  == always {!<=-1,!>=2}
  0 always 0
Line 574
  "int" always "int"
  == always {!<=-1,!>=2}
  0 always 0
Line 576
  "long" always "long"
  == always {!<=-1,!>=2}
  0 always 0
Line 578
  "long long" always "long long"
  == always {!<=-1,!>=2}
  0 always 0
Line 581
  "size" always "size"
Line 583
  . always !<=-1
  size always !<=-1
  = always !<=-1
Line 584
  "sign" always "sign"
Line 591
  == always {!<=-1,!>=2}
  "platformtype" always "platformtype"
Line 592
  "name" always "name"
Line 593
  == always {!<=-1,!>=2}
  nullptr always 0
Line 594
  "name" always "name"
Line 595
  "value" always "value"
Line 596
  == always {!<=-1,!>=2}
  nullptr always 0
Line 597
  "value" always "value"
Line 603
  == always {!<=-1,!>=2}
  "platform" always "platform"
Line 604
  "type" always "type"
Line 605
  == always {!<=-1,!>=2}
  nullptr always 0
Line 606
  "type" always "type"
Line 608
  == always {!<=-1,!>=2}
  "signed" always "signed"
Line 609
  . always {!<=-1,!>=2}
  mSigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 610
  == always {!<=-1,!>=2}
  "unsigned" always "unsigned"
Line 611
  . always {!<=-1,!>=2}
  mUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 612
  == always {!<=-1,!>=2}
  "long" always "long"
Line 613
  . always {!<=-1,!>=2}
  mLong always {!<=-1,!>=2}
  = always 1
  true always 1
Line 614
  == always {!<=-1,!>=2}
  "pointer" always "pointer"
Line 615
  . always {!<=-1,!>=2}
  mPointer always {!<=-1,!>=2}
  = always 1
  true always 1
Line 616
  == always {!<=-1,!>=2}
  "ptr_ptr" always "ptr_ptr"
Line 617
  . always {!<=-1,!>=2}
  mPtrPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 618
  == always {!<=-1,!>=2}
  "const_ptr" always "const_ptr"
Line 619
  . always {!<=-1,!>=2}
  mConstPtr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 623
  ( always {!<=-1,!>=2}
Line 625
  type_ptr always symbolic=(platform_type(type_name,emptyString))
Line 626
  type_ptr always symbolic=(platform_type(type_name,emptyString))
  == always {!<=-1,!>=2}
Line 634
  type_ptr always symbolic=(platform_type(type_name,p))
Line 635
  type_ptr always symbolic=(platform_type(type_name,p))
  == always {!<=-1,!>=2}
Line 647
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 649
  = {lifetime[Iterator]=(unknown_elements),start=0}
  ( {lifetime[Iterator]=(unknown_elements),start=0}
  i possible lifetime[Iterator]=(unknown_elements)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(unknown_elements),end=0}
Line 650
  i possible lifetime[Iterator]=(unknown_elements)
Line 651
  i possible lifetime[Iterator]=(unknown_elements)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(unknown_elements),end=0}
Line 652
  ", " always ", "
Line 661
  ( always {!<=-1,!>=2}
Line 664
  name always !size=0
Line 668
  functionnodename possible {size=4,size=5,size=11,size=20,size=10,size=3,size=14,size=9}
  == {!<=-1,!>=2,0}
  "noreturn" always "noreturn"
Line 669
  "false" always "false"
  == always {!<=-1,!>=2}
  0 always 0
Line 671
  "maybe" always "maybe"
  == always {!<=-1,!>=2}
  0 always 0
Line 675
  functionnodename possible {size=5,size=11,size=20,size=10,size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "pure" always "pure"
Line 676
  . always {!<=-1,!>=2}
  ispure always {!<=-1,!>=2}
  = always 1
  true always 1
Line 677
  functionnodename possible {size=11,size=20,size=10,size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "const" always "const"
Line 678
  . always {!<=-1,!>=2}
  ispure always {!<=-1,!>=2}
  = always 1
  true always 1
Line 679
  . always {!<=-1,!>=2}
  isconst always {!<=-1,!>=2}
  = always 1
  true always 1
Line 680
  functionnodename possible {size=20,size=10,size=11,size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "leak-ignore" always "leak-ignore"
Line 681
  . always {!<=-1,!>=2}
  leakignore always {!<=-1,!>=2}
  = always 1
  true always 1
Line 682
  functionnodename possible {size=10,size=11,size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "not-overlapping-data" always "not-overlapping-data"
Line 684
  nonOverlappingData always Uninit
  ptr1Arg always Uninit
  "ptr1-arg" always "ptr1-arg"
  -1 always -1
Line 685
  "ptr2-arg" always "ptr2-arg"
  -1 always -1
Line 686
  "size-arg" always "size-arg"
  -1 always -1
Line 687
  "strlen-arg" always "strlen-arg"
  -1 always -1
Line 689
  functionnodename possible {size=11,size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "use-retval" always "use-retval"
Line 690
  = always 1
  :: always 1
  DEFAULT always 1
Line 691
  "type" always "type"
Line 692
  type always !0
  "error-code" always "error-code"
  == always {!<=-1,!>=2}
  0 always 0
Line 693
  = always 2
  :: always 2
  ERROR_CODE always 2
Line 694
  functionnodename possible {size=3,size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "returnValue" always "returnValue"
Line 696
  = always !0
  expr always !0
Line 697
  "type" always "type"
Line 698
  = always !0
  type always !0
Line 699
  "container" always "container"
Line 700
  container always !0
Line 701
  "unknownValues" always "unknownValues"
Line 702
  unknownReturnValues always !0
  "all" always "all"
  == always {!<=-1,!>=2}
  0 always 0
Line 704
  = always {{,size=2}
  values always {{,size=2}
Line 707
  functionnodename possible {size=14,size=9,size=4}
  == {!<=-1,!>=2,0}
  "arg" always "arg"
Line 708
  "nr" always "nr"
Line 709
  ! always {!<=-1,!>=2}
Line 710
  "nr" always "nr"
Line 711
  bAnyArg always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  argNrString always !0
  "any" always "any"
  == always {!<=-1,!>=2}
  0 always 0
Line 712
  bVariadicArg always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  argNrString always !0
  "variadic" always "variadic"
  == always {!<=-1,!>=2}
  0 always 0
Line 713
  bAnyArg {symbolic=(strcmp(argNrString,"any")==0),!<=-1,!>=2}
  || always {!<=-1,!>=2}
  bVariadicArg {symbolic=(strcmp(argNrString,"variadic")==0),!<=-1,!>=2}
  -1 always -1
  : always -1
  argNrString always !0
Line 714
  nr always symbolic=((bAnyArg||bVariadicArg)?-1:std::atoi(argNrString))
Line 715
  . always {!<=-1,!>=2}
  optional always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  "default" always "default"
  != always {!<=-1,!>=2}
  nullptr always 0
Line 716
  . always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
  = {symbolic=(strcmp(argNrString,"variadic")==0),!<=-1,!>=2}
  bVariadicArg {symbolic=(strcmp(argNrString,"variadic")==0),!<=-1,!>=2}
Line 717
  "direction" always "direction"
Line 719
  argDirLen always !<=-1
  = always !<=-1
  ( always !<=-1
  argDirection always !0
Line 720
  ! always {!<=-1,!>=2}
  argDirection always !0
  "in" always "in"
  argDirLen {symbolic=(strlen(argDirection)),!<=-1}
Line 722
  ! always {!<=-1,!>=2}
  argDirection always !0
  "out" always "out"
  argDirLen {symbolic=(strlen(argDirection)),!<=-1}
Line 724
  ! always {!<=-1,!>=2}
  argDirection always !0
  "inout" always "inout"
  argDirLen {symbolic=(strlen(argDirection)),!<=-1}
Line 730
  = always 0
  0 always 0
Line 731
  "indirect" always "indirect"
Line 733
  indirectStr always !0
Line 734
  argnodename possible {size=8,size=10,size=9,size=4,size=5,size=7}
  == {!<=-1,!>=2,0}
  "not-bool" always "not-bool"
Line 735
  . always {!<=-1,!>=2}
  notbool always {!<=-1,!>=2}
  = always 1
  true always 1
Line 736
  argnodename possible {size=10,size=9,size=4,size=5,size=7,size=8}
  == {!<=-1,!>=2,0}
  "not-null" always "not-null"
Line 737
  . always {!<=-1,!>=2}
  notnull always {!<=-1,!>=2}
  = always 1
  true always 1
Line 738
  argnodename possible {size=9,size=4,size=5,size=7,size=8}
  == {!<=-1,!>=2,0}
  "not-uninit" always "not-uninit"
Line 740
  argnodename possible {size=4,size=5,size=7,size=8}
  == {!<=-1,!>=2,0}
  "formatstr" always "formatstr"
Line 741
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 742
  argnodename possible {size=5,size=7,size=8}
  == {!<=-1,!>=2,0}
  "strz" always "strz"
Line 743
  . always {!<=-1,!>=2}
  strz always {!<=-1,!>=2}
  = always 1
  true always 1
Line 744
  argnodename possible {size=7,size=8}
  == {!<=-1,!>=2,0}
  "valid" always "valid"
Line 747
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 748
  ! always {!<=-1,!>=2}
  ? possible "\"\""
  "\"\"" always "\"\""
  : always "\"\""
Line 752
  argnodename possible size=8
  == {!<=-1,!>=2,0}
  "minsize" always "minsize"
Line 753
  "type" always "type"
Line 754
  ! always {!<=-1,!>=2}
Line 755
  "type" always "type"
Line 758
  typeattr always !0
  "strlen" always "strlen"
  == always {!<=-1,!>=2}
  0 always 0
Line 760
  typeattr always !0
  "argvalue" always "argvalue"
  == always {!<=-1,!>=2}
  0 always 0
Line 762
  typeattr always !0
  "sizeof" always "sizeof"
  == always {!<=-1,!>=2}
  0 always 0
Line 764
  typeattr always !0
  "mul" always "mul"
  == always {!<=-1,!>=2}
  0 always 0
Line 766
  typeattr always !0
  "value" always "value"
  == always {!<=-1,!>=2}
  0 always 0
Line 769
  typeattr always !0
Line 771
  == always {!<=-1,!>=2}
Line 772
  "value" always "value"
Line 773
  ! always {!<=-1,!>=2}
Line 774
  "value" always "value"
Line 775
  = always 0
  0 always 0
Line 777
  valueattr always !0
Line 779
  valueattr always !0
Line 781
  <= always {!<=-1,!>=2}
  0 always 0
Line 783
  0 always 0
Line 784
  = {!<=0,>=1}
  minsizevalue {!<=0,>=1}
Line 786
  "arg" always "arg"
Line 787
  ! always {!<=-1,!>=2}
Line 788
  "arg" always "arg"
Line 789
  ( always !<=-1
  argattr always !0
  != always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  argattr always !0
  0 always 0
  < always {!<=-1,!>=2}
  '0' always 48
  || always {!<=-1,!>=2}
  argattr always !0
  [ {!<=47,>=48}
  0 always 0
  > {!<=-1,!>=2,>=0}
  '9' always 57
Line 790
  argattr always !0
Line 792
  == always {!<=-1,!>=2}
  ? possible {2,1}
  2 always 2
  : always 1
  1 always 1
Line 793
  argattr always !0
  [ always {!<=47,!>=58}
  0 always 0
  - always {!<=-1,!>=10}
  '0' always 48
Line 794
  == always {!<=-1,!>=2}
Line 795
  "arg2" always "arg2"
Line 796
  ! always {!<=-1,!>=2}
Line 797
  "arg2" always "arg2"
Line 798
  ( always !<=-1
  arg2attr always !0
  != always {!<=-1,!>=2}
  1 always 1
  || always {!<=-1,!>=2}
  arg2attr always !0
  0 always 0
  < always {!<=-1,!>=2}
  '0' always 48
  || always {!<=-1,!>=2}
  arg2attr always !0
  [ {!<=47,>=48}
  0 always 0
  > {!<=-1,!>=2,>=0}
  '9' always 57
Line 799
  arg2attr always !0
Line 800
  = {!<=-1,>=0,!>=10,<=9}
  arg2attr always !0
  [ {!<=47,>=48,!>=58,<=57}
  0 always 0
  - {!<=-1,>=0,!>=10,<=9}
  '0' always 48
Line 805
  == always {!<=-1,!>=2}
  "iterator" always "iterator"
Line 806
  . always {!<=-1,!>=2}
  it always {!<=-1,!>=2}
  = always 1
  true always 1
Line 807
  "type" always "type"
Line 808
  . always {!<=-1,!>=2}
  first always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  str always !0
  "first" always "first"
  == always {!<=-1,!>=2}
  0 always 0
Line 809
  . always {!<=-1,!>=2}
  last always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  str always !0
  "last" always "last"
  == always {!<=-1,!>=2}
  0 always 0
Line 810
  "container" always "container"
  0 always 0
Line 816
  == always {!<=-1,!>=2}
  0 always 0
Line 817
  . always {!<=-1,!>=2}
  notnull always {!<=-1,!>=2}
  1 always 1
  : always 0
  0 always 0
Line 818
  functionnodename possible {size=9,size=4}
  == {!<=-1,!>=2,0}
  "ignorefunction" always "ignorefunction"
Line 819
  . always {!<=-1,!>=2}
  ignore always {!<=-1,!>=2}
  = always 1
  true always 1
Line 820
  functionnodename possible {size=4,size=9}
  == {!<=-1,!>=2,0}
  "formatstr" always "formatstr"
Line 821
  . always {!<=-1,!>=2}
  formatstr always {!<=-1,!>=2}
  = always 1
  true always 1
Line 822
  "scan" always "scan"
Line 823
  "secure" always "secure"
Line 824
  . always {!<=-1,!>=2}
  formatstr_scan always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  scan always !0
Line 825
  . always {!<=-1,!>=2}
  formatstr_secure always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  secure always !0
Line 826
  functionnodename possible size=9
  == {!<=-1,!>=2,0}
  "warn" always "warn"
Line 828
  "severity" always "severity"
Line 829
  == always {!<=-1,!>=2}
  nullptr always 0
Line 830
  "severity" always "severity"
Line 831
  severity always !0
Line 833
  "cstd" always "cstd"
Line 835
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cstd always !0
Line 836
  cstd always !0
Line 838
  = always 0
  :: always 0
  C89 always 0
Line 840
  "cppstd" always "cppstd"
Line 842
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cppstd always !0
Line 843
  cppstd always !0
Line 845
  = always 0
  :: always 0
  CPP03 always 0
Line 847
  "reason" always "reason"
Line 848
  "alternatives" always "alternatives"
Line 849
  && always {!<=-1,!>=2}
Line 851
  reason always !0
  " function '" always " function '"
  "' called. It is recommended to use " always "' called. It is recommended to use "
Line 852
  alternatives always !0
Line 853
  i always !<=-1
  = always 0
  0 always 0
  i {!<=-1,symbolic=(alt.size()-1),symbolic=(alt.size()-2),symbolic=(alt.size()-1+1),symbolic=(alt.size()-2+1),0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ {!<=0,symbolic=(alt.size()-1+1),symbolic=(alt.size()-2+1)}
  i {!<=-1,symbolic=(alt.size()-1),symbolic=(alt.size()-2)}
Line 854
  "'" always "'"
  i {!<=-1,symbolic=(alt.size()-1),symbolic=(alt.size()-2),<=symbolic=(alt.size()-1),!>=symbolic=(alt.size())}
  "'" always "'"
Line 855
  i {!<=-1,symbolic=(alt.size()-2),<=symbolic=(alt.size()-1),!>=symbolic=(alt.size())}
  == always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 856
  " instead." always " instead."
Line 857
  i always {!<=-1,!>=symbolic=(alt.size()),!symbolic=(alt.size()-1)}
  == always {!<=-1,!>=2}
  ( always {!<=-1,!symbolic=(i+1)}
  - always !<=-1
  2 always 2
Line 858
  " or " always " or "
Line 860
  ", " always ", "
Line 864
  ! always {!<=-1,!>=2}
Line 865
  "\"reason\" and \"alternatives\" or some text." always "\"reason\" and \"alternatives\" or some text."
Line 867
  = always !0
  message always !0
Line 871
  == always {!<=-1,!>=2}
  "container" always "container"
Line 872
  "action" always "action"
Line 875
  = always !0
  action_ptr always !0
Line 876
  actionName always !0
Line 877
  action always symbolic=(Container::actionFrom(actionName))
  == always {!<=-1,!>=2}
Line 878
  actionName always !0
Line 880
  = possible symbolic=(Container::actionFrom(actionName))
  action possible symbolic=(Container::actionFrom(actionName))
Line 882
  "yields" always "yields"
Line 885
  = always !0
  yield_ptr always !0
Line 886
  yieldName always !0
Line 887
  yield always symbolic=(Container::yieldFrom(yieldName))
  == always {!<=-1,!>=2}
Line 888
  yieldName always !0
Line 890
  = possible symbolic=(Container::yieldFrom(yieldName))
  yield possible symbolic=(Container::yieldFrom(yieldName))
Line 897
  ( always {!<=-1,!>=2}
Line 900
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ac always !0
  ( always {!<=-1,!>=2}
Line 901
  return always {!<=-1,!>=2}
  true always 1
Line 902
  ac always !0
  . always !size=0
  ( always !<=-1
  '.' always 46
  != always {!<=-1,!>=2}
Line 903
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 904
  nullptr always 0
Line 905
  ac always !0
  . always !size=0
Line 907
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 908
  return always {!<=-1,!>=2}
  true always 1
Line 909
  ( always {!<=-1,!>=2}
  "%num% : %num%" always "%num% : %num%"
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvalue {>=symbolic=(MathLib::toLongNumber(tok->str())),!<=symbolic=(MathLib::toLongNumber(tok->str())-1)}
  <= always {!<=-1,!>=2}
  2 always 2
Line 910
  return always {!<=-1,!>=2}
  true always 1
Line 911
  ( always {!<=-1,!>=2}
  "%num% : ," always "%num% : ,"
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 912
  return always {!<=-1,!>=2}
  true always 1
Line 913
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ": %num%" always ": %num%"
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  1 always 1
Line 914
  return always {!<=-1,!>=2}
  true always 1
Line 916
  return always {!<=-1,!>=2}
  false always 0
Line 919
  ( always {!<=-1,!>=2}
Line 922
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ac always !0
  ( always {!<=-1,!>=2}
Line 923
  return always {!<=-1,!>=2}
  true always 1
Line 924
  nullptr always 0
Line 925
  ac always !0
  . always !size=0
Line 927
  ( always {!<=-1,!>=2}
  "%num% : %num%" always "%num% : %num%"
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  argvalue possible >=symbolic=(MathLib::toDoubleNumber(tok->str()))
  <= always {!<=-1,!>=2}
  2 always 2
Line 928
  return always {!<=-1,!>=2}
  true always 1
Line 929
  ( always {!<=-1,!>=2}
  "%num% : ," always "%num% : ,"
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 930
  return always {!<=-1,!>=2}
  true always 1
Line 931
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always !0
  == always {!<=-1,!>=2}
  "," always ","
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ": %num%" always ": %num%"
  && always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
  1 always 1
Line 932
  return always {!<=-1,!>=2}
  true always 1
Line 933
  ( always {!<=-1,!>=2}
  "%num%" always "%num%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 934
  return always {!<=-1,!>=2}
  true always 1
Line 935
  ( always {!<=-1,!>=2}
  "! %num%" always "! %num%"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 936
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 938
  return always {!<=-1,!>=2}
  false always 0
Line 943
  ! always {!<=-1,!>=2}
  ftok possible symbolic=(ftok->astParent()->isUnaryOp("&")?ftok->astParent()->astOperand1():ftok->next()->astOperand1())@157
Line 944
  * always {!<=-1,!>=2}
  error possible lifetime[Address]=(error)@157
  = always 1
  true always 1
Line 945
  "" always ""
Line 947
  ftok {!0,symbolic=(ftok->astParent()->isUnaryOp("&")?ftok->astParent()->astOperand1():ftok->next()->astOperand1())@157}
  ( always {!<=-1,!>=2}
Line 948
  ftok always !0
Line 949
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 953
  "::" always "::"
  ftok always !0
Line 954
  ( possible lifetime[Iterator]=(functions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ftok always !0
Line 960
  ftok always !0
  ( possible size=1
  == {!<=-1,!>=2,0}
  "::" always "::"
Line 961
  ! always {!<=-1,!>=2}
  ftok always !0
Line 962
  ftok always !0
Line 963
  "::" always "::"
  ( always !0
Line 965
  == always {!<=-1,!>=2}
  "." always "."
  && always {!<=-1,!>=2}
Line 966
  ( always !0
Line 967
  ( always {!<=-1,!>=2}
Line 968
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 969
  "" always ""
Line 972
  type always !size=0
  "::" always "::"
Line 974
  * always {!<=-1,!>=2}
  = always 1
  true always 1
Line 975
  "" always ""
Line 980
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
  && always {!<=-1,!>=2}
  -1 always -1
  != always {!<=-1,!>=2}
  "&" always "&"
  || always {!<=-1,!>=2}
Line 981
  "" always ""
Line 985
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 986
  ( always !0
  ( always {!<=-1,!>=2}
  "&" always "&"
  ( always !0
Line 987
  tok always symbolic=(ftok->astParent()->isUnaryOp("&")?ftok->astParent()->astOperand1():ftok->next()->astOperand1())
  & {lifetime[Address]=(error),!0}
  error always 0
Line 988
  error always {!<=-1,!>=2}
Line 992
  ( always {!<=-1,!>=2}
  "." always "."
Line 993
  "" always ""
Line 994
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  "%name% ::" always "%name% ::"
Line 997
  -2 always -2
Line 998
  ( always {!<=-1,!>=2}
  "%name% ::" always "%name% ::"
Line 999
  "::" always "::"
Line 1000
  -2 always -2
Line 1005
  ( always {!<=-1,!>=2}
Line 1008
  ! {!<=-1,!>=2,1}
  arg possible 0
Line 1011
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1012
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1013
  return always {!<=-1,!>=2}
  true always 1
Line 1015
  return always {!<=-1,!>=2}
  arg possible 0
  && always {!<=-1,!>=2}
  arg always !0
  . always {!<=-1,!>=2}
  notnull always {!<=-1,!>=2}
Line 1018
  ( always {!<=-1,!>=2}
Line 1021
  ! {!<=-1,!>=2,1}
  arg possible 0
Line 1024
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1025
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1026
  return always {!<=-1,!>=2}
  true always 1
Line 1028
  && always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  arg always !0
  >= always {!<=-1,!>=2}
  1 always 1
Line 1029
  * always {!<=-1,!>=2}
  hasIndirect always !0
  = always 1
  true always 1
Line 1030
  return always {!<=-1,!>=2}
  arg possible 0
  && always {!<=-1,!>=2}
  arg always !0
  >= always {!<=-1,!>=2}
Line 1038
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(functions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  nullptr always 0
  : always 0
Line 1045
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(functions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  nullptr always 0
  : always 0
Line 1052
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(functions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  nullptr always 0
  : always 0
Line 1059
  && always {!<=-1,!>=2}
  af always !0
  == always {!<=-1,!>=2}
  af always !0
  : always 0
  0 always 0
Line 1066
  && always {!<=-1,!>=2}
  af always !0
  == always {!<=-1,!>=2}
  af always !0
  : always 0
  0 always 0
Line 1073
  && always {!<=-1,!>=2}
  af always !0
  == always {!<=-1,!>=2}
  af always !0
  : always 0
  0 always 0
Line 1079
  ( always {!<=-1,!>=2}
Line 1080
  nullptr always 0
Line 1081
  :: possible {symbolic=(functions.cend()),end=0}
  it1 possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1082
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1083
  nullptr always 0
Line 1084
  it1 always {!symbolic=(functions.cend()),!end=0}
Line 1085
  != always {!<=-1,!>=2}
  it1 always {!symbolic=(functions.cend()),!end=0}
Line 1086
  & {lifetime[Address]=(it2->second),!0}
Line 1087
  it1 always {!symbolic=(functions.cend()),!end=0}
  -1 always -1
Line 1088
  != always {!<=-1,!>=2}
  it1 always {!symbolic=(functions.cend()),!end=0}
Line 1089
  & {lifetime[Address]=(it3->second),!0}
Line 1090
  nullptr always 0
Line 1093
  ( always {!<=-1,!>=2}
Line 1096
  unknownFunc always !0
Line 1098
  ( always {!<=-1,!>=2}
  -2 always -2
  "!!{ ; }" always "!!{ ; }"
Line 1099
  -2 always -2
Line 1100
  ( always {!<=-1,!>=2}
  "<<" always "<<"
  && always {!<=-1,!>=2}
Line 1101
  ( always {!<=-1,!>=2}
  "(" always "("
  && always {!<=-1,!>=2}
Line 1102
  ( always {!<=-1,!>=2}
  "%name% (" always "%name% ("
Line 1103
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1106
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -2 always -2
  ") ; }" always ") ; }"
Line 1107
  return always {!<=-1,!>=2}
  false always 0
Line 1109
  -2 always -2
Line 1111
  ( always {!<=-1,!>=2}
  funcname always symbolic=(start)
  -3 always -3
  "( * %name% )" always "( * %name% )"
Line 1112
  funcname always symbolic=(start)
Line 1113
  -3 always -3
Line 1114
  funcname always symbolic=(start)
  ( always {!<=-1,!>=2}
Line 1115
  ( always {!<=-1,!>=2}
  start possible symbolic=(funcname)
  "%name%|.|::" always "%name%|.|::"
Line 1118
  return always {!<=-1,!>=2}
  false always 0
Line 1120
  ( always {!<=-1,!>=2}
  "[;{}]" always "[;{}]"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  "%name% )| (" always "%name% )| ("
Line 1121
  == always {!<=-1,!>=2}
  "exit" always "exit"
Line 1122
  return always {!<=-1,!>=2}
  true always 1
Line 1123
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1124
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1125
  unknownFunc always !0
Line 1126
  return always {!<=-1,!>=2}
  true always 1
Line 1129
  return always {!<=-1,!>=2}
  false always 0
Line 1132
  , always {!<=-1,!>=2}
  iterator always {!<=-1,!>=2}
Line 1134
  = {lifetime[Iterator]=(containers),start=0}
  ( {lifetime[Iterator]=(containers),start=0}
  i possible {lifetime[Iterator]=(containers),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(containers),end=0}
Line 1135
  i {lifetime[Iterator]=(containers),!symbolic=(containers.end()),!end=0}
Line 1136
  container always symbolic=(i->second)
  ( always {!<=-1,!>=2}
Line 1139
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  container always symbolic=(i->second)
  ( {lifetime[Object]=(container.startPattern2),lifetime[Object]=(startPattern2),!0}
Line 1142
  ! always {!<=-1,!>=2}
  iterator always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1143
  & {lifetime[Object]=(containers),!0}
Line 1145
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  tok always !0
Line 1147
  iterator always {!<=-1,!>=2}
Line 1148
  ( always {!<=-1,!>=2}
  ( always !0
  endPattern always symbolic=(iterator?container.itEndPattern:container.endPattern)
  ( {lifetime[Object]=(container.itEndPattern),lifetime[Object]=(itEndPattern),lifetime[Object]=(container.endPattern),lifetime[Object]=(endPattern),!0}
Line 1149
  & {lifetime[Object]=(containers),!0}
Line 1154
  nullptr always 0
Line 1162
  * always {!<=-1,!>=2}
  isIterator always !0
  = always 0
  false always 0
Line 1163
  c always !0
Line 1165
  true always 1
Line 1166
  && always {!<=-1,!>=2}
Line 1167
  * always {!<=-1,!>=2}
  isIterator always !0
  = always 1
  true always 1
Line 1168
  c possible 0
Line 1171
  ( always {!<=-1,!>=2}
Line 1173
  ! always {!<=-1,!>=2}
Line 1174
  return always {!<=-1,!>=2}
  false always 0
Line 1175
  cond always !0
  == always {!<=-1,!>=2}
  "(" always "("
Line 1176
  cond always !0
Line 1177
  tok always symbolic=(cond->astOperand1())
  && always {!<=-1,!>=2}
  tok {symbolic=(cond->astOperand1()),!0}
  == always {!<=-1,!>=2}
  "." always "."
Line 1178
  tok {symbolic=(cond->astOperand1()),!0}
  && always {!<=-1,!>=2}
  tok {symbolic=(cond->astOperand1()),!0}
  ( always !0
Line 1179
  tok {symbolic=(cond->astOperand1()),!0}
  ( always !0
  ( always !0
Line 1180
  return always {!<=-1,!>=2}
  tok {symbolic=(cond->astOperand1()),!0}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  container always !0
  tok {symbolic=(cond->astOperand1()),!0}
  ( always !0
Line 1182
  ! {!<=-1,!>=2,0}
  fallback possible size=0
  ( {!<=-1,!>=2,1}
Line 1183
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  cond always !0
  "( )" always "( )"
  && always {!<=-1,!>=2}
  cond always !0
  == always {!<=-1,!>=2}
Line 1187
  return always {!<=-1,!>=2}
  false always 0
Line 1191
  ( always {!<=-1,!>=2}
Line 1193
  && always {!<=-1,!>=2}
  ( always !0
  && always {!<=-1,!>=2}
  ( always !0
  . always !0
  != always {!<=-1,!>=2}
  :: always 0
  eGlobal always 0
Line 1194
  return always {!<=-1,!>=2}
  true always 1
Line 1198
  return always {!<=-1,!>=2}
  true always 1
Line 1200
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1203
  ( always {!<=-1,!>=2}
Line 1206
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1207
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1208
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  0 always 0
Line 1209
  = always 0
  0 always 0
Line 1210
  = always -1
  -1 always -1
Line 1211
  it always {!symbolic=(functions.cend()),!end=0}
  != always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1212
  > always {!<=-1,!>=2}
Line 1213
  = {>=symbolic=(args+1),!<=symbolic=(args)}
  . {>=symbolic=(args+1),!<=symbolic=(args)}
Line 1214
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  -1 always -1
  || always {!<=-1,!>=2}
  firstOptionalArg always !-1
  > always {!<=-1,!>=2}
Line 1217
  || always {!<=-1,!>=2}
Line 1218
  return always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 1220
  return always {!<=-1,!>=2}
  firstOptionalArg possible -1
  < {!<=-1,!>=2,1}
  0 always 0
  ? always {!<=-1,!>=2}
  args possible 0
  == always {!<=-1,!>=2}
  : always {!<=-1,!>=2}
  callargs possible {<=symbolic=(args),>=symbolic=(args+1)}
  >= always {!<=-1,!>=2}
  firstOptionalArg {!<=-1,>=0}
  - {!<=-2,>=-1}
  1 always 1
  && always {!<=-1,!>=2}
  callargs {>=symbolic=(firstOptionalArg-1),!<=symbolic=(firstOptionalArg-1-1)}
  <= always {!<=-1,!>=2}
Line 1225
  ( always {!<=-1,!>=2}
Line 1226
  nullptr always 0
Line 1227
  = possible lifetime[Iterator]=(functionwarn)
  ( possible lifetime[Iterator]=(functionwarn)
Line 1228
  i possible lifetime[Iterator]=(functionwarn)
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functionwarn),end=0}
Line 1229
  nullptr always 0
Line 1230
  & {lifetime[Object]=(functionwarn),!0}
  i {lifetime[Iterator]=(functionwarn),!symbolic=(functionwarn.cend()),!end=0}
Line 1233
  ( always {!<=-1,!>=2}
Line 1235
  ! always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  p always !0
Line 1236
  return always {!<=-1,!>=2}
  false always 0
Line 1238
  error always {!<=-1,!>=2}
  error always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1239
  range always {!<=-1,!>=2}
  range always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1240
  has_dot always {!<=-1,!>=2}
  has_dot always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1241
  has_E always {!<=-1,!>=2}
  has_E always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1243
  error always {!<=-1,!>=2}
  = {!<=-1,!>=2,0,1}
  * {58,45,43,44,46,69,101,33,!0}
  p always !0
  == {!<=-1,!>=2,0,1}
  '.' always 46
Line 1244
  * possible {58,45,43,44,46,69,101,33}
Line 1245
  ( possible 0
  * possible {58,45,43,44,46,69,101,33}
Line 1246
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '-' always 45
Line 1248
  * possible {45,43,44,46,69,101,33}
  == {!<=-1,!>=2,0}
  ':' always 58
Line 1249
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  range always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '.' always 46
Line 1250
  range always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1251
  has_dot always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1252
  has_E always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1254
  * {44,46,69,101,33,!58}
  == {!<=-1,!>=2,0}
  '-' always 45
  || {!<=-1,!>=2,0}
  * {44,46,69,101,33,!58,!45}
  == {!<=-1,!>=2,0}
  '+' always 43
Line 1255
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 1257
  * {46,69,101,33,!58,!45,!43}
  == {!<=-1,!>=2,0}
  ',' always 44
Line 1258
  range always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1259
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '.' always 46
Line 1260
  has_dot always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1261
  has_E always {!<=-1,!>=2}
  = always 0
  false always 0
Line 1262
  * {69,101,33,!58,!45,!43,!44}
  == {!<=-1,!>=2,0}
  '.' always 46
Line 1263
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  has_dot always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
Line 1264
  has_dot always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1265
  * {101,33,!58,!45,!43,!44,!46}
  == {!<=-1,!>=2,0}
  'E' always 69
  || {!<=-1,!>=2,0}
  * {33,!58,!45,!43,!44,!46,!69}
  == {!<=-1,!>=2,0}
  'e' always 101
Line 1266
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  has_E always {!<=-1,!>=2}
Line 1267
  has_E always {!<=-1,!>=2}
  = always 1
  true always 1
Line 1268
  * always {!58,!45,!43,!44,!46,!69,!101}
  == always {!<=-1,!>=2}
  '!' always 33
Line 1269
  error always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  1 always 1
  == always {!<=-1,!>=2}
  '-' always 45
  || always {!<=-1,!>=2}
  * always !45
  1 always 1
  == always {!<=-1,!>=2}
  '+' always 43
  || always {!<=-1,!>=2}
  * always {!45,!43}
  1 always 1
Line 1271
  return always {!<=-1,!>=2}
  false always 0
Line 1273
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  error {symbolic=(*p=='.'),!<=-1,!>=2}
Line 1276
  ( always {!<=-1,!>=2}
Line 1278
  ( always {!<=-1,!>=2}
Line 1279
  return always {!<=-1,!>=2}
  false always 0
Line 1281
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1282
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1283
  return always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1284
  return always {!<=-1,!>=2}
  false always 0
Line 1290
  = {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),start=0}
  ( {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),start=0}
  i possible {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),start=0}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),end=0}
Line 1291
  i {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),!symbolic=(argumentChecksFunc.cend()),!end=0}
Line 1292
  i {lifetime[Iterator]=(functions.at(getFunctionName(ftok)).argumentChecks),lifetime[Object]=(argumentChecks),!symbolic=(argumentChecksFunc.cend()),!end=0}
  1 always 1
Line 1295
  -1 always -1
Line 1298
  ( always {!<=-1,!>=2}
Line 1300
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  formatstr_scan always {!<=-1,!>=2}
Line 1303
  ( always {!<=-1,!>=2}
Line 1305
  return always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  formatstr_secure always {!<=-1,!>=2}
Line 1310
  ( always {!<=-1,!>=2}
Line 1311
  nullptr always 0
Line 1312
  = possible lifetime[Iterator]=(mNonOverlappingData)
  ( possible lifetime[Iterator]=(mNonOverlappingData)
Line 1313
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mNonOverlappingData),end=0}
  & {lifetime[Address]=(it->second),!0}
  it always {!symbolic=(mNonOverlappingData.cend()),!end=0}
  nullptr always 0
Line 1318
  ( always {!<=-1,!>=2}
Line 1319
  :: always 0
  NONE always 0
Line 1320
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1321
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1322
  it always {!symbolic=(functions.cend()),!end=0}
Line 1323
  :: always 0
  NONE always 0
Line 1328
  ( always {!<=-1,!>=2}
Line 1330
  :: possible {symbolic=(mReturnValue.end()),end=0}
  it possible {symbolic=(mReturnValue.end()),end=0}
  = possible lifetime[Iterator]=(mReturnValue)
  ( possible lifetime[Iterator]=(mReturnValue)
Line 1331
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReturnValue),end=0}
  it always {!symbolic=(mReturnValue.end()),!end=0}
Line 1336
  ( always {!<=-1,!>=2}
Line 1338
  :: possible {symbolic=(mReturnValueType.end()),end=0}
  it possible {symbolic=(mReturnValueType.end()),end=0}
  = possible lifetime[Iterator]=(mReturnValueType)
  ( possible lifetime[Iterator]=(mReturnValueType)
Line 1339
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReturnValueType),end=0}
  it always {!symbolic=(mReturnValueType.end()),!end=0}
Line 1344
  ( always {!<=-1,!>=2}
Line 1345
  -1 always -1
Line 1346
  :: possible {symbolic=(mReturnValueContainer.end()),end=0}
  it possible {symbolic=(mReturnValueContainer.end()),end=0}
  = possible lifetime[Iterator]=(mReturnValueContainer)
  ( possible lifetime[Iterator]=(mReturnValueContainer)
Line 1347
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReturnValueContainer),end=0}
  it always {!symbolic=(mReturnValueContainer.end()),!end=0}
  : always -1
  -1 always -1
Line 1352
  ( always {!<=-1,!>=2}
Line 1353
  ( always size=0
Line 1354
  = possible lifetime[Iterator]=(mUnknownReturnValues)
  ( possible lifetime[Iterator]=(mUnknownReturnValues)
Line 1355
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mUnknownReturnValues),end=0}
  ( always size=0
  it always {!symbolic=(mUnknownReturnValues.end()),!end=0}
Line 1360
  ( always {!<=-1,!>=2}
Line 1361
  nullptr always 0
Line 1362
  :: possible {symbolic=(functions.cend()),end=0}
  it1 possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1363
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1364
  nullptr always 0
Line 1365
  & {lifetime[Address]=(it1->second),!0}
  it1 always {!symbolic=(functions.cend()),!end=0}
Line 1369
  ( always {!<=-1,!>=2}
Line 1371
  ( always {!<=-1,!>=2}
Line 1372
  return always {!<=-1,!>=2}
  false always 0
Line 1373
  :: possible {symbolic=(functions.cend()),end=0}
  it1 possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1374
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1375
  return always {!<=-1,!>=2}
  false always 0
Line 1376
  it1 always {!symbolic=(functions.cend()),!end=0}
  != always {!<=-1,!>=2}
  it1 always {!symbolic=(functions.cend()),!end=0}
Line 1377
  ! always {!<=-1,!>=2}
Line 1378
  return always {!<=-1,!>=2}
  true always 1
Line 1380
  return always {!<=-1,!>=2}
  false always 0
Line 1387
  arg always !0
Line 1388
  ( always {!<=-1,!>=2}
Line 1390
  fs_argno possible {<=symbolic=(argnr),>=symbolic=(argnr+1)}
  >= always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
  fs_argno {>=0,!<=-1}
Line 1391
  ( always {!<=-1,!>=2}
Line 1400
  ( always {!<=-1,!>=2}
Line 1402
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1403
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1404
  return always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1405
  return always {!<=-1,!>=2}
  false always 0
Line 1407
  ( always {!<=-1,!>=2}
Line 1409
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1410
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1411
  return always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1412
  return always {!<=-1,!>=2}
  false always 0
Line 1414
  ( always {!<=-1,!>=2}
Line 1416
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1417
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1418
  return always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1419
  return always {!<=-1,!>=2}
  false always 0
Line 1421
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
Line 1423
  :: possible {symbolic=(functions.cend()),end=0}
  it possible {symbolic=(functions.cend()),end=0}
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1424
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
Line 1425
  return always {!<=-1,!>=2}
  pure always {!<=-1,!>=2}
  it always {!symbolic=(functions.cend()),!end=0}
  it always {!symbolic=(functions.cend()),!end=0}
Line 1426
  return always {!<=-1,!>=2}
  false always 0
Line 1428
  ( always {!<=-1,!>=2}
Line 1430
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1431
  return always {!<=-1,!>=2}
  true always 1
Line 1432
  ( always {!<=-1,!>=2}
Line 1433
  return always {!<=-1,!>=2}
  false always 0
Line 1434
  = possible lifetime[Iterator]=(functions)
  ( possible lifetime[Iterator]=(functions)
Line 1435
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(functions),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(functions.end()),!end=0}
Line 1438
  ( always {!<=-1,!>=2}
Line 1440
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1441
  return always {!<=-1,!>=2}
  true always 1
Line 1442
  ( always {!<=-1,!>=2}
Line 1443
  return always {!<=-1,!>=2}
  false always 0
Line 1444
  :: possible {symbolic=(mNoReturn.end()),end=0}
  it possible {symbolic=(mNoReturn.end()),end=0}
  = possible lifetime[Iterator]=(mNoReturn)
  ( possible lifetime[Iterator]=(mNoReturn)
Line 1445
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mNoReturn),end=0}
Line 1446
  return always {!<=-1,!>=2}
  false always 0
Line 1447
  it always {!symbolic=(mNoReturn.end()),!end=0}
  == always {!<=-1,!>=2}
Line 1448
  return always {!<=-1,!>=2}
  true always 1
Line 1449
  return always {!<=-1,!>=2}
  it always {!symbolic=(mNoReturn.end()),!end=0}
  == always {!<=-1,!>=2}
Line 1452
  ( always {!<=-1,!>=2}
Line 1454
  && always {!<=-1,!>=2}
  ( always !0
  ( always {!<=-1,!>=2}
Line 1455
  return always {!<=-1,!>=2}
  false always 0
Line 1456
  ( always {!<=-1,!>=2}
Line 1457
  return always {!<=-1,!>=2}
  false always 0
Line 1458
  :: possible {symbolic=(mNoReturn.end()),end=0}
  it possible {symbolic=(mNoReturn.end()),end=0}
  = possible lifetime[Iterator]=(mNoReturn)
  ( possible lifetime[Iterator]=(mNoReturn)
Line 1459
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mNoReturn),end=0}
Line 1460
  return always {!<=-1,!>=2}
  false always 0
Line 1461
  it always {!symbolic=(mNoReturn.end()),!end=0}
  == always {!<=-1,!>=2}
Line 1462
  return always {!<=-1,!>=2}
  false always 0
Line 1463
  return always {!<=-1,!>=2}
  it always {!symbolic=(mNoReturn.end()),!end=0}
  == always {!<=-1,!>=2}
Line 1466
  ( always {!<=-1,!>=2}
Line 1468
  return always {!<=-1,!>=2}
  ( possible lifetime[Iterator]=(mMarkupExtensions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mMarkupExtensions),end=0}
Line 1471
  ( always {!<=-1,!>=2}
Line 1473
  = possible lifetime[Iterator]=(mProcessAfterCode)
  ( possible lifetime[Iterator]=(mProcessAfterCode)
Line 1474
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mProcessAfterCode),end=0}
  || always {!<=-1,!>=2}
  it always {!symbolic=(mProcessAfterCode.end()),!end=0}
Line 1477
  ( always {!<=-1,!>=2}
Line 1479
  = possible lifetime[Iterator]=(mReportErrors)
  ( possible lifetime[Iterator]=(mReportErrors)
Line 1480
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mReportErrors),end=0}
  || always {!<=-1,!>=2}
  it always {!symbolic=(mReportErrors.end()),!end=0}
Line 1483
  ( always {!<=-1,!>=2}
Line 1485
  = possible lifetime[Iterator]=(mExecutableBlocks)
  ( possible lifetime[Iterator]=(mExecutableBlocks)
Line 1486
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExecutableBlocks),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mExecutableBlocks.end()),!end=0}
Line 1491
  = always -1
  -1 always -1
Line 1492
  :: possible {symbolic=(mExecutableBlocks.end()),end=0}
  map_it possible {symbolic=(mExecutableBlocks.end()),end=0}
Line 1493
  = possible lifetime[Iterator]=(mExecutableBlocks)
  ( possible lifetime[Iterator]=(mExecutableBlocks)
Line 1495
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExecutableBlocks),end=0}
Line 1496
  map_it always {!symbolic=(mExecutableBlocks.end()),!end=0}
Line 1498
  offset possible -1
Line 1503
  :: possible {symbolic=(mExecutableBlocks.end()),end=0}
  map_it possible {symbolic=(mExecutableBlocks.end()),end=0}
Line 1504
  = possible lifetime[Iterator]=(mExecutableBlocks)
  ( possible lifetime[Iterator]=(mExecutableBlocks)
Line 1506
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExecutableBlocks),end=0}
Line 1507
  map_it always {!symbolic=(mExecutableBlocks.end()),!end=0}
Line 1514
  :: possible {symbolic=(mExecutableBlocks.end()),end=0}
  map_it possible {symbolic=(mExecutableBlocks.end()),end=0}
Line 1515
  = possible lifetime[Iterator]=(mExecutableBlocks)
  ( possible lifetime[Iterator]=(mExecutableBlocks)
Line 1517
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mExecutableBlocks),end=0}
Line 1518
  map_it always {!symbolic=(mExecutableBlocks.end()),!end=0}
Line 1523
  ( always {!<=-1,!>=2}
Line 1525
  = possible lifetime[Iterator]=(mKeywords)
Line 1526
  ( possible lifetime[Iterator]=(mKeywords)
Line 1527
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mKeywords),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mKeywords.end()),!end=0}
Line 1530
  ( always {!<=-1,!>=2}
Line 1532
  = possible lifetime[Iterator]=(mImporters)
Line 1533
  ( possible lifetime[Iterator]=(mImporters)
Line 1534
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mImporters),end=0}
  && always {!<=-1,!>=2}
  it always {!symbolic=(mImporters.end()),!end=0}
  > always {!<=-1,!>=2}
  0 always 0
Line 1539
  ! always {!<=-1,!>=2}
Line 1540
  nullptr always 0
Line 1541
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  ". %name% (" always ". %name% ("
Line 1542
  tok always !0
  -2 always -2
Line 1543
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1544
  nullptr always 0
Line 1545
  && always {!<=-1,!>=2}
Line 1546
  . always !0
  tok always !0
  -1 always -1
  == always {!<=-1,!>=2}
Line 1548
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "empty ( )" always "empty ( )"
Line 1550
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  -1 always -1
  "size|length ( )" always "size|length ( )"
Line 1552
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 1553
  this always !0
  tok always !0
Line 1554
  f always !0
  == always {!<=-1,!>=2}
Line 1555
  tok always !0
Line 1559
  nullptr always 0
Line 1565
  ! always {!<=-1,!>=2}
Line 1566
  nullptr always 0
Line 1567
  ( always {!<=-1,!>=2}
  tok always !0
  -2 always -2
  ". %name% (" always ". %name% ("
Line 1568
  tok always !0
  -2 always -2
Line 1569
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1570
  nullptr always 0
Line 1571
  && always {!<=-1,!>=2}
Line 1572
  . always !0
  tok always !0
  -1 always -1
  == always {!<=-1,!>=2}
Line 1574
  ( always {!<=-1,!>=2}
  -1 always -1
  "empty ( )" always "empty ( )"
Line 1576
  ( always {!<=-1,!>=2}
  tok always !0
  "%name% (" always "%name% ("
Line 1577
  this always !0
  tok always !0
Line 1578
  f always !0
  == always {!<=-1,!>=2}
Line 1579
  tok always !0
Line 1583
  nullptr always 0
Line 1586
  ( always {!<=-1,!>=2}
Line 1588
  return always {!<=-1,!>=2}
Line 1594
  ( always {!<=-1,!>=2}
  "%name%|::" always "%name%|::"
Line 1598
  = possible lifetime[Iterator]=(smartPointers)
  ( possible lifetime[Iterator]=(smartPointers)
  typestr possible size=0
Line 1599
  it {lifetime[Iterator]=(smartPointers),symbolic=(smartPointers.find(typestr))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(smartPointers),end=0}
Line 1600
  nullptr always 0
Line 1601
  & {lifetime[Object]=(smartPointers),!0}
  it {lifetime[Iterator]=(smartPointers),symbolic=(smartPointers.find(typestr)),!symbolic=(smartPointers.end()),!end=0}
Line 1606
  ! always {!<=-1,!>=2}
Line 1607
  nullptr always 0
Line 1610
  tok always !0
  ( always {!<=-1,!>=2}
  "*" always "*"
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  tok always !0
Line 1611
  tok always !0
Line 1612
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1614
  != always {!<=-1,!>=2}
  :: always 4
  Address always 4
Line 1619
  ! always {!<=-1,!>=2}
  tok always !0
Line 1620
  nullptr always 0
Line 1621
  tok always !0
  ( always !0
Line 1626
  = possible lifetime[Iterator]=(mTypeChecks)
  ( possible lifetime[Iterator]=(mTypeChecks)
Line 1627
  it {lifetime[Iterator]=(mTypeChecks),symbolic=(mTypeChecks.find(std::pair<std::string,std::string>(check,typeName)))}
  == always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mTypeChecks),end=0}
  it {lifetime[Iterator]=(mTypeChecks),symbolic=(mTypeChecks.find(std::pair<std::string,std::string>(check,typeName))),!symbolic=(mTypeChecks.end()),!end=0}
Line 1634
  = always !0
  ( always !0
Line 1636
  "return " always "return "
  ";" always ";"
Line 1638
  ! always {!<=-1,!>=2}
  tokenList {symbolic=(std::make_shared<TokenList>(settings)),!0}
  ( always {!<=-1,!>=2}
Line 1639
  nullptr always 0
Line 1644
  tokenList {symbolic=(std::make_shared<TokenList>(settings)),!0}
Line 1645
  ( always {!<=-1,!>=2}
  "[!<>=] =" always "[!<>=] ="
Line 1646
  "=" always "="
Line 1648
  ( possible size=1
  == always {!<=-1,!>=2}
  "(" always "("
Line 1650
  == always {!<=-1,!>=2}
  ")" always ")"
Line 1651
  ( always {!<=-1,!>=2}
Line 1652
  nullptr always 0
Line 1653
  lpar always !size=0
Line 1654
  lpar always !size=0
Line 1657
  ! {!<=-1,!>=2,0}
  lpar possible size=0
  ( {!<=-1,!>=2,1}
Line 1658
  nullptr always 0
Line 1662
  0 always 0
  3 always 3
  "arg" always "arg"
  != always {!<=-1,!>=2}
  0 always 0
Line 1664
  ( {lifetime[Object]=(tok2->str()),!0}
  + {lifetime[Object]=(tok2->str()),!3}
  3 always 3
Line 1667
  lookupVarId always !0
Line 1673
  expr always symbolic=(tokenList->front()->astOperand1())
