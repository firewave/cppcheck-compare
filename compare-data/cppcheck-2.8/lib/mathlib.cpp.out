

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var2 ;
42: double mDoubleValue@var3 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var4 ;
44: bool mIsUnsigned@var5 ;
45:
46: void promote ( const value & v@var6 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var7 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var4 !=@expr1073742153 Type ::@expr1073742154 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var4 ==@expr1073742155 Type ::@expr1073742156 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073742157 ) ?@expr1073742158 mDoubleValue@var3 :@expr1073742159 (@expr1073742160 double ) mIntValue@var2 ;
60: }
61:
62: static value calc ( char op@var8 , const value & v1@var9 , const value & v2@var10 ) ;
63: int compare ( const value & v@var11 ) const ;
64: value add ( int v@var12 ) const ;
65: value shiftLeft ( const value & v@var13 ) const ;
66: value shiftRight ( const value & v@var14 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var15 ;
72:
73: static long long toLongNumber ( const std :: string & str@var16 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var17 ) ;
75:
|
498:
499: static std :: string toString<double> ( double value@var18 ) ;
76: template < class T > static std :: string toString ( T value@var19 ) {
77: std ::@expr1073742161 ostringstream result@var20 ;
78: result@var20 <<@expr1073742162 value@var19 ;
79: return result@var20 .@expr1073742163 str (@expr1073742164 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var21 ) ;
82:
83: static bool isInt ( const std :: string & str@var22 ) ;
84: static bool isFloat ( const std :: string & str@var23 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var24 ) ;
86: static bool isNegative ( const std :: string & str@var25 ) ;
87: static bool isPositive ( const std :: string & str@var26 ) ;
88: static bool isDec ( const std :: string & str@var27 ) ;
89: static bool isFloatHex ( const std :: string & str@var28 ) ;
90: static bool isIntHex ( const std :: string & str@var29 ) ;
91: static bool isOct ( const std :: string & str@var30 ) ;
92: static bool isBin ( const std :: string & str@var31 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var32 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var33 , bool supportMicrosoftExtensions@var34 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var35 , const std :: string & second@var36 ) ;
105: static std :: string subtract ( const std :: string & first@var37 , const std :: string & second@var38 ) ;
106: static std :: string multiply ( const std :: string & first@var39 , const std :: string & second@var40 ) ;
107: static std :: string divide ( const std :: string & first@var41 , const std :: string & second@var42 ) ;
108: static std :: string mod ( const std :: string & first@var43 , const std :: string & second@var44 ) ;
109: static std :: string incdec ( const std :: string & var@var45 , const std :: string & op@var46 ) ;
110: static std :: string calculate ( const std :: string & first@var47 , const std :: string & second@var48 , char action@var49 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var50 ) ;
113: static std :: string cos ( const std :: string & tok@var51 ) ;
114: static std :: string tan ( const std :: string & tok@var52 ) ;
115: static std :: string abs ( const std :: string & tok@var53 ) ;
116: static bool isEqual ( const std :: string & first@var54 , const std :: string & second@var55 ) ;
117: static bool isNotEqual ( const std :: string & first@var56 , const std :: string & second@var57 ) ;
118: static bool isGreater ( const std :: string & first@var58 , const std :: string & second@var59 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var60 , const std :: string & second@var61 ) ;
120: static bool isLess ( const std :: string & first@var62 , const std :: string & second@var63 ) ;
121: static bool isLessEqual ( const std :: string & first@var64 , const std :: string & second@var65 ) ;
122: static bool isNullValue ( const std :: string & str@var66 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var67 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var68 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var69 , std :: string :: size_type iPos@var70 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var71 , const MathLib :: value & v2@var72 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var73 , const MathLib :: value & v2@var74 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var75 , const MathLib :: value & v2@var76 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var77 , const MathLib :: value & v2@var78 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var79 , const MathLib :: value & v2@var80 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var81 , const MathLib :: value & v2@var82 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var83 , const MathLib :: value & v2@var84 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var85 , const MathLib :: value & v2@var86 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var87 , const MathLib :: value & v2@var88 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var89 , const MathLib :: value & v2@var90 ) ;
150:
151: template < > std :: string MathLib :: toString<double> ( double value@var91 ) ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var92 , const std :: string & errorMsg@var93 , Type type@var94 = INTERNAL ) ;
38: const Token * token@var95 ;
39: std :: string errorMessage@var96 ;
40: Type type@var97 ;
41: std :: string id@var98 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var99 ) ;
117: static SeverityType fromString ( const std :: string & severity@var100 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var101 ) : id@var102 ( cweId@var101 ) { }
122: unsigned short id@var102 ;
123: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var103 ) const {
35: return p@var103 .@expr1073742165 first@var104 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var105 ) const {
42: return p@var105 .@expr1073742166 second@var106 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var107 , const T & x@var108 )
48: {
49: return std ::@expr1073742167 find (@expr1073742168 r@var107 .@expr1073742169 begin (@expr1073742170 ) , r@var107 .@expr347 end (@expr348 ) , x@var108 ) !=@expr1073742173 r@var107 .@expr347 end (@expr348 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var109 , const T & x@var110 )
54: {
55: return std ::@expr1073742176 find (@expr1073742177 r@var109 .@expr1073742178 begin (@expr1073742179 ) , r@var109 .@expr356 end (@expr357 ) , x@var110 ) !=@expr1073742182 r@var109 .@expr356 end (@expr357 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var111 , const U & x@var112 )
60: {
61: return std ::@expr1073742185 find (@expr1073742186 r@var111 .@expr1073742187 begin (@expr1073742188 ) , r@var111 .@expr365 end (@expr366 ) , x@var112 ) !=@expr1073742191 r@var111 .@expr365 end (@expr366 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var113 ) const
68: {
69: return static_cast < unsigned long > (@expr1073742194 t@var113 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var114 , char c@var115 )
74: {
75: return !@expr1073742195 str@var114 .@expr1073742196 empty (@expr1073742197 ) &&@expr1073742198 str@var114 .@expr1073742199 back (@expr1073742200 ) ==@expr1073742201 c@var115 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var116 , const char end@var117 [ ] , unsigned long endlen@var118 )
79: {
80: return (@expr378 str@var116 .@expr379 size (@expr380 ) >=@expr1073742205 endlen@var118 ) &&@expr1073742206 (@expr378 str@var116 .@expr1073742208 compare (@expr1073742209 str@var116 .@expr379 size (@expr380 ) -@expr1073742212 endlen@var118 , endlen@var118 , end@var117 ) ==@expr1073742213 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var119 , const char ( & end@var120 ) [ N ] )
85: {
86: return endsWith (@expr1073742215 str@var119 , end@var120 , N@expr1073742214 -@expr1073742216 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var121 , char q@var122 , const std :: string & p@var123 )
90: {
91: if (@expr1073742217 !@expr1073742218 endsWith (@expr1073742219 str@var121 , q@var122 ) ) {
92: return false ; }
93: if (@expr1073742220 (@expr1073742221 str@var121 .@expr1073742222 length (@expr1073742223 ) +@expr1073742224 1 ) >@expr1073742225 p@var123 .@expr1073742226 length (@expr1073742227 ) &&@expr1073742228 (@expr1073742229 str@var121 .@expr1073742230 compare (@expr1073742231 0 , p@var123 .@expr1073742232 size (@expr1073742233 ) +@expr1073742234 1 , p@var123 +@expr1073742235 q@var122 ) ==@expr1073742236 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var124 , char q@var125 )
99: {
100: static const std ::@expr413 vector < std ::@expr413 string > suffixes@var126 {@expr1073742239 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073742240 const std ::@expr413 string &@expr1073742242 p@var127 :@expr1073742243 suffixes@var126 ) {
102: if (@expr1073742244 isPrefixStringCharLiteral (@expr1073742245 str@var124 , q@var125 , p@var127 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var128 )
109: {
110: return isStringCharLiteral (@expr1073742246 str@var128 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var129 )
114: {
115: return isStringCharLiteral (@expr1073742247 str@var129 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var130 , char q@var131 )
119: {
120: const unsigned long quotePos@var132 =@expr1073742248 str@var130 .@expr1073742249 find (@expr1073742250 q@var131 ) ;
121: return str@var130 .@expr1073742251 substr (@expr1073742252 quotePos@var132 +@expr1073742253 1U , str@var130 .@expr1073742254 size (@expr1073742255 ) -@expr1073742256 quotePos@var132 -@expr1073742257 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var133 )
125: {
126: if (@expr1073742258 isStringLiteral (@expr1073742259 str@var133 ) ) {
127: return getStringCharLiteral (@expr1073742260 str@var133 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var134 )
132: {
133: if (@expr1073742261 isCharLiteral (@expr1073742262 str@var134 ) ) {
134: return getStringCharLiteral (@expr1073742263 str@var134 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var135 )
139: {
140: if (@expr1073742264 i@var135 ==@expr1073742265 1 ) {
141: return "st" ; }
142: if (@expr1073742266 i@var135 ==@expr1073742267 2 ) {
143: return "nd" ; }
144: if (@expr1073742268 i@var135 ==@expr1073742269 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var136 , const std :: string & rhs@var137 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var138 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var139 , const std :: string & name@var140 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var141 , const std :: string & name@var142 ) ;
156:
157: void strTolower ( std :: string & str@var143 ) ;

##file cppcheck-2.8/lib/mathlib.cpp

1:
|
44:
45: const int MathLib :: bigint_bits@var15 = 64 ;
46:
47: MathLib :: value :: value ( const std :: string & s@var144 ) :
48: mIntValue@var2 ( 0 ) , mDoubleValue@var3 ( 0 ) , mIsUnsigned@var5 ( false )
49: {
50: if (@expr1073742270 MathLib ::@expr1073742271 isFloat (@expr1073742272 s@var144 ) ) {
51: mType@var4 =@expr1073742273 MathLib ::@expr450 value ::@expr451 Type ::@expr1073742276 FLOAT ;
52: mDoubleValue@var3 =@expr1073742277 MathLib ::@expr1073742278 toDoubleNumber (@expr1073742279 s@var144 ) ;
53: return ;
54: }
55:
56: if (@expr1073742280 !@expr1073742281 MathLib ::@expr1073742282 isInt (@expr1073742283 s@var144 ) ) {
57: throw InternalError (@expr1073742284 nullptr , "Invalid value: " +@expr1073742285 s@var144 ) ; }
58:
59: mType@var4 =@expr1073742286 MathLib ::@expr450 value ::@expr451 Type ::@expr465 INT ;
60: mIntValue@var2 =@expr1073742290 MathLib ::@expr1073742291 toLongNumber (@expr1073742292 s@var144 ) ;
61:
62: if (@expr1073742293 isIntHex (@expr1073742294 s@var144 ) &&@expr1073742295 mIntValue@var2 <@expr1073742296 0 ) {
63: mIsUnsigned@var5 =@expr1073742297 true ; }
64:
65:
66: if (@expr1073742298 s@var144 .@expr475 size (@expr476 ) >=@expr1073742301 2U ) {
67: for (@expr1073742302 unsigned long i@var145 =@expr1073742303 s@var144 .@expr475 size (@expr476 ) -@expr1073742306 1U ; i@var145 >@expr1073742307 0U ; --@expr1073742308 i@var145 ) {
68: const char c@var146 =@expr1073742309 s@var144 [@expr1073742310 i@var145 ] ;
69: if (@expr1073742311 c@var146 ==@expr1073742312 'u' ||@expr1073742313 c@var146 ==@expr1073742314 'U' ) {
70: mIsUnsigned@var5 =@expr1073742315 true ; }
71: else { if (@expr1073742316 c@var146 ==@expr1073742317 'l' ||@expr1073742318 c@var146 ==@expr1073742319 'L' ) {
72: if (@expr1073742320 mType@var4 ==@expr1073742321 MathLib ::@expr450 value ::@expr451 Type ::@expr465 INT ) {
73: mType@var4 =@expr1073742325 MathLib ::@expr450 value ::@expr451 Type ::@expr504 LONG ; }
74: else { if (@expr1073742329 mType@var4 ==@expr1073742330 MathLib ::@expr450 value ::@expr451 Type ::@expr504 LONG ) {
75: mType@var4 =@expr1073742334 MathLib ::@expr450 value ::@expr451 Type ::@expr513 LONGLONG ; } }
76: } else { if (@expr1073742338 i@var145 >@expr1073742339 2U &&@expr1073742340 c@var146 ==@expr1073742341 '4' &&@expr1073742342 s@var144 [@expr1073742343 i@var145 -@expr1073742344 1 ] ==@expr1073742345 '6' &&@expr1073742346 s@var144 [@expr1073742347 i@var145 -@expr1073742348 2 ] ==@expr1073742349 'i' ) {
77: mType@var4 =@expr1073742350 MathLib ::@expr450 value ::@expr451 Type ::@expr513 LONGLONG ; } } }
78: }
79: }
80: }
81:
82: std :: string MathLib :: value :: str ( ) const
83: {
84: std ::@expr1073742355 ostringstream ostr@var147 ;
85: if (@expr1073742356 mType@var4 ==@expr1073742357 MathLib ::@expr534 value ::@expr535 Type ::@expr1073742360 FLOAT ) {
86: if (@expr1073742361 $std $::@expr1073742362 $isnan $(@expr1073742363 mDoubleValue@var3 $) ) {
87: return "nan.0" ; }
88: if (@expr1073742364 $std $::@expr1073742365 $isinf $(@expr1073742366 mDoubleValue@var3 $) ) {
89: return (@expr1073742367 mDoubleValue@var3 >@expr1073742368 0 ) ?@expr1073742369 "inf.0" :@expr1073742370 "-inf.0" ; }
90:
91: ostr@var147 .@expr1073742371 precision (@expr1073742372 9 ) ;
92: ostr@var147 <<@expr1073742373 std ::@expr1073742374 fixed@expr1073742354 <<@expr1073742375 mDoubleValue@var3 ;
93:
94:
95: std ::@expr1073742376 string ret@var148 (@expr1073742377 ostr@var147 .@expr554 str (@expr555 ) ) ;
96: std ::@expr1073742380 string ::@expr1073742381 size_type pos@var149 ; pos@var149 =@expr1073742382 ret@var148 .@expr1073742383 size (@expr1073742384 ) -@expr1073742385 1U ;
97: while (@expr1073742386 ret@var148 [@expr563 pos@var149 ] ==@expr1073742388 '0' ) {
98: pos@var149 --@expr1073742389 ; }
99: if (@expr1073742390 ret@var148 [@expr563 pos@var149 ] ==@expr1073742392 '.' ) {
100: ++@expr1073742393 pos@var149 ; }
101:
102: return ret@var148 .@expr1073742394 substr (@expr1073742395 0 , pos@var149 +@expr1073742396 1 ) ;
103: }
104:
105: if (@expr1073742397 mIsUnsigned@var5 ) {
106: ostr@var147 <<@expr1073742398 static_cast < unsigned long long > (@expr1073742399 mIntValue@var2 ) <<@expr1073742400 "U" ; }
107: else {
108: ostr@var147 <<@expr1073742401 mIntValue@var2 ; }
109: if (@expr1073742402 mType@var4 ==@expr1073742403 MathLib ::@expr534 value ::@expr535 Type ::@expr1073742406 LONG ) {
110: ostr@var147 <<@expr1073742407 "L" ; }
111: else { if (@expr1073742408 mType@var4 ==@expr1073742409 MathLib ::@expr534 value ::@expr535 Type ::@expr1073742412 LONGLONG ) {
112: ostr@var147 <<@expr1073742413 "LL" ; } }
113: return ostr@var147 .@expr554 str (@expr555 ) ;
114: }
115:
116: void MathLib :: value :: promote ( const MathLib :: value & v@var150 )
117: {
118: if (@expr1073742416 isInt (@expr1073742417 ) &&@expr1073742418 v@var150 .@expr1073742419 isInt (@expr1073742420 ) ) {
119: if (@expr1073742421 mType@var4 <@expr1073742422 v@var150 .@expr599 mType@var151 ) {
120: mType@var4 =@expr1073742424 v@var150 .@expr599 mType@var151 ;
121: mIsUnsigned@var5 =@expr1073742426 v@var150 .@expr603 mIsUnsigned@var152 ;
122: } else { if (@expr1073742428 mType@var4 ==@expr1073742429 v@var150 .@expr599 mType@var151 ) {
123: mIsUnsigned@var5 |=@expr1073742431 v@var150 .@expr603 mIsUnsigned@var152 ;
124: } }
125: } else { if (@expr1073742433 !@expr1073742434 isFloat (@expr1073742435 ) ) {
126: mIsUnsigned@var5 =@expr1073742436 false ;
127: mDoubleValue@var3 =@expr1073742437 mIntValue@var2 ;
128: mType@var4 =@expr1073742438 MathLib ::@expr1073742439 value ::@expr1073742440 Type ::@expr1073742441 FLOAT ;
129: } }
130: }
131:
132:
133: MathLib :: value MathLib :: value :: calc ( char op@var153 , const MathLib :: value & v1@var154 , const MathLib :: value & v2@var155 )
134: {
135: value temp@var156 (@expr1073742442 v1@var154 ) ;
136: temp@var156 .@expr1073742443 promote (@expr1073742444 v2@var155 ) ;
137: if (@expr1073742445 temp@var156 .@expr1073742446 isFloat (@expr1073742447 ) ) {
138: switch (@expr624 op@var153 ) {
139: case '+' :@expr625 ;
140: temp@var156 .@expr626 mDoubleValue@var157 +=@expr1073742451 v2@var155 .@expr628 getDoubleValue (@expr629 ) ;
141: break ;
142: case '-' :@expr625 ;
143: temp@var156 .@expr626 mDoubleValue@var157 -=@expr1073742456 v2@var155 .@expr628 getDoubleValue (@expr629 ) ;
144: break ;
145: case '*' :@expr625 ;
146: temp@var156 .@expr626 mDoubleValue@var157 *=@expr1073742461 v2@var155 .@expr628 getDoubleValue (@expr629 ) ;
147: break ;
148: case '/' :@expr625 ;
149: temp@var156 .@expr626 mDoubleValue@var157 /=@expr1073742466 v2@var155 .@expr628 getDoubleValue (@expr629 ) ;
150: break ;
151: case '%' :@expr625
152: case '&' :@expr625
153: case '|' :@expr625
154: case '^' :@expr625 ;
155: throw InternalError (@expr1073742473 nullptr , "Invalid calculation" ) ;
156: default :@expr625 ;
157: throw InternalError (@expr651 nullptr , "Unhandled calculation" ) ;
158: }
159: } else { if (@expr1073742476 temp@var156 .@expr1073742477 mIsUnsigned@var158 ) {
160: switch (@expr624 op@var153 ) {
161: case '+' :@expr625 ;
162: temp@var156 .@expr656 mIntValue@var159 +=@expr1073742481 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
163: break ;
164: case '-' :@expr625 ;
165: temp@var156 .@expr656 mIntValue@var159 -=@expr1073742486 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
166: break ;
167: case '*' :@expr625 ;
168: temp@var156 .@expr656 mIntValue@var159 *=@expr1073742491 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
169: break ;
170: case '/' :@expr625 ;
171: if (@expr671 v2@var155 .@expr659 mIntValue@var160 ==@expr673 0 ) {
172: throw InternalError (@expr674 nullptr , "Internal Error: Division by zero" ) ; }
173: if (@expr675 v1@var154 .@expr676 mIntValue@var161 ==@expr677 std ::@expr678 numeric_limits < long long > ::@expr679 min (@expr680 ) &&@expr681 std ::@expr682 abs (@expr683 v2@var155 .@expr659 mIntValue@var160 ) <=@expr685 1 ) {
174: throw InternalError (@expr686 nullptr , "Internal Error: Division overflow" ) ; }
175: temp@var156 .@expr656 mIntValue@var159 /=@expr1073742512 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
176: break ;
177: case '%' :@expr625 ;
178: if (@expr671 v2@var155 .@expr659 mIntValue@var160 ==@expr673 0 ) {
179: throw InternalError (@expr674 nullptr , "Internal Error: Division by zero" ) ; }
180: temp@var156 .@expr656 mIntValue@var159 %=@expr1073742521 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
181: break ;
182: case '&' :@expr625 ;
183: temp@var156 .@expr656 mIntValue@var159 &=@expr1073742526 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
184: break ;
185: case '|' :@expr625 ;
186: temp@var156 .@expr656 mIntValue@var159 |=@expr1073742531 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
187: break ;
188: case '^' :@expr625 ;
189: temp@var156 .@expr656 mIntValue@var159 ^=@expr1073742536 (@expr658 unsigned long long ) v2@var155 .@expr659 mIntValue@var160 ;
190: break ;
191: default :@expr625 ;
192: throw InternalError (@expr651 nullptr , "Unhandled calculation" ) ;
193: }
194: } else {
195: switch (@expr624 op@var153 ) {
196: case '+' :@expr625 ;
197: temp@var156 .@expr656 mIntValue@var159 +=@expr1073742544 v2@var155 .@expr659 mIntValue@var160 ;
198: break ;
199: case '-' :@expr625 ;
200: temp@var156 .@expr656 mIntValue@var159 -=@expr1073742548 v2@var155 .@expr659 mIntValue@var160 ;
201: break ;
202: case '*' :@expr625 ;
203: temp@var156 .@expr656 mIntValue@var159 *=@expr1073742552 v2@var155 .@expr659 mIntValue@var160 ;
204: break ;
205: case '/' :@expr625 ;
206: if (@expr671 v2@var155 .@expr659 mIntValue@var160 ==@expr673 0 ) {
207: throw InternalError (@expr674 nullptr , "Internal Error: Division by zero" ) ; }
208: if (@expr675 v1@var154 .@expr676 mIntValue@var161 ==@expr677 std ::@expr678 numeric_limits < long long > ::@expr679 min (@expr680 ) &&@expr681 std ::@expr682 abs (@expr683 v2@var155 .@expr659 mIntValue@var160 ) <=@expr685 1 ) {
209: throw InternalError (@expr686 nullptr , "Internal Error: Division overflow" ) ; }
210: temp@var156 .@expr656 mIntValue@var159 /=@expr1073742572 v2@var155 .@expr659 mIntValue@var160 ;
211: break ;
212: case '%' :@expr625 ;
213: if (@expr671 v2@var155 .@expr659 mIntValue@var160 ==@expr673 0 ) {
214: throw InternalError (@expr674 nullptr , "Internal Error: Division by zero" ) ; }
215: temp@var156 .@expr656 mIntValue@var159 %=@expr1073742580 v2@var155 .@expr659 mIntValue@var160 ;
216: break ;
217: case '&' :@expr625 ;
218: temp@var156 .@expr656 mIntValue@var159 &=@expr1073742584 v2@var155 .@expr659 mIntValue@var160 ;
219: break ;
220: case '|' :@expr625 ;
221: temp@var156 .@expr656 mIntValue@var159 |=@expr1073742588 v2@var155 .@expr659 mIntValue@var160 ;
222: break ;
223: case '^' :@expr625 ;
224: temp@var156 .@expr656 mIntValue@var159 ^=@expr1073742592 v2@var155 .@expr659 mIntValue@var160 ;
225: break ;
226: default :@expr625 ;
227: throw InternalError (@expr651 nullptr , "Unhandled calculation" ) ;
228: }
229: } }
230: return temp@var156 ;
231: }
232:
233:
234: int MathLib :: value :: compare ( const MathLib :: value & v@var162 ) const
235: {
236: value temp@var163 (@expr1073742596 *@expr1073742597 this@expr1073742598 ) ;
237: temp@var163 .@expr1073742599 promote (@expr1073742600 v@var162 ) ;
238:
239: if (@expr1073742601 temp@var163 .@expr1073742602 isFloat (@expr1073742603 ) ) {
240: if (@expr1073742604 temp@var163 .@expr781 mDoubleValue@var164 <@expr1073742606 v@var162 .@expr783 getDoubleValue (@expr784 ) ) {
241: return -1 ; }
242: if (@expr1073742609 temp@var163 .@expr781 mDoubleValue@var164 >@expr1073742611 v@var162 .@expr783 getDoubleValue (@expr784 ) ) {
243: return 1 ; }
244: return 0 ;
245: }
246:
247: if (@expr1073742614 temp@var163 .@expr1073742615 mIsUnsigned@var165 ) {
248: if (@expr1073742616 (@expr793 unsigned long long ) mIntValue@var2 <@expr1073742618 (@expr795 unsigned long long ) v@var162 .@expr796 mIntValue@var166 ) {
249: return -1 ; }
250: if (@expr1073742621 (@expr793 unsigned long long ) mIntValue@var2 >@expr1073742623 (@expr795 unsigned long long ) v@var162 .@expr796 mIntValue@var166 ) {
251: return 1 ; }
252: return 0 ;
253: }
254:
255: if (@expr1073742626 mIntValue@var2 <@expr1073742627 v@var162 .@expr796 mIntValue@var166 ) {
256: return -1 ; }
257: if (@expr1073742629 mIntValue@var2 >@expr1073742630 v@var162 .@expr796 mIntValue@var166 ) {
258: return 1 ; }
259: return 0 ;
260: }
261:
262: MathLib :: value MathLib :: value :: add ( int v@var167 ) const
263: {
264: MathLib ::@expr1073742632 value temp@var168 (@expr1073742633 *@expr1073742634 this@expr1073742635 ) ;
265: if (@expr1073742636 temp@var168 .@expr1073742637 isInt (@expr1073742638 ) ) {
266: temp@var168 .@expr1073742639 mIntValue@var169 +=@expr1073742640 v@var167 ; }
267: else {
268: temp@var168 .@expr1073742641 mDoubleValue@var170 +=@expr1073742642 v@var167 ; }
269: return temp@var168 ;
270: }
271:
272: MathLib :: value MathLib :: value :: shiftLeft ( const MathLib :: value & v@var171 ) const
273: {
274: if (@expr1073742643 !@expr1073742644 isInt (@expr1073742645 ) ||@expr1073742646 !@expr1073742647 v@var171 .@expr1073742648 isInt (@expr1073742649 ) ) {
275: throw InternalError (@expr1073742650 nullptr , "Shift operand is not integer" ) ; }
276: MathLib ::@expr1073742651 value ret@var172 (@expr1073742652 *@expr1073742653 this@expr1073742654 ) ;
277: if (@expr1073742655 v@var171 .@expr832 mIntValue@var173 >=@expr1073742657 MathLib ::@expr1073742658 bigint_bits@var15 ) {
278: return ret@var172 ;
279: }
280: ret@var172 .@expr1073742659 mIntValue@var174 <<=@expr1073742660 v@var171 .@expr832 mIntValue@var173 ;
281: return ret@var172 ;
282: }
283:
284: MathLib :: value MathLib :: value :: shiftRight ( const MathLib :: value & v@var175 ) const
285: {
286: if (@expr1073742662 !@expr1073742663 isInt (@expr1073742664 ) ||@expr1073742665 !@expr1073742666 v@var175 .@expr1073742667 isInt (@expr1073742668 ) ) {
287: throw InternalError (@expr1073742669 nullptr , "Shift operand is not integer" ) ; }
288: MathLib ::@expr1073742670 value ret@var176 (@expr1073742671 *@expr1073742672 this@expr1073742673 ) ;
289: if (@expr1073742674 v@var175 .@expr851 mIntValue@var177 >=@expr1073742676 MathLib ::@expr1073742677 bigint_bits@var15 ) {
290: return ret@var176 ;
291: }
292: ret@var176 .@expr1073742678 mIntValue@var178 >>=@expr1073742679 v@var175 .@expr851 mIntValue@var177 ;
293: return ret@var176 ;
294: }
295:
296:
297: unsigned long long MathLib :: toULongNumber ( const std :: string & str@var179 )
298: {
299:
300: if (@expr1073742681 isIntHex (@expr1073742682 str@var179 ) ) {
301: try {
302: const unsigned long long ret@var180 =@expr1073742683 std ::@expr860 stoull (@expr1073742685 str@var179 , nullptr , 16 ) ;
303: return ret@var180 ;
304: } catch (@expr1073742686 const std ::@expr863 out_of_range & e@var181 ) {
305: throw InternalError (@expr1073742688 nullptr , "Internal Error. MathLib::toULongNumber: out_of_range: " +@expr865 str@var179 +@expr866 " (" +@expr1073742691 e@var181 .@expr1073742692 what (@expr1073742693 ) +@expr1073742694 ")" ) ;
306: }
307: }
308:
309:
310: if (@expr1073742695 isOct (@expr1073742696 str@var179 ) ) {
311: try {
312: const unsigned long long ret@var182 =@expr1073742697 std ::@expr860 stoull (@expr1073742699 str@var179 , nullptr , 8 ) ;
313: return ret@var182 ;
314: } catch (@expr1073742700 const std ::@expr863 out_of_range & e@var183 ) {
315: throw InternalError (@expr1073742702 nullptr , "Internal Error. MathLib::toULongNumber: out_of_range: " +@expr865 str@var179 +@expr866 " (" +@expr1073742705 e@var183 .@expr1073742706 what (@expr1073742707 ) +@expr1073742708 ")" ) ;
316: }
317: }
318:
319:
320: if (@expr1073742709 isBin (@expr1073742710 str@var179 ) ) {
321: unsigned long long ret@var184 ; ret@var184 =@expr1073742711 0 ;
322: for (@expr1073742712 std ::@expr889 string ::@expr889 size_type i@var185 =@expr1073742715 str@var179 [@expr1073742716 0 ] ==@expr1073742717 '0' ?@expr1073742718 2 :@expr1073742719 3 ; i@var185 <@expr1073742720 str@var179 .@expr1073742721 length (@expr1073742722 ) ; i@var185 ++@expr1073742723 ) {
323: if (@expr1073742724 str@var179 [@expr901 i@var185 ] !=@expr1073742726 '1' &&@expr1073742727 str@var179 [@expr901 i@var185 ] !=@expr1073742729 '0' ) {
324: break ; }
325: ret@var184 <<=@expr1073742730 1 ;
326: if (@expr1073742731 str@var179 [@expr901 i@var185 ] ==@expr1073742733 '1' ) {
327: ret@var184 |=@expr1073742734 1 ; }
328: }
329:
330:
331: return ret@var184 ;
332: }
333:
334: if (@expr1073742735 isFloat (@expr1073742736 str@var179 ) ) {
335:
336:
337: const double doubleval@var186 =@expr1073742737 std ::@expr1073742738 atof (@expr1073742739 str@var179 .@expr1073742740 c_str (@expr1073742741 ) ) ;
338: if (@expr1073742742 doubleval@var186 >@expr1073742743 (@expr1073742744 double ) std ::@expr921 numeric_limits < unsigned long long > ::@expr922 max (@expr923 ) ) {
339: return std ::@expr921 numeric_limits < unsigned long long > ::@expr922 max (@expr923 ) ; }
340: else {
341: return static_cast < unsigned long long > (@expr1073742751 doubleval@var186 ) ; }
342: }
343:
344: try {
345: const unsigned long long ret@var187 =@expr1073742752 std ::@expr860 stoull (@expr1073742754 str@var179 , nullptr , 10 ) ;
346: return ret@var187 ;
347: } catch (@expr1073742755 const std ::@expr863 out_of_range & e@var188 ) {
348: throw InternalError (@expr1073742757 nullptr , "Internal Error. MathLib::toULongNumber: out_of_range: " +@expr865 str@var179 +@expr866 " (" +@expr1073742760 e@var188 .@expr1073742761 what (@expr1073742762 ) +@expr1073742763 ")" ) ;
349: }
350: }
351:
352: unsigned int MathLib :: encodeMultiChar ( const std :: string & str@var189 )
353: {
354: unsigned int retval@var190 ; retval@var190 =@expr1073742764 0 ;
355: for (@expr1073742765 char it@var191 :@expr1073742766 str@var189 ) {
356: retval@var190 =@expr1073742767 (@expr1073742768 retval@var190 <<@expr1073742769 8 ) |@expr1073742770 it@var191 ;
357: }
358: return retval@var190 ;
359: }
360:
361: long long MathLib :: toLongNumber ( const std :: string & str@var192 )
362: {
363:
364: if (@expr1073742771 isIntHex (@expr1073742772 str@var192 ) ) {
365: try {
366: const unsigned long long ret@var193 =@expr1073742773 std ::@expr950 stoull (@expr1073742775 str@var192 , nullptr , 16 ) ;
367: return (@expr1073742776 long long ) ret@var193 ;
368: } catch (@expr1073742777 const std ::@expr954 out_of_range & e@var194 ) {
369: throw InternalError (@expr1073742779 nullptr , "Internal Error. MathLib::toLongNumber: out_of_range: " +@expr956 str@var192 +@expr957 " (" +@expr1073742782 e@var194 .@expr1073742783 what (@expr1073742784 ) +@expr1073742785 ")" ) ;
370: }
371: }
372:
373:
374: if (@expr1073742786 isOct (@expr1073742787 str@var192 ) ) {
375: try {
376: const unsigned long long ret@var195 =@expr1073742788 std ::@expr950 stoull (@expr1073742790 str@var192 , nullptr , 8 ) ;
377: return ret@var195 ;
378: } catch (@expr1073742791 const std ::@expr954 out_of_range & e@var196 ) {
379: throw InternalError (@expr1073742793 nullptr , "Internal Error. MathLib::toLongNumber: out_of_range: " +@expr956 str@var192 +@expr957 " (" +@expr1073742796 e@var196 .@expr1073742797 what (@expr1073742798 ) +@expr1073742799 ")" ) ;
380: }
381: }
382:
383:
384: if (@expr1073742800 isBin (@expr1073742801 str@var192 ) ) {
385: long long ret@var197 ; ret@var197 =@expr1073742802 0 ;
386: for (@expr1073742803 std ::@expr980 string ::@expr980 size_type i@var198 =@expr1073742806 str@var192 [@expr983 0 ] ==@expr1073742808 '0' ?@expr1073742809 2 :@expr1073742810 3 ; i@var198 <@expr1073742811 str@var192 .@expr1073742812 length (@expr1073742813 ) ; i@var198 ++@expr1073742814 ) {
387: if (@expr1073742815 str@var192 [@expr992 i@var198 ] !=@expr1073742817 '1' &&@expr1073742818 str@var192 [@expr992 i@var198 ] !=@expr1073742820 '0' ) {
388: break ; }
389: ret@var197 <<=@expr1073742821 1 ;
390: if (@expr1073742822 str@var192 [@expr992 i@var198 ] ==@expr1073742824 '1' ) {
391: ret@var197 |=@expr1073742825 1 ; }
392: }
393: if (@expr1073742826 str@var192 [@expr983 0 ] ==@expr1073742828 '-' ) {
394: ret@var197 =@expr1073742829 -@expr1073742830 ret@var197 ; }
395: return ret@var197 ;
396: }
397:
398: if (@expr1073742831 isFloat (@expr1073742832 str@var192 ) ) {
399:
400:
401: const double doubleval@var199 =@expr1073742833 toDoubleNumber (@expr1073742834 str@var192 ) ;
402: if (@expr1073742835 doubleval@var199 >@expr1073742836 (@expr1073742837 double ) std ::@expr1014 numeric_limits < long long > ::@expr1015 max (@expr1016 ) ) {
403: return std ::@expr1014 numeric_limits < long long > ::@expr1015 max (@expr1016 ) ; }
404: else { if (@expr1073742844 doubleval@var199 <@expr1073742845 (@expr1073742846 double ) std ::@expr1014 numeric_limits < long long > ::@expr1024 min (@expr1025 ) ) {
405: return std ::@expr1014 numeric_limits < long long > ::@expr1024 min (@expr1025 ) ; }
406: else {
407: return static_cast < long long > (@expr1073742853 doubleval@var199 ) ; } }
408: }
409:
410: if (@expr1073742854 isCharLiteral (@expr1073742855 str@var192 ) ) {
411: return simplecpp ::@expr1073742856 characterLiteralToLL (@expr1073742857 str@var192 ) ; }
412:
413: try {
414: const unsigned long long ret@var200 =@expr1073742858 std ::@expr950 stoull (@expr1073742860 str@var192 , nullptr , 10 ) ;
415: return ret@var200 ;
416: } catch (@expr1073742861 const std ::@expr954 out_of_range & e@var201 ) {
417: throw InternalError (@expr1073742863 nullptr , "Internal Error. MathLib::toLongNumber: out_of_range: " +@expr956 str@var192 +@expr957 " (" +@expr1073742866 e@var201 .@expr1073742867 what (@expr1073742868 ) +@expr1073742869 ")" ) ;
418: }
419: }
420:
421:
422: static double myStod ( const std :: string & str@var202 , std :: string :: const_iterator from@var203 , std :: string :: const_iterator to@var204 , int base@var205 )
423: {
424: double result@var206 ; result@var206 =@expr1073742871 0. ;
425: bool positivesign@var207 ; positivesign@var207 =@expr1073742872 true ;
426: std ::@expr1049 string ::@expr1073742874 const_iterator it@var208 ;
427: if (@expr1073742875 '+' ==@expr1073742876 *@expr1053 from@var203 ) {
428: it@var208 =@expr1073742878 from@var203 +@expr1055 1 ;
429: } else { if (@expr1073742880 '-' ==@expr1073742881 *@expr1053 from@var203 ) {
430: it@var208 =@expr1073742883 from@var203 +@expr1055 1 ;
431: positivesign@var207 =@expr1073742885 false ;
432: } else {
433: it@var208 =@expr1073742886 from@var203 ; } }
434: const unsigned long decimalsep@var209 =@expr1073742887 str@var202 .@expr1073742888 find (@expr1073742889 '.' , it@var208 -@expr1073742890 str@var202 .@expr1067 begin (@expr1068 ) ) ;
435: int distance@var210 ;
436: if (@expr1073742893 std ::@expr1049 string ::@expr1073742895 npos@expr1073742870 ==@expr1073742896 decimalsep@var209 ) {
437: distance@var210 =@expr1073742897 to@var204 -@expr1073742898 it@var208 ;
438: } else { if (@expr1073742899 decimalsep@var209 >@expr1073742900 (@expr1073742901 to@var204 -@expr1073742902 str@var202 .@expr1067 begin (@expr1068 ) ) ) {
439: return 0. ; }
440: else {
441: distance@var210 =@expr1073742905 int (@expr1073742906 decimalsep@var209 ) -@expr1073742907 (@expr1073742908 from@var203 -@expr1073742909 str@var202 .@expr1067 begin (@expr1068 ) ) ; } }
442: auto digitval@var211 ; digitval@var211 =@expr1073742912 [@expr1073742913 &@expr1073742914 ] (@expr1073742915 char c@var212 ) {
443: if (@expr1073742916 (@expr1073742917 10 <@expr1073742918 base@var205 ) &&@expr1073742919 (@expr1073742920 c@var212 >@expr1073742921 '9' ) ) {
444: return 10 +@expr1073742922 std ::@expr1073742923 tolower (@expr1073742924 c@var212 ) -@expr1073742925 'a' ; }
445: else {
446: return c@var212 -@expr1073742926 '0' ; }
447: } ;
448: for (@expr1073742927 ; it@var208 !=@expr1073742928 to@var204 ; ++@expr1073742929 it@var208 ) {
449: if (@expr1073742930 '.' ==@expr1073742931 *@expr1108 it@var208 ) {
450: continue ; }
451: else {
452: --@expr1073742933 distance@var210 ; }
453: result@var206 +=@expr1073742934 digitval@var211 (@expr1073742935 *@expr1108 it@var208 ) *@expr1073742937 std ::@expr1073742938 pow (@expr1073742939 base@var205 , distance@var210 ) ;
454: }
455: return positivesign@var207 ?@expr1073742940 result@var206 :@expr1073742941 -@expr1073742942 result@var206 ;
456: }
457:
458:
459:
460: static double floatHexToDoubleNumber ( const std :: string & str@var213 )
461: {
462: const unsigned long p@var214 =@expr1073742943 str@var213 .@expr1073742944 find_first_of (@expr1073742945 "pP" , 3 ) ;
463: const double factor1@var215 =@expr1073742946 myStod (@expr1073742947 str@var213 , str@var213 .@expr1124 begin (@expr1125 ) +@expr1073742950 2 , str@var213 .@expr1124 begin (@expr1125 ) +@expr1129 p@var214 , 16 ) ;
464: const bool suffix@var216 =@expr1073742954 (@expr1073742955 str@var213 .@expr1132 back (@expr1133 ) ==@expr1073742958 'f' ) ||@expr1073742959 (@expr1073742960 str@var213 .@expr1132 back (@expr1133 ) ==@expr1073742963 'F' ) ||@expr1073742964 (@expr1073742965 str@var213 .@expr1132 back (@expr1133 ) ==@expr1073742968 'l' ) ||@expr1073742969 (@expr1073742970 str@var213 .@expr1132 back (@expr1133 ) ==@expr1073742973 'L' ) ;
465: const double exponent@var217 =@expr1073742974 myStod (@expr1073742975 str@var213 , str@var213 .@expr1124 begin (@expr1125 ) +@expr1129 p@var214 +@expr1073742979 1 , suffix@var216 ?@expr1073742980 str@var213 .@expr1157 end (@expr1158 ) -@expr1073742983 1 :@expr1073742984 str@var213 .@expr1157 end (@expr1158 ) , 10 ) ;
466: const double factor2@var218 =@expr1073742987 std ::@expr1073742988 pow (@expr1073742989 2 , exponent@var217 ) ;
467: return factor1@var215 *@expr1073742990 factor2@var218 ;
468: }
469:
470: double MathLib :: toDoubleNumber ( const std :: string & str@var219 )
471: {
472: if (@expr1073742991 isCharLiteral (@expr1073742992 str@var219 ) ) {
473: try {
474: return simplecpp ::@expr1073742993 characterLiteralToLL (@expr1073742994 str@var219 ) ;
475: } catch (@expr1073742995 const std ::@expr1073742996 exception & e@var220 ) {
476: throw InternalError (@expr1073742997 nullptr , "Internal Error. MathLib::toLongNumber: characterLiteralToLL(" +@expr1073742998 str@var219 +@expr1073742999 ") => " +@expr1073743000 e@var220 .@expr1073743001 what (@expr1073743002 ) ) ;
477: }
478: }
479: if (@expr1073743003 isIntHex (@expr1073743004 str@var219 ) ) {
480: return static_cast < double > (@expr1073743005 toLongNumber (@expr1073743006 str@var219 ) ) ; }
481:
482: if (@expr1073743007 isNullValue (@expr1073743008 str@var219 ) ) {
483: return 0.0 ; }
484:
|
488:
489: if (@expr1073743009 isFloatHex (@expr1073743010 str@var219 ) ) {
490: return floatHexToDoubleNumber (@expr1073743011 str@var219 ) ; }
491:
492: std ::@expr1073743012 istringstream istr@var221 (@expr1073743013 str@var219 ) ;
493: istr@var221 .@expr1073743014 imbue (@expr1073743015 std ::@expr1073743016 locale ::@expr1073743017 classic (@expr1073743018 ) ) ;
494: double ret@var222 ;
495: istr@var221 >>@expr1073743019 ret@var222 ;
496: return ret@var222 ;
497: }
498:
499: std :: string MathLib :: toString<double> ( double value@var223 )
500: {
501: std ::@expr1073743021 ostringstream result@var224 ;
502: result@var224 .@expr1073743022 precision (@expr1073743023 12 ) ;
503: result@var224 <<@expr1073743024 value@var223 ;
504: if (@expr1073743025 result@var224 .@expr1202 str (@expr1203 ) ==@expr1073743028 "-0" ) {
505: return "0.0" ; }
506: if (@expr1073743029 result@var224 .@expr1202 str (@expr1203 ) .@expr1073743032 find (@expr1073743033 '.' ) ==@expr1073743034 std ::@expr1073743035 string ::@expr1073743036 npos@expr1073743020 ) {
507: return result@var224 .@expr1202 str (@expr1203 ) +@expr1073743039 ".0" ; }
508: return result@var224 .@expr1202 str (@expr1203 ) ;
509: }
510:
511: bool MathLib :: isFloat ( const std :: string & str@var225 )
512: {
513: return isDecimalFloat (@expr1073743042 str@var225 ) ||@expr1073743043 isFloatHex (@expr1073743044 str@var225 ) ;
514: }
515:
516: bool MathLib :: isDecimalFloat ( const std :: string & str@var226 )
517: {
518: if (@expr1073743051 str@var226 .@expr1073743052 empty (@expr1073743053 ) ) {
519: return false ; }
520: enum class State {
521: START , BASE_DIGITS1 , LEADING_DECIMAL , TRAILING_DECIMAL , BASE_DIGITS2 , E , MANTISSA_PLUSMINUS , MANTISSA_DIGITS , SUFFIX_F , SUFFIX_L
522: } ; enum State state@var227 ; state@var227 =@expr1073743054 State ::@expr1231 START@expr1073743045 ;
523: std ::@expr1073743056 string ::@expr1073743057 const_iterator it@var228 ; it@var228 =@expr1073743058 str@var226 .@expr1073743059 begin (@expr1073743060 ) ;
524: if (@expr1237 '+' ==@expr1238 *@expr1239 it@var228 ||@expr1240 '-' ==@expr1241 *@expr1239 it@var228 ) {
525: ++@expr1073743067 it@var228 ; }
526: for (@expr1073743068 ; it@var228 !=@expr1073743069 str@var226 .@expr1073743070 end (@expr1073743071 ) ; ++@expr1073743072 it@var228 ) {
527: switch (@expr1073743073 state@var227 ) {
528: case State ::@expr1231 START :@expr1251 ;
529: if (@expr1252 *@expr1239 it@var228 ==@expr1254 '.' ) {
530: state@var227 =@expr1073743079 State ::@expr1256 LEADING_DECIMAL ; }
531: else { if (@expr1257 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
532: state@var227 =@expr1073743086 State ::@expr1263 BASE_DIGITS1 ; }
533: else {
534: return false ; } }
535: break ;
536: case State ::@expr1256 LEADING_DECIMAL :@expr1251 ;
537: if (@expr1257 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
538: state@var227 =@expr1073743095 State ::@expr1272 BASE_DIGITS2 ; }
539: else {
540: return false ; }
541: break ;
542: case State ::@expr1263 BASE_DIGITS1 :@expr1251 ;
543: if (@expr1275 *@expr1239 it@var228 ==@expr1277 'e' ||@expr1278 *@expr1239 it@var228 ==@expr1280 'E' ) {
544: state@var227 =@expr1073743105 State ::@expr1282 E ; }
545: else { if (@expr1252 *@expr1239 it@var228 ==@expr1254 '.' ) {
546: state@var227 =@expr1073743110 State ::@expr1287 TRAILING_DECIMAL ; }
547: else { if (@expr1288 !@expr1289 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
548: return false ; } } }
549: break ;
550: case State ::@expr1287 TRAILING_DECIMAL :@expr1251 ;
551: if (@expr1275 *@expr1239 it@var228 ==@expr1277 'e' ||@expr1278 *@expr1239 it@var228 ==@expr1280 'E' ) {
552: state@var227 =@expr1073743126 State ::@expr1282 E ; }
553: else { if (@expr1304 *@expr1239 it@var228 ==@expr1306 'f' ||@expr1307 *@expr1239 it@var228 ==@expr1309 'F' ) {
554: state@var227 =@expr1073743134 State ::@expr1311 SUFFIX_F ; }
555: else { if (@expr1312 *@expr1239 it@var228 ==@expr1314 'l' ||@expr1315 *@expr1239 it@var228 ==@expr1317 'L' ) {
556: state@var227 =@expr1073743142 State ::@expr1319 SUFFIX_L ; }
557: else { if (@expr1257 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
558: state@var227 =@expr1073743149 State ::@expr1272 BASE_DIGITS2 ; }
559: else {
560: return false ; } } } }
561: break ;
562: case State ::@expr1272 BASE_DIGITS2 :@expr1251 ;
563: if (@expr1275 *@expr1239 it@var228 ==@expr1277 'e' ||@expr1278 *@expr1239 it@var228 ==@expr1280 'E' ) {
564: state@var227 =@expr1073743159 State ::@expr1282 E ; }
565: else { if (@expr1304 *@expr1239 it@var228 ==@expr1306 'f' ||@expr1307 *@expr1239 it@var228 ==@expr1309 'F' ) {
566: state@var227 =@expr1073743167 State ::@expr1311 SUFFIX_F ; }
567: else { if (@expr1312 *@expr1239 it@var228 ==@expr1314 'l' ||@expr1315 *@expr1239 it@var228 ==@expr1317 'L' ) {
568: state@var227 =@expr1073743175 State ::@expr1319 SUFFIX_L ; }
569: else { if (@expr1288 !@expr1289 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
570: return false ; } } } }
571: break ;
572: case State ::@expr1282 E :@expr1251 ;
573: if (@expr1237 *@expr1239 it@var228 ==@expr1238 '+' ||@expr1240 *@expr1239 it@var228 ==@expr1241 '-' ) {
574: state@var227 =@expr1073743191 State ::@expr1368 MANTISSA_PLUSMINUS ; }
575: else { if (@expr1257 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
576: state@var227 =@expr1073743198 State ::@expr1375 MANTISSA_DIGITS ; }
577: else {
578: return false ; } }
579: break ;
580: case State ::@expr1368 MANTISSA_PLUSMINUS :@expr1251 ;
581: if (@expr1288 !@expr1289 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
582: return false ; }
583: else {
584: state@var227 =@expr1073743208 State ::@expr1375 MANTISSA_DIGITS ; }
585: break ;
586: case State ::@expr1375 MANTISSA_DIGITS :@expr1251 ;
587: if (@expr1304 *@expr1239 it@var228 ==@expr1306 'f' ||@expr1307 *@expr1239 it@var228 ==@expr1309 'F' ) {
588: state@var227 =@expr1073743218 State ::@expr1311 SUFFIX_F ; }
589: else { if (@expr1312 *@expr1239 it@var228 ==@expr1314 'l' ||@expr1315 *@expr1239 it@var228 ==@expr1317 'L' ) {
590: state@var227 =@expr1073743226 State ::@expr1319 SUFFIX_L ; }
591: else { if (@expr1288 !@expr1289 std ::@expr1258 isdigit (@expr1259 static_cast < unsigned char > (@expr1260 *@expr1239 it@var228 ) ) ) {
592: return false ; } } }
593: break ;
594: case State ::@expr1311 SUFFIX_F :@expr1251 ;
595: return false ;
596: case State ::@expr1319 SUFFIX_L :@expr1251 ;
597: return false ;
598: }
599: }
600: return (@expr1073743238 state@var227 ==@expr1073743239 State ::@expr1272 BASE_DIGITS2@expr1073743046 ||@expr1073743241 state@var227 ==@expr1073743242 State ::@expr1375 MANTISSA_DIGITS@expr1073743047 ||@expr1073743244 state@var227 ==@expr1073743245 State ::@expr1287 TRAILING_DECIMAL@expr1073743048 ||@expr1073743247 state@var227 ==@expr1073743248 State ::@expr1311 SUFFIX_F@expr1073743049 ||@expr1073743250 state@var227 ==@expr1073743251 State ::@expr1319 SUFFIX_L@expr1073743050 ) ;
601: }
602:
603: bool MathLib :: isNegative ( const std :: string & str@var229 )
604: {
605: if (@expr1073743253 str@var229 .@expr1073743254 empty (@expr1073743255 ) ) {
606: return false ; }
607: return (@expr1073743256 str@var229 [@expr1073743257 0 ] ==@expr1073743258 '-' ) ;
608: }
609:
610: bool MathLib :: isPositive ( const std :: string & str@var230 )
611: {
612: if (@expr1073743259 str@var230 .@expr1073743260 empty (@expr1073743261 ) ) {
613: return false ; }
614: return !@expr1073743262 MathLib ::@expr1073743263 isNegative (@expr1073743264 str@var230 ) ;
615: }
616:
617: static bool isValidIntegerSuffixIt ( std :: string :: const_iterator it@var231 , std :: string :: const_iterator end@var232 , bool supportMicrosoftExtensions@var233 = true )
618: {
619: enum class Status { START , SUFFIX_U , SUFFIX_UL , SUFFIX_ULL , SUFFIX_L , SUFFIX_LU , SUFFIX_LL , SUFFIX_LLU , SUFFIX_I , SUFFIX_I6 , SUFFIX_I64 , SUFFIX_UI , SUFFIX_UI6 , SUFFIX_UI64 } ; enum Status state@var234 ; state@var234 =@expr1073743275 Status ::@expr1452 START@expr1073743265 ;
620: for (@expr1073743277 ; it@var231 !=@expr1073743278 end@var232 ; ++@expr1073743279 it@var231 ) {
621: switch (@expr1073743280 state@var234 ) {
622: case Status ::@expr1452 START :@expr1458 ;
623: if (@expr1459 *@expr1460 it@var231 ==@expr1461 'u' ||@expr1462 *@expr1460 it@var231 ==@expr1464 'U' ) {
624: state@var234 =@expr1073743289 Status ::@expr1466 SUFFIX_U ; }
625: else { if (@expr1467 *@expr1460 it@var231 ==@expr1469 'l' ||@expr1470 *@expr1460 it@var231 ==@expr1472 'L' ) {
626: state@var234 =@expr1073743297 Status ::@expr1474 SUFFIX_L@expr1442 ; }
627: else { if (@expr1475 supportMicrosoftExtensions@var233 &&@expr1476 (@expr1073743301 *@expr1460 it@var231 ==@expr1479 'i' ||@expr1480 *@expr1460 it@var231 ==@expr1482 'I' ) ) {
628: state@var234 =@expr1073743307 Status ::@expr1484 SUFFIX_I ; }
629: else {
630: return false ; } } }
631: break ;
632: case Status ::@expr1466 SUFFIX_U :@expr1458 ;
633: if (@expr1467 *@expr1460 it@var231 ==@expr1469 'l' ||@expr1470 *@expr1460 it@var231 ==@expr1472 'L' ) {
634: state@var234 =@expr1073743317 Status ::@expr1494 SUFFIX_UL ; }
635: else { if (@expr1475 supportMicrosoftExtensions@var233 &&@expr1476 (@expr1073743321 *@expr1460 it@var231 ==@expr1479 'i' ||@expr1480 *@expr1460 it@var231 ==@expr1482 'I' ) ) {
636: state@var234 =@expr1073743327 Status ::@expr1504 SUFFIX_UI ; }
637: else {
638: return false ; } }
639: break ;
640: case Status ::@expr1494 SUFFIX_UL :@expr1458 ;
641: if (@expr1467 *@expr1460 it@var231 ==@expr1469 'l' ||@expr1470 *@expr1460 it@var231 ==@expr1472 'L' ) {
642: state@var234 =@expr1073743337 Status ::@expr1514 SUFFIX_ULL ; }
643: else {
644: return false ; }
645: break ;
646: case Status ::@expr1474 SUFFIX_L :@expr1458 ;
647: if (@expr1459 *@expr1460 it@var231 ==@expr1461 'u' ||@expr1462 *@expr1460 it@var231 ==@expr1464 'U' ) {
648: state@var234 =@expr1073743347 Status ::@expr1524 SUFFIX_LU ; }
649: else { if (@expr1467 *@expr1460 it@var231 ==@expr1469 'l' ||@expr1470 *@expr1460 it@var231 ==@expr1472 'L' ) {
650: state@var234 =@expr1073743355 Status ::@expr1532 SUFFIX_LL ; }
651: else {
652: return false ; } }
653: break ;
654: case Status ::@expr1524 SUFFIX_LU :@expr1458 ;
655: return false ;
656: case Status ::@expr1532 SUFFIX_LL :@expr1458 ;
657: if (@expr1459 *@expr1460 it@var231 ==@expr1461 'u' ||@expr1462 *@expr1460 it@var231 ==@expr1464 'U' ) {
658: state@var234 =@expr1073743367 Status ::@expr1544 SUFFIX_LLU ; }
659: else {
660: return false ; }
661: break ;
662: case Status ::@expr1484 SUFFIX_I :@expr1458 ;
663: if (@expr1547 *@expr1460 it@var231 ==@expr1549 '6' ) {
664: state@var234 =@expr1073743374 Status ::@expr1551 SUFFIX_I6 ; }
665: else {
666: return false ; }
667: break ;
668: case Status ::@expr1551 SUFFIX_I6 :@expr1458 ;
669: if (@expr1554 *@expr1460 it@var231 ==@expr1556 '4' ) {
670: state@var234 =@expr1073743381 Status ::@expr1558 SUFFIX_I64 ; }
671: else {
672: return false ; }
673: break ;
674: case Status ::@expr1504 SUFFIX_UI :@expr1458 ;
675: if (@expr1547 *@expr1460 it@var231 ==@expr1549 '6' ) {
676: state@var234 =@expr1073743388 Status ::@expr1565 SUFFIX_UI6 ; }
677: else {
678: return false ; }
679: break ;
680: case Status ::@expr1565 SUFFIX_UI6 :@expr1458 ;
681: if (@expr1554 *@expr1460 it@var231 ==@expr1556 '4' ) {
682: state@var234 =@expr1073743395 Status ::@expr1572 SUFFIX_UI64 ; }
683: else {
684: return false ; }
685: break ;
686: default :@expr1458 ;
687: return false ;
688: }
689: }
690: return (@expr1574 (@expr1574 state@var234 ==@expr1073743400 Status ::@expr1466 SUFFIX_U@expr1073743267 ) ||@expr1073743402
691: (@expr1574 state@var234 ==@expr1073743404 Status ::@expr1474 SUFFIX_L@expr1442 ) ||@expr1073743406
692: (@expr1574 state@var234 ==@expr1073743408 Status ::@expr1494 SUFFIX_UL@expr1073743268 ) ||@expr1073743410
693: (@expr1574 state@var234 ==@expr1073743412 Status ::@expr1524 SUFFIX_LU@expr1073743269 ) ||@expr1073743414
694: (@expr1574 state@var234 ==@expr1073743416 Status ::@expr1532 SUFFIX_LL@expr1073743270 ) ||@expr1073743418
695: (@expr1574 state@var234 ==@expr1073743420 Status ::@expr1514 SUFFIX_ULL@expr1073743271 ) ||@expr1073743422
696: (@expr1574 state@var234 ==@expr1073743424 Status ::@expr1544 SUFFIX_LLU@expr1073743272 ) ||@expr1073743426
697: (@expr1574 state@var234 ==@expr1073743428 Status ::@expr1558 SUFFIX_I64@expr1073743273 ) ||@expr1073743430
698: (@expr1574 state@var234 ==@expr1073743432 Status ::@expr1572 SUFFIX_UI64@expr1073743274 ) ) ;
699: }
700:
701:
702: bool MathLib :: isValidIntegerSuffix ( const std :: string & str@var235 , bool supportMicrosoftExtensions@var236 )
703: {
704: return isValidIntegerSuffixIt (@expr1073743434 str@var235 .@expr1073743435 begin (@expr1073743436 ) , str@var235 .@expr1073743437 end (@expr1073743438 ) , supportMicrosoftExtensions@var236 ) ;
705: }
706:
|
717:
718: bool MathLib :: isOct ( const std :: string & str@var237 )
719: {
720: enum class Status {
721: START , OCTAL_PREFIX , DIGITS
722: } ; enum Status state@var238 ; state@var238 =@expr1073743441 Status ::@expr1618 START@expr1073743439 ;
723: if (@expr1073743443 str@var237 .@expr1073743444 empty (@expr1073743445 ) ) {
724: return false ; }
725: std ::@expr1073743446 string ::@expr1073743447 const_iterator it@var239 ; it@var239 =@expr1073743448 str@var237 .@expr1073743449 begin (@expr1073743450 ) ;
726: if (@expr1073743451 '+' ==@expr1073743452 *@expr1629 it@var239 ||@expr1073743454 '-' ==@expr1073743455 *@expr1629 it@var239 ) {
727: ++@expr1073743457 it@var239 ; }
728: for (@expr1073743458 ; it@var239 !=@expr1073743459 str@var237 .@expr1636 end (@expr1637 ) ; ++@expr1073743462 it@var239 ) {
729: switch (@expr1073743463 state@var238 ) {
730: case Status ::@expr1618 START :@expr1641 ;
731: if (@expr1073743466 *@expr1629 it@var239 ==@expr1073743468 '0' ) {
732: state@var238 =@expr1073743469 Status ::@expr1646 OCTAL_PREFIX ; }
733: else {
734: return false ; }
735: break ;
736: case Status ::@expr1646 OCTAL_PREFIX :@expr1641 ;
737: if (@expr1649 isOctalDigit (@expr1650 static_cast < unsigned char > (@expr1651 *@expr1629 it@var239 ) ) ) {
738: state@var238 =@expr1073743477 Status ::@expr1654 DIGITS ; }
739: else {
740: return false ; }
741: break ;
742: case Status ::@expr1654 DIGITS :@expr1641 ;
743: if (@expr1649 isOctalDigit (@expr1650 static_cast < unsigned char > (@expr1651 *@expr1629 it@var239 ) ) ) {
744: state@var238 =@expr1073743485 Status ::@expr1654 DIGITS ; }
745: else {
746: return isValidIntegerSuffixIt (@expr1073743487 it@var239 , str@var237 .@expr1636 end (@expr1637 ) ) ; }
747: break ;
748: }
749: }
750: return state@var238 ==@expr1073743490 Status ::@expr1654 DIGITS@expr1073743440 ;
751: }
752:
753: bool MathLib :: isIntHex ( const std :: string & str@var240 )
754: {
755: enum class Status {
756: START , HEX_0 , HEX_X , DIGIT
757: } ; enum Status state@var241 ; state@var241 =@expr1073743494 Status ::@expr1671 START@expr1073743492 ;
758: if (@expr1073743496 str@var240 .@expr1073743497 empty (@expr1073743498 ) ) {
759: return false ; }
760: std ::@expr1073743499 string ::@expr1073743500 const_iterator it@var242 ; it@var242 =@expr1073743501 str@var240 .@expr1073743502 begin (@expr1073743503 ) ;
761: if (@expr1073743504 '+' ==@expr1073743505 *@expr1682 it@var242 ||@expr1073743507 '-' ==@expr1073743508 *@expr1682 it@var242 ) {
762: ++@expr1073743510 it@var242 ; }
763: for (@expr1073743511 ; it@var242 !=@expr1073743512 str@var240 .@expr1689 end (@expr1690 ) ; ++@expr1073743515 it@var242 ) {
764: switch (@expr1073743516 state@var241 ) {
765: case Status ::@expr1671 START :@expr1694 ;
766: if (@expr1073743519 *@expr1682 it@var242 ==@expr1073743521 '0' ) {
767: state@var241 =@expr1073743522 Status ::@expr1699 HEX_0 ; }
768: else {
769: return false ; }
770: break ;
771: case Status ::@expr1699 HEX_0 :@expr1694 ;
772: if (@expr1073743526 *@expr1682 it@var242 ==@expr1073743528 'x' ||@expr1073743529 *@expr1682 it@var242 ==@expr1073743531 'X' ) {
773: state@var241 =@expr1073743532 Status ::@expr1709 HEX_X ; }
774: else {
775: return false ; }
776: break ;
777: case Status ::@expr1709 HEX_X :@expr1694 ;
778: if (@expr1712 isxdigit (@expr1713 static_cast < unsigned char > (@expr1714 *@expr1682 it@var242 ) ) ) {
779: state@var241 =@expr1073743540 Status ::@expr1717 DIGIT ; }
780: else {
781: return false ; }
782: break ;
783: case Status ::@expr1717 DIGIT :@expr1694 ;
784: if (@expr1712 isxdigit (@expr1713 static_cast < unsigned char > (@expr1714 *@expr1682 it@var242 ) ) ) {
785: ; }
786: else {
787: return isValidIntegerSuffixIt (@expr1073743548 it@var242 , str@var240 .@expr1689 end (@expr1690 ) ) ; }
788: break ;
789: }
790: }
791: return Status ::@expr1717 DIGIT@expr1073743493 ==@expr1073743552 state@var241 ;
792: }
793:
794: bool MathLib :: isFloatHex ( const std :: string & str@var243 )
795: {
796: enum class Status {
797: START , HEX_0 , HEX_X , WHOLE_NUMBER_DIGIT , POINT , FRACTION , EXPONENT_P , EXPONENT_SIGN , EXPONENT_DIGITS , EXPONENT_SUFFIX
798: } ; enum Status state@var244 ; state@var244 =@expr1073743556 Status ::@expr1733 START@expr1073743553 ;
799: if (@expr1073743558 str@var243 .@expr1073743559 empty (@expr1073743560 ) ) {
800: return false ; }
801: std ::@expr1073743561 string ::@expr1073743562 const_iterator it@var245 ; it@var245 =@expr1073743563 str@var243 .@expr1073743564 begin (@expr1073743565 ) ;
802: if (@expr1742 '+' ==@expr1743 *@expr1744 it@var245 ||@expr1745 '-' ==@expr1746 *@expr1744 it@var245 ) {
803: ++@expr1073743572 it@var245 ; }
804: for (@expr1073743573 ; it@var245 !=@expr1073743574 str@var243 .@expr1073743575 end (@expr1073743576 ) ; ++@expr1073743577 it@var245 ) {
805: switch (@expr1073743578 state@var244 ) {
806: case Status ::@expr1733 START :@expr1756 ;
807: if (@expr1073743581 *@expr1744 it@var245 ==@expr1073743583 '0' ) {
808: state@var244 =@expr1073743584 Status ::@expr1761 HEX_0 ; }
809: else {
810: return false ; }
811: break ;
812: case Status ::@expr1761 HEX_0 :@expr1756 ;
813: if (@expr1073743588 *@expr1744 it@var245 ==@expr1073743590 'x' ||@expr1073743591 *@expr1744 it@var245 ==@expr1073743593 'X' ) {
814: state@var244 =@expr1073743594 Status ::@expr1771 HEX_X ; }
815: else {
816: return false ; }
817: break ;
818: case Status ::@expr1771 HEX_X :@expr1756 ;
819: if (@expr1774 isxdigit (@expr1775 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
820: state@var244 =@expr1073743602 Status ::@expr1779 WHOLE_NUMBER_DIGIT ; }
821: else { if (@expr1780 *@expr1744 it@var245 ==@expr1782 '.' ) {
822: state@var244 =@expr1073743607 Status ::@expr1784 POINT ; }
823: else {
824: return false ; } }
825: break ;
826: case Status ::@expr1779 WHOLE_NUMBER_DIGIT :@expr1756 ;
827: if (@expr1774 isxdigit (@expr1775 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
828: ; }
829: else { if (@expr1780 *@expr1744 it@var245 ==@expr1782 '.' ) {
830: state@var244 =@expr1073743618 Status ::@expr1795 FRACTION ; }
831: else { if (@expr1796 *@expr1744 it@var245 ==@expr1798 'p' ||@expr1799 *@expr1744 it@var245 ==@expr1801 'P' ) {
832: state@var244 =@expr1073743626 Status ::@expr1803 EXPONENT_P ; }
833: else {
834: return false ; } } }
835: break ;
836: case Status ::@expr1784 POINT :@expr1756
837: case Status ::@expr1795 FRACTION :@expr1756 ;
838: if (@expr1774 isxdigit (@expr1775 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
839: state@var244 =@expr1073743636 Status ::@expr1795 FRACTION ; }
840: else { if (@expr1796 *@expr1744 it@var245 ==@expr1798 'p' ||@expr1799 *@expr1744 it@var245 ==@expr1801 'P' ) {
841: state@var244 =@expr1073743644 Status ::@expr1803 EXPONENT_P ; }
842: else {
843: return false ; } }
844: break ;
845: case Status ::@expr1803 EXPONENT_P :@expr1756 ;
846: if (@expr1824 isdigit (@expr1825 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
847: state@var244 =@expr1073743652 Status ::@expr1829 EXPONENT_DIGITS ; }
848: else { if (@expr1742 *@expr1744 it@var245 ==@expr1743 '+' ||@expr1745 *@expr1744 it@var245 ==@expr1746 '-' ) {
849: state@var244 =@expr1073743660 Status ::@expr1837 EXPONENT_SIGN ; }
850: else {
851: return false ; } }
852: break ;
853: case Status ::@expr1837 EXPONENT_SIGN :@expr1756 ;
854: if (@expr1824 isdigit (@expr1825 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
855: state@var244 =@expr1073743668 Status ::@expr1829 EXPONENT_DIGITS ; }
856: else {
857: return false ; }
858: break ;
859: case Status ::@expr1829 EXPONENT_DIGITS :@expr1756 ;
860: if (@expr1824 isdigit (@expr1825 static_cast < unsigned char > (@expr1776 *@expr1744 it@var245 ) ) ) {
861: ; }
862: else { if (@expr1073743676 *@expr1744 it@var245 ==@expr1073743678 'f' ||@expr1073743679 *@expr1744 it@var245 ==@expr1073743681 'F' ||@expr1073743682 *@expr1744 it@var245 ==@expr1073743684 'l' ||@expr1073743685 *@expr1744 it@var245 ==@expr1073743687 'L' ) {
863: state@var244 =@expr1073743688 Status ::@expr1865 EXPONENT_SUFFIX ; }
864: else {
865: return false ; } }
866: break ;
867: case Status ::@expr1865 EXPONENT_SUFFIX :@expr1756 ;
868: return false ;
869: }
870: }
871: return (@expr1868 Status ::@expr1829 EXPONENT_DIGITS@expr1073743554 ==@expr1073743694 state@var244 ) ||@expr1073743695 (@expr1868 Status ::@expr1865 EXPONENT_SUFFIX@expr1073743555 ==@expr1073743698 state@var244 ) ;
872: }
873:
|
883:
884: bool MathLib :: isBin ( const std :: string & str@var246 )
885: {
886: enum class Status {
887: START , GNU_BIN_PREFIX_0 , GNU_BIN_PREFIX_B , DIGIT
888: } ; enum Status state@var247 ; state@var247 =@expr1073743701 Status ::@expr1878 START@expr1073743699 ;
889: if (@expr1073743703 str@var246 .@expr1073743704 empty (@expr1073743705 ) ) {
890: return false ; }
891: std ::@expr1073743706 string ::@expr1073743707 const_iterator it@var248 ; it@var248 =@expr1073743708 str@var246 .@expr1073743709 begin (@expr1073743710 ) ;
892: if (@expr1073743711 '+' ==@expr1073743712 *@expr1889 it@var248 ||@expr1073743714 '-' ==@expr1073743715 *@expr1889 it@var248 ) {
893: ++@expr1073743717 it@var248 ; }
894: for (@expr1073743718 ; it@var248 !=@expr1073743719 str@var246 .@expr1896 end (@expr1897 ) ; ++@expr1073743722 it@var248 ) {
895: switch (@expr1073743723 state@var247 ) {
896: case Status ::@expr1878 START :@expr1901 ;
897: if (@expr1073743726 *@expr1889 it@var248 ==@expr1904 '0' ) {
898: state@var247 =@expr1073743729 Status ::@expr1906 GNU_BIN_PREFIX_0 ; }
899: else {
900: return false ; }
901: break ;
902: case Status ::@expr1906 GNU_BIN_PREFIX_0 :@expr1901 ;
903: if (@expr1073743733 *@expr1889 it@var248 ==@expr1073743735 'b' ||@expr1073743736 *@expr1889 it@var248 ==@expr1073743738 'B' ) {
904: state@var247 =@expr1073743739 Status ::@expr1916 GNU_BIN_PREFIX_B ; }
905: else {
906: return false ; }
907: break ;
908: case Status ::@expr1916 GNU_BIN_PREFIX_B :@expr1901 ;
909: if (@expr1919 *@expr1889 it@var248 ==@expr1904 '0' ||@expr1922 *@expr1889 it@var248 ==@expr1924 '1' ) {
910: state@var247 =@expr1073743749 Status ::@expr1926 DIGIT@expr1876 ; }
911: else {
912: return false ; }
913: break ;
914: case Status ::@expr1926 DIGIT :@expr1901 ;
915: if (@expr1919 *@expr1889 it@var248 ==@expr1904 '0' ||@expr1922 *@expr1889 it@var248 ==@expr1924 '1' ) {
916: ; }
917: else {
918: return isValidIntegerSuffixIt (@expr1073743759 it@var248 , str@var246 .@expr1896 end (@expr1897 ) ) ; }
919: break ;
920: }
921: }
922: return state@var247 ==@expr1073743762 Status ::@expr1926 DIGIT@expr1876 ;
923: }
924:
925: bool MathLib :: isDec ( const std :: string & str@var249 )
926: {
927: enum class Status {
928: START , DIGIT
929: } ; enum Status state@var250 ; state@var250 =@expr1073743766 Status ::@expr1943 START@expr1073743764 ;
930: if (@expr1073743768 str@var249 .@expr1073743769 empty (@expr1073743770 ) ) {
931: return false ; }
932: std ::@expr1073743771 string ::@expr1073743772 const_iterator it@var251 ; it@var251 =@expr1073743773 str@var249 .@expr1073743774 begin (@expr1073743775 ) ;
933: if (@expr1073743776 '+' ==@expr1073743777 *@expr1954 it@var251 ||@expr1073743779 '-' ==@expr1073743780 *@expr1954 it@var251 ) {
934: ++@expr1073743782 it@var251 ; }
935: for (@expr1073743783 ; it@var251 !=@expr1073743784 str@var249 .@expr1961 end (@expr1962 ) ; ++@expr1073743787 it@var251 ) {
936: switch (@expr1073743788 state@var250 ) {
937: case Status ::@expr1943 START :@expr1966 ;
938: if (@expr1967 isdigit (@expr1968 static_cast < unsigned char > (@expr1969 *@expr1954 it@var251 ) ) ) {
939: state@var250 =@expr1073743795 Status ::@expr1972 DIGIT@expr1941 ; }
940: else {
941: return false ; }
942: break ;
943: case Status ::@expr1972 DIGIT :@expr1966 ;
944: if (@expr1967 isdigit (@expr1968 static_cast < unsigned char > (@expr1969 *@expr1954 it@var251 ) ) ) {
945: state@var250 =@expr1073743803 Status ::@expr1972 DIGIT@expr1941 ; }
946: else {
947: return isValidIntegerSuffixIt (@expr1073743805 it@var251 , str@var249 .@expr1961 end (@expr1962 ) ) ; }
948: break ;
949: }
950: }
951: return state@var250 ==@expr1073743808 Status ::@expr1972 DIGIT@expr1941 ;
952: }
953:
954: bool MathLib :: isInt ( const std :: string & str@var252 )
955: {
956: return isDec (@expr1073743810 str@var252 ) ||@expr1073743811 isIntHex (@expr1073743812 str@var252 ) ||@expr1073743813 isOct (@expr1073743814 str@var252 ) ||@expr1073743815 isBin (@expr1073743816 str@var252 ) ;
957: }
958:
959: std :: string MathLib :: getSuffix ( const std :: string & value@var253 )
960: {
961: if (@expr1073743817 value@var253 .@expr1994 size (@expr1995 ) >@expr1073743820 3 &&@expr1073743821 value@var253 [@expr1073743822 value@var253 .@expr1994 size (@expr1995 ) -@expr1073743825 3 ] ==@expr1073743826 'i' &&@expr1073743827 value@var253 [@expr1073743828 value@var253 .@expr1994 size (@expr1995 ) -@expr1073743831 2 ] ==@expr1073743832 '6' &&@expr1073743833 value@var253 [@expr1073743834 value@var253 .@expr1994 size (@expr1995 ) -@expr1073743837 1 ] ==@expr1073743838 '4' ) {
962: if (@expr1073743839 value@var253 [@expr1073743840 value@var253 .@expr1994 size (@expr1995 ) -@expr1073743843 4 ] ==@expr1073743844 'u' ) {
963: return "ULL" ; }
964: return "LL" ;
965: }
966: bool isUnsigned@var254 ; isUnsigned@var254 =@expr1073743845 false ;
967: unsigned int longState@var255 ; longState@var255 =@expr1073743846 0 ;
968: for (@expr1073743847 unsigned long i@var256 =@expr1073743848 1U ; i@var256 <@expr1073743849 value@var253 .@expr1994 size (@expr1995 ) ; ++@expr1073743852 i@var256 ) {
969: const char c@var257 =@expr1073743853 value@var253 [@expr1073743854 value@var253 .@expr1994 size (@expr1995 ) -@expr1073743857 i@var256 ] ;
970: if (@expr1073743858 c@var257 ==@expr1073743859 'u' ||@expr1073743860 c@var257 ==@expr1073743861 'U' ) {
971: isUnsigned@var254 =@expr1073743862 true ; }
972: else { if (@expr1073743863 c@var257 ==@expr1073743864 'L' ||@expr1073743865 c@var257 ==@expr1073743866 'l' ) {
973: longState@var255 ++@expr1073743867 ; }
974: else { break ; } }
975: }
976: if (@expr1073743868 longState@var255 ==@expr1073743869 0 ) {
977: return isUnsigned@var254 ?@expr1073743870 "U" :@expr1073743871 "" ; }
978: if (@expr1073743872 longState@var255 ==@expr1073743873 1 ) {
979: return isUnsigned@var254 ?@expr1073743874 "UL" :@expr1073743875 "L" ; }
980: if (@expr1073743876 longState@var255 ==@expr1073743877 2 ) {
981: return isUnsigned@var254 ?@expr1073743878 "ULL" :@expr1073743879 "LL" ; }
982: else { return "" ; }
983: }
984:
985: static std :: string intsuffix ( const std :: string & first@var258 , const std :: string & second@var259 )
986: {
987: const std ::@expr2056 string suffix1@var260 =@expr1073743881 MathLib ::@expr2058 getSuffix (@expr1073743883 first@var258 ) ;
988: const std ::@expr2056 string suffix2@var261 =@expr1073743885 MathLib ::@expr2058 getSuffix (@expr1073743887 second@var259 ) ;
989: if (@expr1073743888 suffix1@var260 ==@expr1073743889 "ULL" ||@expr1073743890 suffix2@var261 ==@expr1073743891 "ULL" ) {
990: return "ULL" ; }
991: if (@expr1073743892 suffix1@var260 ==@expr1073743893 "LL" ||@expr1073743894 suffix2@var261 ==@expr1073743895 "LL" ) {
992: return "LL" ; }
993: if (@expr1073743896 suffix1@var260 ==@expr1073743897 "UL" ||@expr1073743898 suffix2@var261 ==@expr1073743899 "UL" ) {
994: return "UL" ; }
995: if (@expr1073743900 suffix1@var260 ==@expr1073743901 "L" ||@expr1073743902 suffix2@var261 ==@expr1073743903 "L" ) {
996: return "L" ; }
997: if (@expr1073743904 suffix1@var260 ==@expr1073743905 "U" ||@expr1073743906 suffix2@var261 ==@expr1073743907 "U" ) {
998: return "U" ; }
999:
1000: return suffix1@var260 .@expr1073743908 empty (@expr1073743909 ) ?@expr1073743910 suffix2@var261 :@expr1073743911 suffix1@var260 ;
1001: }
1002:
1003: std :: string MathLib :: add ( const std :: string & first@var262 , const std :: string & second@var263 )
1004: {
1005:
1006:
1007:
1008: if (@expr1073743912 MathLib ::@expr2089 isInt (@expr1073743914 first@var262 ) &&@expr1073743915 MathLib ::@expr2089 isInt (@expr1073743917 second@var263 ) ) {
1009: return toString<double> (@expr1073743918 toLongNumber (@expr1073743919 first@var262 ) +@expr1073743920 toLongNumber (@expr1073743921 second@var263 ) ) +@expr1073743922 intsuffix (@expr1073743923 first@var262 , second@var263 ) ;
1010: }
1011:
1012: double d1@var264 ; d1@var264 =@expr1073743924 toDoubleNumber (@expr1073743925 first@var262 ) ;
1013: double d2@var265 ; d2@var265 =@expr1073743926 toDoubleNumber (@expr1073743927 second@var263 ) ;
1014:
1015: int count@var266 ; count@var266 =@expr1073743928 0 ;
1016: while (@expr1073743929 d1@var264 >@expr1073743930 100000.0 *@expr1073743931 d2@var265 &&@expr1073743932 toString<double> (@expr2109 d1@var264 +@expr2110 d2@var265 ) ==@expr1073743935 first@var262 &&@expr1073743936 ++@expr1073743937 count@var266 <@expr1073743938 5 ) {
1017: d2@var265 *=@expr1073743939 10.0 ; }
1018: while (@expr1073743940 d2@var265 >@expr1073743941 100000.0 *@expr1073743942 d1@var264 &&@expr1073743943 toString<double> (@expr2109 d1@var264 +@expr2110 d2@var265 ) ==@expr1073743946 second@var263 &&@expr1073743947 ++@expr1073743948 count@var266 <@expr1073743949 5 ) {
1019: d1@var264 *=@expr1073743950 10.0 ; }
1020:
1021: return toString<double> (@expr2109 d1@var264 +@expr2110 d2@var265 ) ;
1022:
1023: }
1024:
1025: std :: string MathLib :: subtract ( const std :: string & first@var267 , const std :: string & second@var268 )
1026: {
1027:
1028:
1029:
1030: if (@expr1073743953 MathLib ::@expr2130 isInt (@expr1073743955 first@var267 ) &&@expr1073743956 MathLib ::@expr2130 isInt (@expr1073743958 second@var268 ) ) {
1031: return toString<double> (@expr1073743959 toLongNumber (@expr1073743960 first@var267 ) -@expr1073743961 toLongNumber (@expr1073743962 second@var268 ) ) +@expr1073743963 intsuffix (@expr1073743964 first@var267 , second@var268 ) ;
1032: }
1033:
1034: if (@expr1073743965 first@var267 ==@expr1073743966 second@var268 ) {
1035: return "0.0" ; }
1036:
1037: double d1@var269 ; d1@var269 =@expr1073743967 toDoubleNumber (@expr1073743968 first@var267 ) ;
1038: double d2@var270 ; d2@var270 =@expr1073743969 toDoubleNumber (@expr1073743970 second@var268 ) ;
1039:
1040: int count@var271 ; count@var271 =@expr1073743971 0 ;
1041: while (@expr1073743972 d1@var269 >@expr1073743973 100000.0 *@expr1073743974 d2@var270 &&@expr1073743975 toString<double> (@expr2152 d1@var269 -@expr2153 d2@var270 ) ==@expr1073743978 first@var267 &&@expr1073743979 ++@expr1073743980 count@var271 <@expr1073743981 5 ) {
1042: d2@var270 *=@expr1073743982 10.0 ; }
1043: while (@expr1073743983 d2@var270 >@expr1073743984 100000.0 *@expr1073743985 d1@var269 &&@expr1073743986 toString<double> (@expr2152 d1@var269 -@expr2153 d2@var270 ) ==@expr1073743989 second@var268 &&@expr1073743990 ++@expr1073743991 count@var271 <@expr1073743992 5 ) {
1044: d1@var269 *=@expr1073743993 10.0 ; }
1045:
1046: return toString<double> (@expr2152 d1@var269 -@expr2153 d2@var270 ) ;
1047:
1048: }
1049:
1050: std :: string MathLib :: incdec ( const std :: string & var@var272 , const std :: string & op@var273 )
1051: {
1052:
|
1057:
1058: if (@expr1073743996 op@var273 ==@expr1073743997 "++" ) {
1059: return MathLib ::@expr1073743998 add (@expr1073743999 var@var272 , "1" ) ; }
1060: else { if (@expr1073744000 op@var273 ==@expr1073744001 "--" ) {
1061: return MathLib ::@expr1073744002 subtract (@expr1073744003 var@var272 , "1" ) ; } }
1062:
1063:
1064: throw InternalError (@expr1073744004 nullptr , std ::@expr1073744005 string (@expr1073744006 "Unexpected operation '" ) +@expr1073744007 op@var273 +@expr1073744008 "' in MathLib::incdec(). Please report this to Cppcheck developers." ) ;
1065: }
1066:
1067: std :: string MathLib :: divide ( const std :: string & first@var274 , const std :: string & second@var275 )
1068: {
1069:
1070:
1071:
1072: if (@expr1073744009 MathLib ::@expr2186 isInt (@expr1073744011 first@var274 ) &&@expr1073744012 MathLib ::@expr2186 isInt (@expr1073744014 second@var275 ) ) {
1073: const long long a@var276 =@expr1073744015 toLongNumber (@expr2192 first@var274 ) ;
1074: const long long b@var277 =@expr1073744017 toLongNumber (@expr1073744018 second@var275 ) ;
1075: if (@expr1073744019 b@var277 ==@expr1073744020 0 ) {
1076: throw InternalError (@expr1073744021 nullptr , "Internal Error: Division by zero" ) ; }
1077: if (@expr1073744022 a@var276 ==@expr1073744023 std ::@expr1073744024 numeric_limits < long long > ::@expr1073744025 min (@expr1073744026 ) &&@expr1073744027 std ::@expr1073744028 abs (@expr1073744029 b@var277 ) <=@expr1073744030 1 ) {
1078: throw InternalError (@expr1073744031 nullptr , "Internal Error: Division overflow" ) ; }
1079: return toString<double> (@expr1073744032 toLongNumber (@expr2192 first@var274 ) /@expr1073744034 b@var277 ) +@expr1073744035 intsuffix (@expr1073744036 first@var274 , second@var275 ) ;
1080: } else { if (@expr1073744037 isNullValue (@expr1073744038 second@var275 ) ) {
1081: if (@expr1073744039 isNullValue (@expr1073744040 first@var274 ) ) {
1082: return "nan.0" ; }
1083: return isPositive (@expr1073744041 first@var274 ) ?@expr1073744042 "inf.0" :@expr1073744043 "-inf.0" ;
1084: } }
1085: return toString<double> (@expr1073744044 toDoubleNumber (@expr1073744045 first@var274 ) /@expr1073744046 toDoubleNumber (@expr1073744047 second@var275 ) ) ;
1086:
1087: }
1088:
1089: std :: string MathLib :: multiply ( const std :: string & first@var278 , const std :: string & second@var279 )
1090: {
1091:
1092:
1093:
1094: if (@expr1073744048 MathLib ::@expr2225 isInt (@expr1073744050 first@var278 ) &&@expr1073744051 MathLib ::@expr2225 isInt (@expr1073744053 second@var279 ) ) {
1095: return toString<double> (@expr1073744054 toLongNumber (@expr1073744055 first@var278 ) *@expr1073744056 toLongNumber (@expr1073744057 second@var279 ) ) +@expr1073744058 intsuffix (@expr1073744059 first@var278 , second@var279 ) ;
1096: }
1097: return toString<double> (@expr1073744060 toDoubleNumber (@expr1073744061 first@var278 ) *@expr1073744062 toDoubleNumber (@expr1073744063 second@var279 ) ) ;
1098:
1099: }
1100:
1101: std :: string MathLib :: mod ( const std :: string & first@var280 , const std :: string & second@var281 )
1102: {
1103:
1104:
1105:
1106: if (@expr1073744064 MathLib ::@expr2241 isInt (@expr1073744066 first@var280 ) &&@expr1073744067 MathLib ::@expr2241 isInt (@expr1073744069 second@var281 ) ) {
1107: const long long b@var282 =@expr1073744070 toLongNumber (@expr1073744071 second@var281 ) ;
1108: if (@expr1073744072 b@var282 ==@expr1073744073 0 ) {
1109: throw InternalError (@expr1073744074 nullptr , "Internal Error: Division by zero" ) ; }
1110: return toString<double> (@expr1073744075 toLongNumber (@expr1073744076 first@var280 ) %@expr1073744077 b@var282 ) +@expr1073744078 intsuffix (@expr1073744079 first@var280 , second@var281 ) ;
1111: }
1112: return toString<double> (@expr1073744080 std ::@expr1073744081 fmod (@expr1073744082 toDoubleNumber (@expr1073744083 first@var280 ) , toDoubleNumber (@expr1073744084 second@var281 ) ) ) ;
1113:
1114: }
1115:
1116: std :: string MathLib :: calculate ( const std :: string & first@var283 , const std :: string & second@var284 , char action@var285 )
1117: {
1118: switch (@expr1073744085 action@var285 ) {
1119: case '+' :@expr2262 ;
1120: return MathLib ::@expr1073744087 add (@expr1073744088 first@var283 , second@var284 ) ;
1121:
1122: case '-' :@expr2262 ;
1123: return MathLib ::@expr1073744090 subtract (@expr1073744091 first@var283 , second@var284 ) ;
1124:
1125: case '*' :@expr2262 ;
1126: return MathLib ::@expr1073744093 multiply (@expr1073744094 first@var283 , second@var284 ) ;
1127:
1128: case '/' :@expr2262 ;
1129: return MathLib ::@expr1073744096 divide (@expr1073744097 first@var283 , second@var284 ) ;
1130:
1131: case '%' :@expr2262 ;
1132: return MathLib ::@expr1073744099 mod (@expr1073744100 first@var283 , second@var284 ) ;
1133:
1134: case '&' :@expr2262 ;
1135: return MathLib ::@expr2278 toString<double> (@expr1073744103 MathLib ::@expr2280 toLongNumber (@expr2281 first@var283 ) &@expr1073744106 MathLib ::@expr2280 toLongNumber (@expr2284 second@var284 ) ) +@expr1073744109 intsuffix (@expr2286 first@var283 , second@var284 ) ;
1136:
1137: case '|' :@expr2262 ;
1138: return MathLib ::@expr2278 toString<double> (@expr1073744113 MathLib ::@expr2280 toLongNumber (@expr2281 first@var283 ) |@expr1073744116 MathLib ::@expr2280 toLongNumber (@expr2284 second@var284 ) ) +@expr1073744119 intsuffix (@expr2286 first@var283 , second@var284 ) ;
1139:
1140: case '^' :@expr2262 ;
1141: return MathLib ::@expr2278 toString<double> (@expr1073744123 MathLib ::@expr2280 toLongNumber (@expr2281 first@var283 ) ^@expr1073744126 MathLib ::@expr2280 toLongNumber (@expr2284 second@var284 ) ) +@expr1073744129 intsuffix (@expr2286 first@var283 , second@var284 ) ;
1142:
1143: default :@expr2262 ;
1144: throw InternalError (@expr1073744132 nullptr , std ::@expr1073744133 string (@expr1073744134 "Unexpected action '" ) +@expr1073744135 action@var285 +@expr1073744136 "' in MathLib::calculate(). Please report this to Cppcheck developers." ) ;
1145: }
1146: }
1147:
1148: std :: string MathLib :: sin ( const std :: string & tok@var286 )
1149: {
1150: return toString<double> (@expr1073744137 std ::@expr1073744138 sin (@expr1073744139 toDoubleNumber (@expr1073744140 tok@var286 ) ) ) ;
1151: }
1152:
1153:
1154: std :: string MathLib :: cos ( const std :: string & tok@var287 )
1155: {
1156: return toString<double> (@expr1073744141 std ::@expr1073744142 cos (@expr1073744143 toDoubleNumber (@expr1073744144 tok@var287 ) ) ) ;
1157: }
1158:
1159: std :: string MathLib :: tan ( const std :: string & tok@var288 )
1160: {
1161: return toString<double> (@expr1073744145 std ::@expr1073744146 tan (@expr1073744147 toDoubleNumber (@expr1073744148 tok@var288 ) ) ) ;
1162: }
1163:
1164:
1165: std :: string MathLib :: abs ( const std :: string & tok@var289 )
1166: {
1167: if (@expr1073744149 isNegative (@expr1073744150 tok@var289 ) ) {
1168: return tok@var289 .@expr1073744151 substr (@expr1073744152 1 , tok@var289 .@expr1073744153 length (@expr1073744154 ) -@expr1073744155 1 ) ; }
1169: return tok@var289 ;
1170: }
1171:
1172: bool MathLib :: isEqual ( const std :: string & first@var290 , const std :: string & second@var291 )
1173: {
1174:
1175:
1176: return toString<double> (@expr1073744156 toDoubleNumber (@expr1073744157 first@var290 ) ) ==@expr1073744158 toString<double> (@expr1073744159 toDoubleNumber (@expr1073744160 second@var291 ) ) ;
1177: }
1178:
1179: bool MathLib :: isNotEqual ( const std :: string & first@var292 , const std :: string & second@var293 )
1180: {
1181: return !@expr1073744161 isEqual (@expr1073744162 first@var292 , second@var293 ) ;
1182: }
1183:
1184:
1185: bool MathLib :: isGreater ( const std :: string & first@var294 , const std :: string & second@var295 )
1186: {
1187: return toDoubleNumber (@expr1073744163 first@var294 ) >@expr1073744164 toDoubleNumber (@expr1073744165 second@var295 ) ;
1188: }
1189:
1190:
1191: bool MathLib :: isGreaterEqual ( const std :: string & first@var296 , const std :: string & second@var297 )
1192: {
1193: return toDoubleNumber (@expr1073744166 first@var296 ) >=@expr1073744167 toDoubleNumber (@expr1073744168 second@var297 ) ;
1194: }
1195:
1196:
1197: bool MathLib :: isLess ( const std :: string & first@var298 , const std :: string & second@var299 )
1198: {
1199: return toDoubleNumber (@expr1073744169 first@var298 ) <@expr1073744170 toDoubleNumber (@expr1073744171 second@var299 ) ;
1200: }
1201:
1202: bool MathLib :: isLessEqual ( const std :: string & first@var300 , const std :: string & second@var301 )
1203: {
1204: return toDoubleNumber (@expr1073744172 first@var300 ) <=@expr1073744173 toDoubleNumber (@expr1073744174 second@var301 ) ;
1205: }
1206:
|
1215:
1216: bool MathLib :: isNullValue ( const std :: string & str@var302 )
1217: {
1218: if (@expr1073744175 str@var302 .@expr1073744176 empty (@expr1073744177 ) ||@expr1073744178 (@expr1073744179 !@expr1073744180 std ::@expr2357 isdigit (@expr1073744182 static_cast < unsigned char > (@expr1073744183 str@var302 [@expr2360 0 ] ) ) &&@expr1073744185 (@expr1073744186 str@var302 [@expr2360 0 ] !=@expr1073744188 '.' &&@expr1073744189 str@var302 [@expr2360 0 ] !=@expr1073744191 '-' &&@expr1073744192 str@var302 [@expr2360 0 ] !=@expr1073744194 '+' ) ) ) {
1219: return false ; }
1220:
1221: if (@expr1073744195 !@expr1073744196 isInt (@expr1073744197 str@var302 ) &&@expr1073744198 !@expr1073744199 isFloat (@expr1073744200 str@var302 ) ) {
1222: return false ; }
1223: bool isHex@var303 ; isHex@var303 =@expr1073744201 isIntHex (@expr1073744202 str@var302 ) ||@expr1073744203 isFloatHex (@expr1073744204 str@var302 ) ;
1224: for (@expr1073744205 char i@var304 :@expr1073744206 str@var302 ) {
1225: if (@expr1073744207 std ::@expr2357 isdigit (@expr1073744209 static_cast < unsigned char > (@expr1073744210 i@var304 ) ) &&@expr1073744211 i@var304 !=@expr2388 '0' ) {
1226: return false ; }
1227: if (@expr1073744213 i@var304 ==@expr1073744214 'p' ||@expr1073744215 i@var304 ==@expr1073744216 'P' ||@expr1073744217 (@expr1073744218 !@expr1073744219 isHex@var303 &&@expr1073744220 (@expr1073744221 i@var304 ==@expr1073744222 'E' ||@expr1073744223 i@var304 ==@expr1073744224 'e' ) ) ) {
1228: return true ; }
1229: if (@expr1073744225 isHex@var303 &&@expr1073744226 isxdigit (@expr1073744227 i@var304 ) &&@expr1073744228 i@var304 !=@expr2388 '0' ) {
1230: return false ; }
1231: }
1232: return true ;
1233: }
1234:
1235: bool MathLib :: isOctalDigit ( char c@var305 )
1236: {
1237: return (@expr1073744230 c@var305 >=@expr1073744231 '0' &&@expr1073744232 c@var305 <=@expr1073744233 '7' ) ;
1238: }
1239:
1240: bool MathLib :: isDigitSeparator ( const std :: string & iCode@var306 , std :: string :: size_type iPos@var307 )
1241: {
1242: if (@expr1073744234 iPos@var307 ==@expr1073744235 0 ||@expr1073744236 iPos@var307 >=@expr1073744237 iCode@var306 .@expr1073744238 size (@expr1073744239 ) ||@expr1073744240 iCode@var306 [@expr1073744241 iPos@var307 ] !=@expr1073744242 '\'' ) {
1243: return false ; }
1244: std ::@expr1073744243 string ::@expr1073744244 size_type i@var308 ; i@var308 =@expr1073744245 iPos@var307 -@expr2422 1 ;
1245: while (@expr1073744247 std ::@expr1073744248 isxdigit (@expr1073744249 iCode@var306 [@expr2426 i@var308 ] ) ) {
1246: if (@expr1073744251 i@var308 ==@expr1073744252 0 ) {
1247: return true ; }
1248: --@expr1073744253 i@var308 ;
1249: }
1250: if (@expr1073744254 i@var308 ==@expr1073744255 iPos@var307 -@expr2422 1 ) {
1251: return false ;
1252: } else {
1253: switch (@expr1073744257 iCode@var306 [@expr2426 i@var308 ] ) {
1254: case ' ' :@expr2435
1255: case '.' :@expr2435
1256: case ',' :@expr2435
1257: case 'x' :@expr2435
1258: case '(' :@expr2435
1259: case '{' :@expr2435
1260: case '+' :@expr2435
1261: case '-' :@expr2435
1262: case '*' :@expr2435
1263: case '%' :@expr2435
1264: case '/' :@expr2435
1265: case '&' :@expr2435
1266: case '|' :@expr2435
1267: case '^' :@expr2435
1268: case '~' :@expr2435
1269: case '=' :@expr2435 ;
1270: return true ;
1271: case '\'' :@expr2435 ;
1272: return isDigitSeparator (@expr1073744276 iCode@var306 , i@var308 ) ;
1273: default :@expr2435 ;
1274: return false ;
1275: }
1276: }
1277: }
1278:
1279: MathLib :: value operator+ ( const MathLib :: value & v1@var309 , const MathLib :: value & v2@var310 )
1280: {
1281: return MathLib ::@expr1073744278 value ::@expr1073744279 calc (@expr1073744280 '+' , v1@var309 , v2@var310 ) ;
1282: }
1283:
1284: MathLib :: value operator- ( const MathLib :: value & v1@var311 , const MathLib :: value & v2@var312 )
1285: {
1286: return MathLib ::@expr1073744281 value ::@expr1073744282 calc (@expr1073744283 '-' , v1@var311 , v2@var312 ) ;
1287: }
1288:
1289: MathLib :: value operator* ( const MathLib :: value & v1@var313 , const MathLib :: value & v2@var314 )
1290: {
1291: return MathLib ::@expr1073744284 value ::@expr1073744285 calc (@expr1073744286 '*' , v1@var313 , v2@var314 ) ;
1292: }
1293:
1294: MathLib :: value operator/ ( const MathLib :: value & v1@var315 , const MathLib :: value & v2@var316 )
1295: {
1296: return MathLib ::@expr1073744287 value ::@expr1073744288 calc (@expr1073744289 '/' , v1@var315 , v2@var316 ) ;
1297: }
1298:
1299: MathLib :: value operator% ( const MathLib :: value & v1@var317 , const MathLib :: value & v2@var318 )
1300: {
1301: return MathLib ::@expr1073744290 value ::@expr1073744291 calc (@expr1073744292 '%' , v1@var317 , v2@var318 ) ;
1302: }
1303:
1304: MathLib :: value operator& ( const MathLib :: value & v1@var319 , const MathLib :: value & v2@var320 )
1305: {
1306: return MathLib ::@expr1073744293 value ::@expr1073744294 calc (@expr1073744295 '&' , v1@var319 , v2@var320 ) ;
1307: }
1308:
1309: MathLib :: value operator| ( const MathLib :: value & v1@var321 , const MathLib :: value & v2@var322 )
1310: {
1311: return MathLib ::@expr1073744296 value ::@expr1073744297 calc (@expr1073744298 '|' , v1@var321 , v2@var322 ) ;
1312: }
1313:
1314: MathLib :: value operator^ ( const MathLib :: value & v1@var323 , const MathLib :: value & v2@var324 )
1315: {
1316: return MathLib ::@expr1073744299 value ::@expr1073744300 calc (@expr1073744301 '^' , v1@var323 , v2@var324 ) ;
1317: }
1318:
1319: MathLib :: value operator<< ( const MathLib :: value & v1@var325 , const MathLib :: value & v2@var326 )
1320: {
1321: return v1@var325 .@expr1073744302 shiftLeft (@expr1073744303 v2@var326 ) ;
1322: }
1323:
1324: MathLib :: value operator>> ( const MathLib :: value & v1@var327 , const MathLib :: value & v2@var328 )
1325: {
1326: return v1@var327 .@expr1073744304 shiftRight (@expr1073744305 v2@var328 ) ;
1327: }



##Value flow
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible 34@42663
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible 34@166
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible "1"@5531772
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@162,34@164}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 45
  = always 64
  64 always 64
Line 48
  0 always 0
  0 always 0
  mIsUnsigned always {!<=-1,!>=2}
  false always 0
Line 50
  ( always {!<=-1,!>=2}
Line 51
  = always 3
  :: always 3
  FLOAT always 3
Line 56
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 57
  nullptr always 0
  "Invalid value: " always "Invalid value: "
Line 59
  = always 0
  :: always 0
  INT always 0
Line 60
  s possible {>=size=2,<=size=1}
Line 62
  ( always {!<=-1,!>=2}
  s possible {>=size=2,<=size=1}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  0 always 0
Line 63
  mIsUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 66
  ( always !<=-1
  >= always {!<=-1,!>=2}
  2U always 2
Line 67
  i always !<=-1
  = {>=1,!<=0}
  s {>=size=2,!<=size=1}
  ( {>=2,!<=1}
  - {>=1,!<=0}
  1U always 1
  i {!<=-1,>=2,<=1}
  > {!<=-1,!>=2,>=1}
  0U always 0
  -- {!<=-1,>=2,<=1}
  i {!<=-1,>=3,<=2}
Line 68
  s {>=size=2,!<=size=1}
  i {>=1,!<=0}
Line 69
  c {symbolic=(s[i]),85,108,76,52}
  == {!<=-1,!>=2,0}
  'u' always 117
  || always {!<=-1,!>=2}
  c {symbolic=(s[i]),108,76,52,!117}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 70
  mIsUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 71
  c {symbolic=(s[i]),76,52,!117,!85}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  c {symbolic=(s[i]),52,!117,!85,!108}
  == {!<=-1,!>=2,0}
  'L' always 76
Line 72
  mType possible 1
  == {!<=-1,!>=2,0}
  :: always 0
  INT always 0
Line 73
  = always 1
  :: always 1
  LONG always 1
Line 74
  mType always !0
  == always {!<=-1,!>=2}
  :: always 1
  LONG always 1
Line 75
  = always 2
  :: always 2
  LONGLONG always 2
Line 76
  i always !<=0
  > always {!<=-1,!>=2}
  2U always 2
  && always {!<=-1,!>=2}
  c {symbolic=(s[i]),!117,!85,!108,!76}
  == always {!<=-1,!>=2}
  '4' always 52
  && always {!<=-1,!>=2}
  s always !<=size=1
  i {>=3,!<=2}
  - {>=2,!<=1}
  1 always 1
  == always {!<=-1,!>=2}
  '6' always 54
  && always {!<=-1,!>=2}
  s always !<=size=1
  i always !<=0
  - always !<=-1
  2 always 2
  == always {!<=-1,!>=2}
  'i' always 105
Line 77
  = always 2
  :: always 2
  LONGLONG always 2
Line 85
  mType possible {1,2}
  == {!<=-1,!>=2,0}
  :: always 3
  FLOAT always 3
Line 87
  "nan.0" always "nan.0"
Line 89
  > always {!<=-1,!>=2}
  0 always 0
  ? possible {"inf.0","-inf.0"}
  "inf.0" always "inf.0"
  : always "-inf.0"
  "-inf.0" always "-inf.0"
Line 91
  9 always 9
Line 96
  :: always !<=-1
  pos always !<=-1
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  - always !<=-1
  1U always 1
Line 97
  [ possible 46
  pos always !<=-1
  == {!<=-1,!>=2,0}
  '0' always 48
Line 98
  pos always !<=-1
  -- always !<=-1
Line 99
  [ always !48
  pos always !<=-1
  == always {!<=-1,!>=2}
  '.' always 46
Line 100
  ++ always !<=0
  pos always !<=-1
Line 102
  0 always 0
  pos always !<=-1
  + always !<=0
  1 always 1
Line 105
  mIsUnsigned always {!<=-1,!>=2}
Line 106
  ( always !<=-1
  "U" always "U"
Line 109
  mType {2,!3}
  == {!<=-1,!>=2,0}
  :: always 1
  LONG always 1
Line 110
  "L" always "L"
Line 111
  mType always {!3,!1}
  == always {!<=-1,!>=2}
  :: always 2
  LONGLONG always 2
Line 112
  "LL" always "LL"
Line 118
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 119
  mType possible symbolic=(v.mType)
  < {!<=-1,!>=2,0}
  . possible symbolic=(mType)
Line 120
  = {>=symbolic=(mType+1),!<=symbolic=(mType)}
  . {>=symbolic=(mType+1),!<=symbolic=(mType)}
Line 121
  mIsUnsigned always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mIsUnsigned always {!<=-1,!>=2}
Line 122
  mType {!<=symbolic=(v.mType-1),>=symbolic=(v.mType)}
  == always {!<=-1,!>=2}
  . {!>=symbolic=(mType+1),<=symbolic=(mType)}
Line 123
  mIsUnsigned always {!<=-1,!>=2}
  |= always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  mIsUnsigned always {!<=-1,!>=2}
Line 125
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 126
  mIsUnsigned always {!<=-1,!>=2}
  = always 0
  false always 0
Line 128
  = always 3
  :: always 3
  FLOAT always 3
Line 139
  '+' always 43
Line 142
  '-' always 45
Line 145
  '*' always 42
Line 148
  '/' always 47
Line 151
  '%' always 37
Line 152
  '&' always 38
Line 153
  '|' always 124
Line 154
  '^' always 94
Line 155
  nullptr always 0
  "Invalid calculation" always "Invalid calculation"
Line 157
  nullptr always 0
  "Unhandled calculation" always "Unhandled calculation"
Line 161
  '+' always 43
Line 162
  ( always !<=-1
Line 164
  '-' always 45
Line 165
  ( always !<=-1
Line 167
  '*' always 42
Line 168
  ( always !<=-1
Line 170
  '/' always 47
Line 171
  == always {!<=-1,!>=2}
  0 always 0
Line 172
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 173
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1 always 1
Line 174
  nullptr always 0
  "Internal Error: Division overflow" always "Internal Error: Division overflow"
Line 175
  ( always !<=-1
Line 177
  '%' always 37
Line 178
  == always {!<=-1,!>=2}
  0 always 0
Line 179
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 180
  ( always !<=0
  . always !0
Line 182
  '&' always 38
Line 183
  ( always !<=-1
Line 185
  '|' always 124
Line 186
  ( always !<=-1
Line 188
  '^' always 94
Line 189
  ( always !<=-1
Line 192
  nullptr always 0
  "Unhandled calculation" always "Unhandled calculation"
Line 196
  '+' always 43
Line 199
  '-' always 45
Line 202
  '*' always 42
Line 205
  '/' always 47
Line 206
  == always {!<=-1,!>=2}
  0 always 0
Line 207
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 208
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  <= always {!<=-1,!>=2}
  1 always 1
Line 209
  nullptr always 0
  "Internal Error: Division overflow" always "Internal Error: Division overflow"
Line 212
  '%' always 37
Line 213
  == always {!<=-1,!>=2}
  0 always 0
Line 214
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 215
  . always !0
Line 217
  '&' always 38
Line 220
  '|' always 124
Line 223
  '^' always 94
Line 227
  nullptr always 0
  "Unhandled calculation" always "Unhandled calculation"
Line 236
  this always !0
Line 240
  . possible {>=symbolic=(v.getDoubleValue()+1),<=symbolic=(v.getDoubleValue())}
  < always {!<=-1,!>=2}
Line 241
  -1 always -1
Line 242
  . {!<=symbolic=(v.getDoubleValue()-1),>=symbolic=(v.getDoubleValue())}
  > always {!<=-1,!>=2}
  ( {!>=symbolic=(temp.mDoubleValue+1),<=symbolic=(temp.mDoubleValue)}
Line 243
  1 always 1
Line 244
  0 always 0
Line 248
  ( {!<=-1,>=symbolic=((unsigned long long)v.mIntValue+1),<=symbolic=((unsigned long long)v.mIntValue)}
  < always {!<=-1,!>=2}
  ( {!<=-1,<=symbolic=((unsigned long long)mIntValue-1),>=symbolic=((unsigned long long)mIntValue)}
Line 249
  -1 always -1
Line 250
  ( {!<=-1,!<=symbolic=((unsigned long long)v.mIntValue-1),>=symbolic=((unsigned long long)v.mIntValue)}
  > always {!<=-1,!>=2}
  ( {!<=-1,!>=symbolic=((unsigned long long)mIntValue+1),<=symbolic=((unsigned long long)mIntValue)}
Line 251
  1 always 1
Line 252
  0 always 0
Line 255
  < always {!<=-1,!>=2}
Line 256
  -1 always -1
Line 257
  mIntValue {!<=symbolic=(v.mIntValue-1),>=symbolic=(v.mIntValue)}
  > always {!<=-1,!>=2}
  . {!>=symbolic=(mIntValue+1),<=symbolic=(mIntValue)}
Line 258
  1 always 1
Line 259
  0 always 0
Line 264
  this always !0
Line 265
  ( always {!<=-1,!>=2}
Line 274
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 275
  nullptr always 0
  "Shift operand is not integer" always "Shift operand is not integer"
Line 276
  this always !0
Line 277
  >= always {!<=-1,!>=2}
Line 280
  . {!>=symbolic=(MathLib::bigint_bits),<=symbolic=(MathLib::bigint_bits-1)}
Line 286
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 287
  nullptr always 0
  "Shift operand is not integer" always "Shift operand is not integer"
Line 288
  this always !0
Line 289
  >= always {!<=-1,!>=2}
Line 292
  . {!>=symbolic=(MathLib::bigint_bits),<=symbolic=(MathLib::bigint_bits-1)}
Line 297
  ( always !<=-1
Line 300
  ( always {!<=-1,!>=2}
Line 302
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  16 always 16
Line 303
  return always !<=-1
  ret always !<=-1
Line 305
  nullptr always 0
  "Internal Error. MathLib::toULongNumber: out_of_range: " always "Internal Error. MathLib::toULongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 310
  ( always {!<=-1,!>=2}
Line 312
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  8 always 8
Line 313
  return always !<=-1
  ret always !<=-1
Line 315
  nullptr always 0
  "Internal Error. MathLib::toULongNumber: out_of_range: " always "Internal Error. MathLib::toULongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 320
  ( always {!<=-1,!>=2}
Line 321
  ret always !<=-1
  ret always !<=-1
  = always 0
  0 always 0
Line 322
  i always !<=-1
  = {2,3,!<=-1}
  0 always 0
  == always {!<=-1,!>=2}
  '0' always 48
  ? possible {2,3}
  2 always 2
  : always 3
  3 always 3
  i {!<=-1,2,3}
  < always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 323
  [ possible {48,49}
  i {!<=-1,<=symbolic=(str.length()-1),!>=symbolic=(str.length())}
  != {!<=-1,!>=2,1,0}
  '1' always 49
  && always {!<=-1,!>=2}
  i always {!<=-1,!>=symbolic=(str.length())}
  != always {!<=-1,!>=2}
  '0' always 48
Line 325
  ret always !<=-1
  <<= always !<=-1
  1 always 1
Line 326
  [ possible {49,48}
  i always !<=-1
  == {!<=-1,!>=2,1,0}
  '1' always 49
Line 327
  ret always !<=-1
  |= always !<=-1
  1 always 1
Line 331
  return always !<=-1
  ret always !<=-1
Line 334
  ( always {!<=-1,!>=2}
Line 337
  ( {lifetime[Object]=(str),!0}
Line 338
  doubleval always symbolic=(std::atof(str.c_str()))
  > always {!<=-1,!>=2}
Line 339
  return always !<=-1
Line 341
  return always !<=-1
  ( always !<=-1
Line 345
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  10 always 10
Line 346
  return always !<=-1
  ret always !<=-1
Line 348
  nullptr always 0
  "Internal Error. MathLib::toULongNumber: out_of_range: " always "Internal Error. MathLib::toULongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 352
  ( always !<=-1
Line 354
  retval always !<=-1
  retval always !<=-1
  = always 0
  0 always 0
Line 356
  retval always !<=-1
  = always !<=-1
  retval {!<=-1,0}
  << {!<=-1,0}
  8 always 8
  | always !<=-1
Line 358
  return always !<=-1
  retval always !<=-1
Line 364
  ( always {!<=-1,!>=2}
  str possible {>=size=2@159,<=size=1@159}
Line 366
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  16 always 16
Line 367
  ret always !<=-1
Line 369
  nullptr always 0
  "Internal Error. MathLib::toLongNumber: out_of_range: " always "Internal Error. MathLib::toLongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 374
  ( always {!<=-1,!>=2}
Line 376
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  8 always 8
Line 377
  ret always !<=-1
Line 379
  nullptr always 0
  "Internal Error. MathLib::toLongNumber: out_of_range: " always "Internal Error. MathLib::toLongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 384
  ( always {!<=-1,!>=2}
Line 385
  = always 0
  0 always 0
Line 386
  i always !<=-1
  = {2,3,!<=-1}
  0 always 0
  == always {!<=-1,!>=2}
  '0' always 48
  ? possible {2,3}
  2 always 2
  : always 3
  3 always 3
  i {!<=-1,2,3}
  < always {!<=-1,!>=2}
  ( always !<=-1
  i always !<=-1
  ++ always !<=-1
Line 387
  [ possible {48,49}
  i {!<=-1,<=symbolic=(str.length()-1),!>=symbolic=(str.length())}
  != {!<=-1,!>=2,1,0}
  '1' always 49
  && always {!<=-1,!>=2}
  i always {!<=-1,!>=symbolic=(str.length())}
  != always {!<=-1,!>=2}
  '0' always 48
Line 389
  1 always 1
Line 390
  [ possible {49,48}
  i always !<=-1
  == {!<=-1,!>=2,1,0}
  '1' always 49
Line 391
  1 always 1
Line 393
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
Line 398
  ( always {!<=-1,!>=2}
Line 402
  doubleval always symbolic=(toDoubleNumber(str))
  > always {!<=-1,!>=2}
Line 404
  < always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 414
  ret always !<=-1
  = always !<=-1
  ( always !<=-1
  nullptr always 0
  10 always 10
Line 415
  ret always !<=-1
Line 417
  nullptr always 0
  "Internal Error. MathLib::toLongNumber: out_of_range: " always "Internal Error. MathLib::toLongNumber: out_of_range: "
  " (" always " ("
  ")" always ")"
Line 424
  = always 0
  0. always 0
Line 425
  positivesign always {!<=-1,!>=2}
  positivesign always {!<=-1,!>=2}
  = always 1
  true always 1
Line 427
  '+' always 43
  == {!<=-1,!>=2,0}
  * possible 45
  from possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
Line 428
  from possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
  1 always 1
Line 429
  '-' always 45
  == always {!<=-1,!>=2}
  * always !43
  from possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
Line 430
  from possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
  1 always 1
Line 431
  positivesign always {!<=-1,!>=2}
  = always 0
  false always 0
Line 433
  = possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
  from possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
Line 434
  decimalsep always !<=-1
  = always !<=-1
  ( always !<=-1
  '.' always 46
  it possible {symbolic=(from+1),symbolic=(from),lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,start=2@130}
  ( {lifetime[Iterator]=(str),start=0}
Line 436
  == always {!<=-1,!>=2}
  decimalsep {symbolic=(str.find('.',it-str.begin())),!<=-1,>=symbolic=(to-str.begin()+1),<=symbolic=(to-str.begin())}
Line 437
  it possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131}
Line 438
  decimalsep {symbolic=(str.find('.',it-str.begin())),!<=-1}
  > always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),start=0}
Line 439
  0. always 0
Line 441
  ( {symbolic=(str.find('.',it-str.begin())),!>=symbolic=(to-str.begin()+1),<=symbolic=(to-str.begin())}
  decimalsep {symbolic=(str.find('.',it-str.begin())),!<=-1,!>=symbolic=(to-str.begin()+1),<=symbolic=(to-str.begin())}
  ( {lifetime[Iterator]=(str),start=0}
Line 442
  = possible lifetime[Lambda]=(base)
  [ possible lifetime[Lambda]=(base)
Line 443
  10 always 10
  < always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  '9' always 57
Line 444
  10 always 10
  + possible >=68
  ( possible >=58
  c {>=58,!<=57}
  - {>=-29,!<=-30}
  'a' always 97
Line 446
  c possible <=57
  - {<=9,!>=10}
  '0' always 48
Line 448
  it inconclusive {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131}
  != always {!<=-1,!>=2}
  to possible {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131,lifetime[Iterator]=(str)@131,end=0@131}
  it inconclusive {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131}
Line 449
  '.' always 46
  == always {!<=-1,!>=2}
  it inconclusive {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131}
Line 453
  digitval possible lifetime[Lambda]=(base)
  * always !46
  it inconclusive {lifetime[Iterator]=(str)@130,lifetime[Iterator]=(str)@131}
Line 455
  positivesign always {!<=-1,!>=2}
Line 462
  p always !<=-1
  = always !<=-1
  ( always !<=-1
  "pP" always "pP"
  3 always 3
Line 463
  ( {lifetime[Iterator]=(str),start=0}
  + {lifetime[Iterator]=(str),start=2}
  2 always 2
  ( {lifetime[Iterator]=(str),start=0}
  + {lifetime[Iterator]=(str),!<=start=-1}
  p {symbolic=(str.find_first_of("pP",3)),!<=-1}
  16 always 16
Line 464
  suffix always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'f' always 102
  || always {!<=-1,!>=2}
  ( always !102
  == always {!<=-1,!>=2}
  'F' always 70
  || always {!<=-1,!>=2}
  ( always {!102,!70}
  == always {!<=-1,!>=2}
  'l' always 108
  || always {!<=-1,!>=2}
  ( always {!70,!108}
  == always {!<=-1,!>=2}
  'L' always 76
Line 465
  ( {lifetime[Iterator]=(str),start=0}
  + {lifetime[Iterator]=(str),!<=start=-1}
  p always !<=-1
  + {lifetime[Iterator]=(str),!<=start=0}
  1 always 1
  suffix {symbolic=((str.back()=='f')||(str.back()=='F')||(str.back()=='l')||(str.back()=='L')),!<=-1,!>=2}
  ? {lifetime[Iterator]=(str),lifetime[Iterator]=(str),end=0}
  ( {lifetime[Iterator]=(str),end=0}
  - {lifetime[Iterator]=(str),end=-1}
  1 always 1
  : {lifetime[Iterator]=(str),lifetime[Iterator]=(str),end=0}
  ( {lifetime[Iterator]=(str),end=0}
  10 always 10
Line 466
  2 always 2
Line 467
  factor2 always symbolic=(std::pow(2,exponent))
Line 472
  ( always {!<=-1,!>=2}
  str possible "1"@21608
Line 476
  nullptr always 0
  "Internal Error. MathLib::toLongNumber: characterLiteralToLL(" always "Internal Error. MathLib::toLongNumber: characterLiteralToLL("
  ") => " always ") => "
Line 479
  ( always {!<=-1,!>=2}
Line 482
  ( always {!<=-1,!>=2}
Line 483
  0.0 always 0
Line 489
  ( always {!<=-1,!>=2}
Line 502
  12 always 12
Line 504
  == always {!<=-1,!>=2}
  "-0" always "-0"
Line 505
  "0.0" always "0.0"
Line 506
  '.' always 46
  == always {!<=-1,!>=2}
Line 507
  ".0" always ".0"
Line 511
  ( always {!<=-1,!>=2}
Line 513
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 516
  ( always {!<=-1,!>=2}
Line 518
  ( always {!<=-1,!>=2}
Line 519
  return always {!<=-1,!>=2}
  false always 0
Line 521
  START always 0
  BASE_DIGITS1 always 1
  LEADING_DECIMAL always 2
  TRAILING_DECIMAL always 3
  BASE_DIGITS2 always 4
  E always 5
  MANTISSA_PLUSMINUS always 6
  MANTISSA_DIGITS always 7
  SUFFIX_F always 8
  SUFFIX_L always 9
Line 523
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str always !size=0
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 524
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 525
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 526
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 529
  == always {!<=-1,!>=2}
  '.' always 46
Line 530
  = always 2
  :: always 2
  LEADING_DECIMAL always 2
Line 531
  ( always {!<=-1,!46}
  * always !46
Line 532
  = always 1
  :: always 1
  BASE_DIGITS1 always 1
Line 534
  return always {!<=-1,!>=2}
  false always 0
Line 536
  :: always 2
  LEADING_DECIMAL always 2
Line 537
  ( always !<=-1
Line 538
  = always 4
  :: always 4
  BASE_DIGITS2 always 4
Line 540
  return always {!<=-1,!>=2}
  false always 0
Line 542
  :: always 1
  BASE_DIGITS1 always 1
Line 543
  * possible {69,46}
  == {!<=-1,!>=2,0}
  'e' always 101
  || {!<=-1,!>=2,0}
  * possible 46
  == {!<=-1,!>=2,0}
  'E' always 69
Line 544
  = always 5
  :: always 5
  E always 5
Line 545
  * always {!101,!69}
  == always {!<=-1,!>=2}
  '.' always 46
Line 546
  = always 3
  :: always 3
  TRAILING_DECIMAL always 3
Line 547
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!101,!69,!46}
  * always {!101,!69,!46}
Line 548
  return always {!<=-1,!>=2}
  false always 0
Line 550
  :: always 3
  TRAILING_DECIMAL always 3
Line 551
  * possible {69,102,70,108,76}
  == {!<=-1,!>=2,0}
  'e' always 101
  || {!<=-1,!>=2,0}
  * possible {102,70,108,76}
  == {!<=-1,!>=2,0}
  'E' always 69
Line 552
  = always 5
  :: always 5
  E always 5
Line 553
  * {70,108,76,!101,!69}
  == {!<=-1,!>=2,0}
  'f' always 102
  || {!<=-1,!>=2,0}
  * {108,76,!101,!69}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 554
  = always 8
  :: always 8
  SUFFIX_F always 8
Line 555
  * {76,!101,!69,!102,!70}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  * always {!101,!69,!102,!70}
  == always {!<=-1,!>=2}
  'L' always 76
Line 556
  = always 9
  :: always 9
  SUFFIX_L always 9
Line 557
  ( always {!<=-1,!101,!69,!102,!70,!108,!76}
  * always {!101,!69,!102,!70,!108,!76}
Line 558
  = always 4
  :: always 4
  BASE_DIGITS2 always 4
Line 560
  return always {!<=-1,!>=2}
  false always 0
Line 562
  :: always 4
  BASE_DIGITS2 always 4
Line 563
  * possible {69,102,70,108,76}
  == {!<=-1,!>=2,0}
  'e' always 101
  || {!<=-1,!>=2,0}
  * possible {102,70,108,76}
  == {!<=-1,!>=2,0}
  'E' always 69
Line 564
  = always 5
  :: always 5
  E always 5
Line 565
  * {70,108,76,!101,!69}
  == {!<=-1,!>=2,0}
  'f' always 102
  || {!<=-1,!>=2,0}
  * {108,76,!101,!69}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 566
  = always 8
  :: always 8
  SUFFIX_F always 8
Line 567
  * {76,!101,!69,!102,!70}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  * always {!101,!69,!102,!70}
  == always {!<=-1,!>=2}
  'L' always 76
Line 568
  = always 9
  :: always 9
  SUFFIX_L always 9
Line 569
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!101,!69,!102,!70,!108,!76}
  * always {!101,!69,!102,!70,!108,!76}
Line 570
  return always {!<=-1,!>=2}
  false always 0
Line 572
  :: always 5
  E always 5
Line 573
  * possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '-' always 45
Line 574
  = always 6
  :: always 6
  MANTISSA_PLUSMINUS always 6
Line 575
  ( always {!<=-1,!43,!45}
  * always {!43,!45}
Line 576
  = always 7
  :: always 7
  MANTISSA_DIGITS always 7
Line 578
  return always {!<=-1,!>=2}
  false always 0
Line 580
  :: always 6
  MANTISSA_PLUSMINUS always 6
Line 581
  ! always {!<=-1,!>=2}
  ( always !<=-1
Line 582
  return always {!<=-1,!>=2}
  false always 0
Line 584
  = always 7
  :: always 7
  MANTISSA_DIGITS always 7
Line 586
  :: always 7
  MANTISSA_DIGITS always 7
Line 587
  * possible {70,108,76}
  == {!<=-1,!>=2,0}
  'f' always 102
  || {!<=-1,!>=2,0}
  * possible {108,76}
  == {!<=-1,!>=2,0}
  'F' always 70
Line 588
  = always 8
  :: always 8
  SUFFIX_F always 8
Line 589
  * {76,!102,!70}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  * always {!102,!70}
  == always {!<=-1,!>=2}
  'L' always 76
Line 590
  = always 9
  :: always 9
  SUFFIX_L always 9
Line 591
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!102,!70,!108,!76}
  * always {!102,!70,!108,!76}
Line 592
  return always {!<=-1,!>=2}
  false always 0
Line 594
  :: always 8
  SUFFIX_F always 8
Line 595
  return always {!<=-1,!>=2}
  false always 0
Line 596
  :: always 9
  SUFFIX_L always 9
Line 597
  return always {!<=-1,!>=2}
  false always 0
Line 600
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 603
  ( always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  false always 0
Line 607
  return always {!<=-1,!>=2}
  str always !size=0
  0 always 0
  == always {!<=-1,!>=2}
  '-' always 45
Line 610
  ( always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  false always 0
Line 614
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str always !size=0
Line 617
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 619
  START always 0
  SUFFIX_U always 1
  SUFFIX_UL always 2
  SUFFIX_ULL always 3
  SUFFIX_L always 4
  SUFFIX_LU always 5
  SUFFIX_LL always 6
  SUFFIX_LLU always 7
  SUFFIX_I always 8
  SUFFIX_I6 always 9
  SUFFIX_I64 always 10
  SUFFIX_UI always 11
  SUFFIX_UI6 always 12
  SUFFIX_UI64 always 13
Line 620
  it possible {lifetime[Iterator]=(str)@120,start=0@120}
  != always {!<=-1,!>=2}
  end possible {lifetime[Iterator]=(str)@114,lifetime[Iterator]=(str)@115,lifetime[Iterator]=(str)@116,lifetime[Iterator]=(str)@119,lifetime[Iterator]=(str)@120,end=0@114}
Line 623
  * possible {85,108,76,105,73}
  == {!<=-1,!>=2,0}
  'u' always 117
  || {!<=-1,!>=2,0}
  * possible {108,76,105,73}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 624
  = always 1
  :: always 1
  SUFFIX_U always 1
Line 625
  * {76,105,73,!117,!85}
  == {!<=-1,!>=2,0}
  'l' always 108
  || {!<=-1,!>=2,0}
  * {105,73,!117,!85}
  == {!<=-1,!>=2,0}
  'L' always 76
Line 627
  supportMicrosoftExtensions always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  * always {!117,!85,!108,!76}
  == always {!<=-1,!>=2}
  'i' always 105
  || always {!<=-1,!>=2}
  * always {!117,!85,!108,!76}
  == always {!<=-1,!>=2}
  'I' always 73
Line 628
  = always 8
  :: always 8
  SUFFIX_I always 8
Line 630
  return always {!<=-1,!>=2}
  false always 0
Line 632
  :: always 1
  SUFFIX_U always 1
Line 633
  * possible {76,105,73}
  == {!<=-1,!>=2,0}
  'l' always 108
  || {!<=-1,!>=2,0}
  * possible {105,73}
  == {!<=-1,!>=2,0}
  'L' always 76
Line 634
  = always 2
  :: always 2
  SUFFIX_UL always 2
Line 635
  supportMicrosoftExtensions always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  * always {!108,!76}
  == always {!<=-1,!>=2}
  'i' always 105
  || always {!<=-1,!>=2}
  * always {!108,!76}
  == always {!<=-1,!>=2}
  'I' always 73
Line 636
  = always 11
  :: always 11
  SUFFIX_UI always 11
Line 638
  return always {!<=-1,!>=2}
  false always 0
Line 640
  :: always 2
  SUFFIX_UL always 2
Line 641
  * possible 76
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'L' always 76
Line 642
  = always 3
  :: always 3
  SUFFIX_ULL always 3
Line 644
  return always {!<=-1,!>=2}
  false always 0
Line 647
  * possible {85,108,76}
  == {!<=-1,!>=2,0}
  'u' always 117
  || {!<=-1,!>=2,0}
  * possible {108,76}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 648
  = always 5
  :: always 5
  SUFFIX_LU always 5
Line 649
  * {76,!117,!85}
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  * always {!117,!85}
  == always {!<=-1,!>=2}
  'L' always 76
Line 650
  = always 6
  :: always 6
  SUFFIX_LL always 6
Line 652
  return always {!<=-1,!>=2}
  false always 0
Line 654
  :: always 5
  SUFFIX_LU always 5
Line 655
  return always {!<=-1,!>=2}
  false always 0
Line 656
  :: always 6
  SUFFIX_LL always 6
Line 657
  * possible 85
  == {!<=-1,!>=2,0}
  'u' always 117
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'U' always 85
Line 658
  = always 7
  :: always 7
  SUFFIX_LLU always 7
Line 660
  return always {!<=-1,!>=2}
  false always 0
Line 662
  :: always 8
  SUFFIX_I always 8
Line 663
  == always {!<=-1,!>=2}
  '6' always 54
Line 664
  = always 9
  :: always 9
  SUFFIX_I6 always 9
Line 666
  return always {!<=-1,!>=2}
  false always 0
Line 668
  :: always 9
  SUFFIX_I6 always 9
Line 669
  == always {!<=-1,!>=2}
  '4' always 52
Line 670
  = always 10
  :: always 10
  SUFFIX_I64 always 10
Line 672
  return always {!<=-1,!>=2}
  false always 0
Line 674
  :: always 11
  SUFFIX_UI always 11
Line 675
  == always {!<=-1,!>=2}
  '6' always 54
Line 676
  = always 12
  :: always 12
  SUFFIX_UI6 always 12
Line 678
  return always {!<=-1,!>=2}
  false always 0
Line 680
  :: always 12
  SUFFIX_UI6 always 12
Line 681
  == always {!<=-1,!>=2}
  '4' always 52
Line 682
  = always 13
  :: always 13
  SUFFIX_UI64 always 13
Line 684
  return always {!<=-1,!>=2}
  false always 0
Line 687
  return always {!<=-1,!>=2}
  false always 0
Line 690
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 691
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 692
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 693
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 694
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 696
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 697
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 698
  == always {!<=-1,!>=2}
Line 702
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  supportMicrosoftExtensions always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),start=0}
  ( {lifetime[Iterator]=(str),end=0}
  supportMicrosoftExtensions always {!<=-1,!>=2}
Line 718
  ( always {!<=-1,!>=2}
Line 721
  START always 0
  OCTAL_PREFIX always 1
  DIGITS always 2
Line 723
  str possible {"1"@5592944,"1"@5530224}
  ( always {!<=-1,!>=2}
Line 724
  return always {!<=-1,!>=2}
  false always 0
Line 725
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str {"1"@5592944,"1"@5530224,!size=0}
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 726
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 727
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 728
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 731
  == always {!<=-1,!>=2}
  '0' always 48
Line 732
  = always 1
  :: always 1
  OCTAL_PREFIX always 1
Line 734
  return always {!<=-1,!>=2}
  false always 0
Line 736
  :: always 1
  OCTAL_PREFIX always 1
Line 737
  ( always {!<=-1,!>=2}
  ( always !<=-1
Line 738
  = always 2
  :: always 2
  DIGITS always 2
Line 740
  return always {!<=-1,!>=2}
  false always 0
Line 742
  :: always 2
  DIGITS always 2
Line 743
  ( always {!<=-1,!>=2}
  ( always !<=-1
Line 744
  = always 2
  :: always 2
  DIGITS always 2
Line 746
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 750
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 753
  ( always {!<=-1,!>=2}
Line 756
  START always 0
  HEX_0 always 1
  HEX_X always 2
  DIGIT always 3
Line 758
  str possible {"1"@5592943,"1"@5530223,>=size=2@160,<=size=1@160}
  ( {!<=-1,!>=2,0@160}
Line 759
  return always {!<=-1,!>=2}
  false always 0
Line 760
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str {"1"@5592943,"1"@5530223,!size=0,>=size=2@160,<=size=1@160}
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 761
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 762
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 763
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 766
  == always {!<=-1,!>=2}
  '0' always 48
Line 767
  = always 1
  :: always 1
  HEX_0 always 1
Line 769
  return always {!<=-1,!>=2}
  false always 0
Line 771
  :: always 1
  HEX_0 always 1
Line 772
  * possible 88
  == {!<=-1,!>=2,0}
  'x' always 120
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'X' always 88
Line 773
  = always 2
  :: always 2
  HEX_X always 2
Line 775
  return always {!<=-1,!>=2}
  false always 0
Line 777
  :: always 2
  HEX_X always 2
Line 778
  ( always !<=-1
Line 779
  = always 3
  :: always 3
  DIGIT always 3
Line 781
  return always {!<=-1,!>=2}
  false always 0
Line 783
  :: always 3
  DIGIT always 3
Line 784
  ( always !<=-1
Line 787
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 791
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 794
  ( always {!<=-1,!>=2}
Line 797
  START always 0
  HEX_0 always 1
  HEX_X always 2
  WHOLE_NUMBER_DIGIT always 3
  POINT always 4
  FRACTION always 5
  EXPONENT_P always 6
  EXPONENT_SIGN always 7
  EXPONENT_DIGITS always 8
  EXPONENT_SUFFIX always 9
Line 799
  ( always {!<=-1,!>=2}
Line 800
  return always {!<=-1,!>=2}
  false always 0
Line 801
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str always !size=0
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 802
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 803
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 804
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 807
  == always {!<=-1,!>=2}
  '0' always 48
Line 808
  = always 1
  :: always 1
  HEX_0 always 1
Line 810
  return always {!<=-1,!>=2}
  false always 0
Line 812
  :: always 1
  HEX_0 always 1
Line 813
  * possible 88
  == {!<=-1,!>=2,0}
  'x' always 120
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'X' always 88
Line 814
  = always 2
  :: always 2
  HEX_X always 2
Line 816
  return always {!<=-1,!>=2}
  false always 0
Line 818
  :: always 2
  HEX_X always 2
Line 819
  ( possible 0
  ( {!<=-1,46}
  * possible 46
Line 820
  = always 3
  :: always 3
  WHOLE_NUMBER_DIGIT always 3
Line 821
  == always {!<=-1,!>=2}
  '.' always 46
Line 822
  = always 4
  :: always 4
  POINT always 4
Line 824
  return always {!<=-1,!>=2}
  false always 0
Line 826
  :: always 3
  WHOLE_NUMBER_DIGIT always 3
Line 827
  ( possible 0
  ( {!<=-1,46,112,80}
  * possible {46,112,80}
Line 829
  * possible {112,80}
  == {!<=-1,!>=2,0}
  '.' always 46
Line 830
  = always 5
  :: always 5
  FRACTION always 5
Line 831
  * {80,!46}
  == {!<=-1,!>=2,0}
  'p' always 112
  || always {!<=-1,!>=2}
  * always !46
  == always {!<=-1,!>=2}
  'P' always 80
Line 832
  = always 6
  :: always 6
  EXPONENT_P always 6
Line 834
  return always {!<=-1,!>=2}
  false always 0
Line 836
  :: always 4
  POINT always 4
Line 837
  :: always 5
  FRACTION always 5
Line 838
  ( possible 0
  ( {!<=-1,112,80}
  * possible {112,80}
Line 839
  = always 5
  :: always 5
  FRACTION always 5
Line 840
  * possible 80
  == {!<=-1,!>=2,0}
  'p' always 112
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'P' always 80
Line 841
  = always 6
  :: always 6
  EXPONENT_P always 6
Line 843
  return always {!<=-1,!>=2}
  false always 0
Line 845
  :: always 6
  EXPONENT_P always 6
Line 846
  ( possible 0
  ( {!<=-1,43,45}
  * possible {43,45}
Line 847
  = always 8
  :: always 8
  EXPONENT_DIGITS always 8
Line 848
  * possible 45
  == {!<=-1,!>=2,0}
  '+' always 43
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '-' always 45
Line 849
  = always 7
  :: always 7
  EXPONENT_SIGN always 7
Line 851
  return always {!<=-1,!>=2}
  false always 0
Line 853
  :: always 7
  EXPONENT_SIGN always 7
Line 854
  ( always !<=-1
Line 855
  = always 8
  :: always 8
  EXPONENT_DIGITS always 8
Line 857
  return always {!<=-1,!>=2}
  false always 0
Line 859
  :: always 8
  EXPONENT_DIGITS always 8
Line 860
  ( possible 0
  ( {!<=-1,102,70,108,76}
  * possible {102,70,108,76}
Line 862
  * possible {70,108,76}
  == {!<=-1,!>=2,0}
  'f' always 102
  || {!<=-1,!>=2,0}
  * possible {108,76}
  == {!<=-1,!>=2,0}
  'F' always 70
  || {!<=-1,!>=2,0}
  * possible 76
  == {!<=-1,!>=2,0}
  'l' always 108
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'L' always 76
Line 863
  = always 9
  :: always 9
  EXPONENT_SUFFIX always 9
Line 865
  return always {!<=-1,!>=2}
  false always 0
Line 867
  :: always 9
  EXPONENT_SUFFIX always 9
Line 868
  return always {!<=-1,!>=2}
  false always 0
Line 871
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 884
  ( always {!<=-1,!>=2}
Line 887
  START always 0
  GNU_BIN_PREFIX_0 always 1
  GNU_BIN_PREFIX_B always 2
  DIGIT always 3
Line 889
  str possible {"1"@5592945,"1"@5530225}
  ( always {!<=-1,!>=2}
Line 890
  return always {!<=-1,!>=2}
  false always 0
Line 891
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str {"1"@5592945,"1"@5530225,!size=0}
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 892
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 893
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 894
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 897
  == always {!<=-1,!>=2}
  '0' always 48
Line 898
  = always 1
  :: always 1
  GNU_BIN_PREFIX_0 always 1
Line 900
  return always {!<=-1,!>=2}
  false always 0
Line 902
  :: always 1
  GNU_BIN_PREFIX_0 always 1
Line 903
  * possible 66
  == {!<=-1,!>=2,0}
  'b' always 98
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  'B' always 66
Line 904
  = always 2
  :: always 2
  GNU_BIN_PREFIX_B always 2
Line 906
  return always {!<=-1,!>=2}
  false always 0
Line 908
  :: always 2
  GNU_BIN_PREFIX_B always 2
Line 909
  * possible 49
  == {!<=-1,!>=2,0}
  '0' always 48
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '1' always 49
Line 912
  return always {!<=-1,!>=2}
  false always 0
Line 915
  * possible 49
  == {!<=-1,!>=2,0}
  '0' always 48
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  '1' always 49
Line 918
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 922
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 925
  ( always {!<=-1,!>=2}
Line 928
  START always 0
  DIGIT always 1
Line 930
  str possible {"1"@5592942,"1"@5530222}
  ( always {!<=-1,!>=2}
Line 931
  return always {!<=-1,!>=2}
  false always 0
Line 932
  = {lifetime[Iterator]=(str),!size=0,start=0}
  str {"1"@5592942,"1"@5530222,!size=0}
  ( {lifetime[Iterator]=(str),!size=0,start=0}
Line 933
  '+' always 43
  == {!<=-1,!>=2,0}
  * {45,!size=0}
  it {lifetime[Iterator]=(str),symbolic=(str.begin()),start=0}
  || always {!<=-1,!>=2}
  '-' always 45
  == always {!<=-1,!>=2}
  * always !size=0
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 934
  ++ always symbolic=(str.begin()+1)
  it {lifetime[Iterator]=(str),symbolic=(str.begin())}
Line 935
  it possible {lifetime[Iterator]=(str),symbolic=(str.begin())}
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 938
  ( always !<=-1
Line 941
  return always {!<=-1,!>=2}
  false always 0
Line 944
  ( always !<=-1
Line 947
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(str),end=0}
Line 951
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 954
  ( always {!<=-1,!>=2}
Line 956
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {"1"@21847,"1"@21602}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {"1"@21847,"1"@21602}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {"1"@21847,"1"@21602}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str possible {"1"@21847,"1"@21602}
Line 961
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
  && always {!<=-1,!>=2}
  value {>=size=4,!<=size=3}
  value {>=size=4,!<=size=3}
  ( {>=4,!<=3}
  - {>=1,!<=0}
  3 always 3
  == always {!<=-1,!>=2}
  'i' always 105
  && always {!<=-1,!>=2}
  value {>=size=4,!<=size=3}
  value {>=size=4,!<=size=3}
  ( {>=4,!<=3}
  - {>=2,!<=1}
  2 always 2
  == always {!<=-1,!>=2}
  '6' always 54
  && always {!<=-1,!>=2}
  ( always !<=-1
  - always !<=-1
  1 always 1
  == always {!<=-1,!>=2}
  '4' always 52
Line 962
  value {>=size=4,!<=size=3}
  value {>=size=4,!<=size=3}
  ( {>=4,!<=3}
  - {!<=-1,>=0}
  4 always 4
  == always {!<=-1,!>=2}
  'u' always 117
Line 963
  "ULL" always "ULL"
Line 964
  "LL" always "LL"
Line 966
  isUnsigned always {!<=-1,!>=2}
  isUnsigned always {!<=-1,!>=2}
  = always 0
  false always 0
Line 967
  longState always !<=-1
  longState always !<=-1
  = always 0
  0 always 0
Line 968
  i always !<=-1
  = always 1
  1U always 1
  i {!<=-1,1}
  < {!<=-1,!>=2,<=1}
  value possible <=size=3
  ( {!<=-1,<=3}
  ++ always !<=0
  i always !<=-1
Line 969
  value possible <=size=3
  value possible <=size=3
  ( {!<=-1,<=3}
  - {!<=0,!>=4,<=2}
  i {!<=-1,<=symbolic=(value.size()-1),!>=symbolic=(value.size()),1}
Line 970
  c {symbolic=(value[value.size()-i]),85,76,108}
  == {!<=-1,!>=2,0}
  'u' always 117
  || always {!<=-1,!>=2}
  c {symbolic=(value[value.size()-i]),76,108,!117}
  == {!<=-1,!>=2,0}
  'U' always 85
Line 971
  isUnsigned always {!<=-1,!>=2}
  = always 1
  true always 1
Line 972
  c {symbolic=(value[value.size()-i]),108,!117,!85}
  == {!<=-1,!>=2,0}
  'L' always 76
  || always {!<=-1,!>=2}
  c {symbolic=(value[value.size()-i]),!117,!85,!76}
  == always {!<=-1,!>=2}
  'l' always 108
Line 973
  longState always !<=-1
  ++ always !<=-1
Line 976
  longState {!<=-1,1,2}
  == {!<=-1,!>=2,0}
  0 always 0
Line 977
  isUnsigned {!<=-1,!>=2,0}
  ? possible {"U",""}
  "U" always "U"
  : always ""
  "" always ""
Line 978
  longState {2,!<=0}
  == {!<=-1,!>=2,0}
  1 always 1
Line 979
  isUnsigned always {!<=-1,!>=2}
  ? possible {"UL","L"}
  "UL" always "UL"
  : always "L"
  "L" always "L"
Line 980
  longState always {!<=1,!0}
  == always {!<=-1,!>=2}
  2 always 2
Line 981
  isUnsigned always {!<=-1,!>=2}
  ? possible {"ULL","LL"}
  "ULL" always "ULL"
  : always "LL"
  "LL" always "LL"
Line 982
  "" always ""
Line 989
  suffix1 {symbolic=(MathLib::getSuffix(first)),size=2,size=1,size=0}
  == {!<=-1,!>=2,0}
  "ULL" always "ULL"
  || always {!<=-1,!>=2}
  suffix2 always symbolic=(MathLib::getSuffix(second))
  == always {!<=-1,!>=2}
  "ULL" always "ULL"
Line 990
  "ULL" always "ULL"
Line 991
  suffix1 {symbolic=(MathLib::getSuffix(first)),size=2,size=1,size=0}
  == {!<=-1,!>=2,0}
  "LL" always "LL"
  || always {!<=-1,!>=2}
  suffix2 always symbolic=(MathLib::getSuffix(second))
  == always {!<=-1,!>=2}
  "LL" always "LL"
Line 992
  "LL" always "LL"
Line 993
  suffix1 possible {size=1,size=0}
  == {!<=-1,!>=2,0}
  "UL" always "UL"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "UL" always "UL"
Line 994
  "UL" always "UL"
Line 995
  suffix1 possible {size=1,size=0}
  == {!<=-1,!>=2,0}
  "L" always "L"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "L" always "L"
Line 996
  "L" always "L"
Line 997
  suffix1 possible size=0
  == {!<=-1,!>=2,0}
  "U" always "U"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "U" always "U"
Line 998
  "U" always "U"
Line 1000
  ( always {!<=-1,!>=2}
  suffix1 always !size=0
Line 1008
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  second possible "1"@84
Line 1013
  second possible "1"@84
Line 1015
  = always 0
  0 always 0
Line 1016
  d1 possible symbolic=(toDoubleNumber(first))
  > always {!<=-1,!>=2}
  100000.0 always 100000
  d2 possible symbolic=(toDoubleNumber(second))
  && always {!<=-1,!>=2}
  d1 possible {symbolic=(toDoubleNumber(first)),>=symbolic=(100000.0*d2+1)}
  d2 possible symbolic=(toDoubleNumber(second))
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ++ possible 1
  count possible 0
  < {!<=-1,!>=2,1}
  5 always 5
Line 1017
  10.0 always 10
Line 1018
  > always {!<=-1,!>=2}
  100000.0 always 100000
  d1 possible <=symbolic=(100000.0*d2)
  && always {!<=-1,!>=2}
  d2 possible >=symbolic=(100000.0*d1+1)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  5 always 5
Line 1019
  10.0 always 10
Line 1021
  d2 possible <=symbolic=(100000.0*d1)
Line 1030
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  second possible "1"@85
Line 1034
  == always {!<=-1,!>=2}
  second possible "1"@85
Line 1035
  "0.0" always "0.0"
Line 1037
  first always !symbolic=(second)
Line 1038
  second always !symbolic=(first)
Line 1040
  = always 0
  0 always 0
Line 1041
  d1 possible symbolic=(toDoubleNumber(first))
  > always {!<=-1,!>=2}
  100000.0 always 100000
  d2 possible symbolic=(toDoubleNumber(second))
  && always {!<=-1,!>=2}
  d1 possible {symbolic=(toDoubleNumber(first)),>=symbolic=(100000.0*d2+1)}
  d2 possible symbolic=(toDoubleNumber(second))
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ++ possible 1
  count possible 0
  < {!<=-1,!>=2,1}
  5 always 5
Line 1042
  10.0 always 10
Line 1043
  > always {!<=-1,!>=2}
  100000.0 always 100000
  d1 possible <=symbolic=(100000.0*d2)
  && always {!<=-1,!>=2}
  d2 possible >=symbolic=(100000.0*d1+1)
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
  5 always 5
Line 1044
  10.0 always 10
Line 1046
  d2 possible <=symbolic=(100000.0*d1)
Line 1058
  op possible size=2
  == always {!<=-1,!>=2}
  "++" always "++"
Line 1059
  "1" always "1"
Line 1060
  == always {!<=-1,!>=2}
  "--" always "--"
Line 1061
  "1" always "1"
Line 1064
  nullptr always 0
  "Unexpected operation '" always "Unexpected operation '"
  "' in MathLib::incdec(). Please report this to Cppcheck developers." always "' in MathLib::incdec(). Please report this to Cppcheck developers."
Line 1072
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1075
  b always symbolic=(toLongNumber(second))
  == always {!<=-1,!>=2}
  0 always 0
Line 1076
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 1077
  a always symbolic=(toLongNumber(first))
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always !<=-1
  b always !0
  <= always {!<=-1,!>=2}
  1 always 1
Line 1078
  nullptr always 0
  "Internal Error: Division overflow" always "Internal Error: Division overflow"
Line 1079
  b always !0
Line 1080
  ( always {!<=-1,!>=2}
Line 1081
  ( always {!<=-1,!>=2}
Line 1082
  "nan.0" always "nan.0"
Line 1083
  ( always {!<=-1,!>=2}
  "inf.0" always "inf.0"
  : always "-inf.0"
  "-inf.0" always "-inf.0"
Line 1094
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1106
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1108
  b always symbolic=(toLongNumber(second))
  == always {!<=-1,!>=2}
  0 always 0
Line 1109
  nullptr always 0
  "Internal Error: Division by zero" always "Internal Error: Division by zero"
Line 1110
  b {symbolic=(toLongNumber(second)),!0}
Line 1119
  '+' always 43
Line 1122
  '-' always 45
Line 1125
  '*' always 42
Line 1128
  '/' always 47
Line 1131
  '%' always 37
Line 1134
  '&' always 38
Line 1137
  '|' always 124
Line 1140
  '^' always 94
Line 1144
  nullptr always 0
  "Unexpected action '" always "Unexpected action '"
  "' in MathLib::calculate(). Please report this to Cppcheck developers." always "' in MathLib::calculate(). Please report this to Cppcheck developers."
Line 1165
  ( always !<=-1
Line 1167
  ( always {!<=-1,!>=2}
Line 1168
  1 always 1
  ( always !<=-1
  - always !<=-1
  1 always 1
Line 1172
  ( always {!<=-1,!>=2}
Line 1176
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 1179
  ( always {!<=-1,!>=2}
Line 1181
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 1185
  ( always {!<=-1,!>=2}
Line 1187
  return always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
Line 1191
  ( always {!<=-1,!>=2}
Line 1193
  return always {!<=-1,!>=2}
  >= always {!<=-1,!>=2}
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 1202
  ( always {!<=-1,!>=2}
Line 1204
  return always {!<=-1,!>=2}
  <= always {!<=-1,!>=2}
Line 1216
  ( always {!<=-1,!>=2}
Line 1218
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! {!<=-1,!>=2,1}
  ( possible 0
  ( {!<=-1,45,43}
  str always !size=0
  [ possible {45,43}
  0 always 0
  && always {!<=-1,!>=2}
  str always !size=0
  0 always 0
  != always {!<=-1,!>=2}
  '.' always 46
  && always {!<=-1,!>=2}
  str always !size=0
  0 always 0
  != always {!<=-1,!>=2}
  '-' always 45
  && always {!<=-1,!>=2}
  str always !size=0
  0 always 0
  != always {!<=-1,!>=2}
  '+' always 43
Line 1219
  return always {!<=-1,!>=2}
  false always 0
Line 1221
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str always !size=0
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str always !size=0
Line 1222
  return always {!<=-1,!>=2}
  false always 0
Line 1223
  isHex always {!<=-1,!>=2}
  isHex always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str always !size=0
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  str always !size=0
Line 1224
  str always !size=0
Line 1225
  ( possible {1,0}
  ( {!<=-1,48,112,80,69,101}
  i possible {48,112,80,69,101}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  '0' always 48
Line 1226
  return always {!<=-1,!>=2}
  false always 0
Line 1227
  i possible {80,69,101,48}
  == {!<=-1,!>=2,0}
  'p' always 112
  || always {!<=-1,!>=2}
  i {69,101,48,!112}
  == {!<=-1,!>=2,0}
  'P' always 80
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  isHex always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  i always {!112,!80}
  == always {!<=-1,!>=2}
  'E' always 69
  || always {!<=-1,!>=2}
  i always {!112,!80,!69}
  == always {!<=-1,!>=2}
  'e' always 101
Line 1228
  return always {!<=-1,!>=2}
  true always 1
Line 1229
  isHex always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  i always {!112,!80}
  && always {!<=-1,!>=2}
  i always {!112,!80}
  != always {!<=-1,!>=2}
  '0' always 48
Line 1230
  return always {!<=-1,!>=2}
  false always 0
Line 1232
  return always {!<=-1,!>=2}
  true always 1
Line 1235
  ( always {!<=-1,!>=2}
Line 1237
  return always {!<=-1,!>=2}
  c possible {<=55,>=56}
  >= {!<=-1,!>=2,<=1}
  '0' always 48
  && always {!<=-1,!>=2}
  c {>=48,!<=47}
  <= {!<=-1,!>=2,>=1}
  '7' always 55
Line 1240
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 1242
  iPos {!<=-1,>=symbolic=(iCode.size()),<=symbolic=(iCode.size()-1)}
  == always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  iPos always !<=0
  >= always {!<=-1,!>=2}
  ( always !<=-1
  || always {!<=-1,!>=2}
  iPos {!>=symbolic=(iCode.size()),<=symbolic=(iCode.size()-1),!<=0}
  != always {!<=-1,!>=2}
  '\'' always 39
Line 1243
  return always {!<=-1,!>=2}
  false always 0
Line 1244
  :: always !<=-1
  i always !<=-1
  i always !<=-1
  = always !<=-1
  iPos {!>=symbolic=(iCode.size()),<=symbolic=(iCode.size()-1),!<=0}
  - always !<=-1
  1 always 1
Line 1245
  i {symbolic=(iPos-1),!<=-1}
Line 1246
  i always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 1247
  return always {!<=-1,!>=2}
  true always 1
Line 1248
  -- always !<=-1
  i always !<=0
Line 1250
  i always !<=-1
  == always {!<=-1,!>=2}
  iPos {symbolic=(i+1),!>=symbolic=(iCode.size()),!<=0}
  - always !<=-1
  1 always 1
Line 1251
  return always {!<=-1,!>=2}
  false always 0
Line 1253
  i always {!<=-1,!symbolic=(iPos-1)}
Line 1254
  ' ' always 32
Line 1255
  '.' always 46
Line 1256
  ',' always 44
Line 1257
  'x' always 120
Line 1258
  '(' always 40
Line 1259
  '{' always 123
Line 1260
  '+' always 43
Line 1261
  '-' always 45
Line 1262
  '*' always 42
Line 1263
  '%' always 37
Line 1264
  '/' always 47
Line 1265
  '&' always 38
Line 1266
  '|' always 124
Line 1267
  '^' always 94
Line 1268
  '~' always 126
Line 1269
  '=' always 61
Line 1270
  return always {!<=-1,!>=2}
  true always 1
Line 1271
  '\'' always 39
Line 1272
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  i always !<=-1
Line 1274
  return always {!<=-1,!>=2}
  false always 0
Line 1281
  '+' always 43
Line 1286
  '-' always 45
Line 1291
  '*' always 42
Line 1296
  '/' always 47
Line 1301
  '%' always 37
Line 1306
  '&' always 38
Line 1311
  '|' always 124
Line 1316
  '^' always 94
