

##file cppcheck-2.8/lib/config.h

1:
|
78:
79: static const std :: string emptyString@var1 ;

##file cppcheck-2.8/lib/errortypes.h

1:
|
31:
32: class Token ;
33:
34:
35: struct InternalError {
36: enum Type { AST , SYNTAX , UNKNOWN_MACRO , INTERNAL , LIMIT , INSTANTIATION } ;
37: InternalError ( const Token * tok@var2 , const std :: string & errorMsg@var3 , Type type@var4 = INTERNAL ) ;
38: const Token * token@var5 ;
39: std :: string errorMessage@var6 ;
40: Type type@var7 ;
41: std :: string id@var8 ;
42: } ;
43:
44: class Certainty {
45: public:
46: enum CertaintyLevel {
47: normal , inconclusive , safe , experimental
48: } ;
49: } ;
50:
51: class Checks {
52: public:
53: enum CheckList {
54: unusedFunction , missingInclude , internalCheck
55: } ;
56: } ;
57:
58:
59: class Severity {
60: public:
61:
62:
63:
64: enum SeverityType {
65:
66:
67:
68: none ,
69:
|
73:
74: error ,
75:
|
79:
80: warning ,
81:
|
86:
87: style ,
88:
|
92:
93: performance ,
94:
|
100:
101: portability ,
102:
|
107:
108: information ,
109:
|
112:
113: debug
114: } ;
115:
116: static std :: string toString ( SeverityType severity@var9 ) ;
117: static SeverityType fromString ( const std :: string & severity@var10 ) ;
118: } ;
119:
120: struct CWE {
121: explicit CWE ( unsigned short cweId@var11 ) : id@var12 ( cweId@var11 ) { }
122: unsigned short id@var12 ;
123: } ;

##file cppcheck-2.8/lib/suppressions.h

1:
|
34:
35: class Tokenizer ;
36:
37:
38: class Suppressions {
39: public:
40:
41: struct ErrorMessage {
42: unsigned long hash@var13 ;
43: std :: string errorId@var14 ;
44: void setFileName ( const std :: string & s@var15 ) ;
45: const std :: string & getFileName ( ) const {
46: return mFileName@var19 ;
47: }
48: int lineNumber@var16 ;
49: Certainty :: CertaintyLevel certainty@var17 ;
50: std :: string symbolNames@var18 ;
51: private:
52: std :: string mFileName@var19 ;
53: } ;
54:
55: struct Suppression {
56: Suppression ( ) : lineNumber@var53 ( NO_LINE ) , hash@var55 ( 0 ) , thisAndNextLine@var56 ( false ) , matched@var57 ( false ) , checked@var58 ( false ) { }
57: Suppression ( const Suppression & other@var20 ) {
58: *@expr1073743011 this@expr1073743012 =@expr1073743013 other@var20 ;
59: }
60: Suppression ( const std :: string & id@var21 , const std :: string & file@var22 , int line@var23 = NO_LINE ) : errorId@var51 ( id@var21 ) , fileName@var52 ( file@var22 ) , lineNumber@var53 ( line@var23 ) , hash@var55 ( 0 ) , thisAndNextLine@var56 ( false ) , matched@var57 ( false ) , checked@var58 ( false ) { }
61:
62: Suppression & operator= ( const Suppression & other@var24 ) {
63: errorId@var51 =@expr1073743014 other@var24 .@expr1073743015 errorId@var25 ;
64: fileName@var52 =@expr1073743016 other@var24 .@expr1073743017 fileName@var26 ;
65: lineNumber@var53 =@expr1073743018 other@var24 .@expr1073743019 lineNumber@var27 ;
66: symbolName@var54 =@expr1073743020 other@var24 .@expr1073743021 symbolName@var28 ;
67: hash@var55 =@expr1073743022 other@var24 .@expr1073743023 hash@var29 ;
68: thisAndNextLine@var56 =@expr1073743024 other@var24 .@expr1073743025 thisAndNextLine@var30 ;
69: matched@var57 =@expr1073743026 other@var24 .@expr1073743027 matched@var31 ;
70: checked@var58 =@expr1073743028 other@var24 .@expr1073743029 checked@var32 ;
71: return *@expr1073743030 this@expr1073743031 ;
72: }
73:
74: bool operator< ( const Suppression & other@var33 ) const {
75: if (@expr1073743032 errorId@var51 !=@expr1073743033 other@var33 .@expr1210 errorId@var34 ) {
76: return errorId@var51 <@expr1073743035 other@var33 .@expr1210 errorId@var34 ; }
77: if (@expr1073743037 lineNumber@var53 <@expr1073743038 other@var33 .@expr1073743039 lineNumber@var35 ) {
78: return true ; }
79: if (@expr1073743040 fileName@var52 !=@expr1073743041 other@var33 .@expr1218 fileName@var36 ) {
80: return fileName@var52 <@expr1073743043 other@var33 .@expr1218 fileName@var36 ; }
81: if (@expr1073743045 symbolName@var54 !=@expr1073743046 other@var33 .@expr1223 symbolName@var37 ) {
82: return symbolName@var54 <@expr1073743048 other@var33 .@expr1223 symbolName@var37 ; }
83: if (@expr1073743050 hash@var55 !=@expr1073743051 other@var33 .@expr1228 hash@var38 ) {
84: return hash@var55 <@expr1073743053 other@var33 .@expr1228 hash@var38 ; }
85: if (@expr1073743055 thisAndNextLine@var56 !=@expr1073743056 other@var33 .@expr1073743057 thisAndNextLine@var39 ) {
86: return thisAndNextLine@var56 ; }
87: return false ;
88: }
89:
|
95:
96: bool parseComment ( std :: string comment@var40 , std :: string * errorMessage@var41 ) ;
97:
98: bool isSuppressed ( const ErrorMessage & errmsg@var42 ) const ;
99:
100: bool isMatch ( const ErrorMessage & errmsg@var43 ) ;
101:
102: std :: string getText ( ) const ;
103:
104: bool isLocal ( ) const {
105: return !@expr1073743059 fileName@var52 .@expr1073743060 empty (@expr1073743061 ) &&@expr1073743062 fileName@var52 .@expr1073743063 find_first_of (@expr1073743064 "?*" ) ==@expr1073743065 std ::@expr1073743066 string ::@expr1073743067 npos@expr1073743058 ;
106: }
107:
108: bool isSameParameters ( const Suppression & other@var44 ) const {
109: return errorId@var51 ==@expr1073743068 other@var44 .@expr1073743069 errorId@var45 &&@expr1073743070
110: fileName@var52 ==@expr1073743071 other@var44 .@expr1073743072 fileName@var46 &&@expr1073743073
111: lineNumber@var53 ==@expr1073743074 other@var44 .@expr1073743075 lineNumber@var47 &&@expr1073743076
112: symbolName@var54 ==@expr1073743077 other@var44 .@expr1073743078 symbolName@var48 &&@expr1073743079
113: hash@var55 ==@expr1073743080 other@var44 .@expr1073743081 hash@var49 &&@expr1073743082
114: thisAndNextLine@var56 ==@expr1073743083 other@var44 .@expr1073743084 thisAndNextLine@var50 ;
115: }
116:
117: std :: string errorId@var51 ;
118: std :: string fileName@var52 ;
119: int lineNumber@var53 ;
120: std :: string symbolName@var54 ;
121: unsigned long hash@var55 ;
122: bool thisAndNextLine@var56 ;
123: bool matched@var57 ;
124: bool checked@var58 ;
125:
126: enum Anonymous0 { NO_LINE = -1 } ;
127: } ;
128:
|
133:
134: std :: string parseFile ( std :: istream & istr@var59 ) ;
135:
|
140:
141: std :: string parseXmlFile ( const char * filename@var60 ) ;
142:
|
148:
149: static std :: vector < Suppression > parseMultiSuppressComment ( const std :: string & comment@var61 , std :: string * errorMessage@var62 ) ;
150:
|
155:
156: std :: string addSuppressionLine ( const std :: string & line@var63 ) ;
157:
|
163:
164: std :: string addSuppression ( const Suppression & suppression@var64 ) ;
165:
|
170:
171: std :: string addSuppressions ( const std :: list < Suppression > & suppressions@var65 ) ;
172:
|
177:
178: bool isSuppressed ( const ErrorMessage & errmsg@var66 ) ;
179:
|
184:
185: bool isSuppressedLocal ( const ErrorMessage & errmsg@var67 ) ;
186:
|
190:
191: void dump ( std :: ostream & out@var68 ) const ;
192:
|
196:
197: std :: list < Suppression > getUnmatchedLocalSuppressions ( const std :: string & file@var69 , const bool unusedFunctionChecking@var70 ) const ;
198:
|
202:
203: std :: list < Suppression > getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var71 ) const ;
204:
|
208:
209: const std :: list < Suppression > & getSuppressions ( ) const ;
210:
|
213:
214: void markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var72 ) ;
215:
216: private:
217:
218: std :: list < Suppression > mSuppressions@var73 ;
219: } ;

##file cppcheck-2.8/lib/color.h

1:
|
26:
27: enum class Color {
28: Reset = 0 ,
29: Bold = 1 ,
30: Dim = 2 ,
31: FgRed = 31 ,
32: FgGreen = 32 ,
33: FgBlue = 34 ,
34: FgMagenta = 35 ,
35: FgDefault = 39 ,
36: BgRed = 41 ,
37: BgGreen = 42 ,
38: BgBlue = 44 ,
39: BgDefault = 49
40: } ;
41: std :: ostream & operator<< ( std :: ostream & os@var74 , const Color & c@var75 ) ;
42:
43: std :: string toString ( const Color & c@var76 ) ;

##file cppcheck-2.8/lib/errorlogger.h

1:
|
39:
40: static const struct CWE CWE_USE_OF_UNINITIALIZED_VARIABLE@var77 ( 457U ) ;
41: static const struct CWE CWE_NULL_POINTER_DEREFERENCE@var78 ( 476U ) ;
42: static const struct CWE CWE_USE_OF_POTENTIALLY_DANGEROUS_FUNCTION@var79 ( 676U ) ;
43: static const struct CWE CWE_INCORRECT_CALCULATION@var80 ( 682U ) ;
44: static const struct CWE CWE_EXPIRED_POINTER_DEREFERENCE@var81 ( 825U ) ;
45:
46:
47: class Token ;
48: class TokenList ;
49:
50: namespace tinyxml2 {
51: class XMLElement ;
52: }
53:
|
59:
60: class ErrorMessage {
61: public:
62:
|
66:
67: class FileLocation {
68: public:
69: FileLocation ( )
70: : fileIndex@var97 ( 0 ) , line@var98 ( 0 ) , column@var99 ( 0 ) { }
71:
72: FileLocation ( const std :: string & file@var82 , int line@var83 , unsigned int column@var84 )
73: : fileIndex@var97 ( 0 ) , line@var98 ( line@var83 ) , column@var99 ( column@var84 ) , mOrigFileName@var101 ( file@var82 ) , mFileName@var102 ( file@var82 ) { }
74:
75: FileLocation ( const std :: string & file@var85 , const std :: string & info@var86 , int line@var87 , unsigned int column@var88 )
76: : fileIndex@var97 ( 0 ) , line@var98 ( line@var87 ) , column@var99 ( column@var88 ) , mOrigFileName@var101 ( file@var85 ) , mFileName@var102 ( file@var85 ) , mInfo@var103 ( info@var86 ) { }
77:
78: FileLocation ( const Token * tok@var89 , const TokenList * tokenList@var90 ) ;
79: FileLocation ( const Token * tok@var91 , const std :: string & info@var92 , const TokenList * tokenList@var93 ) ;
80:
|
85:
86: std :: string getfile ( bool convert@var94 = true ) const ;
87:
|
92:
93: std :: string getOrigFile ( bool convert@var95 = true ) const ;
94:
|
98:
99: void setfile ( const std :: string & file@var96 ) ;
100:
|
103:
104: std :: string stringify ( ) const ;
105:
106: unsigned int fileIndex@var97 ;
107: int line@var98 ;
108: unsigned int column@var99 ;
109:
110: std :: string getinfo ( ) const {
111: return mInfo@var103 ;
112: }
113: void setinfo ( const std :: string & i@var100 ) {
114: mInfo@var103 =@expr1073743085 i@var100 ;
115: }
116:
117: private:
118: std :: string mOrigFileName@var101 ;
119: std :: string mFileName@var102 ;
120: std :: string mInfo@var103 ;
121: } ;
122:
123: ErrorMessage ( const std :: list < FileLocation > & callStack@var104 ,
124: const std :: string & file1@var105 ,
125: Severity :: SeverityType severity@var106 ,
126: const std :: string & msg@var107 ,
127: const std :: string & id@var108 , Certainty :: CertaintyLevel certainty@var109 ) ;
128: ErrorMessage ( const std :: list < FileLocation > & callStack@var110 ,
129: const std :: string & file1@var111 ,
130: Severity :: SeverityType severity@var112 ,
131: const std :: string & msg@var113 ,
132: const std :: string & id@var114 ,
133: const CWE & cwe@var115 ,
134: Certainty :: CertaintyLevel certainty@var116 ) ;
135: ErrorMessage ( const std :: list < const Token * > & callstack@var117 ,
136: const TokenList * list@var118 ,
137: Severity :: SeverityType severity@var119 ,
138: const std :: string & id@var120 ,
139: const std :: string & msg@var121 ,
140: Certainty :: CertaintyLevel certainty@var122 ) ;
141: ErrorMessage ( const std :: list < const Token * > & callstack@var123 ,
142: const TokenList * list@var124 ,
143: Severity :: SeverityType severity@var125 ,
144: const std :: string & id@var126 ,
145: const std :: string & msg@var127 ,
146: const CWE & cwe@var128 ,
147: Certainty :: CertaintyLevel certainty@var129 ) ;
148: ErrorMessage ( const std :: list < std :: pair < const Token * , std :: string > > & errorPath@var130 ,
149: const TokenList * tokenList@var131 ,
150: Severity :: SeverityType severity@var132 ,
151: const char id@var133 [ ] ,
152: const std :: string & msg@var134 ,
153: const CWE & cwe@var135 ,
154: Certainty :: CertaintyLevel certainty@var136 ) ;
155: ErrorMessage ( ) ;
156: explicit ErrorMessage ( const tinyxml2 :: XMLElement * const errmsg@var137 ) ;
157:
|
160:
161: std :: string toXML ( ) const ;
162:
163: static std :: string getXMLHeader ( ) ;
164: static std :: string getXMLFooter ( ) ;
165:
|
174:
175: std :: string toString ( bool verbose@var138 ,
176: const std :: string & templateFormat@var139 = emptyString@var1 ,
177: const std :: string & templateLocation@var140 = emptyString@var1 ) const ;
178:
179: std :: string serialize ( ) const ;
180: bool deserialize ( const std :: string & data@var141 ) ;
181:
182: std :: list < FileLocation > callStack@var142 ;
183: std :: string id@var143 ;
184:
185:
186: std :: string file0@var144 ;
187:
188: std :: string function@var145 ;
189:
190: bool incomplete@var146 ;
191:
192: Severity :: SeverityType severity@var147 ;
193: CWE cwe@var148 ;
194: Certainty :: CertaintyLevel certainty@var149 ;
195:
196:
197: unsigned long hash@var150 ;
198:
199:
200: void setmsg ( const std :: string & msg@var151 ) ;
201:
202:
203: const std :: string & shortMessage ( ) const {
204: return mShortMessage@var153 ;
205: }
206:
207:
208: const std :: string & verboseMessage ( ) const {
209: return mVerboseMessage@var154 ;
210: }
211:
212:
213: const std :: string & symbolNames ( ) const {
214: return mSymbolNames@var155 ;
215: }
216:
217: Suppressions :: ErrorMessage toSuppressionsErrorMessage ( ) const ;
218:
219: private:
220: static std :: string fixInvalidChars ( const std :: string & raw@var152 ) ;
221:
222:
223: std :: string mShortMessage@var153 ;
224:
225:
226: std :: string mVerboseMessage@var154 ;
227:
228:
229: std :: string mSymbolNames@var155 ;
230: } ;
231:
|
235:
236: class ErrorLogger {
237: protected:
238: std :: ofstream plistFile@var156 ;
239: public:
240: ErrorLogger ( ) { }
241: virtual ~ ErrorLogger ( ) {
242: if (@expr1073743086 plistFile@var156 .@expr1073743087 is_open (@expr1073743088 ) ) {
243: plistFile@var156 <<@expr1073743089 ErrorLogger ::@expr1073743090 plistFooter (@expr1073743091 ) ;
244: plistFile@var156 .@expr1073743092 close (@expr1073743093 ) ;
245: }
246: }
247:
|
253:
254: virtual void reportOut ( const std :: string & outmsg@var157 , Color c@var158 = Color :: Reset ) = 0 ;
255:
|
261:
262: virtual void reportErr ( const ErrorMessage & msg@var159 ) = 0 ;
263:
|
269:
270: virtual void reportProgress ( const std :: string & filename@var160 , const char stage@var161 [ ] , const unsigned long value@var162 ) {
271: (@expr1073743094 void ) filename@var160 ;
272: (@expr1073743095 void ) stage@var161 ;
273: (@expr1073743096 void ) value@var162 ;
274: }
275:
|
279:
280: virtual void reportInfo ( const ErrorMessage & msg@var163 ) {
281: reportErr (@expr1073743097 msg@var163 ) ;
282: }
283:
|
288:
289: bool reportUnmatchedSuppressions ( const std :: list < Suppressions :: Suppression > & unmatched@var164 ) ;
290:
291: static std :: string callStackToString ( const std :: list < ErrorMessage :: FileLocation > & callStack@var165 ) ;
292:
|
297:
298: static std :: string toxml ( const std :: string & str@var166 ) ;
299:
300: static std :: string plistHeader ( const std :: string & version@var167 , const std :: vector < std :: string > & files@var168 ) ;
301: static std :: string plistData ( const ErrorMessage & msg@var169 ) ;
302: static const char * plistFooter ( ) {
303: return " </array>\r\n</dict>\r\n</plist>"
304:
305: ;
306: }
307: } ;
308:
309:
310: std :: string replaceStr ( std :: string s@var170 , const std :: string & from@var171 , const std :: string & to@var172 ) ;

##file cppcheck-2.8/lib/mathlib.h

1:
|
33:
34: class MathLib {
35: friend class TestMathLib ;
36:
37: public:
38:
39: class value {
40: private:
41: long long mIntValue@var173 ;
42: double mDoubleValue@var174 ;
43: enum class Type { INT , LONG , LONGLONG , FLOAT } ; enum Type mType@var175 ;
44: bool mIsUnsigned@var176 ;
45:
46: void promote ( const value & v@var177 ) ;
47:
48: public:
49: explicit value ( const std :: string & s@var178 ) ;
50: std :: string str ( ) const ;
51: bool isInt ( ) const {
52: return mType@var175 !=@expr1073743098 Type ::@expr1073743099 FLOAT ;
53: }
54: bool isFloat ( ) const {
55: return mType@var175 ==@expr1073743100 Type ::@expr1073743101 FLOAT ;
56: }
57:
58: double getDoubleValue ( ) const {
59: return isFloat (@expr1073743102 ) ?@expr1073743103 mDoubleValue@var174 :@expr1073743104 (@expr1073743105 double ) mIntValue@var173 ;
60: }
61:
62: static value calc ( char op@var179 , const value & v1@var180 , const value & v2@var181 ) ;
63: int compare ( const value & v@var182 ) const ;
64: value add ( int v@var183 ) const ;
65: value shiftLeft ( const value & v@var184 ) const ;
66: value shiftRight ( const value & v@var185 ) const ;
67: } ;
68:
69:
70:
71: static const int bigint_bits@var186 ;
72:
73: static long long toLongNumber ( const std :: string & str@var187 ) ;
74: static unsigned long long toULongNumber ( const std :: string & str@var188 ) ;
75:
76: template < class T > static std :: string toString ( T value@var189 ) {
77: std ::@expr1073743106 ostringstream result@var190 ;
78: result@var190 <<@expr1073743107 value@var189 ;
79: return result@var190 .@expr1073743108 str (@expr1073743109 ) ;
80: }
81: static double toDoubleNumber ( const std :: string & str@var191 ) ;
82:
83: static bool isInt ( const std :: string & str@var192 ) ;
84: static bool isFloat ( const std :: string & str@var193 ) ;
85: static bool isDecimalFloat ( const std :: string & str@var194 ) ;
86: static bool isNegative ( const std :: string & str@var195 ) ;
87: static bool isPositive ( const std :: string & str@var196 ) ;
88: static bool isDec ( const std :: string & str@var197 ) ;
89: static bool isFloatHex ( const std :: string & str@var198 ) ;
90: static bool isIntHex ( const std :: string & str@var199 ) ;
91: static bool isOct ( const std :: string & str@var200 ) ;
92: static bool isBin ( const std :: string & str@var201 ) ;
93:
94: static std :: string getSuffix ( const std :: string & value@var202 ) ;
95:
|
101:
102: static bool isValidIntegerSuffix ( const std :: string & str@var203 , bool supportMicrosoftExtensions@var204 = true ) ;
103:
104: static std :: string add ( const std :: string & first@var205 , const std :: string & second@var206 ) ;
105: static std :: string subtract ( const std :: string & first@var207 , const std :: string & second@var208 ) ;
106: static std :: string multiply ( const std :: string & first@var209 , const std :: string & second@var210 ) ;
107: static std :: string divide ( const std :: string & first@var211 , const std :: string & second@var212 ) ;
108: static std :: string mod ( const std :: string & first@var213 , const std :: string & second@var214 ) ;
109: static std :: string incdec ( const std :: string & var@var215 , const std :: string & op@var216 ) ;
110: static std :: string calculate ( const std :: string & first@var217 , const std :: string & second@var218 , char action@var219 ) ;
111:
112: static std :: string sin ( const std :: string & tok@var220 ) ;
113: static std :: string cos ( const std :: string & tok@var221 ) ;
114: static std :: string tan ( const std :: string & tok@var222 ) ;
115: static std :: string abs ( const std :: string & tok@var223 ) ;
116: static bool isEqual ( const std :: string & first@var224 , const std :: string & second@var225 ) ;
117: static bool isNotEqual ( const std :: string & first@var226 , const std :: string & second@var227 ) ;
118: static bool isGreater ( const std :: string & first@var228 , const std :: string & second@var229 ) ;
119: static bool isGreaterEqual ( const std :: string & first@var230 , const std :: string & second@var231 ) ;
120: static bool isLess ( const std :: string & first@var232 , const std :: string & second@var233 ) ;
121: static bool isLessEqual ( const std :: string & first@var234 , const std :: string & second@var235 ) ;
122: static bool isNullValue ( const std :: string & str@var236 ) ;
123:
|
127:
128: static bool isOctalDigit ( char c@var237 ) ;
129:
130: static unsigned int encodeMultiChar ( const std :: string & str@var238 ) ;
131:
|
136:
137: static bool isDigitSeparator ( const std :: string & iCode@var239 , std :: string :: size_type iPos@var240 ) ;
138: } ;
139:
140: MathLib :: value operator+ ( const MathLib :: value & v1@var241 , const MathLib :: value & v2@var242 ) ;
141: MathLib :: value operator- ( const MathLib :: value & v1@var243 , const MathLib :: value & v2@var244 ) ;
142: MathLib :: value operator* ( const MathLib :: value & v1@var245 , const MathLib :: value & v2@var246 ) ;
143: MathLib :: value operator/ ( const MathLib :: value & v1@var247 , const MathLib :: value & v2@var248 ) ;
144: MathLib :: value operator% ( const MathLib :: value & v1@var249 , const MathLib :: value & v2@var250 ) ;
145: MathLib :: value operator& ( const MathLib :: value & v1@var251 , const MathLib :: value & v2@var252 ) ;
146: MathLib :: value operator| ( const MathLib :: value & v1@var253 , const MathLib :: value & v2@var254 ) ;
147: MathLib :: value operator^ ( const MathLib :: value & v1@var255 , const MathLib :: value & v2@var256 ) ;
148: MathLib :: value operator<< ( const MathLib :: value & v1@var257 , const MathLib :: value & v2@var258 ) ;
149: MathLib :: value operator>> ( const MathLib :: value & v1@var259 , const MathLib :: value & v2@var260 ) ;
150:
151: template < > std :: string MathLib :: toString < double > ( double value@var261 ) ;

##file cppcheck-2.8/lib/path.h

1:
|
39:
40: class Path {
41: public:
42:
|
46:
47: static std :: string toNativeSeparators ( std :: string path@var262 ) ;
48:
|
53:
54: static std :: string fromNativeSeparators ( std :: string path@var263 ) ;
55:
|
60:
61: static std :: string simplifyPath ( std :: string originalPath@var264 ) ;
62:
|
67:
68: static std :: string getPathFromFilename ( const std :: string & filename@var265 ) ;
69:
|
76:
77: static bool sameFileName ( const std :: string & fname1@var266 , const std :: string & fname2@var267 ) ;
78:
|
83:
84: static std :: string removeQuotationMarks ( std :: string path@var268 ) ;
85:
|
90:
91: static std :: string getFilenameExtension ( const std :: string & path@var269 ) ;
92:
|
97:
98: static std :: string getFilenameExtensionInLowerCase ( const std :: string & path@var270 ) ;
99:
|
103:
104: static std :: string getCurrentPath ( ) ;
105:
|
110:
111: static bool isAbsolute ( const std :: string & path@var271 ) ;
112:
|
118:
119: static std :: string getRelativePath ( const std :: string & absolutePath@var272 , const std :: vector < std :: string > & basePaths@var273 ) ;
120:
|
125:
126: static std :: string getAbsoluteFilePath ( const std :: string & filePath@var274 ) ;
127:
|
133:
134: static bool acceptFile ( const std :: string & filename@var275 ) {
135: const std ::@expr1073743110 set < std ::@expr1073743111 string > extra@var276 ;
136: return acceptFile (@expr1073743112 filename@var275 , extra@var276 ) ;
137: }
138:
|
145:
146: static bool acceptFile ( const std :: string & path@var277 , const std :: set < std :: string > & extra@var278 ) ;
147:
|
152:
153: static bool isC ( const std :: string & path@var279 ) ;
154:
|
159:
160: static bool isCPP ( const std :: string & path@var280 ) ;
161:
|
166:
167: static bool isHeader ( const std :: string & path@var281 ) ;
168:
|
173:
174: static std :: string stripDirectoryPart ( const std :: string & file@var282 ) ;
175:
|
180:
181: static bool fileExists ( const std :: string & file@var283 ) ;
182: } ;

##file cppcheck-2.8/lib/utils.h

1:
|
31:
32: struct SelectMapKeys {
33: template < class Pair >
34: Pair :: first_type operator() ( const Pair & p@var284 ) const {
35: return p@var284 .@expr1073743113 first@var285 ;
36: }
37: } ;
38:
39: struct SelectMapValues {
40: template < class Pair >
41: Pair :: second_type operator() ( const Pair & p@var286 ) const {
42: return p@var286 .@expr1073743114 second@var287 ;
43: }
44: } ;
45:
46: template < class Range , class T >
47: bool contains ( const Range & r@var288 , const T & x@var289 )
48: {
49: return std ::@expr1073743115 find (@expr1073743116 r@var288 .@expr1073743117 begin (@expr1073743118 ) , r@var288 .@expr1295 end (@expr1296 ) , x@var289 ) !=@expr1073743121 r@var288 .@expr1295 end (@expr1296 ) ;
50: }
51:
52: template < class T >
53: bool contains ( const std :: initializer_list < T > & r@var290 , const T & x@var291 )
54: {
55: return std ::@expr1073743124 find (@expr1073743125 r@var290 .@expr1073743126 begin (@expr1073743127 ) , r@var290 .@expr1304 end (@expr1305 ) , x@var291 ) !=@expr1073743130 r@var290 .@expr1304 end (@expr1305 ) ;
56: }
57:
58: template < class T , class U >
59: bool contains ( const std :: initializer_list < T > & r@var292 , const U & x@var293 )
60: {
61: return std ::@expr1073743133 find (@expr1073743134 r@var292 .@expr1073743135 begin (@expr1073743136 ) , r@var292 .@expr1313 end (@expr1314 ) , x@var293 ) !=@expr1073743139 r@var292 .@expr1313 end (@expr1314 ) ;
62: }
63:
64:
65: struct EnumClassHash {
66: template < typename T >
67: unsigned long operator() ( T t@var294 ) const
68: {
69: return static_cast < unsigned long > (@expr1073743142 t@var294 ) ;
70: }
71: } ;
72:
73: bool endsWith ( const std :: string & str@var295 , char c@var296 )
74: {
75: return !@expr1073743143 str@var295 .@expr1073743144 empty (@expr1073743145 ) &&@expr1073743146 str@var295 .@expr1073743147 back (@expr1073743148 ) ==@expr1073743149 c@var296 ;
76: }
77:
78: bool endsWith ( const std :: string & str@var297 , const char end@var298 [ ] , unsigned long endlen@var299 )
79: {
80: return (@expr1326 str@var297 .@expr1327 size (@expr1328 ) >=@expr1073743153 endlen@var299 ) &&@expr1073743154 (@expr1326 str@var297 .@expr1073743156 compare (@expr1073743157 str@var297 .@expr1327 size (@expr1328 ) -@expr1073743160 endlen@var299 , endlen@var299 , end@var298 ) ==@expr1073743161 0 ) ;
81: }
82:
83: template < unsigned long N >
84: bool endsWith ( const std :: string & str@var300 , const char ( & end@var301 ) [ N ] )
85: {
86: return endsWith (@expr1073743163 str@var300 , end@var301 , N@expr1073743162 -@expr1073743164 1 ) ;
87: }
88:
89: static bool isPrefixStringCharLiteral ( const std :: string & str@var302 , char q@var303 , const std :: string & p@var304 )
90: {
91: if (@expr1073743165 !@expr1073743166 endsWith (@expr1073743167 str@var302 , q@var303 ) ) {
92: return false ; }
93: if (@expr1073743168 (@expr1073743169 str@var302 .@expr1073743170 length (@expr1073743171 ) +@expr1073743172 1 ) >@expr1073743173 p@var304 .@expr1073743174 length (@expr1073743175 ) &&@expr1073743176 (@expr1073743177 str@var302 .@expr1073743178 compare (@expr1073743179 0 , p@var304 .@expr1073743180 size (@expr1073743181 ) +@expr1073743182 1 , p@var304 +@expr1073743183 q@var303 ) ==@expr1073743184 0 ) ) {
94: return true ; }
95: return false ;
96: }
97:
98: static bool isStringCharLiteral ( const std :: string & str@var305 , char q@var306 )
99: {
100: static const std ::@expr1361 vector < std ::@expr1361 string > suffixes@var307 {@expr1073743187 "" , "u8" , "u" , "U" , "L" } ;
101: for (@expr1073743188 const std ::@expr1361 string &@expr1073743190 p@var308 :@expr1073743191 suffixes@var307 ) {
102: if (@expr1073743192 isPrefixStringCharLiteral (@expr1073743193 str@var305 , q@var306 , p@var308 ) ) {
103: return true ; }
104: }
105: return false ;
106: }
107:
108: static bool isStringLiteral ( const std :: string & str@var309 )
109: {
110: return isStringCharLiteral (@expr1073743194 str@var309 , '"' ) ;
111: }
112:
113: static bool isCharLiteral ( const std :: string & str@var310 )
114: {
115: return isStringCharLiteral (@expr1073743195 str@var310 , '\'' ) ;
116: }
117:
118: static std :: string getStringCharLiteral ( const std :: string & str@var311 , char q@var312 )
119: {
120: const unsigned long quotePos@var313 =@expr1073743196 str@var311 .@expr1073743197 find (@expr1073743198 q@var312 ) ;
121: return str@var311 .@expr1073743199 substr (@expr1073743200 quotePos@var313 +@expr1073743201 1U , str@var311 .@expr1073743202 size (@expr1073743203 ) -@expr1073743204 quotePos@var313 -@expr1073743205 2U ) ;
122: }
123:
124: static std :: string getStringLiteral ( const std :: string & str@var314 )
125: {
126: if (@expr1073743206 isStringLiteral (@expr1073743207 str@var314 ) ) {
127: return getStringCharLiteral (@expr1073743208 str@var314 , '"' ) ; }
128: return "" ;
129: }
130:
131: static std :: string getCharLiteral ( const std :: string & str@var315 )
132: {
133: if (@expr1073743209 isCharLiteral (@expr1073743210 str@var315 ) ) {
134: return getStringCharLiteral (@expr1073743211 str@var315 , '\'' ) ; }
135: return "" ;
136: }
137:
138: static const char * getOrdinalText ( int i@var316 )
139: {
140: if (@expr1073743212 i@var316 ==@expr1073743213 1 ) {
141: return "st" ; }
142: if (@expr1073743214 i@var316 ==@expr1073743215 2 ) {
143: return "nd" ; }
144: if (@expr1073743216 i@var316 ==@expr1073743217 3 ) {
145: return "rd" ; }
146: return "th" ;
147: }
148:
149: int caseInsensitiveStringCompare ( const std :: string & lhs@var317 , const std :: string & rhs@var318 ) ;
150:
151: bool isValidGlobPattern ( const std :: string & pattern@var319 ) ;
152:
153: bool matchglob ( const std :: string & pattern@var320 , const std :: string & name@var321 ) ;
154:
155: bool matchglobs ( const std :: vector < std :: string > & patterns@var322 , const std :: string & name@var323 ) ;
156:
157: void strTolower ( std :: string & str@var324 ) ;

##file cppcheck-2.8/lib/valueflow.h

1:
|
36:
37: class ErrorLogger ;
38: struct InferModel ;
39: class Settings ;
40: class SymbolDatabase ;
41: class Token ;
42: class TokenList ;
43: class ValueType ;
44: class Variable ;
45: class Scope ;
46:
47: template < class T >
48: class ValuePtr ;
49:
50: namespace ValueFlow {
51: struct increment {
52: template < class T >
53: void operator() ( T & x@var325 ) const {
54: x@var325 ++@expr1073743218 ;
55: }
56: } ;
57: struct decrement {
58: template < class T >
59: void operator() ( T & x@var326 ) const {
60: x@var326 --@expr1073743219 ;
61: }
62: } ;
63:
64: struct less {
65: template < class T , class U >
66: bool operator() ( const T & x@var327 , const U & y@var328 ) const {
67: return x@var327 <@expr1073743220 y@var328 ;
68: }
69: } ;
70:
71: struct adjacent {
72: template < class T , class U >
73: bool operator() ( const T & x@var329 , const U & y@var330 ) const {
74: return std ::@expr1073743221 abs (@expr1073743222 x@var329 -@expr1073743223 y@var330 ) ==@expr1073743224 1 ;
75: }
76: } ;
77:
78: struct equalVisitor {
79: template < class T , class U >
80: void operator() ( bool & result@var331 , T x@var332 , U y@var333 ) const {
81: result@var331 =@expr1073743225 !@expr1073743226 (@expr1073743227 x@var332 >@expr1073743228 y@var333 ||@expr1073743229 x@var332 <@expr1073743230 y@var333 ) ;
82: }
83: } ;
84: class Value {
85: public:
86:
87:
88: enum class Bound { Upper , Lower , Point } ;
89:
90: explicit Value ( long long val@var334 = 0 , Bound b@var335 = Bound :: Point )
91: : valueType@var375 ( ValueType :: INT ) ,
92: bound@var376 ( b@var335 ) ,
93: intvalue@var377 ( val@var334 ) ,
94: tokvalue@var378 ( nullptr ) ,
95: floatValue@var379 ( 0.0 ) ,
96: moveKind@var380 ( MoveKind :: NonMovedVariable ) ,
97: varvalue@var381 ( val@var334 ) ,
98: condition@var382 ( nullptr ) ,
99: varId@var384 ( 0U ) ,
100: safe@var385 ( false ) ,
101: conditional@var386 ( false ) ,
102: macro@var387 ( false ) ,
103: defaultArg@var388 ( false ) ,
104: indirect@var389 ( 0 ) ,
105: path@var390 ( 0 ) ,
106: wideintvalue@var391 ( val@var334 ) ,
107: subexpressions@var392 ( ) ,
108: capturetok@var393 ( nullptr ) ,
109: lifetimeKind@var394 ( LifetimeKind :: Object ) ,
110: lifetimeScope@var395 ( LifetimeScope :: Local ) ,
111: valueKind@var400 ( ValueKind :: Possible )
112: { }
113: Value ( const Token * c@var336 , long long val@var337 , Bound b@var338 = Bound :: Point ) ;
114:
115: static Value unknown ( ) ;
116:
117: bool equalValue ( const ValueFlow :: Value & rhs@var339 ) const {
118: if (@expr1073743231 valueType@var375 !=@expr1073743232 rhs@var339 .@expr1073743233 valueType@var340 ) {
119: return false ; }
120: switch (@expr1073743234 valueType@var375 ) {
121: case ValueType ::@expr1073743235 INT :@expr1412
122: case ValueType ::@expr1073743237 CONTAINER_SIZE :@expr1412
123: case ValueType ::@expr1073743239 BUFFER_SIZE :@expr1412
124: case ValueType ::@expr1073743241 ITERATOR_START :@expr1412
125: case ValueType ::@expr1073743243 ITERATOR_END :@expr1412 ;
126: if (@expr1421 intvalue@var377 !=@expr1422 rhs@var339 .@expr1423 intvalue@var341 ) {
127: return false ; }
128: break ;
129: case ValueType ::@expr1073743248 TOK :@expr1412 ;
130: if (@expr1426 tokvalue@var378 !=@expr1427 rhs@var339 .@expr1428 tokvalue@var342 ) {
131: return false ; }
132: break ;
133: case ValueType ::@expr1073743253 FLOAT :@expr1412 ;
134:
135: if (@expr1073743255 floatValue@var379 >@expr1073743256 rhs@var339 .@expr1433 floatValue@var343 ||@expr1073743258 floatValue@var379 <@expr1073743259 rhs@var339 .@expr1433 floatValue@var343 ) {
136: return false ; }
137: break ;
138: case ValueType ::@expr1073743261 MOVED :@expr1412 ;
139: if (@expr1073743263 moveKind@var380 !=@expr1073743264 rhs@var339 .@expr1073743265 moveKind@var344 ) {
140: return false ; }
141: break ;
142: case ValueType ::@expr1073743266 UNINIT :@expr1412 ;
143: break ;
144: case ValueType ::@expr1073743268 LIFETIME :@expr1412 ;
145: if (@expr1426 tokvalue@var378 !=@expr1427 rhs@var339 .@expr1428 tokvalue@var342 ) {
146: return false ; }
147: break ;
148: case ValueType ::@expr1073743273 SYMBOLIC :@expr1412 ;
149: if (@expr1073743275 !@expr1073743276 sameToken (@expr1073743277 tokvalue@var378 , rhs@var339 .@expr1428 tokvalue@var342 ) ) {
150: return false ; }
151: if (@expr1421 intvalue@var377 !=@expr1422 rhs@var339 .@expr1423 intvalue@var341 ) {
152: return false ; }
153: break ;
154: }
155: return true ;
156: }
157:
158: template < class T , class F >
159: static void visitValue ( T & self@var345 , F f@var346 ) {
160: switch (@expr1073743282 self@var345 .@expr1073743283 valueType@var347 ) {
161: case ValueType ::@expr1073743284 INT :@expr1461
162: case ValueType ::@expr1073743286 SYMBOLIC :@expr1461
163: case ValueType ::@expr1073743288 BUFFER_SIZE :@expr1461
164: case ValueType ::@expr1073743290 CONTAINER_SIZE :@expr1461
165: case ValueType ::@expr1073743292 ITERATOR_START :@expr1461
166: case ValueType ::@expr1073743294 ITERATOR_END :@expr1461 ; {
167: f@var346 (@expr1073743296 self@var345 .@expr1073743297 intvalue@var348 ) ;
168: break ;
169: }
170: case ValueType ::@expr1073743298 FLOAT :@expr1461 ; {
171: f@var346 (@expr1073743300 self@var345 .@expr1073743301 floatValue@var349 ) ;
172: break ;
173: }
174: case ValueType ::@expr1073743302 UNINIT :@expr1461
175: case ValueType ::@expr1073743304 TOK :@expr1461
176: case ValueType ::@expr1073743306 LIFETIME :@expr1461
177: case ValueType ::@expr1073743308 MOVED :@expr1461 ;
178: break ;
179: }
180: }
181:
182: struct compareVisitor {
183: struct innerVisitor {
184: template < class Compare , class T , class U >
185: void operator() ( bool & result@var350 , Compare compare@var351 , T x@var352 , U y@var353 ) const {
186: result@var350 =@expr1073743310 compare@var351 (@expr1073743311 x@var352 , y@var353 ) ;
187: }
188: } ;
189: template < class Compare , class T >
190: void operator() ( bool & result@var354 , const Value & rhs@var355 , Compare compare@var356 , T x@var357 ) const {
191: visitValue (@expr1073743313 rhs@var355 ,
192: std ::@expr1073743314 bind (@expr1073743315 innerVisitor {@expr1073743316 } , std ::@expr1073743317 ref (@expr1073743318 result@var354 ) , std ::@expr1073743319 move (@expr1073743320 compare@var356 ) , x@var357 , std ::@expr1073743321 placeholders ::@expr1073743322 _1@expr1073743312 ) ) ;
193: }
194: } ;
195:
196: template < class Compare >
197: bool compareValue ( const Value & rhs@var358 , Compare compare@var359 ) const {
198: assert (@expr1073743324 (@expr1073743325 !@expr1073743326 this@expr1503 .@expr1073743328 isSymbolicValue (@expr1073743329 ) &&@expr1073743330 !@expr1073743331 rhs@var358 .@expr1073743332 isSymbolicValue (@expr1073743333 ) ) ||@expr1073743334
199: (@expr1073743335 this@expr1503 .@expr1073743336 valueType@var375 ==@expr1073743337 rhs@var358 .@expr1073743338 valueType@var360 &&@expr1073743339 sameToken (@expr1073743340 this@expr1503 .@expr1073743341 tokvalue@var378 , rhs@var358 .@expr1073743342 tokvalue@var361 ) ) ) ;
200: bool result@var362 ; result@var362 =@expr1073743343 false ;
201: visitValue (@expr1073743344
202: *@expr1073743345 this@expr1503 ,
203: std ::@expr1073743346 bind (@expr1073743347 compareVisitor {@expr1073743348 } , std ::@expr1525 ref (@expr1073743350 result@var362 ) , std ::@expr1525 ref (@expr1073743352 rhs@var358 ) , std ::@expr1073743353 move (@expr1073743354 compare@var359 ) , std ::@expr1073743355 placeholders ::@expr1073743356 _1@expr1073743323 ) ) ;
204: return result@var362 ;
205: }
206:
207: bool operator== ( const Value & rhs@var363 ) const {
208: if (@expr1073743357 !@expr1073743358 equalValue (@expr1073743359 rhs@var363 ) ) {
209: return false ; }
210:
211: return varvalue@var381 ==@expr1073743360 rhs@var363 .@expr1073743361 varvalue@var364 &&@expr1073743362
212: condition@var382 ==@expr1073743363 rhs@var363 .@expr1073743364 condition@var365 &&@expr1073743365
213: varId@var384 ==@expr1073743366 rhs@var363 .@expr1073743367 varId@var366 &&@expr1073743368
214: conditional@var386 ==@expr1073743369 rhs@var363 .@expr1073743370 conditional@var367 &&@expr1073743371
215: defaultArg@var388 ==@expr1073743372 rhs@var363 .@expr1073743373 defaultArg@var368 &&@expr1073743374
216: indirect@var389 ==@expr1073743375 rhs@var363 .@expr1073743376 indirect@var369 &&@expr1073743377
217: valueKind@var400 ==@expr1073743378 rhs@var363 .@expr1073743379 valueKind@var370 ;
218: }
219:
220: bool operator!= ( const Value & rhs@var371 ) const {
221: return !@expr1073743380 (@expr1073743381 *@expr1073743382 this@expr1073743383 ==@expr1073743384 rhs@var371 ) ;
222: }
223:
224: template < class T , $class $= $typename $std $:: $enable_if $< std :: is_arithmetic < T > $:: $value $> $:: $type >
225: bool equalTo ( const T & x@var372 ) const {
226: bool result@var373 ; result@var373 =@expr1073743386 false ;
227: visitValue (@expr1073743387 *@expr1073743388 this@expr1073743389 , std ::@expr1073743390 bind (@expr1073743391 equalVisitor {@expr1073743392 } , std ::@expr1073743393 ref (@expr1073743394 result@var373 ) , x@var372 , std ::@expr1073743395 placeholders ::@expr1073743396 _1@expr1073743385 ) ) ;
228: return result@var373 ;
229: }
230:
231: void decreaseRange ( ) {
232: if (@expr1073743397 bound@var376 ==@expr1073743398 Bound ::@expr1073743399 Lower ) {
233: visitValue (@expr1073743400 *@expr1577 this@expr1578 , increment {@expr1073743403 } ) ; }
234: else { if (@expr1073743404 bound@var376 ==@expr1073743405 Bound ::@expr1073743406 Upper ) {
235: visitValue (@expr1073743407 *@expr1577 this@expr1578 , decrement {@expr1073743409 } ) ; } }
236: }
237:
238: void invertBound ( ) {
239: if (@expr1073743410 bound@var376 ==@expr1073743411 Bound ::@expr1588 Lower ) {
240: bound@var376 =@expr1073743413 Bound ::@expr1590 Upper ; }
241: else { if (@expr1073743415 bound@var376 ==@expr1073743416 Bound ::@expr1590 Upper ) {
242: bound@var376 =@expr1073743418 Bound ::@expr1588 Lower ; } }
243: }
244:
245: void invertRange ( ) {
246: invertBound (@expr1073743420 ) ;
247: decreaseRange (@expr1073743421 ) ;
248: }
249:
250: void assumeCondition ( const Token * tok@var374 ) ;
251:
252: std :: string infoString ( ) const ;
253:
254: enum class ValueType {
255: INT ,
256: TOK ,
257: FLOAT ,
258: MOVED ,
259: UNINIT ,
260: CONTAINER_SIZE ,
261: LIFETIME ,
262: BUFFER_SIZE ,
263: ITERATOR_START ,
264: ITERATOR_END ,
265: SYMBOLIC
266: } ; enum ValueType valueType@var375 ;
267: bool isIntValue ( ) const {
268: return valueType@var375 ==@expr1073743423 ValueType ::@expr1073743424 INT@expr1073743422 ;
269: }
270: bool isTokValue ( ) const {
271: return valueType@var375 ==@expr1073743425 ValueType ::@expr1073743426 TOK ;
272: }
273: bool isFloatValue ( ) const {
274: return valueType@var375 ==@expr1073743427 ValueType ::@expr1073743428 FLOAT ;
275: }
276: bool isMovedValue ( ) const {
277: return valueType@var375 ==@expr1073743429 ValueType ::@expr1073743430 MOVED ;
278: }
279: bool isUninitValue ( ) const {
280: return valueType@var375 ==@expr1073743431 ValueType ::@expr1073743432 UNINIT ;
281: }
282: bool isContainerSizeValue ( ) const {
283: return valueType@var375 ==@expr1073743433 ValueType ::@expr1073743434 CONTAINER_SIZE ;
284: }
285: bool isLifetimeValue ( ) const {
286: return valueType@var375 ==@expr1073743435 ValueType ::@expr1073743436 LIFETIME ;
287: }
288: bool isBufferSizeValue ( ) const {
289: return valueType@var375 ==@expr1073743437 ValueType ::@expr1073743438 BUFFER_SIZE ;
290: }
291: bool isIteratorValue ( ) const {
292: return valueType@var375 ==@expr1073743439 ValueType ::@expr1073743440 ITERATOR_START ||@expr1073743441 valueType@var375 ==@expr1073743442 ValueType ::@expr1073743443 ITERATOR_END ;
293: }
294: bool isIteratorStartValue ( ) const {
295: return valueType@var375 ==@expr1073743444 ValueType ::@expr1073743445 ITERATOR_START ;
296: }
297: bool isIteratorEndValue ( ) const {
298: return valueType@var375 ==@expr1073743446 ValueType ::@expr1073743447 ITERATOR_END ;
299: }
300: bool isSymbolicValue ( ) const {
301: return valueType@var375 ==@expr1073743448 ValueType ::@expr1073743449 SYMBOLIC ;
302: }
303:
304: bool isLocalLifetimeValue ( ) const {
305: return valueType@var375 ==@expr1073743451 ValueType ::@expr1073743452 LIFETIME &&@expr1073743453 lifetimeScope@var395 ==@expr1073743454 LifetimeScope ::@expr1073743455 Local@expr1073743450 ;
306: }
307:
308: bool isArgumentLifetimeValue ( ) const {
309: return valueType@var375 ==@expr1073743456 ValueType ::@expr1073743457 LIFETIME &&@expr1073743458 lifetimeScope@var395 ==@expr1073743459 LifetimeScope ::@expr1073743460 Argument ;
310: }
311:
312: bool isSubFunctionLifetimeValue ( ) const {
313: return valueType@var375 ==@expr1073743461 ValueType ::@expr1073743462 LIFETIME &&@expr1073743463 lifetimeScope@var395 ==@expr1073743464 LifetimeScope ::@expr1073743465 SubFunction ;
314: }
315:
316: bool isNonValue ( ) const {
317: return isMovedValue (@expr1073743466 ) ||@expr1073743467 isUninitValue (@expr1073743468 ) ||@expr1073743469 isLifetimeValue (@expr1073743470 ) ;
318: }
319:
320:
321: Bound bound@var376 ;
322:
323:
324: long long intvalue@var377 ;
325:
326:
327: const Token * tokvalue@var378 ;
328:
329:
330: double floatValue@var379 ;
331:
332:
333: enum class MoveKind { NonMovedVariable , MovedVariable , ForwardedVariable } ; enum MoveKind moveKind@var380 ;
334:
335:
336: long long varvalue@var381 ;
337:
338:
339: const Token * condition@var382 ;
340:
341: std :: list < std :: pair < const Token * , std :: string > > errorPath@var383 ;
342:
343:
344: int varId@var384 ;
345:
346:
347: bool safe@var385 ;
348:
349:
350: bool conditional@var386 ;
351:
352:
353: bool macro@var387 ;
354:
355:
356: bool defaultArg@var388 ;
357:
358: int indirect@var389 ;
359:
360:
361: long long path@var390 ;
362:
363:
364: long long wideintvalue@var391 ;
365:
366: std :: vector < std :: string > subexpressions@var392 ;
367:
368:
369: const Token * capturetok@var393 ;
370:
371: enum class LifetimeKind {
372:
373: Object ,
374:
375: SubObject ,
376:
377: Lambda ,
378:
379: Iterator ,
380:
381: Address
382: } ; enum LifetimeKind lifetimeKind@var394 ;
383:
384: enum class LifetimeScope { Local , Argument , SubFunction , ThisPointer , ThisValue } ; enum LifetimeScope lifetimeScope@var395 ;
385:
386: static const char * toString ( MoveKind moveKind@var396 ) ;
387: static const char * toString ( LifetimeKind lifetimeKind@var397 ) ;
388: static const char * toString ( LifetimeScope lifetimeScope@var398 ) ;
389: static const char * toString ( Bound bound@var399 ) ;
390:
391:
392: enum class ValueKind {
393:
394: Possible ,
395:
396: Known ,
397:
398: Inconclusive ,
399:
400: Impossible
401: } ; enum ValueKind valueKind@var400 ;
402:
403: void setKnown ( ) {
404: valueKind@var400 =@expr1073743471 ValueKind ::@expr1073743472 Known ;
405: }
406:
407: bool isKnown ( ) const {
408: return valueKind@var400 ==@expr1073743473 ValueKind ::@expr1073743474 Known ;
409: }
410:
411: void setPossible ( ) {
412: valueKind@var400 =@expr1073743476 ValueKind ::@expr1073743477 Possible@expr1073743475 ;
413: }
414:
415: bool isPossible ( ) const {
416: return valueKind@var400 ==@expr1073743479 ValueKind ::@expr1073743480 Possible@expr1073743478 ;
417: }
418:
419: bool isImpossible ( ) const {
420: return valueKind@var400 ==@expr1073743481 ValueKind ::@expr1073743482 Impossible ;
421: }
422:
423: void setImpossible ( ) {
424: valueKind@var400 =@expr1073743483 ValueKind ::@expr1073743484 Impossible ;
425: }
426:
427: void setInconclusive ( bool inconclusive@var401 = true ) {
428: if (@expr1073743485 inconclusive@var401 ) {
429: valueKind@var400 =@expr1073743486 ValueKind ::@expr1073743487 Inconclusive ; }
430: }
431:
432: bool isInconclusive ( ) const {
433: return valueKind@var400 ==@expr1073743488 ValueKind ::@expr1073743489 Inconclusive ;
434: }
435:
436: void changeKnownToPossible ( ) {
437: if (@expr1073743491 isKnown (@expr1073743492 ) ) {
438: valueKind@var400 =@expr1073743493 ValueKind ::@expr1073743494 Possible@expr1073743490 ; }
439: }
440:
441: bool errorSeverity ( ) const {
442: return !@expr1073743495 condition@var382 &&@expr1073743496 !@expr1073743497 defaultArg@var388 ;
443: }
444:
445: static bool sameToken ( const Token * tok1@var402 , const Token * tok2@var403 ) ;
446: } ;
447:
448:
449: const ValueFlow :: Value * valueFlowConstantFoldAST ( Token * expr@var404 , const Settings * settings@var405 ) ;
450:
451:
452: void setValues ( TokenList * tokenlist@var406 , SymbolDatabase * symboldatabase@var407 , ErrorLogger * errorLogger@var408 , const Settings * settings@var409 ) ;
453:
454: std :: string eitherTheConditionIsRedundant ( const Token * condition@var410 ) ;
455:
456: unsigned long getSizeOf ( const ValueType & vt@var411 , const Settings * settings@var412 ) ;
457:
458: const ValueFlow :: Value * findValue ( const std :: list < ValueFlow :: Value > & values@var413 ,
459: const Settings * settings@var414 ,
460: std :: function < bool ( const ValueFlow :: Value & ) > pred@var415 ) ;
461:
462: std :: vector < ValueFlow :: Value > isOutOfBounds ( const Value & size@var416 , const Token * indexTok@var417 , bool possible@var418 = true ) ;
463: }
464:
465: ValueFlow :: Value asImpossible ( ValueFlow :: Value v@var419 ) ;
466:
467: bool isContainerSizeChanged ( const Token * tok@var420 , const Settings * settings@var421 = nullptr , int depth@var422 = 20 ) ;
468:
469: struct LifetimeToken {
470: const Token * token@var423 ;
471: bool addressOf@var424 ;
472: std :: list < std :: pair < const Token * , std :: string > > errorPath@var425 ;
473: bool inconclusive@var426 ;
474:
475: LifetimeToken ( ) : token@var423 ( nullptr ) , addressOf@var424 ( false ) , errorPath@var425 ( ) , inconclusive@var426 ( false ) { }
476:
477: LifetimeToken ( const Token * token@var427 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var428 )
478: : token@var423 ( token@var427 ) , addressOf@var424 ( false ) , errorPath@var425 ( std :: move ( errorPath@var428 ) ) , inconclusive@var426 ( false )
479: { }
480:
481: LifetimeToken ( const Token * token@var429 , bool addressOf@var430 , std :: list < std :: pair < const Token * , std :: string > > errorPath@var431 )
482: : token@var423 ( token@var429 ) , addressOf@var424 ( addressOf@var430 ) , errorPath@var425 ( std :: move ( errorPath@var431 ) ) , inconclusive@var426 ( false )
483: { }
484:
485: static std :: vector < LifetimeToken > setAddressOf ( std :: vector < LifetimeToken > v@var432 , bool b@var433 ) {
486: for (@expr1073743498 LifetimeToken &@expr1073743499 x@var434 :@expr1073743500 v@var432 ) {
487: x@var434 .@expr1073743501 addressOf@var435 =@expr1073743502 b@var433 ; }
488: return v@var432 ;
489: }
490:
491: static std :: vector < LifetimeToken > setInconclusive ( std :: vector < LifetimeToken > v@var436 , bool b@var437 ) {
492: for (@expr1073743503 LifetimeToken &@expr1073743504 x@var438 :@expr1073743505 v@var436 ) {
493: x@var438 .@expr1073743506 inconclusive@var439 =@expr1073743507 b@var437 ; }
494: return v@var436 ;
495: }
496: } ;
497:
498: const Token * parseCompareInt ( const Token * tok@var440 , ValueFlow :: Value & true_value@var441 , ValueFlow :: Value & false_value@var442 , const std :: function < std :: vector < long long > ( const Token * ) > & evaluate@var443 ) ;
499: const Token * parseCompareInt ( const Token * tok@var444 , ValueFlow :: Value & true_value@var445 , ValueFlow :: Value & false_value@var446 ) ;
500:
501: ValueFlow :: Value inferCondition ( std :: string op@var447 , long long val@var448 , const Token * varTok@var449 ) ;
502: ValueFlow :: Value inferCondition ( const std :: string & op@var450 , const Token * varTok@var451 , long long val@var452 ) ;
503:
504: ValuePtr < InferModel > makeIntegralInferModel ( ) ;
505:
506: const Token * solveExprValue ( const Token * expr@var453 ,
507: const std :: function < std :: vector < long long > ( const Token * ) > & eval@var454 ,
508: ValueFlow :: Value & value@var455 ) ;
509:
510: std :: vector < LifetimeToken > getLifetimeTokens ( const Token * tok@var456 ,
511: bool escape@var457 = false ,
512: std :: list < std :: pair < const Token * , std :: string > > errorPath@var458 = std :: list < std :: pair < const Token * , std :: string > > { } ) ;
513:
514: bool hasLifetimeToken ( const Token * tok@var459 , const Token * lifetime@var460 ) ;
515:
516: const Variable * getLifetimeVariable ( const Token * tok@var461 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var462 , bool * addressOf@var463 = nullptr ) ;
517:
518: const Variable * getLifetimeVariable ( const Token * tok@var464 ) ;
519:
520: bool isLifetimeBorrowed ( const Token * tok@var465 , const Settings * settings@var466 ) ;
521:
522: std :: string lifetimeType ( const Token * tok@var467 , const ValueFlow :: Value * val@var468 ) ;
523:
524: std :: string lifetimeMessage ( const Token * tok@var469 , const ValueFlow :: Value * val@var470 , std :: list < std :: pair < const Token * , std :: string > > & errorPath@var471 ) ;
525:
526: ValueFlow :: Value getLifetimeObjValue ( const Token * tok@var472 , bool inconclusive@var473 = false ) ;
527:
528: std :: vector < ValueFlow :: Value > getLifetimeObjValues ( const Token * tok@var474 ,
529: bool inconclusive@var475 = false ,
530: long long path@var476 = 0 ) ;
531:
532: const Token * getEndOfExprScope ( const Token * tok@var477 , const Scope * defaultScope@var478 = nullptr , bool smallest@var479 = true ) ;

##file cppcheck-2.8/lib/templatesimplifier.h

1:
|
34:
35: class ErrorLogger ;
36: class Settings ;
37: class Token ;
38: class Tokenizer ;
39: class TokenList ;
40:
|
44:
45: class TemplateSimplifier {
46: friend class TestSimplifyTemplate ;
47:
48: public:
49: explicit TemplateSimplifier ( Tokenizer * tokenizer@var480 ) ;
50: ~ TemplateSimplifier ( ) ;
51:
52:
53:
54: void checkComplicatedSyntaxErrorsInTemplates ( ) ;
55:
|
61:
62: static unsigned int templateParameters ( const Token * tok@var481 ) ;
63:
|
66:
67: class TokenAndName {
68: Token * mToken@var482 ;
69: std :: string mScope@var483 ;
70: std :: string mName@var484 ;
71: std :: string mFullName@var485 ;
72: const Token * mNameToken@var486 ;
73: const Token * mParamEnd@var487 ;
74: unsigned int mFlags@var488 ;
75:
76: enum Anonymous1 {
77: fIsClass = ( 1 << 0 ) ,
78: fIsFunction = ( 1 << 1 ) ,
79: fIsVariable = ( 1 << 2 ) ,
80: fIsAlias = ( 1 << 3 ) ,
81: fIsSpecialization = ( 1 << 4 ) ,
82: fIsPartialSpecialization = ( 1 << 5 ) ,
83: fIsForwardDeclaration = ( 1 << 6 ) ,
84: fIsVariadic = ( 1 << 7 ) ,
85: fIsFriend = ( 1 << 8 ) ,
86: fFamilyMask = ( fIsClass | fIsFunction | fIsVariable )
87: } ;
88:
89: void isClass ( bool state@var489 ) {
90: setFlag (@expr1073743508 fIsClass , state@var489 ) ;
91: }
92: void isFunction ( bool state@var490 ) {
93: setFlag (@expr1073743509 fIsFunction , state@var490 ) ;
94: }
95: void isVariable ( bool state@var491 ) {
96: setFlag (@expr1073743510 fIsVariable , state@var491 ) ;
97: }
98: void isAlias ( bool state@var492 ) {
99: setFlag (@expr1073743511 fIsAlias , state@var492 ) ;
100: }
101: void isSpecialization ( bool state@var493 ) {
102: setFlag (@expr1073743512 fIsSpecialization , state@var493 ) ;
103: }
104: void isPartialSpecialization ( bool state@var494 ) {
105: setFlag (@expr1073743513 fIsPartialSpecialization , state@var494 ) ;
106: }
107: void isForwardDeclaration ( bool state@var495 ) {
108: setFlag (@expr1073743514 fIsForwardDeclaration , state@var495 ) ;
109: }
110: void isVariadic ( bool state@var496 ) {
111: setFlag (@expr1073743515 fIsVariadic , state@var496 ) ;
112: }
113: void isFriend ( bool state@var497 ) {
114: setFlag (@expr1073743516 fIsFriend , state@var497 ) ;
115: }
116:
|
121:
122: bool getFlag ( unsigned int flag@var498 ) const {
123: return (@expr1693 (@expr1693 mFlags@var488 &@expr1073743519 flag@var498 ) !=@expr1073743520 0 ) ;
124: }
125:
|
130:
131: void setFlag ( unsigned int flag@var499 , bool state@var500 ) {
132: mFlags@var488 =@expr1073743521 state@var500 ?@expr1073743522 mFlags@var488 |@expr1073743523 flag@var499 :@expr1073743524 mFlags@var488 &@expr1073743525 ~@expr1073743526 flag@var499 ;
133: }
134:
135: public:
136:
|
140:
141: TokenAndName ( Token * token@var501 , const std :: string & scope@var502 ) ;
142:
|
148:
149: TokenAndName ( Token * token@var503 , const std :: string & scope@var504 , const Token * nameToken@var505 , const Token * paramEnd@var506 ) ;
150: TokenAndName ( const TokenAndName & other@var507 ) ;
151: ~ TokenAndName ( ) ;
152:
153: bool operator== ( const TokenAndName & rhs@var508 ) const {
154: return mToken@var482 ==@expr1073743527 rhs@var508 .@expr1073743528 mToken@var509 &&@expr1073743529 mScope@var483 ==@expr1073743530 rhs@var508 .@expr1073743531 mScope@var510 &&@expr1073743532 mName@var484 ==@expr1073743533 rhs@var508 .@expr1073743534 mName@var511 &&@expr1073743535 mFullName@var485 ==@expr1073743536 rhs@var508 .@expr1073743537 mFullName@var512 &&@expr1073743538
155: mNameToken@var486 ==@expr1073743539 rhs@var508 .@expr1073743540 mNameToken@var513 &&@expr1073743541 mParamEnd@var487 ==@expr1073743542 rhs@var508 .@expr1073743543 mParamEnd@var514 &&@expr1073743544 mFlags@var488 ==@expr1073743545 rhs@var508 .@expr1073743546 mFlags@var515 ;
156: }
157:
158: Token * token ( ) const {
159: return mToken@var482 ;
160: }
161: void token ( Token * token@var516 ) {
162: mToken@var482 =@expr1073743547 token@var516 ;
163: }
164: const std :: string & scope ( ) const {
165: return mScope@var483 ;
166: }
167: const std :: string & name ( ) const {
168: return mName@var484 ;
169: }
170: const std :: string & fullName ( ) const {
171: return mFullName@var485 ;
172: }
173: const Token * nameToken ( ) const {
174: return mNameToken@var486 ;
175: }
176: const Token * paramEnd ( ) const {
177: return mParamEnd@var487 ;
178: }
179: void paramEnd ( const Token * end@var517 ) {
180: mParamEnd@var487 =@expr1073743548 end@var517 ;
181: }
182:
183: bool isClass ( ) const {
184: return getFlag (@expr1073743549 fIsClass ) ;
185: }
186: bool isFunction ( ) const {
187: return getFlag (@expr1073743550 fIsFunction ) ;
188: }
189: bool isVariable ( ) const {
190: return getFlag (@expr1073743551 fIsVariable ) ;
191: }
192: bool isAlias ( ) const {
193: return getFlag (@expr1073743552 fIsAlias ) ;
194: }
195: bool isSpecialization ( ) const {
196: return getFlag (@expr1073743553 fIsSpecialization ) ;
197: }
198: bool isPartialSpecialization ( ) const {
199: return getFlag (@expr1073743554 fIsPartialSpecialization ) ;
200: }
201: bool isForwardDeclaration ( ) const {
202: return getFlag (@expr1073743555 fIsForwardDeclaration ) ;
203: }
204: bool isVariadic ( ) const {
205: return getFlag (@expr1073743556 fIsVariadic ) ;
206: }
207: bool isFriend ( ) const {
208: return getFlag (@expr1073743557 fIsFriend ) ;
209: }
210:
|
216:
217: const Token * aliasStartToken ( ) const ;
218:
|
224:
225: const Token * aliasEndToken ( ) const ;
226:
|
233:
234: bool isAliasToken ( const Token * tok@var518 ) const ;
235:
|
241:
242: bool isSameFamily ( const TemplateSimplifier :: TokenAndName & decl@var519 ) const {
243:
244:
245: return (@expr1734 (@expr1734 mFlags@var488 &@expr1073743560 fFamilyMask ) &@expr1073743561 (@expr1734 decl@var519 .@expr1073743563 mFlags@var520 &@expr1073743564 fFamilyMask ) ) !=@expr1073743565 0 ;
246: }
247: } ;
248:
|
253:
254: static Token * findTemplateDeclarationEnd ( Token * tok@var521 ) ;
255: static const Token * findTemplateDeclarationEnd ( const Token * tok@var522 ) ;
256:
|
264:
265: static bool instantiateMatch ( const Token * instance@var523 , const unsigned long numberOfArguments@var524 , bool variadic@var525 , const char patternAfter@var526 [ ] ) ;
266:
|
272:
273: int getTemplateNamePosition ( const Token * tok@var527 ) ;
274:
|
280:
281: static bool getTemplateNamePositionTemplateClass ( const Token * tok@var528 , int & namepos@var529 ) ;
282:
|
288:
289: static bool getTemplateNamePositionTemplateFunction ( const Token * tok@var530 , int & namepos@var531 ) ;
290:
|
296:
297: static bool getTemplateNamePositionTemplateVariable ( const Token * tok@var532 , int & namepos@var533 ) ;
298:
|
303:
304: void simplifyTemplates (
305: const std :: time_t maxtime@var534 ,
306: bool & codeWithTemplates@var535 ) ;
307:
|
313:
314: static bool simplifyNumericCalculations ( Token * tok@var536 , bool isTemplate@var537 = true ) ;
315:
|
321:
322: bool simplifyCalculations ( Token * frontToken@var538 = nullptr , Token * backToken@var539 = nullptr , bool isTemplate@var540 = true ) ;
323:
|
327:
328: void simplifyTemplateArgs ( Token * start@var541 , Token * end@var542 ) ;
329:
330: private:
331:
|
334:
335: bool getTemplateDeclarations ( ) ;
336:
|
340:
341: void addInstantiation ( Token * token@var543 , const std :: string & scope@var544 ) ;
342:
|
345:
346: void getTemplateInstantiations ( ) ;
347:
|
351:
352: void fixForwardDeclaredDefaultArgumentValues ( ) ;
353:
|
356:
357: void useDefaultArgumentValues ( ) ;
358:
|
362:
363: void useDefaultArgumentValues ( TokenAndName & declaration@var545 ) ;
364:
|
368:
369: void getSpecializations ( ) ;
370:
|
374:
375: void getPartialSpecializations ( ) ;
376:
|
379:
380: void simplifyTemplateAliases ( ) ;
381:
|
390:
391: bool simplifyTemplateInstantiations (
392: const TokenAndName & templateDeclaration@var546 ,
393: const std :: list < const Token * > & specializations@var547 ,
394: const std :: time_t maxtime@var548 ,
395: std :: set < std :: string > & expandedtemplates@var549 ) ;
396:
|
401:
402: void addNamespace ( const TokenAndName & templateDeclaration@var550 , const Token * tok@var551 ) ;
403:
|
409:
410: static bool alreadyHasNamespace ( const TokenAndName & templateDeclaration@var552 , const Token * tok@var553 ) ;
411:
|
419:
420: void expandTemplate (
421: const TokenAndName & templateDeclaration@var554 ,
422: const TokenAndName & templateInstantiation@var555 ,
423: const std :: vector < const Token * > & typeParametersInDeclaration@var556 ,
424: const std :: string & newName@var557 ,
425: bool copy@var558 ) ;
426:
|
432:
433: void replaceTemplateUsage ( const TokenAndName & instantiation@var559 ,
434: const std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var560 ,
435: const std :: string & newName@var561 ) ;
436:
|
443:
444: static void getTemplateParametersInDeclaration (
445: const Token * tok@var562 ,
446: std :: vector < const Token * > & typeParametersInDeclaration@var563 ) ;
447:
|
450:
451: static bool removeTemplate ( Token * tok@var564 ) ;
452:
453:
454: static void syntaxError ( const Token * tok@var565 ) ;
455:
456: static bool matchSpecialization (
457: const Token * templateDeclarationNameToken@var566 ,
458: const Token * templateInstantiationNameToken@var567 ,
459: const std :: list < const Token * > & specializations@var568 ) ;
460:
|
465:
466: static void eraseTokens ( Token * begin@var569 , const Token * end@var570 ) ;
467:
|
472:
473: static void deleteToken ( Token * tok@var571 ) ;
474:
|
480:
481: std :: string getNewName (
482: Token * tok2@var572 ,
483: std :: list < std :: string > & typeStringsUsedInTemplateInstantiation@var573 ) ;
484:
485: void printOut (
486: const TokenAndName & tokenAndName@var574 ,
487: const std :: string & indent@var575 = "    " ) const ;
488: void printOut ( const std :: string & text@var576 = "" ) const ;
489:
490: Tokenizer * mTokenizer@var577 ;
491: TokenList & mTokenList@var578 ;
492: const Settings * mSettings@var579 ;
493: ErrorLogger * mErrorLogger@var580 ;
494: bool mChanged@var581 ;
495:
496: std :: list < TokenAndName > mTemplateDeclarations@var582 ;
497: std :: list < TokenAndName > mTemplateForwardDeclarations@var583 ;
498: std :: map < Token * , Token * > mTemplateForwardDeclarationsMap@var584 ;
499: std :: map < Token * , Token * > mTemplateSpecializationMap@var585 ;
500: std :: map < Token * , Token * > mTemplatePartialSpecializationMap@var586 ;
501: std :: list < TokenAndName > mTemplateInstantiations@var587 ;
502: std :: list < TokenAndName > mInstantiatedTemplates@var588 ;
503: std :: list < TokenAndName > mMemberFunctionsToDelete@var589 ;
504: std :: vector < TokenAndName > mExplicitInstantiationsToDelete@var590 ;
505: std :: vector < TokenAndName > mTypesUsedInTemplateInstantiation@var591 ;
506: std :: unordered_map < const Token * , int > mTemplateNamePos@var592 ;
507: } ;

##file cppcheck-2.8/lib/token.h

1:
|
40:
41: class Enumerator ;
42: class Function ;
43: class Scope ;
44: class Settings ;
45: class Type ;
46: class ValueType ;
47: class Variable ;
48: class TokenList ;
49: class ConstTokenRange ;
50: class Token ;
51:
|
54:
55: struct TokensFrontBack {
56: Token * front@var593 ;
57: Token * back@var594 ;
58: const TokenList * list@var595 ;
59: } ;
60:
61: struct ScopeInfo2 {
62: ScopeInfo2 ( const std :: string & name_@var596 , const Token * bodyEnd_@var597 , const std :: set < std :: string > & usingNamespaces_@var598 = std :: set < std :: string > ( ) ) : name@var599 ( name_@var596 ) , bodyEnd@var600 ( bodyEnd_@var597 ) , usingNamespaces@var601 ( usingNamespaces_@var598 ) { }
63: std :: string name@var599 ;
64: const Token * const bodyEnd@var600 ;
65: std :: set < std :: string > usingNamespaces@var601 ;
66: } ;
67:
68: struct TokenImpl {
69: int mVarId@var602 ;
70: int mFileIndex@var603 ;
71: int mLineNumber@var604 ;
72: int mColumn@var605 ;
73: int mExprId@var606 ;
74:
75:
76: Token * mAstOperand1@var607 ;
77: Token * mAstOperand2@var608 ;
78: Token * mAstParent@var609 ;
79:
80:
81: const Scope * mScope@var610 ;
82: union {
83: const Function * mFunction@var611 ;
84: const Variable * mVariable@var612 ;
85: const :: Type * mType@var613 ;
86: const Enumerator * mEnumerator@var614 ;
87: } ;
88:
|
92:
93: int mProgressValue@var615 ;
94:
|
97:
98: int mIndex@var616 ;
99:
100:
101: std :: string * mOriginalName@var617 ;
102:
103:
104: ValueType * mValueType@var618 ;
105:
106:
107: std :: list < ValueFlow :: Value > * mValues@var619 ;
108: static const std :: list < ValueFlow :: Value > mEmptyValueList@var620 ;
109:
110:
111: std :: set < TemplateSimplifier :: TokenAndName * > * mTemplateSimplifierPointers@var621 ;
112:
113:
114: std :: shared_ptr < ScopeInfo2 > mScopeInfo@var622 ;
115:
116:
117: struct CppcheckAttributes {
118: enum Type { LOW , HIGH } ; enum Type type@var623 ;
119: long long value@var624 ;
120: struct CppcheckAttributes * next@var625 ;
121: } ;
122: struct CppcheckAttributes * mCppcheckAttributes@var626 ;
123:
124:
125: enum class Cpp11init { UNKNOWN , CPP11INIT , NOINIT } ; enum Cpp11init mCpp11init@var627 ;
126:
127:
128: unsigned char mBits@var628 ;
129:
130: void setCppcheckAttribute ( CppcheckAttributes :: Type type@var629 , long long value@var630 ) ;
131: bool getCppcheckAttribute ( CppcheckAttributes :: Type type@var631 , long long * value@var632 ) const ;
132:
133: TokenImpl ( )
134: : mVarId@var602 ( 0 )
135: , mFileIndex@var603 ( 0 )
136: , mLineNumber@var604 ( 0 )
137: , mColumn@var605 ( 0 )
138: , mExprId@var606 ( 0 )
139: , mAstOperand1@var607 ( nullptr )
140: , mAstOperand2@var608 ( nullptr )
141: , mAstParent@var609 ( nullptr )
142: , mScope@var610 ( nullptr )
143: , mFunction@var611 ( nullptr )
144: , mProgressValue@var615 ( 0 )
145: , mIndex@var616 ( 0 )
146: , mOriginalName@var617 ( nullptr )
147: , mValueType@var618 ( nullptr )
148: , mValues@var619 ( nullptr )
149: , mTemplateSimplifierPointers@var621 ( nullptr )
150: , mScopeInfo@var622 ( nullptr )
151: , mCppcheckAttributes@var626 ( nullptr )
152: , mCpp11init@var627 ( Cpp11init :: UNKNOWN )
153: , mBits@var628 ( 0 )
154: { }
155:
156: ~ TokenImpl ( ) ;
157: } ;
158:
|
171:
172: class Token {
173: private:
174: TokensFrontBack * mTokensFrontBack@var633 ;
175:
176:
177: Token ( const Token & ) ;
178: Token operator= ( const Token & ) ;
179:
180: public:
181: enum Type {
182: eVariable , eType , eFunction , eKeyword , eName ,
183: eNumber , eString , eChar , eBoolean , eLiteral , eEnumerator ,
184: eArithmeticalOp , eComparisonOp , eAssignmentOp , eLogicalOp , eBitOp , eIncDecOp , eExtendedOp ,
185: eBracket ,
186: eLambda ,
187: eEllipsis ,
188: eOther ,
189: eNone
190: } ;
191:
192: explicit Token ( TokensFrontBack * tokensFrontBack@var634 = nullptr ) ;
193: ~ Token ( ) ;
194:
195: ConstTokenRange until ( const Token * t@var635 ) const ;
196:
197: template < typename T >
198: void str ( T && s@var636 ) {
199: mStr@var848 =@expr1073743566 s@var636 ;
200: mImpl@var854 .@expr1073743567 mVarId@var885 =@expr1073743568 0 ;
201:
202: update_property_info (@expr1073743569 ) ;
203: }
204:
|
208:
209: void concatStr ( const std :: string & b@var637 ) ;
210:
211: const std :: string & str ( ) const {
212: return mStr@var848 ;
213: }
214:
|
217:
218: void deleteNext ( int count@var638 = 1 ) ;
219:
|
222:
223: void deletePrevious ( int count@var639 = 1 ) ;
224:
|
227:
228: void swapWithNext ( ) ;
229:
|
234:
235: const Token * tokAt ( int index@var640 ) const ;
236: Token * tokAt ( int index@var641 ) {
237: return const_cast < Token *@expr1746 > (@expr1073743571 const_cast < const Token *@expr1746 > (@expr1073743573 this@expr1073743574 ) .@expr1073743575 tokAt (@expr1073743576 index@var641 ) ) ;
238: }
239:
|
243:
244: const Token * linkAt ( int index@var642 ) const ;
245: Token * linkAt ( int index@var643 ) {
246: return const_cast < Token *@expr1753 > (@expr1073743578 const_cast < const Token *@expr1753 > (@expr1073743580 this@expr1073743581 ) .@expr1073743582 linkAt (@expr1073743583 index@var643 ) ) ;
247: }
248:
|
252:
253: const std :: string & strAt ( int index@var644 ) const ;
254:
|
273:
274: template < unsigned long count >
275: static bool simpleMatch ( const Token * tok@var645 , const char ( & pattern@var646 ) [ count ] ) {
276: return simpleMatch (@expr1073743585 tok@var645 , pattern@var646 , count@expr1073743584 -@expr1073743586 1 ) ;
277: }
278:
279: static bool simpleMatch ( const Token * tok@var647 , const char pattern@var648 [ ] , unsigned long pattern_len@var649 ) ;
280:
|
323:
324: static bool Match ( const Token * tok@var650 , const char pattern@var651 [ ] , int varid@var652 = 0 ) ;
325:
|
332:
333: static int getStrLength ( const Token * tok@var653 ) ;
334:
|
341:
342: static int getStrArraySize ( const Token * tok@var654 ) ;
343:
|
351:
352: static int getStrSize ( const Token * tok@var655 , const Settings * const settings@var656 ) ;
353:
|
361:
362: static std :: string getCharAt ( const Token * tok@var657 , long long index@var658 ) ;
363:
364: const ValueType * valueType ( ) const {
365: return mImpl@var854 .@expr1073743587 mValueType@var886 ;
366: }
367: void setValueType ( ValueType * vt@var659 ) ;
368:
369: const ValueType * argumentType ( ) const {
370: const Token * top@var660 ; top@var660 =@expr1073743588 this@expr1073743589 ;
371: while (@expr1073743590 top@var660 &&@expr1073743591 !@expr1073743592 Token ::@expr1073743593 Match (@expr1073743594 top@var660 .@expr1771 astParent (@expr1772 ) , ",|(" ) ) {
372: top@var660 =@expr1073743597 top@var660 .@expr1771 astParent (@expr1772 ) ; }
373: return top@var660 ?@expr1073743600 top@var660 .@expr1073743601 mImpl@var661 .@expr1073743602 mValueType@var662 :@expr1073743603 nullptr ;
374: }
375:
376: Token :: Type tokType ( ) const {
377: return mTokType@var852 ;
378: }
379: void tokType ( Token :: Type t@var663 ) {
380: mTokType@var852 =@expr1073743604 t@var663 ;
381:
382: const bool memoizedIsName@var664 =@expr1073743605 mTokType@var852 ==@expr1073743606 eName ||@expr1073743607 mTokType@var852 ==@expr1073743608 eType ||@expr1073743609 mTokType@var852 ==@expr1073743610 eVariable ||@expr1073743611
383: mTokType@var852 ==@expr1073743612 eFunction ||@expr1073743613 mTokType@var852 ==@expr1073743614 eKeyword ||@expr1073743615 mTokType@var852 ==@expr1792 eBoolean ||@expr1073743617
384: mTokType@var852 ==@expr1794 eEnumerator ;
385: setFlag (@expr1073743619 fIsName , memoizedIsName@var664 ) ;
386:
387: const bool memoizedIsLiteral@var665 =@expr1073743620 mTokType@var852 ==@expr1073743621 eNumber ||@expr1073743622 mTokType@var852 ==@expr1073743623 eString ||@expr1073743624 mTokType@var852 ==@expr1073743625 eChar ||@expr1073743626
388: mTokType@var852 ==@expr1792 eBoolean ||@expr1073743628 mTokType@var852 ==@expr1073743629 eLiteral ||@expr1073743630 mTokType@var852 ==@expr1794 eEnumerator ;
389: setFlag (@expr1073743632 fIsLiteral , memoizedIsLiteral@var665 ) ;
390: }
391: bool isKeyword ( ) const {
392: return mTokType@var852 ==@expr1073743633 eKeyword ;
393: }
394: bool isName ( ) const {
395: return getFlag (@expr1073743634 fIsName ) ;
396: }
397: bool isNameOnly ( ) const {
398: return mFlags@var853 ==@expr1073743635 fIsName &&@expr1073743636 mTokType@var852 ==@expr1073743637 eName ;
399: }
400: bool isUpperCaseName ( ) const ;
401: bool isLiteral ( ) const {
402: return getFlag (@expr1073743638 fIsLiteral ) ;
403: }
404: bool isNumber ( ) const {
405: return mTokType@var852 ==@expr1073743639 eNumber ;
406: }
407: bool isEnumerator ( ) const {
408: return mTokType@var852 ==@expr1073743640 eEnumerator ;
409: }
410: bool isOp ( ) const {
411: return (@expr1073743641 isConstOp (@expr1073743642 ) ||@expr1073743643
412: isAssignmentOp (@expr1073743644 ) ||@expr1073743645
413: mTokType@var852 ==@expr1073743646 eIncDecOp ) ;
414: }
415: bool isConstOp ( ) const {
416: return (@expr1073743647 isArithmeticalOp (@expr1073743648 ) ||@expr1073743649
417: mTokType@var852 ==@expr1073743650 eLogicalOp ||@expr1073743651
418: mTokType@var852 ==@expr1073743652 eComparisonOp ||@expr1073743653
419: mTokType@var852 ==@expr1073743654 eBitOp ) ;
420: }
421: bool isExtendedOp ( ) const {
422: return isConstOp (@expr1073743655 ) ||@expr1073743656
423: mTokType@var852 ==@expr1073743657 eExtendedOp ;
424: }
425: bool isArithmeticalOp ( ) const {
426: return mTokType@var852 ==@expr1073743658 eArithmeticalOp ;
427: }
428: bool isComparisonOp ( ) const {
429: return mTokType@var852 ==@expr1073743659 eComparisonOp ;
430: }
431: bool isAssignmentOp ( ) const {
432: return mTokType@var852 ==@expr1073743660 eAssignmentOp ;
433: }
434: bool isBoolean ( ) const {
435: return mTokType@var852 ==@expr1073743661 eBoolean ;
436: }
437: bool isIncDecOp ( ) const {
438: return mTokType@var852 ==@expr1073743662 eIncDecOp ;
439: }
440: bool isBinaryOp ( ) const {
441: return astOperand1 (@expr1073743663 ) !=@expr1073743664 nullptr &&@expr1073743665 astOperand2 (@expr1073743666 ) !=@expr1073743667 nullptr ;
442: }
443: bool isUnaryOp ( const std :: string & s@var666 ) const {
444: return s@var666 ==@expr1073743668 mStr@var848 &&@expr1073743669 astOperand1 (@expr1073743670 ) !=@expr1073743671 nullptr &&@expr1073743672 astOperand2 (@expr1073743673 ) ==@expr1073743674 nullptr ;
445: }
446: bool isUnaryPreOp ( ) const ;
447:
448: unsigned int flags ( ) const {
449: return mFlags@var853 ;
450: }
451: void flags ( const unsigned int flags_@var667 ) {
452: mFlags@var853 =@expr1073743675 flags_@var667 ;
453: }
454: bool isUnsigned ( ) const {
455: return getFlag (@expr1073743676 fIsUnsigned ) ;
456: }
457: void isUnsigned ( const bool sign@var668 ) {
458: setFlag (@expr1073743677 fIsUnsigned , sign@var668 ) ;
459: }
460: bool isSigned ( ) const {
461: return getFlag (@expr1073743678 fIsSigned ) ;
462: }
463: void isSigned ( const bool sign@var669 ) {
464: setFlag (@expr1073743679 fIsSigned , sign@var669 ) ;
465: }
466: bool isPointerCompare ( ) const {
467: return getFlag (@expr1073743680 fIsPointerCompare ) ;
468: }
469: void isPointerCompare ( const bool b@var670 ) {
470: setFlag (@expr1073743681 fIsPointerCompare , b@var670 ) ;
471: }
472: bool isLong ( ) const {
473: return getFlag (@expr1073743682 fIsLong ) ;
474: }
475: void isLong ( bool size@var671 ) {
476: setFlag (@expr1073743683 fIsLong , size@var671 ) ;
477: }
478: bool isStandardType ( ) const {
479: return getFlag (@expr1073743684 fIsStandardType ) ;
480: }
481: void isStandardType ( const bool b@var672 ) {
482: setFlag (@expr1073743685 fIsStandardType , b@var672 ) ;
483: }
484: bool isExpandedMacro ( ) const {
485: return getFlag (@expr1073743686 fIsExpandedMacro ) ;
486: }
487: void isExpandedMacro ( const bool m@var673 ) {
488: setFlag (@expr1073743687 fIsExpandedMacro , m@var673 ) ;
489: }
490: bool isCast ( ) const {
491: return getFlag (@expr1073743688 fIsCast ) ;
492: }
493: void isCast ( bool c@var674 ) {
494: setFlag (@expr1073743689 fIsCast , c@var674 ) ;
495: }
496: bool isAttributeConstructor ( ) const {
497: return getFlag (@expr1073743690 fIsAttributeConstructor ) ;
498: }
499: void isAttributeConstructor ( const bool ac@var675 ) {
500: setFlag (@expr1073743691 fIsAttributeConstructor , ac@var675 ) ;
501: }
502: bool isAttributeDestructor ( ) const {
503: return getFlag (@expr1073743692 fIsAttributeDestructor ) ;
504: }
505: void isAttributeDestructor ( const bool value@var676 ) {
506: setFlag (@expr1073743693 fIsAttributeDestructor , value@var676 ) ;
507: }
508: bool isAttributeUnused ( ) const {
509: return getFlag (@expr1073743694 fIsAttributeUnused ) ;
510: }
511: void isAttributeUnused ( bool unused@var677 ) {
512: setFlag (@expr1073743695 fIsAttributeUnused , unused@var677 ) ;
513: }
514: bool isAttributeUsed ( ) const {
515: return getFlag (@expr1073743696 fIsAttributeUsed ) ;
516: }
517: void isAttributeUsed ( const bool unused@var678 ) {
518: setFlag (@expr1073743697 fIsAttributeUsed , unused@var678 ) ;
519: }
520: bool isAttributePure ( ) const {
521: return getFlag (@expr1073743698 fIsAttributePure ) ;
522: }
523: void isAttributePure ( const bool value@var679 ) {
524: setFlag (@expr1073743699 fIsAttributePure , value@var679 ) ;
525: }
526: bool isAttributeConst ( ) const {
527: return getFlag (@expr1073743700 fIsAttributeConst ) ;
528: }
529: void isAttributeConst ( bool value@var680 ) {
530: setFlag (@expr1073743701 fIsAttributeConst , value@var680 ) ;
531: }
532: bool isAttributeNoreturn ( ) const {
533: return getFlag (@expr1073743702 fIsAttributeNoreturn ) ;
534: }
535: void isAttributeNoreturn ( const bool value@var681 ) {
536: setFlag (@expr1073743703 fIsAttributeNoreturn , value@var681 ) ;
537: }
538: bool isAttributeNothrow ( ) const {
539: return getFlag (@expr1073743704 fIsAttributeNothrow ) ;
540: }
541: void isAttributeNothrow ( const bool value@var682 ) {
542: setFlag (@expr1073743705 fIsAttributeNothrow , value@var682 ) ;
543: }
544: bool isAttributePacked ( ) const {
545: return getFlag (@expr1073743706 fIsAttributePacked ) ;
546: }
547: void isAttributePacked ( const bool value@var683 ) {
548: setFlag (@expr1073743707 fIsAttributePacked , value@var683 ) ;
549: }
550: bool isAttributeNodiscard ( ) const {
551: return getFlag (@expr1073743708 fIsAttributeNodiscard ) ;
552: }
553: void isAttributeNodiscard ( const bool value@var684 ) {
554: setFlag (@expr1073743709 fIsAttributeNodiscard , value@var684 ) ;
555: }
556: bool isAttributeMaybeUnused ( ) const {
557: return getFlag (@expr1073743710 fIsAttributeMaybeUnused ) ;
558: }
559: void isAttributeMaybeUnused ( const bool value@var685 ) {
560: setFlag (@expr1073743711 fIsAttributeMaybeUnused , value@var685 ) ;
561: }
562: void setCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var686 , long long value@var687 ) {
563: mImpl@var854 .@expr1073743712 setCppcheckAttribute (@expr1073743713 type@var686 , value@var687 ) ;
564: }
565: bool getCppcheckAttribute ( TokenImpl :: CppcheckAttributes :: Type type@var688 , long long * value@var689 ) const {
566: return mImpl@var854 .@expr1073743714 getCppcheckAttribute (@expr1073743715 type@var688 , value@var689 ) ;
567: }
568: bool hasCppcheckAttributes ( ) const {
569: return nullptr !=@expr1073743716 mImpl@var854 .@expr1073743717 mCppcheckAttributes@var887 ;
570: }
571: bool isControlFlowKeyword ( ) const {
572: return getFlag (@expr1073743718 fIsControlFlowKeyword ) ;
573: }
574: bool isOperatorKeyword ( ) const {
575: return getFlag (@expr1073743719 fIsOperatorKeyword ) ;
576: }
577: void isOperatorKeyword ( const bool value@var690 ) {
578: setFlag (@expr1073743720 fIsOperatorKeyword , value@var690 ) ;
579: }
580: bool isComplex ( ) const {
581: return getFlag (@expr1073743721 fIsComplex ) ;
582: }
583: void isComplex ( const bool value@var691 ) {
584: setFlag (@expr1073743722 fIsComplex , value@var691 ) ;
585: }
586: bool isEnumType ( ) const {
587: return getFlag (@expr1073743723 fIsEnumType ) ;
588: }
589: void isEnumType ( const bool value@var692 ) {
590: setFlag (@expr1073743724 fIsEnumType , value@var692 ) ;
591: }
592: bool isAtAddress ( ) const {
593: return getFlag (@expr1073743725 fAtAddress ) ;
594: }
595: void isAtAddress ( bool b@var693 ) {
596: setFlag (@expr1073743726 fAtAddress , b@var693 ) ;
597: }
598: bool isIncompleteVar ( ) const {
599: return getFlag (@expr1073743727 fIncompleteVar ) ;
600: }
601: void isIncompleteVar ( bool b@var694 ) {
602: setFlag (@expr1073743728 fIncompleteVar , b@var694 ) ;
603: }
604:
605: bool isIncompleteConstant ( ) const {
606: return getFlag (@expr1073743729 fIsIncompleteConstant ) ;
607: }
608: void isIncompleteConstant ( bool b@var695 ) {
609: setFlag (@expr1073743730 fIsIncompleteConstant , b@var695 ) ;
610: }
611:
612: bool isConstexpr ( ) const {
613: return getFlag (@expr1073743731 fConstexpr ) ;
614: }
615: void isConstexpr ( bool b@var696 ) {
616: setFlag (@expr1073743732 fConstexpr , b@var696 ) ;
617: }
618:
619: bool isExternC ( ) const {
620: return getFlag (@expr1073743733 fExternC ) ;
621: }
622: void isExternC ( bool b@var697 ) {
623: setFlag (@expr1073743734 fExternC , b@var697 ) ;
624: }
625:
626: bool isSplittedVarDeclComma ( ) const {
627: return getFlag (@expr1073743735 fIsSplitVarDeclComma ) ;
628: }
629: void isSplittedVarDeclComma ( bool b@var698 ) {
630: setFlag (@expr1073743736 fIsSplitVarDeclComma , b@var698 ) ;
631: }
632:
633: bool isSplittedVarDeclEq ( ) const {
634: return getFlag (@expr1073743737 fIsSplitVarDeclEq ) ;
635: }
636: void isSplittedVarDeclEq ( bool b@var699 ) {
637: setFlag (@expr1073743738 fIsSplitVarDeclEq , b@var699 ) ;
638: }
639:
640: bool isImplicitInt ( ) const {
641: return getFlag (@expr1073743739 fIsImplicitInt ) ;
642: }
643: void isImplicitInt ( bool b@var700 ) {
644: setFlag (@expr1073743740 fIsImplicitInt , b@var700 ) ;
645: }
646:
647: bool isInline ( ) const {
648: return getFlag (@expr1073743741 fIsInline ) ;
649: }
650: void isInline ( bool b@var701 ) {
651: setFlag (@expr1073743742 fIsInline , b@var701 ) ;
652: }
653:
654: bool isRemovedVoidParameter ( ) const {
655: return getFlag (@expr1073743743 fIsRemovedVoidParameter ) ;
656: }
657: void setRemovedVoidParameter ( bool b@var702 ) {
658: setFlag (@expr1073743744 fIsRemovedVoidParameter , b@var702 ) ;
659: }
660:
661: bool isTemplate ( ) const {
662: return getFlag (@expr1073743745 fIsTemplate ) ;
663: }
664: void isTemplate ( bool b@var703 ) {
665: setFlag (@expr1073743746 fIsTemplate , b@var703 ) ;
666: }
667:
668: bool isSimplifiedScope ( ) const {
669: return getFlag (@expr1073743747 fIsSimplifedScope ) ;
670: }
671: void isSimplifiedScope ( bool b@var704 ) {
672: setFlag (@expr1073743748 fIsSimplifedScope , b@var704 ) ;
673: }
674:
675: bool isBitfield ( ) const {
676: return mImpl@var854 .@expr1073743749 mBits@var888 >@expr1073743750 0 ;
677: }
678: unsigned char bits ( ) const {
679: return mImpl@var854 .@expr1073743751 mBits@var888 ;
680: }
681: std :: set < TemplateSimplifier :: TokenAndName * > * templateSimplifierPointers ( ) const {
682: return mImpl@var854 .@expr1073743752 mTemplateSimplifierPointers@var889 ;
683: }
684: void templateSimplifierPointer ( TemplateSimplifier :: TokenAndName * tokenAndName@var705 ) {
685: if (@expr1073743753 !@expr1073743754 mImpl@var854 .@expr1931 mTemplateSimplifierPointers@var889 ) {
686: mImpl@var854 .@expr1931 mTemplateSimplifierPointers@var889 =@expr1073743757 new std ::@expr1073743758 set < TemplateSimplifier ::@expr1073743759 TokenAndName *@expr1073743760 > ; }
687: mImpl@var854 .@expr1931 mTemplateSimplifierPointers@var889 .@expr1073743762 insert (@expr1073743763 tokenAndName@var705 ) ;
688: }
689: void setBits ( const unsigned char b@var706 ) {
690: mImpl@var854 .@expr1073743764 mBits@var888 =@expr1073743765 b@var706 ;
691: }
692:
693: bool isUtf8 ( ) const {
694: return (@expr1942 (@expr1942 (@expr1942 mTokType@var852 ==@expr1073743769 eString ) &&@expr1073743770 isPrefixStringCharLiteral (@expr1073743771 mStr@var848 , '"' , "u8" ) ) ||@expr1073743772
695: (@expr1942 (@expr1942 mTokType@var852 ==@expr1073743775 eChar ) &&@expr1073743776 isPrefixStringCharLiteral (@expr1073743777 mStr@var848 , '\'' , "u8" ) ) ) ;
696: }
697:
698: bool isUtf16 ( ) const {
699: return (@expr1954 (@expr1954 (@expr1954 mTokType@var852 ==@expr1073743781 eString ) &&@expr1073743782 isPrefixStringCharLiteral (@expr1073743783 mStr@var848 , '"' , "u" ) ) ||@expr1073743784
700: (@expr1954 (@expr1954 mTokType@var852 ==@expr1073743787 eChar ) &&@expr1073743788 isPrefixStringCharLiteral (@expr1073743789 mStr@var848 , '\'' , "u" ) ) ) ;
701: }
702:
703: bool isUtf32 ( ) const {
704: return (@expr1966 (@expr1966 (@expr1966 mTokType@var852 ==@expr1073743793 eString ) &&@expr1073743794 isPrefixStringCharLiteral (@expr1073743795 mStr@var848 , '"' , "U" ) ) ||@expr1073743796
705: (@expr1966 (@expr1966 mTokType@var852 ==@expr1073743799 eChar ) &&@expr1073743800 isPrefixStringCharLiteral (@expr1073743801 mStr@var848 , '\'' , "U" ) ) ) ;
706: }
707:
708: bool isCChar ( ) const {
709: return (@expr1978 (@expr1978 (@expr1978 mTokType@var852 ==@expr1073743805 eString ) &&@expr1073743806 isPrefixStringCharLiteral (@expr1073743807 mStr@var848 , '"' , "" ) ) ||@expr1073743808
710: (@expr1978 (@expr1978 mTokType@var852 ==@expr1073743811 eChar ) &&@expr1073743812 isPrefixStringCharLiteral (@expr1073743813 mStr@var848 , '\'' , "" ) &&@expr1073743814 mStr@var848 .@expr1073743815 length (@expr1073743816 ) ==@expr1073743817 3 ) ) ;
711: }
712:
713: bool isCMultiChar ( ) const {
714: return (@expr1994 (@expr1994 (@expr1994 mTokType@var852 ==@expr1073743821 eChar ) &&@expr1073743822 isPrefixStringCharLiteral (@expr1073743823 mStr@var848 , '\'' , "" ) ) &&@expr1073743824
715: (@expr1994 mStr@var848 .@expr1073743826 length (@expr1073743827 ) >@expr1073743828 3 ) ) ;
716: }
717:
|
733:
734: bool isTemplateArg ( ) const {
735: return getFlag (@expr1073743829 fIsTemplateArg ) ;
736: }
737: void isTemplateArg ( const bool value@var707 ) {
738: setFlag (@expr1073743830 fIsTemplateArg , value@var707 ) ;
739: }
740:
741: template < unsigned long count >
742: static const Token * findsimplematch ( const Token * const startTok@var708 , const char ( & pattern@var709 ) [ count ] ) {
743: return findsimplematch (@expr1073743832 startTok@var708 , pattern@var709 , count@expr1073743831 -@expr1073743833 1 ) ;
744: }
745: static const Token * findsimplematch ( const Token * const startTok@var710 , const char pattern@var711 [ ] , unsigned long pattern_len@var712 ) ;
746:
747: template < unsigned long count >
748: static const Token * findsimplematch ( const Token * const startTok@var713 , const char ( & pattern@var714 ) [ count ] , const Token * const end@var715 ) {
749: return findsimplematch (@expr1073743835 startTok@var713 , pattern@var714 , count@expr1073743834 -@expr1073743836 1 , end@var715 ) ;
750: }
751: static const Token * findsimplematch ( const Token * const startTok@var716 , const char pattern@var717 [ ] , unsigned long pattern_len@var718 , const Token * const end@var719 ) ;
752:
753: static const Token * findmatch ( const Token * const startTok@var720 , const char pattern@var721 [ ] , const int varId@var722 = 0 ) ;
754: static const Token * findmatch ( const Token * const startTok@var723 , const char pattern@var724 [ ] , const Token * const end@var725 , const int varId@var726 = 0 ) ;
755:
756: template < unsigned long count >
757: static Token * findsimplematch ( Token * const startTok@var727 , const char ( & pattern@var728 ) [ count ] ) {
758: return findsimplematch (@expr1073743838 startTok@var727 , pattern@var728 , count@expr1073743837 -@expr1073743839 1 ) ;
759: }
760: static Token * findsimplematch ( Token * const startTok@var729 , const char pattern@var730 [ ] , unsigned long pattern_len@var731 ) {
761: return const_cast < Token *@expr2016 > (@expr1073743841 findsimplematch (@expr1073743842 const_cast < const Token *@expr2016 > (@expr1073743844 startTok@var729 ) , pattern@var730 , pattern_len@var731 ) ) ;
762: }
763: template < unsigned long count >
764: static Token * findsimplematch ( Token * const startTok@var732 , const char ( & pattern@var733 ) [ count ] , const Token * const end@var734 ) {
765: return findsimplematch (@expr1073743846 startTok@var732 , pattern@var733 , count@expr1073743845 -@expr1073743847 1 , end@var734 ) ;
766: }
767: static Token * findsimplematch ( Token * const startTok@var735 , const char pattern@var736 [ ] , unsigned long pattern_len@var737 , const Token * const end@var738 ) {
768: return const_cast < Token *@expr2024 > (@expr1073743849 findsimplematch (@expr1073743850 const_cast < const Token *@expr2024 > (@expr1073743852 startTok@var735 ) , pattern@var736 , pattern_len@var737 , end@var738 ) ) ;
769: }
770:
771: static Token * findmatch ( Token * const startTok@var739 , const char pattern@var740 [ ] , const int varId@var741 = 0 ) {
772: return const_cast < Token *@expr2029 > (@expr1073743854 findmatch (@expr1073743855 const_cast < const Token *@expr2029 > (@expr1073743857 startTok@var739 ) , pattern@var740 , varId@var741 ) ) ;
773: }
774: static Token * findmatch ( Token * const startTok@var742 , const char pattern@var743 [ ] , const Token * const end@var744 , const int varId@var745 = 0 ) {
775: return const_cast < Token *@expr2034 > (@expr1073743859 findmatch (@expr1073743860 const_cast < const Token *@expr2034 > (@expr1073743862 startTok@var742 ) , pattern@var743 , end@var744 , varId@var745 ) ) ;
776: }
777:
|
791:
792: static int multiCompare ( const Token * tok@var746 , const char * haystack@var747 , int varid@var748 ) ;
793:
794: int fileIndex ( ) const {
795: return mImpl@var854 .@expr1073743863 mFileIndex@var890 ;
796: }
797: void fileIndex ( int indexOfFile@var749 ) {
798: mImpl@var854 .@expr1073743864 mFileIndex@var890 =@expr1073743865 indexOfFile@var749 ;
799: }
800:
801: int linenr ( ) const {
802: return mImpl@var854 .@expr1073743866 mLineNumber@var891 ;
803: }
804: void linenr ( int lineNumber@var750 ) {
805: mImpl@var854 .@expr1073743867 mLineNumber@var891 =@expr1073743868 lineNumber@var750 ;
806: }
807:
808: int column ( ) const {
809: return mImpl@var854 .@expr1073743869 mColumn@var892 ;
810: }
811: void column ( int c@var751 ) {
812: mImpl@var854 .@expr1073743870 mColumn@var892 =@expr1073743871 c@var751 ;
813: }
814:
815: Token * next ( ) const {
816: return mNext@var849 ;
817: }
818:
|
826:
827: static void eraseTokens ( Token * begin@var752 , const Token * end@var753 ) ;
828:
|
836:
837: Token * insertToken ( const std :: string & tokenStr@var754 , const std :: string & originalNameStr@var755 = emptyString@var1 , bool prepend@var756 = false ) ;
838:
839: Token * insertTokenBefore ( const std :: string & tokenStr@var757 , const std :: string & originalNameStr@var758 = emptyString@var1 )
840: {
841: return insertToken (@expr1073743872 tokenStr@var757 , originalNameStr@var758 , true ) ;
842: }
843:
844: Token * previous ( ) const {
845: return mPrevious@var850 ;
846: }
847:
848:
849: int varId ( ) const {
850: return mImpl@var854 .@expr1073743873 mVarId@var885 ;
851: }
852: void varId ( int id@var759 ) {
853: mImpl@var854 .@expr1073743874 mVarId@var885 =@expr1073743875 id@var759 ;
854: if (@expr1073743876 id@var759 !=@expr1073743877 0 ) {
855: tokType (@expr1073743878 eVariable ) ;
856: isStandardType (@expr1073743879 false ) ;
857: } else {
858: update_property_info (@expr1073743880 ) ;
859: }
860: }
861:
862: int exprId ( ) const {
863: if (@expr1073743881 mImpl@var854 .@expr2058 mExprId@var893 ) {
864: return mImpl@var854 .@expr2058 mExprId@var893 ; }
865: return mImpl@var854 .@expr1073743884 mVarId@var885 ;
866: }
867: void exprId ( int id@var760 ) {
868: mImpl@var854 .@expr1073743885 mExprId@var893 =@expr1073743886 id@var760 ;
869: }
870:
|
876:
877: void printOut ( const char * title@var761 = nullptr ) const ;
878:
|
886:
887: void printOut ( const char * title@var762 , const std :: vector < std :: string > & fileNames@var763 ) const ;
888:
|
891:
892: void printLines ( int lines@var764 = 5 ) const ;
893:
|
900:
901: static void replace ( Token * replaceThis@var765 , Token * start@var766 , Token * end@var767 ) ;
902:
903: struct stringifyOptions {
904: bool varid@var768 ; varid@var768 = false ;
905: bool exprid@var769 ; exprid@var769 = false ;
906: bool idtype@var770 ; idtype@var770 = false ;
907: bool attributes@var771 ; attributes@var771 = false ;
908: bool macro@var772 ; macro@var772 = false ;
909: bool linenumbers@var773 ; linenumbers@var773 = false ;
910: bool linebreaks@var774 ; linebreaks@var774 = false ;
911: bool files@var775 ; files@var775 = false ;
912: static stringifyOptions forDebug ( ) {
913: stringifyOptions options@var776 ;
914: options@var776 .@expr1073743887 attributes@var777 =@expr1073743888 true ;
915: options@var776 .@expr1073743889 macro@var778 =@expr1073743890 true ;
916: options@var776 .@expr1073743891 linenumbers@var779 =@expr1073743892 true ;
917: options@var776 .@expr1073743893 linebreaks@var780 =@expr1073743894 true ;
918: options@var776 .@expr1073743895 files@var781 =@expr1073743896 true ;
919: return options@var776 ;
920: }
921: static stringifyOptions forDebugVarId ( ) {
922: stringifyOptions options@var782 ; options@var782 =@expr1073743897 forDebug (@expr1073743898 ) ;
923: options@var782 .@expr1073743899 varid@var783 =@expr1073743900 true ;
924: return options@var782 ;
925: }
926: static stringifyOptions forDebugExprId ( ) {
927: stringifyOptions options@var784 ; options@var784 =@expr1073743901 forDebug (@expr1073743902 ) ;
928: options@var784 .@expr1073743903 exprid@var785 =@expr1073743904 true ;
929: return options@var784 ;
930: }
931: static stringifyOptions forPrintOut ( ) {
932: stringifyOptions options@var786 ; options@var786 =@expr1073743905 forDebug (@expr1073743906 ) ;
933: options@var786 .@expr1073743907 exprid@var787 =@expr1073743908 true ;
934: options@var786 .@expr1073743909 varid@var788 =@expr1073743910 true ;
935: options@var786 .@expr1073743911 idtype@var789 =@expr1073743912 true ;
936: return options@var786 ;
937: }
938: } ;
939:
940: std :: string stringify ( const stringifyOptions & options@var790 ) const ;
941:
|
947:
948: std :: string stringify ( bool varid@var791 , bool attributes@var792 , bool macro@var793 ) const ;
949:
950: std :: string stringifyList ( const stringifyOptions & options@var794 , const std :: vector < std :: string > * fileNames@var795 = nullptr , const Token * end@var796 = nullptr ) const ;
951: std :: string stringifyList ( const Token * end@var797 , bool attributes@var798 = true ) const ;
952: std :: string stringifyList ( bool varid@var799 = false ) const ;
953:
|
964:
965: std :: string stringifyList ( bool varid@var800 , bool attributes@var801 , bool linenumbers@var802 , bool linebreaks@var803 , bool files@var804 , const std :: vector < std :: string > * fileNames@var805 = nullptr , const Token * end@var806 = nullptr ) const ;
966:
|
974:
975: void deleteThis ( ) ;
976:
|
981:
982: void link ( Token * linkToToken@var807 ) {
983: mLink@var851 =@expr1073743913 linkToToken@var807 ;
984: if (@expr1073743914 mStr@var848 ==@expr1073743915 "<" ||@expr1073743916 mStr@var848 ==@expr1073743917 ">" ) {
985: update_property_info (@expr1073743918 ) ; }
986: }
987:
|
996:
997: Token * link ( ) const {
998: return mLink@var851 ;
999: }
1000:
|
1004:
1005: void scope ( const Scope * s@var808 ) {
1006: mImpl@var854 .@expr1073743919 mScope@var894 =@expr1073743920 s@var808 ;
1007: }
1008:
|
1011:
1012: const Scope * scope ( ) const {
1013: return mImpl@var854 .@expr1073743921 mScope@var894 ;
1014: }
1015:
|
1019:
1020: void function ( const Function * f@var809 ) ;
1021:
|
1024:
1025: const Function * function ( ) const {
1026: return mTokType@var852 ==@expr1073743922 eFunction ||@expr1073743923 mTokType@var852 ==@expr1073743924 eLambda ?@expr1073743925 mImpl@var854 .@expr1073743926 mFunction@var895 :@expr1073743927 nullptr ;
1027: }
1028:
|
1032:
1033: void variable ( const Variable * v@var810 ) {
1034: mImpl@var854 .@expr1073743928 mVariable@var896 =@expr1073743929 v@var810 ;
1035: if (@expr1073743930 v@var810 ||@expr1073743931 mImpl@var854 .@expr1073743932 mVarId@var885 ) {
1036: tokType (@expr1073743933 eVariable ) ; }
1037: else { if (@expr1073743934 mTokType@var852 ==@expr1073743935 eVariable ) {
1038: tokType (@expr1073743936 eName ) ; } }
1039: }
1040:
|
1043:
1044: const Variable * variable ( ) const {
1045: return mTokType@var852 ==@expr1073743937 eVariable ?@expr1073743938 mImpl@var854 .@expr1073743939 mVariable@var896 :@expr1073743940 nullptr ;
1046: }
1047:
|
1051:
1052: void type ( const :: Type * t@var811 ) ;
1053:
|
1056:
1057: const :: Type * type ( ) const {
1058: return mTokType@var852 ==@expr1073743941 eType ?@expr1073743942 mImpl@var854 .@expr1073743943 mType@var897 :@expr1073743944 nullptr ;
1059: }
1060:
1061: static const :: Type * typeOf ( const Token * tok@var812 , const Token * * typeTok@var813 = nullptr ) ;
1062:
1063: static std :: pair < const Token * , const Token * > typeDecl ( const Token * tok@var814 ) ;
1064:
1065: static std :: string typeStr ( const Token * tok@var815 ) ;
1066:
|
1069:
1070: const Enumerator * enumerator ( ) const {
1071: return mTokType@var852 ==@expr1073743945 eEnumerator ?@expr1073743946 mImpl@var854 .@expr1073743947 mEnumerator@var898 :@expr1073743948 nullptr ;
1072: }
1073:
|
1077:
1078: void enumerator ( const Enumerator * e@var816 ) {
1079: mImpl@var854 .@expr1073743949 mEnumerator@var898 =@expr1073743950 e@var816 ;
1080: if (@expr1073743951 e@var816 ) {
1081: tokType (@expr1073743952 eEnumerator ) ; }
1082: else { if (@expr1073743953 mTokType@var852 ==@expr1073743954 eEnumerator ) {
1083: tokType (@expr1073743955 eName ) ; } }
1084: }
1085:
|
1088:
1089: static void createMutualLinks ( Token * begin@var817 , Token * end@var818 ) ;
1090:
|
1096:
1097: std :: string strValue ( ) const ;
1098:
|
1105:
1106: static void move ( Token * srcStart@var819 , Token * srcEnd@var820 , Token * newLocation@var821 ) ;
1107:
1108:
1109: int progressValue ( ) const {
1110: return mImpl@var854 .@expr1073743956 mProgressValue@var899 ;
1111: }
1112:
1113:
1114: static void assignProgressValues ( Token * tok@var822 ) ;
1115:
|
1120:
1121: Token * nextArgument ( ) const ;
1122:
|
1127:
1128: Token * nextArgumentBeforeCreateLinks2 ( ) const ;
1129:
|
1134:
1135: Token * nextTemplateArgument ( ) const ;
1136:
|
1141:
1142: const Token * findClosingBracket ( ) const ;
1143: Token * findClosingBracket ( ) ;
1144:
1145: const Token * findOpeningBracket ( ) const ;
1146: Token * findOpeningBracket ( ) ;
1147:
|
1150:
1151: const std :: string & originalName ( ) const {
1152: return mImpl@var854 .@expr2133 mOriginalName@var900 ?@expr1073743958 *@expr1073743959 mImpl@var854 .@expr2133 mOriginalName@var900 :@expr1073743961 emptyString@var1 ;
1153: }
1154:
1155: const std :: list < ValueFlow :: Value > & values ( ) const {
1156: return mImpl@var854 .@expr2138 mValues@var873 ?@expr1073743963 *@expr1073743964 mImpl@var854 .@expr2138 mValues@var873 :@expr1073743966 TokenImpl ::@expr1073743967 mEmptyValueList@var620 ;
1157: }
1158:
|
1161:
1162: template < typename T >
1163: void originalName ( T && name@var823 ) {
1164: if (@expr1073743968 !@expr1073743969 mImpl@var854 .@expr2146 mOriginalName@var900 ) {
1165: mImpl@var854 .@expr2146 mOriginalName@var900 =@expr1073743972 new std ::@expr1073743973 string (@expr1073743974 name@var823 ) ; }
1166: else {
1167: *@expr1073743975 mImpl@var854 .@expr2146 mOriginalName@var900 =@expr1073743977 name@var823 ; }
1168: }
1169:
1170: bool hasKnownIntValue ( ) const ;
1171: bool hasKnownValue ( ) const ;
1172: bool hasKnownValue ( ValueFlow :: Value :: ValueType t@var824 ) const ;
1173: bool hasKnownSymbolicValue ( const Token * tok@var825 ) const ;
1174:
1175: const ValueFlow :: Value * getKnownValue ( ValueFlow :: Value :: ValueType t@var826 ) const ;
1176: long long getKnownIntValue ( ) const {
1177: return mImpl@var854 .@expr1073743979 mValues@var873 .@expr1073743980 front (@expr1073743981 ) .@expr1073743982 intvalue@expr1073743978 ;
1178: }
1179:
1180: const ValueFlow :: Value * getValue ( const long long val@var827 ) const ;
1181:
1182: const ValueFlow :: Value * getMaxValue ( bool condition@var828 , long long path@var829 = 0 ) const ;
1183:
1184: const ValueFlow :: Value * getMovedValue ( ) const ;
1185:
1186: const ValueFlow :: Value * getValueLE ( const long long val@var830 , const Settings * settings@var831 ) const ;
1187: const ValueFlow :: Value * getValueGE ( const long long val@var832 , const Settings * settings@var833 ) const ;
1188:
1189: const ValueFlow :: Value * getInvalidValue ( const Token * ftok@var834 , int argnr@var835 , const Settings * settings@var836 ) const ;
1190:
1191: const ValueFlow :: Value * getContainerSizeValue ( const long long val@var837 ) const ;
1192:
1193: const Token * getValueTokenMaxStrLength ( ) const ;
1194: const Token * getValueTokenMinStrSize ( const Settings * settings@var838 ) const ;
1195:
1196:
1197: bool addValue ( const ValueFlow :: Value & value@var839 ) ;
1198:
1199: void removeValues ( std :: function < bool ( const ValueFlow :: Value & ) > pred@var840 ) {
1200: if (@expr1073743983 mImpl@var854 .@expr2160 mValues@var873 ) {
1201: mImpl@var854 .@expr2160 mValues@var873 .@expr1073743986 remove_if (@expr1073743987 pred@var840 ) ; }
1202: }
1203:
1204: int index ( ) const {
1205: return mImpl@var854 .@expr1073743988 mIndex@var901 ;
1206: }
1207:
1208: void assignIndexes ( ) ;
1209:
1210: private:
1211:
1212: void next ( Token * nextToken@var841 ) {
1213: mNext@var849 =@expr1073743989 nextToken@var841 ;
1214: }
1215: void previous ( Token * previousToken@var842 ) {
1216: mPrevious@var850 =@expr1073743990 previousToken@var842 ;
1217: }
1218:
1219:
1220: void takeData ( Token * fromToken@var843 ) ;
1221:
|
1226:
1227: static bool firstWordEquals ( const char * str@var844 , const char * word@var845 ) ;
1228:
|
1233:
1234: static const char * chrInFirstWord ( const char * str@var846 , char c@var847 ) ;
1235:
1236: std :: string mStr@var848 ;
1237:
1238: Token * mNext@var849 ;
1239: Token * mPrevious@var850 ;
1240: Token * mLink@var851 ;
1241:
1242: enum Anonymous2 : uint64_t {
1243: fIsUnsigned = ( 1 << 0 ) ,
1244: fIsSigned = ( 1 << 1 ) ,
1245: fIsPointerCompare = ( 1 << 2 ) ,
1246: fIsLong = ( 1 << 3 ) ,
1247: fIsStandardType = ( 1 << 4 ) ,
1248: fIsExpandedMacro = ( 1 << 5 ) ,
1249: fIsCast = ( 1 << 6 ) ,
1250: fIsAttributeConstructor = ( 1 << 7 ) ,
1251: fIsAttributeDestructor = ( 1 << 8 ) ,
1252: fIsAttributeUnused = ( 1 << 9 ) ,
1253: fIsAttributePure = ( 1 << 10 ) ,
1254: fIsAttributeConst = ( 1 << 11 ) ,
1255: fIsAttributeNoreturn = ( 1 << 12 ) ,
1256: fIsAttributeNothrow = ( 1 << 13 ) ,
1257: fIsAttributeUsed = ( 1 << 14 ) ,
1258: fIsAttributePacked = ( 1 << 15 ) ,
1259: fIsAttributeMaybeUnused = ( 1 << 16 ) ,
1260: fIsControlFlowKeyword = ( 1 << 17 ) ,
1261: fIsOperatorKeyword = ( 1 << 18 ) ,
1262: fIsComplex = ( 1 << 19 ) ,
1263: fIsEnumType = ( 1 << 20 ) ,
1264: fIsName = ( 1 << 21 ) ,
1265: fIsLiteral = ( 1 << 22 ) ,
1266: fIsTemplateArg = ( 1 << 23 ) ,
1267: fIsAttributeNodiscard = ( 1 << 24 ) ,
1268: fAtAddress = ( 1 << 25 ) ,
1269: fIncompleteVar = ( 1 << 26 ) ,
1270: fConstexpr = ( 1 << 27 ) ,
1271: fExternC = ( 1 << 28 ) ,
1272: fIsSplitVarDeclComma = ( 1 << 29 ) ,
1273: fIsSplitVarDeclEq = ( 1 << 30 ) ,
1274: fIsImplicitInt = ( 1U << 31 ) ,
1275: fIsInline = ( 1ULL << 32 ) ,
1276: fIsTemplate = ( 1ULL << 33 ) ,
1277: fIsSimplifedScope = ( 1ULL << 34 ) ,
1278: fIsRemovedVoidParameter = ( 1ULL << 35 ) ,
1279: fIsIncompleteConstant = ( 1ULL << 36 ) ,
1280: } ;
1281:
1282: Token :: Type mTokType@var852 ;
1283:
1284: uint64_t mFlags@var853 ;
1285:
1286: TokenImpl * mImpl@var854 ;
1287:
|
1292:
1293: bool getFlag ( uint64_t flag_@var855 ) const {
1294: return (@expr2167 (@expr2167 mFlags@var853 &@expr1073743993 flag_@var855 ) !=@expr1073743994 0 ) ;
1295: }
1296:
|
1301:
1302: void setFlag ( uint64_t flag_@var856 , bool state_@var857 ) {
1303: mFlags@var853 =@expr1073743995 state_@var857 ?@expr1073743996 mFlags@var853 |@expr1073743997 flag_@var856 :@expr1073743998 mFlags@var853 &@expr1073743999 ~@expr1073744000 flag_@var856 ;
1304: }
1305:
1306:
1307:
1308: void update_property_info ( ) ;
1309:
1310:
1311: void update_property_isStandardType ( ) ;
1312:
1313:
1314: void update_property_char_string_literal ( ) ;
1315:
1316:
1317: void astStringVerboseRecursive ( std :: string & ret@var858 , const int indent1@var859 = 0 , const int indent2@var860 = 0 ) const ;
1318:
1319: public:
1320: void astOperand1 ( Token * tok@var861 ) ;
1321: void astOperand2 ( Token * tok@var862 ) ;
1322: void astParent ( Token * tok@var863 ) ;
1323:
1324: Token * astOperand1 ( ) {
1325: return mImpl@var854 .@expr1073744001 mAstOperand1@var864 ;
1326: }
1327: const Token * astOperand1 ( ) const {
1328: return mImpl@var854 .@expr1073744002 mAstOperand1@var864 ;
1329: }
1330: Token * astOperand2 ( ) {
1331: return mImpl@var854 .@expr1073744003 mAstOperand2@var865 ;
1332: }
1333: const Token * astOperand2 ( ) const {
1334: return mImpl@var854 .@expr1073744004 mAstOperand2@var865 ;
1335: }
1336: Token * astParent ( ) {
1337: return mImpl@var854 .@expr1073744005 mAstParent@var866 ;
1338: }
1339: const Token * astParent ( ) const {
1340: return mImpl@var854 .@expr1073744006 mAstParent@var866 ;
1341: }
1342: Token * astSibling ( ) {
1343: if (@expr1073744007 !@expr1073744008 astParent (@expr2185 ) ) {
1344: return nullptr ; }
1345: if (@expr1073744010 this@expr2187 ==@expr1073744012 astParent (@expr2185 ) .@expr2190 astOperand1 (@expr2191 ) ) {
1346: return astParent (@expr2185 ) .@expr2193 astOperand2 (@expr2194 ) ; }
1347: else { if (@expr1073744019 this@expr2187 ==@expr1073744020 astParent (@expr2185 ) .@expr2193 astOperand2 (@expr2194 ) ) {
1348: return astParent (@expr2185 ) .@expr2190 astOperand1 (@expr2191 ) ; } }
1349: return nullptr ;
1350:
1351: }
1352: const Token * astSibling ( ) const {
1353: if (@expr1073744027 !@expr1073744028 astParent (@expr2205 ) ) {
1354: return nullptr ; }
1355: if (@expr1073744030 this@expr2207 ==@expr1073744032 astParent (@expr2205 ) .@expr2210 astOperand1 (@expr2211 ) ) {
1356: return astParent (@expr2205 ) .@expr2213 astOperand2 (@expr2214 ) ; }
1357: else { if (@expr1073744039 this@expr2207 ==@expr1073744040 astParent (@expr2205 ) .@expr2213 astOperand2 (@expr2214 ) ) {
1358: return astParent (@expr2205 ) .@expr2210 astOperand1 (@expr2211 ) ; } }
1359: return nullptr ;
1360:
1361: }
1362: Token * astTop ( ) {
1363: Token * ret@var867 ; ret@var867 =@expr1073744047 this@expr1073744048 ;
1364: while (@expr1073744049 ret@var867 .@expr2226 mImpl@var868 .@expr2227 mAstParent@var869 ) {
1365: ret@var867 =@expr1073744052 ret@var867 .@expr2226 mImpl@var868 .@expr2227 mAstParent@var869 ; }
1366: return ret@var867 ;
1367: }
1368:
1369: const Token * astTop ( ) const {
1370: const Token * ret@var870 ; ret@var870 =@expr1073744055 this@expr1073744056 ;
1371: while (@expr1073744057 ret@var870 .@expr2234 mImpl@var871 .@expr2235 mAstParent@var872 ) {
1372: ret@var870 =@expr1073744060 ret@var870 .@expr2234 mImpl@var871 .@expr2235 mAstParent@var872 ; }
1373: return ret@var870 ;
1374: }
1375:
1376: std :: pair < const Token * , const Token * > findExpressionStartEndTokens ( ) const ;
1377:
|
1384:
1385: bool isCalculation ( ) const ;
1386:
1387: void clearAst ( ) {
1388: mImpl@var854 .@expr1073744063 mAstOperand1@var864 =@expr1073744064 mImpl@var854 .@expr1073744065 mAstOperand2@var865 =@expr1073744066 mImpl@var854 .@expr1073744067 mAstParent@var866 =@expr1073744068 nullptr ;
1389: }
1390:
1391: void clearValueFlow ( ) {
1392: delete mImpl@var854 .@expr2245 mValues@var873 ;
1393: mImpl@var854 .@expr2245 mValues@var873 =@expr1073744071 nullptr ;
1394: }
1395:
1396: std :: string astString ( const char * sep@var874 = "" ) const {
1397: std ::@expr1073744072 string ret@var875 ;
1398: if (@expr1073744073 mImpl@var854 .@expr2250 mAstOperand1@var864 ) {
1399: ret@var875 =@expr1073744075 mImpl@var854 .@expr2250 mAstOperand1@var864 .@expr1073744077 astString (@expr1073744078 sep@var874 ) ; }
1400: if (@expr1073744079 mImpl@var854 .@expr2256 mAstOperand2@var865 ) {
1401: ret@var875 +=@expr1073744081 mImpl@var854 .@expr2256 mAstOperand2@var865 .@expr1073744083 astString (@expr1073744084 sep@var874 ) ; }
1402: return ret@var875 +@expr1073744085 sep@var874 +@expr1073744086 mStr@var848 ;
1403: }
1404:
1405: std :: string astStringVerbose ( ) const ;
1406:
1407: std :: string astStringZ3 ( ) const ;
1408:
1409: std :: string expressionString ( ) const ;
1410:
1411: void printAst ( bool verbose@var876 , bool xml@var877 , const std :: vector < std :: string > & fileNames@var878 , std :: ostream & out@var879 ) const ;
1412:
1413: void printValueFlow ( bool xml@var880 , std :: ostream & out@var881 ) const ;
1414:
1415: void scopeInfo ( std :: shared_ptr < ScopeInfo2 > newScopeInfo@var882 ) ;
1416: std :: shared_ptr < ScopeInfo2 > scopeInfo ( ) const ;
1417:
1418: void setCpp11init ( bool cpp11init@var883 ) const {
1419: mImpl@var854 .@expr1073744087 mCpp11init@var884 =@expr1073744088 cpp11init@var883 ?@expr1073744089 TokenImpl ::@expr2266 Cpp11init ::@expr1073744091 CPP11INIT :@expr1073744092 TokenImpl ::@expr2266 Cpp11init ::@expr1073744094 NOINIT ;
1420: }
1421: TokenImpl :: Cpp11init isCpp11init ( ) const {
1422: return mImpl@var854 .@expr1073744095 mCpp11init@var884 ;
1423: }
1424: } ;
1425:
1426: Token * findTypeEnd ( Token * tok@var902 ) ;
1427: const Token * findTypeEnd ( const Token * tok@var903 ) ;
1428: Token * findLambdaEndScope ( Token * tok@var904 ) ;
1429: const Token * findLambdaEndScope ( const Token * tok@var905 ) ;

##file cppcheck-2.8/lib/tokenlist.h

1:
|
31:
32: class Settings ;
33:
34: namespace simplecpp {
35: class TokenList ;
36: }
37:
|
40:
41: class TokenList {
42: public:
43: explicit TokenList ( const Settings * settings@var906 ) ;
44: ~ TokenList ( ) ;
45:
46: void setSettings ( const Settings * settings@var907 ) {
47: mSettings@var942 =@expr1073744096 settings@var907 ;
48: }
49:
50: const Settings * getSettings ( ) const {
51: return mSettings@var942 ;
52: }
53:
54:
55: const std :: string & getSourceFilePath ( ) const ;
56:
57:
58: bool isC ( ) const {
59: return mIsC@var944 ;
60: }
61:
62:
63: bool isCPP ( ) const {
64: return mIsCpp@var945 ;
65: }
66:
|
70:
71: static void deleteTokens ( Token * tok@var908 ) ;
72:
73: void addtoken ( const std :: string & str@var909 , const int lineno@var910 , const int column@var911 , const int fileno@var912 , bool split@var913 = false ) ;
74: void addtoken ( const std :: string & str@var914 , const Token * locationTok@var915 ) ;
75:
76: void addtoken ( const Token * tok@var916 , const int lineno@var917 , const int column@var918 , const int fileno@var919 ) ;
77: void addtoken ( const Token * tok@var920 , const Token * locationTok@var921 ) ;
78: void addtoken ( const Token * tok@var922 ) ;
79:
80: static void insertTokens ( Token * dest@var923 , const Token * src@var924 , int n@var925 ) ;
81:
|
89:
90: static Token * copyTokens ( Token * dest@var926 , const Token * first@var927 , const Token * last@var928 , bool one_line@var929 = true ) ;
91:
|
100:
101: bool createTokens ( std :: istream & code@var930 , const std :: string & file0@var931 = emptyString@var1 ) ;
102:
103: void createTokens ( simplecpp :: TokenList && tokenList@var932 ) ;
104:
105:
106: void deallocateTokens ( ) ;
107:
108:
109: int appendFileIfNew ( const std :: string & fileName@var933 ) ;
110:
111:
112: const Token * front ( ) const {
113: return mTokensFrontBack@var939 .@expr1073744097 front@var946 ;
114: }
115: Token * front ( ) {
116: return mTokensFrontBack@var939 .@expr1073744098 front@var946 ;
117: }
118:
119:
120: const Token * back ( ) const {
121: return mTokensFrontBack@var939 .@expr1073744099 back@var947 ;
122: }
123: Token * back ( ) {
124: return mTokensFrontBack@var939 .@expr1073744100 back@var947 ;
125: }
126:
|
131:
132: const std :: vector < std :: string > & getFiles ( ) const {
133: return mFiles@var940 ;
134: }
135:
136: std :: string getOrigFile ( const Token * tok@var934 ) const ;
137:
|
142:
143: const std :: string & file ( const Token * tok@var935 ) const ;
144:
|
149:
150: std :: string fileLine ( const Token * tok@var936 ) const ;
151:
|
155:
156: unsigned long long calculateChecksum ( ) const ;
157:
|
160:
161: void createAst ( ) const ;
162:
|
166:
167: void validateAst ( ) const ;
168:
|
174:
175: bool validateToken ( const Token * tok@var937 ) const ;
176:
|
181:
182: void simplifyPlatformTypes ( ) ;
183:
|
187:
188: void simplifyStdType ( ) ;
189:
190: void clangSetOrigFiles ( ) ;
191:
192: bool isKeyword ( const std :: string & str@var938 ) const ;
193:
194: private:
195:
196:
197: TokenList ( const TokenList & ) ;
198:
199:
200: TokenList & operator= ( const TokenList & ) ;
201:
202: void determineCppC ( ) ;
203:
204:
205: TokensFrontBack mTokensFrontBack@var939 ;
206:
207:
208: std :: vector < std :: string > mFiles@var940 ;
209:
210:
211: std :: vector < std :: string > mOrigFiles@var941 ;
212:
213:
214: const Settings * mSettings@var942 ;
215:
216: std :: unordered_set < std :: string > mKeywords@var943 ;
217:
218:
219: bool mIsC@var944 ;
220: bool mIsCpp@var945 ;
221: } ;

##file cppcheck-2.8/lib/tokenize.h

1:
|
35:
36: class Settings ;
37: class SymbolDatabase ;
38: class TimerResults ;
39: class Token ;
40: class TemplateSimplifier ;
41: class ErrorLogger ;
42: class Preprocessor ;
43:
44: namespace simplecpp {
45: class TokenList ;
46: }
47:
|
51:
52: class Tokenizer {
53:
54: friend class TestSimplifyTokens ;
55: friend class TestSimplifyTypedef ;
56: friend class TestSimplifyUsing ;
57: friend class TestTokenizer ;
58: friend class SymbolDatabase ;
59: friend class TestSimplifyTemplate ;
60: friend class TemplateSimplifier ;
61:
62:
63: class VariableMap {
64: private:
65: std :: map < std :: string , int > mVariableId@var948 ;
66: std :: stack < std :: list < std :: pair < std :: string , int > > > mScopeInfo@var949 ;
67: mutable int mVarId@var950 ;
68: public:
69: VariableMap ( ) ;
70: void enterScope ( ) ;
71: bool leaveScope ( ) ;
72: void addVariable ( const std :: string & varname@var951 ) ;
73: bool hasVariable ( const std :: string & varname@var952 ) const ;
74: std :: map < std :: string , int > :: const_iterator find ( const std :: string & varname@var953 ) const {
75: return mVariableId@var948 .@expr1073744101 find (@expr1073744102 varname@var953 ) ;
76: }
77: std :: map < std :: string , int > :: const_iterator end ( ) const {
78: return mVariableId@var948 .@expr1073744103 end (@expr1073744104 ) ;
79: }
80: const std :: map < std :: string , int > & map ( ) const {
81: return mVariableId@var948 ;
82: }
83: int * getVarId ( ) const {
84: return &@expr1073744105 mVarId@var950 ;
85: }
86: } ;
87:
88:
89: public:
90: Tokenizer ( ) ;
91: Tokenizer ( const Settings * settings@var954 , ErrorLogger * errorLogger@var955 ) ;
92: ~ Tokenizer ( ) ;
93:
94: void setTimerResults ( TimerResults * tr@var956 ) {
95: mTimerResults@var1076 =@expr1073744106 tr@var956 ;
96: }
97:
98:
99: bool isC ( ) const {
100: return list@var1054 .@expr1073744107 isC (@expr1073744108 ) ;
101: }
102:
103:
104: bool isCPP ( ) const {
105: return list@var1054 .@expr1073744109 isCPP (@expr1073744110 ) ;
106: }
107:
|
113:
114: bool isScopeNoReturn ( const Token * endScopeToken@var957 , bool * unknown@var958 = nullptr ) const ;
115:
116: bool createTokens ( std :: istream & code@var959 , const std :: string & FileName@var960 ) ;
117: void createTokens ( simplecpp :: TokenList && tokenList@var961 ) ;
118:
119: bool simplifyTokens1 ( const std :: string & configuration@var962 ) ;
120:
|
140:
141: bool tokenize ( std :: istream & code@var963 ,
142: const char FileName@var964 [ ] ,
143: const std :: string & configuration@var965 = emptyString@var1 ) ;
144:
145:
146: void setVarId ( ) ;
147: void setVarIdPass1 ( ) ;
148: void setVarIdPass2 ( ) ;
149:
|
158:
159: bool simplifyTokenList1 ( const char FileName@var966 [ ] ) ;
160:
|
166:
167: bool simplifyTokenList2 ( ) ;
168:
|
173:
174: void simplifyHeadersAndUnusedTemplates ( ) ;
175:
|
178:
179: void removeExtraTemplateKeywords ( ) ;
180:
|
184:
185: void splitTemplateRightAngleBrackets ( bool check@var967 ) ;
186:
|
202:
203: static void eraseDeadCode ( Token * begin@var968 , const Token * end@var969 ) ;
204:
|
209:
210: int sizeOfType ( const Token * type@var970 ) const ;
211:
|
217:
218: bool isFunctionParameterPassedByValue ( const Token * fpar@var971 ) const ;
219:
220:
221:
222: void simplifyAssignmentInFunctionCall ( ) ;
223:
224:
225: void simplifyAssignmentBlock ( ) ;
226:
|
231:
232: bool simplifyCalculations ( ) ;
233:
|
238:
239: void simplifyOffsetPointerDereference ( ) ;
240:
|
244:
245: void simplifyOffsetPointerReference ( ) ;
246:
247:
248: void arraySize ( ) ;
249:
250:
251:
252: void simplifyLabelsCaseDefault ( ) ;
253:
254:
255:
256: void simplifyCaseRange ( ) ;
257:
258:
259: void removeMacrosInGlobalScope ( ) ;
260:
261: void addSemicolonAfterUnknownMacro ( ) ;
262:
263:
264: void removePragma ( ) ;
265:
|
269:
270: void removeMacroInClassDef ( ) ;
271:
272:
273: void removeMacroInVarDecl ( ) ;
274:
275:
276: void removeRedundantAssignment ( ) ;
277:
|
281:
282: void simplifyRealloc ( ) ;
283:
284:
285: void sizeofAddParentheses ( ) ;
286:
|
291:
292: bool simplifySizeof ( ) ;
293:
|
297:
298: void simplifyVarDecl ( const bool only_k_r_fpar@var972 ) ;
299: void simplifyVarDecl ( Token * tokBegin@var973 , const Token * const tokEnd@var974 , const bool only_k_r_fpar@var975 ) ;
300:
|
304:
305: void simplifyInitVar ( ) ;
306: static Token * initVar ( Token * tok@var976 ) ;
307:
|
313:
314: bool simplifyConstTernaryOp ( ) ;
315:
|
319:
320: void simplifyCompoundAssignment ( ) ;
321:
|
327:
328: void simplifyStaticConst ( ) ;
329:
|
335:
336: void simplifyIfAndWhileAssign ( ) ;
337:
|
341:
342: void simplifyVariableMultipleAssign ( ) ;
343:
|
350:
351: bool simplifyCAlternativeTokens ( ) ;
352:
|
358:
359: void simplifyComma ( ) ;
360:
|
363:
364: bool simplifyAddBraces ( ) ;
365:
|
371:
372: Token * simplifyAddBracesToCommand ( Token * tok@var977 ) ;
373:
|
379:
380: Token * simplifyAddBracesPair ( Token * tok@var978 , bool commandWithCondition@var979 ) ;
381:
382:
383: void simplifyUsingToTypedef ( ) ;
384:
|
392:
393: void simplifyTypedef ( ) ;
394:
395:
396:
397: bool isMemberFunction ( const Token * openParen@var980 ) const ;
398:
399:
400:
401: bool simplifyUsing ( ) ;
402:
|
405:
406: void simplifyCasts ( ) ;
407:
|
410:
411: void simplifyUndefinedSizeArray ( ) ;
412:
|
419:
420: bool simplifyKnownVariables ( ) ;
421:
|
425:
426: static bool simplifyKnownVariablesGetData ( int varid@var981 , Token * * _tok2@var982 , Token * * _tok3@var983 , std :: string & value@var984 , int & valueVarId@var985 , bool & valueIsPointer@var986 , bool floatvar@var987 ) ;
427:
|
431:
432: bool simplifyKnownVariablesSimplify ( Token * * tok2@var988 , Token * tok3@var989 , int varid@var990 , const std :: string & structname@var991 , std :: string & value@var992 , int valueVarId@var993 , bool valueIsPointer@var994 , const Token * const valueToken@var995 , int indentlevel@var996 ) const ;
433:
434:
435: void simplifyEmptyNamespaces ( ) ;
436:
|
439:
440: void simplifyFlowControl ( ) ;
441:
442:
443: void simplifyNestedStrcat ( ) ;
444:
445:
446: void elseif ( ) ;
447:
448:
449: void simplifyIfSwitchForInit ( ) ;
450:
|
454:
455: bool simplifyConditions ( ) ;
456:
|
461:
462: bool removeRedundantConditions ( ) ;
463:
|
467:
468: void removeRedundantFor ( ) ;
469:
|
473:
474: void removeRedundantSemicolons ( ) ;
475:
|
479:
480: bool simplifyFunctionReturn ( ) ;
481:
|
485:
486: void simplifyStructDecl ( ) ;
487:
|
496:
497: bool simplifyRedundantParentheses ( ) ;
498:
499: void simplifyCharAt ( ) ;
500:
501:
502: void simplifyReference ( ) ;
503:
|
507:
508: void simplifyFunctionParameters ( ) ;
509:
|
513:
514: void simplifyFunctionTryCatch ( ) ;
515:
|
518:
519: void simplifyTemplates ( ) ;
520:
521: void simplifyDoublePlusAndDoubleMinus ( ) ;
522:
523: void simplifyRedundantConsecutiveBraces ( ) ;
524:
525: void simplifyArrayAccessSyntax ( ) ;
526:
527: void simplifyParameterVoid ( ) ;
528:
529: void fillTypeSizes ( ) ;
530:
531: void combineOperators ( ) ;
532:
533: void combineStringAndCharLiterals ( ) ;
534:
535: void concatenateNegativeNumberAndAnyPositive ( ) ;
536:
537: void simplifyExternC ( ) ;
538:
539: void simplifyRoundCurlyParentheses ( ) ;
540:
541: void simplifyTypeIntrinsics ( ) ;
542:
543: void simplifySQL ( ) ;
544:
545: void checkForEnumsWithTypedef ( ) ;
546:
547: void findComplicatedSyntaxErrorsInTemplates ( ) ;
548:
|
551:
552: void simplifyMathFunctions ( ) ;
553:
|
556:
557: void simplifyMathExpressions ( ) ;
558:
|
564:
565: static std :: string simplifyString ( const std :: string & source@var997 ) ;
566:
|
572:
573: const Token * isFunctionHead ( const Token * tok@var998 , const std :: string & endsWith@var999 ) const ;
574:
|
581:
582: static const Token * isFunctionHead ( const Token * tok@var1000 , const std :: string & endsWith@var1001 , bool cpp@var1002 ) ;
583:
584: void setPreprocessor ( const Preprocessor * preprocessor@var1003 ) {
585: mPreprocessor@var1077 =@expr1073744111 preprocessor@var1003 ;
586: }
587: const Preprocessor * getPreprocessor ( ) const {
588: return mPreprocessor@var1077 ;
589: }
590:
591: bool hasIfdef ( const Token * start@var1004 , const Token * end@var1005 ) const ;
592:
593: private:
594:
|
597:
598: void simplifyWhile0 ( ) ;
599:
|
602:
603: void simplifyErrNoInWhile ( ) ;
604:
|
607:
608: void simplifyFuncInWhile ( ) ;
609:
|
612:
613: void simplifyStd ( ) ;
614:
615:
616: void simplifyPointerToStandardType ( ) ;
617:
618:
619: void simplifyFunctionPointers ( ) ;
620:
|
624:
625: void cppcheckError ( const Token * tok@var1006 ) const ;
626:
|
629:
630: void createLinks ( ) ;
631:
|
634:
635: void createLinks2 ( ) ;
636:
637: public:
638:
639:
640: void syntaxError ( const Token * tok@var1007 , const std :: string & code@var1008 = "" ) const ;
641:
642:
643: void unmatchedToken ( const Token * tok@var1009 ) const ;
644:
645:
646: void syntaxErrorC ( const Token * tok@var1010 , const std :: string & what@var1011 ) const ;
647:
648:
649: void unknownMacroError ( const Token * tok1@var1012 ) const ;
650:
651: void unhandledCharLiteral ( const Token * tok@var1013 , const std :: string & msg@var1014 ) const ;
652:
653: private:
654:
655:
656: void unhandled_macro_class_x_y ( const Token * tok@var1015 ) const ;
657:
658:
659: void checkConfiguration ( ) const ;
660: void macroWithSemicolonError ( const Token * tok@var1016 , const std :: string & macroName@var1017 ) const ;
661:
|
664:
665: void validateC ( ) const ;
666:
|
670:
671: void validate ( ) const ;
672:
673:
674: void reportUnknownMacros ( ) const ;
675:
676:
677: void findGarbageCode ( ) const ;
678:
679:
680: static bool isGarbageExpr ( const Token * start@var1018 , const Token * end@var1019 , bool allowSemicolon@var1020 ) ;
681:
|
684:
685: void simplifyDeclspec ( ) ;
686:
|
689:
690: void simplifyCallingConvention ( ) ;
691:
|
694:
695: void simplifyAttribute ( ) ;
696:
|
699:
700: void simplifyCppcheckAttribute ( ) ;
701:
702:
703: void removeAlignas ( ) ;
704:
705:
706: void simplifySpaceshipOperator ( ) ;
707:
|
710:
711: void simplifyKeyword ( ) ;
712:
|
715:
716: void simplifyAsm ( ) ;
717:
|
720:
721: void simplifyAsm2 ( ) ;
722:
|
725:
726: void simplifyAt ( ) ;
727:
|
730:
731: void simplifyBitfields ( ) ;
732:
|
735:
736: void removeUnnecessaryQualification ( ) ;
737:
|
740:
741: void simplifyNamespaceStd ( ) ;
742:
|
749:
750: void simplifyMicrosoftMemoryFunctions ( ) ;
751:
|
755:
756: void simplifyMicrosoftStringFunctions ( ) ;
757:
|
760:
761: void simplifyBorland ( ) ;
762:
|
765:
766: void simplifyQtSignalsSlots ( ) ;
767:
|
771:
772: void simplifyOperatorName ( ) ;
773:
774:
775: void simplifyOverloadedOperators ( ) ;
776:
|
779:
780: void simplifyCPPAttribute ( ) ;
781:
|
785:
786: bool simplifyStrlen ( ) ;
787:
|
790:
791: void simplifyNamespaceAliases ( ) ;
792:
|
795:
796: void simplifyNestedNamespace ( ) ;
797:
|
802:
803: void simplifyCoroutines ( ) ;
804:
|
807:
808: void prepareTernaryOpForAST ( ) ;
809:
|
812:
813: void reportError ( const Token * tok@var1021 , const Severity :: SeverityType severity@var1022 , const std :: string & id@var1023 , const std :: string & msg@var1024 , bool inconclusive@var1025 = false ) const ;
814: void reportError ( const std :: list < const Token * > & callstack@var1026 , Severity :: SeverityType severity@var1027 , const std :: string & id@var1028 , const std :: string & msg@var1029 , bool inconclusive@var1030 = false ) const ;
815:
816: bool duplicateTypedef ( Token * * tokPtr@var1031 , const Token * name@var1032 , const Token * typeDef@var1033 ) const ;
817:
818: void unsupportedTypedef ( const Token * tok@var1034 ) const ;
819:
820: void setVarIdClassDeclaration ( const Token * const startToken@var1035 ,
821: const VariableMap & variableMap@var1036 ,
822: const int scopeStartVarId@var1037 ,
823: std :: map < int , std :: map < std :: string , int > > & structMembers@var1038 ) ;
824:
825: void setVarIdStructMembers ( Token * * tok1@var1039 ,
826: std :: map < int , std :: map < std :: string , int > > & structMembers@var1040 ,
827: int * varId@var1041 ) const ;
828:
829: void setVarIdClassFunction ( const std :: string & classname@var1042 ,
830: Token * const startToken@var1043 ,
831: const Token * const endToken@var1044 ,
832: const std :: map < std :: string , int > & varlist@var1045 ,
833: std :: map < int , std :: map < std :: string , int > > & structMembers@var1046 ,
834: int * varId_@var1047 ) ;
835:
|
839:
840: void simplifyReturnStrncat ( ) ;
841:
|
844:
845: void printUnknownTypes ( ) const ;
846:
847:
848: static const Token * findSQLBlockEnd ( const Token * tokSQLStart@var1048 ) ;
849:
850: bool operatorEnd ( const Token * tok@var1049 ) const ;
851:
852: public:
853:
854:
855: bool codeWithTemplates ( ) const {
856: return mCodeWithTemplates@var1075 ;
857: }
858:
859:
860: void setSettings ( const Settings * settings@var1050 ) {
861: mSettings@var1061 =@expr1073744112 settings@var1050 ;
862: list@var1054 .@expr1073744113 setSettings (@expr1073744114 settings@var1050 ) ;
863: }
864:
865: const SymbolDatabase * getSymbolDatabase ( ) const {
866: return mSymbolDatabase@var1063 ;
867: }
868: void createSymbolDatabase ( ) ;
869: void deleteSymbolDatabase ( ) ;
870:
|
875:
876: void printDebugOutput ( int simplification@var1051 ) const ;
877:
878: void dump ( std :: ostream & out@var1052 ) const ;
879:
880: Token * deleteInvalidTypedef ( Token * typeDef@var1053 ) ;
881:
|
885:
886: int varIdCount ( ) const {
887: return mVarId@var1073 ;
888: }
889:
|
892:
893: TokenList list@var1054 ;
894:
895: const Token * tokens ( ) const {
896: return list@var1054 .@expr1073744115 front (@expr1073744116 ) ;
897: }
898:
|
903:
904: static bool isZeroNumber ( const std :: string & s@var1055 ) ;
905:
|
910:
911: static bool isOneNumber ( const std :: string & s@var1056 ) ;
912:
|
917:
918: static bool isTwoNumber ( const std :: string & s@var1057 ) ;
919:
|
925:
926: static const Token * startOfExecutableScope ( const Token * tok@var1058 ) ;
927:
|
931:
932: static bool isMaxTime ( ) {
933: return false ;
934:
935: }
936:
937: const Settings * getSettings ( ) const {
938: return mSettings@var1061 ;
939: }
940:
941: void calculateScopes ( ) ;
942:
943:
944: Tokenizer ( const Tokenizer & ) = delete ;
945:
946:
947: Tokenizer & operator= ( const Tokenizer & ) = delete ;
948:
949: private:
950: Token * processFunc ( Token * tok2@var1059 , bool inOperator@var1060 ) const ;
951:
|
955:
956: int newVarId ( ) {
957: return ++@expr1073744117 mVarId@var1073 ;
958: }
959:
960:
961: void setPodTypes ( ) ;
962:
963:
964: const Settings * mSettings@var1061 ;
965:
966:
967: ErrorLogger * const mErrorLogger@var1062 ;
968:
969:
970: SymbolDatabase * mSymbolDatabase@var1063 ;
971:
972: TemplateSimplifier * mTemplateSimplifier@var1064 ;
973:
974:
975:
976: std :: string mConfiguration@var1065 ;
977:
978:
979: std :: map < std :: string , int > mTypeSize@var1066 ;
980:
981: struct TypedefInfo {
982: std :: string name@var1067 ;
983: std :: string filename@var1068 ;
984: int lineNumber@var1069 ;
985: int column@var1070 ;
986: bool used@var1071 ;
987: } ;
988: std :: vector < TypedefInfo > mTypedefInfo@var1072 ;
989:
990:
991: int mVarId@var1073 ;
992:
993:
994: int mUnnamedCount@var1074 ;
995:
|
999:
1000: bool mCodeWithTemplates@var1075 ;
1001:
|
1004:
1005: TimerResults * mTimerResults@var1076 ;
1006:
|
1011:
1012: const Preprocessor * mPreprocessor@var1077 ;
1013: } ;

##file cppcheck-2.8/lib/suppressions.cpp

1:
|
36:
37: static bool isAcceptedErrorIdChar ( char c@var1078 )
38: {
39: switch (@expr1073744118 c@var1078 ) {
40: case '_' :@expr2295
41: case '-' :@expr2295
42: case '.' :@expr2295 ;
43: return true ;
44: default :@expr2295 ;
45: return std ::@expr1073744123 isalnum (@expr1073744124 c@var1078 ) ;
46: }
47: }
48:
49: std :: string Suppressions :: parseFile ( std :: istream & istr@var1079 )
50: {
51:
52: std ::@expr1073744125 string filedata@var1080 ;
53: std ::@expr1073744126 string line@var1081 ;
54: while (@expr1073744127 std ::@expr2304 getline (@expr1073744129 istr@var1079 , line@var1081 ) ) {
55: filedata@var1080 +=@expr1073744130 line@var1081 +@expr1073744131 "\n" ; }
56: std ::@expr1073744132 replace (@expr1073744133 filedata@var1080 .@expr1073744134 begin (@expr1073744135 ) , filedata@var1080 .@expr1073744136 end (@expr1073744137 ) , '\r' , '\n' ) ;
57:
58:
59: std ::@expr1073744138 istringstream istr2@var1082 (@expr1073744139 filedata@var1080 ) ;
60: while (@expr1073744140 std ::@expr2304 getline (@expr1073744142 istr2@var1082 , line@var1081 ) ) {
61:
62: if (@expr1073744143 line@var1081 .@expr1073744144 empty (@expr1073744145 ) ) {
63: continue ; }
64:
65:
66: if (@expr1073744146 line@var1081 .@expr2323 length (@expr2324 ) >@expr1073744149 1 &&@expr1073744150 line@var1081 [@expr2327 0 ] ==@expr1073744152 '#' ) {
67: continue ; }
68: if (@expr1073744153 line@var1081 .@expr2323 length (@expr2324 ) >=@expr1073744156 2 &&@expr1073744157 line@var1081 [@expr2327 0 ] ==@expr1073744159 '/' &&@expr1073744160 line@var1081 [@expr1073744161 1 ] ==@expr1073744162 '/' ) {
69: continue ; }
70:
71: const std ::@expr1073744163 string errmsg@var1083 (@expr1073744164 addSuppressionLine (@expr1073744165 line@var1081 ) ) ;
72: if (@expr1073744166 !@expr1073744167 errmsg@var1083 .@expr1073744168 empty (@expr1073744169 ) ) {
73: return errmsg@var1083 ; }
74: }
75:
76: return "" ;
77: }
78:
79:
80: std :: string Suppressions :: parseXmlFile ( const char * filename@var1084 )
81: {
82: tinyxml2 ::@expr1073744173 XMLDocument doc@var1085 ;
83: const tinyxml2 ::@expr2350 XMLError error@var1086 =@expr1073744175 doc@var1085 .@expr1073744176 LoadFile (@expr1073744177 filename@var1084 ) ;
84: if (@expr1073744178 error@var1086 ==@expr1073744179 tinyxml2 ::@expr1073744180 XML_ERROR_FILE_NOT_FOUND@expr1073744170 ) {
85: return "File not found" ; }
86: if (@expr1073744181 error@var1086 !=@expr1073744182 tinyxml2 ::@expr1073744183 XML_SUCCESS@expr1073744171 ) {
87: return "Failed to parse XML file" ; }
88:
89: const tinyxml2 ::@expr1073744184 XMLElement@expr1073744172 * const rootnode@var1087 ; rootnode@var1087 =@expr1073744185 doc@var1085 .@expr1073744186 FirstChildElement (@expr1073744187 ) ;
90: for (@expr1073744188 const tinyxml2 ::@expr2350 XMLElement *@expr2366 e@var1088 =@expr1073744191 rootnode@var1087 .@expr1073744192 FirstChildElement (@expr1073744193 ) ; e@var1088 ; e@var1088 =@expr1073744194 e@var1088 .@expr1073744195 NextSiblingElement (@expr1073744196 ) ) {
91: if (@expr1073744197 std ::@expr2374 strcmp (@expr1073744199 e@var1088 .@expr2376 Name (@expr2377 ) , "suppress" ) !=@expr1073744202 0 ) {
92: return "Invalid suppression xml file format, expected <suppress> element but got a \"" +@expr1073744203 std ::@expr2380 string (@expr1073744205 e@var1088 .@expr2376 Name (@expr2377 ) ) +@expr1073744208 '\"' ; }
93:
94: Suppression s@var1089 ;
95: for (@expr1073744209 const tinyxml2 ::@expr2350 XMLElement *@expr2366 e2@var1090 =@expr1073744212 e@var1088 .@expr1073744213 FirstChildElement (@expr1073744214 ) ; e2@var1090 ; e2@var1090 =@expr1073744215 e2@var1090 .@expr1073744216 NextSiblingElement (@expr1073744217 ) ) {
96: const char * text@var1091 ; text@var1091 =@expr1073744218 e2@var1090 .@expr2395 GetText (@expr2396 ) ?@expr1073744221 e2@var1090 .@expr2395 GetText (@expr2396 ) :@expr1073744224 "" ;
97: if (@expr1073744225 std ::@expr2374 strcmp (@expr1073744227 e2@var1090 .@expr2404 Name (@expr2405 ) , "id" ) ==@expr1073744230 0 ) {
98: s@var1089 .@expr1073744231 errorId@var1092 =@expr1073744232 text@var1091 ; }
99: else { if (@expr1073744233 std ::@expr2374 strcmp (@expr1073744235 e2@var1090 .@expr2404 Name (@expr2405 ) , "fileName" ) ==@expr1073744238 0 ) {
100: s@var1089 .@expr1073744239 fileName@var1093 =@expr1073744240 text@var1091 ; }
101: else { if (@expr1073744241 std ::@expr2374 strcmp (@expr1073744243 e2@var1090 .@expr2404 Name (@expr2405 ) , "lineNumber" ) ==@expr1073744246 0 ) {
102: s@var1089 .@expr1073744247 lineNumber@var1094 =@expr1073744248 std ::@expr1073744249 atoi (@expr1073744250 text@var1091 ) ; }
103: else { if (@expr1073744251 std ::@expr2374 strcmp (@expr1073744253 e2@var1090 .@expr2404 Name (@expr2405 ) , "symbolName" ) ==@expr1073744256 0 ) {
104: s@var1089 .@expr1073744257 symbolName@var1095 =@expr1073744258 text@var1091 ; }
105: else { if (@expr1073744259 *@expr1073744260 text@var1091 &&@expr1073744261 std ::@expr2374 strcmp (@expr1073744263 e2@var1090 .@expr2404 Name (@expr2405 ) , "hash" ) ==@expr1073744266 0 ) {
106: std ::@expr1073744267 istringstream (@expr1073744268 text@var1091 ) >>@expr1073744269 s@var1089 .@expr1073744270 hash@var1096 ; }
107: else {
108: return "Unknown suppression element \"" +@expr1073744271 std ::@expr2380 string (@expr1073744273 e2@var1090 .@expr2404 Name (@expr2405 ) ) +@expr1073744276 "\", expected id/fileName/lineNumber/symbolName/hash" ; } } } } }
109: }
110:
111: const std ::@expr2350 string err@var1097 =@expr1073744278 addSuppression (@expr1073744279 s@var1089 ) ;
112: if (@expr1073744280 !@expr1073744281 err@var1097 .@expr1073744282 empty (@expr1073744283 ) ) {
113: return err@var1097 ; }
114: }
115:
116: return "" ;
117: }
118:
119: std :: vector < Suppressions :: Suppression > Suppressions :: parseMultiSuppressComment ( const std :: string & comment@var1098 , std :: string * errorMessage@var1099 )
120: {
121: std ::@expr1073744285 vector < Suppression > suppressions@var1100 ;
122:
123:
124: const std ::@expr2462 string ::@expr2462 size_type start_position@var1101 =@expr1073744288 comment@var1098 .@expr2465 find (@expr1073744290 "[" ) ;
125: const std ::@expr2462 string ::@expr2462 size_type end_position@var1102 =@expr1073744293 comment@var1098 .@expr2465 find (@expr1073744295 "]" , start_position@var1101 ) ;
126: if (@expr1073744296 end_position@var1102 ==@expr1073744297 std ::@expr2474 string ::@expr2475 npos@expr2460 ) {
127: if (@expr2476 errorMessage@var1099 &&@expr2477 errorMessage@var1099 .@expr2478 empty (@expr2479 ) ) {
128: *@expr2480 errorMessage@var1099 =@expr1073744305 "Bad multi suppression '" +@expr2482 comment@var1098 +@expr2483 "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" ; }
129: return suppressions@var1100 ;
130: }
131:
132:
133: for (@expr1073744308 std ::@expr2462 string ::@expr2462 size_type pos@var1103 =@expr1073744311 start_position@var1101 ; pos@var1103 <@expr2488 end_position@var1102 ; ) {
134: const std ::@expr2462 string ::@expr2462 size_type pos1@var1104 =@expr1073744315 pos@var1103 +@expr1073744316 1 ;
135: pos@var1103 =@expr1073744317 comment@var1098 .@expr2465 find (@expr1073744319 "," , pos1@var1104 ) ;
136: const std ::@expr2462 string ::@expr2462 size_type pos2@var1105 =@expr1073744322 (@expr1073744323 pos@var1103 <@expr2488 end_position@var1102 ) ?@expr1073744325 pos@var1103 :@expr1073744326 end_position@var1102 ;
137: if (@expr1073744327 pos1@var1104 ==@expr1073744328 pos2@var1105 ) {
138: continue ; }
139:
140: Suppression s@var1106 ;
141: std ::@expr1073744329 istringstream iss@var1107 (@expr1073744330 comment@var1098 .@expr1073744331 substr (@expr1073744332 pos1@var1104 , pos2@var1105 -@expr1073744333 pos1@var1104 ) ) ;
142:
143: iss@var1107 >>@expr1073744334 s@var1106 .@expr1073744335 errorId@var1108 ;
144: if (@expr2512 !@expr2513 iss@var1107 ) {
145: if (@expr2476 errorMessage@var1099 &&@expr2477 errorMessage@var1099 .@expr2478 empty (@expr2479 ) ) {
146: *@expr2480 errorMessage@var1099 =@expr1073744343 "Bad multi suppression '" +@expr2482 comment@var1098 +@expr2483 "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" ; }
147: suppressions@var1100 .@expr2522 clear (@expr2523 ) ;
148: return suppressions@var1100 ;
149: }
150:
151: while (@expr1073744348 iss@var1107 ) {
152: std ::@expr1073744349 string word@var1109 ;
153: iss@var1107 >>@expr1073744350 word@var1109 ;
154: if (@expr2512 !@expr2513 iss@var1107 ) {
155: break ; }
156: if (@expr1073744353 word@var1109 .@expr1073744354 find_first_not_of (@expr1073744355 "+-*/%#;" ) ==@expr1073744356 std ::@expr2474 string ::@expr2475 npos@expr2460 ) {
157: break ; }
158: if (@expr1073744359 word@var1109 .@expr1073744360 compare (@expr1073744361 0 , 11 , "symbolName=" ) ==@expr1073744362 0 ) {
159: s@var1106 .@expr1073744363 symbolName@var1110 =@expr1073744364 word@var1109 .@expr1073744365 substr (@expr1073744366 11 ) ;
160: } else {
161: if (@expr2476 errorMessage@var1099 &&@expr2477 errorMessage@var1099 .@expr2478 empty (@expr2479 ) ) {
162: *@expr2480 errorMessage@var1099 =@expr1073744372 "Bad multi suppression '" +@expr2482 comment@var1098 +@expr2483 "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" ; }
163: suppressions@var1100 .@expr2522 clear (@expr2523 ) ;
164: return suppressions@var1100 ;
165: }
166: }
167:
168: suppressions@var1100 .@expr1073744377 push_back (@expr1073744378 s@var1106 ) ;
169: }
170:
171: return suppressions@var1100 ;
172: }
173:
174: std :: string Suppressions :: addSuppressionLine ( const std :: string & line@var1111 )
175: {
176: std ::@expr1073744380 istringstream lineStream@var1112 ;
177: Suppressions ::@expr1073744381 Suppression suppression@var1113 ;
178:
179:
180: std ::@expr2558 string ::@expr1073744383 size_type endpos@var1114 ; endpos@var1114 =@expr1073744384 std ::@expr1073744385 min (@expr1073744386 line@var1111 .@expr2563 find (@expr1073744388 "#" ) , line@var1111 .@expr2563 find (@expr1073744390 "//" ) ) ;
181: if (@expr1073744391 endpos@var1114 !=@expr1073744392 std ::@expr2558 string ::@expr2570 npos@expr2555 ) {
182: while (@expr1073744395 endpos@var1114 >@expr1073744396 0 &&@expr1073744397 std ::@expr1073744398 isspace (@expr1073744399 line@var1111 [@expr1073744400 endpos@var1114 -@expr1073744401 1 ] ) ) {
183: endpos@var1114 --@expr1073744402 ;
184: }
185: lineStream@var1112 .@expr2579 str (@expr1073744404 line@var1111 .@expr1073744405 substr (@expr1073744406 0 , endpos@var1114 ) ) ;
186: } else {
187: lineStream@var1112 .@expr2579 str (@expr1073744408 line@var1111 ) ;
188: }
189:
190: if (@expr1073744409 std ::@expr2586 getline (@expr1073744411 lineStream@var1112 , suppression@var1113 .@expr1073744412 errorId@var1115 , ':' ) ) {
191: if (@expr1073744413 std ::@expr2586 getline (@expr1073744415 lineStream@var1112 , suppression@var1113 .@expr2592 fileName@var1116 ) ) {
192:
|
196:
197: const std ::@expr2593 string ::@expr2593 size_type pos@var1117 =@expr1073744419 suppression@var1113 .@expr2592 fileName@var1116 .@expr1073744421 rfind (@expr1073744422 ':' ) ;
198:
199:
200: if (@expr1073744423 pos@var1117 !=@expr1073744424 std ::@expr2558 string ::@expr2570 npos &&@expr1073744427
201: suppression@var1113 .@expr2592 fileName@var1116 .@expr1073744429 find (@expr1073744430 '.' , pos@var1117 ) ==@expr1073744431 std ::@expr2558 string ::@expr2570 npos@expr2555 ) {
202:
203: try {
204: std ::@expr1073744434 istringstream istr1@var1118 (@expr1073744435 suppression@var1113 .@expr2592 fileName@var1116 .@expr1073744437 substr (@expr1073744438 pos@var1117 +@expr1073744439 1 ) ) ;
205: istr1@var1118 >>@expr1073744440 suppression@var1113 .@expr2617 lineNumber@var1119 ;
206: } catch (@expr1073744442 ... ) {
207: suppression@var1113 .@expr2617 lineNumber@var1119 =@expr1073744444 Suppressions ::@expr2621 Suppression ::@expr2622 NO_LINE ;
208: }
209:
210: if (@expr1073744447 suppression@var1113 .@expr2617 lineNumber@var1119 !=@expr1073744449 Suppressions ::@expr2621 Suppression ::@expr2622 NO_LINE ) {
211: suppression@var1113 .@expr2592 fileName@var1116 .@expr1073744453 erase (@expr1073744454 pos@var1117 ) ;
212: }
213: }
214: }
215: }
216:
217: suppression@var1113 .@expr2592 fileName@var1116 =@expr1073744456 Path ::@expr1073744457 simplifyPath (@expr1073744458 suppression@var1113 .@expr2592 fileName@var1116 ) ;
218:
219: return addSuppression (@expr1073744460 suppression@var1113 ) ;
220: }
221:
222: std :: string Suppressions :: addSuppression ( const Suppressions :: Suppression & suppression@var1120 )
223: {
224:
225: auto foundSuppression@var1121 ; foundSuppression@var1121 =@expr1073744462 std ::@expr1073744463 find_if (@expr1073744464 mSuppressions@var73 .@expr1073744465 begin (@expr1073744466 ) , mSuppressions@var73 .@expr2643 end (@expr2644 ) ,
226: std ::@expr1073744469 bind (@expr1073744470 &@expr1073744471 Suppression ::@expr1073744472 isSameParameters , &@expr1073744473 suppression@var1120 , std ::@expr1073744474 placeholders ::@expr1073744475 _1@expr1073744461 ) ) ;
227: if (@expr1073744476 foundSuppression@var1121 !=@expr1073744477 mSuppressions@var73 .@expr2643 end (@expr2644 ) ) {
228:
229: if (@expr1073744480 !@expr1073744481 suppression@var1120 .@expr1073744482 isLocal (@expr1073744483 ) &&@expr1073744484 suppression@var1120 .@expr2661 matched@var1122 ) {
230: foundSuppression@var1121 .@expr1073744486 matched@var1123 =@expr1073744487 suppression@var1120 .@expr2661 matched@var1122 ; }
231: return "" ;
232: }
233:
234:
235: if (@expr1073744489 suppression@var1120 .@expr2666 errorId@var1124 .@expr1073744491 empty (@expr1073744492 ) &&@expr1073744493 suppression@var1120 .@expr1073744494 hash@var1125 ==@expr1073744495 0 ) {
236: return "Failed to add suppression. No id." ; }
237:
238: if (@expr1073744496 suppression@var1120 .@expr2666 errorId@var1124 !=@expr1073744498 "*" ) {
239: for (@expr1073744499 std ::@expr2676 string ::@expr2676 size_type pos@var1126 =@expr1073744502 0 ; pos@var1126 <@expr1073744503 suppression@var1120 .@expr2666 errorId@var1124 .@expr1073744505 length (@expr1073744506 ) ; ++@expr1073744507 pos@var1126 ) {
240: if (@expr1073744508 suppression@var1120 .@expr2666 errorId@var1124 [@expr2686 pos@var1126 ] <@expr1073744511 0 ||@expr1073744512 !@expr1073744513 isAcceptedErrorIdChar (@expr1073744514 suppression@var1120 .@expr2666 errorId@var1124 [@expr2686 pos@var1126 ] ) ) {
241: return "Failed to add suppression. Invalid id \"" +@expr2693 suppression@var1120 .@expr2666 errorId@var1124 +@expr2695 "\"" ;
242: }
243: if (@expr1073744520 pos@var1126 ==@expr1073744521 0 &&@expr1073744522 std ::@expr1073744523 isdigit (@expr1073744524 suppression@var1120 .@expr2666 errorId@var1124 [@expr2686 pos@var1126 ] ) ) {
244: return "Failed to add suppression. Invalid id \"" +@expr2693 suppression@var1120 .@expr2666 errorId@var1124 +@expr2695 "\"" ;
245: }
246: }
247: }
248:
249: if (@expr1073744530 !@expr1073744531 isValidGlobPattern (@expr1073744532 suppression@var1120 .@expr2666 errorId@var1124 ) ) {
250: return "Failed to add suppression. Invalid glob pattern '" +@expr1073744534 suppression@var1120 .@expr2666 errorId@var1124 +@expr1073744536 "'." ; }
251: if (@expr1073744537 !@expr1073744538 isValidGlobPattern (@expr1073744539 suppression@var1120 .@expr2716 fileName@var1127 ) ) {
252: return "Failed to add suppression. Invalid glob pattern '" +@expr1073744541 suppression@var1120 .@expr2716 fileName@var1127 +@expr1073744543 "'." ; }
253:
254: mSuppressions@var73 .@expr1073744544 push_back (@expr1073744545 suppression@var1120 ) ;
255:
256: return "" ;
257: }
258:
259: std :: string Suppressions :: addSuppressions ( const std :: list < Suppression > & suppressions@var1128 )
260: {
261: for (@expr1073744546 const auto &@expr1073744547 newSuppression@var1129 :@expr1073744548 suppressions@var1128 ) {
262: auto errmsg@var1130 ; errmsg@var1130 =@expr1073744549 addSuppression (@expr1073744550 newSuppression@var1129 ) ;
263: if (@expr1073744551 !@expr1073744552 errmsg@var1130 .@expr1073744553 empty (@expr1073744554 ) ) {
264: return errmsg@var1130 ; }
265: }
266: return "" ;
267: }
268:
269: void Suppressions :: ErrorMessage :: setFileName ( const std :: string & s@var1131 )
270: {
271: mFileName@var19 =@expr1073744555 Path ::@expr1073744556 simplifyPath (@expr1073744557 s@var1131 ) ;
272: }
273:
274: bool Suppressions :: Suppression :: parseComment ( std :: string comment@var1132 , std :: string * errorMessage@var1133 )
275: {
276: if (@expr1073744559 comment@var1132 .@expr2736 size (@expr2737 ) <@expr1073744562 2 ) {
277: return false ; }
278:
279: if (@expr1073744563 comment@var1132 .@expr2740 find (@expr2741 ';' ) !=@expr1073744566 std ::@expr2743 string ::@expr2744 npos@expr2734 ) {
280: comment@var1132 .@expr2745 erase (@expr1073744570 comment@var1132 .@expr2740 find (@expr2741 ';' ) ) ; }
281:
282: if (@expr1073744573 comment@var1132 .@expr2740 find (@expr2751 "//" , 2 ) !=@expr1073744576 std ::@expr2743 string ::@expr2744 npos@expr2734 ) {
283: comment@var1132 .@expr2745 erase (@expr1073744580 comment@var1132 .@expr2740 find (@expr2751 "//" , 2 ) ) ; }
284:
285: if (@expr1073744583 comment@var1132 .@expr1073744584 compare (@expr1073744585 comment@var1132 .@expr2736 size (@expr2737 ) -@expr2764 2 , 2 , "*/" ) ==@expr1073744589 0 ) {
286: comment@var1132 .@expr2745 erase (@expr1073744591 comment@var1132 .@expr2736 size (@expr2737 ) -@expr2764 2 , 2 ) ; }
287:
288: std ::@expr1073744595 istringstream iss@var1134 (@expr1073744596 comment@var1132 .@expr1073744597 substr (@expr1073744598 2 ) ) ;
289: std ::@expr1073744599 string word@var1135 ;
290: iss@var1134 >>@expr2776 word@var1135 ;
291: if (@expr1073744601 word@var1135 !=@expr1073744602 "cppcheck-suppress" ) {
292: return false ; }
293: iss@var1134 >>@expr1073744603 errorId@var51 ;
294: if (@expr2780 !@expr2781 iss@var1134 ) {
295: return false ; }
296: while (@expr1073744606 iss@var1134 ) {
297: iss@var1134 >>@expr2776 word@var1135 ;
298: if (@expr2780 !@expr2781 iss@var1134 ) {
299: break ; }
300: if (@expr1073744610 word@var1135 .@expr1073744611 find_first_not_of (@expr1073744612 "+-*/%#;" ) ==@expr1073744613 std ::@expr2743 string ::@expr2744 npos@expr2734 ) {
301: break ; }
302: if (@expr1073744616 word@var1135 .@expr1073744617 compare (@expr1073744618 0 , 11 , "symbolName=" ) ==@expr1073744619 0 ) {
303: symbolName@var54 =@expr1073744620 word@var1135 .@expr1073744621 substr (@expr1073744622 11 ) ; }
304: else { if (@expr1073744623 errorMessage@var1133 &&@expr1073744624 errorMessage@var1133 .@expr1073744625 empty (@expr1073744626 ) ) {
305: *@expr1073744627 errorMessage@var1133 =@expr1073744628 "Bad suppression attribute '" +@expr1073744629 word@var1135 +@expr1073744630 "'. You can write comments in the comment after a ; or //. Valid suppression attributes; symbolName=sym" ; } }
306: }
307: return true ;
308: }
309:
310: bool Suppressions :: Suppression :: isSuppressed ( const Suppressions :: ErrorMessage & errmsg@var1136 ) const
311: {
312: if (@expr1073744632 hash@var55 >@expr1073744633 0 &&@expr1073744634 hash@var55 !=@expr1073744635 errmsg@var1136 .@expr1073744636 hash@var1137 ) {
313: return false ; }
314: if (@expr1073744637 !@expr1073744638 errorId@var51 .@expr1073744639 empty (@expr1073744640 ) &&@expr1073744641 !@expr1073744642 matchglob (@expr1073744643 errorId@var51 , errmsg@var1136 .@expr1073744644 errorId@var1138 ) ) {
315: return false ; }
316: if (@expr1073744645 !@expr1073744646 fileName@var52 .@expr1073744647 empty (@expr1073744648 ) &&@expr1073744649 !@expr1073744650 matchglob (@expr1073744651 fileName@var52 , errmsg@var1136 .@expr1073744652 getFileName (@expr1073744653 ) ) ) {
317: return false ; }
318: if (@expr1073744654 lineNumber@var53 !=@expr1073744655 NO_LINE &&@expr1073744656 lineNumber@var53 !=@expr1073744657 errmsg@var1136 .@expr2834 lineNumber@var1139 ) {
319: if (@expr1073744659 !@expr1073744660 thisAndNextLine@var56 ||@expr1073744661 lineNumber@var53 +@expr1073744662 1 !=@expr1073744663 errmsg@var1136 .@expr2834 lineNumber@var1139 ) {
320: return false ; }
321: }
322: if (@expr1073744665 !@expr1073744666 symbolName@var54 .@expr1073744667 empty (@expr1073744668 ) ) {
323: for (@expr1073744669 std ::@expr2846 string ::@expr2846 size_type pos@var1140 =@expr1073744672 0 ; pos@var1140 <@expr1073744673 errmsg@var1136 .@expr2850 symbolNames@var1141 .@expr1073744675 size (@expr1073744676 ) ; ) {
324: const std ::@expr2846 string ::@expr2846 size_type pos2@var1142 =@expr1073744679 errmsg@var1136 .@expr2850 symbolNames@var1141 .@expr1073744681 find (@expr1073744682 '\n' , pos@var1140 ) ;
325: std ::@expr1073744683 string symname@var1143 ;
326: if (@expr1073744684 pos2@var1142 ==@expr1073744685 std ::@expr1073744686 string ::@expr1073744687 npos@expr1073744631 ) {
327: symname@var1143 =@expr1073744688 errmsg@var1136 .@expr2850 symbolNames@var1141 .@expr2866 substr (@expr1073744691 pos@var1140 ) ;
328: pos@var1140 =@expr1073744692 pos2@var1142 ;
329: } else {
330: symname@var1143 =@expr1073744693 errmsg@var1136 .@expr2850 symbolNames@var1141 .@expr2866 substr (@expr1073744696 pos@var1140 , pos2@var1142 -@expr1073744697 pos@var1140 ) ;
331: pos@var1140 =@expr1073744698 pos2@var1142 +@expr1073744699 1 ;
332: }
333: if (@expr1073744700 matchglob (@expr1073744701 symbolName@var54 , symname@var1143 ) ) {
334: return true ; }
335: }
336: return false ;
337: }
338: return true ;
339: }
340:
341: bool Suppressions :: Suppression :: isMatch ( const Suppressions :: ErrorMessage & errmsg@var1144 )
342: {
343: if (@expr1073744702 !@expr1073744703 isSuppressed (@expr1073744704 errmsg@var1144 ) ) {
344: return false ; }
345: matched@var57 =@expr1073744705 true ;
346: checked@var58 =@expr1073744706 true ;
347: return true ;
348: }
349:
350: std :: string Suppressions :: Suppression :: getText ( ) const
351: {
352: std ::@expr1073744707 string ret@var1145 ;
353: if (@expr1073744708 !@expr1073744709 errorId@var51 .@expr1073744710 empty (@expr1073744711 ) ) {
354: ret@var1145 =@expr1073744712 errorId@var51 ; }
355: if (@expr1073744713 !@expr1073744714 fileName@var52 .@expr1073744715 empty (@expr1073744716 ) ) {
356: ret@var1145 +=@expr1073744717 " fileName=" +@expr1073744718 fileName@var52 ; }
357: if (@expr1073744719 lineNumber@var53 !=@expr1073744720 NO_LINE ) {
358: ret@var1145 +=@expr1073744721 " lineNumber=" +@expr1073744722 MathLib ::@expr2899 toString (@expr1073744724 lineNumber@var53 ) ; }
359: if (@expr1073744725 !@expr1073744726 symbolName@var54 .@expr1073744727 empty (@expr1073744728 ) ) {
360: ret@var1145 +=@expr1073744729 " symbolName=" +@expr1073744730 symbolName@var54 ; }
361: if (@expr1073744731 hash@var55 >@expr1073744732 0 ) {
362: ret@var1145 +=@expr1073744733 " hash=" +@expr1073744734 MathLib ::@expr2899 toString (@expr1073744736 hash@var55 ) ; }
363: if (@expr1073744737 ret@var1145 .@expr1073744738 compare (@expr1073744739 0 , 1 , " " ) ==@expr1073744740 0 ) {
364: return ret@var1145 .@expr1073744741 substr (@expr1073744742 1 ) ; }
365: return ret@var1145 ;
366: }
367:
368: bool Suppressions :: isSuppressed ( const Suppressions :: ErrorMessage & errmsg@var1146 )
369: {
370: const bool unmatchedSuppression@var1147 (@expr1073744743 errmsg@var1146 .@expr2920 errorId@var1148 ==@expr1073744745 "unmatchedSuppression" ) ;
371: for (@expr1073744746 Suppression &@expr1073744747 s@var1149 :@expr1073744748 mSuppressions@var73 ) {
372: if (@expr1073744749 unmatchedSuppression@var1147 &&@expr1073744750 s@var1149 .@expr1073744751 errorId@var1150 !=@expr1073744752 errmsg@var1146 .@expr2920 errorId@var1148 ) {
373: continue ; }
374: if (@expr1073744754 s@var1149 .@expr1073744755 isMatch (@expr1073744756 errmsg@var1146 ) ) {
375: return true ; }
376: }
377: return false ;
378: }
379:
380: bool Suppressions :: isSuppressedLocal ( const Suppressions :: ErrorMessage & errmsg@var1151 )
381: {
382: const bool unmatchedSuppression@var1152 (@expr1073744757 errmsg@var1151 .@expr2934 errorId@var1153 ==@expr1073744759 "unmatchedSuppression" ) ;
383: for (@expr1073744760 Suppression &@expr1073744761 s@var1154 :@expr1073744762 mSuppressions@var73 ) {
384: if (@expr1073744763 !@expr1073744764 s@var1154 .@expr1073744765 isLocal (@expr1073744766 ) ) {
385: continue ; }
386: if (@expr1073744767 unmatchedSuppression@var1152 &&@expr1073744768 s@var1154 .@expr1073744769 errorId@var1155 !=@expr1073744770 errmsg@var1151 .@expr2934 errorId@var1153 ) {
387: continue ; }
388: if (@expr1073744772 s@var1154 .@expr1073744773 isMatch (@expr1073744774 errmsg@var1151 ) ) {
389: return true ; }
390: }
391: return false ;
392: }
393:
394: void Suppressions :: dump ( std :: ostream & out@var1156 ) const
395: {
396: out@var1156 <<@expr1073744777 "  <suppressions>" <<@expr1073744778 std ::@expr2955 endl@expr2951 ;
397: for (@expr1073744780 const Suppression &@expr1073744781 suppression@var1157 :@expr1073744782 mSuppressions@var73 ) {
398: out@var1156 <<@expr1073744783 "    <suppression" ;
399: out@var1156 <<@expr1073744784 " errorId=\"" <<@expr1073744785 ErrorLogger ::@expr2962 toxml (@expr1073744787 suppression@var1157 .@expr1073744788 errorId@var1158 ) <<@expr1073744789 '"' ;
400: if (@expr1073744790 !@expr1073744791 suppression@var1157 .@expr2968 fileName@var1159 .@expr1073744793 empty (@expr1073744794 ) ) {
401: out@var1156 <<@expr1073744795 " fileName=\"" <<@expr1073744796 ErrorLogger ::@expr2962 toxml (@expr1073744798 suppression@var1157 .@expr2968 fileName@var1159 ) <<@expr1073744800 '"' ; }
402: if (@expr1073744801 suppression@var1157 .@expr2978 lineNumber@var1160 !=@expr1073744803 Suppression ::@expr1073744804 NO_LINE@expr1073744776 ) {
403: out@var1156 <<@expr1073744805 " lineNumber=\"" <<@expr1073744806 suppression@var1157 .@expr2978 lineNumber@var1160 <<@expr1073744808 '"' ; }
404: if (@expr1073744809 !@expr1073744810 suppression@var1157 .@expr2987 symbolName@var1161 .@expr1073744812 empty (@expr1073744813 ) ) {
405: out@var1156 <<@expr1073744814 " symbolName=\"" <<@expr1073744815 ErrorLogger ::@expr2962 toxml (@expr1073744817 suppression@var1157 .@expr2987 symbolName@var1161 ) <<@expr1073744819 '\"' ; }
406: if (@expr1073744820 suppression@var1157 .@expr2997 hash@var1162 >@expr1073744822 0 ) {
407: out@var1156 <<@expr1073744823 " hash=\"" <<@expr1073744824 suppression@var1157 .@expr2997 hash@var1162 <<@expr1073744826 '\"' ; }
408: out@var1156 <<@expr1073744827 " />" <<@expr1073744828 std ::@expr2955 endl@expr2951 ;
409: }
410: out@var1156 <<@expr1073744830 "  </suppressions>" <<@expr1073744831 std ::@expr2955 endl@expr2951 ;
411: }
412:
413: std :: list < Suppressions :: Suppression > Suppressions :: getUnmatchedLocalSuppressions ( const std :: string & file@var1163 , const bool unusedFunctionChecking@var1164 ) const
414: {
415: std ::@expr1073744834 string tmpFile@var1165 ; tmpFile@var1165 =@expr1073744835 Path ::@expr1073744836 simplifyPath (@expr1073744837 file@var1163 ) ;
416: std ::@expr1073744838 list < Suppression > result@var1166 ;
417: for (@expr1073744839 const Suppression &@expr1073744840 s@var1167 :@expr1073744841 mSuppressions@var73 ) {
418: if (@expr1073744842 s@var1167 .@expr1073744843 matched@var1168 ||@expr1073744844 (@expr1073744845 (@expr1073744846 s@var1167 .@expr1073744847 lineNumber@var1169 !=@expr1073744848 Suppression ::@expr1073744849 NO_LINE@expr1073744833 ) &&@expr1073744850 !@expr1073744851 s@var1167 .@expr1073744852 checked@var1170 ) ) {
419: continue ; }
420: if (@expr1073744853 s@var1167 .@expr1073744854 hash@var1171 >@expr1073744855 0 ) {
421: continue ; }
422: if (@expr1073744856 !@expr1073744857 unusedFunctionChecking@var1164 &&@expr1073744858 s@var1167 .@expr1073744859 errorId@var1172 ==@expr1073744860 "unusedFunction" ) {
423: continue ; }
424: if (@expr1073744861 tmpFile@var1165 .@expr1073744862 empty (@expr1073744863 ) ||@expr1073744864 !@expr1073744865 s@var1167 .@expr1073744866 isLocal (@expr1073744867 ) ||@expr1073744868 s@var1167 .@expr1073744869 fileName@var1173 !=@expr1073744870 tmpFile@var1165 ) {
425: continue ; }
426: result@var1166 .@expr1073744871 push_back (@expr1073744872 s@var1167 ) ;
427: }
428: return result@var1166 ;
429: }
430:
431: std :: list < Suppressions :: Suppression > Suppressions :: getUnmatchedGlobalSuppressions ( const bool unusedFunctionChecking@var1174 ) const
432: {
433: std ::@expr1073744874 list < Suppression > result@var1175 ;
434: for (@expr1073744875 const Suppression &@expr1073744876 s@var1176 :@expr1073744877 mSuppressions@var73 ) {
435: if (@expr1073744878 s@var1176 .@expr1073744879 matched@var1177 ||@expr1073744880 (@expr1073744881 (@expr1073744882 s@var1176 .@expr1073744883 lineNumber@var1178 !=@expr1073744884 Suppression ::@expr1073744885 NO_LINE@expr1073744873 ) &&@expr1073744886 !@expr1073744887 s@var1176 .@expr1073744888 checked@var1179 ) ) {
436: continue ; }
437: if (@expr1073744889 s@var1176 .@expr1073744890 hash@var1180 >@expr1073744891 0 ) {
438: continue ; }
439: if (@expr1073744892 !@expr1073744893 unusedFunctionChecking@var1174 &&@expr1073744894 s@var1176 .@expr1073744895 errorId@var1181 ==@expr1073744896 "unusedFunction" ) {
440: continue ; }
441: if (@expr1073744897 s@var1176 .@expr1073744898 isLocal (@expr1073744899 ) ) {
442: continue ; }
443: result@var1175 .@expr1073744900 push_back (@expr1073744901 s@var1176 ) ;
444: }
445: return result@var1175 ;
446: }
447:
448: const std :: list < Suppressions :: Suppression > & Suppressions :: getSuppressions ( ) const
449: {
450: return mSuppressions@var73 ;
451: }
452:
453: void Suppressions :: markUnmatchedInlineSuppressionsAsChecked ( const Tokenizer & tokenizer@var1182 ) {
454: int currLineNr@var1183 ; currLineNr@var1183 =@expr1073744902 -1 ;
455: int currFileIdx@var1184 ; currFileIdx@var1184 =@expr1073744903 -1 ;
456: for (@expr1073744904 const Token *@expr1073744905 tok@var1185 =@expr1073744906 tokenizer@var1182 .@expr1073744907 tokens (@expr1073744908 ) ; tok@var1185 ; tok@var1185 =@expr1073744909 tok@var1185 .@expr1073744910 next (@expr1073744911 ) ) {
457: if (@expr1073744912 currFileIdx@var1184 !=@expr1073744913 tok@var1185 .@expr3090 fileIndex (@expr3091 ) ||@expr1073744916 currLineNr@var1183 !=@expr1073744917 tok@var1185 .@expr3094 linenr (@expr3095 ) ) {
458: currLineNr@var1183 =@expr1073744920 tok@var1185 .@expr3094 linenr (@expr3095 ) ;
459: currFileIdx@var1184 =@expr1073744923 tok@var1185 .@expr3090 fileIndex (@expr3091 ) ;
460: for (@expr1073744926 auto &@expr1073744927 suppression@var1186 :@expr1073744928 mSuppressions@var73 ) {
461: if (@expr1073744929 !@expr1073744930 suppression@var1186 .@expr3107 checked@var1187 &&@expr1073744932 (@expr1073744933 suppression@var1186 .@expr1073744934 lineNumber@var1188 ==@expr1073744935 currLineNr@var1183 ) &&@expr1073744936 (@expr1073744937 suppression@var1186 .@expr1073744938 fileName@var1189 ==@expr1073744939 tokenizer@var1182 .@expr1073744940 list@var1190 .@expr1073744941 file (@expr1073744942 tok@var1185 ) ) ) {
462: suppression@var1186 .@expr3107 checked@var1187 =@expr1073744944 true ;
463: }
464: }
465: }
466: }
467: }



##Value flow
Line 36
  AST always 0
  SYNTAX always 1
  UNKNOWN_MACRO always 2
  INTERNAL always 3
  LIMIT always 4
  INSTANTIATION always 5
Line 37
  = always 3
  INTERNAL always 3
Line 47
  normal always 0
  inconclusive always 1
  safe always 2
  experimental always 3
Line 54
  unusedFunction always 0
  missingInclude always 1
  internalCheck always 2
Line 68
  none always 0
Line 74
  error always 1
Line 80
  warning always 2
Line 87
  style always 3
Line 93
  performance always 4
Line 101
  portability always 5
Line 108
  information always 6
Line 113
  debug always 7
Line 121
  ( possible lifetime[SubObject]=(cweId)
  cweId always !<=-1
  id always !<=-1
  cweId always !<=-1
Line 122
  id always !<=-1
Line 42
  hash always !<=-1
Line 56
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 58
  this always !0
Line 60
  = always -1
  NO_LINE always -1
  hash always !<=-1
  0 always 0
  thisAndNextLine always {!<=-1,!>=2}
  false always 0
  matched always {!<=-1,!>=2}
  false always 0
  checked always {!<=-1,!>=2}
  false always 0
Line 67
  hash always !<=-1
  = always !<=-1
  . always !<=-1
  hash always !<=-1
Line 68
  thisAndNextLine always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 69
  matched always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 70
  checked always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 71
  this always !0
Line 74
  ( always {!<=-1,!>=2}
Line 75
  != always {!<=-1,!>=2}
Line 76
  return always {!<=-1,!>=2}
  errorId always !symbolic=(other.errorId)
  < always {!<=-1,!>=2}
  . always !symbolic=(errorId)
Line 77
  < always {!<=-1,!>=2}
Line 78
  return always {!<=-1,!>=2}
  true always 1
Line 79
  != always {!<=-1,!>=2}
Line 80
  return always {!<=-1,!>=2}
  fileName always !symbolic=(other.fileName)
  < always {!<=-1,!>=2}
  . always !symbolic=(fileName)
Line 81
  != always {!<=-1,!>=2}
Line 82
  return always {!<=-1,!>=2}
  symbolName always !symbolic=(other.symbolName)
  < always {!<=-1,!>=2}
  . always !symbolic=(symbolName)
Line 83
  hash always !<=-1
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 84
  return always {!<=-1,!>=2}
  hash always {!<=-1,!symbolic=(other.hash)}
  < always {!<=-1,!>=2}
  . always {!<=-1,!symbolic=(hash)}
  hash always !<=-1
Line 85
  thisAndNextLine always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 86
  return always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2,!symbolic=(other.thisAndNextLine)}
Line 87
  return always {!<=-1,!>=2}
  false always 0
Line 96
  ( always {!<=-1,!>=2}
Line 98
  ( always {!<=-1,!>=2}
Line 100
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  fileName always !size=0
  ( always !<=-1
  "?*" always "?*"
  == always {!<=-1,!>=2}
Line 108
  ( always {!<=-1,!>=2}
Line 109
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 110
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 111
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 112
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 113
  hash always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  && always {!<=-1,!>=2}
Line 114
  thisAndNextLine always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
Line 121
  hash always !<=-1
Line 122
  thisAndNextLine always {!<=-1,!>=2}
Line 123
  matched always {!<=-1,!>=2}
Line 124
  checked always {!<=-1,!>=2}
Line 126
  NO_LINE always -1
  = always -1
  -1 always -1
Line 178
  ( always {!<=-1,!>=2}
Line 185
  ( always {!<=-1,!>=2}
Line 28
  Reset always 0
  = always 0
  0 always 0
  , always 1
Line 29
  Bold always 1
  = always 1
  1 always 1
  , always 2
Line 30
  Dim always 2
  = always 2
  2 always 2
  , always 31
Line 31
  FgRed always 31
  = always 31
  31 always 31
  , always 32
Line 32
  FgGreen always 32
  = always 32
  32 always 32
  , always 34
Line 33
  FgBlue always 34
  = always 34
  34 always 34
  , always 35
Line 34
  FgMagenta always 35
  = always 35
  35 always 35
  , always 39
Line 35
  FgDefault always 39
  = always 39
  39 always 39
  , always 41
Line 36
  BgRed always 41
  = always 41
  41 always 41
  , always 42
Line 37
  BgGreen always 42
  = always 42
  42 always 42
  , always 44
Line 38
  BgBlue always 44
  = always 44
  44 always 44
  , always 49
Line 39
  BgDefault always 49
  = always 49
  49 always 49
Line 40
  457U always 457
Line 41
  476U always 476
Line 42
  676U always 676
Line 43
  682U always 682
Line 44
  825U always 825
Line 70
  fileIndex always !<=-1
  0 always 0
  0 always 0
  column always !<=-1
  0 always 0
Line 72
  column always !<=-1
Line 73
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 75
  column always !<=-1
Line 76
  fileIndex always !<=-1
  0 always 0
  column always !<=-1
  column always !<=-1
Line 86
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 93
  convert always {!<=-1,!>=2}
  = always 1
  true always 1
Line 106
  fileIndex always !<=-1
Line 108
  column always !<=-1
Line 175
  verbose always {!<=-1,!>=2}
Line 180
  ( always {!<=-1,!>=2}
Line 190
  incomplete always {!<=-1,!>=2}
Line 197
  hash always !<=-1
Line 243
  ( always " </array>\r\n</dict>\r\n</plist>"
Line 254
  = always 0
  :: always 0
  Reset always 0
  = always 0
  0 always 0
Line 262
  = always 0
  0 always 0
Line 270
  , always !<=-1
  value always !<=-1
Line 273
  ( always !<=-1
  value always !<=-1
Line 289
  ( always {!<=-1,!>=2}
Line 303
  " </array>\r\n</dict>\r\n</plist>" always " </array>\r\n</dict>\r\n</plist>"
Line 43
  INT always 0
  LONG always 1
  LONGLONG always 2
  FLOAT always 3
Line 44
  mIsUnsigned always {!<=-1,!>=2}
Line 51
  ( always {!<=-1,!>=2}
Line 52
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 54
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  FLOAT always 3
Line 59
  ( always {!<=-1,!>=2}
Line 74
  ( always !<=-1
Line 78
  value possible >=1@13
Line 83
  ( always {!<=-1,!>=2}
Line 84
  ( always {!<=-1,!>=2}
Line 85
  ( always {!<=-1,!>=2}
Line 86
  ( always {!<=-1,!>=2}
Line 87
  ( always {!<=-1,!>=2}
Line 88
  ( always {!<=-1,!>=2}
Line 89
  ( always {!<=-1,!>=2}
Line 90
  ( always {!<=-1,!>=2}
Line 91
  ( always {!<=-1,!>=2}
Line 92
  ( always {!<=-1,!>=2}
Line 102
  ( always {!<=-1,!>=2}
  , always 1
  supportMicrosoftExtensions always {!<=-1,!>=2}
  = always 1
  true always 1
Line 115
  ( always !<=-1
Line 116
  ( always {!<=-1,!>=2}
Line 117
  ( always {!<=-1,!>=2}
Line 118
  ( always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 120
  ( always {!<=-1,!>=2}
Line 121
  ( always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
Line 128
  ( always {!<=-1,!>=2}
Line 130
  ( always !<=-1
Line 137
  ( always {!<=-1,!>=2}
  , always !<=-1
  :: always !<=-1
  iPos always !<=-1
Line 77
  ( always {!<=-1,!>=2}
Line 111
  ( always {!<=-1,!>=2}
Line 134
  ( always {!<=-1,!>=2}
Line 136
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  extra always size=0
Line 146
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 160
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 181
  ( always {!<=-1,!>=2}
Line 47
  ( always {!<=-1,!>=2}
Line 49
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 53
  ( always {!<=-1,!>=2}
Line 55
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 59
  ( always {!<=-1,!>=2}
Line 61
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 67
  ( always !<=-1
Line 69
  return always !<=-1
  ( always !<=-1
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return always {!<=-1,!>=2}
  ! {!<=-1,!>=2,0}
  str possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  str always !size=0
  == always {!<=-1,!>=2}
  c possible {39@14778,34@15034}
Line 78
  ( always {!<=-1,!>=2}
  , always !<=-1
  endlen always !<=-1
Line 80
  return always {!<=-1,!>=2}
  ( always !<=-1
  >= always {!<=-1,!>=2}
  endlen always !<=-1
  && always {!<=-1,!>=2}
  ( {!<=-1,>=symbolic=(endlen),!<=symbolic=(endlen-1)}
  - always !<=-1
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  endlen {!<=-1,<=symbolic=(str.size()),!>=symbolic=(str.size()+1)}
  == always {!<=-1,!>=2}
  0 always 0
Line 84
  ( always {!<=-1,!>=2}
  ( always !0
  & always !0
Line 86
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 89
  ( always {!<=-1,!>=2}
Line 91
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  q possible {39@57,34@58}
Line 92
  return always {!<=-1,!>=2}
  false always 0
Line 93
  ( always !<=-1
  + always !<=0
  1 always 1
  > always {!<=-1,!>=2}
  p possible {""@57,""@58,""@59,"U"@60,"U"@61,"u"@62,"u"@63,"u8"@64,"u8"@65}
  ( always !<=-1
  && always {!<=-1,!>=2}
  0 always 0
  ( always !<=-1
  + always !<=0
  1 always 1
  == always {!<=-1,!>=2}
  0 always 0
Line 94
  return always {!<=-1,!>=2}
  true always 1
Line 95
  return always {!<=-1,!>=2}
  false always 0
Line 98
  ( always {!<=-1,!>=2}
Line 100
  "" always ""
  "u8" always "u8"
  "u" always "u"
  "U" always "U"
  "L" always "L"
Line 102
  ( always {!<=-1,!>=2}
  q possible {39@183,34@184}
Line 103
  return always {!<=-1,!>=2}
  true always 1
Line 105
  return always {!<=-1,!>=2}
  false always 0
Line 108
  ( always {!<=-1,!>=2}
Line 110
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
Line 113
  ( always {!<=-1,!>=2}
Line 115
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
Line 120
  quotePos always !<=-1
  = always !<=-1
  ( always !<=-1
  q possible {39@180,34@182}
Line 121
  quotePos {symbolic=(str.find(q)),!<=-1}
  + always !<=0
  1U always 1
  ( always !<=-1
  - always !<=-1
  quotePos {symbolic=(str.find(q)),!<=-1}
  - always !<=-1
  2U always 2
Line 126
  ( always {!<=-1,!>=2}
Line 127
  '"' always 34
Line 128
  "" always ""
Line 133
  ( always {!<=-1,!>=2}
Line 134
  '\'' always 39
Line 135
  "" always ""
Line 140
  i possible {2,3}
  == {!<=-1,!>=2,0}
  1 always 1
Line 141
  "st" always "st"
Line 142
  i {3,!1}
  == {!<=-1,!>=2,0}
  2 always 2
Line 143
  "nd" always "nd"
Line 144
  i always {!1,!2}
  == always {!<=-1,!>=2}
  3 always 3
Line 145
  "rd" always "rd"
Line 146
  "th" always "th"
Line 151
  ( always {!<=-1,!>=2}
Line 153
  ( always {!<=-1,!>=2}
Line 155
  ( always {!<=-1,!>=2}
Line 66
  ( always {!<=-1,!>=2}
Line 67
  return always {!<=-1,!>=2}
  < always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 74
  return always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  1 always 1
Line 80
  result always {!<=-1,!>=2}
Line 81
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  x {!>=symbolic=(y+1),<=symbolic=(y)}
  < always {!<=-1,!>=2}
  y {!<=symbolic=(x-1),>=symbolic=(x)}
Line 88
  Upper always 0
  Lower always 1
  Point always 2
Line 90
  = always 0
  0 always 0
Line 94
  nullptr always 0
Line 95
  0.0 always 0
Line 98
  nullptr always 0
Line 99
  0U always 0
Line 100
  safe always {!<=-1,!>=2}
  false always 0
Line 101
  conditional always {!<=-1,!>=2}
  false always 0
Line 102
  macro always {!<=-1,!>=2}
  false always 0
Line 103
  defaultArg always {!<=-1,!>=2}
  false always 0
Line 104
  0 always 0
Line 105
  0 always 0
Line 108
  nullptr always 0
Line 117
  ( always {!<=-1,!>=2}
Line 118
  != always {!<=-1,!>=2}
Line 119
  return always {!<=-1,!>=2}
  false always 0
Line 120
  valueType always symbolic=(rhs.valueType)
Line 122
  :: always 5
  CONTAINER_SIZE always 5
Line 123
  :: always 7
  BUFFER_SIZE always 7
Line 124
  :: always 8
  ITERATOR_START always 8
Line 125
  :: always 9
  ITERATOR_END always 9
Line 126
  != always {!<=-1,!>=2}
Line 127
  return always {!<=-1,!>=2}
  false always 0
Line 129
  :: always 1
  TOK always 1
Line 130
  != always {!<=-1,!>=2}
Line 131
  return always {!<=-1,!>=2}
  false always 0
Line 133
  :: always 2
  FLOAT always 2
Line 135
  > always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  floatValue possible <=symbolic=(rhs.floatValue)
  < always {!<=-1,!>=2}
  . possible >=symbolic=(floatValue)
Line 136
  return always {!<=-1,!>=2}
  false always 0
Line 138
  :: always 3
  MOVED always 3
Line 139
  != always {!<=-1,!>=2}
Line 140
  return always {!<=-1,!>=2}
  false always 0
Line 142
  :: always 4
  UNINIT always 4
Line 144
  :: always 6
  LIFETIME always 6
Line 145
  != always {!<=-1,!>=2}
Line 146
  return always {!<=-1,!>=2}
  false always 0
Line 148
  :: always 10
  SYMBOLIC always 10
Line 149
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 150
  return always {!<=-1,!>=2}
  false always 0
Line 151
  != always {!<=-1,!>=2}
Line 152
  return always {!<=-1,!>=2}
  false always 0
Line 155
  return always {!<=-1,!>=2}
  true always 1
Line 162
  :: always 10
  SYMBOLIC always 10
Line 163
  :: always 7
  BUFFER_SIZE always 7
Line 164
  :: always 5
  CONTAINER_SIZE always 5
Line 165
  :: always 8
  ITERATOR_START always 8
Line 166
  :: always 9
  ITERATOR_END always 9
Line 170
  :: always 2
  FLOAT always 2
Line 174
  :: always 4
  UNINIT always 4
Line 175
  :: always 1
  TOK always 1
Line 176
  :: always 6
  LIFETIME always 6
Line 177
  :: always 3
  MOVED always 3
Line 185
  result always {!<=-1,!>=2}
Line 186
  result always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
Line 190
  result always {!<=-1,!>=2}
Line 192
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always {!<=-1,!>=2}
  ( possible lifetime[Object]=(compare)
Line 197
  ( always {!<=-1,!>=2}
Line 198
  ! always {!<=-1,!>=2}
  this always !0
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 199
  this always !0
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  this always !0
Line 200
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 202
  this always !0
Line 203
  ( possible {lifetime[Object]=(result),lifetime[Object]=(rhs),lifetime[Object]=(compare)}
  ( possible lifetime[Object]=(result)
  result always 0
  ( possible lifetime[Object]=(rhs)
  ( possible lifetime[Object]=(compare)
Line 204
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 207
  ( always {!<=-1,!>=2}
Line 208
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 209
  return always {!<=-1,!>=2}
  false always 0
Line 211
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 212
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 213
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 214
  conditional always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  conditional always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 215
  defaultArg always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 216
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 217
  == always {!<=-1,!>=2}
Line 220
  ( always {!<=-1,!>=2}
Line 221
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  this always !0
  == always {!<=-1,!>=2}
Line 225
  ( always {!<=-1,!>=2}
Line 226
  result always {!<=-1,!>=2}
  result always {!<=-1,!>=2}
  = always 0
  false always 0
Line 227
  this always !0
  ( possible {lifetime[Object]=(x),lifetime[Object]=(result)}
  ( possible lifetime[Object]=(result)
  result always 0
Line 228
  return always {!<=-1,!>=2}
  result {!<=-1,!>=2,0}
Line 232
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 233
  this always !0
Line 234
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 235
  this always !0
Line 239
  bound possible 0
  == {!<=-1,!>=2,0}
  :: always 1
  Lower always 1
Line 240
  = always 0
  :: always 0
  Upper always 0
Line 241
  bound always !1
  == always {!<=-1,!>=2}
  :: always 0
  Upper always 0
Line 242
  = always 1
  :: always 1
  Lower always 1
Line 255
  INT always 0
Line 256
  TOK always 1
Line 257
  FLOAT always 2
Line 258
  MOVED always 3
Line 259
  UNINIT always 4
Line 260
  CONTAINER_SIZE always 5
Line 261
  LIFETIME always 6
Line 262
  BUFFER_SIZE always 7
Line 263
  ITERATOR_START always 8
Line 264
  ITERATOR_END always 9
Line 265
  SYMBOLIC always 10
Line 267
  ( always {!<=-1,!>=2}
Line 268
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 270
  ( always {!<=-1,!>=2}
Line 271
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  TOK always 1
Line 273
  ( always {!<=-1,!>=2}
Line 274
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  FLOAT always 2
Line 276
  ( always {!<=-1,!>=2}
Line 277
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  MOVED always 3
Line 279
  ( always {!<=-1,!>=2}
Line 280
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 4
  UNINIT always 4
Line 282
  ( always {!<=-1,!>=2}
Line 283
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 5
  CONTAINER_SIZE always 5
Line 285
  ( always {!<=-1,!>=2}
Line 286
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
Line 288
  ( always {!<=-1,!>=2}
Line 289
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 7
  BUFFER_SIZE always 7
Line 291
  ( always {!<=-1,!>=2}
Line 292
  return always {!<=-1,!>=2}
  valueType possible 9
  == {!<=-1,!>=2,0}
  :: always 8
  ITERATOR_START always 8
  || always {!<=-1,!>=2}
  valueType always !8
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 294
  ( always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 8
  ITERATOR_START always 8
Line 297
  ( always {!<=-1,!>=2}
Line 298
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 9
  ITERATOR_END always 9
Line 300
  ( always {!<=-1,!>=2}
Line 301
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 10
  SYMBOLIC always 10
Line 304
  ( always {!<=-1,!>=2}
Line 305
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 308
  ( always {!<=-1,!>=2}
Line 309
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Argument always 1
Line 312
  ( always {!<=-1,!>=2}
Line 313
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 6
  LIFETIME always 6
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  SubFunction always 2
Line 316
  ( always {!<=-1,!>=2}
Line 317
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 333
  NonMovedVariable always 0
  MovedVariable always 1
  ForwardedVariable always 2
Line 347
  safe always {!<=-1,!>=2}
Line 350
  conditional always {!<=-1,!>=2}
Line 353
  macro always {!<=-1,!>=2}
Line 356
  defaultArg always {!<=-1,!>=2}
Line 373
  Object always 0
Line 375
  SubObject always 1
Line 377
  Lambda always 2
Line 379
  Iterator always 3
Line 381
  Address always 4
Line 384
  Local always 0
  Argument always 1
  SubFunction always 2
  ThisPointer always 3
  ThisValue always 4
Line 394
  Possible always 0
Line 396
  Known always 1
Line 398
  Inconclusive always 2
Line 400
  Impossible always 3
Line 404
  = always 1
  :: always 1
  Known always 1
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 1
  Known always 1
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 419
  ( always {!<=-1,!>=2}
Line 420
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 3
  Impossible always 3
Line 424
  = always 3
  :: always 3
  Impossible always 3
Line 427
  inconclusive always {!<=-1,!>=2}
  = always 1
  true always 1
Line 428
  inconclusive always {!<=-1,!>=2}
Line 429
  = always 2
  :: always 2
  Inconclusive always 2
Line 432
  ( always {!<=-1,!>=2}
Line 433
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  :: always 2
  Inconclusive always 2
Line 437
  ( always {!<=-1,!>=2}
Line 441
  ( always {!<=-1,!>=2}
Line 442
  return always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  defaultArg always {!<=-1,!>=2}
Line 445
  ( always {!<=-1,!>=2}
Line 456
  ( always !<=-1
Line 460
  ( always {!<=-1,!>=2}
Line 462
  possible always {!<=-1,!>=2}
  = always 1
  true always 1
Line 467
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
  , always 20
  = always 20
  20 always 20
Line 471
  addressOf always {!<=-1,!>=2}
Line 473
  inconclusive always {!<=-1,!>=2}
Line 475
  nullptr always 0
  addressOf always {!<=-1,!>=2}
  false always 0
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 478
  addressOf always {!<=-1,!>=2}
  false always 0
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 481
  addressOf always {!<=-1,!>=2}
Line 482
  addressOf always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  ( possible lifetime[Object]=(errorPath)
  inconclusive always {!<=-1,!>=2}
  false always 0
Line 485
  b always {!<=-1,!>=2}
Line 487
  . always {!<=-1,!>=2}
  addressOf always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 491
  b always {!<=-1,!>=2}
Line 493
  . always {!<=-1,!>=2}
  inconclusive always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  b always {!<=-1,!>=2}
Line 511
  escape always {!<=-1,!>=2}
  = always 0
  false always 0
Line 514
  ( always {!<=-1,!>=2}
Line 516
  , always 0
  = always 0
  nullptr always 0
Line 520
  ( always {!<=-1,!>=2}
Line 526
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 529
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 530
  = always 0
  0 always 0
Line 532
  , always 0
  = always 0
  nullptr always 0
  , always 1
  smallest always {!<=-1,!>=2}
  = always 1
  true always 1
Line 62
  ( always !<=-1
Line 74
  mFlags always !<=-1
Line 77
  fIsClass always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 78
  fIsFunction always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 79
  fIsVariable always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 80
  fIsAlias always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 81
  fIsSpecialization always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 82
  fIsPartialSpecialization always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 83
  fIsForwardDeclaration always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 84
  fIsVariadic always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 85
  fIsFriend always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 7
Line 86
  fFamilyMask always 7
  = always 7
  fIsClass always 1
  | always 3
  fIsFunction always 2
  | always 7
  fIsVariable always 4
Line 89
  state always {!<=-1,!>=2}
Line 90
  fIsClass always 1
  state always {!<=-1,!>=2}
Line 92
  state always {!<=-1,!>=2}
Line 93
  fIsFunction always 2
  state always {!<=-1,!>=2}
Line 95
  state always {!<=-1,!>=2}
Line 96
  fIsVariable always 4
  state always {!<=-1,!>=2}
Line 98
  state always {!<=-1,!>=2}
Line 99
  fIsAlias always 8
  state always {!<=-1,!>=2}
Line 101
  state always {!<=-1,!>=2}
Line 102
  fIsSpecialization always 16
  state always {!<=-1,!>=2}
Line 104
  state always {!<=-1,!>=2}
Line 105
  fIsPartialSpecialization always 32
  state always {!<=-1,!>=2}
Line 107
  state always {!<=-1,!>=2}
Line 108
  fIsForwardDeclaration always 64
  state always {!<=-1,!>=2}
Line 110
  state always {!<=-1,!>=2}
Line 111
  fIsVariadic always 128
  state always {!<=-1,!>=2}
Line 113
  state always {!<=-1,!>=2}
Line 114
  fIsFriend always 256
  state always {!<=-1,!>=2}
Line 122
  ( always {!<=-1,!>=2}
  flag always !<=-1
Line 123
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag {!<=-1,256@147,128@148,64@149,32@150,16@151,8@152,4@153,2@154,1@155}
  != always {!<=-1,!>=2}
  0 always 0
Line 131
  flag always !<=-1
  state always {!<=-1,!>=2}
Line 132
  mFlags always !<=-1
  = always !<=-1
  state always {!<=-1,!>=2}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag {!<=-1,256@156,128@157,64@158,32@159,16@160,8@161,4@162,2@163,1@164}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ {!<=0,4294967039@156,4294967167@157,4294967231@158,4294967263@159,4294967279@160,4294967287@161,4294967291@162,4294967293@163,4294967294@164}
  flag {!<=-1,256@156,128@157,64@158,32@159,16@160,8@161,4@162,2@163,1@164}
Line 153
  ( always {!<=-1,!>=2}
Line 154
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 155
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  . always !<=-1
  mFlags always !<=-1
Line 183
  ( always {!<=-1,!>=2}
Line 184
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsClass always 1
Line 186
  ( always {!<=-1,!>=2}
Line 187
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFunction always 2
Line 189
  ( always {!<=-1,!>=2}
Line 190
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariable always 4
Line 192
  ( always {!<=-1,!>=2}
Line 193
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAlias always 8
Line 195
  ( always {!<=-1,!>=2}
Line 196
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSpecialization always 16
Line 198
  ( always {!<=-1,!>=2}
Line 199
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPartialSpecialization always 32
Line 201
  ( always {!<=-1,!>=2}
Line 202
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsForwardDeclaration always 64
Line 204
  ( always {!<=-1,!>=2}
Line 205
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsVariadic always 128
Line 207
  ( always {!<=-1,!>=2}
Line 208
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsFriend always 256
Line 234
  ( always {!<=-1,!>=2}
Line 242
  ( always {!<=-1,!>=2}
Line 245
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  & always !<=-1
  . always !<=-1
  mFlags always !<=-1
  & always !<=-1
  fFamilyMask always 7
  != always {!<=-1,!>=2}
  0 always 0
Line 265
  ( always {!<=-1,!>=2}
  , always !<=-1
  numberOfArguments always !<=-1
  , always {!<=-1,!>=2}
  variadic always {!<=-1,!>=2}
Line 281
  ( always {!<=-1,!>=2}
Line 289
  ( always {!<=-1,!>=2}
Line 297
  ( always {!<=-1,!>=2}
Line 306
  codeWithTemplates always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 322
  ( always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
  , always 1
  isTemplate always {!<=-1,!>=2}
  = always 1
  true always 1
Line 335
  ( always {!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 410
  ( always {!<=-1,!>=2}
Line 424
  , always {!<=-1,!>=2}
Line 425
  copy always {!<=-1,!>=2}
Line 451
  ( always {!<=-1,!>=2}
Line 456
  ( always {!<=-1,!>=2}
Line 486
  , always "    "
Line 487
  = always "    "
  "    " always "    "
Line 488
  = always ""
  "" always ""
Line 494
  mChanged always {!<=-1,!>=2}
Line 118
  LOW always 0
  HIGH always 1
Line 125
  UNKNOWN always 0
  CPP11INIT always 1
  NOINIT always 2
Line 128
  mBits always !<=-1
Line 131
  ( always {!<=-1,!>=2}
Line 134
  0 always 0
Line 135
  0 always 0
Line 136
  0 always 0
Line 137
  0 always 0
Line 138
  0 always 0
Line 139
  nullptr always 0
Line 140
  nullptr always 0
Line 141
  nullptr always 0
Line 142
  nullptr always 0
Line 143
  nullptr always 0
Line 144
  0 always 0
Line 145
  0 always 0
Line 146
  nullptr always 0
Line 147
  nullptr always 0
Line 148
  nullptr always 0
Line 149
  nullptr always 0
Line 150
  nullptr always 0
Line 151
  nullptr always 0
Line 153
  mBits always !<=-1
  0 always 0
Line 182
  eVariable always 0
  eType always 1
  eFunction always 2
  eKeyword always 3
  eName always 4
Line 183
  eNumber always 5
  eString always 6
  eChar always 7
  eBoolean always 8
  eLiteral always 9
  eEnumerator always 10
Line 184
  eArithmeticalOp always 11
  eComparisonOp always 12
  eAssignmentOp always 13
  eLogicalOp always 14
  eBitOp always 15
  eIncDecOp always 16
  eExtendedOp always 17
Line 185
  eBracket always 18
Line 186
  eLambda always 19
Line 187
  eEllipsis always 20
Line 188
  eOther always 21
Line 189
  eNone always 22
Line 192
  = always 0
  nullptr always 0
Line 198
  && always {!<=-1,!>=2}
Line 200
  = always 0
  0 always 0
Line 218
  = always 1
  1 always 1
Line 223
  = always 1
  1 always 1
Line 237
  ( always !0
  this always !0
Line 246
  ( always !0
  this always !0
Line 275
  ( always {!<=-1,!>=2}
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 276
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  1 always 1
Line 279
  ( always {!<=-1,!>=2}
  , always !<=-1
  pattern_len always !<=-1
Line 324
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  0 always 0
Line 370
  = always !0
  this always !0
Line 371
  top possible {symbolic=(this),0}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  top {symbolic=(this),!0}
  ",|(" always ",|("
Line 372
  top always !0
Line 373
  top possible {symbolic=(this),0}
  ? possible 0
  top always !0
  : always 0
  nullptr always 0
Line 380
  = possible {10@46,4@47,0@48}
  t possible {10@46,4@47,0@48}
Line 382
  memoizedIsName always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  mTokType possible {10@46,4@47,0@48}
  == always {!<=-1,!>=2}
  eName always 4
  || always {!<=-1,!>=2}
  mTokType {!4,10@46,0@48}
  == always {!<=-1,!>=2}
  eType always 1
  || always {!<=-1,!>=2}
  mTokType {!4,!1,10@46,0@48}
  == always {!<=-1,!>=2}
  eVariable always 0
  || always {!<=-1,!>=2}
Line 383
  mTokType {!1,!0,10@46}
  == always {!<=-1,!>=2}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType {!0,!2,10@46}
  == always {!<=-1,!>=2}
  eKeyword always 3
  || always {!<=-1,!>=2}
  mTokType {!2,!3,10@46}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
Line 384
  mTokType {!3,!8,10@46}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 385
  fIsName always 2097152
  memoizedIsName {symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator),!<=-1,!>=2,1@46}
Line 387
  memoizedIsLiteral always {!<=-1,!>=2}
  = always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
  || always {!<=-1,!>=2}
  mTokType always !5
  == always {!<=-1,!>=2}
  eString always 6
  || always {!<=-1,!>=2}
  mTokType always {!5,!6}
  == always {!<=-1,!>=2}
  eChar always 7
  || always {!<=-1,!>=2}
Line 388
  mTokType always {!6,!7}
  == always {!<=-1,!>=2}
  eBoolean always 8
  || always {!<=-1,!>=2}
  mTokType always {!7,!8}
  == always {!<=-1,!>=2}
  eLiteral always 9
  || always {!<=-1,!>=2}
  mTokType always {!8,!9}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 389
  fIsLiteral always 4194304
  memoizedIsLiteral {symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator),!<=-1,!>=2}
Line 391
  ( always {!<=-1,!>=2}
Line 392
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eKeyword always 3
Line 394
  ( always {!<=-1,!>=2}
Line 395
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsName always 2097152
Line 397
  ( always {!<=-1,!>=2}
Line 398
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  == always {!<=-1,!>=2}
  fIsName always 2097152
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eName always 4
Line 400
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 402
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLiteral always 4194304
Line 404
  ( always {!<=-1,!>=2}
Line 405
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eNumber always 5
Line 407
  ( always {!<=-1,!>=2}
Line 408
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 410
  ( always {!<=-1,!>=2}
Line 411
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 412
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 413
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 415
  ( always {!<=-1,!>=2}
Line 416
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 417
  == always {!<=-1,!>=2}
  eLogicalOp always 14
  || always {!<=-1,!>=2}
Line 418
  mTokType always !14
  == always {!<=-1,!>=2}
  eComparisonOp always 12
  || always {!<=-1,!>=2}
Line 419
  mTokType always {!14,!12}
  == always {!<=-1,!>=2}
  eBitOp always 15
Line 421
  ( always {!<=-1,!>=2}
Line 422
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
Line 423
  == always {!<=-1,!>=2}
  eExtendedOp always 17
Line 425
  ( always {!<=-1,!>=2}
Line 426
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eArithmeticalOp always 11
Line 428
  ( always {!<=-1,!>=2}
Line 429
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eComparisonOp always 12
Line 431
  ( always {!<=-1,!>=2}
Line 432
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eAssignmentOp always 13
Line 434
  ( always {!<=-1,!>=2}
Line 435
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eBoolean always 8
Line 437
  ( always {!<=-1,!>=2}
Line 438
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eIncDecOp always 16
Line 440
  ( always {!<=-1,!>=2}
Line 441
  return always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
Line 443
  ( always {!<=-1,!>=2}
Line 444
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  nullptr always 0
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  nullptr always 0
Line 446
  ( always {!<=-1,!>=2}
Line 448
  ( always !<=-1
Line 449
  return always !<=-1
  mFlags always !<=-1
Line 451
  flags_ always !<=-1
Line 452
  mFlags always !<=-1
  = always !<=-1
  flags_ always !<=-1
Line 454
  ( always {!<=-1,!>=2}
Line 455
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsUnsigned always 1
Line 457
  sign always {!<=-1,!>=2}
Line 458
  fIsUnsigned always 1
  sign always {!<=-1,!>=2}
Line 460
  ( always {!<=-1,!>=2}
Line 461
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSigned always 2
Line 463
  sign always {!<=-1,!>=2}
Line 464
  fIsSigned always 2
  sign always {!<=-1,!>=2}
Line 466
  ( always {!<=-1,!>=2}
Line 467
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsPointerCompare always 4
Line 469
  b always {!<=-1,!>=2}
Line 470
  fIsPointerCompare always 4
  b always {!<=-1,!>=2}
Line 472
  ( always {!<=-1,!>=2}
Line 473
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsLong always 8
Line 475
  size always {!<=-1,!>=2}
Line 476
  fIsLong always 8
  size always {!<=-1,!>=2}
Line 478
  ( always {!<=-1,!>=2}
Line 479
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsStandardType always 16
Line 481
  b always {!<=-1,!>=2}
Line 482
  fIsStandardType always 16
  b {!<=-1,!>=2,0@54}
Line 484
  ( always {!<=-1,!>=2}
Line 485
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsExpandedMacro always 32
Line 487
  m always {!<=-1,!>=2}
Line 488
  fIsExpandedMacro always 32
  m always {!<=-1,!>=2}
Line 490
  ( always {!<=-1,!>=2}
Line 491
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsCast always 64
Line 493
  c always {!<=-1,!>=2}
Line 494
  fIsCast always 64
  c always {!<=-1,!>=2}
Line 496
  ( always {!<=-1,!>=2}
Line 497
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConstructor always 128
Line 499
  ac always {!<=-1,!>=2}
Line 500
  fIsAttributeConstructor always 128
  ac always {!<=-1,!>=2}
Line 502
  ( always {!<=-1,!>=2}
Line 503
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeDestructor always 256
Line 505
  value always {!<=-1,!>=2}
Line 506
  fIsAttributeDestructor always 256
  value always {!<=-1,!>=2}
Line 508
  ( always {!<=-1,!>=2}
Line 509
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUnused always 512
Line 511
  unused always {!<=-1,!>=2}
Line 512
  fIsAttributeUnused always 512
  unused always {!<=-1,!>=2}
Line 514
  ( always {!<=-1,!>=2}
Line 515
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeUsed always 16384
Line 517
  unused always {!<=-1,!>=2}
Line 518
  fIsAttributeUsed always 16384
  unused always {!<=-1,!>=2}
Line 520
  ( always {!<=-1,!>=2}
Line 521
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePure always 1024
Line 523
  value always {!<=-1,!>=2}
Line 524
  fIsAttributePure always 1024
  value always {!<=-1,!>=2}
Line 526
  ( always {!<=-1,!>=2}
Line 527
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeConst always 2048
Line 529
  value always {!<=-1,!>=2}
Line 530
  fIsAttributeConst always 2048
  value always {!<=-1,!>=2}
Line 532
  ( always {!<=-1,!>=2}
Line 533
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNoreturn always 4096
Line 535
  value always {!<=-1,!>=2}
Line 536
  fIsAttributeNoreturn always 4096
  value always {!<=-1,!>=2}
Line 538
  ( always {!<=-1,!>=2}
Line 539
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNothrow always 8192
Line 541
  value always {!<=-1,!>=2}
Line 542
  fIsAttributeNothrow always 8192
  value always {!<=-1,!>=2}
Line 544
  ( always {!<=-1,!>=2}
Line 545
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributePacked always 32768
Line 547
  value always {!<=-1,!>=2}
Line 548
  fIsAttributePacked always 32768
  value always {!<=-1,!>=2}
Line 550
  ( always {!<=-1,!>=2}
Line 551
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeNodiscard always 16777216
Line 553
  value always {!<=-1,!>=2}
Line 554
  fIsAttributeNodiscard always 16777216
  value always {!<=-1,!>=2}
Line 556
  ( always {!<=-1,!>=2}
Line 557
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsAttributeMaybeUnused always 65536
Line 559
  value always {!<=-1,!>=2}
Line 560
  fIsAttributeMaybeUnused always 65536
  value always {!<=-1,!>=2}
Line 565
  ( always {!<=-1,!>=2}
Line 566
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 568
  ( always {!<=-1,!>=2}
Line 569
  return always {!<=-1,!>=2}
  nullptr always 0
  != always {!<=-1,!>=2}
Line 571
  ( always {!<=-1,!>=2}
Line 572
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsControlFlowKeyword always 131072
Line 574
  ( always {!<=-1,!>=2}
Line 575
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsOperatorKeyword always 262144
Line 577
  value always {!<=-1,!>=2}
Line 578
  fIsOperatorKeyword always 262144
  value always {!<=-1,!>=2}
Line 580
  ( always {!<=-1,!>=2}
Line 581
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsComplex always 524288
Line 583
  value always {!<=-1,!>=2}
Line 584
  fIsComplex always 524288
  value always {!<=-1,!>=2}
Line 586
  ( always {!<=-1,!>=2}
Line 587
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsEnumType always 1048576
Line 589
  value always {!<=-1,!>=2}
Line 590
  fIsEnumType always 1048576
  value always {!<=-1,!>=2}
Line 592
  ( always {!<=-1,!>=2}
Line 593
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fAtAddress always 33554432
Line 595
  b always {!<=-1,!>=2}
Line 596
  fAtAddress always 33554432
  b always {!<=-1,!>=2}
Line 598
  ( always {!<=-1,!>=2}
Line 599
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIncompleteVar always 67108864
Line 601
  b always {!<=-1,!>=2}
Line 602
  fIncompleteVar always 67108864
  b always {!<=-1,!>=2}
Line 605
  ( always {!<=-1,!>=2}
Line 606
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsIncompleteConstant always 68719476736
Line 608
  b always {!<=-1,!>=2}
Line 609
  fIsIncompleteConstant always 68719476736
  b always {!<=-1,!>=2}
Line 612
  ( always {!<=-1,!>=2}
Line 613
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fConstexpr always 134217728
Line 615
  b always {!<=-1,!>=2}
Line 616
  fConstexpr always 134217728
  b always {!<=-1,!>=2}
Line 619
  ( always {!<=-1,!>=2}
Line 620
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fExternC always 268435456
Line 622
  b always {!<=-1,!>=2}
Line 623
  fExternC always 268435456
  b always {!<=-1,!>=2}
Line 626
  ( always {!<=-1,!>=2}
Line 627
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclComma always 536870912
Line 629
  b always {!<=-1,!>=2}
Line 630
  fIsSplitVarDeclComma always 536870912
  b always {!<=-1,!>=2}
Line 633
  ( always {!<=-1,!>=2}
Line 634
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSplitVarDeclEq always 1073741824
Line 636
  b always {!<=-1,!>=2}
Line 637
  fIsSplitVarDeclEq always 1073741824
  b always {!<=-1,!>=2}
Line 640
  ( always {!<=-1,!>=2}
Line 641
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsImplicitInt always 2147483648
Line 643
  b always {!<=-1,!>=2}
Line 644
  fIsImplicitInt always 2147483648
  b always {!<=-1,!>=2}
Line 647
  ( always {!<=-1,!>=2}
Line 648
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsInline always 4294967296
Line 650
  b always {!<=-1,!>=2}
Line 651
  fIsInline always 4294967296
  b always {!<=-1,!>=2}
Line 654
  ( always {!<=-1,!>=2}
Line 655
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsRemovedVoidParameter always 34359738368
Line 657
  b always {!<=-1,!>=2}
Line 658
  fIsRemovedVoidParameter always 34359738368
  b always {!<=-1,!>=2}
Line 661
  ( always {!<=-1,!>=2}
Line 662
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplate always 8589934592
Line 664
  b always {!<=-1,!>=2}
Line 665
  fIsTemplate always 8589934592
  b always {!<=-1,!>=2}
Line 668
  ( always {!<=-1,!>=2}
Line 669
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsSimplifedScope always 17179869184
Line 671
  b always {!<=-1,!>=2}
Line 672
  fIsSimplifedScope always 17179869184
  b always {!<=-1,!>=2}
Line 675
  ( always {!<=-1,!>=2}
Line 676
  return always {!<=-1,!>=2}
  . always !<=-1
  mBits always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 678
  ( always !<=-1
Line 679
  return always !<=-1
  . always !<=-1
  mBits always !<=-1
Line 685
  ! always {!<=-1,!>=2}
Line 687
  . possible lifetime[Object]=(tokenAndName)
Line 689
  b always !<=-1
Line 690
  . always !<=-1
  mBits always !<=-1
  = always !<=-1
  b always !<=-1
Line 693
  ( always {!<=-1,!>=2}
Line 694
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u8" always "u8"
  || always {!<=-1,!>=2}
Line 695
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u8" always "u8"
Line 698
  ( always {!<=-1,!>=2}
Line 699
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "u" always "u"
  || always {!<=-1,!>=2}
Line 700
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "u" always "u"
Line 703
  ( always {!<=-1,!>=2}
Line 704
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "U" always "U"
  || always {!<=-1,!>=2}
Line 705
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "U" always "U"
Line 708
  ( always {!<=-1,!>=2}
Line 709
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eString always 6
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '"' always 34
  "" always ""
  || always {!<=-1,!>=2}
Line 710
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
  ( always !<=-1
  == always {!<=-1,!>=2}
  3 always 3
Line 713
  ( always {!<=-1,!>=2}
Line 714
  return always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  eChar always 7
  && always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  '\'' always 39
  "" always ""
  && always {!<=-1,!>=2}
Line 715
  ( always !<=-1
  > always {!<=-1,!>=2}
  3 always 3
Line 734
  ( always {!<=-1,!>=2}
Line 735
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fIsTemplateArg always 8388608
Line 737
  value always {!<=-1,!>=2}
Line 738
  fIsTemplateArg always 8388608
  value always {!<=-1,!>=2}
Line 742
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 743
  1 always 1
Line 745
  , always !<=-1
  pattern_len always !<=-1
Line 748
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 749
  1 always 1
Line 751
  , always !<=-1
  pattern_len always !<=-1
Line 753
  , always 0
  = always 0
  0 always 0
Line 754
  , always 0
  = always 0
  0 always 0
Line 757
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 758
  1 always 1
Line 760
  , always !<=-1
  pattern_len always !<=-1
Line 761
  pattern_len always !<=-1
Line 764
  ( always !0
  & {lifetime[Address]=(pattern),!0}
Line 765
  1 always 1
Line 767
  , always !<=-1
  pattern_len always !<=-1
Line 768
  pattern_len always !<=-1
Line 771
  , always 0
  = always 0
  0 always 0
Line 772
  varId possible 0
Line 774
  , always 0
  = always 0
  0 always 0
Line 775
  varId possible 0
Line 837
  , always 0
  prepend always {!<=-1,!>=2}
  = always 0
  false always 0
Line 841
  true always 1
Line 853
  = possible 0
  id possible 0
Line 854
  != always {!<=-1,!>=2}
  0 always 0
Line 855
  eVariable always 0
Line 856
  false always 0
Line 864
  . always !0
Line 877
  = always 0
  nullptr always 0
Line 892
  = always 5
  5 always 5
Line 904
  varid always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 905
  exprid always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 906
  idtype always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 0
  false always 0
Line 907
  attributes always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 0
  false always 0
Line 908
  macro always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 0
  false always 0
Line 909
  linenumbers always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 0
  false always 0
Line 910
  linebreaks always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 0
  false always 0
Line 911
  files always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  false always 0
Line 914
  . always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 915
  . always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
  = always 1
  true always 1
Line 916
  . always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  = always 1
  true always 1
Line 917
  . always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  = always 1
  true always 1
Line 918
  . always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 1
  true always 1
Line 923
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 928
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 933
  . always {!<=-1,!>=2}
  exprid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 934
  . always {!<=-1,!>=2}
  varid always {!<=-1,!>=2}
  = always 1
  true always 1
Line 935
  . always {!<=-1,!>=2}
  idtype always {!<=-1,!>=2}
  = always 1
  true always 1
Line 948
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  macro always {!<=-1,!>=2}
Line 950
  , always 0
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 951
  , always 1
  attributes always {!<=-1,!>=2}
  = always 1
  true always 1
Line 952
  varid always {!<=-1,!>=2}
  = always 0
  false always 0
Line 965
  varid always {!<=-1,!>=2}
  attributes always {!<=-1,!>=2}
  linenumbers always {!<=-1,!>=2}
  linebreaks always {!<=-1,!>=2}
  files always {!<=-1,!>=2}
  = always 0
  nullptr always 0
  , always 0
  = always 0
  nullptr always 0
Line 984
  mStr possible size=1
  == always {!<=-1,!>=2}
  "<" always "<"
  || always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  ">" always ">"
Line 1026
  mTokType possible 19
  == {!<=-1,!>=2,0}
  eFunction always 2
  || always {!<=-1,!>=2}
  mTokType always !2
  == always {!<=-1,!>=2}
  eLambda always 19
  : always 0
  nullptr always 0
Line 1034
  = possible 0
  v possible 0
Line 1035
  || always {!<=-1,!>=2}
Line 1036
  eVariable always 0
Line 1037
  == always {!<=-1,!>=2}
  eVariable always 0
Line 1038
  eName always 4
Line 1045
  == always {!<=-1,!>=2}
  eVariable always 0
  ? possible 0
  : always 0
  nullptr always 0
Line 1058
  == always {!<=-1,!>=2}
  eType always 1
  ? possible 0
  : always 0
  nullptr always 0
Line 1061
  , always 0
  = always 0
  nullptr always 0
Line 1071
  == always {!<=-1,!>=2}
  eEnumerator always 10
  ? possible 0
  : always 0
  nullptr always 0
Line 1079
  = possible 0
  e possible 0
Line 1081
  eEnumerator always 10
Line 1082
  == always {!<=-1,!>=2}
  eEnumerator always 10
Line 1083
  eName always 4
Line 1152
  . always !0
Line 1156
  . always !0
Line 1163
  && always {!<=-1,!>=2}
Line 1164
  ! always {!<=-1,!>=2}
Line 1170
  ( always {!<=-1,!>=2}
Line 1171
  ( always {!<=-1,!>=2}
Line 1172
  ( always {!<=-1,!>=2}
Line 1173
  ( always {!<=-1,!>=2}
Line 1182
  condition always {!<=-1,!>=2}
  = always 0
  0 always 0
Line 1197
  ( always {!<=-1,!>=2}
Line 1199
  ( always {!<=-1,!>=2}
Line 1227
  ( always {!<=-1,!>=2}
Line 1243
  fIsUnsigned always 1
  = always 1
  1 always 1
  << always 1
  0 always 0
  , always 2
Line 1244
  fIsSigned always 2
  = always 2
  1 always 1
  << always 2
  1 always 1
  , always 4
Line 1245
  fIsPointerCompare always 4
  = always 4
  1 always 1
  << always 4
  2 always 2
  , always 8
Line 1246
  fIsLong always 8
  = always 8
  1 always 1
  << always 8
  3 always 3
  , always 16
Line 1247
  fIsStandardType always 16
  = always 16
  1 always 1
  << always 16
  4 always 4
  , always 32
Line 1248
  fIsExpandedMacro always 32
  = always 32
  1 always 1
  << always 32
  5 always 5
  , always 64
Line 1249
  fIsCast always 64
  = always 64
  1 always 1
  << always 64
  6 always 6
  , always 128
Line 1250
  fIsAttributeConstructor always 128
  = always 128
  1 always 1
  << always 128
  7 always 7
  , always 256
Line 1251
  fIsAttributeDestructor always 256
  = always 256
  1 always 1
  << always 256
  8 always 8
  , always 512
Line 1252
  fIsAttributeUnused always 512
  = always 512
  1 always 1
  << always 512
  9 always 9
  , always 1024
Line 1253
  fIsAttributePure always 1024
  = always 1024
  1 always 1
  << always 1024
  10 always 10
  , always 2048
Line 1254
  fIsAttributeConst always 2048
  = always 2048
  1 always 1
  << always 2048
  11 always 11
  , always 4096
Line 1255
  fIsAttributeNoreturn always 4096
  = always 4096
  1 always 1
  << always 4096
  12 always 12
  , always 8192
Line 1256
  fIsAttributeNothrow always 8192
  = always 8192
  1 always 1
  << always 8192
  13 always 13
  , always 16384
Line 1257
  fIsAttributeUsed always 16384
  = always 16384
  1 always 1
  << always 16384
  14 always 14
  , always 32768
Line 1258
  fIsAttributePacked always 32768
  = always 32768
  1 always 1
  << always 32768
  15 always 15
  , always 65536
Line 1259
  fIsAttributeMaybeUnused always 65536
  = always 65536
  1 always 1
  << always 65536
  16 always 16
  , always 131072
Line 1260
  fIsControlFlowKeyword always 131072
  = always 131072
  1 always 1
  << always 131072
  17 always 17
  , always 262144
Line 1261
  fIsOperatorKeyword always 262144
  = always 262144
  1 always 1
  << always 262144
  18 always 18
  , always 524288
Line 1262
  fIsComplex always 524288
  = always 524288
  1 always 1
  << always 524288
  19 always 19
  , always 1048576
Line 1263
  fIsEnumType always 1048576
  = always 1048576
  1 always 1
  << always 1048576
  20 always 20
  , always 2097152
Line 1264
  fIsName always 2097152
  = always 2097152
  1 always 1
  << always 2097152
  21 always 21
  , always 4194304
Line 1265
  fIsLiteral always 4194304
  = always 4194304
  1 always 1
  << always 4194304
  22 always 22
  , always 8388608
Line 1266
  fIsTemplateArg always 8388608
  = always 8388608
  1 always 1
  << always 8388608
  23 always 23
  , always 16777216
Line 1267
  fIsAttributeNodiscard always 16777216
  = always 16777216
  1 always 1
  << always 16777216
  24 always 24
  , always 33554432
Line 1268
  fAtAddress always 33554432
  = always 33554432
  1 always 1
  << always 33554432
  25 always 25
  , always 67108864
Line 1269
  fIncompleteVar always 67108864
  = always 67108864
  1 always 1
  << always 67108864
  26 always 26
  , always 134217728
Line 1270
  fConstexpr always 134217728
  = always 134217728
  1 always 1
  << always 134217728
  27 always 27
  , always 268435456
Line 1271
  fExternC always 268435456
  = always 268435456
  1 always 1
  << always 268435456
  28 always 28
  , always 536870912
Line 1272
  fIsSplitVarDeclComma always 536870912
  = always 536870912
  1 always 1
  << always 536870912
  29 always 29
  , always 1073741824
Line 1273
  fIsSplitVarDeclEq always 1073741824
  = always 1073741824
  1 always 1
  << always 1073741824
  30 always 30
  , always 2147483648
Line 1274
  fIsImplicitInt always 2147483648
  = always 2147483648
  1U always 1
  << always 2147483648
  31 always 31
  , always 4294967296
Line 1275
  fIsInline always 4294967296
  = always 4294967296
  1ULL always 1
  << always 4294967296
  32 always 32
  , always 8589934592
Line 1276
  fIsTemplate always 8589934592
  = always 8589934592
  1ULL always 1
  << always 8589934592
  33 always 33
  , always 17179869184
Line 1277
  fIsSimplifedScope always 17179869184
  = always 17179869184
  1ULL always 1
  << always 17179869184
  34 always 34
  , always 34359738368
Line 1278
  fIsRemovedVoidParameter always 34359738368
  = always 34359738368
  1ULL always 1
  << always 34359738368
  35 always 35
  , always 68719476736
Line 1279
  fIsIncompleteConstant always 68719476736
  = always 68719476736
  1ULL always 1
  << always 68719476736
  36 always 36
Line 1284
  mFlags always !<=-1
Line 1293
  ( always {!<=-1,!>=2}
  flag_ always !<=-1
Line 1294
  return always {!<=-1,!>=2}
  mFlags always !<=-1
  & always !<=-1
  flag_ {!<=-1,8388608@56,17179869184@67,8589934592@69,34359738368@71,4294967296@73,2147483648@75,1073741824@77,536870912@79,268435456@81}
  != always {!<=-1,!>=2}
  0 always 0
Line 1302
  flag_ always !<=-1
  state_ always {!<=-1,!>=2}
Line 1303
  mFlags always !<=-1
  = always !<=-1
  state_ {!<=-1,!>=2,symbolic=(mTokType==eName||mTokType==eType||mTokType==eVariable||mTokType==eFunction||mTokType==eKeyword||mTokType==eBoolean||mTokType==eEnumerator)@143,symbolic=(mTokType==eNumber||mTokType==eString||mTokType==eChar||mTokType==eBoolean||mTokType==eLiteral||mTokType==eEnumerator)@144}
  ? always !<=-1
  mFlags always !<=-1
  | always !<=-1
  flag_ {!<=-1,8388608@55,17179869184@66,8589934592@68,34359738368@70,4294967296@72,2147483648@74,1073741824@76,536870912@78,268435456@80}
  : always !<=-1
  mFlags always !<=-1
  & always !<=-1
  ~ always !<=0
  flag_ {!<=-1,8388608@55,17179869184@66,8589934592@68,34359738368@70,4294967296@72,2147483648@74,1073741824@76,536870912@78,268435456@80}
Line 1317
  , always 0
  = always 0
  0 always 0
  , always 0
  = always 0
  0 always 0
Line 1343
  ! always {!<=-1,!>=2}
Line 1344
  nullptr always 0
Line 1345
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1346
  ( always !0
Line 1347
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1348
  ( always !0
Line 1349
  nullptr always 0
Line 1353
  ! always {!<=-1,!>=2}
Line 1354
  nullptr always 0
Line 1355
  this {!0,symbolic=(astParent()->astOperand2())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1356
  ( always !0
Line 1357
  this always {!0,!symbolic=(astParent()->astOperand1())}
  == always {!<=-1,!>=2}
  ( always !0
Line 1358
  ( always !0
Line 1359
  nullptr always 0
Line 1363
  = always !0
  this always !0
Line 1364
  ret possible symbolic=(this)
Line 1365
  = always !0
  . always !0
Line 1366
  ret possible symbolic=(this)
Line 1370
  = always !0
  this always !0
Line 1371
  ret possible symbolic=(this)
Line 1372
  = always !0
  . always !0
Line 1373
  ret possible symbolic=(this)
Line 1385
  ( always {!<=-1,!>=2}
Line 1388
  = always 0
  = always 0
  = always 0
  nullptr always 0
Line 1393
  = always 0
  nullptr always 0
Line 1396
  = always ""
  "" always ""
Line 1402
  sep possible ""
Line 1411
  verbose always {!<=-1,!>=2}
  xml always {!<=-1,!>=2}
Line 1413
  xml always {!<=-1,!>=2}
Line 1418
  cpp11init always {!<=-1,!>=2}
Line 1419
  = possible {1,2}
  cpp11init always {!<=-1,!>=2}
  ? possible {1,2}
  :: always 1
  CPP11INIT always 1
  : always 2
  :: always 2
  NOINIT always 2
Line 58
  ( always {!<=-1,!>=2}
Line 59
  return always {!<=-1,!>=2}
  mIsC always {!<=-1,!>=2}
Line 63
  ( always {!<=-1,!>=2}
Line 64
  return always {!<=-1,!>=2}
  mIsCpp always {!<=-1,!>=2}
Line 73
  , always 0
  split always {!<=-1,!>=2}
  = always 0
  false always 0
Line 90
  , always 1
  one_line always {!<=-1,!>=2}
  = always 1
  true always 1
Line 101
  ( always {!<=-1,!>=2}
Line 103
  && always {!<=-1,!>=2}
Line 156
  ( always !<=-1
Line 175
  ( always {!<=-1,!>=2}
Line 192
  ( always {!<=-1,!>=2}
Line 219
  mIsC always {!<=-1,!>=2}
Line 220
  mIsCpp always {!<=-1,!>=2}
Line 71
  ( always {!<=-1,!>=2}
Line 73
  ( always {!<=-1,!>=2}
Line 75
  return possible lifetime[Iterator]=(mVariableId)
  ( possible lifetime[Iterator]=(mVariableId)
Line 77
  ( always end=0
Line 78
  return possible lifetime[Iterator]=(mVariableId)
  ( {lifetime[Iterator]=(mVariableId),end=0}
Line 84
  & {lifetime[Address]=(mVarId),!0}
Line 99
  ( always {!<=-1,!>=2}
Line 100
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 104
  ( always {!<=-1,!>=2}
Line 105
  return always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 114
  ( always {!<=-1,!>=2}
  , always 0
  = always 0
  nullptr always 0
Line 116
  ( always {!<=-1,!>=2}
Line 117
  && always {!<=-1,!>=2}
Line 119
  ( always {!<=-1,!>=2}
Line 141
  ( always {!<=-1,!>=2}
Line 159
  ( always {!<=-1,!>=2}
Line 167
  ( always {!<=-1,!>=2}
Line 185
  check always {!<=-1,!>=2}
Line 218
  ( always {!<=-1,!>=2}
Line 232
  ( always {!<=-1,!>=2}
Line 292
  ( always {!<=-1,!>=2}
Line 298
  only_k_r_fpar always {!<=-1,!>=2}
Line 299
  , always {!<=-1,!>=2}
  only_k_r_fpar always {!<=-1,!>=2}
Line 314
  ( always {!<=-1,!>=2}
Line 351
  ( always {!<=-1,!>=2}
Line 364
  ( always {!<=-1,!>=2}
Line 380
  , always {!<=-1,!>=2}
  commandWithCondition always {!<=-1,!>=2}
Line 397
  ( always {!<=-1,!>=2}
Line 401
  ( always {!<=-1,!>=2}
Line 420
  ( always {!<=-1,!>=2}
Line 426
  ( always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  floatvar always {!<=-1,!>=2}
Line 432
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  valueIsPointer always {!<=-1,!>=2}
Line 455
  ( always {!<=-1,!>=2}
Line 462
  ( always {!<=-1,!>=2}
Line 480
  ( always {!<=-1,!>=2}
Line 497
  ( always {!<=-1,!>=2}
Line 582
  , always {!<=-1,!>=2}
  cpp always {!<=-1,!>=2}
Line 591
  ( always {!<=-1,!>=2}
Line 640
  , always ""
  = always ""
  "" always ""
Line 680
  ( always {!<=-1,!>=2}
  , always {!<=-1,!>=2}
  allowSemicolon always {!<=-1,!>=2}
Line 786
  ( always {!<=-1,!>=2}
Line 813
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 814
  , always 0
  inconclusive always {!<=-1,!>=2}
  = always 0
  false always 0
Line 816
  ( always {!<=-1,!>=2}
Line 850
  ( always {!<=-1,!>=2}
Line 855
  ( always {!<=-1,!>=2}
Line 856
  return always {!<=-1,!>=2}
  mCodeWithTemplates always {!<=-1,!>=2}
Line 904
  ( always {!<=-1,!>=2}
Line 911
  ( always {!<=-1,!>=2}
Line 918
  ( always {!<=-1,!>=2}
Line 932
  ( always {!<=-1,!>=2}
Line 933
  return always {!<=-1,!>=2}
  false always 0
Line 950
  , always {!<=-1,!>=2}
  inOperator always {!<=-1,!>=2}
Line 986
  used always {!<=-1,!>=2}
Line 1000
  mCodeWithTemplates always {!<=-1,!>=2}
Line 37
  ( always {!<=-1,!>=2}
Line 39
  c possible >=0@18
Line 40
  '_' always 95
Line 41
  '-' always 45
Line 42
  '.' always 46
Line 43
  return always {!<=-1,!>=2}
  true always 1
Line 45
  return always {!<=-1,!>=2}
Line 54
  line possible size=0
Line 55
  "\n" always "\n"
Line 56
  filedata possible size=0
  ( {lifetime[Iterator]=(filedata),size=0,start=0}
  filedata possible size=0
  ( {lifetime[Iterator]=(filedata),size=0,end=0}
  '\r' always 13
  '\n' always 10
Line 59
  filedata possible size=0
Line 60
  line possible {size=0,>=size=2,<=size=1}
Line 62
  line possible {>=size=2,<=size=1}
  ( {!<=-1,!>=2,0}
Line 66
  line {>=size=2,<=size=1,!size=0}
  ( {>=2,<=1,!<=0}
  > {!<=-1,!>=2,>=1,<=0}
  1 always 1
  && always {!<=-1,!>=2}
  line {>=size=2,!size=0,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '#' always 35
Line 68
  line {!size=0,<=size=1}
  ( {<=1,!<=0}
  >= {!<=-1,!>=2,<=0}
  2 always 2
  && always {!<=-1,!>=2}
  line {!size=0,>=size=2,!<=size=1}
  0 always 0
  == always {!<=-1,!>=2}
  '/' always 47
  && always {!<=-1,!>=2}
  line {!size=0,>=size=2,!<=size=1}
  1 always 1
  == always {!<=-1,!>=2}
  '/' always 47
Line 71
  errmsg possible size=0
  line possible <=size=1
Line 72
  ! {!<=-1,!>=2,0}
  errmsg possible size=0
  ( {!<=-1,!>=2,1}
Line 73
  errmsg always !size=0
Line 76
  "" always ""
Line 84
  == always {!<=-1,!>=2}
Line 85
  "File not found" always "File not found"
Line 86
  != always {!<=-1,!>=2}
Line 87
  "Failed to parse XML file" always "Failed to parse XML file"
Line 91
  "suppress" always "suppress"
  != always {!<=-1,!>=2}
  0 always 0
Line 92
  "Invalid suppression xml file format, expected <suppress> element but got a \"" always "Invalid suppression xml file format, expected <suppress> element but got a \""
  '\"' always 34
Line 96
  : always ""
  "" always ""
Line 97
  "id" always "id"
  == always {!<=-1,!>=2}
  0 always 0
Line 99
  "fileName" always "fileName"
  == always {!<=-1,!>=2}
  0 always 0
Line 101
  "lineNumber" always "lineNumber"
  == always {!<=-1,!>=2}
  0 always 0
Line 103
  "symbolName" always "symbolName"
  == always {!<=-1,!>=2}
  0 always 0
Line 105
  && always {!<=-1,!>=2}
  "hash" always "hash"
  == always {!<=-1,!>=2}
  0 always 0
Line 106
  . always !<=-1
  hash always !<=-1
Line 108
  "Unknown suppression element \"" always "Unknown suppression element \""
  "\", expected id/fileName/lineNumber/symbolName/hash" always "\", expected id/fileName/lineNumber/symbolName/hash"
Line 112
  ! {!<=-1,!>=2,0}
  err possible size=0
  ( {!<=-1,!>=2,1}
Line 113
  err always !size=0
Line 116
  "" always ""
Line 124
  start_position always !<=-1
  = always !<=-1
  ( always !<=-1
  "[" always "["
Line 125
  end_position always !<=-1
  = always !<=-1
  ( always !<=-1
  "]" always "]"
  start_position always !<=-1
Line 126
  end_position always !<=-1
  == always {!<=-1,!>=2}
Line 127
  errorMessage possible size=0
  && always {!<=-1,!>=2}
  errorMessage always !0
  ( always {!<=-1,!>=2}
Line 128
  errorMessage {!0,size=0}
  "Bad multi suppression '" always "Bad multi suppression '"
  "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" always "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]"
Line 129
  suppressions always size=0
Line 133
  pos always !<=-1
  = always !<=-1
  start_position always !<=-1
  pos always !<=-1
  < always {!<=-1,!>=2}
  end_position always !<=-1
Line 134
  pos1 always !<=-1
  = always !<=0
  pos always !<=-1
  + always !<=0
  1 always 1
Line 135
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  "," always ","
  pos1 {symbolic=(pos+1),!<=0}
Line 136
  pos2 always !<=-1
  = always {!<=-1,!>=symbolic=(pos+1),!>=symbolic=(end_position+1)}
  pos always !<=-1
  < always {!<=-1,!>=2}
  end_position always !<=-1
  ? always {!<=-1,!>=symbolic=(pos+1),!>=symbolic=(end_position+1)}
  pos {!<=-1,<=symbolic=(end_position-1),!>=symbolic=(end_position)}
  : {!<=-1,<=symbolic=(end_position-1),!>=symbolic=(end_position),!>=symbolic=(pos+1),<=symbolic=(pos)}
  end_position {!<=-1,!>=symbolic=(pos+1),<=symbolic=(pos)}
Line 137
  pos1 always !<=-1
  == always {!<=-1,!>=2}
  pos2 {symbolic=((pos<end_position)?pos:end_position),!<=-1,!>=symbolic=(pos+1),!>=symbolic=(end_position+1)}
Line 141
  pos1 always {!<=-1,!symbolic=(pos2)}
  pos2 {symbolic=((pos<end_position)?pos:end_position),!<=-1,!symbolic=(pos1),!>=symbolic=(pos+1),!>=symbolic=(end_position+1)}
  - always !<=-1
  pos1 always {!<=-1,!symbolic=(pos2)}
Line 144
  ! always {!<=-1,!>=2}
Line 145
  errorMessage possible size=0
  && always {!<=-1,!>=2}
  errorMessage always !0
  ( always {!<=-1,!>=2}
Line 146
  errorMessage {!0,size=0}
  "Bad multi suppression '" always "Bad multi suppression '"
  "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" always "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]"
Line 147
  suppressions always NonMovedVariable
Line 148
  suppressions always {NonMovedVariable,size=0}
Line 154
  ! always {!<=-1,!>=2}
Line 156
  ( always !<=-1
  "+-*/%#;" always "+-*/%#;"
  == always {!<=-1,!>=2}
Line 158
  0 always 0
  11 always 11
  "symbolName=" always "symbolName="
  == always {!<=-1,!>=2}
  0 always 0
Line 159
  11 always 11
Line 161
  errorMessage possible size=0
  && always {!<=-1,!>=2}
  errorMessage always !0
  ( always {!<=-1,!>=2}
Line 162
  errorMessage {!0,size=0}
  "Bad multi suppression '" always "Bad multi suppression '"
  "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]" always "'. legal format is cppcheck-suppress[errorId, errorId symbolName=arr, ...]"
Line 163
  suppressions always NonMovedVariable
Line 164
  suppressions always {NonMovedVariable,size=0}
Line 180
  :: always !<=-1
  endpos always !<=-1
  endpos always !<=-1
  = always !<=-1
  line possible <=size=1@21
  ( always !<=-1
  "#" always "#"
  line possible <=size=1@21
  ( always !<=-1
  "//" always "//"
Line 181
  endpos {symbolic=(std::min(line.find("#"),line.find("//"))),!<=-1}
  != always {!<=-1,!>=2}
Line 182
  endpos {symbolic=(std::min(line.find("#"),line.find("//"))),!<=-1}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  endpos {symbolic=(std::min(line.find("#"),line.find("//"))),>=1,!<=0}
  - {!<=-1,>=0}
  1 always 1
Line 183
  endpos {>=1,!<=0}
  -- {>=1,!<=0}
Line 185
  0 always 0
  endpos {!<=-1,<=0}
Line 190
  ':' always 58
Line 197
  pos always !<=-1
  = always !<=-1
  ( always !<=-1
  ':' always 58
Line 200
  pos always !<=-1
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
Line 201
  ( always !<=-1
  '.' always 46
  pos always {!<=-1,!symbolic=(std::string::npos)}
  == always {!<=-1,!>=2}
  :: always !symbolic=(pos)
Line 204
  pos always !<=-1
  + always !<=0
  1 always 1
Line 207
  = always -1
  :: always -1
  NO_LINE always -1
Line 210
  . possible -1
  != {!<=-1,!>=2,0}
  :: always -1
  NO_LINE always -1
Line 211
  pos always !<=-1
Line 225
  = possible lifetime[Iterator]=(mSuppressions)
  ( possible lifetime[Iterator]=(mSuppressions)
  ( {lifetime[Iterator]=(mSuppressions),start=0}
  ( {lifetime[Iterator]=(mSuppressions),end=0}
Line 226
  ( possible {lifetime[Object]=(isSameParameters),lifetime[Object]=(suppression)}
  & {lifetime[Address]=(isSameParameters),!0}
  & {lifetime[Address]=(suppression),!0}
Line 227
  foundSuppression possible lifetime[Iterator]=(mSuppressions)
  != always {!<=-1,!>=2}
  ( {lifetime[Iterator]=(mSuppressions),end=0}
Line 229
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
Line 230
  foundSuppression {lifetime[Iterator]=(mSuppressions),!symbolic=(mSuppressions.end()),!end=0}
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
  = always 1
  . always 1
  matched always {!<=-1,!>=2}
Line 231
  "" always ""
Line 235
  . possible size=1
  ( {!<=-1,!>=2,0}
  && always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
Line 236
  "Failed to add suppression. No id." always "Failed to add suppression. No id."
Line 238
  != always {!<=-1,!>=2}
  "*" always "*"
Line 239
  pos always !<=-1
  = always 0
  0 always 0
  pos {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
  ++ always !<=0
  pos always !<=-1
Line 240
  pos {!<=-1,<=symbolic=(suppression.errorId.length()-1),!>=symbolic=(suppression.errorId.length()),0}
  < always {!<=-1,!>=2}
  0 always 0
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  [ possible >=0
  pos always {!<=-1,!>=symbolic=(suppression.errorId.length())}
Line 241
  "Failed to add suppression. Invalid id \"" always "Failed to add suppression. Invalid id \""
  "\"" always "\""
Line 243
  pos always !<=-1
  == always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  pos always 0
Line 244
  "Failed to add suppression. Invalid id \"" always "Failed to add suppression. Invalid id \""
  "\"" always "\""
Line 249
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  . possible size=1
Line 250
  "Failed to add suppression. Invalid glob pattern '" always "Failed to add suppression. Invalid glob pattern '"
  "'." always "'."
Line 251
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 252
  "Failed to add suppression. Invalid glob pattern '" always "Failed to add suppression. Invalid glob pattern '"
  "'." always "'."
Line 254
  mSuppressions possible lifetime[Object]=(suppression)
Line 256
  "" always ""
Line 263
  ! {!<=-1,!>=2,0}
  errmsg possible size=0
  ( {!<=-1,!>=2,1}
Line 264
  errmsg always !size=0
Line 266
  "" always ""
Line 274
  ( always {!<=-1,!>=2}
Line 276
  ( always !<=-1
  < always {!<=-1,!>=2}
  2 always 2
Line 277
  return always {!<=-1,!>=2}
  false always 0
Line 279
  comment {!<=size=1,>=size=2}
  ( always !<=-1
  ';' always 59
  != always {!<=-1,!>=2}
Line 280
  comment always !<=size=1
  ( always !<=-1
  ';' always 59
Line 282
  ( always !<=-1
  "//" always "//"
  2 always 2
  != always {!<=-1,!>=2}
Line 283
  ( always !<=-1
  "//" always "//"
  2 always 2
Line 285
  ( always !<=-1
  - always !<=-1
  2 always 2
  2 always 2
  "*/" always "*/"
  == always {!<=-1,!>=2}
  0 always 0
Line 286
  ( always !<=-1
  - always !<=-1
  2 always 2
  2 always 2
Line 288
  2 always 2
Line 291
  != always {!<=-1,!>=2}
  "cppcheck-suppress" always "cppcheck-suppress"
Line 292
  return always {!<=-1,!>=2}
  false always 0
Line 294
  ! always {!<=-1,!>=2}
Line 295
  return always {!<=-1,!>=2}
  false always 0
Line 298
  ! always {!<=-1,!>=2}
Line 300
  ( always !<=-1
  "+-*/%#;" always "+-*/%#;"
  == always {!<=-1,!>=2}
Line 302
  0 always 0
  11 always 11
  "symbolName=" always "symbolName="
  == always {!<=-1,!>=2}
  0 always 0
Line 303
  11 always 11
Line 304
  errorMessage possible size=0
  && always {!<=-1,!>=2}
  errorMessage always !0
  ( always {!<=-1,!>=2}
Line 305
  errorMessage {!0,size=0}
  "Bad suppression attribute '" always "Bad suppression attribute '"
  "'. You can write comments in the comment after a ; or //. Valid suppression attributes; symbolName=sym" always "'. You can write comments in the comment after a ; or //. Valid suppression attributes; symbolName=sym"
Line 307
  return always {!<=-1,!>=2}
  true always 1
Line 310
  ( always {!<=-1,!>=2}
Line 312
  hash {!<=-1,symbolic=(errmsg.hash)}
  > always {!<=-1,!>=2}
  0 always 0
  && always {!<=-1,!>=2}
  hash {>=1,!<=0}
  != always {!<=-1,!>=2}
  . always !<=-1
  hash always !<=-1
Line 313
  return always {!<=-1,!>=2}
  false always 0
Line 314
  ! {!<=-1,!>=2,0}
  errorId possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  errorId always !size=0
Line 315
  return always {!<=-1,!>=2}
  false always 0
Line 316
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  fileName always !size=0
Line 317
  return always {!<=-1,!>=2}
  false always 0
Line 318
  lineNumber possible symbolic=(errmsg.lineNumber)
  != always {!<=-1,!>=2}
  NO_LINE always -1
  && always {!<=-1,!>=2}
  lineNumber always !-1
  != always {!<=-1,!>=2}
Line 319
  ! always {!<=-1,!>=2}
  thisAndNextLine always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  lineNumber always {!symbolic=(errmsg.lineNumber),!-1}
  + always !0
  1 always 1
  != always {!<=-1,!>=2}
  . always !symbolic=(lineNumber)
Line 320
  return always {!<=-1,!>=2}
  false always 0
Line 322
  ! {!<=-1,!>=2,0}
  symbolName possible size=0
  ( {!<=-1,!>=2,1}
Line 323
  pos always !<=-1
  = always 0
  0 always 0
  pos {!<=-1,0}
  < always {!<=-1,!>=2}
  ( always !<=-1
Line 324
  pos2 always !<=-1
  = always !<=-1
  ( always !<=-1
  '\n' always 10
  pos {!<=-1,0}
Line 326
  pos2 always !<=-1
  == always {!<=-1,!>=2}
Line 327
  pos always !<=-1
Line 328
  pos always !<=-1
  = always !<=-1
  pos2 always !<=-1
Line 330
  pos always !<=-1
  pos2 always !<=-1
  - always !<=-1
  pos always !<=-1
Line 331
  pos always !<=-1
  = always !<=0
  pos2 always !<=-1
  + always !<=0
  1 always 1
Line 333
  ( always {!<=-1,!>=2}
  symbolName always !size=0
Line 334
  return always {!<=-1,!>=2}
  true always 1
Line 336
  return always {!<=-1,!>=2}
  false always 0
Line 338
  return always {!<=-1,!>=2}
  true always 1
Line 341
  ( always {!<=-1,!>=2}
Line 343
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 344
  return always {!<=-1,!>=2}
  false always 0
Line 345
  matched always {!<=-1,!>=2}
  = always 1
  true always 1
Line 346
  checked always {!<=-1,!>=2}
  = always 1
  true always 1
Line 347
  return always {!<=-1,!>=2}
  true always 1
Line 353
  ! {!<=-1,!>=2,0}
  errorId possible size=0
  ( {!<=-1,!>=2,1}
Line 354
  = always !size=0
  errorId always !size=0
Line 355
  ! {!<=-1,!>=2,0}
  fileName possible size=0
  ( {!<=-1,!>=2,1}
Line 356
  " fileName=" always " fileName="
  fileName always !size=0
Line 357
  != always {!<=-1,!>=2}
  NO_LINE always -1
Line 358
  " lineNumber=" always " lineNumber="
  lineNumber always !-1
Line 359
  ! {!<=-1,!>=2,0}
  symbolName possible size=0
  ( {!<=-1,!>=2,1}
Line 360
  " symbolName=" always " symbolName="
  symbolName always !size=0
Line 361
  hash always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 362
  " hash=" always " hash="
  hash {>=1,!<=0}
Line 363
  0 always 0
  1 always 1
  " " always " "
  == always {!<=-1,!>=2}
  0 always 0
Line 364
  1 always 1
Line 368
  ( always {!<=-1,!>=2}
Line 370
  unmatchedSuppression {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  "unmatchedSuppression" always "unmatchedSuppression"
Line 372
  unmatchedSuppression always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 374
  ( always {!<=-1,!>=2}
Line 375
  return always {!<=-1,!>=2}
  true always 1
Line 377
  return always {!<=-1,!>=2}
  false always 0
Line 380
  ( always {!<=-1,!>=2}
Line 382
  unmatchedSuppression {!<=-1,!>=2,0}
  == always {!<=-1,!>=2}
  "unmatchedSuppression" always "unmatchedSuppression"
Line 384
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
Line 386
  unmatchedSuppression always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 388
  ( always {!<=-1,!>=2}
Line 389
  return always {!<=-1,!>=2}
  true always 1
Line 391
  return always {!<=-1,!>=2}
  false always 0
Line 396
  "  <suppressions>" always "  <suppressions>"
Line 398
  "    <suppression" always "    <suppression"
Line 399
  " errorId=\"" always " errorId=\""
  '"' always 34
Line 400
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 401
  " fileName=\"" always " fileName=\""
  . always !size=0
  '"' always 34
Line 402
  != always {!<=-1,!>=2}
Line 403
  " lineNumber=\"" always " lineNumber=\""
  '"' always 34
Line 404
  ! {!<=-1,!>=2,0}
  . possible size=0
  ( {!<=-1,!>=2,1}
Line 405
  " symbolName=\"" always " symbolName=\""
  . always !size=0
  '\"' always 34
Line 406
  . always !<=-1
  hash always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 407
  " hash=\"" always " hash=\""
  . {>=1,!<=0}
  hash always !<=-1
  '\"' always 34
Line 408
  " />" always " />"
Line 410
  "  </suppressions>" always "  </suppressions>"
Line 413
  unusedFunctionChecking always {!<=-1,!>=2}
Line 418
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 420
  . always !<=-1
  hash always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 422
  ! always {!<=-1,!>=2}
  unusedFunctionChecking always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "unusedFunction" always "unusedFunction"
Line 424
  tmpFile possible symbolic=(s.fileName)
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  ( always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  tmpFile always !size=0
Line 431
  unusedFunctionChecking always {!<=-1,!>=2}
Line 435
  . always {!<=-1,!>=2}
  matched always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
Line 437
  . always !<=-1
  hash always !<=-1
  > always {!<=-1,!>=2}
  0 always 0
Line 439
  ! always {!<=-1,!>=2}
  unusedFunctionChecking always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  "unusedFunction" always "unusedFunction"
Line 441
  ( always {!<=-1,!>=2}
Line 454
  = always -1
  -1 always -1
Line 455
  = always -1
  -1 always -1
Line 457
  != always {!<=-1,!>=2}
  || always {!<=-1,!>=2}
  != always {!<=-1,!>=2}
Line 461
  ! always {!<=-1,!>=2}
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
  currLineNr always symbolic=(tok->linenr())
  && always {!<=-1,!>=2}
  == always {!<=-1,!>=2}
Line 462
  . always {!<=-1,!>=2}
  checked always {!<=-1,!>=2}
  = always 1
  true always 1
